[{"title":"绘隙碎笔","url":"/posts/29865.html","content":"​\t才三月份，石家庄就依旧进入繁盛的春天了啊。。。。在我的家乡长久生活的人，不知道会不会感叹这岁月的笔触实在是太快了。​\t又是一节我习惯绘画的课堂，坐在最靠窗户的一排，三月份已然有些许热气，拿出本来，感觉都温暖了许多。​\t我常于这光影交错处徘徊，看日光一寸寸移动，感觉把我生命的长度都不经意的丈量了。​\t所以我把这梦境画下，我又回到那个熟悉的楼里了，那个我可能再也不会有机会回去的，却满含怀念的建筑里。​\t她靠着下午五点半的夕阳，在梦里和我相遇吗。其实不然，在梦里只有楼和我，我却无法把自己画下，只能把祈莉作为我思索的对象，让她替我在一步一步的忧郁。  \n\n\n&#123;% asset_img ShenBangQili.jpg example %&#125;\t\n\n​\t本人懈怠，绘画的热度感觉一日不如一日，也许我是想画吧，可是我用时间在绘画上的刻痕实在是太浅，被琐事纠缠的我，大概是无暇提笔哩。。。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-2025.3.27 中午\n","categories":["杂谈","绘画相关"],"tags":["绘画相关","杂谈"]},{"title":"2025第十六届蓝桥杯Java省B题目加部分题解","url":"/posts/20522.html","content":"由于河北北京这边省赛那两天风很大的原因，所以导致蓝桥杯没有如期进行，所以说来做做已经考完了的人的比赛题目\n\nA. 逃离高塔\n\n首先如果不考虑溢出处理，用BigInteger估计一是比较慢二是方法写起来比较麻烦，所以还是取模取出个位数处理，因为只看个位数，所以取模不会对结果产生影响\npublic class A &#123;\tpublic static void main(String[] args) &#123;\t\tint res = 0;\t\tfor(int i = 1; i &lt;= 2025; i++) &#123;\t\t\t// 结果只取个位数，在每次乘方过程中都取模取出个位数，防止溢出\t\t\tint temp = (int) (((Math.pow(i, 2) % 10) * i) % 10);\t\t\tif(temp == 3) res++;\t\t&#125;\t\tSystem.out.print(res);\t\t// 202\t&#125;&#125;\n\n\n\nB. 消失的蓝宝\n\n大模拟题，首先 N 肯定是从 20250413开始遍历，但是直接遍历肯定要慢很多\n可以先打表发现，20260411 是第一个满足条件2 的数\n// 打表代码public class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor(long n = 20250413; n &lt; Long.MAX_VALUE; n++) &#123;\t\t\tif((n + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t\tif((n + 20240413) % 20250412 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);\t\t// 20260411\t&#125;&#125;\n\n所以从 20260411 开始，每次加 20250412 确保满足条件2，然后判断条件1\npublic class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor (long N = 20260411; N &lt; Long.MAX_VALUE; N += 20250412) &#123;\t\t\tif ((N + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = N;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);    // 409876661809331\t&#125;&#125;\n\n\n\nC. 电池分组\n\n\n\n两组电池异或和相等，异或 相同为 0，不同为1，那么相等的数异或和为 0，要求能分成两组， 那么就是意思组内所有数异或后为 0\npublic class C &#123;\tpublic static void main(String[] args) &#123;\t\tScanner sc = new Scanner(System.in);\t\tint T = sc.nextInt();\t\tfor(int i = 1; i &lt;= T; i++) &#123;\t\t\tint sum = 0;\t\t\tint N = sc.nextInt(); // 本组电池的数量\t\t\tfor (int j = 1; j &lt;= N; j++) &#123;\t\t\t\tint element = sc.nextInt();\t\t\t\tsum = sum ^ element;\t\t\t&#125;\t\t\tif(sum == 0) &#123;\t\t\t\tSystem.out.println(&quot;YES&quot;);\t\t\t&#125;else &#123;\t\t\t\tSystem.out.println(&quot;NO&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n\n\nD. 魔法科考试\n\n\n\n朴素模拟发现只能过2&#x2F; 5的数据，那么该如何优化呢\nclass Solutions1&#123;\t// 质数筛\tboolean check(int p) &#123;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) return false;\t\t&#125;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\n\n首先，看到时间限制就知道这题不简单。 我们在这里要注意以下几个点\n\n素数判定只需要判定这个数的算术平方根及以下的数是不是这个数的因数，这样更节省时间。\n对于已经判定过的数，不需要判断，所以可以打质数筛\nif 判断是有顺序的（从左往右判断）所以素数判定放在最后，当前面不符时，会直接退出就不会再素数判定，节省时间。\n\n// AC代码import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.util.StringTokenizer;import java.util.*;public class Main &#123;\tpublic static void main(String[] args) &#123;\t\tnew Solutions1();\t&#125;&#125;class Solutions1&#123;\tint[] dx = new int[40004];\t// 质数筛\tboolean check(int p) &#123;\t\t// 已经判定过，就无须再判定\t\tif(dx[p] == 1) return false;\t\tif(dx[p] == 2) return true;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) &#123;\t\t\t\tdx[p] = 1;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t\tdx[p] = 2;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\t\t\tclass FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;/*3 42 3 103 4 5 1 */\n\n\n\nE.  爆破\n\n\n\n题目大意：使用尽可能的小距离使 n 个圆连在一起。\n最小生成树，圆和圆的距离可以用圆心距离减半径，用 prim 写吧，算法讲解都在注释里详细写下了\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    private int n;    private class cirlce implements Comparable&lt;cirlce&gt; &#123;        int x, y, r;        public cirlce() &#123;        &#125;        public cirlce(int x, int y, int r) &#123;            this.x = x;            this.y = y;            this.r = r;        &#125;        @Override        public int compareTo(cirlce o) &#123;            return this.x - o.x;        &#125;    &#125;    private cirlce[] cirlces = new cirlce[5005];    private double Getdist(int u, int v) &#123;        return Math.sqrt((cirlces[u].x - cirlces[v].x) * (cirlces[u].x - cirlces[v].x) + (cirlces[u].y - cirlces[v].y) * (cirlces[u].y - cirlces[v].y));    &#125;    private double prim() &#123;        boolean[] visited = new boolean[n];  // 用于标记每个顶点是否已经被加入到最小生成树中        double[] dist = new double[n];   // 距离数组        // 初始化        Arrays.fill(visited, false);        Arrays.fill(dist, Double.MAX_VALUE);         // 选择0号为起点，并且设为距离0        dist[0] = 0.0;        double sum = 0.0;    // 最小生成树的边总权重\t    // 每次选择一个顶点加入到最小生成树中        for (int i = 0; i &lt; n; i++) &#123;            int u = -1;            double minDist = Double.MAX_VALUE;   // 最小距离指针            // 找到距离最小生成树最近且未被访问的顶点            for (int j = 0; j &lt; n; j++) &#123;                if(!visited[j] &amp;&amp; dist[j] &lt; minDist)&#123;                    minDist = dist[j];                    u = j;                &#125;            &#125;            // 没有点可以移出去了，说明全部加入            if(u == -1)&#123;                break;            &#125;            visited[u] = true;            sum += minDist;\t\t   // 遍历所有未被访问的顶点，更新它们到最小生成树的距离            for(int v = 0; v &lt; n; v++)&#123;                if(!visited[v])&#123;                    double w;                    double spcr = Getdist(u, v);                    // 圆心之间距离小于等于半径之和，相交相切                    if(spcr &lt;= cirlces[u].r + cirlces[v].r)&#123;                        w = 0.0;   // 不需要搭桥                    &#125;else&#123;                        w = spcr - (cirlces[u].r + cirlces[v].r);                    &#125;                    // 松弛操作                    if(w &lt; dist[v])&#123;                        dist[v] = w;                    &#125;                &#125;            &#125;        &#125;        return sum;    &#125;    public Solutions() &#123;        FastReader sc = new FastReader();        n = sc.nextInt();        for (int i = 0; i &lt; n; i++) &#123;            cirlces[i] = new cirlce(sc.nextInt(), sc.nextInt(), sc.nextInt());        &#125;        double sum = prim();        System.out.printf(&quot;%.2f&quot;, sum);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n\n\nF. 数组翻转\n\n\n\n贪心，可以发现，答案只跟数组中每个数连续出现的次数有关，如果有两段一样且连续的数但是被分隔开了，那么肯定存在一种翻转方法翻转到答案的数值，所以答案就是统计这两段然后一乘\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    public Solutions() &#123;        FastReader in = new FastReader();        int n = in.nextInt();        int[] a = new int[n];        for (int a_i = 0; a_i &lt; n; a_i++) &#123;            a[a_i] = in.nextInt();        &#125;        // 桶，记录最大的两个连续值        int[][] backet = new int[1000086][2];        for(int i = 0; i &lt; n; i++)&#123;            int cp = 0;   // 出现次数            cp++;            // 发现了两个连续的相等的数            while(i &lt; n - 1 &amp;&amp; a[i] == a[i + 1])&#123;                cp++;                i++;   // 指针跳过相同的数            &#125;            // 第一段出现的更长            if(cp &gt; backet[a[i]][0])&#123;                backet[a[i]][1] = backet[a[i]][0];                backet[a[i]][0] = cp;            // 第二段出现的更长            &#125;else if(cp &gt; backet[a[i]][1])&#123;                backet[a[i]][1] = cp;            &#125;        &#125;        long res = 0;        for(int i = 0; i &lt; 1000003; i++)&#123;            // ai * 总段长 （backet[i][1] + backet[i][0]）            long temp = (long) i * (backet[i][1] + backet[i][0]);            if(temp &gt; res)&#123;                res = temp;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\nG. 2的幂\n\n\n\n\n数组中所有元素的乘积是 2 的 k 次方倍数。\n\n要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。\n\n如果数组中所有元素的 2 的幂次之和大于k，已经符合了，输出0\n如果初始的 2 的幂次之和小于 k，则需要通过重新选择或增加数组中的某些元素，来使总的 2 的幂次之和达到 k。\n考虑dp\n\n使用一个 DP 数组 dp，其中 dp[j] 表示在增加的 2 的幂次之和为 j 时，所需的最小增加的数的总和。\n遍历数组中的每个数 num，计算其在加上某个正整数后，新数能被 2 的 q 次方整除的最小增量cost，并且能够获得的 2 的幂次增量 gain。\n更新 DP 数组，即通过考虑当前数的所有可能增加的选项来更新之前的 DP 状态。\n如果 dp[re]（其中 re 是需要补充的 2 的幂次）仍然是无穷大，说明无法达到目标，输出 -1\n\npackage 动态规划.subject.线性dp.P12160_蓝桥杯2025省JavaB_2的幂;import scala.reflect.internal.util.OwnerOnlyChmod;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions&#123;    // 计算一个数是 2 的几次幂    private int countTwos(int num) &#123;        int count = 0;        while(num % 2 == 0 &amp;&amp; num &gt; 0)&#123;            count++;            num /= 2;        &#125;        return count;    &#125;    public Solutions()&#123;        FastReader fs = new FastReader();        int n = fs.nextInt();        int k = fs.nextInt();    // 目标 2 的幂次        int[] a = new int[n + 1];        for (int i = 1; i &lt;= n; i++) a[i] = fs.nextInt();        // 初始状态 2 的幂次和        int total = 0;        for(int num: a)&#123;            total += countTwos(num);        &#125;        if(total &gt;= k)&#123;            System.out.println(0);            return;        &#125;        // 需要新增的2的幂次        int rp = k - total;  // 差2的rp次幂        int[] dp = new int[rp + 1];        Arrays.fill(dp, Integer.MAX_VALUE);        dp[0] = 0;   // 初始化dp[0]为0，意思是1为初态，不加        // 处理每个数        // 数组中所有元素的乘积是 2 的 k 次方倍数。        // 要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。        for (int i = 0; i &lt; n; i++) &#123;            int num = a[i];            int p = countTwos(num);    // 该数为2的几次幂            // 临时 DP 数组，避免同一组重复选择            int[] tempDp = dp.clone();            // 生成增量选项，开到30差不多            for (int q = p + 1; q &lt;= 30; q++) &#123;                long mp = (long)Math.pow(2, q);    // 2^q                if(mp &gt; 100000) break;   // 注意最大值限制                // 不小于 num 且是 2^q 倍数的最小数 sp                long sp = ((long)num + mp - 1) / mp * mp;                // 新数能被 2 的 q 次方整除的最小增量cost 和 能够获得的 2 的幂次增量 gain。                int cost = (int)(sp - num);                int gain = countTwos((int)sp) - p;                if (gain &lt;= 0) continue;                // 更新dp                for(int j = rp; j &gt;= gain; j--)&#123;                    // dp[j - gain] 不是无穷大，存在一种方式可以到达 j - gain 的 2 的幂次增量                    if(dp[j - gain] != Integer.MAX_VALUE)&#123;                        tempDp[j] = Math.min(tempDp[j], dp[j - gain] + cost);                    &#125;                &#125;            &#125;        &#125;        System.out.println(dp[rp] == Integer.MAX_VALUE? -1 : dp[rp]);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n\n\nH. 研发资源分配\n\n\n\n可以发现，题目思路类似于田忌赛马，贪心考虑，用下等马换掉对方的上等马\n例如题解 1 3 2 用 2 1 3，就是用 最下等的 1 抵掉了 最上等的 3\n而且由于是全排列，所以剩下的所有位置一定可以排出都比对方大的排列。\n// 我是真不知道为什么洛谷一直给我一个 WA 我也不知道哪里错了）public class Main &#123;    public static void main(String[] args) &#123;        new Solutions2();    &#125;&#125;// 1 2 3    2 3 1  1+2-3=0// 1 4 3 2   2 1 4 3  1-2+3+4=6// 1 3 2 4   2 4 3 1  1+2+3-4=2// 2 3 1 5 4   3 4 2 1 5   1+2+3-4+5// 经过了几个案例的打表，我们发现，总是存在这样一种排列，会使得资源份额的差值最大// 那么就是 对面最多只能拿到一天的分数，而且拿到的只能是等级最高的那天class Solutions2&#123;    public Solutions2()&#123;        FastReader sc = new FastReader();        int n = sc.nextInt();        int[] b = new int[n + 1];        for (int i = 1; i &lt;= n; i++) b[i] = sc.nextInt();        if (n == 1) &#123;            System.out.println(0);            return;        &#125;        long res = 0;        for (int i = 1; i &lt;= n; i++) &#123;            // 对面出动了最大的等级，我们使用最下等的去换取，这天的不要            if(b[i] == n)&#123;                res -= i;            &#125;else&#123;                // 别的情况我们都能凑出一种排列比他大，因为我们用最小的把他最大的给抵出去了                res += i;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"Hexo根目录下的_config.yml配置文件","url":"/posts/63024.html","content":"我们在使用hexo初始化一个项目的时候，在根目录下会有一个配置文件_config.yml，这个文件配置了所写博客里面的内容，我们从根目录的该文件来说明每个配置的作用\n头注释_config.yml文件在头部会有一些注释，Hexo Configuration下的两行表示hexo文档的相关文档，Docs指的是hexo的文档，Source指的是hexo的GitHub源码，方便供他人参考查阅\n# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/\n\n\n\n博客网站相关Site下面是网站相关的一些信息配置\n# Sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doelanguage: entimezone: &#x27;&#x27;\n\ntitle：网站的名字，会写在hexo generator命令生成后的public文件夹下的index.html文件的title标签里，作为你个人博客网站的标题，我们也可以在主题的首页左下角找到\nsubtitle：网站的副标题，生成的时候默认为空，一般会出现在你主标题的下面，也就是大约在背景图中间\ndescription：主要用于SEO，告诉搜索引擎一个关于站点的简单描述，在官方文档中建议在这段描述中增加自己的一些关键词\nkeywords：网站的关键词，使用半角逗号分隔开多个关键词，对SEO的优化有一定的作用\nauthor：顾名思义就是作者，这个也只是署个名而已，不会显式的看到\nlanguage：这里就写了网站使用的语言\ntimezone：网站对应的时区，一般情况下不用去刻意配置，会默认使用电脑的时区，但如果发布到其他地方的服务器，可能会使用当地服务器的时区，一般中国的时区可以设置为Asia&#x2F;Shanghai或者北京\n博客网址相关# URL## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;url: http://example.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # 设置为false时会将末尾的index.html去掉  trailing_html: true # 设置为false时会将末尾的.html去掉，对index.html无效\n\nurl：指定博客的完整域名或 URL 地址。当你将博客部署到互联网上时，访问者需要通过这个地址来访问你的博客，要确保 url 地址准确无误，不然可能会导致博客内的链接（如文章内的图片链接、页面跳转链接等）无法正常访问\nroot：网站的根目录，指定博客在域名下的根目录，如果你的博客是直接部署在域名的根目录下，就将 root 设置为 /；若博客部署在域名的子目录下，比如部署在 http://example.com/blog 下，那么就需要把 root 设置为 /blog/。正确设置 root 很重要，不然会影响博客内资源（如 CSS、JavaScript 文件等）的加载路径。\npermalink：文章的永久链接格式，一般是格式化日期字符串，可以在permalink这里配置，如默认中的配置，在hello world文章中就会是这样的url\n\n当使用Font-matter中的值配置的时候（文章格式标签），可选的值有\n\n\n\n**permalink_defaults:**设置永久链接的默认值。当你在文章的 Front - Matter（文章开头的元数据部分）中没有对某些永久链接相关的变量进行设置时，就会使用这里定义的默认值。不过在示例中，没有具体设置默认值，所以会采用 Hexo 的默认配置。\n**pretty_urls:**就是如注释那样\n目录相关# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:\n\nsource_dir：存放hexo文章的文件夹，我们写的md文件都放在这个配置对应的文件夹下，默认值是source\npublic_dir：存放hexo g生成的文件，执行hexo g后根目录就会出现这个文件夹，默认值是public\ntag_dir：按标签存放文章的目录，默认值是tags，如果我们给文章添加标签，使用hexo g时public文件夹下就会多出一个tags文件夹（根据我们的配置文件夹名不同）\narchive_dir：归档文件夹，存放归档文件，默认值为archives\ncategory_dir：分类文件夹，按分类存放的文件，和上面的tags一样，只要在文章中的Font-matter添加了categories就会在使用hexo g构造时出现相应的文件夹\ncode_dir：Include code 文件夹，source_dir 下的子目录，默认值为downloads&#x2F;code\ni18n_dir：国际化（i18n）文件夹，默认值:lang\nskip_render：跳过指定文件的渲染，匹配到的文件将会被不做改动复制到public文件夹下，如果路径对应的是我们的文章，那会直接忽略掉该文章，我们这样设置来忽略掉hello-world.md文件\nskip_render: &quot;_posts/hello-world.md&quot;\n\n​\t\t然后hexo g之后可见生成的文件夹只有一些基础的内容，没有和hello-world.md相关的东西\n文章相关# Writingnew_post_name: :title.md default_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: false\n\nnew_post_name：新文章的默认名称，我们是使用hexo new来构造文章的，生成的文章名就是通过这里配置的，默认为:title.md，也就是标题.md\ndefault_layout：预设布局，指定你新建文章的布局，布局决定了文章在渲染时使用的模板，hexo new可以创建三种文件，post&#x2F;帖子，draft&#x2F;草稿，page&#x2F;页面，这里设置默认值在使用hexo new就可以直接创建对应默认类型的文章，设置了post就等同于说在命令行执行hexo new 和执行hexo new post 是一样的，也可以设置为draft和page\ntitlecase：控制是否将文章标题转换为标题大小写格式。当设置为 true 时，文章标题会被转换为标题大小写（即每个单词的首字母大写）；设置为 false 则不进行转换，保持标题的原始大小写。\nexternal_link：\n\nenable：控制是否在新标签页中打开外部链接。设置为 true 时，文章中的外部链接会在新标签页中打开；设置为 false 则会在当前页面打开。\nfield：指定外部链接设置的应用范围。site 表示该设置应用于整个网站。\nexclude：指定不应用此外部链接设置的域名或路径。这里为空字符串，表示没有排除的域名或路径。\n\nfilename_case：控制文件名的大小写规则。取值为 0 时，文件名保持原始大小写；取值为 1 时，文件名转换为小写；取值为 2 时，文件名转换为大写。\nrender_drafts：控制是否渲染草稿文章。草稿文章通常存放在 source/_drafts 目录下。设置为 true 时，草稿文章会被渲染并显示在网站上；设置为 false 则不会渲染草稿文章。\npost_asset_folder：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在source文件夹下建立一个统一的images文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，就可以设置为true，控制为每篇文章创建一个同名的资源文件夹。当设置为 true 时，使用 hexo new 命令创建文章时，会同时创建一个与文章同名的文件夹，用于存放该文章相关的图片、附件等资源；设置为 false 则不会创建。\nrelative_link: 控制是否使用相对链接。设置为 true 时，文章中的链接会使用相对路径；设置为 false 则使用绝对路径。\nfuture：控制是否发布未来日期的文章。设置为 true 时，即使文章的发布日期设置为未来的某个时间，也会正常发布；设置为 false 则不会发布未来日期的文章。\nhighlight：代码高亮的显示\n\nenable：控制是否启用代码高亮功能。设置为 true 时，文章中的代码块会进行高亮显示；设置为 false 则不进行高亮。\nline_number：控制是否显示代码块的行号。设置为 true 时，代码块会显示行号；设置为 false 则不显示。\nauto_detect：控制是否自动检测代码块的语言。设置为 true 时，Hexo 会尝试自动检测代码块的语言；设置为 false 则需要在代码块中手动指定语言\ntable_replace：用n个空格来代表tab键，如果值为空，则不会代替tab键，这里为空字符串，表示不进行替换。\nwarp：是否将代码放在table标签里，默认为true\nhljs：控制是否使用 highlight.js 进行代码高亮。设置为 true 时，使用 highlight.js 进行高亮；设置为 false 则使用 Hexo 内置的高亮方式。\n\n主页设置index_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date\n\nindex_generator：主页相关的设置\n\npath：主页对应的路径，默认为’’，即域名根目录就是主页的路径\nper_page：每页显示的帖子数，默认为10\norder_by：帖子的排序，默认为-date，即按日期倒序排\n\n分类和标签# Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名\n\ndefault_category：当你创建新文章时，如果没有在文章的 Front - Matter（即文章开头的元数据部分）中明确指定文章的分类，那么这篇文章就会被自动归类到 default_category 所指定的分类中。在这个例子里，默认分类是 uncategorized，也就是 “未分类”。\ncategory_map：category_map 用于设置分类的别名。在实际写文章和管理博客的过程中，你可能会使用一个比较简洁或者容易输入的分类名，但在博客的展示页面上，你希望使用更正式、美观或者表意更清晰的名称。这时就可以通过 category_map 来实现分类名的映射。\n例如：\ncategory_map:  tech: 技术分享  life: 生活随笔\n\n当你在文章的 Front - Matter 中使用 categories: [tech] 时，在博客的分类页面显示的分类名称将会是 “技术分享”，而不是 tech。\ntag_map：tag_map 的作用与 category_map 类似，不过它是用于设置标签的别名。在写文章时，你可能会使用一些简单的标签名，但在博客展示时，希望使用更合适的名称，就可以通过 tag_map 来进行映射。\n元数据元素# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true\n\n是否在页面开头插入下面的meta标签，默认为true\n\n日期和时间# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#x27;s date for updated date unless set in front-matteruse_date_for_updated: false\n\ndate_format：日期格式，默认为YYYY-MM-DD，即年月日\ntime_format：时间格式，默认为HH:mm:ss，即时分秒\nuse_date_for_updated：启用以后，如果 Front Matter 中没有指定 updated（文件更新日期），post.updated 将会使用 date 的值而不是文件的创建时间，默认值为true\n分页# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page\n\nper_page：分页时每页的文章数，如果为0则不分页，默认为10\npagination_dir分页的目录，默认为page，对应于public文件夹下的archives文件夹下的page文件夹，如果只有一页是不会生成这个文件夹的\n包括或不包括目录和文件# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:\n\ninclude：Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude：Hexo 会忽略这些文件和目录\nignore：忽略的文件,要注意的是，这里要写入的是数组，而yaml的数组要用-值表示数组中一个元素或者直接采用js中数组的写法[]\n主题# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 当前使用的主题名\n\n\n\n部署# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#x27;&#x27;\n\nhexo提供了快速方便的一键部署功能hexo deploy，但我们至少需要在_config.yml文件中的deploy中至少配置一个type，比如\ndeploy:  type: git\n\ndeploy:  type: git  repo: &lt;repository url&gt; # 库地址  branch: [branch] # 分支名称  message: [message] # 自定义提交信息\n\n\n\n\n\n\n\n参考内容：部分内容转载自https://blog.csdn.net/zemprogram/article/details/104288872\n hexo官方中文文档\n hexo官方英文文档（有些中文文档没有的英文文档的才有）\n hexo fromt-matter\n hexo 部署\n","categories":["实用","介绍说明"],"tags":["网站技术","Hexo相关","实用知识"]},{"title":"JavaWeb-http","url":"/posts/31243.html","content":"HTTP请求客户端–&gt;请求–&gt;服务器\n\n超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\n\nHTTP是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。\n\n\n以请求百度为例\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\nAccept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9  语言Cache-Control: max-age=0Connection: keep-alive\n\n1.请求行请求行中的请求方式：GET\n\n\n\nGET请求方式\n请求方式：\n\n\n\n2.消息头\n\n\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接\n\n\n\nHTTP响应服务器–&gt;响应–&gt;客户端\n例子\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\n\n响应体Accept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的    sendRedirect方法，该方法同时设置状态代码为302。Set-Cookie:设置和页面关联的Cookie。\n\n响应状态码常见状态码200：请求响应成功\n301：请求重定向\n\n请求重定向(Redirect)：通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。\n\n404: 找不到资源\n500：服务器代码错误\nHTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n\n\n\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaEE","Web","JavaWeb"]},{"title":"Java之动态代理","url":"/posts/60449.html","content":"设计模式–代理模式代理模式是常用的java设计模式，它允许你通过创建一个代理对象来控制对另一个对象（即目标对象）的访问，代理类与委托类有同样的接口。\n代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。\n代理对象充当了目标对象的接口，客户端通过代理对象与目标对象进行交互，而不是直接访问目标对象。\n代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。\n在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。代理模式可以在不改变目标对象代码的前提下，对目标对象的功能进行增强或扩展。\n\n\n可以发现，其中有\n\n代理对象\n\n被代理的行为\n\n被代理的对象\n\n行为的完全控制\n\n\n静态代理静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。\n简单实现首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。\n/** * 创建Person接口 * @author Gonjan */public interface Person &#123;    //上交班费    void giveMoney();&#125;\n\nStudent类实现Person接口。Student可以具体实施上交班费的动作。\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\n\nStudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为\n// 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为public class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        stu.giveMoney();    &#125;&#125;\n测试主类\npublic class StaticProxyTest &#123;    public static void main(String[] args) &#123;        //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成        Person zhangsan = new Student(&quot;张三&quot;);                //生成代理对象，并将张三传给代理对象        Person monitor = new StudentsProxy(zhangsan);                //班长代理上交班费        monitor.giveMoney();    &#125;&#125;\n\n这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。\n代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。\n代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。\n这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以很方便的加上一些其他用途\npublic class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        System.out.println(&quot;张三最近学习有进步！&quot;);  // 代理类顺便告诉张三最近学习有进步        stu.giveMoney();    &#125;&#125;\n\n可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。\n动态代理介绍代理类在程序运行时创建的代理方式被成为动态代理。  \n我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。\n然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。\n相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法：\npublic void giveMoney() &#123;      //调用被代理方法前加入处理方法      beforeMethod();      stu.giveMoney();  &#125;\n\n这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。\n简单实现在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。\n相关方法：\n创建一个InvocationHandler对象\n//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);\n\nInvocationHandler接口定义了一个invoke方法，当通过代理对象调用目标方法时，invoke 方法会被调用。invoke 方法接收三个参数：代理对象、被调用的方法对象以及方法的参数数组。在 invoke 方法中，我们可以编写额外的逻辑，然后调用目标方法并返回结果。\n例如\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler接口 &#123;  // 实现InvocationHandler接口    private Object target;    public MyInvocationHandler(Object target) &#123;        // 存储目标对象。这个目标对象就是我们要为其添加额外功能的对象。        this.target = target;    &#125;    // 需要重写invoke方法    @Override    // Object proxy：代理对象本身   Method method：被调用的目标方法对象   Object[] args：调用目标方法时传递的参数数组    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        // 调用目标方法前的逻辑，例如记录日志        System.out.println(&quot;Before method invocation: &quot; + method.getName());        // 调用目标方法        Object result = method.invoke(target, args);   // 代理target对象实际方法        // 调用目标方法后的逻辑，例如记录日志        System.out.println(&quot;After method invocation: &quot; + method.getName());        return result;    &#125;&#125;\n\n\n\n使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass \nClass&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;);\n\n该类提供了静态方法用于创建动态代理类和代理对象。\n其中，newProxyInstance 方法是创建代理对象的关键方法，它接收三个参数：类加载器、目标对象实现的接口数组以及 InvocationHandler 实例。\n例如\nimport java.lang.reflect.Proxy;// 为传入的目标对象创建一个动态代理对象。public class ProxyFactory &#123;    public static Object createProxy(Object target) &#123;        return Proxy.newProxyInstance(                target.getClass().getClassLoader(),     // 类加载器// 动态代理只能为实现了接口的类创建代理对象，因此需要指定目标对象实现的接口，这样代理对象才能实现相同的接口。                target.getClass().getInterfaces(),   // 获取目标对象所实现的所有接口的数组                new MyInvocationHandler(target));    &#125;&#125;\n\n\n\n获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor\nConstructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);\n\n在 Java 反射机制中，Class 类提供了一系列方法来获取类的构造器信息。这里通过 PersonProxy.getConstructor(InvocationHandler.class) 来获取 PersonProxy 类中，参数为 InvocationHandler.class 的构造器。getConstructor 方法会返回一个 Constructor 对象，它代表了对应的构造器。\n通过构造器constructor来创建一个动态实例stuProxy\nPerson stuProxy = (Person) cons.newInstance(stuHandler);\n\nConstructor 类的 newInstance 方法用于根据构造器来创建类的实例。这里传入了 stuHandler 作为参数，stuHandler 应该是实现了 InvocationHandler 接口的对象实例。它会调用之前获取到的构造器（要求参数为 InvocationHandler 类型 ）来初始化一个 PersonProxy 实例，并将其强制转换为 Person 类型（前提是 PersonProxy 类实现了 Person 接口 ）\n一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化\n//创建一个与代理对象相关联的InvocationHandler  InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);\n\n\n\n完整的动态代理例子定义一个Person接口，里面定义一个抽象方法 giveMoney();\npublic interface Person &#123;    //上交班费    void giveMoney();&#125;\n\n创建需要被代理的实际类 Student类，实现了Person接口，是被代理的目标对象：\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;        try &#123;          //假设数钱花了一秒时间            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\n\n再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。\npublic class MonitorUtil &#123;        private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();        public static void start() &#123;        tl.set(System.currentTimeMillis());    &#125;        //结束时打印耗时    public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();        System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);    &#125;&#125;\n\n创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。再在invoke方法中执行被代理对象target的相应方法。\n所以说InvocationHandler 负责处理代理对象方法的调用，当调用代理对象的方法时，实际上会调用 InvocationHandler 的 invoke 方法。\n当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。\npublic class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123;   // invocationHandler持有的被代理对象    T target;        public StuInvocationHandler(T target) &#123;       this.target = target;    &#125;        /**     * proxy:代表动态代理对象     * method：代表正在执行的方法     * args：代表调用目标方法时传入的实参     */     @Override   // 实现 InvocationHandler 接口需要重写invoke方法    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;);          //代理过程中插入监测方法,计算该方法耗时        MonitorUtil.start();        Object result = method.invoke(target, args);        MonitorUtil.finish(method.getName());        return result;    &#125;&#125;\n\n我们使用简化的方式创建动态代理对象：\npublic class ProxyTest &#123;    public static void main(String[] args) &#123;        //创建一个实例对象，这个对象是被代理的对象        Person zhangsan = new Student(&quot;张三&quot;);        //创建一个与代理对象相关联的InvocationHandler        InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan);        //创建一个代理对象stuProxy来代理张三，代理对象的每个执行方法都会替换执行Invocation中的invoke方法        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；       //代理执行上交班费的方法        stuProxy.giveMoney();    &#125;&#125;\n\n过程讲解： \nstuHandler为代理对象相关联的InvocationHandler，将目标对象 张三 传递给 StuInvocationHandler 的构造函数。InvocationHandler 的作用是处理代理对象方法的调用，当调用代理对象的方法时，会自动调用 InvocationHandler 的 invoke 方法\n使用 Proxy.newProxyInstance 方法创建一个代理对象 stuProxy，需要传入类加载器，实现的接口，指定处理代理对象方法调用的InvocationHandle对象，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\n之后调用代理对象的 giveMoney 方法，实际上会调用 StuInvocationHandler 的 invoke 方法，在 invoke 方法中会先调用 MonitorUtil.start() 记录开始时间，然后调用目标对象的 giveMoney 方法，最后调用 MonitorUtil.finish() 计算并打印方法执行的耗时。\n\n\n动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\n是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。\n例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而只做了很少的代码量。\n动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。\n因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行，这就涉及到java动态代理的原理了\n动态代理原理分析Java动态代理创建出来的动态代理类上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：\n/** * 返回一个指定接口的代理类实例，该实例会将方法调用分派到指定的调用处理器。 * * @param loader 定义代理类的类加载器 * @param interfaces 代理类要实现的接口列表 * @param h 调度方法调用的调用处理器 * @return 一个实现了指定接口的代理类实例，它会将方法调用分派给指定的调用处理器 * @throws IllegalArgumentException 如果违反了对该方法参数的任何限制 */public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)    throws IllegalArgumentException&#123;    // 检查调用处理器是否为 null，如果为 null 则抛出 NullPointerException    Objects.requireNonNull(h);    // 克隆接口数组，防止外部对原数组进行修改影响后续操作    final Class&lt;?&gt;[] intfs = interfaces.clone();    // 获取系统的安全管理器    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        // 如果存在安全管理器，检查调用者是否有创建代理类的权限        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    /*     * 查找或生成指定的代理类。     */    // 通过类加载器和接口数组获取代理类的 Class 对象    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * 使用指定的调用处理器调用其构造函数。     */    try &#123;        if (sm != null) &#123;            // 如果存在安全管理器，检查调用者是否有创建代理实例的权限            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        // 获取代理类的构造函数，该构造函数接收一个 InvocationHandler 类型的参数        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        // 保存传入的调用处理器        final InvocationHandler ih = h;        if (!Modifier.isPublic(cl.getModifiers())) &#123;            // 如果代理类不是公共类，则使用特权操作将构造函数设置为可访问            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;        // 使用构造函数创建代理类的实例，并传入调用处理器        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;        // 处理非法访问或实例化异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        // 处理构造函数调用抛出的异常        Throwable t = e.getCause();        if (t instanceof RuntimeException) &#123;            // 如果是运行时异常，直接抛出            throw (RuntimeException) t;        &#125; else &#123;            // 否则抛出内部错误            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        // 处理构造函数未找到的异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125;&#125;\n\nClass&lt;?&gt; cl = getProxyClass0(loader, intfs);\n\n\nloader：这是一个 ClassLoader 对象，它指定了代理类应该使用哪个类加载器来加载。类加载器负责将类的字节码文件加载到 JVM 中，不同的类加载器可能会从不同的位置（如文件系统、网络等）加载类。通常，我们会使用被代理接口的类加载器，这样可以确保代理类和被代理接口在同一个类加载器的命名空间中，从而避免类加载的冲突。\nintfs：这是一个 Class[] 数组，包含了代理类需要实现的接口列表。代理类会实现这些接口中定义的所有方法，当调用代理对象的这些方法时，实际上会将调用转发到 InvocationHandler 的 invoke 方法中进行处理。\n\n其实，我们最应该关注的是 Class&lt;?&gt; cl &#x3D; getProxyClass0(loader,  intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，这个类文件时缓存在java虚拟机中的\n\n在 Java 动态代理中，Proxy.newProxyInstance 方法的核心目标是创建一个实现了指定接口的代理对象。而 getProxyClass0 方法就是用来生成这个代理对象所对应的代理类的。这个代理类是在运行时动态生成的，并且会被加载到 Java 虚拟机（JVM）中，后续的代理对象实例就是基于这个动态生成的类来创建的。\n\n那么是如何动态生成代理类的：\n\ngetProxyClass0 方法会根据传入的类加载器和接口数组，在运行时动态生成一个代理类的字节码。这个代理类会实现 intfs 数组中指定的所有接口，并且会重写这些接口中的方法。在重写的方法中，会调用 InvocationHandler 的 invoke 方法，从而实现对目标方法的增强。\n这其中有一个缓存机制，为了提高性能，Java 虚拟机对动态生成的代理类采用了缓存机制。也就是说，如果已经为相同的类加载器和接口列表生成过代理类，那么 getProxyClass0 方法会直接从缓存中获取这个代理类，而不是再次生成。这样可以避免重复生成相同的代理类，减少开销。\n\n之后对这个class文件反编译\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.Person;// $Proxy0 是动态生成的代理类，它继承自 Proxy 类并实现了 Person 接口。Proxy 类是 Java 中所有代理类的基类// 它持有一个 InvocationHandler 类型的成员变量 h，用于处理方法调用public final class $Proxy0 extends Proxy implements Person&#123;  // 这些静态变量用于存储通过反射获取的方法对象。m3 对应 Person 接口的 giveMoney 方法，m0、m1、m2 分别对应 Object 类的 hashCode、equals 和 toString 方法。  private static Method m1;  private static Method m2;  private static Method m3;  private static Method m0;    /**  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，代理类的构造方法接收一个 InvocationHandler 类型的参数，并调用父类 Proxy 的构造方法将其传递给父类的 h 成员变量。这意味着代理类持有一个 InvocationHandler 对象，后续的方法调用将由该对象处理。  *  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。  *父类持有：protected InvocationHandler h;  *Proxy构造方法：  *    protected Proxy(InvocationHandler h) &#123;  *         Objects.requireNonNull(h);  *         this.h = h;  *     &#125;  *  */  public $Proxy0(InvocationHandler paramInvocationHandler)    throws   &#123;    super(paramInvocationHandler);  &#125;    //这个静态块本来是在最后的，我把它拿到前面来，方便描述   static  &#123;    try    &#123;      //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);      m3 = Class.forName(&quot;proxy.Person&quot;).getMethod(&quot;giveMoney&quot;, new Class[0]);      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);      return;    &#125;    catch (NoSuchMethodException localNoSuchMethodException)    &#123;      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());    &#125;    catch (ClassNotFoundException localClassNotFoundException)    &#123;      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());    &#125;  &#125;   /**  *   *当调用代理对象的 giveMoney 方法时，实际上会调用 InvocationHandler 对象的 invoke 方法，并将代理对象本身（this）、giveMoney 方法的 Method 对象（m3）和方法参数（这里为 null）作为参数传递给 invoke 方法。  *this.h.invoke(this, m3, null);这里简单，明了。  *InvocationHandler 对象持有被代理对象的引用，在 invoke 方法中可以调用被代理对象的相应方法，并可以在方法调用前后添加额外的逻辑，从而实现对被代理对象方法的增强。  */  public final void giveMoney()    throws   &#123;    try    &#123;      this.h.invoke(this, m3, null);      return;    &#125;    catch (Error|RuntimeException localError)    &#123;      throw localError;    &#125;    catch (Throwable localThrowable)    &#123;      throw new UndeclaredThrowableException(localThrowable);    &#125;  &#125;  //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。&#125;\n\njdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。\n我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。\n代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。\n引用\n[java动态代理实现与原理详细分析\nJava动态代理详细讲解-使用方式及应用场景\n","categories":["Java学习","JavaSE","JavaEE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识01之对象流","url":"/posts/54621.html","content":"Java难绷知识01之对象流本篇文章会探讨一些JavaIO流中比较容易被忽视的对象流，而且会相对的探讨其中的一些细节其中对于对象流的操作讲解会少一些，主要讨论的是一些细节  \n在 Java IO 流中，对象流（ObjectInputStream对象输入流 和 ObjectOutputStream对象输出流）用于将对象进行序列化和反序列化操作  \n对象流及其序列化首先，ObjectInputStream和ObjectOutputStream这两个类都属于是字节流，它们分别继承自InputStream和OutputStream  \n对象输出流，ObjectOutputStream，用于对象的序列化，也就是把Java对象转换成字节序列，把字节序列写出到文件，以这种对象转换为字节序列的机制实现了对象存储序列化目的是能够将整个 Java 对象（包括对象的状态，即成员变量的值）转换为字节流，以便在网络上传输或存储到文件中，之后还能稳定的从字节流中恢复出原来的对象。通过序列化，对象的状态信息（包括成员变量的值）可以被保存下来，以便后续传输或存储。  \n对象输入流，ObjectInputStream，用于对象的反序列化，是将文件中的字节序列恢复为Java对象，以这种字节序列转换为对象的机制实现了对象读取反序列化时，系统会根据字节流中的信息重新构建对象的状态。  \n在其基础上，我们再探讨序列化的一些细节  \n对象序列化的条件要想使一个类的对象能够被序列化，该类必须实现 java.io.Serializable 接口这是一个标记接口，没有任何方法需要实现。实现该接口，意味着告诉 Java 虚拟机这个类的对象可以被序列化。  \n\n点击查看代码\n\nimport java.io.*;// 定义一个实现Serializable接口的类class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;public class SerializationExample &#123;    public static void main(String[] args) &#123;        // 创建一个对象        Person person = new Person(&quot;Alice&quot;, 30);        // 序列化对象到文件        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) &#123;            oos.writeObject(person);            System.out.println(&quot;对象已成功序列化到文件 person.ser&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 从文件反序列化对象        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) &#123;            Person deserializedPerson = (Person) ois.readObject();            System.out.println(&quot;反序列化后的对象: &quot; + deserializedPerson);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注意：\n每个可序列化的类都应该有一个serialVersionUID，用于验证序列化和反序列化过程中的版本兼容性\n使用transient关键字声明的成员变量不会被序列化\n序列化可能会引发安全问题  \n\n对象流的使用细节对象流需要关闭吗先说结论，可以不关但是强烈建议关闭。这与 Java 流的资源管理机制紧密相关。涉及到对外部资源的读写操作，包括网络、硬盘等等的I&#x2F;O流，如果在使用完毕之后不关闭，会导致资源泄漏以及可能会引起文件锁定等问题。  \n当我们使用流进行数据操作时，它们会占用系统资源，如文件句柄、网络连接等。如果不关闭流，这些资源将不会被释放，可能导致资源泄漏问题。长时间运行的程序如果频繁出现资源泄漏，最终可能耗尽系统资源，导致程序崩溃或系统性能严重下降。\n而且关闭流可以确保所有已写入的数据被正确地传输到目标位置例如，当使用 ObjectOutputStream 将对象写入文件时，关闭流会保证缓冲区中的所有数据都被写入文件，避免数据丢失。通常建议使用try - with - resources语句来自动关闭流，示例代码如下  \n\n示例代码\n\nimport java.io.*;class MyClass implements Serializable &#123;    private static final long serialVersionUID = 1L;    int data;    public MyClass(int data) &#123;        this.data = data;    &#125;&#125;public class SerializeExample &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass(42);        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myfile.ser&quot;))) &#123;            oos.writeObject(obj);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n  \n#### 对象流需要使用flush吗\n先说结论，不用  \nObjectOutputStream内部维护了一个缓冲区。在调用writeObject方法时，数据首先会被写入缓冲区。调用flush方法可以强制将缓冲区中的数据立即写入底层输出流。然而，在大多数情况下，并不需要显式调用flush。因为当缓冲区满、流关闭或者调用某些特定方法（如writeObject在某些情况下会触发缓冲区数据的刷新）时，缓冲区的数据会自动被写入底层流。\n当然特意需要弄的时候可以弄  \n\nserialVersionUID在对象流中的必要性凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量：    private static final long serialVersionUID;来表明类的不同版本间的兼容性。  \n在完成序列化操作后，如果对序列化对象进行了修改，那么我们再进行反序列化就会抛出InvalidClassException异常。 因为serialVersionUID缺失（没有显式分配）或者serialVersionUID发生了变化， serialVersionUID的作用在此体现——对序列化对象进行版本控制，有关各版本反序加化时是否兼容。避免混乱。  \nclass Person implements Serializable &#123;    private static final long serialVersionUID = 1234567890123456789L;    private String name;    private int age;    // 后续可以安全地对类结构进行一些兼容的修改&#125;\n一个类在没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。所以建议一般显式声明。  \n序列化的一些细节static修饰的属性 不可以被序列化原因在于 static 变量属于类，而不是类的实例。它们是类级别的共享数据，与对象的状态无关。序列化的目的是保存对象的状态，所以 static 变量不会被包含在序列化的内容中。\nclass StaticExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private static int sharedValue = 10;    private int instanceValue;    public StaticExample(int instanceValue) &#123;        this.instanceValue = instanceValue;    &#125;&#125;\n当我们序列化 StaticExample 类的对象时，sharedValue 不会被序列化。在反序列化时，sharedValue 的值将取决于类加载时的初始化状态，而不是序列化时的值  \ntransient 修饰的属性不可以被序列化transient 关键字用于标记那些不希望被序列化的属性。这在某些场景下非常有用，比如当对象的某个属性包含敏感信息（如密码）或者该属性在反序列化后可以通过其他方式重新计算得到时。\nclass TransientExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String username;    private transient String password;    public TransientExample(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;&#125;\n当对 TransientExample 对象进行序列化时，password 的值不会被写入序列化流。这样可以保护敏感信息，防止其在序列化过程中被泄露。在反序列化后，password 属性的值将为 null，程序可以重新设置该值。\n对象序列化的作用为什么JavaIO流要特意造出这么一个IO流  \n当你需要把对象写入到文件或者读取的时候，其实我们更多的情况通常是保存对象的有效值字段，也就是对象的具体实例的字段，那么使用文件操作流FileOutputStream和字符输出流BufferedWriter或PrintStream就足够。这些流可以用于处理文件写入和基本数据类型及字符串的输出，但对象序列化有着独特且不可替代的作用  \n网络传输对象对象序列化机制是Java内建的一种对象持久化方式，可以很容易实现在JVM中的活动对象与字节流之间进行转换\n在网络传输中，发送端将对象序列化成字节流，经过网络传输到网络的另一端，可以从字节流重新还原为对象，这个特点使得在进行端到端的网络传输数据时候，字节流和Java对象之间的转换稳定且快速。  \n在其中分布式系统中，不同的节点之间需要进行对象的传递，对象序列化使得这种对象传输变得简单直接，确保了对象在不同 Java 虚拟机之间的准确传输，即使这些 JVM 运行在不同的操作系统上。\nRMI 是 Java 的一种远程方法调用机制，它允许一个 JVM 中的对象调用另一个 JVM 中的对象的方法。对象序列化也在其中起着关键作用 \n确保对象深层次的复制和持久化当对一个对象进行序列化然后反序列化时，会得到一个与原对象状态完全相同但内存地址不同的新对象。可以实现在不影响原对象的情况下对对象进行操作，多线程下的数据处理的机制也有一定序列化和反序列化的影子。这种情况对于远程创建对象副本并且调度的时候十分方便，而且不会干扰对象内部包含的复杂的引用关系，合理使用对象流可以大大提高程序处理复杂数据的能力。  \n在很多情况下，对象内部状态是需要被持久化的，序列化通过把对象写为字节流，保存的位置从JVM内存转移到文件系统，在需要的时候随时可以进行快速方便的还原例如：在一个游戏中，可以使用对象流将玩家的游戏进度（一个复杂的对象，包含玩家角色信息、游戏关卡等）保存到文件中，下次玩家启动游戏时可以恢复到上次的进度。  \n对象流与其他流的关系与字节流的关系字符流是对象流的特例，它们处理的是字符数据的序列化和反序列化。\n字符流（Reader 和 Writer 及其子类，如 BufferedReader、BufferedWriter 等）主要用于处理字符数据。Java 采用 Unicode 编码来表示字符，字符流对其的输入输出有优化。而且字符流在处理数据时，会根据指定的字符编码进行字节和字符之间的转换  \n而对象流可以将任何实现了 Serializable 接口的对象进行序列化和反序列化，意味着对象流操作的数据是复杂的对象结构，包括对象的成员变量、对象之间的引用关系。  \n与缓冲流的关系功能叠加：缓冲流（如 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter）的主要作用是提高数据读写的效率，通过在内存中设置缓冲区，减少实际的 I&#x2F;O 操作次数。对象流可以和缓冲流结合使用，以提升对象序列化和反序列化的性能。可以将 ObjectOutputStream 包装在 BufferedOutputStream 中，这样在写入对象时，数据会先写入缓冲区，当缓冲区满或流关闭时，才会一次性将数据写入底层输出流，从而减少磁盘 I&#x2F;O 操作的频率，提高写入效率。在处理大量对象的序列化或反序列化时，结合缓冲流能显著提升性能。不过反序列化涉及到的种种安全关系，这种情况，讨论一下就好。  \n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java注解与Annotation类","url":"/posts/54622.html","content":"了解注解Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。是提供一种为程序元素设置元数据的方法，这些信息可以被编译器、开发工具或运行时环境读取和处理。\n（程序元素：接口、类、属性、方法等；   元数据：描述数据的数据）\n关键特性：\n\n注解本身不包含业务逻辑，但可以通过反射机制在运行时获取并处理\n\n注解不影响程序本身的执行，但可以通过工具影响程序的行为\n\n注解可以包含命名参数，这些参数可以有默认值\n\n\n其实就是写在接口、类、属性、方法上的一个标签，或者说是一个特殊形式的注释，普通注释只是一个注释，而注解在代码运行时是可以被反射读取并进行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。\nJava 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。\n在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。\n可以利用注解来自定义一些实现，比如在某个方法上加一个自定义注解，就可以实现方法日志的自动记录打印\n举例@Override:\n它的作用是告诉阅读者(开发人员、编译器)这个方法重写了父类的方法，对于开发人员只是一个标志，然而编译器如果发现方法标注了这个注解，就会检查这个方法到底是不是真的覆写了父类的方法，如果没有会报错，而如果不添加@Override注解，程序也是可以正常运行的，不过缺乏了静态的检查\n在spring框架中加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。\n注意：注解不能直接干扰程序代码的运行\n注解的作用话说当年非常流行xml配置的。优点呢就是整个项目的配置信息集中在一个文件中，从而方便管理，是集中式的配置。缺点也显而易见，当配置信息非常多的时候，配置文件会变得越来越大不易查看管理，特别是多人协作开发时会导致一定的相互干扰。\n现在都提倡解耦、轻量化或者说微小化，那么注解就顺应了这一需求，各个包或模块在内部方法或类上使用注解即可实现指定功能，缺点呢就是不方便统一管理，如果需要修改某一类功能，则需要整体搜索逐个修改，是分散式的存在各个角落。\nxml的方式是集中式的元数据，不需要和代码绑定的，而注解是一种分散式的元数据设置方式。\n开发者的视角可以解读出这个类&#x2F;方法&#x2F;属性的作用以及该怎么使用，而从框架的视角则可以解析注解本身和其属性实现各种功能，编译器的角度则可以进行一些预检查(@Override)和抑制警告(@SuppressWarnings)等。\n\n作为特定标记，用于告诉编译器一些信息\n编译时动态处理，如动态生成代码\n运行时动态处理，作为额外信息的载体，如获取注解信息\n\nAnnotation架构Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。\n\n\n其中\n\n1 个 Annotation 和 1 个 RetentionPolicy 关联。\n可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。\nRetentionPolicy 是一个枚举类型，它定义了注解的保留策略，也就是规定了注解在什么阶段是可用的。\n\n\n\n\n1 个 Annotation 和 1~n 个 ElementType 关联。\n对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性\n\n\nAnnotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。\n每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\n\n\n\nAnnotation 组成部分java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：Annotation  ElementType RetentionPolicy\npackage java.lang.annotation;public interface Annotation &#123;    // 当两个注解对象满足以下条件时，认为它们相等：注解类型相同  所有注解元素的值都相等    boolean equals(Object obj);    int hashCode();    // 将当前注解对象转换为字符串表示形式,字符串表示通常包含注解的类型名称和所有注解元素的值。    String toString();       // 获取当前注解对象的注解类型。注解类型是一个 Class 对象，它表示定义该注解的接口。    Class&lt;? extends Annotation&gt; annotationType();   &#125;\n\npackage java.lang.annotation;public enum ElementType &#123;    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */&#125;\n\npackage java.lang.annotation;public enum RetentionPolicy &#123;    SOURCE,   /*源码级 Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /*类文件级 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /*运行级 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125;\n\n其中：\n\nAnnotation这个接口中，每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\nElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途\n就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。\n\nAnnotation 通用定义@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125;\n\n上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。\n定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。\njava常用的Annotation@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented  -- @Documented 所标注内容，是否包含在用户文档中javadoc@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention   -- @Retention只能被用来标注“Annotation类型”，用来指定Annotation的RetentionPolicy属性作用域。@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。\n\n\n\nAnnotation 的作用编译检查Annotation 具有”让编译器进行编译检查的作用”。\n例如\n\n@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。\n若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。\n\n\n我们可以发现 getString() 函数会报错。这是因为 getString() 被 @Override 所标注，但在OverrideTest 的任何父类中都没有定义 getString() 函数”。\n反射中使用Annotation在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。我们可以在反射中解析并使用 Annotation。\n/** * Annotation在反射函数中的使用示例 */@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String[] value() default &quot;unknown&quot;;&#125;/** * Person类。它会使用MyAnnotation注解。 */class Person &#123;        /**     * empty()方法同时被 &quot;@Deprecated&quot; 和 &quot;@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注      * (01) @Deprecated，意味着empty()方法，不再被建议使用     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;     */    @MyAnnotation    @Deprecated    public void empty()&#123;        System.out.println(&quot;\\nempty&quot;);    &#125;        /**     * sombody() 被 @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，     * @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;     */    @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)    public void somebody(String name, int age)&#123;        System.out.println(&quot;\\nsomebody: &quot;+name+&quot;, &quot;+age);    &#125;&#125;public class AnnotationTest &#123;    public static void main(String[] args) throws Exception &#123;                // 新建Person        Person person = new Person();        // 获取Person的Class实例        Class&lt;Person&gt; c = Person.class;        // 获取 somebody() 方法的Method实例        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]&#123;String.class, int.class&#125;);        // 执行该方法        mSomebody.invoke(person, new Object[]&#123;&quot;lily&quot;, 18&#125;);        iteratorAnnotations(mSomebody);                // 获取 somebody() 方法的Method实例        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]&#123;&#125;);        // 执行该方法        mEmpty.invoke(person, new Object[]&#123;&#125;);                iteratorAnnotations(mEmpty);    &#125;        public static void iteratorAnnotations(Method method) &#123;        // 判断 somebody() 方法是否包含MyAnnotation注解        if(method.isAnnotationPresent(MyAnnotation.class))&#123;            // 获取该方法的MyAnnotation注解实例            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);            // 获取 myAnnotation的值，并打印出来            String[] values = myAnnotation.value();            for (String str:values)                System.out.printf(str+&quot;, &quot;);            System.out.println();        &#125;                // 获取方法上的所有注解，并打印出来        Annotation[] annotations = method.getAnnotations();        for(Annotation annotation : annotations)&#123;            System.out.println(annotation);        &#125;    &#125;&#125;\n\n\n\n注解的分类 通常来说注解分为以下三类\n\n元注解 – java内置的注解，标明该注解的使用范围、生命周期等。\n标准注解 – Java提供的基础注解，标明过期的元素&#x2F;标明是复写父类方法的方法&#x2F;标明抑制警告。\n自定义注解 – 第三方定义的注解，含义和功能由第三方来定义和实现。\n\n元注解用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。\n元注解就是最基本不可分解的注解，我们不能去改变它只能使用它来定义自定义的注解。\n元注解包含以下五种： @Retention、@Target、@Documented、@Inherited、@Repeatable\n@Retention定义\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    RetentionPolicy value();&#125;\n\n标明自定义注解的生命周期，这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。它决定了注解在何时有效以及在何处可用。\n从编写Java代码到运行主要周期为源文件→ Class文件 → 运行时数据，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为SOURCE →CLASS→RUNTIME。\n\nSOURCE：源代码java文件，不会包含在编译后的 class 文件中，编译时候会丢弃\nCLASS：类文件级别保留，class文件中会保留注解，但是jvm加载运行时就没有了，是默认的保留策略\nRUNTIME：运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的\n\n各个生命周期的用途：\n\nSOURCE级别：\n典型应用：Lombok的@Getter、@Setter\n特点：编译后完全消失，不会增加运行时负担\n使用场景：仅用于编译期检查或代码生成\n\n\nCLASS级别：\n典型应用：Android的@Keep注解\n特点：保留到class文件但不会被加载到JVM\n使用场景：字节码分析工具使用\n\n\nRUNTIME级别：\n典型应用：Spring的@Controller、@Service\n特点：可通过反射获取，影响运行时行为\n使用场景：框架开发中最常用\n\n\n\n// Lombok的@Getter示例 SOURCE级别@Retention(RetentionPolicy.SOURCE)public @interface Getter &#123;    AccessLevel value() default AccessLevel.PUBLIC;&#125;// 使用@Getterpublic class User &#123;    private String name;&#125;// 编译时会生成getName()方法，但注解本身不会保留\n\n@Target描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上(类、方法、属性、局部属性、参数…)\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    ElementType[] value();&#125;\n\nvalue是一个数组，可以有多个取值，说明同一个注解可以同时用于标注在不同的元素上。value的取值如下\n@Target可以指定更精确的应用目标，包括：\n@Target(&#123;    ElementType.TYPE,               // 类、接口、枚举    ElementType.FIELD,              // 字段（包括枚举常量）    ElementType.METHOD,             // 方法    ElementType.PARAMETER,          // 方法参数    ElementType.CONSTRUCTOR,        // 构造器    ElementType.LOCAL_VARIABLE,     // 局部变量    ElementType.ANNOTATION_TYPE,    // 注解类型    ElementType.PACKAGE,            // 包    ElementType.TYPE_PARAMETER,     // 类型参数（Java 8+）    ElementType.TYPE_USE            // 类型使用（Java 8+）&#125;)\n\n自定义一个注解@MyAnnotation1想要用在类或方法上，就可以如下定义\n/**    * 自定义注解，使用@Target指定该注解可以应用在哪些元素上    * 这里指定了TYPE(类/接口/枚举等)和METHOD(方法)上    */   @Retention(RetentionPolicy.RUNTIME)    // 运行时保留   @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)  // 只能用于类和方法上   public @interface MyAnnotation &#123;       String description() default &quot;&quot;;   // 注解属性默认值   &#125;   /**    * 测试类，演示@Target的使用    * 因为@MyAnnotation允许用在TYPE上，所以可以用在类声明上    */   @MyAnnotation(description = &quot;这是一个类级别的注解示例&quot;)   public static class AnnotationTest &#123;       // @MyAnnotation   用在属性上则会报错       public String name;       @MyAnnotation(description = &quot;这是一个方法级别的注解示例&quot;)       public void testMethod() &#123;           System.out.println(&quot;测试方法执行&quot;);       &#125;   &#125;\n\n获取其中的注解，只能获取到类和方法上的\npublic static void main(String[] args) &#123;        // 获取类上的注解        MyAnnotation classAnnotation = AnnotationTest.class.getAnnotation(MyAnnotation.class);        System.out.println(classAnnotation.description());        try&#123;            // 获取方法上的注释            Method method = AnnotationTest.class.getMethod(&quot;testMethod&quot;);            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);            System.out.println(annotation.description());        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;\n\n@Inherited表示是否可以被标注类的子类继承。当注解 Inheritable 被 @Inherited 标注时，它具有继承性。否则，没有继承性。\n定义如下\n@Documented   // 说明该注解能出现在 javadoc 中。@Retention(RetentionPolicy.RUNTIME)   // 指定 Inherited 的策略是 RetentionPolicy.RUNTIME@Target(ElementType.ANNOTATION_TYPE)  // @Inherited 只能被用来标注 &quot;Annotation 类型&quot;// 它的用来修饰 Inherited，意味着 Inherited 实现了 Annotation 接口；即 Inherited 就是一个注解。public @interface Inherited &#123;    &#125;\n\n当一个类使用了带有 @Inherited 的注解时，这个注解会被该类的子类继承。\n\n仅对类注解有效：@Inherited 只对类级别的注解有效（即注解的 @Target 包含 ElementType.TYPE）\n不适用于接口：从父类继承的注解不会应用于实现接口的类\n不适用于方法等其他元素：方法上的注解不会被继承\n\n\n示例，通过反射获取注解\n// 定义一个可以被继承的注释@Inherited@Retention(RetentionPolicy.RUNTIME)  // 运行时保留，可以通过反射获取@Target(ElementType.TYPE)  // 只能用于类/接口/枚举上@interface InheritableAnnotation &#123;    String value() default &quot;父类注解&quot;;&#125;// 定义一个不可被继承的注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface NonInheritableAnnotation &#123;    String value() default &quot;不可继承的注解&quot;;&#125;// 父类，带有可继承和不可继承的注解@InheritableAnnotation(&quot;这是父类的可继承注解&quot;)@NonInheritableAnnotation(&quot;这是父类的不可继承注解&quot;)class ParentClass &#123;&#125;// 子类，继承自ParentClass，没有显式添加任何注解class ChildClass extends ParentClass &#123;&#125;\n\n打印注解的信息后可以发现：\n类 ParentClass 上的注解:  InheritableAnnotation:   NonInheritableAnnotation: 类 ChildClass 上的注解:  InheritableAnnotation: \n\n发现ChildClass 类没有继承 NonInheritableAnnotation 注解\n@Repeatable定义如下\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123;    // 指定包含重复注解的容器注解类型    Class&lt;? extends Annotation&gt; value();&#125;\n\n标识某注解可以在同一个声明上使用多次。（Java 8+特性）\n示例：\n// 定义可重复注解@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;// 定义包含可重复注解的容器注解@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations &#123;    MyAnnotation[] value();&#125;// 使用可重复注解@MyAnnotation(&quot;First Annotation&quot;)@MyAnnotation(&quot;Second Annotation&quot;)class MyClass &#123;    // 类的内容&#125;public class RepeatableExample &#123;    public static void main(String[] args) &#123;        // 普通的获取类上的所有 MyAnnotation 注解        // 需要定义容器注解来存放重复注解        // 通过getAnnotationsByType()获取重复注解        MyAnnotation[] annotations = MyClass.class.getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation annotation : annotations) &#123;            System.out.println(annotation.value());        &#125;        // 使用MyAnnotations，获取类上的 MyAnnotations 注解        MyAnnotations container = MyClass.class.getAnnotation(MyAnnotations.class);        if (container != null) &#123;   // 语法糖，相当于是返回一个MyAnnotation[]            for (MyAnnotation annotation : container.value()) &#123;                System.out.println(annotation.value());            &#125;        &#125;    &#125;&#125;\n\n虽然我们标注的是多个@MyAnnotation，其实会给我们返回一个@MyAnnotations，相当于是Java帮我们把重复的注解放入了一个数组属性中\n@Documented定义如下\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\n\n标记注解是否包含在Javadoc中。被@Documented标注的注解会出现在生成的API文档里。\n\n无参数\n只影响文档生成\n常用于重要的API注解\n\n根据 Annotation 生成帮助文档：\n通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。\n标准注解@Override定义\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\n\n标识方法覆写了父类或接口中的方法，提供编译时检查。\n\n仅用于方法\n编译时检查（非强制使用）\n源代码级别（不保留到class文件）\n可防止拼写错误导致意外创建新方法\n\n支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE\n这个天天用，估计大伙都会都知道，很多人注解学习的起步就是@Override\n@Deprecated某个方法被 @Deprecated 标注，则该方法不再被建议使用\n如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息\n\n\n定义如下\n@Documented  // 会出现在doc中@Retention(RetentionPolicy.RUNTIME)   // 指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。// @interface -- 它的用来修饰 Deprecated,即 Deprecated 就是一个注解public @interface Deprecated &#123;&#125;\n\n@SuppressWarnings让编译器对”它所标注的内容”的某些警告保持静默。\n\n定义如下\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();  // SuppressWarnings 能指定参数&#125;\n\n@FunctionalInterface用于标识函数式接口\n定义：\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125;\n使用示例\n@FunctionalInterfaceinterface Greeter &#123;    void greet(String name);        // 可以有默认方法    default void defaultGreet() &#123;        System.out.println(&quot;Hello, world!&quot;);    &#125;&#125;\n\n编译时会检查是否确实是函数式接口\n如果不是（有多个抽象方法），会报错\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"Log4j2日志记录框架的使用与配置文件的解析","url":"/posts/47832.html","content":"Log4j2如何使用什么是日志日志(Log)是软件系统运行时记录的重要事件、状态信息和操作轨迹的机制。它是软件开发、测试和维护过程中不可或缺的工具，具有以下特点和作用：\n\n问题诊断：当系统出现异常或错误时，日志提供了问题发生的上下文信息，帮助开发人员快速定位问题根源\n行为追踪：记录用户操作和系统行为，便于审计和追踪业务流程\n性能监控：通过记录关键操作的时间戳，可以分析系统性能瓶颈\n安全审计：记录系统访问和敏感操作，满足合规性要求\n运行状态记录：保存系统运行期间的重要状态变化，便于事后分析\n\n日志通常分为不同级别，便于过滤和分类处理：\n\nFATAL&#x2F;ERROR：错误，严重错误事件，可能导致系统崩溃或功能失效\nWARN：警告，输出警告的信息，潜在的有害情况，需要引起注意但不会立即影响系统运行\nINFO：信息，输出重要的运行时信息，记录系统正常运行状态\nDEBUG：调试，一般在开发中都设置的最低级别，详细的调试信息，用于开发阶段问题排查\nTRACE：追踪，最低的日志级别，最详细的跟踪信息，记录程序执行的详细路径\n\n级别高的日志会自动屏蔽级别低的日志\n日志的输出目的地指定了日志将会打印到控制台还是文件中，输出格式控制了日志信息的显示内容\nLog4j2作为Java生态中最流行的日志框架之一，提供了强大的日志记录能力，能够满足上述所有日志需求。\n简介Log4j的1.x版本虽然已经被广泛使用于很多应用程序中，但由于出现内存泄漏等bug，代码难以维护，以及需要使用老版本的jdk等劣势，在2015年8月已经玩完。它的替代品，SLF4J，Logback，Log4j2对日志框架做了很多必要的改进。\n历史上出现了很多的日记框架，如：\nLog4j：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。\nLog4j2：Apache Log4j 2是apache开发的一款Log4j的升级产品。\nCommons Logging：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。\nSlf4j：类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。\nLogback：一套日志组件的实现(Slf4j阵营)。\nJul(Java Util Logging)：自Java1.4以来的官方日志实现。\n安装在开发中使用Log4j2日志记录框架需要引入的jar包如下：\nlog4j-api-2.13.0.jarlog4j-core-2.13.0.jar\n\nmaven中配置xml如下\n&lt;properties&gt;    &lt;logging.log4j.version&gt;2.13.0&lt;/logging.log4j.version&gt;&lt;/properties&gt; &lt;dependencies&gt;    &lt;!-- Log4j2日志记录框架 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置文件在项目的src根目录下，创建log4j2.xml配置文件。配置信息如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;     &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。对于Loggers中level的定义同样适用。\n下面是Appender配置，Appender可以理解为日志的输出目的地，这里配置了一个类型为Console的Appender，也就是输出到控制台。Console节点中的PatternLayout定义了输出日志时的格式。\nLog4j提供的转换模式：\n\n%m 输出代码中指定的消息。\n\n%p 输出优先级，即DEBUG,INFO,WARN,ERROR,FATAL。\n\n%r 输出自应用启动到输出该log信息耗费的毫秒数。\n\n%c 输出所属的类目,通常就是所在类的全名。\n\n%t 输出产生该日志事件的线程名。\n\n%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n”。\n\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{dd MMM yyyy HH:mm:ss,SSS}，输出类似：02 Nov 2012 14:34:02,781)。\n\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数， 如：Testlog.main(TestLog.java:10)。\n\n%F 输出日志消息产生时所在的文件名称。\n\n%L 输出代码中的行号。\n\n%x 输出和当前线程相关联的NDC(嵌套诊断环境)，像java servlets多客户多线程的应用中。\n\n%% 输出一个”%”字符。\n\n\n最后是Logger的配置，这里只配置了一个Root Logger。\n可以用如下代码测试\npublic static void main(String[] args)&#123;    Logger logger = LogManager.getLogger(LogFunction.class);    logger.trace(&quot;trace level&quot;);    logger.debug(&quot;debug level&quot;);    logger.info(&quot;info level&quot;);    logger.warn(&quot;warn level&quot;);    logger.error(&quot;error level&quot;);    logger.fatal(&quot;fatal level&quot;);&#125;\n\n\n\nSpring中整合Log4j2日志框架Log4j2依赖导入引入Log4j2的依赖\n&lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;\n\n在引入log4j2时，需要排除掉Logback日志框架的依赖即。\n&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n\nlog4j2一般可以通过xml,json,yaml或者properties形式文件来实现，我们这边主要介绍xml文件格式。因为log4j 2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,”.json”或者”.jsn”。\n系统选择配置文件的优先级(从先到后)如下：\n(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件。\n(2).classpath下的名为log4j2-test.xml的文件。\n(3).classpath下名为log4j2.json 或者log4j2.jsn的文件。\n(4).classpath下名为log4j2.xml的文件。\n我们一般默认使用log4j2.xml进行命名。如果本地要测试，可以把log4j2-test.xml放到classpath，而正式环境使用log4j2.xml，则在打包部署的时候不要打包log4j2-test.xml即可。\nLog4j2的路径相关默认路径\n引入log4j2依赖后，默认在src/main/resources目录下加入log4j2.xml配置文件对日志进行配置即可，然后在application.yml中进行访问路径的配置。\n示例如下：\n\nlog4j2.xml部署位置   在代码工程中的src&#x2F;main&#x2F;resources目录下放入配置文件。\nyml配置\n\n#日志配置 无特殊需求无需更改logging:  config:  classpath:log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\n\n那么如何自定义部署位置\n当然我们也可以在微服务部署的config/目录下放置，然后在application.yml中进行访问路径的配置。\n举例：我们的micro-service01部署中配置的log4j2.xml路径。\n\nlog4j2.xml部署位置\n\n[userA@linux01 config]$ pwd/home/userA/SpringBoot/micro-service01/config[userA@linux01 config]$ lltotal 24-rwxr-xr-x 1 userA userA 5938 Sep  9 16:30 application.yml-r-------- 1 userA userA 8342 Sep  8 16:33 log4j2.xml\n\n\nyml配置\n\n#日志配置 无特殊需求无需更改logging:  config: /home/userA/SpringBoot/micro-service01/config/log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\n\nLog4j2.xml配置详解缺省默认配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;&lt;Appenders&gt;    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;        &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;    &lt;/Console&gt;&lt;/Appenders&gt;&lt;Loggers&gt;    &lt;Root level=&quot;error&quot;&gt;        &lt;AppenderRef ref=&quot;Console&quot; /&gt;    &lt;/Root&gt;&lt;/Loggers&gt;&lt;/Configuration&gt;\n\n解读：\n全局配置：\n\n仅输出 ERROR 及以上级别的日志（Root level=&quot;error&quot;）。\n使用名为 Console 的Appender（控制台输出）。\n\n日志格式：\n14:25:30.456 [main] ERROR com.example.MyClass - This is an error message\n\n\n%d&#123;HH:mm:ss.SSS&#125; → 时间（时:分:秒.毫秒）。\n[%t] → 线程名（如 [main]）。\n%-5level → 左对齐的日志级别（如 ERROR）。\n%logger&#123;36&#125; → 类名（长度限制为36字符）。\n%msg%n → 日志内容 + 换行。\n\n配置文件节点解析\n**根节点 &lt;Configuration**&gt;\n&lt;Configuration status=&quot;WARN&quot;&gt;\n\n\n作用：整个配置文件的根节点。\n两个属性：\nstatus：用来指定log4j2本身的打印日志的级别，用于调试配置文件问题。可选值：TRACE, DEBUG, INFO, WARN, ERROR, FATAL。\n其他可选属性：monitorInterval=&quot;30&quot;用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s\n\n\n有两个子节点：Appenders和Loggers(表明可以定义多个Appender和Logger)。\n\n\n日志输出器Appenders节点，常见的有三种子节点：Console、RollingFile、File。\n&lt;Appenders&gt;  &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;    &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;  &lt;/Console&gt;&lt;/Appenders&gt;\n\n\n作用：定义日志输出的目的地（如控制台、文件等）。\n子节点类型：\n**&lt;Console&gt;**：定义输出到控制台的Appender。\nname：唯一标识符,指定Appender的名字。（后续通过 AppenderRef 引用）。\ntarget：输出目标，可选 SYSTEM_OUT（标准输出）或 SYSTEM_ERR（标准错误）。一般只设置默认：SYSTEM_OUT。\nPatternLayout：输出格式，不设置默认为:%m%n。\n\n\n&lt;File&gt;：输出到文件（支持滚动日志）。用来定义输出到指定位置的文件的Appender。\nname：指定Appender的名字\nfileName：指定输出日志的目的文件带全路径的文件名。\nPatternLayout：输出格式，不设置默认为:%m%n。\n\n\n**&lt;RollingFile&gt;**节点用来定义超过指定大小自动删除旧的创建新的的Appender。\nname：指定Appender的名字。\nfileName：指定输出日志的目的文件带全路径的文件名。\nPatternLayout：输出格式，不设置默认为:%m%n。\nfilePattern：指定新建日志文件的名称格式。\nPolicies：指定滚动日志的策略，就是什么时候进行新建日志文件输出日志。\nTimeBasedTriggeringPolicy：Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate&#x3D;true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am。\nSizeBasedTriggeringPolicy：Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小。\nDefaultRolloverStrategy：用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。\n\n\n其他：&lt;Socket&gt;   &lt;Kafka&gt;   &lt;JDBC&gt;  等\n\n\n**&lt;PatternLayout&gt;**：定义日志格式。\npattern：格式模板，常用占位符：\n%d：日期时间（可指定格式如 %d&#123;yyyy-MM-dd HH:mm:ss&#125;）。\n%t：线程名。\n%-5level：左对齐的日志级别（长度5）。\n%logger&#123;36&#125;：Logger名称（最大长度36）。\n%msg：日志消息。\n%n：换行符。\n\n\n\n\n\n\n日志记录器&lt;Loggers&gt;\n&lt;Loggers&gt;  &lt;Root level=&quot;error&quot;&gt;    &lt;AppenderRef ref=&quot;Console&quot; /&gt;  &lt;/Root&gt;&lt;/Loggers&gt;\n\n\n作用：定义日志的采集规则（哪些级别的日志被记录，输出到哪些Appender）。常见的有两种：Root和Logger。\n核心节点：\nRoot节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出。\nlevel：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。\nAppenderRef：Root的子节点，用来指定该日志输出到哪个Appender。\nLogger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。\nlevel：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。\nname：用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点。\nAppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=&quot;false&quot;只在自定义的Appender中进行输出。\n\n\n\n\n关于日志level\n共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。\n\nAll：最低等级的，用于打开所有日志记录。\nTrace：是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出。\nDebug：指出细粒度信息事件对调试应用程序是非常有帮助的。\nInfo：消息在粗粒度级别上突出强调应用程序的运行过程。\nWarn：输出警告及warn以下级别的日志。\nError：输出错误信息日志。\nFatal：输出每个严重的错误事件将会导致应用程序的退出的日志。\nOFF：最高等级的，用于关闭所有日志记录。\n\n程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。\n\n\n比较完整的log4j2.xml配置模板配置模板1:不同级别日志分离存储带日志滚动归档，历史日志分析\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;!--先定义所有的appender--&gt;    &lt;appenders&gt;        &lt;!--这个输出控制台的配置--&gt;         &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;        &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;        &lt;/File&gt;        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/info.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/warn.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/error.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;loggers&gt;        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;        &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;root level=&quot;all&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n配置模板2基础控制台 + 文件日志（带滚动策略）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- status=&quot;WARN&quot; 表示 Log4j2 自身日志级别，调试时可设为 TRACE --&gt;&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;Appenders&gt;        &lt;!-- 控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 滚动文件日志 (每天滚动，最多保留7天) --&gt;        &lt;RollingFile name=&quot;RollingFile&quot;                      fileName=&quot;logs/app.log&quot;                      filePattern=&quot;logs/app-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout&gt;                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;            &lt;/PatternLayout&gt;            &lt;Policies&gt;                &lt;!-- 每天午夜滚动日志 --&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;                &lt;!-- 单个日志文件最大 100MB --&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- 最多保留 7 天的日志 --&gt;            &lt;DefaultRolloverStrategy max=&quot;7&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- Spring 框架日志控制 --&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- Hibernate 日志控制 --&gt;        &lt;Logger name=&quot;org.hibernate&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 项目代码日志 (包路径根据实际情况修改) --&gt;        &lt;Logger name=&quot;com.example&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 根日志配置 --&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n配置模板3按环境区分配置（开发&#x2F;生产）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Properties&gt;        &lt;!-- 通过环境变量切换配置 --&gt;        &lt;Property name=&quot;log.level&quot;&gt;$&#123;sys:spring.profiles.active:-dev&#125;&lt;/Property&gt;        &lt;Property name=&quot;logPath&quot;&gt;logs&lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!-- 彩色控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;cyan&#125; %highlight&#123;%-5level&#125; %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 生产环境专用文件日志 --&gt;        &lt;RollingFile name=&quot;ProdFile&quot;                      fileName=&quot;$&#123;logPath&#125;/prod.log&quot;                     filePattern=&quot;$&#123;logPath&#125;/prod-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;500 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 开发环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;dev&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;DEBUG&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;        &lt;!-- 生产环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;prod&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;WARN&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;                &lt;AppenderRef ref=&quot;ProdFile&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n配置模板4高性能异步日志\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;!-- 启用异步日志 --&gt;    &lt;AsyncLoggerConfig includeLocation=&quot;true&quot; /&gt;    &lt;Appenders&gt;        &lt;!-- 异步文件追加器 --&gt;        &lt;RollingRandomAccessFile name=&quot;AsyncFile&quot;                                fileName=&quot;logs/async.log&quot;                                filePattern=&quot;logs/async-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;ISO8601&#125; %-5level [%t] %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;200 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;!-- 控制台快速输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 异步记录器配置 --&gt;        &lt;AsyncLogger name=&quot;com.example&quot; level=&quot;INFO&quot; includeLocation=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/AsyncLogger&gt;        &lt;!-- SQL 日志单独记录 --&gt;        &lt;Logger name=&quot;jdbc.sqlonly&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;WARN&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n模板5JSON 格式日志（适用于 ELK 收集）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;JsonLayout compact=&quot;true&quot; eventEol=&quot;true&quot;&gt;                &lt;KeyValuePair key=&quot;app&quot; value=&quot;MySpringApp&quot;/&gt;                &lt;KeyValuePair key=&quot;env&quot; value=&quot;$&#123;sys:spring.profiles.active&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/Console&gt;        &lt;File name=&quot;JsonFile&quot; fileName=&quot;logs/app.json&quot;&gt;            &lt;JsonLayout complete=&quot;false&quot; compact=&quot;false&quot;&gt;                &lt;KeyValuePair key=&quot;timestamp&quot; value=&quot;$$&#123;date:yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#125;&quot;/&gt;                &lt;KeyValuePair key=&quot;thread&quot; value=&quot;%t&quot;/&gt;                &lt;KeyValuePair key=&quot;level&quot; value=&quot;%level&quot;/&gt;                &lt;KeyValuePair key=&quot;logger&quot; value=&quot;%logger&quot;/&gt;                &lt;KeyValuePair key=&quot;message&quot; value=&quot;%message&quot;/&gt;                &lt;KeyValuePair key=&quot;exception&quot; value=&quot;%ex&#123;full&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/File&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 结构化日志专用配置 --&gt;        &lt;Logger name=&quot;com.example.api&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n\n\n\n\n自定义配置文件夹位置log4j2默认在classpath下查找配置文件，可以修改配置文件的位置。在非web项目中：\npublic static void main(String[] args) throws IOException&#123;    File file = new File(&quot;D:/log4j2.xml&quot;);    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));    final ConfigurationSource source = new ConfigurationSource(in);    Configurator.initialize(null, source);     Logger logger = LogManager.getLogger(&quot;mylog&quot;);&#125;\n\n如果是web项目，在web.xml中添加：\n&lt;context-param&gt;    &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt;    &lt;param-value&gt;/WEB-INF/conf/log4j2.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;listener&gt;    &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n\n上述内容部分引用自  https://blog.csdn.net/pan_junbiao/article/details/104313938\n推荐教程\n推荐几篇我在网上找到的，写的很好的学习教程：\n学习资料1：详解log4j2(上) - 从基础到实战\n学习资料2：详解log4j2(下) - Async&#x2F;MongoDB&#x2F;Flume Appender 按日志级别区分文件输出\n学习资料3：SpringBoot—整合log4j2入门和log4j2.xml配置详解\n\n简单示例在项目的src根目录下的resources文件夹创建如下log4j2.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;    &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n日志功能测试类\npublic class TestUser &#123;    // 创建Logger    private Logger logger = LoggerFactory.getLogger(TestUser.class);    @Test    public void test() &#123;        // 加载spring配置文件，对象创建        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 获取创建的对象        User user = (User)context.getBean(&quot;user&quot;);        System.out.println(&quot;1:&quot; + user);    // 输出了对象的地址        // 使用对象调用方法完成测试        System.out.println(&quot;2:&quot;);        user.add();        // 手动写日志        logger.info(&quot;@执行调用成功&quot;);        // 追踪        logger.trace(&quot;trace level&quot;);        logger.debug(&quot;debug level&quot;);        logger.info(&quot;info level&quot;);        logger.warn(&quot;warn level&quot;);        logger.error(&quot;error level&quot;);    &#125;\n\n输出结果\n\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework","日志与调试"]},{"title":"Servlet与http","url":"/posts/62509.html","content":"软件架构与网络通信软件架构：\n\nB&#x2F;S：浏览器端-服务器端（JavaEE体系）  客户端不用再去开发，开发更加快速\nC&#x2F;S：客户端-服务器端\n\n资源分类：\n\n静态资源：所有用户访问后得到的结果是一样的，称为静态资源\n如html css js\n\n\n动态资源：每个用户访问相同资源后，得到的结构可能不一样，称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器\n如 servlet php jsp\n\n\n\n网络通信三要素：\n\nIP：电子设备在网络中的唯一标识\n端口:应用程序在计算机中的唯一标识\n传输协议：规定了通信的规则\n基础协议：tcp udp\n\n\n\n\n\nhttp概述http：超文本传输协议\n传输协议：定义了客户端和服务器端通信的时候发送数据的格式\n特点：\n\n基于TCP&#x2F;IP的高级协议\n默认端口号是80\n基于请求响应模型，一次请求对应一次响应\n无状态的，每次请求之间相互独立\n\nhttp的请求消息和请求行请求消息数据格式：\n请求行\n明确请求的基本信息（操作类型、目标资源、协议版本）\n请求方式 请求url 请求协议&#x2F;版本    \n请求方法：\n常见方法（Servlet 中常用）\n\n\n\n\n方法\n含义\n特点\n是否有请求体\n\n\n\nGET\n请求获取资源\n请求参数在请求行，数据通过 URL 传递，明文可见，长度有限制（浏览器通常限制 8KB）\n无\n\n\nPOST\n提交数据（如表单）\n数据放在请求体中，适合传输大量数据，安全性较高\n有\n\n\nPUT\n更新资源（全量更新）\n需指定资源完整路径，幂等性（多次操作结果一致）\n有\n\n\nDELETE\n删除资源\n指定 URL 对应的资源，幂等性\n无\n\n\nHEAD\n获取资源头部信息\n仅返回响应头，不返回响应体，用于快速检查资源是否存在\n无\n\n\n请求url：协议:&#x2F;&#x2F;主机:端口&#x2F;路径?查询参数#锚点\n\n协议：固定为http或https（如http://）\n\n主机：服务器域名（如www.example.com）或 IP 地址（如192.168.1.1）\n\n端口：可选，默认80（HTTP）或443（HTTPS），如8080\n\n路径：资源在服务器上的路径（如/user/login）\n\n查询参数：可选，格式为key=value&amp;key2=value2，通过?与路径分隔\n\n锚点：客户端浏览器使用，用于定位页面内元素，服务器不处理\nServlet服务器接收的 URL 部分：不包含锚点，仅到查询参数为止\n\n\n\n请求头\n携带请求的附加信息（客户端环境、请求参数、安全信息等）\n请求头名称：请求头值\n通用头字段：\n\n\n\n字段名\n含义\n示例\nServlet 获取方法\n\n\n\nHost\n目标服务器的主机和端口（必传）\nlocalhost:8080\nrequest.getHeader(&quot;Host&quot;)\n\n\nUser-Agent\n客户端信息（浏览器 &#x2F; 操作系统）\nMozilla/5.0 (Windows NT 10.0) Chrome/110.0.0.0\nrequest.getHeader(&quot;User-Agent&quot;)\n\n\nReferer\n来源页面 URL（防盗链，统计）\nhttp://example.com/login.html\nrequest.getHeader(&quot;Referer&quot;)\n\n\nAccept\n客户端接受的响应内容类型\ntext/html,application/json\nrequest.getHeader(&quot;Accept&quot;)\n\n\n可以在服务器端获取User-Agent该头的信息，解决浏览器端兼容性问题\n与请求体相关的头字段：\n\n\n\n字段名\n含义\n示例\nServlet 关联\n\n\n\nContent-Type\n请求体的数据格式和编码\napplication/x-www-form-urlencoded; charset=UTF-8（表单数据） multipart/form-data; boundary=xxx（文件上传）\n通过request.getContentType()获取\n\n\nContent-Length\n请求体的字节长度\n1024\n通过request.getContentLength()获取\n\n\n\n请求空行\n作为请求头和请求体的分隔符，必须存在且仅包含一个换行符（\\r\\n）\n\n请求体\n封装POST请求消息的请求体的，GET请求没有请求体\n空行之后（可选，非必须），存放请求的具体数据（如表单提交的参数、上传文件内容等）\n\n数据格式\n\n\napplication&#x2F;x-www-form-urlencoded：表单默认格式，键值对编码为key=value&amp;key2=value2，不支持文件上传\nmultipart&#x2F;form-data：文件上传专用格式，通过boundary分隔不同字段，支持二进制数据\napplication&#x2F;json：JSON 格式数据，需在Content-Type头中声明\n\n\nServlet 中获取请求体数据\n\n\n普通表单数据：通过request.getParameter(&quot;参数名&quot;)直接获取（自动解码）\nJSON 数据：需通过request.getReader()或request.getInputStream()手动解析\n文件上传：需使用MultipartHttpServletRequest（需配置MultipartResolver）\n\n\n\n响应消息数据格式\nRequest请求原理\n\nrequest对象和response对象的原理：\n由服务器创建，我们仅使用\nrequest对象获取请求消息，response对象来设置响应消息\n\nrequest对象继承体系的结构Servlet中的HttpServletRequest对象是处理HTTP请求的核心接口\n基本继承层次：\njavax.servlet.ServletRequest (接口)       ↑javax.servlet.http.HttpServletRequest (接口)       ↑org.apache.catalina.connector.RequestFacade (Tomcat实现类)\n\nServletRequest接口这是最基础的请求接口，定义了通用的请求方法，不限于HTTP协议：\n\n核心方法：\ngetParameter(String name) - 获取请求参数\ngetAttribute(String name) - 获取请求属性\nsetAttribute(String name, Object o) - 设置请求属性\ngetInputStream() - 获取输入流\ngetReader() - 获取字符读取器\ngetContentType() - 获取内容类型\ngetLocalAddr() - 获取服务器IP地址\n\n\n\nHttpServletRequest接口继承自ServletResponse接口，专门用来封装HTTP响应消息。  由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。：\n\nHTTP相关方法：\ngetHeader(String name) - 获取请求头\ngetMethod() - 获取HTTP方法(GET&#x2F;POST等)\ngetCookies() - 返回一个cookie对象数组\ngetSession() - 返回与这个请求相关的会话对象\ngetRequestURI() - 获取请求URI\ngetQueryString() - 返回请求URL中的查询字符串\ngetContextPath() - 返回请求上下文的请求URI部分\ngetServletPath() - 获取Servlet路径\n\n\n\n实现类 (以Tomcat为例)Tomcat中的具体实现类结构：\nRequest (org.apache.catalina.connector.Request)       ↑RequestFacade (org.apache.catalina.connector.RequestFacade)\n\n\nRequest：Tomcat内部的实际实现类，包含大量内部方法\nRequestFacade：提供给Servlet开发者的门面类，遵循门面模式，隐藏了内部复杂实现\n\njavax.servlet.http包内容HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：\npublic abstract class HttpServlet extends GenericServlet implements Serializable \n\nHttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。\n\n\nHttpServlet抽象类HttpServlet 抽象类是继承于 GenericServlet 抽象类而来的。\n使用 HttpServlet 抽象类时，还需要借助分别代表 Servlet 请求和 Servlet 响应的 HttpServletRequest 和 HttpServletResponse 对象。\nHttpServletRequest 接口扩展于 javax.servlet.ServletRequest 接口，HttpServletResponse 接口扩展于javax.servlet.servletResponse 接口。\npublic interface HttpServletRequest extends ServletRequest\n\npublic interface HttpServletResponse extends ServletResponse\n\n\n\n其中，HttpServlet 抽象类覆盖了 GenericServlet 抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法。\n这是 GenericServlet 抽象类中定义的service方法：\npublic abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\nHttpServlet 实现的这个 service 方法\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    HttpServletRequest request;    HttpServletResponse response;    try &#123;        request = (HttpServletRequest)req;        response = (HttpServletResponse)res;    &#125; catch (ClassCastException var6) &#123;        throw new ServletException(&quot;non-HTTP request or response&quot;);    &#125;     this.service(request, response);&#125;\n\nHttpServlet 中的 service 方法把接收到的 ServletRequsest 类型的对象转换成了 HttpServletRequest 类型的对象，把ServletResponse 类型的对象转换成了 HttpServletResponse 类型的对象。  \n之所以能够这样强制的转换，是因为在调用Servlet的Service方法时，Servlet容器总会传入一个 HttpServletRequest 对象和 HttpServletResponse 对象，预备使用HTTP。因此，转换类型当然不会出错了。\n转换之后，service方法把两个转换后的对象传入了另一个service方法\n// 参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String method = req.getMethod();    long lastModified;    // 解析HttpServletRequest中的方法参数，并调用以下方法之一，每一种方法都表示一个Http方法。doGet和doPost是最常用的    if (method.equals(&quot;GET&quot;)) &#123;        lastModified = this.getLastModified(req);        if (lastModified == -1L) &#123;            this.doGet(req, resp);        &#125; else &#123;            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if (ifModifiedSince &lt; lastModified) &#123;                this.maybeSetLastModified(resp, lastModified);                this.doGet(req, resp);            &#125; else &#123;                resp.setStatus(304);            &#125;        &#125;    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;        lastModified = this.getLastModified(req);        this.maybeSetLastModified(resp, lastModified);        this.doHead(req, resp);    &#125; else if (method.equals(&quot;POST&quot;)) &#123;        this.doPost(req, resp);    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;        this.doPut(req, resp);    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;        this.doDelete(req, resp);    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;        this.doOptions(req, resp);    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;        this.doTrace(req, resp);    &#125; else &#123;        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[]&#123;method&#125;;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    &#125;&#125;\n\n\n\n\n\n通过request获取内容通过request获得请求行请求行包含HTTP方法、URI和协议版本，例如：GET /test?name=value HTTP/1.1\n// 获取请求方法(GET/POST/PUT/DELETE等)String method = request.getMethod();// 获取请求URL(不包含协议、域名和端口)String requestURL = request.getRequestURL().toString(); // 获取请求URI(相对于Context Path的部分)String requestURI = request.getRequestURI();// 获取查询字符串(问号后面的部分)String queryString = request.getQueryString();// 获取协议和版本String protocol = request.getProtocol(); // HTTP/1.1// 获取上下文路径(web应用的根路径)String contextPath = request.getContextPath();// 获取Servlet路径String servletPath = request.getServletPath();\n\n获取请求头信息请求头包含了客户端环境和请求的附加信息\n// 获取指定请求头的值String userAgent = request.getHeader(&quot;User-Agent&quot;);String accept = request.getHeader(&quot;Accept&quot;);// 获取所有请求头名称的枚举Enumeration&lt;String&gt; headerNames = request.getHeaderNames();// 遍历所有请求头while(headerNames.hasMoreElements()) &#123;    String name = headerNames.nextElement();    String value = request.getHeader(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取Int类型的请求头值int contentLength = request.getIntHeader(&quot;Content-Length&quot;);// 获取日期类型的请求头值long date = request.getDateHeader(&quot;If-Modified-Since&quot;);// 获取多值请求头Enumeration&lt;String&gt; languages = request.getHeaders(&quot;Accept-Language&quot;);\n\n获取请求体请求体主要出现在POST、PUT等请求中，包含客户端发送的数据\n获取表单数据// 获取单个表单参数值String username = request.getParameter(&quot;username&quot;);// 获取多值参数(如复选框)String[] hobbies = request.getParameterValues(&quot;hobby&quot;);// 获取所有参数名的枚举Enumeration&lt;String&gt; paramNames = request.getParameterNames();// 获取所有参数的MapMap&lt;String, String[]&gt; paramMap = request.getParameterMap();// 遍历所有参数paramMap.forEach((key, values) -&gt; &#123;    System.out.print(key + &quot;: &quot;);    for(String value : values) &#123;        System.out.print(value + &quot; &quot;);    &#125;    System.out.println();&#125;);\n\n获取原始请求体// 获取输入流读取原始数据ServletInputStream inputStream = request.getInputStream();BufferedReader reader = request.getReader();// 示例：读取JSON请求体StringBuilder sb = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123;    sb.append(line);&#125;String jsonBody = sb.toString();\n\n获取其他请求信息// 获取客户端IP地址String clientIP = request.getRemoteAddr();// 获取客户端主机名String clientHost = request.getRemoteHost();// 获取客户端端口int clientPort = request.getRemotePort();// 获取服务器信息String serverName = request.getServerName();int serverPort = request.getServerPort();// 获取请求的会话HttpSession session = request.getSession();// 获取Cookie数组Cookie[] cookies = request.getCookies();// 获取内容类型String contentType = request.getContentType();// 获取字符编码String encoding = request.getCharacterEncoding();// 设置字符编码(处理中文乱码)request.setCharacterEncoding(&quot;UTF-8&quot;);\n\n示例处理JSON请求\nprotected void doPost(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 设置字符编码    request.setCharacterEncoding(&quot;UTF-8&quot;);        // 读取JSON请求体    StringBuilder sb = new StringBuilder();    try (BufferedReader reader = request.getReader()) &#123;        String line;        while ((line = reader.readLine()) != null) &#123;            sb.append(line);        &#125;    &#125;        // 解析JSON    JSONObject json = new JSONObject(sb.toString());    String username = json.getString(&quot;username&quot;);    // 处理业务逻辑...&#125;\n\nRequest乱码问题的解决方法Servlet默认编码是ISO-8559-1，需要手动修改编码方式为UTF-8编码\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);  // 解决post提交方式的乱码parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);    //  解决get提交的方式的乱码\n\n\n\n\n\n通过Response设置响应HttpServletResponse对象是Servlet中用于构建HTTP响应的核心接口，它提供了丰富的方法来设置响应状态、响应头和响应体\n设置响应状态设置状态码// 设置成功状态码(200)response.setStatus(HttpServletResponse.SC_OK);// 设置404未找到response.setStatus(HttpServletResponse.SC_NOT_FOUND);// 设置500服务器错误response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);// 设置302重定向(已废弃，推荐使用sendRedirect)response.setStatus(HttpServletResponse.SC_FOUND);\n\n设置状态码和错误消息// 设置状态码和自定义错误消息response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;资源不存在&quot;);// 仅设置状态码(使用默认错误消息)response.sendError(HttpServletResponse.SC_FORBIDDEN);\n\n设置响应头基本响应头设置// 设置单个响应头response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 添加响应头(可设置多个同名头)response.addHeader(&quot;Set-Cookie&quot;, &quot;name=value&quot;);// 设置Int类型响应头response.setIntHeader(&quot;Content-Length&quot;, 1024);// 设置日期类型响应头response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis() + 3600000);\n\n常用响应头快捷方法// 设置内容类型和字符编码(等同于setHeader(&quot;Content-Type&quot;, ...))response.setContentType(&quot;text/html;charset=UTF-8&quot;);// 设置内容长度(等同于setIntHeader(&quot;Content-Length&quot;, ...))response.setContentLength(1024);// 设置字符编码(单独设置)response.setCharacterEncoding(&quot;UTF-8&quot;);\n\n设置响应体获取输出流// 获取字节输出流(用于二进制数据)// 获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。ServletOutputStream outputStream = response.getOutputStream();// 获取字符输出流(用于文本数据)// 获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。PrintWriter writer = response.getWriter();\n\n注意，其中response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。\n重定向相关302重定向// 简单重定向(相对路径)response.sendRedirect(&quot;newPage.html&quot;);// 重定向到绝对URLresponse.sendRedirect(&quot;http://example.com/newPath&quot;);// 重定向到上下文路径下的资源response.sendRedirect(request.getContextPath() + &quot;/secured/page.jsp&quot;);\n\n请求转发(服务器内部)// 获取转发器RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/target.jsp&quot;);// 转发请求和响应dispatcher.forward(request, response);\n\n示例RESTful API响应protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);        try (PrintWriter out = response.getWriter()) &#123;        JSONObject json = new JSONObject();        json.put(&quot;status&quot;, &quot;success&quot;);        json.put(&quot;data&quot;, new JSONObject()            .put(&quot;id&quot;, 123)            .put(&quot;name&quot;, &quot;张三&quot;)            .put(&quot;email&quot;, &quot;zhangsan@example.com&quot;));                out.print(json.toString());    &#125;&#125;\n\n文件下载protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        String fileName = &quot;example.pdf&quot;;    String filePath = &quot;/path/to/files/&quot; + fileName;        response.setContentType(&quot;application/pdf&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        try (InputStream in = new FileInputStream(filePath);         OutputStream out = response.getOutputStream()) &#123;                byte[] buffer = new byte[4096];        int length;        while ((length = in.read(buffer)) &gt; 0) &#123;            out.write(buffer, 0, length);        &#125;    &#125;&#125;\n\n乱码问题response缓冲区的默认编码也是iso8859-1\nresponse.setCharacterEncoding(&quot;utf-8&quot;);  // 更改response的编码方式为UTF-8\n\n更改response的编码方式为UTF-8，只是其中一步，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。\n// 通知浏览器使用utf8response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);\n\nresponse.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)方法即可。\n\nServlet的工作流程\n\n关于Web基础部分\nJavaWeb-http\n引用文章\nJavaWeb——HTTP详解\nJavaWeb——Servlet\n菜鸟教程Servlet部分\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaEE","Web","JavaWeb","Servlet"]},{"title":"Java难绷知识02-抽象类中只能有或者必须有抽象方法吗以及抽象类的细节探讨","url":"/posts/44268.html","content":"Java难绷细节02—抽象类中只能有抽象方法吗首先回答标题抛出的问题——False显然，有抽象方法的类是抽象类，但是，抽象类中只能有抽象方法吗？  \n抽象类可以包含抽象方法，也可以包含具体方法如果一个类包含至少一个抽象方法，用abstract关键字修饰，那么这个类必须被声明为抽象类。抽象类除了可以有抽象方法外，还可以包含具体的方法，即有方法体的方法。一个类用abstract修饰，那它就是抽象类了，但是不是说抽象类中必须有抽象方法，如果一个类像接口那样所有方法都有具体的实现，也可以用abstract修饰为抽象类那么反过来想，抽象方法只能写在抽象类中，但是抽象类中不一定要有抽象方法  \n一个包含了抽象方法和具体方法的抽象类\npublic abstract class Shape &#123;    // 抽象方法    public abstract double getArea();    // 具体方法    public void displayInfo() &#123;        System.out.println(&quot;This is a shape.&quot;);    &#125;&#125;\nabstract class AbstractParent &#123;    // 具体方法    public void printMessage() &#123;        System.out.println(&quot;This is a message from AbstractParent.&quot;);    &#125;&#125;// 子类继承抽象类，非抽象子类需要实现抽象方法class Child extends AbstractParent &#123;    // 子类可以直接使用父类的具体方法，根据需要重写    @Override    public void printMessage() &#123;        System.out.println(&quot;This is a message from Child, overriding the parent method.&quot;);    &#125;&#125;\n另外，如果一个抽象类并没有包含任何抽象方法，那么它的子类即使不实现任何方法也是非抽象类\n总之，抽象类是一种特殊的类，它的存在主要是为了提供一个通用的框架或基类，让其他子类去继承和实现具体的功能，抽象类可以包含抽象方法和具体方法，但是有抽象方法的类必须是抽象类\n如果我这篇博客就说这一点东西就有种，“因为这点事就把大伙叫过来？”的蹩脚感觉于是我们接着探讨一些抽象类中的各种令人很难绷的住的细节  \n为什么要有抽象类这个问题尽管乍看之下对实际开发的直接引导作用并非立竿见影，但深入剖析其中缘由，能让我们对 Java 语言的设计理念和面向对象编程的本质有更为透彻的理解（也能让我说出更多东西）   \n抽象类和抽象方法的产生是为了维护继承链的逻辑，即抽象类相对于那些普通的类处于继承树的根部。抽象类和抽象方法的诞生，很大程度上是为了维护继承体系的逻辑完整性与合理性  \n首先，类用于描述现实生活中一类事物。类中有属性、方法等成员  \n那么，抽象类中，有用的就是方法的声明，方法主体存在的意义被弱化，这种情况下十分适合用于取规范一个子类应该具备一个怎样的方法，既可以定义需要子类去实现的抽象行为，以满足不同子类的个性化需求，又能实现一些通用的行为或属性，让子类能够共享这些功能，从而提高代码的复用性和可维护性。  \n但是，抽象类中的非抽象方法如同在非抽象类中一样，正常继承使用。  \n所以，抽象类通常用于作为其他类的父类，用来定义一些需要子类去实现的抽象行为  \n主要目的是为了阻止其他类直接实例化这个类，同时为其子类提供一个通用的基类框架，用于实现一些通用的行为或属性。  \n抽象类可以设计模板模式，其中的某些步骤由抽象方法表示，具体的实现留给子类，大大增加了可读性和简便程度。\n抽象类可以用于定义一组相关类的通用接口规范，通过抽象类，我们可以确保所有相关类都具有特定的行为，同时又允许它们根据自身特性进行个性化实现。  \n抽象方法抽象方法只有方法声明，没有方法体（有爆Error），并且必须使用 abstract 关键字修饰。\npublic abstract class Shape &#123;    public abstract double getSquare();&#125;\n抽象方法的特点\n抽象方法必须存在于抽象类中\n\n包含抽象方法的类必须被声明为抽象类。这样做的目的是为了确保抽象方法不会被意外调用，因为抽象方法本身没有实际的执行代码，实例化该类时就可能调用到没有实现的方法，这会导致运行时错误。\n\n\n所有子类都需要实现抽象类中的抽象方法，除非子类本身也是抽象类。\n\n抽象类定义了一种抽象的概念，其中的抽象方法是这种概念下未完成的行为。子类继承抽象类，就继承了这种抽象概念及其未完成的行为。如果子类不实现抽象方法，那么这个子类仍然是不完整的，因为它没有完成抽象类中定义的行为。\n\n\n强制子类实现\n\n这个没啥好说的，当一个类继承自包含抽象方法的抽象类时，除非子类本身也是抽象类，否则它必须实现父类中的所有抽象方法。这是保证行为一致性的重要手段。\n\n\n\nabstract class Shape &#123;    public abstract double getArea();&#125;// 子类本身是抽象类，可以不实现getArea方法abstract class ThreeDShape extends Shape &#123;    // 这里没有实现getArea方法，因为ThreeDShape是抽象类&#125;class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\n\n\n\n抽象方法不能用private、final、static、native修饰。\n\n抽象方法不能被声明为 static，静态方法属于类本身，而不是类的实例，而抽象方法的实现依赖于具体的子类实例。如果将抽象方法声明为静态，就无法通过子类实例来提供具体的实现。来回的限制区域错误会导致无法通过子类实例来提供具体的实现\n\nprivate修饰的成员只能在本类中访问，抽象方法的设计目的是为了让子类去实现，矛盾\n\nfinal修饰的方法不能被子类重写。如果一个方法同时被abstract和final修饰，就会产生矛盾\n\nnative方法表示该方法的实现是由本地代码提供的，Java 本身不包含该方法的实现。抽象方法没有实现，就会出现冲突\n\n\n\n\n抽象类的一些各种细节1、抽象类不能被实例化首先抽象类是不能实例化的类\n抽象类存在的意义是作为一种抽象概念，为子类提供一个通用的框架，可能包含一些尚未具体实现的抽象方法，这些方法需要子类去实现如果抽象类可以被实例化，就可能调用到未实现的抽象方法，导致运行时错误\nabstract class Galgame &#123;    public abstract void run();&#125;\n如果允许Galgame被实例化，如Galgame galgame &#x3D; new Galgame();当调用galgame.run()时，由于run方法没有具体实现，就会出现问题\n2、abstract不能static抽象方法可以使用 public 或 protected 作为访问修饰符，但是static不行\n再次强调，抽象方法是一种只有声明没有实现的方法，需要子类去重写实现。它依赖于具体的子类实例来确定具体的行为。  \n而静态方法属于类本身的方法，不依赖于任何类的实例，是通过类名直接调用。在类加载时就已经确定，其生命周期与类的生命周期相同。\n如果一个方法同时被abstract和static修饰，就会产生矛盾。\n因为抽象方法没有具体实现，不能直接调用。只有在创建了子类的实例，并将其赋值给父类类型的引用变量后，通过该引用变量调用抽象方法时，才会执行子类中重写的具体实现。而静态方法不依赖于实例，在类加载时就可调用，这样会导致内存的顺序出现问题，因为静态方法不依赖于对象实例，而抽象方法却依赖子类实例来提供具体实现  \n反证法，如果是静态抽象方法，那么在类加载时就可调用，但此时由于它是抽象的，没有具体实现，调用必然出错。  \n3、抽象类的构造器抽象类可以有构造器虽然抽象类不能被直接实例化，但它的构造器用于被子类调用因为抽象类中是可以有成员变量的当创建子类对象时，会先调用抽象类的构造器，然后再调用子类的构造器。这确保了在子类对象初始化之前，从抽象类继承的部分已经被正确初始化。  \n4、可以有成员变量抽象类可以有成员变量的原因是抽象类中的成员变量可以用于存储子类共享或需要继承的状态信息，如果子类需要，抽象父类可以提供成员变量的访问控制：与普通类一样，抽象类中的成员变量可以有不同的访问修饰符  \nabstract class Vehicle &#123;    private int wheels;    protected String color;    public int speed;    Vehicle(int wheels, String color, int speed) &#123;        this.wheels = wheels;        this.color = color;        this.speed = speed;    &#125;    public int getWheels() &#123;        return wheels;    &#125;    public abstract void move();&#125;class Car extends Vehicle &#123;    public Car(int wheels, String color, int speed) &#123;        super(wheels, color, speed);    &#125;    @Override    public void move() &#123;        System.out.println(&quot;The &quot; + color + &quot; car is moving.&quot;);    &#125;&#125;\n\n5、继承抽象类的抽象子类问题如果一个类继承自抽象类，但它本身也是抽象类，那么它可以选择不实现父类的抽象方法\nabstract class Shape &#123;    public abstract double getArea();&#125;abstract class ThreeDShape extends Shape &#123;    // 可以不实现getArea方法，因为ThreeDShape本身是抽象类&#125;// 而 Sphere 类继承自 ThreeDShape，作为具体类，它必须实现 getArea 方法。class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\n\n抽象类跟接口包括我而言，很多人不禁疑惑，为什么有了抽象类，还要干出一个接口来？？这俩都是一定程度上规范子类的方法，功能一眼看过去差不多  \n这个我打算写一篇详细的文章，但是算了，没啥时间））我还要推gal，而且这不是一个需要长篇大论的问题，在这里和大家简单探讨一下   \n其实是很简单的问题，但凡遇到了两种东西，功能很相似，通常情况就是这几种：使用场景不同，产生的最终结果不同，兼容性与更优性问题。  \n突破继承限制与灵活性在 Java 中，一个类只能继承一个直接父类。这是为了避免多重继承带来的诸如继承混乱问题（什么哈斯图，我正好在看离散）而接口则打破了这种限制，一个类可以实现多个接口。这使得类能够从多个不同的 “行为集合” 中获取规范，灵活性极大up，使得子类更好的拥有多种行为能力。  \n功能侧重点差异抽象类虽然可以包含抽象方法，但也能有具体的属性和方法实现。这意味着抽象类在一定程度上仍然保留了对具体实现细节的描述。这是根据子类的需要，抽象类并不特别死的限制会带来很多方便和意想不到的特别之处  \n接口是一种完全抽象的类型，它只包含抽象方法（Java 8 及之后版本可包含默认方法和静态方法，但是本质绝对不会因为这个改动而改变），没有任何成员变量，只关注行为的定义，不涉及任何细节，只做出最少最需要的方法约束，更加纯粹地体现了一种行为规范，而且不用不行。  \n场景差异当多个类之间存在一些共同的属性和行为，并且这些共同部分可以在抽象类中进行部分实现时，适合使用抽象类。也就是对于很多个类中，我抽象出了一些共有属性实现了一个类，之后的符合该属性的类，就按照抽象类的规定来实现。与行为约束相比，更偏向共性总结。\n而当需要为不相关的类添加一些通用行为时，接口更为合适。也就是接口这是一个规矩，有什么类需要实现这个规矩，我就用接口来规范它。  \n扩展性差异如果在抽象类中添加新的方法，可能需要在所有子类中实现该方法，这对于已经存在的大量子类来说，维护成本较高，一个个改会比较累。  \n对于接口，如果添加新的方法，（在 Java 8 之前，实现该接口的类不会受到影响（除非强制要求实现新方法）），那么实现该接口的类会分为两种，一个是完全实现了接口的类，一个是未完全实现了接口的类。在 Java 8 及之后，新增的默认方法有了默认实现，实现接口的类可以选择是否重写这些默认方法，这使得接口在扩展时对已有实现类的影响较小，更易于维护和扩展。\n\n文章个人编辑较为匆忙，需要大家积极反馈来帮助这篇文章和我的更进一步QQ：1746928194，是喜欢画画的coder，欢迎来玩！\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Spring Framework part2--IoC容器之IoC原理","url":"/posts/undefined.html","content":"Spring Framework part2–IoC容器之IoC原理在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。\n什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。\n例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。\n通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。\nSpring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。\nIoC容器，主要关于Spring容器如何对组件进行生命周期管理和配置组装服务。\nIoC原理Spring提供的容器又称为IoC容器，什么是IoC？\nIoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。\n控制翻转IoCIoC是一种设计思想，能够指导我们能设计出松耦合，更优良的程序，提高程序的扩展力\nSpring 通过 IoC容器来管理所有Java对象的实例化和初始化，控制对象和对象之间的依赖关系，我们将由IoC容器管理的Java对象称为 Spring Bean，他与使用关键字 new 创建的 Java 对象没有任何区别\n容器中存放我们的Bean（java中的对象），创建到销毁过程都是容器进行管理的\n控制反转，反转的是什么\n\n把对象的创建权力交出去，交给第三方容器\n将对象和对象之间的关系的维护权交出去，交给第三方容器负责\n\n控制反转如何实现\n\nDI 依赖注入\n\n容器放bean对象，使用的是 map 集合\nIoC容器过程示例图\n\n\n\n\n依赖注入DI  依赖注入 实现了控制反转的思想\n依赖注入\n\nSpring创建对象的过程中，将对象依赖属性通过配置进行注入\n\n常见方式包括以下两种\n\n第一种，set注入\n第二种，构造注入\n\n所以，IoC就是一直控制反转的思想，而 DI 是对IoC的一种具体实现\nBean管理说的是：Bean对象的创建，以及Bean对象中属性的值（Bean对象之间关系的维护）\nIoC容器在Spring的实现IoC容器中管理的组件也叫Bean，创建Bean之前，首先要创建IoC容器，Spring提供了IoC容器的两组实现方式\n\nBeanFactory\n顶层接口，IoC容器的基本实现，是Spring内部使用的接口，面向Spring本身，不提供给开发人员使用\n\nApplicationContext\nBeanFactory的子接口，提供了更多的高级特性\n主要实现类如下\n\n\n![1](Spring Framework part2-IoC容器之IoC原理&#x2F;image-20250419180915322.png)\n\n\n![image-20250419180928366](Spring Framework part2-IoC容器之IoC原理&#x2F;image-20250419180928366.png)\n\n\n传统 Java 组件协作 与  IoC 控制反转 的对比会在下述例子中体现一个电商系统需要处理订单，订单服务（OrderService）依赖支付服务（PaymentService）完成支付逻辑。\n传统方式：硬编码依赖\n// 支付服务实现public class PaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment...&quot;);    &#125;&#125;// 订单服务直接创建依赖对象public class OrderService &#123;    private PaymentService paymentService = new PaymentService(); // 硬编码依赖    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方代码public class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        orderService.createOrder();    &#125;&#125;\n\n紧耦合：OrderService 直接实例化 PaymentService，若需替换支付实现（如改用支付宝或微信支付），必须修改 OrderService 的代码。\n上述每个组件都采用了一种简单的通过new创建实例并持有的方式，但是这种方式有着很大的缺点：\n\n随着更多的组件被引入，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。\n没有必要让不同的两个类分别创建相同功能的实例，完全可以共享同一个，但谁负责创建，谁负责获取其他组件已经创建的，不好处理\n实例化一个组件其实很难，因为各种依赖关系可能存在\n测试某个组件，例如OrderService，是复杂的，因为必须要在支付环境下执行。\n\n从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\n因此，核心问题是：\n\n谁负责创建组件？\n谁负责根据依赖关系组装组件？\n销毁时，如何按依赖顺序正确销毁？\n\n解决这一问题的核心方案就是IoC。\nIoC 方式：通过依赖注入解耦\n// 定义支付接口（面向接口编程）public interface PaymentService &#123;    void processPayment();&#125;// 支付宝实现public class AlipayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;// 微信支付实现public class WechatPayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Wechat Pay...&quot;);    &#125;&#125;// 订单服务通过构造函数注入依赖public class OrderService &#123;    private PaymentService paymentService;    // 依赖由外部传入（控制权反转）    public OrderService(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方通过容器（如 Spring）管理依赖public class Main &#123;    public static void main(String[] args) &#123;        // 由容器决定具体实现（如配置为 AlipayService）        PaymentService paymentService = new AlipayService();        OrderService orderService = new OrderService(paymentService);        orderService.createOrder();    &#125;&#125;\n\n\n解耦：OrderService 不再关心 PaymentService 的具体实现，只需依赖接口。\n灵活性：更换支付方式时，只需修改外部配置（如 Spring 的 Bean 定义），无需改动 OrderService 代码。\n可测试性：在单元测试中，可以注入 MockPaymentService 模拟不同场景。\n\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。\n为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如 OrderService 自己并不会创建 paymentService，而是等待外部通过createOrder方法来注入一个OrderService \npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;        System.out.println(&quot;Order created!&quot;);    &#125;&#125;\n\n不直接用 new，而是注入一个 paymentService，带来了一系列好处\n\n可维护性显著提升\n\n在传统方式中，若要更换支付服务的实现，比如从当前的简单支付服务切换到支付宝支付服务，就需要直接修改 OrderService 类的代码。而在 IoC 模式下，由于采用了注入机制，OrderService 类本身不需要做任何修改。\n假设我们有一个新的 AlipayPaymentService 类\npublic class AlipayPaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;\n\n在调用方代码中，我们只需要注入新的支付服务实例即可\npublic class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        AlipayPaymentService alipayPaymentService = new AlipayPaymentService();        orderService.createOrder(alipayPaymentService);    &#125;&#125;\n\n这样，当业务需求发生变化时，我们可以轻松地替换支付服务的实现，而不会影响到 OrderService 类的内部逻辑，大大提高了代码的可维护性。\n\n\n\n可测试性大幅增强\n\n在传统方式下，测试 OrderService 类时，由于它直接依赖于 PaymentService，必须在真实的支付环境下进行测试，这不仅增加了测试的复杂性，还可能带来不必要的风险\n而在 IoC 模式下，我们可以使用模拟对象（Mock Object）来进行测试。例如，使用 JUnit 和 Mockito 框架，我们可以创建一个模拟的 PaymentService 对象，并将其注入到 OrderService 中进行测试：\nimport org.junit.jupiter.api.Test;import static org.mockito.Mockito.*;public class OrderServiceTest &#123;    @Test    public void testCreateOrder() &#123;        // 创建模拟的 PaymentService 对象        PaymentService mockPaymentService = mock(PaymentService.class);        OrderService orderService = new OrderService();        // 调用 createOrder 方法并注入模拟对象        orderService.createOrder(mockPaymentService);        // 验证 PaymentService 的 processPayment 方法是否被调用        verify(mockPaymentService, times(1)).processPayment();    &#125;&#125;\n\n\n依赖关系管理更加清晰\n\n在 IoC 模式下，所有组件的创建和依赖关系的组装都由 IoC 容器负责，应用程序只需要使用已经创建好并配置好的组件。在 IoC 模式下,通过配置文件或注解的方式将这些依赖关系清晰地表达出来，由 IoC 容器根据这些配置信息来创建和组装组件。这样，开发人员只需要关注组件的功能实现，而不需要关心组件之间的依赖关系，降低了系统的复杂度。\n\n\n\n因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现\n&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\n依赖注入方式我们从上面的代码可以看到，依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。\n很多Java类都具有带参数的构造方法，如果我们把 OrderService 改造为通过构造方法注入，那么实现代码如下：\npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;&#125;\n\nSpring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。\n无侵入容器在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\n\n应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\n测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Servlet学习之核心接口,工作原理和配置","url":"/posts/4234.html","content":"什么是Servlet运行在服务器端的程序\nservlet是一个接口，定义了Java类被浏览器访问到的规则（接口）\nServlet是用java编写的服务器端的程序，主要是交互式的浏览和修改数据，生成动态Web内容，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上\nServlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\nStruts2的核心用的是Filter（过滤器），而SpringMVC的核心用的就是Servlet。\n// WebServlet注解表示这是一个Servlet，并映射到地址/:@WebServlet(urlPatterns = &quot;/&quot;)public class HelloServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;        // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;&#125;\n\n一个Servlet总是继承自HttpServlet，然后重写doGet()或doPost()方法。注意到doGet()方法传入了HttpServletRequest和HttpServletResponse两个对象，分别代表HTTP请求和响应。我们使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为HttpServletRequest和HttpServletResponse就已经封装好了请求和响应\n工作模式\n客户端发送请求至服务器\n服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器\n服务器将响应返回客户端\n\nAPI预览Servlet API 包含以下4个Java包：\n1.javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。\n2.javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。\n3.javax.servlet.annotation   其中包含标注servlet，Filter,Listener的标注。它还为被标注元件定义元数据。\n4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。\n使用ServletServlet技术的核心是Servlet，它是所有Servlet类必须直接或者间接实现的一个接口。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。\n工作原理​    Servlet接口定义了Servlet与servlet容器之间的契约：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。\n​    但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​    用户请求致使Servlet容器调用Servlet的Service()方法,并传入一个ServletRequest对象和一个ServletResponse对象。 ServletRequest中封装了当前的Http请求,ServletResponse表示当前用户的Http响应.\n​     对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。\n接口中定义的方法public interface Servlet &#123;    // 这是 Servlet 的初始化方法，在 Servlet 实例被创建之后，容器会调用此方法对 Servlet 进行初始化操作。    void init(ServletConfig var1) throws ServletException; \t    // 用于获取 Servlet 的配置信息，会返回由Servlet容器传给init（ ）方法的ServletConfig对象    ServletConfig getServletConfig(); \t    // 用来处理客户端的请求并生成响应。当有客户端请求到达时，Servlet 容器会调用这个方法。    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; \t    // 用于返回 Servlet 的描述信息    String getServletInfo(); \t    // 这是 Servlet 的销毁方法，在 Servlet 实例被销毁之前，容器会调用此方法，用于释放 Servlet 占用的资源    void destroy();&#125;\n\n执行原理当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\n查找Web.xml文件，是否有对应的标签体的内容，如果有，则在对应的全类名\ntomcat会将其字节码加载进内存然后构建对象，调用其方法\nServlet的生命周期上述接口中定义的方法内，init( ),service( ),destroy( )是Servlet生命周期的方法。\nServlet容器（例如TomCat）会根据下面的规则来调用这三个方法：\n\n当Servlet第一次被请求时，Servlet容器就会开始调用 init() 方法，初始化一个Servlet对象出来,这个方法在后续请求中不会在被Servlet容器调用。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。\n\nservice( )方法，每当请求Servlet时，Servlet容器就会调用这个方法，第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。\n\ndestory,当要销毁Servlet时，Servlet容器就会调用这个方法，一般在这个方法中会写一些清除代码，只有服务器正常关闭的时候，才会执行destory方法\n演示代码\n@Overridepublic void init(ServletConfig servletConfig) throws ServletException &#123;    System.out.println(&quot;Servlet正在初始化&quot;);&#125; @Overridepublic ServletConfig getServletConfig() &#123;    return null;&#125; @Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;    //专门向客服端提供响应的方法    System.out.println(&quot;Servlet正在提供服务&quot;); &#125; @Overridepublic String getServletInfo() &#123;    return null;&#125; @Overridepublic void destroy() &#123;    System.out.println(&quot;Servlet正在销毁&quot;);&#125;\n\n其中servlet的创建时期是可以被指定的\n&lt;!-- 指定servlet的创建时期，负数为第一次访问时期，0或正数为服务器启动时期--&gt;&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;\n\nServlet中的 init 方法只执行一次，说明一个Servlet中只存在一个对象，是单例的，多个用户同时访问可能存在线程安全的隐患，所以尽量不要再其中定义成员变量，也不要对其赋值\nTomcat部分普通的Java程序是通过启动JVM，然后执行main()方法开始运行。但是Web应用程序有所不同，我们无法直接运行war文件，必须先启动Web服务器，再由Web服务器加载我们编写的HelloServlet，这样就可以让HelloServlet处理浏览器发送的请求。\nTomcat本身的目录层次结构\n\nTomcat提供了一个部署其服务器在你本地电脑上的功能\n​\t实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机\n​\t执行Tomcat的main()方法，然后由Tomcat负责加载我们的.war文件，并创建一个HelloServlet实例，最后以多线程的模式来处理HTTP请求。\n​\t如果Tomcat服务器收到的请求路径是/（假定部署文件为ROOT.war），就转发到HelloServlet并传入HttpServletRequest和HttpServletResponse两个对象。\n配置Servletweb.xml配置web.xml 文件是用于配置 Web 应用程序的核心文件，它能对 Servlet、过滤器、监听器等组件进行配置\nServlet 定义&lt;servlet&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.ergoutree.servletexpdemo.demo1.FastGo&lt;/servlet-class&gt;&lt;/servlet&gt;\n\n\n标签：该标签的作用是定义一个 Servlet。在一个 web.xml 文件中，可以定义多个 Servlet。\n标签：这里为 Servlet 指定一个名称，也就是 ServletExpDemo。这个名称属于逻辑名称，主要用于在 web.xml 文件的其他部分引用该 Servlet。\n标签：它指定了 Servlet 类的全限定名，即 org.ergoutree.servletexpdemo.demo1.FastGo。当 Web 容器启动时，会依据这个全限定名来加载并实例化该 Servlet 类。\n\nServlet 映射&lt;servlet-mapping&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n标签：此标签的功能是将 Servlet 与一个或多个 URL 模式进行映射。当客户端发送请求时，Web 容器会根据请求的 URL 找到对应的 Servlet。\n标签：这里引用了之前定义的 Servlet 的名称，也就是 ServletExpDemo。\n标签：它指定了与该 Servlet 关联的 URL 模式，即 /demo1。当客户端请求的 URL 匹配这个模式时，Web 容器就会将请求转发给 ServletExpDemo 所对应的 Servlet 类（也就是org.ergoutree.servletexpdemo.demo1.FastGo）进行处理。\n\n原理及其示例原理说明当客户端向 Web 应用程序发送 HTTP 请求时，Web 容器（像 Tomcat 这类）会按照以下步骤处理请求：\n\n解析请求 URL：Web 容器对客户端请求的 URL 进行解析，从中提取出请求的路径部分。\n查找 Servlet 映射：Web 容器在 web.xml 文件里查找与请求路径相匹配的 &#96;&#96;。\n定位 Servlet：若找到匹配的 ，Web 容器会根据对应的  找到之前定义的 Servlet。\n实例化并调用 Servlet：Web 容器加载并实例化该 Servlet 类，然后调用其 service() 方法来处理请求。\n返回响应：Servlet 处理完请求后，将响应返回给客户端。\n\n示例假设客户端发送的请求 URL 为 http://localhost:8080/yourApp/demo1，Web 容器会进行如下操作：\n\n解析出请求路径为 /demo1。\n在 web.xml 文件中找到 为 `/demo1` 的。\n根据 &#96;&#96; 为 ServletExpDemo，找到对应的 Servlet 类 org.ergoutree.servletexpdemo.demo1.FastGo。\n加载并实例化 FastGo 类，调用其 service() 方法处理请求。\n将处理结果返回给客户端。\n\nSerlvet3.0的注解配置@WebServlet 的属性列表：\n![image-20250412202207184](D:\\WorkSpace\\github space\\hexo-blog\\source_posts\\Servlet学习之核心接口，工作原理和配置\\image-20250412202207184.png)\n核心注解**@WebServlet**取代  和 ，直接绑定 URL 模式与 Servlet 类。\n@WebServlet(    name = &quot;userServlet&quot;, // Servlet 名称（可选）    urlPatterns = &#123;&quot;/user&quot;, &quot;/api/user&quot;&#125;, // 支持多 URL 模式    loadOnStartup = 1, // 容器启动时立即加载（替代 &lt;load-on-startup&gt;）    initParams = &#123;        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;) // 初始化参数    &#125;,    asyncSupported = true // 启用异步支持（默认 false）)public class UserServlet extends HttpServlet &#123; ... &#125;\n\n\nurlPatterns：支持精确匹配 (/user)、通配符 (/api/*)、后缀匹配 (*.do)。\n\nloadOnStartup：值越小优先级越高，控制 Servlet 初始化顺序。\n\nasyncSupported：异步处理开关，需配合 AsyncContext 使用（后文详解）。\n\n\n@WebFilter：声明过滤器替代  和，定义请求预处理和后处理逻辑。\n@WebFilter(    filterName = &quot;auditFilter&quot;,    urlPatterns = &quot;/*&quot;, // 过滤所有请求    servletNames = &#123;&quot;userServlet&quot;&#125;, // 针对特定 Servlet    dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.ASYNC&#125;)public class AuditFilter implements Filter &#123; ... &#125;\n\n\ndispatcherTypes：控制过滤器作用的请求类型（如 FORWARD、ERROR）。\n执行顺序问题：注解无法直接指定顺序，需通过类名自然排序或结合 web.xml 的 &#96;&#96;。\n\n@WebListener：事件监听器简化监听器的声明，覆盖 Servlet 上下文、会话、请求等生命周期事件。\n@WebListenerpublic class AppContextListener implements ServletContextListener &#123;    @Override    public void contextInitialized(ServletContextEvent sce) &#123;        // 应用启动逻辑    &#125;&#125;\n\n\n\n异步处理在 @WebServlet 或 @WebFilter 中设置 asyncSupported = true。\n流程：\n\n开启异步上下文：AsyncContext asyncContext = request.startAsync()。\n提交耗时任务到其他线程（如数据库查询、远程调用）。\n任务完成时，通过 asyncContext.complete() 或返回响应。\n\n@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)public class AsyncServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;        AsyncContext ctx = req.startAsync();        CompletableFuture.runAsync(() -&gt; &#123;            // 模拟耗时操作            ctx.getResponse().getWriter().write(&quot;Async Response&quot;);            ctx.complete();        &#125;);    &#125;&#125;\n\n\n\n模块化部署介绍Servlet 3.0 模块化特性：\n\n允许将 Web 组件（Servlet、Filter、Listener）打包为 JAR 文件，置于 WEB-INF/lib 目录。\n容器自动扫描 JAR 中的 META-INF/web-fragment.xml 和注解，实现“即插即用”\n\n注意情况如果使用@WebServlet Annotation（注解）来配置Servlet，需要注意：\n① 不要在 web.xml 文件的根元素（&lt;web-app—&#x2F;&gt;）中指定 metadata-complete&#x3D;“true”；② 不要在 web.xml 文件中再次配置该 Servlet 相关属性\nServletRequest 和 ServletResponse 为 Servlet 提供了处理客户端请求和发送响应的能力；ServletConfig 为 Servlet 提供了配置信息；ServletContext 为 Servlet 提供了整个 Web 应用程序的上下文环境。它们共同协作，使得 Servlet 能够正常运行并处理客户端的请求。\nServletRequset接口Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\nServletRequest接口的部分内容：\npublic interface ServletRequest &#123;    int getContentLength();//返回请求主体的字节数    String getContentType();//返回主体的MIME类型    String getParameter(String var1);//返回请求参数的值&#125;\n\n\n\nServletResponse接口javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。\nServletResponse隐藏了向浏览器发送响应的复杂过程。在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。\nServletResponse内部定义的方法：\npublic interface ServletResponse &#123;    String getCharacterEncoding(); \t// 在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型,加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。    String getContentType(); \t// 发送二进制数据的    ServletOutputStream getOutputStream() throws IOException; \t// PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。    PrintWriter getWriter() throws IOException;     void setCharacterEncoding(String var1);     void setContentLength(int var1);     void setContentType(String var1);     void setBufferSize(int var1);     int getBufferSize();     void flushBuffer() throws IOException;     void resetBuffer();     boolean isCommitted();     void reset();     void setLocale(Locale var1);     Locale getLocale();&#125;\n\n\n\nServletConfig接口当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。\n其中几个方法如下：\n\nServletContext对象ServletContext对象表示Servlet应用程序，是Servlet的上下文对象。每个Web应用程序都只有一个ServletContext对象。\n在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。\n通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。\n有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中\nServletContext中的下列方法负责处理属性：\nObject getAttribute(String var1);  // 获取 ServletContext 中指定名称的属性值 // 用于获取 ServletContext 中所有属性的名称。返回的是一个 Enumeration 对象，通过它可以遍历所有属性的名称。Enumeration&lt;String&gt; getAttributeNames(); void setAttribute(String var1, Object var2);    // 向 ServletContext 中设置一个属性 void removeAttribute(String var1);    // 从 ServletContext 中移除指定名称的属性\n\n\n\nServlet是否为线程安全线程安全问题指的是多线程在并发执行时会不会出现问题。由于Web容器只会创建一个Servlet实例，所以多个用户发起请求时，会有多个线程处理Servlet代码，因此Servlet是线程不安全的。\n考虑以下代码：\n@WebServlet(name = &quot;ThreadSafeServlet&quot;, urlPatterns = &quot;/ThreadSafeServlet&quot;)public class ThreadSafeServlet extends HttpServlet &#123;    private String name;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        name = request.getParameter(&quot;name&quot;);        try &#123;            Thread.sleep(10000);//使线程沉睡10秒        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        response.getWriter().println(&quot;name:&quot; + name);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doPost(request, response);    &#125;&#125;\n\n10秒内在两个不同的浏览器窗口中的表单输入name并提交，假如在A浏览器中输入111，B浏览器中输入222，最后会发现A和B浏览器显示的name都是222。这是因为在第一个线程睡眠时，第二个线程修改了name的值，所有最后显示都是222，那么就产生了线程不安全问题。\n实际上Servlet，Context上下文作用域，HttpSession都是线程不安全的，只有request请求和局部变量是线程安全的。\n关于Servlet与http相关的应用，下一部分是这个\nServlet与http\n关于Web基础部分\nJavaWeb-http\n引用文章\nJavaWeb——HTTP详解\nJavaWeb——Servlet\n菜鸟教程Servlet部分\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaEE","JavaWeb","Servlet"]},{"title":"Servlet与会话管理","url":"/posts/45466.html","content":"为什么进行会话管理Web应用程序基于HTTP协议\n\nHTTP基于请求&#x2F;响应模式\n所有请求都是相互独立的，无连续性的\n\n\nHTTP是无连接的协议\n限制每次连接只处理一个请求\n\n\nHTTP是无状态的协议\n协议对于事务处理没有记忆能力\n\n\n\n对于简单的页面浏览或信息获取，HTTP协议即可胜任，但是对于需要客户端和服务器端多次交互的网络应用，则必须记住客户端状态\n会话就是一个客户端连续不断地和服务器端进行请求&#x2F;响应的一系列交互\n何为会话多次请求间建立关联的方式称为会话管理，或会话跟踪\n会话状态，指服务器与浏览器在会话过程中产生的状态信息\n会话管理是管理浏览器客户端和服务器端之间会话过程中产生的会话数据。\n会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话，主要有四种会话跟踪方法，设置隐藏表单字段，URL重写，Cookie和Session。常用的会话跟踪技术是Cookie和Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。\n浏览器客户端和服务器端的会话管理涉及的技术有Cookie技术与Session技术，两者的区别在于：\n\nCookie技术将会话数据保存在浏览器客户端\nSession技术将会话数据保存在服务器端\n\n会话的实现过程HTTP没有提供任何记住客户端的途径，服务器如何建立、维护与客户端的会话\n\n\nCookie技术如何理解Cookie技术Cookie实际上是存放在客户端浏览器的一小块文本。\n客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来记录用户状态。\nCookie的工作原理主要的记录用户状态，客户端浏览器第一次请求服务器后，服务器会颁发一个Cookie(name &#x3D;  ErgouTree，该Cookie就相当于那唯一的卡号)响应给客户端浏览器，以后客户端的每次请求都会带上这个Cookie，这样服务器就可以根据这唯一的Cookie识别不同的用户。\n特点\n\nCookie技术将会话数据保存在浏览器客户端。\nCookie数据只能是非中文的字符串类型的数据\n浏览器可以保存多个Cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie\n每个Cookie的大小限制为4KB\n\nCookie核心APICookie(String name, String value)   // 用户创建Cookie对象的构造函数void setPath(String uri)    // 设置cookie的有效访问路径，这个可以在浏览器内看，设置-&gt;内容设置-&gt;Cookie-&gt;查看所有Cookie和网站void setMaxAge(int expiry)    // 设置cokie的存活时间void setValue(String newValue)   // 设置cookie的值Cookie[] request.getCookies()    // 接收cookievoid response.addCookie(Cookie cookie)    // 发送cookie到浏览器端保存\n\nCookie的创建Cookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);response.addCookie(cookie);   // Cookie从servlet里发送到浏览器端\n\n创建Cookie对象，利用Cookie的构造函数来创建Cookie，Cookie的构造函数有两个参数，name和value，必须要有这两个参数，value固定为String类型的。\nCookie 是存放在浏览器端的，所以还需要把 Cookie 从 servlet 里发送到浏览器端，利用response里的addCookie方法可以做到，原理是通过在响应中设置 set-Cookie 标头，以 Key&#x2F;Value 键值对的形式发送到浏览器\n你可以使用google浏览器查看响应头中的set-Cookie标头，你能看到你刚刚添加的Cookie和它的属性值\n\n\n响应首部中黄色的部分就是从Servlet发送到浏览器的Cookie\n请求首部中红色划线部分是浏览器发回到服务器的Cookie，这个不是你刚创建的Cookie，因为你创建的Cookie刚发送到浏览器，之后你再请求一次就可以在请求首部看到你刚创建的Cookie。\nCookie的获取在Servlet中只能使用getCookies方法获取所有的Cookie，没有通过Cookie名来获取Cookie的方法。所以需要你自己来编写代码实现。\n&lt;%    // 如何获取Cookie    Cookie[] cookies = request.getCookies();   // 返回值类型为Cookie[]    if (cookies != null) &#123;        for (int i = 0; i &lt; cookies.length; i++) &#123;            System.out.println(cookies[i].getName() + &quot;: &quot; + cookies[i].getValue());        &#125;    &#125;%&gt;\n\nCookie的修改与删除Cookie并不提供修改，删除操作。\n如果要修改某个Cookie，需要新建一个同名的Cookie，并添加到response中就会覆盖原来的Cookie。\n下面的两行代码就可把username的value值 “kindleheart”改为”Hush”。\n// 修改Cookie的示例方法protected void modifyCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 假设我们要将用户名从旧值改为&quot;Hush&quot;    Cookie cookie = new Cookie(&quot;username&quot;, &quot;Hush&quot;);    cookie.setPath(&quot;/Demo&quot;);  // 设置与原始Cookie相同的路径    cookie.setMaxAge(7 * 24 * 60 * 60); // 保持相同的有效期    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已修改&quot;);&#125;\n\n删除Cookie的实现\n如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。\n// 删除Cookie的标准方法protected void deleteCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 1. 创建一个同名Cookie    Cookie cookie = new Cookie(&quot;username&quot;, &quot;&quot;);    // 设置值为空        // 2. 设置path与原始Cookie一致（重要！）    cookie.setPath(&quot;/Demo&quot;);        // 3. 设置生存期为0（立即失效）    cookie.setMaxAge(0);        // 4. 添加到响应中    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已删除&quot;);&#125;\n\n修改和删除Cookie时，新建的Cookie除value，maxAge之外的所有属性，例如name，path，domain等，都要与原Cookie完全一样。否则，浏览器会把这两个Cookie视为不同的Cookie，不允许覆盖，导致修改删除失败。\n服务的完整示例@Override   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       request.setCharacterEncoding(&quot;UTF-8&quot;);       // 获取表单数据       String username = request.getParameter(&quot;username&quot;);       String password = request.getParameter(&quot;pwd&quot;);       String rememberMe = request.getParameter(&quot;rememberMe&quot;);       // 简单的验证（实际项目中应该连接数据库验证）       if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;           // 登录成功           // 如果用户选择了&quot;记住我&quot;           if(&quot;true&quot;.equals(rememberMe)) &#123;               // 创建Cookie保存用户名               Cookie usernameCookie = new Cookie(&quot;username&quot;, username);               // 设置Cookie有效期为7天               usernameCookie.setMaxAge(7 * 24 * 60 * 60);               response.addCookie(usernameCookie);           &#125;else&#123;               // 用户没有选择记住我，删除可能存在的Cookie               Cookie usernameCookie = new Cookie(&quot;username&quot;, &quot;&quot;);               usernameCookie.setMaxAge(0); // 立即过期               response.addCookie(usernameCookie);           &#125;           // 创建会话           HttpSession session = request.getSession();           session.setAttribute(&quot;username&quot;, username);           // 重定向到欢迎页面           response.sendRedirect(&quot;&quot;);       &#125;else&#123;           // 登录失败           response.sendRedirect(&quot;index.jsp?error=1&quot;);       &#125;   &#125;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 初始化变量    String name = &quot;&quot;;    boolean isRemembered = false;        // 获取Cookie    Cookie[] cookies = request.getCookies();    if (cookies != null) &#123;        for (Cookie cookie : cookies) &#123;            // 查找用户名Cookie            if(cookie.getName().equals(&quot;username&quot;))&#123;                name = cookie.getValue();                isRemembered = true;            &#125;        &#125;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;用户登录&lt;/h2&gt;    &lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;        账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;1&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;        记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;        登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nCookie的属性除了name与value之外，Cookie还有其它的一些可选属性，比如注释、路径和域限定符、最大生存时间和版本号。\n每个属性对应着一个get方法和一个set方法。\n\n\n有效期Cookie的maxAge决定着Cookie的有效期，单位为秒，默认值为-1。\nCookie中通过getMaxAge()方法与setMaxAge()方法来读写maxAge属性。\n\nmaxAge &gt; 0：表示Cookie会在 maxAge 秒之后自动失效。浏览器会将 maxAge 为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在 maxAge 秒之前，登录网站时该Cookie仍然有效。\nmaxAge &lt; 0，则表示该Cookie仅仅在关闭窗口前有效。maxAge 为负数的Cookie，为临时Cookie，不会被持久化，不会被写到Cookie文件中，而是保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。\nmaxAge &#x3D; 0，有效时间为0，就表示为删除Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除。\n\nCookie的域名Cookie是不可跨域名的，同一个一级域名下的两个二级域名如 www.kindleheart.com 和 images.kindleheart.com 也不能互相使用Cookie，因为二者的域名并不严格相同。如果想所有kindleheart.com名下的二级域名都可以使用该Cookie，可以设置domain参数。\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setDomain(&quot;.kindleheart.com&quot;);response.addCookie(cookie);\n\nCookie的路径domain属性决定访问Cookie的域名，而path属性决定允许访问Cookie的路径(ContextPath)。\n如果只允许Demo工程下的程序使用Cookie，可以这么写：\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setPath(&quot;/Demo&quot;);response.addCookie(cookie);\n\n\n\nSeesion核心APIHttpSession getSession()    ——    得到session对象HttpSession getSession(boolean create)    ——  当create参数为true时，如果获取不到对应session对象就为浏览器创建一个session对象；如果create参数为false时，如果获取不到对应session对象就返回null。   void setAttribute(String name, Object value)    ——    保存会话数据到session对象Object getAttribute(String name)    ——    从session对象中获取会话数据void removeAttribute(String name)    ——     清除session对象中对应的会话数据void setMaxInactiveInterval(int interval)    ——    设置session的有效时间，默认情况是30分钟void invalidate()    ——    销毁session对象String getId()    ——    得到session编号\n\n理解SessionCookie可以让服务器跟踪每个客户端的访问，Cookie存放在客户端浏览器，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多，那么无形地会增加了客户端与服务器端的数据传输量，而Session正是解决这个问题的。\nSession存放在服务器端，同一个客户每次和服务器端进行交互时，不需要每次传回所有的Cookie值，而是只要传回一个ID，这个ID是客户端第一次访问时生成的，而且每个客户端都是唯一的，这样每个客户端都有了一个唯一的ID，客户端只需要传回这个ID就行了，这个ID通常是name为JSESSIONID的一个Cookie。\n实际上有以下三种方式使得Session正常工作。\n\n基于Cookie，如果没有修改Context容器的Cookies标识，则默认也是支持的。客户端每次请求的时候，Cookie会被返回到服务器，利用请求头中的Cookie标头。　　\n\n基于URL Path Parameter(URL重写)，默认支持。\n浏览器不支持Cookie或者用户把浏览器的Cookie功能关闭了，浏览器就会把该用户的Session的ID信息(JSESSIONID)重写到用户请求的URL参数中，服务器再从URL参数中解析出Session的ID。、\n首先我们把浏览器的Cookie关闭，再使用HttpServletRequest类提供的encodeURL(String url)实现地址重写，下面是一个计录浏览次数的小例子：\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       response.setContentType(&quot;text/html;charset=utf-8&quot;);       HttpSession session = request.getSession();       int count = 0;       if(session.getAttribute(&quot;count&quot;) != null) &#123;           int c = (int) session.getAttribute(&quot;count&quot;);           count = c + 1;       &#125;       session.setAttribute(&quot;count&quot;, count);       PrintWriter out = response.getWriter();       out.println(&quot;&lt;html&gt;&quot;);       out.println(&quot;&lt;body&gt;&quot;);       out.println(&quot;&lt;h1&gt;登入&quot; + count + &quot;次&lt;/h1&gt;&quot;);       //URL重写把JSESSIONID发送到服务器       out.println(&quot;&lt;a href=&#x27;&quot; + response.encodeURL(&quot;IndexServlet&quot;) + &quot;&#x27;&gt;click me&lt;/a&gt;&quot;);       out.println(&quot;&lt;/body&gt;&quot;);       out.println(&quot;&lt;/html&gt;&quot;);       out.close();   &#125;  \n\n在浏览器的地址栏URL里文件名后面URL参数前面可以看到 jsessionid &#x3D; XXX。　\n注意：如果浏览器支持Cookie，那么Tomcat仍然会解析Cookie里的中的Session ID，并会覆盖URL中的Session ID，也就是你在URL就中看不到 jsessionid &#x3D; XXX了。\n\n基于SSL，默认不支持，只有connector.getAttribute(“SSLEnabled”)为TRUE时才支持。\n\n\nSession的生命周期\nSession的创建\n\n\nSession在用户第一次请求服务器的时候自动创建，只有访问Servlet，JSP等动态资源才会创建，访问HTML，IMAGE等静态资源并不会创建Session，如果没有创建成功，也可以使用request.getSession(true)强制创建Session。\n\n\nSession的获取\n\n\n通过HttpServletRequest对象的getSession方法获取一个HttpSession实例。\n//获取此会话HttpSession session = request.getSession();\n\n\nSession的撤销\nSession的撤销有三种可能的情况：\n\nSession超时，Session的默认有效期为30分钟，你如果30分钟内没有请求服务器，Session就会撤销，你30分钟内请求了服务器，服务器就认为你active了一次，重新计算有效期。\n可以在web.xml文件里或者使用setMaxInactiveInterval(20 *  60)方法设置Session的有效期，注意的是web.xml文件里参数以分为单位，15分钟，setMaxInactiveInterval(20 * 60)中的参数以秒为单位，这里是20分钟。\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;session-config&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;  &lt;/session-config&gt;&lt;/web-app&gt;\n\n//设置Session的有效期为20分钟session.setMaxInactiveInterval(20 * 60);\n\n通过会话对象使用invalidate方法使Session无效。\n//使此会话无效session.invalidate();\n\n程序结束\n\n\n\n\nSession的属性操作\nSession增加属性\nSession中的属性也是以键值对的形式存储的，用setAttibute(name, value)方法添加属性，value是Object对象的，所以value不限于String类型，可以是任何数据类型。\n//添加一个name为count的属性，值为250int count = 250;session.setAttribute(&quot;count&quot;, count);\n\nSession获取属性值\n//获取name为count的value值，需要强转int count = (int) session.getAttribute(&quot;count&quot;);\n\nSession修改属性\nSession修改属性，直接使用setAttibute(name, value)方法覆盖相同name的Session即可。\n//把name为count的属性值由250修改到520session.setAttribute(&quot;count&quot;, 250);session.setAttribute(&quot;count&quot;, 520);\n\nSession删除属性\nSession删除属性，使用removeAttribute(name)方法，删除对应name的属性。\n//删除name为count的属性session.removeAttribute(&quot;count&quot;);\n\n应用实例@Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;pwd&quot;);        String rememberMe = request.getParameter(&quot;rememberMe&quot;);        // 简单的登录验证        if(isValidUser(username, password)) &#123;            // 创建或获取session            HttpSession session = request.getSession();            // 存储登录状态            session.setAttribute(&quot;isLoggedIn&quot;, true);            session.setAttribute(&quot;username&quot;, username);            // 如果用户选择了&quot;记住我&quot;            if(&quot;true&quot;.equals(rememberMe)) &#123;                session.setAttribute(&quot;rememberMe&quot;, true);                // 设置session超时时间（7天）                session.setMaxInactiveInterval(7 * 24 * 60 * 60);            &#125;else &#123;                // 不记住则移除属性                session.removeAttribute(&quot;rememberMe&quot;);                // 使用默认的超时时间            &#125;            // 重定向到欢迎页面            response.sendRedirect(&quot;welcome.jsp&quot;);        &#125; else &#123;            // 登录失败            response.sendRedirect(&quot;index.jsp?error=1&quot;);        &#125;    &#125;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 检查session中是否有记住的用户名    String name = &quot;&quot;;    boolean isRemembered = false;    HttpSession existingSession = request.getSession(false);    if (existingSession != null &amp;&amp; existingSession.getAttribute(&quot;rememberMe&quot;) != null) &#123;   \t    // 取出session中存储的用户名，一般只是取出，不修改        name = (String) existingSession.getAttribute(&quot;rememberMe&quot;);        isRemembered = true;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录(Session版)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;用户登录(Session版)&lt;/h2&gt;&lt;% if (&quot;1&quot;.equals(request.getParameter(&quot;error&quot;))) &#123; %&gt;&lt;p style=&quot;color:red;&quot;&gt;用户名或密码错误!&lt;/p&gt;&lt;% &#125; %&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;    账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;    记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;    登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n比较ServletContext，HttpServletRequest和HttpSessionServletContext\n\n范围最大,应用程序级别的,整个应用程序都能访问；\n是Servlet上下文对象，在服务器启动阶段解析web.xml文件创建ServletContext对象，在同一个web app中所有的Servlet对象共享同一个ServletContext对象。该对象一旦创建不会被销毁，除非将服务器停掉。\n一般存储在该对象中的数据首先是所有用户共享的，不会被修改的，少量数据。\nServletContext对象传递数据可以跨Servlet、跨请求、跨用户(跨会话)传递数据。\n\nHttpSession\n\n次之,会话级别的，在当前的浏览器中都能訪问，不论是在同一浏览器开多少窗体，都能够访问，可是换个浏览器就不行了，就必须又一次创建session；\n每一个用户都有一个这样的对象，是一个用户级别的对象，存储在该对象中的数据一般都是该用户专属的数据\nHttpSession对象传递数据可以跨Servlet、跨请求(这些请求必须属于同一个会话)、但是不能跨用户传递数据。\n\nHttpServletRequest\n\n范围最小,请求级别,请求结束,变量的作用域也结束（也就是仅仅是一次访问,访问结束，这个也结束）。\n是请求对象，一次请求一个对象，每一次请求都会新建一个请求对象，是一个请求级别的对象，存储该对象中的数据一般都是请求级别的数据，一次请求之后这个数据就不再使用的数据可以存储在该对象中\nHttpServletRequest对象传递数据可以跨Servlet，但是不能跨请求，更不能跨用户传递数据。\n\n尽量从小范围向大范围使用。(考虑原则：request&lt; session &lt; application)\nServletContext、HttpSession、HttpServletRequest接口的对比：\n以上都是范围对象:\n\nServletContext application; 是应用范围\nHttpSession session; 是会话范围\nHttpServletRequest request; 是请求范围\n\n三个范围的排序：application &gt; session &gt; request\n\napplication完成跨会话共享数据\nsession完成跨请求共享数据，但是这些请求必须在同一个会话当中\nrequest完成跨Servlet共享数据，但是这些Servlet必须在同一个请求当中【转发】\n\n使用原则：有小到大尝试，优先使用小范围。例如：\n\n登录成功之后，已经登录的状态需要保存起来，可以将登录成功的这个状态保存到session对象中。\n登录成功状态不能保存到request范围中，因为一次请求对应一个新的request对象。\n登录成功状态也不能保存到application范围中，因为登录成功状态是属于会话级别的，不能所有用户共享。\n\nCookie与Session的比较Cookie与Session都是为了保持用户访问的连续状态，之所以为了要保持这种状态，一方面是为了实现业务方便，另一方面就是简化服务器端的程序设计，提高访问性能。但是两者的实现原理不太一样，各自都有优点和缺陷，下面通过比较说明这两者的特点和适用场合。\n\n存取方式上\nCookie中只能保持ASCLL字符串，如果存取Unicode字符或者二进制数据，需要进行UTF-8，GBK，或者BASE64等方式的编码，而Session中可以存取任何类型的数据。\n\n隐私安全上\nCookie存放在客户端浏览器，对客户端是可见的，客户端的一些程序可能会窥探复制甚至修改Cookie中的内容。而Session存放在服务器端，对用户是透明的，不存在敏感信息泄露的危险。\n\n有效期上\nCookie可以设置长期有效，浏览器关闭也有效，虽然Session可以设置很长的有效期，但是Session依赖名为JSESSIONID的Cookie，该Cookie的maxAge默认为-1，浏览器关闭Cookie就失效，所以该Session也就失效了。\n\n服务器的负担上\nSession存放在服务器端，每个用户都会产生一个Session。如果并发非常大的网站，会产生大量的Session，消耗大量内存，因此像Baidu，Google这样并发量极高的网站是不会使用Session来追踪会话的，而Cookie保存在客户端，不占用服务器资源，对于并发量极高的网站Cookie是更好的选择。\n\n从浏览器支持上\nCookie是需要浏览器支持的，如果浏览器不支持Cookie，就需要使用Session以及URL地址重写。\n\n从跨域名上\nCookie支持跨域名访问，只要设置domain属性即可，但Session不能够跨域名访问，Session仅在他的域名下有效。\n\n\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaEE","JavaWeb","Servlet"]},{"title":"Spring Farmewrok part1-Spring生态介绍和入门","url":"/posts/26666.html","content":"Spring 和 Spring FrameworkSpring、Spring Framework、Spring Boot、Spring Cloud的区别。\n首先不少人乐意把  Spring Framework 叫做 spring，但是 spring framework 只是 spring中的一个模型，核心是Ioc和aop，而spring是一个生态，spring 是框架。\n\n\n\n\nSpring是一个生态体系（也可以说是技术体系），是集大成者，它包含了 Spring Framework、Spring Boot、Spring Cloud 等（还包括Spring Cloud data flow、spring data、spring integration、spring batch、spring security、spring hateoas），如下图所示（部分截图）：\n\nSpring FrameworkSpring Framework是整个spring生态的基石，它可是硬生生的消灭了Java官方主推的企业级开发标准EJB，从而实现一统天下。\nSpring Framework为基于现代企业应用提供了一个全面的编程和配置的模型 - 在任何类型部署平台上\nSpring Framework为依赖注入、事务管理、WEB应用、数据访问等提供了核心的支持，专注于企业级应用程序的“管道”，以便开发团队可以专注于应用程序的业务逻辑。\nSpring Boot搭建项目的脚手架、黏合剂，整合周边生态\nSpring Boot这家伙简直就是对Java企业级应用开发进行了一场浩浩荡荡的革命。如果稍微有几年工作经验的老油条，应该都记得以前的Java Web开发模式：Tomcat + WAR包。\nSpring Boot能够让你非常容易的创建一个单机版本、生产级别的基于spring framework的应用。然后，”just run”即可。Spring Boot默认集成了很多第三方包，让构建独立的生产级别的Spring应用变得简单，开箱即用，以便你能以最小的代价开始一个项目。\nSpring CloudSpring Clound的出现真正简化了分布式架构的开发\nSpring Cloud事实上是一整套基于Spring Boot的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：配置管理、注册中心、服务发现、限流、网关、链路追踪等。\nSpring Boot是build anything，而Spring Cloud是coordinate anything，Spring Cloud的每一个微服务解决方案都是基于Spring Boot构建的：\n\n\nSpring Cloud AlibabaSpring Cloud Alibaba为分布式应用开发提供一站式解决方案，它包含分布式应用程序开发所需的所有组件，使你可以轻松地使用Spring Cloud开发应用程序。\n使用Spring Cloud Alibaba，你只需要增加一些注解和少量的配置，即可将Spring Cloud应用连接到阿里巴巴的分布式解决方案，并可使用阿里巴巴的中间件构建分布式系统\nSpring Framework主要包括什么Spring Framework主要包括几个模块：\n\n支持IoC和AOP的容器；\n支持JDBC和ORM的数据访问模块；\n支持声明式事务的模块；\n支持基于Servlet的MVC开发；\n支持基于Reactive的Web开发；\n以及集成JMS、JavaMail、JMX、缓存等其他模块。\n\nSpring版本5.x 和 6.x的区别\n\n\nSpring官网是spring.io\n为什么要学Spring FrameworkSpring Framework 是其他 Spring 子项目的基础\n无论是传统企业应用还是云原生微服务，Spring Framework 的核心思想（如 IoC、AOP）均贯穿始终\nSpring Framework 是整个 Spring 技术栈的基石，其他子项目（如 Spring Boot、Spring MVC、Spring Cloud  等）均基于其核心功能扩展。它通过控制反转（IoC）、依赖注入（DI）和面向切面编程（AOP）等机制，为上层模块提供统一的基础设施支持\n而且S pring Framework 其分层架构（如 Core、AOP、Data Access、Web 等模块）允许开发者按需选择功能，避免冗余依赖。这种灵活性使得 Spring 能够适配从传统单体应用到现代微服务的多样化需求\nSpring Framework 提供与多种企业级技术（如 JDBC、JPA、Hibernate、消息队列等）的无缝集成能力，简化了复杂系统的开发\n学习 Spring Framework 是掌握 Spring Boot（快速开发）、Spring Cloud（微服务）等高级框架的前提。例如，Spring Boot 的自动配置机制本质上是基于 Spring Framework 的条件化 Bean 加载实现\n\nSpring Framework 官方文档\nSpring Framework 源码\nSpring 入门课程（W3CSchool）\n\nSpring Framework特点\n非侵入式：Spring Framework开发应用程序时，Spring 对应用程序本身的结构影响特别小，应用代码基本不会被 Spring 特定的 API 所束缚。开发者能够在不依赖 Spring 框架的环境下对代码进行编译、测试和运行。当项目需要更换框架或者调整架构时，由于代码没有与 Spring 框架深度绑定，迁移工作会相对轻松。开发者可以逐步移除 Spring 相关的配置和依赖，而不会对业务逻辑代码造成重大影响。\n控制反转IoC：控制反转是 Spring 框架的核心特性之一，它将对象的创建和依赖关系的管理从应用程序代码转移到了 Spring 容器中。通过控制反转，对象之间的依赖关系变得更加灵活，降低了组件之间的耦合度。\n面向切面编程AOP：面向切面编程允许开发者将横切关注点（如日志记录、事务管理、权限验证等）从业务逻辑中分离出来，以提高代码的可维护性和复用性。通过 AOP，我们可以将通用的横切关注点代码封装到切面中，在多个业务模块中复用这些代码，减少了代码的重复编写。\n容器：Spring 框架提供了强大的容器功能，用于管理对象的生命周期和依赖关系。IoC是一个容器，包含并且管理组件对象的生命周期，组件享受到了容器化的管理，屏蔽了大量的细节。Spring 容器通过依赖注入的方式将对象之间的依赖关系注入到对象中，使得对象之间的协作更加灵活。\n组件化：Spring 鼓励开发者将应用程序拆分成多个独立的组件，每个组件负责特定的功能。开发者可以将不同的业务功能封装成独立的组件，这些组件可以独立开发、测试和部署。组件化的开发方式使得代码结构更加清晰，易于维护和扩展。当需要添加新的功能时，只需要开发新的组件并将其集成到应用中即可。\n一站式：Spring 框架提供了一站式的解决方案，涵盖了企业级应用开发的各个方面。可以整合各种企业应用的开源框架和优秀的第三方类库。\n\nSpring6 的模块组成Spring Framework 主要是围绕 Core 部分\n\n\nSpring Core：核心容器\n\n\nSpring AOP\n\n\nSpring Data Access\n\n\nSpring Web\n就是大家通常说的Spring MVC部分\n\n\nSpring Message 和 Spring test\n\n\n如何创建工程父工程 spring6    子工程 你自己项目名称\n开发步骤：\n\n引入spring相关依赖\n创建类，定义属性和方法\n按照spring要求创建配置文件   xml\nspring配置文件配置相关信息\n进行测试\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Hello World","url":"/posts/16107.html","content":"常用命令Quick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nWrite Draftshexo n draft draft1\n\n在source\\目录下创建_drafts目录，并生成一个draft1.md文件\n当你编辑完草稿后，可以把文章推送到_posts目录下\n$ hexo publish &lt;file_name&gt;\n\n或\nhexo --draft\n\nDeploy In Github# 清理旧文件hexo clean# 生成新文件hexo g# 部署到 GitHub Pageshexo dhexo server\n\n\n\n引用图片![alt](path [title])\n\npath是必选的，表示图片的路径，可使用绝对或相对路径。\nalt是可选的，是图片无法加载时的替代描述文本。\ntitle是可选的，是图片的标题\n将所有文章的图片放到source/images 文件夹中，然后使用markdown语句引用图片\n或\n为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：\n\n在博客根目录打开_config.yml文件做如下修改：yaml post_asset_folder: true\n然后使用hexo n text命令后创建一个使用post布局名为text的文章，你将发现hexo在\\source\\_post文件夹下创建了一个\\text文件夹以及同名的.md文件：\n最后就可以打开text.md文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。注意：请不要自作聪明将text.md文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用\n\nhexo插入图片的原生语法使用 Hexo 的 asset_img 标签\n&#123;% asset_img 文件名.后缀 图片描述 %&#125;\n\n\n需要将图片放在 source/images/ 目录下（或 _config.yml 中 post_asset_folder: true 时与文章同名的文件夹中）\n文件名需要包含后缀（如 .jpg, .png 等）\n\n使用 HTML 的 标签&lt;img src=&quot;图片路径&quot; alt=&quot;图片描述&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;\n\n\n\n\n\n插入视频&lt;video width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;source src=video_path&gt;&lt;/video&gt;\n\n\nvideo_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。\nwidth和height是视频区块的宽度和高度，可自定义。\n\n引用和代码区块&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content...&#123;% endblockquote %&#125;\n\n例如：\nQuick Start\nluzhengli hello-worldluzhengli.github.io/2020/04/10/hello-world\n\n还有一种简单的引用语法：\n&gt; 这也是引用&gt;&gt; 引用1&gt;&gt; 饮用2\n\n\n这也是引用\n引用1\n饮用2\n\n代码用Hexo的太麻烦了\n用markdown原来的&#96;&#96;&#96;得了\nMermaid画流程图语法\n\n    内容\n  \n\n\n\nbutterfly主题的标签外挂语法&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;&#123;% note [class] [no-icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125;\n\n\n\nbutterfly主题下的tag-hide如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。\ninline 在文本里面添加按钮隐藏内容，只限文字\n( content 不能包含英文逗号，可用 &amp;sbquo;)\n&#123;% hideInline content,display,bg,color %&#125;\n\n参数\t解释content\t文本内容display\t【可选】按钮显示的文字bg\t【可选】按钮的背景颜色color\t【可选】按钮文字的颜色\n哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人? &#123;% hideInline ErgouTree %&#125;\n\n哪个英文字母最酷？ 查看答案因为西装裤(C装酷)\n门里站着一个人? ClickErgouTree\nbutterfly主题下的tabs&#123;% tabs Unique name, [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\n\n\n&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\ntest1 1test1 2test1 3This is Tab 1.This is Tab 2.This is Tab 3.\n\n&#123;% tabs test4 %&#125;&lt;!-- tab 第一个Tab --&gt;**tab 名字为第一个 Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有 Tab 名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\n第一个Tab炸弹tab 名字为第一个 Tab只有图标 没有 Tab 名字名字+icon\n\n\n\n文章写完之后编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。\n生成&#x2F;删除静态文件\n 生成静态文件命令：hexo generate或 hexo g 删除静态文件命令：hexo clean\n\n正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。\n如果发生了一些错误，可以先删除静态文件，然后再重新生成。hexo g命令还提供了一个参数-f提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。\n启动本地端口\n 命令：hexo server或 hexo s\n\n"},{"title":"markdown常用语法","url":"/posts/43275.html","content":"markdown常用语法标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n#后必须要有空格还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。Heading level 1===============Heading level 2---------------在实际渲染中，’#’ 号数量对应标题级别，一个 ‘#’ 是一级标题，两个 ‘#’ 是二级标题，以此类推。#的叠加可以很多，但是当过多之后，会变的比正常字体还要小，可以利用这个特性***## 段落和换行#### 换行句子末尾双空格代表换行。或者多个空格进行换行 貌似也可以#### 段落处理段落就是用空白行将一行或多行文本进行分割注意：不要用空格（spaces）或制表符（ tabs）缩进段落。***## 强调*斜体文本*   前后各添加一个星号或下划线  _斜体文本_**粗体文本**   前后各添加两个星号或下划线  __粗体文本__***加粗斜体文本***~~删除线文本~~粗体和斜体可以混合用***## 代码块行内代码：用反引号 包裹代码片段，如System.out.println(“Hello World”);代码块：使用三个反引号  包裹代码块，并可在其后指定语言（可选，用于语法高亮）​```代码语言内部代码注意```需要闭合  貌似三个波浪号也可以~~~ ~~~### 链接- **行内式链接**：`[链接文本](链接地址 &quot;可选标题&quot;)`，例如：[百度](https://www.baidu.com &quot;百度首页&quot;)- **参考式链接**：[链接文本][链接标识][链接标识]: 链接地址 &quot;可选标题&quot;***## 引用&gt; 这是一段引用文本&gt; 引用可以有多行&gt; 若有多段引用，可在每段前加 &gt; 符号。&gt; 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。块引用可以包含其他 Markdown 格式的元素。但并非所有元素都可以使用我已经验证了强调和段落换行表格可以用​&#96;&#96;&#96;markdown&gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用&gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用  &gt; &gt; &gt;&gt; &gt; &gt; ***## 分割\n\n以上三种写法都可生成一条分隔线。  ***## 列表### 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。  数字不必按数学顺序排列，但是列表应当以数字 1 起始。  ​```markdown1. 列表项12. 列表项2   1. 子列表项1   2. 子列表项23. 列表项3\n无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n- 列表项1  - 子列表项1  - 子列表项2+ 列表项2* 列表项3\n列表中来回嵌套的问题在如果需要列表中嵌套其他元素，基本所有都可以，甚至图片，拿代码块举例子要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符  \n1.  列表行12.  下面是代码        &amp;&lt;html&gt;          &amp;lt;head&gt;            &amp;lt;title&gt;Test&amp;lt;/title&gt;          &amp;lt;/head&gt;3.  同样的，列表也可以嵌套列表\n\n列表行1\n\n下面是代码\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Test&amp;lt;/title&gt;\n  &lt;/head&gt;\n\n\n同样的，列表也可以嵌套列表\n\n\n\n表格基本表格语法表头与内容分隔：使用 | 来分隔表格的列，表头与表格内容之间通过 — 分隔，— 还可用于指定列的对齐方式。  \n| 表头1 | 表头2 | 表头3 || :---: | :-- | --: || 居中内容 | 左对齐内容 | 右对齐内容 || 第二行数据1 | 第二行数据2 | 第二行数据3 |\n\n\n\n表头1\n表头2\n表头3\n\n\n\n居中内容\n左对齐内容\n右对齐内容\n\n\n第二行数据1\n第二行数据2\n第二行数据3\n\n\n表格内容换行如果表格内容需要换行，可以直接在 Markdown 源文件中使用 HTML 的  标签。支持扩展语法的编辑器中，也可以通过在单元格内容中按回车键进行换行，然后适当缩进以保持格式。  \n| 列1 | 列2 || ---- | ---- || 长内容 &lt;br&gt; 换行显示 | 其他内容 |\n\n\n\n列1\n列2\n\n\n\n长内容  换行显示\n其他内容\n\n\n合并单元格标准 Markdown 语法本身不支持直接合并单元格。不过，在一些特定的 Markdown 渲染器（如在 Markdown 中嵌入 HTML 时），可以使用 HTML 的  标签来实现。  \n\n图片行内式图片：例如：，换成你自己的图片链接参考式图片：\n![替代文本][图片标识][图片标识]: 图片地址 &quot;可选标题&quot;\n\n任务列表任务列表可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。\n- [x] Write the press release- [ ] Update the website- [ ] Contact the media\n\n Write the press release\n Update the website\n Contact the media\n\n\n转义字符在字符前面添加反斜杠字符 \\ ，这样markdown会识别不去执行该符号例如* Without the backslash, this would be a bullet in an unordered list.  \n\nWithout the backslash, this would be a bullet in an unordered list.  不加就会被识别成列表\n\n\n内嵌html代码对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到Markdown 文本中即可html里面咋用，在这里就可以咋用  \n\n插入表情符号可以简单地从Emojipedia 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。\n目录导航[[TOC]]  \n隐藏注释\n数学公式本质上就是插入latex代码，但是在markdown中插入latex代码需要用两个$符号\n行内公式：$E=mc^2$块级公式：$$\\begin&#123;bmatrix&#125;1 &amp; 0 \\\\0 &amp; 1\\end&#123;bmatrix&#125;$$\n\n流程图（需渲染器支持）`&#96;&#96;mermaid\ngraph TD\n  A[开始] –&gt; B(处理逻辑)\n  B –&gt; C{判断}\n  C –&gt;|是| D[结果1]\n  C –&gt;|否| E[结果2]\n`&#96;&#96;\ngraph TD\n    A[开始] --&gt; B(处理逻辑)\n    B --&gt; C&#123;判断&#125;\n    C --&gt;|是| D[结果1]\n    C --&gt;|否| E[结果2]\n\n","categories":["实用","语言方面"],"tags":["语言方面","实用工具","常用知识"]},{"title":"把Hexo博客配置到Github Pages下","url":"/posts/53748.html","content":"使用 Hexo+GitHub 搭建个人博客前情提要你需要自己去安装nodejs和git的环境，因为Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。\n这种教程csdn一搜一大堆啊，基本照着做都是下一步和最后的配置环境变量\n\nNode.js：https://nodejs.org/zh-cn\n\nGit：https://git-scm.com/downloads\n\n\n安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version 并回车，出现程序版本号即可。\n然后你需要自己去注册一个GitHub账号，这里强烈建议设置SSH密钥\n安装Hexo新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog\n安装Hexo使用 npm 一键安装 Hexo 博客程序：\n注意：建议之后所有使用命令行安装操作都使用 管理员模式下的cmd\nnpm install -g hexo-cli\n\n比较难绷的是安装时候界面没有任何反应，而且时间还不短\n初始化Hexo初始化并安装所需组件\nhexo init      # 初始化npm install    # 安装组件\n\n完成后依次输入下面命令，启动本地服务器进行预览：\nhexo g   # 生成页面hexo s   # 启动预览\n\n访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！\n\n如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。\n博客文件目录结构\n创建一个Github仓库来存放你的静态页面GitHub 主页右上角加号 -&gt; New repository：\n​\t注意，这里的仓库名字是 用户名.github.io   最好选上 “Initialize this repository with a README”\n此时如果你在这个仓库上配置博客的话，博客地址为：https://用户名.github.io\n部署到Github Pages本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。\n首先安装 hexo-deployer-git：\nnpm install hexo-deployer-git --save\n\n然后修改博客根目录下的 _config.yml 文件末尾的 Deployment 部分，修改成如下：\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: main\n\n这里说一下yml文件的格式，yml缩进有严格的格式要求，而且每个字段后的冒号之后必须有空格才能输入有效\n完成后运行 hexo d 将网站上传部署到 GitHub Pages。\n完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。\n绑定域名博客搭建完成使用的是 GitHub 的子域名（用户名.http://github.io），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。\n建议这里使用免实名的域名，实名一个域名比较麻烦，而且要等\n域名注册和解析\n域名注册和解析教程：Namesilo 域名购买及使用教程\n\n按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 用户名.github.io。\n\n绑定域名到 Hexo 博客进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如 http://www.example.com，保存名称为 “CNAME”，格式为 “所有文件”（无 .txt 后缀）。\n清除缓存等文件并重新发布网站：\nhexo clean   # 清除缓存文件等hexo g       # 生成页面hexo s       # 启动预览\n\n现在就可以使用自己的域名访问 Hexo 博客了。\n开启HTTPS配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。\n\nHTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！\n关于使用发布文章进入博客所在目录，右键打开 Git Bash Here，创建博文：\nhexo new &quot;My New Post&quot;\n\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。\n写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。\nhexo g   # 生成页面hexo d   # 部署发布\n\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。\n---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文\n\n\n\n常用命令hexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助\n\n我的另一篇博客也提到了hexo命令的基本用法，可以看看\nHexo命令的基本用法\n","categories":["教程","配置教程"],"tags":["Hexo相关","教程","部署"]},{"title":"洛谷P1631序列合并Java题解","url":"/posts/48002.html","content":"\n\n题目分析给定两个长度为 $N$ 的有序数组 $A &#x3D; \\{a_1, a_2, \\ldots, a_N\\}$ 和 $B &#x3D; \\{b_1, b_2, \\ldots, b_N\\}$，求所有 $a_i + b_j$ 组合中的前 $N$ 个最小和。\n思路开个 N^2 大小的数组，直接计算所有 $N^2$ 个和并排序的时间复杂度为 $O(N^2 \\log N)$，这在 $N \\leq 10^5$ 时显然不可行。\n有序数组存在特性：数组 $A$ 和 $B$ 已分别按升序排列，因此对于固定的 $a_i$，$a_i + b_j$ 的值随 $j$ 增大而单调递增。\n考虑使用堆，观察题中的两个数组： [ a 1 , a 2 , … , a N ] ， [ b 1 , b 2 , … , b N ]，对这两个数组分别从小到大排序，变成两个有序队列。这样，从A和B中各任取一个数相加得到N^2个和，可以把这些和看成形成了n个有序表&#x2F;队列：\n 考虑多路归并： 将每个 $a_i$ 与 $B$ 数组相加得到的序列视为一个有序队列，则总共有 $N$ 个有序队列：$$\\begin{aligned}   Q_1 &amp;: a_1 + b_1,\\ a_1 + b_2,\\ \\ldots,\\ a_1 + b_N \\   Q_2 &amp;: a_2 + b_1,\\ a_2 + b_2,\\ \\ldots,\\ a_2 + b_N \\   &amp;\\vdots \\   Q_N &amp;: a_N + b_1,\\ a_N + b_2,\\ \\ldots,\\ a_N + b_N \\   \\end{aligned}$$我们的目标是合并这些队列，找到前 $N$ 小的元素。\n由所有的 a i + b j  便可以组成以下 N 个偏序集:\n\n\n显然，在这 N 个偏序集中，都能够保证是有序的（单调递增）\n因此，对每个单独的偏序集而言，其始终满足：ai + bj &lt;&#x3D; ai + b(j+1)\n同时，可断言 a 1 + b 1 为所有 a i + b j  组合中的最小值； a N + b N 为所有 a i + b j 组合中的最大值；\n所以，我们就能在 O(1)  的时间复杂度内，从构建好的偏序集中取出当前最小值\n使用最小堆维护当前所有队列的队首元素。每次取出堆顶元素（当前最小值），并将该元素所在队列的下一个元素加入堆中。\n建堆和取值策略如下：\n\n把每个偏序集中的最小元素加入到小根堆 heap 中，即 heap &#x3D; {a1+b1,a2+b1,…,aN+b1} ；\n从小根堆 h e a p heap heap 中取出根元素（即当前堆里的最小值），假设取出的元素为 a i + b j，记弹出数 +1；\n从取出元素所在的偏序集中，取出仅比此小的元素，ai + b (j+1)，将其插入到小根堆 heap 中\n若弹出数不为  N，则继续执行 2；否则结束取值\n\n\n初始化堆将每个队列的第一个元素（即 $a_i + b_1$）加入堆，记录对应的 $i$ 和当前 $b$ 的索引 $j&#x3D;1$。\n\n迭代取最小值重复 $N$ 次：\n\n取出堆顶元素 $a_i + b_j$，加入结果集。\n若 $j+1 \\leq N$，将 $a_i + b_{j+1}$ 加入堆中，并更新索引为 $j+1$。\n\n\n去重与边界处理使用三元组 $(sum, i, j)$ 存储堆元素，确保同一队列中不同位置的元素能被正确追踪。\n\n\n复杂度分析\n\n时间复杂度：$O(N \\log N)$，每次堆操作的时间为 $O(\\log N)$，共进行 $O(N)$ 次。\n空间复杂度：$O(N)$，堆中最多存储 $N$ 个元素。\n\nimport java.util.Arrays;import java.util.PriorityQueue;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n];        int[] b = new int[n];        // 读取输入数据        for (int i = 0; i &lt; n; i++) &#123;            a[i] = sc.nextInt();        &#125;        for (int i = 0; i &lt; n; i++) &#123;            b[i] = sc.nextInt();        &#125;        sc.close();        // 对数组排序        Arrays.sort(a);        Arrays.sort(b);        // 使用优先队列（小根堆）        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((x, y) -&gt; x[0] - y[0]);        // 初始化堆：将每个a[i]与b[0]的和加入堆        for (int i = 0; i &lt; n; i++) &#123;            pq.offer(new int[]&#123;a[i] + b[0], i, 0&#125;);        &#125;        // 查找前 n 小的值        StringBuilder sb = new StringBuilder();        while(n-- &gt; 0)&#123;            int[] curr = pq.poll();            int sum = curr[0];            int aIdx = curr[1];            int bIdx = curr[2];            sb.append(sum).append(&quot; &quot;);            // 如果当前b索引+1有效，则将下一个和加入堆            if (bIdx + 1 &lt; b.length) &#123;                pq.offer(new int[]&#123;a[aIdx] + b[bIdx + 1], aIdx, bIdx + 1&#125;);            &#125;        &#125;        System.out.println(sb.toString().trim());    &#125;&#125;\n\nAC:\n\n\n","categories":["算法类","题解"],"tags":["算法","题解","洛谷","数据结构"]},{"title":"自定义注解","url":"/posts/13512.html","content":"注解的基本结构以重写为例子了解基本结构package java.lang;import java.lang.annotation.*;/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: *  * &lt;ul&gt;&lt;li&gt; * The method does override or implement a method declared in a * supertype. * &lt;/li&gt;&lt;li&gt; * The method has a signature that is override-equivalent to that of * any public method declared in &#123;@linkplain Object&#125;. * &lt;/li&gt;&lt;/ul&gt; *  * @author  Peter von der Ah&amp;eacute; * @author  Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\n\n注解的名称：\npublic @interface Override &#123;&#125;\n\n注解的元注解\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)\n\n这两个注解是注解中用到最多的元注解\n总结：\n注解分为两部分 :\n\n元注解 ;\n\npublic @interface 注解名称 ;\n\n\n注解的本质按照 public @interface 注解名称 格式 , 写出一个注解 , 编译该注解代码生成 Annotation.class 字节码文件 ;\npublic @interface Annotation &#123;&#125;\n\n使用 javap 命令反编译 Annotation.class 字节码文件 , 查看该注解的实际代码 ;\n发现输出\npublic interface Annotation extends java.lang.annotation.Annotation &#123;&#125;\n\n所以说，注解的本质是一个 interface 接口 , 注解接口默认继承了 java.lang.annotation.Annotation 接口 ;\n有如下关键特性：\n\n注解接口隐式继承Annotation接口\n不能显式实现其他接口\n不能包含泛型参数\n不能抛出异常\n\n注解的属性注解的属性注解的本质是接口 , 接口中可以定义 常量 和 方法 ;\n在注解中定义 接口方法 , 就是 注解的属性 ;\n为注解添加属性 : 接口中的方法都是抽象方法 , 其中 public abstract 可以省略 ;\npublic @interface Annotation &#123;    public abstract String path();   // Annotation接口 实现的接口 Annotation 中定义的注解属性(抽象方法)&#125;\n\n使用\n@注解名称(属性名称 = 属性值)\n\n@Annotation(path = &quot;&quot;)Student(String name, int age)&#123;&#125;\n\n属性定义规则\npublic @interface RequestMapping &#123;    String path();                // 必需属性    String method() default &quot;GET&quot;;// 可选属性    String[] params() default &#123;&#125;; // 数组属性&#125;\n\n\n\n\n\n注解的属性类型注解中定义了属性 , 在使用注解时 , 需要 给 注解属性 赋值 ;\n定义 注解属性 时 , 可以 使用 default 关键字 指定属性默认值 \nint intValue() default 666;   // 制定 注解属性 intValue 值类型为 int 整型 , 默认值 666 \n\n\n如果 注解属性 指定了默认值 , 在使用注解时 , 可以选择 不为该属性赋值 ( 此时使用默认属性值 ) , 也可以进行赋值 ( 指定一个新的属性值 ) ;\n\n如果 注解属性 没有指定默认值 , 则使用 注解 时 , 必须为其指定一个默认值 , 否则编译时报错 ;\n\n\n注解属性 ( 接口方法 ) 返回值类型要求 :\n\n基本数据类型 : byte , short , int , long , float , double , char , boolean ;\n字符串类型 : String ;\n枚举类型 : enum ;\n注解类型 ;\n其他注解类型\n以上类型的数组形式 ，不允许多维数组\n\n禁止的类型：\n\n自定义对象类型\n泛型类型（如List）\nnull值（默认值不能为null）\n\n注解属性返回值必须是以上的类型 , 不能设置其它类型返回值 , 否则会报错 ;\n赋值简化操作：\n如果 注解属性 名称是 value , 并且 注解中只有 1 个属性 , 那么在使用 注解 为 注解属性 赋值时 , 可以省略注解名称 , 直接传入 注解属性值 ;\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;// 使用 SuppressWarnings 注解时 , 直接传入 “all” 参数 , 省略了注解属性名称 ;    @SuppressWarnings(&quot;all&quot;)    @Override    public String toString() &#123;        return super.toString();    &#125;// 注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\n\n注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\n自定义一个注解\n使用@interface来申明一个自定义注解时，他会自动继承ava.lang.annotation.Annotation接口。\n格式public @interface xxx(注解名称){定义注解参数内容}。\n\n// 1. 定义带参数的注解@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ApiVersion &#123;    String group() default &quot;default&quot;;    int[] versions();  // 必须显式赋值&#125;// 2. 使用注解@ApiVersion(group = &quot;user&quot;, versions = &#123;1, 2&#125;)public class UserController &#123;    @ApiVersion(versions = &#123;2&#125;) // 使用默认group    public void updateUser() &#123;...&#125;&#125;// 3. 通过反射处理注解Class&lt;UserController&gt; clazz = UserController.class;ApiVersion classAnnotation = clazz.getAnnotation(ApiVersion.class);if (classAnnotation != null) &#123;    System.out.println(&quot;Supported versions: &quot; +         Arrays.toString(classAnnotation.versions()));&#125;\n\n如果是注解有参数，需要在注解里面添加参数类型\n参数格式： 类型 + 名称();\n加了参数后，使用注解如果不添加参数的话会报错，除非添加默认值\n参数设计建议\n\n当只有一个参数时，建议命名为value\n数组参数建议提供空数组默认值（default &#123;&#125;）\n复杂参数使用注解嵌套：\n\n\n如果只有一个参数可以直接使用value命名，这样在使用注解的时候可以省略’名称&#x3D;“xx”’直接赋值\n注解的使用自定义注解的使用需要用到反射的原理\n//作用于类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface ClassAnno&#123;    String value();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoName&#123;    String name();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoAge&#123;    int age();&#125;public class CustomAnnotationExample &#123;    public static void main(String[] args) &#123;        // 获取类的注解信息        Class&lt;Person&gt; personClass = Person.class;   // 反射获取        if (personClass.isAnnotationPresent(ClassAnno.class)) &#123;            // 取出Annotation注解信息            ClassAnno classAnno = personClass.getAnnotation(ClassAnno.class);            System.out.println(&quot;类注解信息: &quot; + classAnno.value());        &#125;        // 获取属性的注解信息        // 需要注意的是，类是默认缺省的，是有访问权限的。而name和age是私有private的，无法直接获取到Filed对象，需要使用getDeclaredField以及getDeclaredAnnotation获取        Field[] fields = personClass.getDeclaredFields();  // getDeclaredFields()反射获取        for (Field field : fields) &#123;            if (field.isAnnotationPresent(FiledAnnoName.class)) &#123;                // 使用反射获取Student注解信息annotations 可以获取到注解里面的值是多少                FiledAnnoName filedAnnoName = field.getAnnotation(FiledAnnoName.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoName.name());            &#125;            if (field.isAnnotationPresent(FiledAnnoAge.class)) &#123;                FiledAnnoAge filedAnnoAge = field.getAnnotation(FiledAnnoAge.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoAge.age());            &#125;        &#125;    &#125;\n\n\n\n\n\n\n\n引用\n【Java 注解】自定义注解 ( 注解属性定义与赋值 )\njava如何优雅的自定义一个注解？\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"蓝桥杯2025Python省BF题园艺题解","url":"/posts/20727.html","content":"洛谷上的题目markdown\nP12175 [蓝桥杯 2025 省 Python B] 园艺\n题目描述小蓝从左到右种了 $n$ 棵小树，第 $i$ 棵树的高度为 $h_i$，相邻树的间隔相同。小蓝想挪走一些树使得剩下的树等间隔分布，且从左到右高度逐渐上升（相邻两棵树高度满足右边的比左边的高），小蓝想知道最多能留下多少棵树。\n输入格式输入的第一行包含一个正整数 $n$。\n第二行包含 $n$ 个正整数 $h_1, h_2, \\cdots, h_n$，相邻整数之间使用一个空格分隔。\n输出格式输出一行包含一个整数表示答案。\n输入输出样例输入 #163 5 4 7 6 7\n\n输出 #13\n\n说明&#x2F;提示样例说明留下第 1、3、5 棵树，它们等间隔且从左到右高度逐渐上升。\n评测用例规模与约定\n对于 $30%$ 的评测用例，$1 \\leq n \\leq 500$；\n对于 $60%$ 的评测用例，$1 \\leq n \\leq 3000$；\n对于所有评测用例，$1 \\leq n \\leq 5000$，$0 &lt; h_i &lt; 10^6$。\n\n\n问题概述题目要求我们在一排树中选出尽可能多的树，满足两个条件：\n\n选出的树必须是等间隔分布的\n选出的树的高度必须严格递增\n\n思路可以发现类似 最长下降子序列 的问题\n考虑 dp ，对于每棵树 i ，检查它前面所有的树 j ，如果树 j 的高度小于树 i 的高度，计算它们之间的间隔 diff\ndp[i][d]表示以第 i 棵树结尾，间隔为 d 的最长子序列长度\n记录以树 i 结尾、间隔为 diff 的最长子序列长度\n代码package 动态规划.subject.线性dp.P12175_蓝桥杯2025_省_PythonB_园艺;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // 初始化输入        Scanner sc = new Scanner(System.in);        int n = sc.nextInt(); // 读取树的总数        int[] tree = new int[n]; // 存储每棵树的高度                // 读取每棵树的高度        for (int i = 0; i &lt; n; i++) &#123;            tree[i] = sc.nextInt();        &#125;        // 动态规划数组        // dp[i][d]表示以第i棵树结尾，间隔为d的最长子序列长度        int[][] dp = new int[n][n];                // 初始最大值设为1，因为至少可以选择一棵树        int max = 1;        // 初始化：每棵树可以单独形成一个子序列        // dp[i][0]表示间隔为0的情况（即只选这一棵树）        for (int i = 0; i &lt; n; i++) &#123;            dp[i][0] = 1;        &#125;        // 动态规划主过程        for (int i = 0; i &lt; n; i++) &#123; // 遍历每棵树作为结尾            for (int j = 0; j &lt; i; j++) &#123; // 检查前面的所有树                // 只有当当前树比前面的树高时才考虑                if (tree[j] &lt; tree[i]) &#123;                    // 计算两棵树之间的间隔                    int diff = i - j;                                        // 获取以树j结尾、间隔为diff的最长子序列长度                    int prev = dp[j][diff];                                        // 如果prev为0，说明树j是单独存在的                    // 此时可以形成一个长度为2的子序列（树j和树i）                    if (prev == 0) &#123;                        prev = 1;                    &#125;                                        // 如果发现更长的子序列，就更新                    if (dp[i][diff] &lt; prev + 1) &#123;                        dp[i][diff] = prev + 1;                                                // 更新全局最大值                        if (dp[i][diff] &gt; max) &#123;                            max = dp[i][diff];                        &#125;                    &#125;                &#125;            &#125;        &#125;        // 输出结果        System.out.println(max);                // 关闭Scanner        sc.close();    &#125;&#125;\n\n因为是 python 组的题目，所以这里放一下python的代码\ndef main():    import sys    input = sys.stdin.read        # 读取输入数据    data = input().split()    n = int(data[0])    tree = list(map(int, data[1:n+1]))        # 初始化动态规划数组    # dp[i][d] 表示以第i棵树结尾，间隔为d的最长子序列长度    dp = [[0] * n for _ in range(n)]    max_len = 1  # 至少可以选一棵树        # 初始化：每棵树可以单独形成一个子序列    for i in range(n):        dp[i][0] = 1        # 动态规划主过程    for i in range(n):  # 遍历每棵树作为结尾        for j in range(i):  # 检查前面的所有树            if tree[j] &lt; tree[i]:  # 只有当前树比前面的树高时才考虑                diff = i - j  # 计算间隔                                # 获取以树j结尾、间隔为diff的最长子序列长度                prev = dp[j][diff]                                # 如果prev为0，说明树j是单独存在的                # 此时可以形成一个长度为2的子序列（树j和树i）                if prev == 0:                    prev = 1                                # 如果发现更长的子序列，就更新                if dp[i][diff] &lt; prev + 1:                    dp[i][diff] = prev + 1                                        # 更新全局最大值                    if dp[i][diff] &gt; max_len:                        max_len = dp[i][diff]        # 输出结果    print(max_len)if __name__ == &quot;__main__&quot;:    main()\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯2025Python省赛B组题解","url":"/posts/5125.html","content":"A. 攻击次数\n\n这题有歧义，如果考虑三个英雄一起上，就是103，考虑一回合只能上一个伤害高的，就是181\n// 一起上的情况public class Main &#123;    public static void main(String[] args) &#123;        // 能一起上就一起上，不能一起上，就上攻击力高的        int hp = 2025;        int cnt = 0;        while(hp &gt; 0)&#123;            cnt++;            int hero1 = 5;   // 英雄 1 的固定伤害            int hero2 = (cnt % 2 == 1) ? 15 : 2;   // 英雄 2 的回合机制伤害            int hero3 = 0;            if(cnt % 3 == 1)&#123;                hero3 = 2;            &#125;else if(cnt % 3 == 2)&#123;                hero3 = 10;            &#125;else if(cnt % 3 == 0)&#123;                hero3 = 7;            &#125;            hp -= hero1 + hero2 + hero3;        &#125;        System.out.println(cnt);    &#125;&#125;\n\n# 不一起上的情况# 挑攻击力大的技能使用即可# 可见：奇数一定使用第二个英雄的技能，然后偶数情况的话模3余1用第一个英雄技能，其他情况用第三个英雄的技能。n = 0i = 1while n &lt; 2025:    if i &amp; 1:        n += 15    else:        if i % 3 == 2:            n += 10        elif i % 3 == 0:            n += 7        else:            n += 5    i += 1print(i - 1)\n\n\nB. 最长字符串\n\n下载附件 words.txt\n优美字符串的定义是：字符串本身存在于给定的单词列表中，并且可以通过调整顺序后由另一个更短的优美字符串扩展而来。\n考的主要是文件读写，默认把 txt 附件存在和代码同级别的目录下\npackage 基础算法和其他.IO读写流.P12171_蓝桥杯_2025_省_Python_B_最长字符串;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        //  读取 words.txt 文件中的单词        List&lt;String&gt; words = new ArrayList&lt;&gt;();        try(BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\\\WorkSpace\\\\JavaDemo\\\\IDEA\\\\Algorithm\\\\src\\\\字符串\\\\subject\\\\P12171_蓝桥杯2025省PythonB最长字符串\\\\words.txt&quot;)))&#123;            String line;            while ((line = br.readLine()) != null) &#123;                words.add(line.trim());            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;        // 按长度升序、字典序升序排序（确保处理顺序正确）        words.sort(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()));        Set&lt;String&gt; bs = new HashSet&lt;&gt;();        // 动态规划：判断每个单词是否是优美字符串        for(String word : words)&#123;            if(word.length() == 1)&#123;                bs.add(word);            &#125;else&#123;                // 如果 前n-1 位的长度的字符串，我们把其和要对比的字符串按一定规律重组，那么两者就是一样的了                String pre = sortString(word.substring(0, word.length() - 1));                for(String sbs: bs)&#123;                    if(sortString(sbs).equals(pre))&#123;                        bs.add(word);                        break;                    &#125;                &#125;            &#125;        &#125;        // 找到最长的优美字符串        int maxLength = 0;        for (String word : bs) &#123;            maxLength = Math.max(maxLength, word.length());        &#125;        List&lt;String&gt; ls = new ArrayList&lt;&gt;();        for (String word : bs) &#123;            if (word.length() == maxLength) &#123;                ls.add(word);            &#125;        &#125;        // 输出字典序最小的结果        ls.sort(Comparator.naturalOrder());        System.out.println(ls.get(0));        // System.out.println(&quot;afplcu&quot;);    &#125;    // 字符串按字母字典序重组    private static String sortString(String s) &#123;        char[] charArray = s.toCharArray();        Arrays.sort(charArray);        return new String(charArray);    &#125;&#125;\n\n# 读取 words.txt 文件中的单词with open(&quot;words.txt&quot;, &quot;r&quot;) as f:    ws = [line.strip() for line in f]# 按长度和字典序排序ws.sort(key=lambda x: (len(x), x))# 初始化优美字符串集合bs = set()# 动态规划：判断每个单词是否是优美字符串for w in ws:    if len(w) == 1:        bs.add(w)    else:        pre = &#x27;&#x27;.join(sorted(w[:-1]))        if any(&#x27;&#x27;.join(sorted(s)) == pre for s in bs):            bs.add(w)# 找到最长的优美字符串ml = max(len(w) for w in bs)lbs = [w for w in bs if len(w) == ml]# 输出字典序最小的结果print(min(lbs))\n\n\n\n\nC. LQ图形\n\n\n\n观察可发现，可以将L分为上下两个部分，上面列数少的为h行，下面列数多的为w行，上下宽度分别为w和v+w。时间复杂度O(h + w)\n//package 基础算法和其他.模拟.P12172_蓝桥杯2025省PythonB_LQ图形;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int w = sc.nextInt();        int h = sc.nextInt();        int v = sc.nextInt();        // 先是h高w宽的Q，然后是w高v+w宽        StringBuilder sb1 = new StringBuilder();        StringBuilder sb2 = new StringBuilder();        for(int i = 1; i &lt;= w; i++) sb1.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= v + w; i++) sb2.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= h; i++) System.out.println(sb1);        for(int i = 1; i &lt;= w; i++) System.out.println(sb2);    &#125;&#125;\n\nw,h,v = MII()t = hb = wfor i in range(t):    print(&#x27;Q&#x27; * w)for i in range(b):    print(&#x27;Q&#x27; * (v + w))\n\n\nD. 最多次数\n\n贪心，遇到连续的三个某个顺序的 l,q,b, 就把他拿掉。时间复杂度O(n)\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // lqb lbq qbl qlb blq bql 可以发现题目给出的是全排列        // 遇到连续的 lqb 三个字母拿掉就行        Scanner sc = new Scanner(System.in);        String str = sc.nextLine();        String[] strs = &#123;&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;&#125;;        int res = 0, index = 0;        for(int i = 0; i &lt; str.length() - 2; i++)&#123;   // 注意防止越界            String sub = str.substring(i, i + 3);            for(int j = 0; j &lt; 6; j++)&#123;                if(sub.equals(strs[j]))&#123;                    i += 2;   // 不判断中间的内容了                    res++;                    break;                &#125;            &#125;        &#125;        System.out.println(res);        sc.close();    &#125;&#125;\n\nstr_input = input()strs = [&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;]res = 0i = 0while i &lt; len(str_input) - 2:    sub = str_input[i:i + 3]    for j in range(6):        if sub == strs[j]:            i += 2            res += 1            break    i += 1print(res)\n\n\nE. A*B Problem\n\n给定 n，求四元组 (a,b,c,d) 个数，满足 a×b+c×d≤n，且 a,b,c,d 都是正整数。\n我们需要枚举所有可能的向量 A 和 B，使得它们的内积不超过 L。\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int L = scanner.nextInt();        int count = 0;        // 枚举所有可能的 (XA, YA) 和 (XB, YB)        for (int XA = 1; XA &lt;= L; XA++) &#123;            for (int YA = 1; YA &lt;= L; YA++) &#123;                for (int XB = 1; XB &lt;= L / XA + 1; XB++) &#123;                    for (int YB = 1; YB &lt;= (L - XA * XB) / YA + 1; YB++) &#123;                        if (XA * XB + YA * YB &lt;= L) &#123;                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(count);    &#125;&#125;\n\n不行，只有80分，考虑优化\n将四元组 (a,b,c,d) 的问题转化为两个部分：x&#x3D;a×b和 y&#x3D;c×d，使得 x+y≤n。\n这样，问题转化为统计所有满足 x+y≤n 的正整数对 (x,y) 的数量，其中 x 和 y 都可以表示为两个正整数的乘积。\n这样对于满足 x+y&#x3D;k 的四元组个数就是 tx×ty。\n考虑每个数 i，预处理其能表示为两个正整数乘积的方式数 t[i]（即 i 的因数对数）。把 x 打表打出来\n使用线性筛法预处理每个数的因数个数，计算 t[i]。\n计算 t[i] 的前缀和数组 s[i]，用于快速查询 y≤n−x 时的 t[y] 的总和。\n对于每个 x，其贡献为 t[x]×s[n−x]\n为什么求 t[y] 要使用前缀和数组，对于每个固定的 x，我们需要找到所有满足 y≤n−x 的 y 的数量，也就是 ∑y&#x3D;1n−x​t[y]\npackage 数学.subject.P12174_蓝桥杯2025省Python_B_AxBProblem;import java.util.Arrays;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int l = sc.nextInt();        int[] t = new int[l + 1];        Arrays.fill(t, 0);        // 枚举所有可能的 (a,b)组合，并统计每个乘积的出现次数，打表出四元组的前两部分乘积        for (int a = 1; a &lt;= l; a++) &#123;            for(int b = 1; a * b &lt;= l; b++)&#123;                t[a * b]++;            &#125;        &#125;        // 前缀和        int[] s = new int[l + 1];        s[0] = 0;        for (int i = 1; i &lt;= l; i++) &#123;            s[i] = s[i - 1] + t[i];        &#125;        long total = 0;        // 对于每个 x        for(int x = 1; x &lt; l; x++)&#123;            // 计算其对应的 y 的最大值 l - x            int y = l - x;            total += (long)t[x] * s[y];   // 前缀和计算        &#125;        System.out.println(total);    &#125;&#125;\n\n\nF. 园艺讲过了，在\n\nG. 书架还原\n\npackage 基础算法和其他.贪心.subject.P12176_蓝桥杯2025省PythonB_书架还原;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n + 1];   // 书架        int[] p = new int[n + 1];   // p[x]表示书本编号现在所处的位置        int res = 0;        for(int i = 1; i &lt;= n; i++)&#123;            a[i] = sc.nextInt();            p[a[i]] = i;    // 桶记录书本a[i]的正确位置，p[a[i]] 是书本应该去的位置        &#125;        // 从第一个位置开始检查，如果当前数字不在正确位置，就找到它应该去的位置，把这两个位置的数字交换。        for(int i = 1; i &lt;= n; i++)&#123;            if(a[i] != i)&#123;   // 不在正确位置，需要调整位置                p[a[i]] = p[i];   // 把书本放到应该去的位置                ++res;                // 把正确位置p[i]上的书本和当前书本位置交换                int temp = a[p[i]];                a[p[i]] = a[i];                a[i] = temp;            &#125;        &#125;        System.out.println(res);    &#125;&#125;\n\nn = II()a = [0] + LII()p = [0] * (n + 1)res = 0for i in range(1,n + 1):    p[a[i]] = ifor i in range(1,n + 1):    if a[i] != i:        p[a[i]] = p[i]        a[i],a[p[i]] = a[p[i]],a[i]        res += 1print(res)\n\n\nH. 异或和\n\n考虑位运算，把每个数拆成二进制然后进行统计\n由于异或运算本身就是建立在位的基础上的，所以我们只需要用一层循环枚举位\n只有两个数当前位不同才能产生贡献。也就是说，如果这一位是 0，那他得跟这一位为 1 的数异或才能有贡献，所以加上这一位为 1 的数的个数再乘以这一位的权值\n如果先不考虑公式后面的 j−i，那么只有用两个变量统计每位 0 和 1 的个数。\n现在还得乘上 j−i，这个值是不断变化的，可以发现其中 i 是不变的，j 每次只加1，开两个变量存储每位 0 和 1 的权值\nimport java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        BigInteger[] arr = new BigInteger[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            arr[i] = sc.nextBigInteger();        &#125;        BigInteger res = BigInteger.ZERO;        // 只有两个数当前位不同才能产生贡献。        for (int dig = 0; dig &lt;= 20; dig++) &#123;            int[] cnt = &#123;0, 0&#125;;   // 记录当前已处理过的数中，二进制位 k 为 0 或 1 的数的个数。            BigInteger[] sum = &#123;BigInteger.ZERO, BigInteger.ZERO&#125;;   // 下标差的动态和            for (int i = 1; i &lt;= n; i++) &#123;                // 提取arr[i]的二进制中第 dig 位的值                int bit = arr[i].shiftRight(dig).and(BigInteger.ONE).intValue();                // 取出相反位的值，这样的才可以产生贡献                BigInteger multiplier = BigInteger.valueOf(1L &lt;&lt; dig);                res = res.add(sum[bit ^ 1].multiply(multiplier));                cnt[bit]++;                // 每次处理一个数时，所有之前记录的数的下标差会自然增加                sum[0] = sum[0].add(BigInteger.valueOf(cnt[0]));                sum[1] = sum[1].add(BigInteger.valueOf(cnt[1]));            &#125;        &#125;        System.out.println(res);    &#125;&#125;    \n\nn = int(input())  # 输入数组长度a = list(map(int, input().split()))  # 输入数组res = 0  # 最终结果for b in range(31):  # 遍历每一位（0到30位）    m = 1 &lt;&lt; b  # 当前位的掩码，用于提取该位的值    c = [0, 0]  # 用于统计当前位为0和1的数量    s = [0, 0]  # 用于记录当前位为0和1的索引和    cur = 0  # 当前位的贡献值    for i in range(n):  # 遍历数组中的每个元素        bit = (a[i] &gt;&gt; b) &amp; 1  # 提取当前元素在当前位的值（0或1）        cur += c[1 - bit] * i - s[1 - bit]  # 计算当前位的贡献值        c[bit] += 1  # 更新当前位的计数        s[bit] += i  # 更新当前位的索引和    res += cur * m  # 将当前位的贡献值乘以掩码，累加到最终结果print(res)  # 输出最终结果\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯3月月赛F题题解","url":"/posts/46832.html","content":"「蓝桥·算法双周赛」第二十七场蓝桥月赛最后一题题解(可能是首发？？nm，真比第三题简单吧)\n(求你们看看吧我对我的码风很自信)\n问题描述 \n二分枚举时间m，然后剩下的就是根据题意纯模拟  \n注意备份和等待能不能跨天进行，这是个坑点\n细节在注释里有\npackage 蓝桥月赛第27场;import java.util.Scanner;public class F &#123;\t\tprivate static int calculateDays(int m, int[] a, int[] b) &#123;\t\t// 如果没有电脑需要备份，返回 0 天    \tif(a.length == 0) return 0;    \t    \t// 如果 M 小于第一台电脑的备份时间    \tif(m &lt; a[0]) return Integer.MAX_VALUE;    \t    \t// 第一天    \tint days = 1;    \t// 备份第一台开始算剩余时间    \tint currentRemaining = m - a[0];    \t// 第一台都备份不上？？        if (currentRemaining &lt; 0) &#123;            return Integer.MAX_VALUE;        &#125;                for (int i = 1; i &lt;= a.length; i++) &#123;        \tint wait = b[i];   // 获取前一台电脑的等待时间        \t        \t// 处理等待时间        \t// 时间足够，直接减去        \tif(currentRemaining &gt;= wait) &#123;        \t\tcurrentRemaining -= wait;        \t// 不够只能过天了，计算剩余的等待时间        \t&#125;else &#123;        \t\t// 把当天能等的给等了        \t\twait -= currentRemaining;        \t\tdays++;        \t\tcurrentRemaining = m;   // 重置剩余时间        \t\t        \t\tint fullDays = wait / m;   // 计算等几天        \t\tdays += fullDays;        \t\twait -= fullDays * m;        \t\t        \t\tif(wait &gt; 0) &#123;        \t\t\t// 减去零头        \t\t\tcurrentRemaining = m - wait;        \t\t&#125;else &#123;        \t\t\tcurrentRemaining = m;  // 重置        \t\t&#125;        \t&#125;        \t        \t        \t// 处理备份时间        \t// 今天够备份        \tif(currentRemaining &gt;= a[i]) &#123;        \t\tcurrentRemaining -= a[i];        \t&#125;else &#123;        \t\t// 今天备份不完，备份不能留到第二天        \t\tdays++;        \t\tcurrentRemaining = m - a[i];        \t\t// 不行，时间太短，备份不完        \t\tif (currentRemaining &lt; 0) &#123;        \t\t\treturn Integer.MAX_VALUE;        \t\t&#125;        \t&#125;        \t        &#125;        return days;    &#125;\t\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\t\t\t// N 台电脑        int n = scanner.nextInt();        // 最多允许的天数T        int t = scanner.nextInt();        // 表示每台电脑的备份时间。        int[] a = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = scanner.nextInt();        &#125;                // 每台电脑备份完成后需要等待的时间。        int[] b = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            b[i] = scanner.nextInt();        &#125;        scanner.close();                // 最长备份时间        int maxA = 0;        for(int ai: a) &#123;        \tif (ai &gt; maxA) &#123;                maxA = ai;            &#125;        &#125;                if (maxA &gt; 3600) &#123;            System.out.println(-1);            return;        &#125;                // 开始二分 枚举m        int left = maxA;        int right = 3600;        int result = -1;                while(left &lt;= right) &#123;        \tint mid = (left + right) / 2;        \tint days = calculateDays(mid, a, b);        \tif (days &lt;= t) &#123;                result = mid;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;                System.out.println(result != -1 ? result : -1);\t&#125;&#125;\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]}]