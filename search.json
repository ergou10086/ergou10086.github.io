[{"title":"绘隙碎笔","url":"/posts/29865.html","content":"​\t才三月份，石家庄就依旧进入繁盛的春天了啊。。。。在我的家乡长久生活的人，不知道会不会感叹这岁月的笔触实在是太快了。​\t又是一节我习惯绘画的课堂，坐在最靠窗户的一排，三月份已然有些许热气，拿出本来，感觉都温暖了许多。​\t我常于这光影交错处徘徊，看日光一寸寸移动，感觉把我生命的长度都不经意的丈量了。​\t所以我把这梦境画下，我又回到那个熟悉的楼里了，那个我可能再也不会有机会回去的，却满含怀念的建筑里。​\t她靠着下午五点半的夕阳，在梦里和我相遇吗。其实不然，在梦里只有楼和我，我却无法把自己画下，只能把祈莉作为我思索的对象，让她替我在一步一步的忧郁。  \n\n&#123;% asset_img ShenBangQili.jpg example %&#125;\t\n\n​\t本人懈怠，绘画的热度感觉一日不如一日，也许我是想画吧，可是我用时间在绘画上的刻痕实在是太浅，被琐事纠缠的我，大概是无暇提笔哩。。。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-2025.3.27 中午\n","categories":["杂谈","绘画相关"],"tags":["绘画相关","杂谈"]},{"title":"Hexo根目录下的_config.yml配置文件","url":"/posts/63024.html","content":"我们在使用hexo初始化一个项目的时候，在根目录下会有一个配置文件_config.yml，这个文件配置了所写博客里面的内容，我们从根目录的该文件来说明每个配置的作用\n头注释_config.yml文件在头部会有一些注释，Hexo Configuration下的两行表示hexo文档的相关文档，Docs指的是hexo的文档，Source指的是hexo的GitHub源码，方便供他人参考查阅\n# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/\n\n\n\n博客网站相关Site下面是网站相关的一些信息配置\n# Sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doelanguage: entimezone: &#x27;&#x27;\n\ntitle：网站的名字，会写在hexo generator命令生成后的public文件夹下的index.html文件的title标签里，作为你个人博客网站的标题，我们也可以在主题的首页左下角找到\nsubtitle：网站的副标题，生成的时候默认为空，一般会出现在你主标题的下面，也就是大约在背景图中间\ndescription：主要用于SEO，告诉搜索引擎一个关于站点的简单描述，在官方文档中建议在这段描述中增加自己的一些关键词\nkeywords：网站的关键词，使用半角逗号分隔开多个关键词，对SEO的优化有一定的作用\nauthor：顾名思义就是作者，这个也只是署个名而已，不会显式的看到\nlanguage：这里就写了网站使用的语言\ntimezone：网站对应的时区，一般情况下不用去刻意配置，会默认使用电脑的时区，但如果发布到其他地方的服务器，可能会使用当地服务器的时区，一般中国的时区可以设置为Asia&#x2F;Shanghai或者北京\n博客网址相关# URL## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;url: http://example.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # 设置为false时会将末尾的index.html去掉  trailing_html: true # 设置为false时会将末尾的.html去掉，对index.html无效\n\nurl：指定博客的完整域名或 URL 地址。当你将博客部署到互联网上时，访问者需要通过这个地址来访问你的博客，要确保 url 地址准确无误，不然可能会导致博客内的链接（如文章内的图片链接、页面跳转链接等）无法正常访问\nroot：网站的根目录，指定博客在域名下的根目录，如果你的博客是直接部署在域名的根目录下，就将 root 设置为 /；若博客部署在域名的子目录下，比如部署在 http://example.com/blog 下，那么就需要把 root 设置为 /blog/。正确设置 root 很重要，不然会影响博客内资源（如 CSS、JavaScript 文件等）的加载路径。\npermalink：文章的永久链接格式，一般是格式化日期字符串，可以在permalink这里配置，如默认中的配置，在hello world文章中就会是这样的url\n\n当使用Font-matter中的值配置的时候（文章格式标签），可选的值有\n\n\n\n**permalink_defaults:**设置永久链接的默认值。当你在文章的 Front - Matter（文章开头的元数据部分）中没有对某些永久链接相关的变量进行设置时，就会使用这里定义的默认值。不过在示例中，没有具体设置默认值，所以会采用 Hexo 的默认配置。\n**pretty_urls:**就是如注释那样\n目录相关# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:\n\nsource_dir：存放hexo文章的文件夹，我们写的md文件都放在这个配置对应的文件夹下，默认值是source\npublic_dir：存放hexo g生成的文件，执行hexo g后根目录就会出现这个文件夹，默认值是public\ntag_dir：按标签存放文章的目录，默认值是tags，如果我们给文章添加标签，使用hexo g时public文件夹下就会多出一个tags文件夹（根据我们的配置文件夹名不同）\narchive_dir：归档文件夹，存放归档文件，默认值为archives\ncategory_dir：分类文件夹，按分类存放的文件，和上面的tags一样，只要在文章中的Font-matter添加了categories就会在使用hexo g构造时出现相应的文件夹\ncode_dir：Include code 文件夹，source_dir 下的子目录，默认值为downloads&#x2F;code\ni18n_dir：国际化（i18n）文件夹，默认值:lang\nskip_render：跳过指定文件的渲染，匹配到的文件将会被不做改动复制到public文件夹下，如果路径对应的是我们的文章，那会直接忽略掉该文章，我们这样设置来忽略掉hello-world.md文件\nskip_render: &quot;_posts/hello-world.md&quot;\n\n​\t\t然后hexo g之后可见生成的文件夹只有一些基础的内容，没有和hello-world.md相关的东西\n文章相关# Writingnew_post_name: :title.md default_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: false\n\nnew_post_name：新文章的默认名称，我们是使用hexo new来构造文章的，生成的文章名就是通过这里配置的，默认为:title.md，也就是标题.md\ndefault_layout：预设布局，指定你新建文章的布局，布局决定了文章在渲染时使用的模板，hexo new可以创建三种文件，post&#x2F;帖子，draft&#x2F;草稿，page&#x2F;页面，这里设置默认值在使用hexo new就可以直接创建对应默认类型的文章，设置了post就等同于说在命令行执行hexo new 和执行hexo new post 是一样的，也可以设置为draft和page\ntitlecase：控制是否将文章标题转换为标题大小写格式。当设置为 true 时，文章标题会被转换为标题大小写（即每个单词的首字母大写）；设置为 false 则不进行转换，保持标题的原始大小写。\nexternal_link：\n\nenable：控制是否在新标签页中打开外部链接。设置为 true 时，文章中的外部链接会在新标签页中打开；设置为 false 则会在当前页面打开。\nfield：指定外部链接设置的应用范围。site 表示该设置应用于整个网站。\nexclude：指定不应用此外部链接设置的域名或路径。这里为空字符串，表示没有排除的域名或路径。\n\nfilename_case：控制文件名的大小写规则。取值为 0 时，文件名保持原始大小写；取值为 1 时，文件名转换为小写；取值为 2 时，文件名转换为大写。\nrender_drafts：控制是否渲染草稿文章。草稿文章通常存放在 source/_drafts 目录下。设置为 true 时，草稿文章会被渲染并显示在网站上；设置为 false 则不会渲染草稿文章。\npost_asset_folder：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在source文件夹下建立一个统一的images文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，就可以设置为true，控制为每篇文章创建一个同名的资源文件夹。当设置为 true 时，使用 hexo new 命令创建文章时，会同时创建一个与文章同名的文件夹，用于存放该文章相关的图片、附件等资源；设置为 false 则不会创建。\nrelative_link: 控制是否使用相对链接。设置为 true 时，文章中的链接会使用相对路径；设置为 false 则使用绝对路径。\nfuture：控制是否发布未来日期的文章。设置为 true 时，即使文章的发布日期设置为未来的某个时间，也会正常发布；设置为 false 则不会发布未来日期的文章。\nhighlight：代码高亮的显示\n\nenable：控制是否启用代码高亮功能。设置为 true 时，文章中的代码块会进行高亮显示；设置为 false 则不进行高亮。\nline_number：控制是否显示代码块的行号。设置为 true 时，代码块会显示行号；设置为 false 则不显示。\nauto_detect：控制是否自动检测代码块的语言。设置为 true 时，Hexo 会尝试自动检测代码块的语言；设置为 false 则需要在代码块中手动指定语言\ntable_replace：用n个空格来代表tab键，如果值为空，则不会代替tab键，这里为空字符串，表示不进行替换。\nwarp：是否将代码放在table标签里，默认为true\nhljs：控制是否使用 highlight.js 进行代码高亮。设置为 true 时，使用 highlight.js 进行高亮；设置为 false 则使用 Hexo 内置的高亮方式。\n\n主页设置index_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date\n\nindex_generator：主页相关的设置\n\npath：主页对应的路径，默认为’’，即域名根目录就是主页的路径\nper_page：每页显示的帖子数，默认为10\norder_by：帖子的排序，默认为-date，即按日期倒序排\n\n分类和标签# Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名\n\ndefault_category：当你创建新文章时，如果没有在文章的 Front - Matter（即文章开头的元数据部分）中明确指定文章的分类，那么这篇文章就会被自动归类到 default_category 所指定的分类中。在这个例子里，默认分类是 uncategorized，也就是 “未分类”。\ncategory_map：category_map 用于设置分类的别名。在实际写文章和管理博客的过程中，你可能会使用一个比较简洁或者容易输入的分类名，但在博客的展示页面上，你希望使用更正式、美观或者表意更清晰的名称。这时就可以通过 category_map 来实现分类名的映射。\n例如：\ncategory_map:  tech: 技术分享  life: 生活随笔\n\n当你在文章的 Front - Matter 中使用 categories: [tech] 时，在博客的分类页面显示的分类名称将会是 “技术分享”，而不是 tech。\ntag_map：tag_map 的作用与 category_map 类似，不过它是用于设置标签的别名。在写文章时，你可能会使用一些简单的标签名，但在博客展示时，希望使用更合适的名称，就可以通过 tag_map 来进行映射。\n元数据元素# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true\n\n是否在页面开头插入下面的meta标签，默认为true\n\n日期和时间# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#x27;s date for updated date unless set in front-matteruse_date_for_updated: false\n\ndate_format：日期格式，默认为YYYY-MM-DD，即年月日\ntime_format：时间格式，默认为HH:mm:ss，即时分秒\nuse_date_for_updated：启用以后，如果 Front Matter 中没有指定 updated（文件更新日期），post.updated 将会使用 date 的值而不是文件的创建时间，默认值为true\n分页# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page\n\nper_page：分页时每页的文章数，如果为0则不分页，默认为10\npagination_dir分页的目录，默认为page，对应于public文件夹下的archives文件夹下的page文件夹，如果只有一页是不会生成这个文件夹的\n包括或不包括目录和文件# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:\n\ninclude：Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude：Hexo 会忽略这些文件和目录\nignore：忽略的文件,要注意的是，这里要写入的是数组，而yaml的数组要用-值表示数组中一个元素或者直接采用js中数组的写法[]\n主题# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 当前使用的主题名\n\n\n\n部署# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#x27;&#x27;\n\nhexo提供了快速方便的一键部署功能hexo deploy，但我们至少需要在_config.yml文件中的deploy中至少配置一个type，比如\ndeploy:  type: git\n\ndeploy:  type: git  repo: &lt;repository url&gt; # 库地址  branch: [branch] # 分支名称  message: [message] # 自定义提交信息\n\n\n\n\n\n\n\n参考内容：部分内容转载自https://blog.csdn.net/zemprogram/article/details/104288872\n hexo官方中文文档\n hexo官方英文文档（有些中文文档没有的英文文档的才有）\n hexo fromt-matter\n hexo 部署\n","categories":["实用","介绍说明"],"tags":["网站技术","Hexo相关","实用知识"]},{"title":"JavaWeb-http","url":"/posts/31243.html","content":"HTTP请求客户端–&gt;请求–&gt;服务器\n\n超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\n\nHTTP是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。\n\n\n以请求百度为例\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\nAccept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9  语言Cache-Control: max-age=0Connection: keep-alive\n\n1.请求行请求行中的请求方式：GET\n\n\n\nGET请求方式\n请求方式：\n\n\n\n2.消息头\n\n\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接\n\n\n\nHTTP响应服务器–&gt;响应–&gt;客户端\n例子\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\n\n响应体Accept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的    sendRedirect方法，该方法同时设置状态代码为302。Set-Cookie:设置和页面关联的Cookie。\n\n响应状态码常见状态码200：请求响应成功\n301：请求重定向\n\n请求重定向(Redirect)：通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。\n\n404: 找不到资源\n500：服务器代码错误\nHTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n\n\n\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaEE","Web","JavaWeb"]},{"title":"Java注解与Annotation类","url":"/posts/54622.html","content":"了解注解Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。是提供一种为程序元素设置元数据的方法，这些信息可以被编译器、开发工具或运行时环境读取和处理。\n（程序元素：接口、类、属性、方法等；   元数据：描述数据的数据）\n关键特性：\n\n注解本身不包含业务逻辑，但可以通过反射机制在运行时获取并处理\n\n注解不影响程序本身的执行，但可以通过工具影响程序的行为\n\n注解可以包含命名参数，这些参数可以有默认值\n\n\n其实就是写在接口、类、属性、方法上的一个标签，或者说是一个特殊形式的注释，普通注释只是一个注释，而注解在代码运行时是可以被反射读取并进行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。\nJava 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。\n在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。\n可以利用注解来自定义一些实现，比如在某个方法上加一个自定义注解，就可以实现方法日志的自动记录打印\n举例@Override:\n它的作用是告诉阅读者(开发人员、编译器)这个方法重写了父类的方法，对于开发人员只是一个标志，然而编译器如果发现方法标注了这个注解，就会检查这个方法到底是不是真的覆写了父类的方法，如果没有会报错，而如果不添加@Override注解，程序也是可以正常运行的，不过缺乏了静态的检查\n在spring框架中加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。\n注意：注解不能直接干扰程序代码的运行\n注解的作用话说当年非常流行xml配置的。优点呢就是整个项目的配置信息集中在一个文件中，从而方便管理，是集中式的配置。缺点也显而易见，当配置信息非常多的时候，配置文件会变得越来越大不易查看管理，特别是多人协作开发时会导致一定的相互干扰。\n现在都提倡解耦、轻量化或者说微小化，那么注解就顺应了这一需求，各个包或模块在内部方法或类上使用注解即可实现指定功能，缺点呢就是不方便统一管理，如果需要修改某一类功能，则需要整体搜索逐个修改，是分散式的存在各个角落。\nxml的方式是集中式的元数据，不需要和代码绑定的，而注解是一种分散式的元数据设置方式。\n开发者的视角可以解读出这个类&#x2F;方法&#x2F;属性的作用以及该怎么使用，而从框架的视角则可以解析注解本身和其属性实现各种功能，编译器的角度则可以进行一些预检查(@Override)和抑制警告(@SuppressWarnings)等。\n\n作为特定标记，用于告诉编译器一些信息\n编译时动态处理，如动态生成代码\n运行时动态处理，作为额外信息的载体，如获取注解信息\n\nAnnotation架构Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。\n\n\n其中\n\n1 个 Annotation 和 1 个 RetentionPolicy 关联。\n可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。\nRetentionPolicy 是一个枚举类型，它定义了注解的保留策略，也就是规定了注解在什么阶段是可用的。\n\n\n\n\n1 个 Annotation 和 1~n 个 ElementType 关联。\n对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性\n\n\nAnnotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。\n每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\n\n\n\nAnnotation 组成部分java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：Annotation  ElementType RetentionPolicy\npackage java.lang.annotation;public interface Annotation &#123;    // 当两个注解对象满足以下条件时，认为它们相等：注解类型相同  所有注解元素的值都相等    boolean equals(Object obj);    int hashCode();    // 将当前注解对象转换为字符串表示形式,字符串表示通常包含注解的类型名称和所有注解元素的值。    String toString();       // 获取当前注解对象的注解类型。注解类型是一个 Class 对象，它表示定义该注解的接口。    Class&lt;? extends Annotation&gt; annotationType();   &#125;\n\npackage java.lang.annotation;public enum ElementType &#123;    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */&#125;\n\npackage java.lang.annotation;public enum RetentionPolicy &#123;    SOURCE,   /*源码级 Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /*类文件级 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /*运行级 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125;\n\n其中：\n\nAnnotation这个接口中，每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\nElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途\n就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。\n\nAnnotation 通用定义@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125;\n\n上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。\n定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。\njava常用的Annotation@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented  -- @Documented 所标注内容，是否包含在用户文档中javadoc@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention   -- @Retention只能被用来标注“Annotation类型”，用来指定Annotation的RetentionPolicy属性作用域。@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。\n\n\n\nAnnotation 的作用编译检查Annotation 具有”让编译器进行编译检查的作用”。\n例如\n\n@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。\n若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。\n\n\n我们可以发现 getString() 函数会报错。这是因为 getString() 被 @Override 所标注，但在OverrideTest 的任何父类中都没有定义 getString() 函数”。\n反射中使用Annotation在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。我们可以在反射中解析并使用 Annotation。\n/** * Annotation在反射函数中的使用示例 */@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String[] value() default &quot;unknown&quot;;&#125;/** * Person类。它会使用MyAnnotation注解。 */class Person &#123;        /**     * empty()方法同时被 &quot;@Deprecated&quot; 和 &quot;@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注      * (01) @Deprecated，意味着empty()方法，不再被建议使用     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;     */    @MyAnnotation    @Deprecated    public void empty()&#123;        System.out.println(&quot;\\nempty&quot;);    &#125;        /**     * sombody() 被 @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，     * @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;     */    @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)    public void somebody(String name, int age)&#123;        System.out.println(&quot;\\nsomebody: &quot;+name+&quot;, &quot;+age);    &#125;&#125;public class AnnotationTest &#123;    public static void main(String[] args) throws Exception &#123;                // 新建Person        Person person = new Person();        // 获取Person的Class实例        Class&lt;Person&gt; c = Person.class;        // 获取 somebody() 方法的Method实例        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]&#123;String.class, int.class&#125;);        // 执行该方法        mSomebody.invoke(person, new Object[]&#123;&quot;lily&quot;, 18&#125;);        iteratorAnnotations(mSomebody);                // 获取 somebody() 方法的Method实例        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]&#123;&#125;);        // 执行该方法        mEmpty.invoke(person, new Object[]&#123;&#125;);                iteratorAnnotations(mEmpty);    &#125;        public static void iteratorAnnotations(Method method) &#123;        // 判断 somebody() 方法是否包含MyAnnotation注解        if(method.isAnnotationPresent(MyAnnotation.class))&#123;            // 获取该方法的MyAnnotation注解实例            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);            // 获取 myAnnotation的值，并打印出来            String[] values = myAnnotation.value();            for (String str:values)                System.out.printf(str+&quot;, &quot;);            System.out.println();        &#125;                // 获取方法上的所有注解，并打印出来        Annotation[] annotations = method.getAnnotations();        for(Annotation annotation : annotations)&#123;            System.out.println(annotation);        &#125;    &#125;&#125;\n\n\n\n注解的分类 通常来说注解分为以下三类\n\n元注解 – java内置的注解，标明该注解的使用范围、生命周期等。\n标准注解 – Java提供的基础注解，标明过期的元素&#x2F;标明是复写父类方法的方法&#x2F;标明抑制警告。\n自定义注解 – 第三方定义的注解，含义和功能由第三方来定义和实现。\n\n元注解用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。\n元注解就是最基本不可分解的注解，我们不能去改变它只能使用它来定义自定义的注解。\n元注解包含以下五种： @Retention、@Target、@Documented、@Inherited、@Repeatable\n@Retention定义\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    RetentionPolicy value();&#125;\n\n标明自定义注解的生命周期，这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。它决定了注解在何时有效以及在何处可用。\n从编写Java代码到运行主要周期为源文件→ Class文件 → 运行时数据，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为SOURCE →CLASS→RUNTIME。\n\nSOURCE：源代码java文件，不会包含在编译后的 class 文件中，编译时候会丢弃\nCLASS：类文件级别保留，class文件中会保留注解，但是jvm加载运行时就没有了，是默认的保留策略\nRUNTIME：运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的\n\n各个生命周期的用途：\n\nSOURCE级别：\n典型应用：Lombok的@Getter、@Setter\n特点：编译后完全消失，不会增加运行时负担\n使用场景：仅用于编译期检查或代码生成\n\n\nCLASS级别：\n典型应用：Android的@Keep注解\n特点：保留到class文件但不会被加载到JVM\n使用场景：字节码分析工具使用\n\n\nRUNTIME级别：\n典型应用：Spring的@Controller、@Service\n特点：可通过反射获取，影响运行时行为\n使用场景：框架开发中最常用\n\n\n\n// Lombok的@Getter示例 SOURCE级别@Retention(RetentionPolicy.SOURCE)public @interface Getter &#123;    AccessLevel value() default AccessLevel.PUBLIC;&#125;// 使用@Getterpublic class User &#123;    private String name;&#125;// 编译时会生成getName()方法，但注解本身不会保留\n\n@Target描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上(类、方法、属性、局部属性、参数…)\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    ElementType[] value();&#125;\n\nvalue是一个数组，可以有多个取值，说明同一个注解可以同时用于标注在不同的元素上。value的取值如下\n@Target可以指定更精确的应用目标，包括：\n@Target(&#123;    ElementType.TYPE,               // 类、接口、枚举    ElementType.FIELD,              // 字段（包括枚举常量）    ElementType.METHOD,             // 方法    ElementType.PARAMETER,          // 方法参数    ElementType.CONSTRUCTOR,        // 构造器    ElementType.LOCAL_VARIABLE,     // 局部变量    ElementType.ANNOTATION_TYPE,    // 注解类型    ElementType.PACKAGE,            // 包    ElementType.TYPE_PARAMETER,     // 类型参数（Java 8+）    ElementType.TYPE_USE            // 类型使用（Java 8+）&#125;)\n\n自定义一个注解@MyAnnotation1想要用在类或方法上，就可以如下定义\n/**    * 自定义注解，使用@Target指定该注解可以应用在哪些元素上    * 这里指定了TYPE(类/接口/枚举等)和METHOD(方法)上    */   @Retention(RetentionPolicy.RUNTIME)    // 运行时保留   @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)  // 只能用于类和方法上   public @interface MyAnnotation &#123;       String description() default &quot;&quot;;   // 注解属性默认值   &#125;   /**    * 测试类，演示@Target的使用    * 因为@MyAnnotation允许用在TYPE上，所以可以用在类声明上    */   @MyAnnotation(description = &quot;这是一个类级别的注解示例&quot;)   public static class AnnotationTest &#123;       // @MyAnnotation   用在属性上则会报错       public String name;       @MyAnnotation(description = &quot;这是一个方法级别的注解示例&quot;)       public void testMethod() &#123;           System.out.println(&quot;测试方法执行&quot;);       &#125;   &#125;\n\n获取其中的注解，只能获取到类和方法上的\npublic static void main(String[] args) &#123;        // 获取类上的注解        MyAnnotation classAnnotation = AnnotationTest.class.getAnnotation(MyAnnotation.class);        System.out.println(classAnnotation.description());        try&#123;            // 获取方法上的注释            Method method = AnnotationTest.class.getMethod(&quot;testMethod&quot;);            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);            System.out.println(annotation.description());        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;\n\n@Inherited表示是否可以被标注类的子类继承。当注解 Inheritable 被 @Inherited 标注时，它具有继承性。否则，没有继承性。\n定义如下\n@Documented   // 说明该注解能出现在 javadoc 中。@Retention(RetentionPolicy.RUNTIME)   // 指定 Inherited 的策略是 RetentionPolicy.RUNTIME@Target(ElementType.ANNOTATION_TYPE)  // @Inherited 只能被用来标注 &quot;Annotation 类型&quot;// 它的用来修饰 Inherited，意味着 Inherited 实现了 Annotation 接口；即 Inherited 就是一个注解。public @interface Inherited &#123;    &#125;\n\n当一个类使用了带有 @Inherited 的注解时，这个注解会被该类的子类继承。\n\n仅对类注解有效：@Inherited 只对类级别的注解有效（即注解的 @Target 包含 ElementType.TYPE）\n不适用于接口：从父类继承的注解不会应用于实现接口的类\n不适用于方法等其他元素：方法上的注解不会被继承\n\n\n示例，通过反射获取注解\n// 定义一个可以被继承的注释@Inherited@Retention(RetentionPolicy.RUNTIME)  // 运行时保留，可以通过反射获取@Target(ElementType.TYPE)  // 只能用于类/接口/枚举上@interface InheritableAnnotation &#123;    String value() default &quot;父类注解&quot;;&#125;// 定义一个不可被继承的注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface NonInheritableAnnotation &#123;    String value() default &quot;不可继承的注解&quot;;&#125;// 父类，带有可继承和不可继承的注解@InheritableAnnotation(&quot;这是父类的可继承注解&quot;)@NonInheritableAnnotation(&quot;这是父类的不可继承注解&quot;)class ParentClass &#123;&#125;// 子类，继承自ParentClass，没有显式添加任何注解class ChildClass extends ParentClass &#123;&#125;\n\n打印注解的信息后可以发现：\n类 ParentClass 上的注解:  InheritableAnnotation:   NonInheritableAnnotation: 类 ChildClass 上的注解:  InheritableAnnotation: \n\n发现ChildClass 类没有继承 NonInheritableAnnotation 注解\n@Repeatable定义如下\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123;    // 指定包含重复注解的容器注解类型    Class&lt;? extends Annotation&gt; value();&#125;\n\n标识某注解可以在同一个声明上使用多次。（Java 8+特性）\n示例：\n// 定义可重复注解@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;// 定义包含可重复注解的容器注解@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations &#123;    MyAnnotation[] value();&#125;// 使用可重复注解@MyAnnotation(&quot;First Annotation&quot;)@MyAnnotation(&quot;Second Annotation&quot;)class MyClass &#123;    // 类的内容&#125;public class RepeatableExample &#123;    public static void main(String[] args) &#123;        // 普通的获取类上的所有 MyAnnotation 注解        // 需要定义容器注解来存放重复注解        // 通过getAnnotationsByType()获取重复注解        MyAnnotation[] annotations = MyClass.class.getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation annotation : annotations) &#123;            System.out.println(annotation.value());        &#125;        // 使用MyAnnotations，获取类上的 MyAnnotations 注解        MyAnnotations container = MyClass.class.getAnnotation(MyAnnotations.class);        if (container != null) &#123;   // 语法糖，相当于是返回一个MyAnnotation[]            for (MyAnnotation annotation : container.value()) &#123;                System.out.println(annotation.value());            &#125;        &#125;    &#125;&#125;\n\n虽然我们标注的是多个@MyAnnotation，其实会给我们返回一个@MyAnnotations，相当于是Java帮我们把重复的注解放入了一个数组属性中\n@Documented定义如下\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\n\n标记注解是否包含在Javadoc中。被@Documented标注的注解会出现在生成的API文档里。\n\n无参数\n只影响文档生成\n常用于重要的API注解\n\n根据 Annotation 生成帮助文档：\n通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。\n标准注解@Override定义\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\n\n标识方法覆写了父类或接口中的方法，提供编译时检查。\n\n仅用于方法\n编译时检查（非强制使用）\n源代码级别（不保留到class文件）\n可防止拼写错误导致意外创建新方法\n\n支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE\n这个天天用，估计大伙都会都知道，很多人注解学习的起步就是@Override\n@Deprecated某个方法被 @Deprecated 标注，则该方法不再被建议使用\n如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息\n\n\n定义如下\n@Documented  // 会出现在doc中@Retention(RetentionPolicy.RUNTIME)   // 指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。// @interface -- 它的用来修饰 Deprecated,即 Deprecated 就是一个注解public @interface Deprecated &#123;&#125;\n\n@SuppressWarnings让编译器对”它所标注的内容”的某些警告保持静默。\n\n定义如下\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();  // SuppressWarnings 能指定参数&#125;\n\n@FunctionalInterface用于标识函数式接口\n定义：\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125;\n使用示例\n@FunctionalInterfaceinterface Greeter &#123;    void greet(String name);        // 可以有默认方法    default void defaultGreet() &#123;        System.out.println(&quot;Hello, world!&quot;);    &#125;&#125;\n\n编译时会检查是否确实是函数式接口\n如果不是（有多个抽象方法），会报错\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"Java注解与Annotation类","url":"/posts/54621.html","content":"Java难绷知识01之对象流本篇文章会探讨一些JavaIO流中比较容易被忽视的对象流，而且会相对的探讨其中的一些细节其中对于对象流的操作讲解会少一些，主要讨论的是一些细节  \n在 Java IO 流中，对象流（ObjectInputStream对象输入流 和 ObjectOutputStream对象输出流）用于将对象进行序列化和反序列化操作  \n对象流及其序列化首先，ObjectInputStream和ObjectOutputStream这两个类都属于是字节流，它们分别继承自InputStream和OutputStream  \n对象输出流，ObjectOutputStream，用于对象的序列化，也就是把Java对象转换成字节序列，把字节序列写出到文件，以这种对象转换为字节序列的机制实现了对象存储序列化目的是能够将整个 Java 对象（包括对象的状态，即成员变量的值）转换为字节流，以便在网络上传输或存储到文件中，之后还能稳定的从字节流中恢复出原来的对象。通过序列化，对象的状态信息（包括成员变量的值）可以被保存下来，以便后续传输或存储。  \n对象输入流，ObjectInputStream，用于对象的反序列化，是将文件中的字节序列恢复为Java对象，以这种字节序列转换为对象的机制实现了对象读取反序列化时，系统会根据字节流中的信息重新构建对象的状态。  \n在其基础上，我们再探讨序列化的一些细节  \n对象序列化的条件要想使一个类的对象能够被序列化，该类必须实现 java.io.Serializable 接口这是一个标记接口，没有任何方法需要实现。实现该接口，意味着告诉 Java 虚拟机这个类的对象可以被序列化。  \n\n点击查看代码\n\nimport java.io.*;// 定义一个实现Serializable接口的类class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;public class SerializationExample &#123;    public static void main(String[] args) &#123;        // 创建一个对象        Person person = new Person(&quot;Alice&quot;, 30);        // 序列化对象到文件        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) &#123;            oos.writeObject(person);            System.out.println(&quot;对象已成功序列化到文件 person.ser&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 从文件反序列化对象        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) &#123;            Person deserializedPerson = (Person) ois.readObject();            System.out.println(&quot;反序列化后的对象: &quot; + deserializedPerson);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注意：\n每个可序列化的类都应该有一个serialVersionUID，用于验证序列化和反序列化过程中的版本兼容性\n使用transient关键字声明的成员变量不会被序列化\n序列化可能会引发安全问题  \n\n对象流的使用细节对象流需要关闭吗先说结论，可以不关但是强烈建议关闭。这与 Java 流的资源管理机制紧密相关。涉及到对外部资源的读写操作，包括网络、硬盘等等的I&#x2F;O流，如果在使用完毕之后不关闭，会导致资源泄漏以及可能会引起文件锁定等问题。  \n当我们使用流进行数据操作时，它们会占用系统资源，如文件句柄、网络连接等。如果不关闭流，这些资源将不会被释放，可能导致资源泄漏问题。长时间运行的程序如果频繁出现资源泄漏，最终可能耗尽系统资源，导致程序崩溃或系统性能严重下降。\n而且关闭流可以确保所有已写入的数据被正确地传输到目标位置例如，当使用 ObjectOutputStream 将对象写入文件时，关闭流会保证缓冲区中的所有数据都被写入文件，避免数据丢失。通常建议使用try - with - resources语句来自动关闭流，示例代码如下  \n\n示例代码\n\nimport java.io.*;class MyClass implements Serializable &#123;    private static final long serialVersionUID = 1L;    int data;    public MyClass(int data) &#123;        this.data = data;    &#125;&#125;public class SerializeExample &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass(42);        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myfile.ser&quot;))) &#123;            oos.writeObject(obj);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n  \n#### 对象流需要使用flush吗\n先说结论，不用  \nObjectOutputStream内部维护了一个缓冲区。在调用writeObject方法时，数据首先会被写入缓冲区。调用flush方法可以强制将缓冲区中的数据立即写入底层输出流。然而，在大多数情况下，并不需要显式调用flush。因为当缓冲区满、流关闭或者调用某些特定方法（如writeObject在某些情况下会触发缓冲区数据的刷新）时，缓冲区的数据会自动被写入底层流。\n当然特意需要弄的时候可以弄  \n\nserialVersionUID在对象流中的必要性凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量：    private static final long serialVersionUID;来表明类的不同版本间的兼容性。  \n在完成序列化操作后，如果对序列化对象进行了修改，那么我们再进行反序列化就会抛出InvalidClassException异常。 因为serialVersionUID缺失（没有显式分配）或者serialVersionUID发生了变化， serialVersionUID的作用在此体现——对序列化对象进行版本控制，有关各版本反序加化时是否兼容。避免混乱。  \nclass Person implements Serializable &#123;    private static final long serialVersionUID = 1234567890123456789L;    private String name;    private int age;    // 后续可以安全地对类结构进行一些兼容的修改&#125;\n一个类在没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。所以建议一般显式声明。  \n序列化的一些细节static修饰的属性 不可以被序列化原因在于 static 变量属于类，而不是类的实例。它们是类级别的共享数据，与对象的状态无关。序列化的目的是保存对象的状态，所以 static 变量不会被包含在序列化的内容中。\nclass StaticExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private static int sharedValue = 10;    private int instanceValue;    public StaticExample(int instanceValue) &#123;        this.instanceValue = instanceValue;    &#125;&#125;\n当我们序列化 StaticExample 类的对象时，sharedValue 不会被序列化。在反序列化时，sharedValue 的值将取决于类加载时的初始化状态，而不是序列化时的值  \ntransient 修饰的属性不可以被序列化transient 关键字用于标记那些不希望被序列化的属性。这在某些场景下非常有用，比如当对象的某个属性包含敏感信息（如密码）或者该属性在反序列化后可以通过其他方式重新计算得到时。\nclass TransientExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String username;    private transient String password;    public TransientExample(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;&#125;\n当对 TransientExample 对象进行序列化时，password 的值不会被写入序列化流。这样可以保护敏感信息，防止其在序列化过程中被泄露。在反序列化后，password 属性的值将为 null，程序可以重新设置该值。\n对象序列化的作用为什么JavaIO流要特意造出这么一个IO流  \n当你需要把对象写入到文件或者读取的时候，其实我们更多的情况通常是保存对象的有效值字段，也就是对象的具体实例的字段，那么使用文件操作流FileOutputStream和字符输出流BufferedWriter或PrintStream就足够。这些流可以用于处理文件写入和基本数据类型及字符串的输出，但对象序列化有着独特且不可替代的作用  \n网络传输对象对象序列化机制是Java内建的一种对象持久化方式，可以很容易实现在JVM中的活动对象与字节流之间进行转换\n在网络传输中，发送端将对象序列化成字节流，经过网络传输到网络的另一端，可以从字节流重新还原为对象，这个特点使得在进行端到端的网络传输数据时候，字节流和Java对象之间的转换稳定且快速。  \n在其中分布式系统中，不同的节点之间需要进行对象的传递，对象序列化使得这种对象传输变得简单直接，确保了对象在不同 Java 虚拟机之间的准确传输，即使这些 JVM 运行在不同的操作系统上。\nRMI 是 Java 的一种远程方法调用机制，它允许一个 JVM 中的对象调用另一个 JVM 中的对象的方法。对象序列化也在其中起着关键作用 \n确保对象深层次的复制和持久化当对一个对象进行序列化然后反序列化时，会得到一个与原对象状态完全相同但内存地址不同的新对象。可以实现在不影响原对象的情况下对对象进行操作，多线程下的数据处理的机制也有一定序列化和反序列化的影子。这种情况对于远程创建对象副本并且调度的时候十分方便，而且不会干扰对象内部包含的复杂的引用关系，合理使用对象流可以大大提高程序处理复杂数据的能力。  \n在很多情况下，对象内部状态是需要被持久化的，序列化通过把对象写为字节流，保存的位置从JVM内存转移到文件系统，在需要的时候随时可以进行快速方便的还原例如：在一个游戏中，可以使用对象流将玩家的游戏进度（一个复杂的对象，包含玩家角色信息、游戏关卡等）保存到文件中，下次玩家启动游戏时可以恢复到上次的进度。  \n对象流与其他流的关系与字节流的关系字符流是对象流的特例，它们处理的是字符数据的序列化和反序列化。\n字符流（Reader 和 Writer 及其子类，如 BufferedReader、BufferedWriter 等）主要用于处理字符数据。Java 采用 Unicode 编码来表示字符，字符流对其的输入输出有优化。而且字符流在处理数据时，会根据指定的字符编码进行字节和字符之间的转换  \n而对象流可以将任何实现了 Serializable 接口的对象进行序列化和反序列化，意味着对象流操作的数据是复杂的对象结构，包括对象的成员变量、对象之间的引用关系。  \n与缓冲流的关系功能叠加：缓冲流（如 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter）的主要作用是提高数据读写的效率，通过在内存中设置缓冲区，减少实际的 I&#x2F;O 操作次数。对象流可以和缓冲流结合使用，以提升对象序列化和反序列化的性能。可以将 ObjectOutputStream 包装在 BufferedOutputStream 中，这样在写入对象时，数据会先写入缓冲区，当缓冲区满或流关闭时，才会一次性将数据写入底层输出流，从而减少磁盘 I&#x2F;O 操作的频率，提高写入效率。在处理大量对象的序列化或反序列化时，结合缓冲流能显著提升性能。不过反序列化涉及到的种种安全关系，这种情况，讨论一下就好。  \n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Servlet与http","url":"/posts/62509.html","content":"软件架构与网络通信软件架构：\n\nB&#x2F;S：浏览器端-服务器端（JavaEE体系）  客户端不用再去开发，开发更加快速\nC&#x2F;S：客户端-服务器端\n\n资源分类：\n\n静态资源：所有用户访问后得到的结果是一样的，称为静态资源\n如html css js\n\n\n动态资源：每个用户访问相同资源后，得到的结构可能不一样，称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器\n如 servlet php jsp\n\n\n\n网络通信三要素：\n\nIP：电子设备在网络中的唯一标识\n端口:应用程序在计算机中的唯一标识\n传输协议：规定了通信的规则\n基础协议：tcp udp\n\n\n\n\n\nhttp概述http：超文本传输协议\n传输协议：定义了客户端和服务器端通信的时候发送数据的格式\n特点：\n\n基于TCP&#x2F;IP的高级协议\n默认端口号是80\n基于请求响应模型，一次请求对应一次响应\n无状态的，每次请求之间相互独立\n\nhttp的请求消息和请求行请求消息数据格式：\n请求行\n明确请求的基本信息（操作类型、目标资源、协议版本）\n请求方式 请求url 请求协议&#x2F;版本    \n请求方法：\n常见方法（Servlet 中常用）\n\n\n\n\n方法\n含义\n特点\n是否有请求体\n\n\n\nGET\n请求获取资源\n请求参数在请求行，数据通过 URL 传递，明文可见，长度有限制（浏览器通常限制 8KB）\n无\n\n\nPOST\n提交数据（如表单）\n数据放在请求体中，适合传输大量数据，安全性较高\n有\n\n\nPUT\n更新资源（全量更新）\n需指定资源完整路径，幂等性（多次操作结果一致）\n有\n\n\nDELETE\n删除资源\n指定 URL 对应的资源，幂等性\n无\n\n\nHEAD\n获取资源头部信息\n仅返回响应头，不返回响应体，用于快速检查资源是否存在\n无\n\n\n请求url：协议:&#x2F;&#x2F;主机:端口&#x2F;路径?查询参数#锚点\n\n协议：固定为http或https（如http://）\n\n主机：服务器域名（如www.example.com）或 IP 地址（如192.168.1.1）\n\n端口：可选，默认80（HTTP）或443（HTTPS），如8080\n\n路径：资源在服务器上的路径（如/user/login）\n\n查询参数：可选，格式为key=value&amp;key2=value2，通过?与路径分隔\n\n锚点：客户端浏览器使用，用于定位页面内元素，服务器不处理\nServlet服务器接收的 URL 部分：不包含锚点，仅到查询参数为止\n\n\n\n请求头\n携带请求的附加信息（客户端环境、请求参数、安全信息等）\n请求头名称：请求头值\n通用头字段：\n\n\n\n字段名\n含义\n示例\nServlet 获取方法\n\n\n\nHost\n目标服务器的主机和端口（必传）\nlocalhost:8080\nrequest.getHeader(&quot;Host&quot;)\n\n\nUser-Agent\n客户端信息（浏览器 &#x2F; 操作系统）\nMozilla/5.0 (Windows NT 10.0) Chrome/110.0.0.0\nrequest.getHeader(&quot;User-Agent&quot;)\n\n\nReferer\n来源页面 URL（防盗链，统计）\nhttp://example.com/login.html\nrequest.getHeader(&quot;Referer&quot;)\n\n\nAccept\n客户端接受的响应内容类型\ntext/html,application/json\nrequest.getHeader(&quot;Accept&quot;)\n\n\n可以在服务器端获取User-Agent该头的信息，解决浏览器端兼容性问题\n与请求体相关的头字段：\n\n\n\n字段名\n含义\n示例\nServlet 关联\n\n\n\nContent-Type\n请求体的数据格式和编码\napplication/x-www-form-urlencoded; charset=UTF-8（表单数据） multipart/form-data; boundary=xxx（文件上传）\n通过request.getContentType()获取\n\n\nContent-Length\n请求体的字节长度\n1024\n通过request.getContentLength()获取\n\n\n\n请求空行\n作为请求头和请求体的分隔符，必须存在且仅包含一个换行符（\\r\\n）\n\n请求体\n封装POST请求消息的请求体的，GET请求没有请求体\n空行之后（可选，非必须），存放请求的具体数据（如表单提交的参数、上传文件内容等）\n\n数据格式\n\n\napplication&#x2F;x-www-form-urlencoded：表单默认格式，键值对编码为key=value&amp;key2=value2，不支持文件上传\nmultipart&#x2F;form-data：文件上传专用格式，通过boundary分隔不同字段，支持二进制数据\napplication&#x2F;json：JSON 格式数据，需在Content-Type头中声明\n\n\nServlet 中获取请求体数据\n\n\n普通表单数据：通过request.getParameter(&quot;参数名&quot;)直接获取（自动解码）\nJSON 数据：需通过request.getReader()或request.getInputStream()手动解析\n文件上传：需使用MultipartHttpServletRequest（需配置MultipartResolver）\n\n\n\n响应消息数据格式\nRequest请求原理\n\nrequest对象和response对象的原理：\n由服务器创建，我们仅使用\nrequest对象获取请求消息，response对象来设置响应消息\n\nrequest对象继承体系的结构Servlet中的HttpServletRequest对象是处理HTTP请求的核心接口\n基本继承层次：\njavax.servlet.ServletRequest (接口)       ↑javax.servlet.http.HttpServletRequest (接口)       ↑org.apache.catalina.connector.RequestFacade (Tomcat实现类)\n\nServletRequest接口这是最基础的请求接口，定义了通用的请求方法，不限于HTTP协议：\n\n核心方法：\ngetParameter(String name) - 获取请求参数\ngetAttribute(String name) - 获取请求属性\nsetAttribute(String name, Object o) - 设置请求属性\ngetInputStream() - 获取输入流\ngetReader() - 获取字符读取器\ngetContentType() - 获取内容类型\ngetLocalAddr() - 获取服务器IP地址\n\n\n\nHttpServletRequest接口继承自ServletResponse接口，专门用来封装HTTP响应消息。  由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。：\n\nHTTP相关方法：\ngetHeader(String name) - 获取请求头\ngetMethod() - 获取HTTP方法(GET&#x2F;POST等)\ngetCookies() - 返回一个cookie对象数组\ngetSession() - 返回与这个请求相关的会话对象\ngetRequestURI() - 获取请求URI\ngetQueryString() - 返回请求URL中的查询字符串\ngetContextPath() - 返回请求上下文的请求URI部分\ngetServletPath() - 获取Servlet路径\n\n\n\n实现类 (以Tomcat为例)Tomcat中的具体实现类结构：\nRequest (org.apache.catalina.connector.Request)       ↑RequestFacade (org.apache.catalina.connector.RequestFacade)\n\n\nRequest：Tomcat内部的实际实现类，包含大量内部方法\nRequestFacade：提供给Servlet开发者的门面类，遵循门面模式，隐藏了内部复杂实现\n\njavax.servlet.http包内容HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：\npublic abstract class HttpServlet extends GenericServlet implements Serializable \n\nHttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。\n\n\nHttpServlet抽象类HttpServlet 抽象类是继承于 GenericServlet 抽象类而来的。\n使用 HttpServlet 抽象类时，还需要借助分别代表 Servlet 请求和 Servlet 响应的 HttpServletRequest 和 HttpServletResponse 对象。\nHttpServletRequest 接口扩展于 javax.servlet.ServletRequest 接口，HttpServletResponse 接口扩展于javax.servlet.servletResponse 接口。\npublic interface HttpServletRequest extends ServletRequest\n\npublic interface HttpServletResponse extends ServletResponse\n\n\n\n其中，HttpServlet 抽象类覆盖了 GenericServlet 抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法。\n这是 GenericServlet 抽象类中定义的service方法：\npublic abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\nHttpServlet 实现的这个 service 方法\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    HttpServletRequest request;    HttpServletResponse response;    try &#123;        request = (HttpServletRequest)req;        response = (HttpServletResponse)res;    &#125; catch (ClassCastException var6) &#123;        throw new ServletException(&quot;non-HTTP request or response&quot;);    &#125;     this.service(request, response);&#125;\n\nHttpServlet 中的 service 方法把接收到的 ServletRequsest 类型的对象转换成了 HttpServletRequest 类型的对象，把ServletResponse 类型的对象转换成了 HttpServletResponse 类型的对象。  \n之所以能够这样强制的转换，是因为在调用Servlet的Service方法时，Servlet容器总会传入一个 HttpServletRequest 对象和 HttpServletResponse 对象，预备使用HTTP。因此，转换类型当然不会出错了。\n转换之后，service方法把两个转换后的对象传入了另一个service方法\n// 参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String method = req.getMethod();    long lastModified;    // 解析HttpServletRequest中的方法参数，并调用以下方法之一，每一种方法都表示一个Http方法。doGet和doPost是最常用的    if (method.equals(&quot;GET&quot;)) &#123;        lastModified = this.getLastModified(req);        if (lastModified == -1L) &#123;            this.doGet(req, resp);        &#125; else &#123;            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if (ifModifiedSince &lt; lastModified) &#123;                this.maybeSetLastModified(resp, lastModified);                this.doGet(req, resp);            &#125; else &#123;                resp.setStatus(304);            &#125;        &#125;    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;        lastModified = this.getLastModified(req);        this.maybeSetLastModified(resp, lastModified);        this.doHead(req, resp);    &#125; else if (method.equals(&quot;POST&quot;)) &#123;        this.doPost(req, resp);    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;        this.doPut(req, resp);    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;        this.doDelete(req, resp);    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;        this.doOptions(req, resp);    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;        this.doTrace(req, resp);    &#125; else &#123;        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[]&#123;method&#125;;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    &#125;&#125;\n\n\n\n\n\n通过request获取内容通过request获得请求行请求行包含HTTP方法、URI和协议版本，例如：GET /test?name=value HTTP/1.1\n// 获取请求方法(GET/POST/PUT/DELETE等)String method = request.getMethod();// 获取请求URL(不包含协议、域名和端口)String requestURL = request.getRequestURL().toString(); // 获取请求URI(相对于Context Path的部分)String requestURI = request.getRequestURI();// 获取查询字符串(问号后面的部分)String queryString = request.getQueryString();// 获取协议和版本String protocol = request.getProtocol(); // HTTP/1.1// 获取上下文路径(web应用的根路径)String contextPath = request.getContextPath();// 获取Servlet路径String servletPath = request.getServletPath();\n\n获取请求头信息请求头包含了客户端环境和请求的附加信息\n// 获取指定请求头的值String userAgent = request.getHeader(&quot;User-Agent&quot;);String accept = request.getHeader(&quot;Accept&quot;);// 获取所有请求头名称的枚举Enumeration&lt;String&gt; headerNames = request.getHeaderNames();// 遍历所有请求头while(headerNames.hasMoreElements()) &#123;    String name = headerNames.nextElement();    String value = request.getHeader(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取Int类型的请求头值int contentLength = request.getIntHeader(&quot;Content-Length&quot;);// 获取日期类型的请求头值long date = request.getDateHeader(&quot;If-Modified-Since&quot;);// 获取多值请求头Enumeration&lt;String&gt; languages = request.getHeaders(&quot;Accept-Language&quot;);\n\n获取请求体请求体主要出现在POST、PUT等请求中，包含客户端发送的数据\n获取表单数据// 获取单个表单参数值String username = request.getParameter(&quot;username&quot;);// 获取多值参数(如复选框)String[] hobbies = request.getParameterValues(&quot;hobby&quot;);// 获取所有参数名的枚举Enumeration&lt;String&gt; paramNames = request.getParameterNames();// 获取所有参数的MapMap&lt;String, String[]&gt; paramMap = request.getParameterMap();// 遍历所有参数paramMap.forEach((key, values) -&gt; &#123;    System.out.print(key + &quot;: &quot;);    for(String value : values) &#123;        System.out.print(value + &quot; &quot;);    &#125;    System.out.println();&#125;);\n\n获取原始请求体// 获取输入流读取原始数据ServletInputStream inputStream = request.getInputStream();BufferedReader reader = request.getReader();// 示例：读取JSON请求体StringBuilder sb = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123;    sb.append(line);&#125;String jsonBody = sb.toString();\n\n获取其他请求信息// 获取客户端IP地址String clientIP = request.getRemoteAddr();// 获取客户端主机名String clientHost = request.getRemoteHost();// 获取客户端端口int clientPort = request.getRemotePort();// 获取服务器信息String serverName = request.getServerName();int serverPort = request.getServerPort();// 获取请求的会话HttpSession session = request.getSession();// 获取Cookie数组Cookie[] cookies = request.getCookies();// 获取内容类型String contentType = request.getContentType();// 获取字符编码String encoding = request.getCharacterEncoding();// 设置字符编码(处理中文乱码)request.setCharacterEncoding(&quot;UTF-8&quot;);\n\n示例处理JSON请求\nprotected void doPost(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 设置字符编码    request.setCharacterEncoding(&quot;UTF-8&quot;);        // 读取JSON请求体    StringBuilder sb = new StringBuilder();    try (BufferedReader reader = request.getReader()) &#123;        String line;        while ((line = reader.readLine()) != null) &#123;            sb.append(line);        &#125;    &#125;        // 解析JSON    JSONObject json = new JSONObject(sb.toString());    String username = json.getString(&quot;username&quot;);    // 处理业务逻辑...&#125;\n\nRequest乱码问题的解决方法Servlet默认编码是ISO-8559-1，需要手动修改编码方式为UTF-8编码\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);  // 解决post提交方式的乱码parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);    //  解决get提交的方式的乱码\n\n\n\n\n\n通过Response设置响应HttpServletResponse对象是Servlet中用于构建HTTP响应的核心接口，它提供了丰富的方法来设置响应状态、响应头和响应体\n设置响应状态设置状态码// 设置成功状态码(200)response.setStatus(HttpServletResponse.SC_OK);// 设置404未找到response.setStatus(HttpServletResponse.SC_NOT_FOUND);// 设置500服务器错误response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);// 设置302重定向(已废弃，推荐使用sendRedirect)response.setStatus(HttpServletResponse.SC_FOUND);\n\n设置状态码和错误消息// 设置状态码和自定义错误消息response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;资源不存在&quot;);// 仅设置状态码(使用默认错误消息)response.sendError(HttpServletResponse.SC_FORBIDDEN);\n\n设置响应头基本响应头设置// 设置单个响应头response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 添加响应头(可设置多个同名头)response.addHeader(&quot;Set-Cookie&quot;, &quot;name=value&quot;);// 设置Int类型响应头response.setIntHeader(&quot;Content-Length&quot;, 1024);// 设置日期类型响应头response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis() + 3600000);\n\n常用响应头快捷方法// 设置内容类型和字符编码(等同于setHeader(&quot;Content-Type&quot;, ...))response.setContentType(&quot;text/html;charset=UTF-8&quot;);// 设置内容长度(等同于setIntHeader(&quot;Content-Length&quot;, ...))response.setContentLength(1024);// 设置字符编码(单独设置)response.setCharacterEncoding(&quot;UTF-8&quot;);\n\n设置响应体获取输出流// 获取字节输出流(用于二进制数据)// 获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。ServletOutputStream outputStream = response.getOutputStream();// 获取字符输出流(用于文本数据)// 获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。PrintWriter writer = response.getWriter();\n\n注意，其中response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。\n重定向相关302重定向// 简单重定向(相对路径)response.sendRedirect(&quot;newPage.html&quot;);// 重定向到绝对URLresponse.sendRedirect(&quot;http://example.com/newPath&quot;);// 重定向到上下文路径下的资源response.sendRedirect(request.getContextPath() + &quot;/secured/page.jsp&quot;);\n\n请求转发(服务器内部)// 获取转发器RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/target.jsp&quot;);// 转发请求和响应dispatcher.forward(request, response);\n\n示例RESTful API响应protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);        try (PrintWriter out = response.getWriter()) &#123;        JSONObject json = new JSONObject();        json.put(&quot;status&quot;, &quot;success&quot;);        json.put(&quot;data&quot;, new JSONObject()            .put(&quot;id&quot;, 123)            .put(&quot;name&quot;, &quot;张三&quot;)            .put(&quot;email&quot;, &quot;zhangsan@example.com&quot;));                out.print(json.toString());    &#125;&#125;\n\n文件下载protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        String fileName = &quot;example.pdf&quot;;    String filePath = &quot;/path/to/files/&quot; + fileName;        response.setContentType(&quot;application/pdf&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        try (InputStream in = new FileInputStream(filePath);         OutputStream out = response.getOutputStream()) &#123;                byte[] buffer = new byte[4096];        int length;        while ((length = in.read(buffer)) &gt; 0) &#123;            out.write(buffer, 0, length);        &#125;    &#125;&#125;\n\n乱码问题response缓冲区的默认编码也是iso8859-1\nresponse.setCharacterEncoding(&quot;utf-8&quot;);  // 更改response的编码方式为UTF-8\n\n更改response的编码方式为UTF-8，只是其中一步，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。\n// 通知浏览器使用utf8response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);\n\nresponse.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)方法即可。\n\nServlet的工作流程\n\n关于Web基础部分\nJavaWeb-http\n引用文章\nJavaWeb——HTTP详解\nJavaWeb——Servlet\n菜鸟教程Servlet部分\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaEE","Web","JavaWeb","Servlet"]},{"title":"Servlet学习之核心接口,工作原理和配置","url":"/posts/4234.html","content":"什么是Servlet运行在服务器端的程序\nservlet是一个接口，定义了Java类被浏览器访问到的规则（接口）\nServlet是用java编写的服务器端的程序，主要是交互式的浏览和修改数据，生成动态Web内容，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上\nServlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\nStruts2的核心用的是Filter（过滤器），而SpringMVC的核心用的就是Servlet。\n// WebServlet注解表示这是一个Servlet，并映射到地址/:@WebServlet(urlPatterns = &quot;/&quot;)public class HelloServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;        // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;&#125;\n\n一个Servlet总是继承自HttpServlet，然后重写doGet()或doPost()方法。注意到doGet()方法传入了HttpServletRequest和HttpServletResponse两个对象，分别代表HTTP请求和响应。我们使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为HttpServletRequest和HttpServletResponse就已经封装好了请求和响应\n工作模式\n客户端发送请求至服务器\n服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器\n服务器将响应返回客户端\n\nAPI预览Servlet API 包含以下4个Java包：\n1.javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。\n2.javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。\n3.javax.servlet.annotation   其中包含标注servlet，Filter,Listener的标注。它还为被标注元件定义元数据。\n4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。\n使用ServletServlet技术的核心是Servlet，它是所有Servlet类必须直接或者间接实现的一个接口。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。\n工作原理​    Servlet接口定义了Servlet与servlet容器之间的契约：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。\n​    但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​    用户请求致使Servlet容器调用Servlet的Service()方法,并传入一个ServletRequest对象和一个ServletResponse对象。 ServletRequest中封装了当前的Http请求,ServletResponse表示当前用户的Http响应.\n​     对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。\n接口中定义的方法public interface Servlet &#123;    // 这是 Servlet 的初始化方法，在 Servlet 实例被创建之后，容器会调用此方法对 Servlet 进行初始化操作。    void init(ServletConfig var1) throws ServletException; \t    // 用于获取 Servlet 的配置信息，会返回由Servlet容器传给init（ ）方法的ServletConfig对象    ServletConfig getServletConfig(); \t    // 用来处理客户端的请求并生成响应。当有客户端请求到达时，Servlet 容器会调用这个方法。    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; \t    // 用于返回 Servlet 的描述信息    String getServletInfo(); \t    // 这是 Servlet 的销毁方法，在 Servlet 实例被销毁之前，容器会调用此方法，用于释放 Servlet 占用的资源    void destroy();&#125;\n\n执行原理当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\n查找Web.xml文件，是否有对应的标签体的内容，如果有，则在对应的全类名\ntomcat会将其字节码加载进内存然后构建对象，调用其方法\nServlet的生命周期上述接口中定义的方法内，init( ),service( ),destroy( )是Servlet生命周期的方法。\nServlet容器（例如TomCat）会根据下面的规则来调用这三个方法：\n\n当Servlet第一次被请求时，Servlet容器就会开始调用 init() 方法，初始化一个Servlet对象出来,这个方法在后续请求中不会在被Servlet容器调用。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。\n\nservice( )方法，每当请求Servlet时，Servlet容器就会调用这个方法，第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。\n\ndestory,当要销毁Servlet时，Servlet容器就会调用这个方法，一般在这个方法中会写一些清除代码，只有服务器正常关闭的时候，才会执行destory方法\n演示代码\n@Overridepublic void init(ServletConfig servletConfig) throws ServletException &#123;    System.out.println(&quot;Servlet正在初始化&quot;);&#125; @Overridepublic ServletConfig getServletConfig() &#123;    return null;&#125; @Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;    //专门向客服端提供响应的方法    System.out.println(&quot;Servlet正在提供服务&quot;); &#125; @Overridepublic String getServletInfo() &#123;    return null;&#125; @Overridepublic void destroy() &#123;    System.out.println(&quot;Servlet正在销毁&quot;);&#125;\n\n其中servlet的创建时期是可以被指定的\n&lt;!-- 指定servlet的创建时期，负数为第一次访问时期，0或正数为服务器启动时期--&gt;&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;\n\nServlet中的 init 方法只执行一次，说明一个Servlet中只存在一个对象，是单例的，多个用户同时访问可能存在线程安全的隐患，所以尽量不要再其中定义成员变量，也不要对其赋值\nTomcat部分普通的Java程序是通过启动JVM，然后执行main()方法开始运行。但是Web应用程序有所不同，我们无法直接运行war文件，必须先启动Web服务器，再由Web服务器加载我们编写的HelloServlet，这样就可以让HelloServlet处理浏览器发送的请求。\nTomcat本身的目录层次结构\n\nTomcat提供了一个部署其服务器在你本地电脑上的功能\n​\t实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机\n​\t执行Tomcat的main()方法，然后由Tomcat负责加载我们的.war文件，并创建一个HelloServlet实例，最后以多线程的模式来处理HTTP请求。\n​\t如果Tomcat服务器收到的请求路径是/（假定部署文件为ROOT.war），就转发到HelloServlet并传入HttpServletRequest和HttpServletResponse两个对象。\n配置Servletweb.xml配置web.xml 文件是用于配置 Web 应用程序的核心文件，它能对 Servlet、过滤器、监听器等组件进行配置\nServlet 定义&lt;servlet&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.ergoutree.servletexpdemo.demo1.FastGo&lt;/servlet-class&gt;&lt;/servlet&gt;\n\n\n标签：该标签的作用是定义一个 Servlet。在一个 web.xml 文件中，可以定义多个 Servlet。\n标签：这里为 Servlet 指定一个名称，也就是 ServletExpDemo。这个名称属于逻辑名称，主要用于在 web.xml 文件的其他部分引用该 Servlet。\n标签：它指定了 Servlet 类的全限定名，即 org.ergoutree.servletexpdemo.demo1.FastGo。当 Web 容器启动时，会依据这个全限定名来加载并实例化该 Servlet 类。\n\nServlet 映射&lt;servlet-mapping&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n标签：此标签的功能是将 Servlet 与一个或多个 URL 模式进行映射。当客户端发送请求时，Web 容器会根据请求的 URL 找到对应的 Servlet。\n标签：这里引用了之前定义的 Servlet 的名称，也就是 ServletExpDemo。\n标签：它指定了与该 Servlet 关联的 URL 模式，即 /demo1。当客户端请求的 URL 匹配这个模式时，Web 容器就会将请求转发给 ServletExpDemo 所对应的 Servlet 类（也就是org.ergoutree.servletexpdemo.demo1.FastGo）进行处理。\n\n原理及其示例原理说明当客户端向 Web 应用程序发送 HTTP 请求时，Web 容器（像 Tomcat 这类）会按照以下步骤处理请求：\n\n解析请求 URL：Web 容器对客户端请求的 URL 进行解析，从中提取出请求的路径部分。\n查找 Servlet 映射：Web 容器在 web.xml 文件里查找与请求路径相匹配的 &#96;&#96;。\n定位 Servlet：若找到匹配的 ，Web 容器会根据对应的  找到之前定义的 Servlet。\n实例化并调用 Servlet：Web 容器加载并实例化该 Servlet 类，然后调用其 service() 方法来处理请求。\n返回响应：Servlet 处理完请求后，将响应返回给客户端。\n\n示例假设客户端发送的请求 URL 为 http://localhost:8080/yourApp/demo1，Web 容器会进行如下操作：\n\n解析出请求路径为 /demo1。\n在 web.xml 文件中找到 为 `/demo1` 的。\n根据 &#96;&#96; 为 ServletExpDemo，找到对应的 Servlet 类 org.ergoutree.servletexpdemo.demo1.FastGo。\n加载并实例化 FastGo 类，调用其 service() 方法处理请求。\n将处理结果返回给客户端。\n\nSerlvet3.0的注解配置@WebServlet 的属性列表：\n![image-20250412202207184](D:\\WorkSpace\\github space\\hexo-blog\\source_posts\\Servlet学习之核心接口，工作原理和配置\\image-20250412202207184.png)\n核心注解**@WebServlet**取代  和 ，直接绑定 URL 模式与 Servlet 类。\n@WebServlet(    name = &quot;userServlet&quot;, // Servlet 名称（可选）    urlPatterns = &#123;&quot;/user&quot;, &quot;/api/user&quot;&#125;, // 支持多 URL 模式    loadOnStartup = 1, // 容器启动时立即加载（替代 &lt;load-on-startup&gt;）    initParams = &#123;        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;) // 初始化参数    &#125;,    asyncSupported = true // 启用异步支持（默认 false）)public class UserServlet extends HttpServlet &#123; ... &#125;\n\n\nurlPatterns：支持精确匹配 (/user)、通配符 (/api/*)、后缀匹配 (*.do)。\n\nloadOnStartup：值越小优先级越高，控制 Servlet 初始化顺序。\n\nasyncSupported：异步处理开关，需配合 AsyncContext 使用（后文详解）。\n\n\n@WebFilter：声明过滤器替代  和，定义请求预处理和后处理逻辑。\n@WebFilter(    filterName = &quot;auditFilter&quot;,    urlPatterns = &quot;/*&quot;, // 过滤所有请求    servletNames = &#123;&quot;userServlet&quot;&#125;, // 针对特定 Servlet    dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.ASYNC&#125;)public class AuditFilter implements Filter &#123; ... &#125;\n\n\ndispatcherTypes：控制过滤器作用的请求类型（如 FORWARD、ERROR）。\n执行顺序问题：注解无法直接指定顺序，需通过类名自然排序或结合 web.xml 的 &#96;&#96;。\n\n@WebListener：事件监听器简化监听器的声明，覆盖 Servlet 上下文、会话、请求等生命周期事件。\n@WebListenerpublic class AppContextListener implements ServletContextListener &#123;    @Override    public void contextInitialized(ServletContextEvent sce) &#123;        // 应用启动逻辑    &#125;&#125;\n\n\n\n异步处理在 @WebServlet 或 @WebFilter 中设置 asyncSupported = true。\n流程：\n\n开启异步上下文：AsyncContext asyncContext = request.startAsync()。\n提交耗时任务到其他线程（如数据库查询、远程调用）。\n任务完成时，通过 asyncContext.complete() 或返回响应。\n\n@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)public class AsyncServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;        AsyncContext ctx = req.startAsync();        CompletableFuture.runAsync(() -&gt; &#123;            // 模拟耗时操作            ctx.getResponse().getWriter().write(&quot;Async Response&quot;);            ctx.complete();        &#125;);    &#125;&#125;\n\n\n\n模块化部署介绍Servlet 3.0 模块化特性：\n\n允许将 Web 组件（Servlet、Filter、Listener）打包为 JAR 文件，置于 WEB-INF/lib 目录。\n容器自动扫描 JAR 中的 META-INF/web-fragment.xml 和注解，实现“即插即用”\n\n注意情况如果使用@WebServlet Annotation（注解）来配置Servlet，需要注意：\n① 不要在 web.xml 文件的根元素（&lt;web-app—&#x2F;&gt;）中指定 metadata-complete&#x3D;“true”；② 不要在 web.xml 文件中再次配置该 Servlet 相关属性\nServletRequest 和 ServletResponse 为 Servlet 提供了处理客户端请求和发送响应的能力；ServletConfig 为 Servlet 提供了配置信息；ServletContext 为 Servlet 提供了整个 Web 应用程序的上下文环境。它们共同协作，使得 Servlet 能够正常运行并处理客户端的请求。\nServletRequset接口Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\nServletRequest接口的部分内容：\npublic interface ServletRequest &#123;    int getContentLength();//返回请求主体的字节数    String getContentType();//返回主体的MIME类型    String getParameter(String var1);//返回请求参数的值&#125;\n\n\n\nServletResponse接口javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。\nServletResponse隐藏了向浏览器发送响应的复杂过程。在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。\nServletResponse内部定义的方法：\npublic interface ServletResponse &#123;    String getCharacterEncoding(); \t// 在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型,加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。    String getContentType(); \t// 发送二进制数据的    ServletOutputStream getOutputStream() throws IOException; \t// PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。    PrintWriter getWriter() throws IOException;     void setCharacterEncoding(String var1);     void setContentLength(int var1);     void setContentType(String var1);     void setBufferSize(int var1);     int getBufferSize();     void flushBuffer() throws IOException;     void resetBuffer();     boolean isCommitted();     void reset();     void setLocale(Locale var1);     Locale getLocale();&#125;\n\n\n\nServletConfig接口当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。\n其中几个方法如下：\n\nServletContext对象ServletContext对象表示Servlet应用程序，是Servlet的上下文对象。每个Web应用程序都只有一个ServletContext对象。\n在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。\n通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。\n有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中\nServletContext中的下列方法负责处理属性：\nObject getAttribute(String var1);  // 获取 ServletContext 中指定名称的属性值 // 用于获取 ServletContext 中所有属性的名称。返回的是一个 Enumeration 对象，通过它可以遍历所有属性的名称。Enumeration&lt;String&gt; getAttributeNames(); void setAttribute(String var1, Object var2);    // 向 ServletContext 中设置一个属性 void removeAttribute(String var1);    // 从 ServletContext 中移除指定名称的属性\n\n\n\n关于Servlet与http相关的应用，下一部分是这个\nServlet与http\n关于Web基础部分\nJavaWeb-http\n引用文章\nJavaWeb——HTTP详解\nJavaWeb——Servlet\n菜鸟教程Servlet部分\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaEE","JavaWeb","Servlet"]},{"title":"markdown常用语法","url":"/posts/43275.html","content":"markdown常用语法标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n#后必须要有空格还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。Heading level 1===============Heading level 2---------------在实际渲染中，’#’ 号数量对应标题级别，一个 ‘#’ 是一级标题，两个 ‘#’ 是二级标题，以此类推。#的叠加可以很多，但是当过多之后，会变的比正常字体还要小，可以利用这个特性***## 段落和换行#### 换行句子末尾双空格代表换行。或者多个空格进行换行 貌似也可以#### 段落处理段落就是用空白行将一行或多行文本进行分割注意：不要用空格（spaces）或制表符（ tabs）缩进段落。***## 强调*斜体文本*   前后各添加一个星号或下划线  _斜体文本_**粗体文本**   前后各添加两个星号或下划线  __粗体文本__***加粗斜体文本***~~删除线文本~~粗体和斜体可以混合用***## 代码块行内代码：用反引号 包裹代码片段，如System.out.println(“Hello World”);代码块：使用三个反引号  包裹代码块，并可在其后指定语言（可选，用于语法高亮）​```代码语言内部代码注意```需要闭合  貌似三个波浪号也可以~~~ ~~~### 链接- **行内式链接**：`[链接文本](链接地址 &quot;可选标题&quot;)`，例如：[百度](https://www.baidu.com &quot;百度首页&quot;)- **参考式链接**：[链接文本][链接标识][链接标识]: 链接地址 &quot;可选标题&quot;***## 引用&gt; 这是一段引用文本&gt; 引用可以有多行&gt; 若有多段引用，可在每段前加 &gt; 符号。&gt; 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。块引用可以包含其他 Markdown 格式的元素。但并非所有元素都可以使用我已经验证了强调和段落换行表格可以用​&#96;&#96;&#96;markdown&gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用&gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用  &gt; &gt; &gt;&gt; &gt; &gt; ***## 分割\n\n以上三种写法都可生成一条分隔线。  ***## 列表### 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。  数字不必按数学顺序排列，但是列表应当以数字 1 起始。  ​```markdown1. 列表项12. 列表项2   1. 子列表项1   2. 子列表项23. 列表项3\n无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n- 列表项1  - 子列表项1  - 子列表项2+ 列表项2* 列表项3\n列表中来回嵌套的问题在如果需要列表中嵌套其他元素，基本所有都可以，甚至图片，拿代码块举例子要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符  \n1.  列表行12.  下面是代码        &amp;&lt;html&gt;          &amp;lt;head&gt;            &amp;lt;title&gt;Test&amp;lt;/title&gt;          &amp;lt;/head&gt;3.  同样的，列表也可以嵌套列表\n\n列表行1\n\n下面是代码\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Test&amp;lt;/title&gt;\n  &lt;/head&gt;\n\n\n同样的，列表也可以嵌套列表\n\n\n\n表格基本表格语法表头与内容分隔：使用 | 来分隔表格的列，表头与表格内容之间通过 — 分隔，— 还可用于指定列的对齐方式。  \n| 表头1 | 表头2 | 表头3 || :---: | :-- | --: || 居中内容 | 左对齐内容 | 右对齐内容 || 第二行数据1 | 第二行数据2 | 第二行数据3 |\n\n\n\n表头1\n表头2\n表头3\n\n\n\n居中内容\n左对齐内容\n右对齐内容\n\n\n第二行数据1\n第二行数据2\n第二行数据3\n\n\n表格内容换行如果表格内容需要换行，可以直接在 Markdown 源文件中使用 HTML 的  标签。支持扩展语法的编辑器中，也可以通过在单元格内容中按回车键进行换行，然后适当缩进以保持格式。  \n| 列1 | 列2 || ---- | ---- || 长内容 &lt;br&gt; 换行显示 | 其他内容 |\n\n\n\n列1\n列2\n\n\n\n长内容  换行显示\n其他内容\n\n\n合并单元格标准 Markdown 语法本身不支持直接合并单元格。不过，在一些特定的 Markdown 渲染器（如在 Markdown 中嵌入 HTML 时），可以使用 HTML 的  标签来实现。  \n\n图片行内式图片：例如：，换成你自己的图片链接参考式图片：\n![替代文本][图片标识][图片标识]: 图片地址 &quot;可选标题&quot;\n\n任务列表任务列表可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。\n- [x] Write the press release- [ ] Update the website- [ ] Contact the media\n\n Write the press release\n Update the website\n Contact the media\n\n\n转义字符在字符前面添加反斜杠字符 \\ ，这样markdown会识别不去执行该符号例如* Without the backslash, this would be a bullet in an unordered list.  \n\nWithout the backslash, this would be a bullet in an unordered list.  不加就会被识别成列表\n\n\n内嵌html代码对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到Markdown 文本中即可html里面咋用，在这里就可以咋用  \n\n插入表情符号可以简单地从Emojipedia 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。\n目录导航[[TOC]]  \n隐藏注释\n数学公式本质上就是插入latex代码，但是在markdown中插入latex代码需要用两个$符号\n行内公式：$E=mc^2$块级公式：$$\\begin&#123;bmatrix&#125;1 &amp; 0 \\\\0 &amp; 1\\end&#123;bmatrix&#125;$$\n\n流程图（需渲染器支持）`&#96;&#96;mermaid\ngraph TD\n  A[开始] –&gt; B(处理逻辑)\n  B –&gt; C{判断}\n  C –&gt;|是| D[结果1]\n  C –&gt;|否| E[结果2]\n`&#96;&#96;\ngraph TD    A[开始] --&gt; B(处理逻辑)    B --&gt; C&#123;判断&#125;    C --&gt;|是| D[结果1]    C --&gt;|否| E[结果2]\n\n","categories":["实用","语言方面"],"tags":["语言方面","实用工具","常用知识"]},{"title":"Hello World","url":"/posts/16107.html","content":"常用命令Quick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nWrite Draftshexo n draft draft1\n\n在source\\目录下创建_drafts目录，并生成一个draft1.md文件\n当你编辑完草稿后，可以把文章推送到_posts目录下\n$ hexo publish &lt;file_name&gt;\n\n或\nhexo --draft\n\nDeploy In Github# 清理旧文件hexo clean# 生成新文件hexo g# 部署到 GitHub Pageshexo dhexo server\n\n\n\n引用图片![alt](path [title])\n\npath是必选的，表示图片的路径，可使用绝对或相对路径。\nalt是可选的，是图片无法加载时的替代描述文本。\ntitle是可选的，是图片的标题\n将所有文章的图片放到source/images 文件夹中，然后使用markdown语句引用图片\n或\n为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：\n\n在博客根目录打开_config.yml文件做如下修改：yaml post_asset_folder: true\n然后使用hexo n text命令后创建一个使用post布局名为text的文章，你将发现hexo在\\source\\_post文件夹下创建了一个\\text文件夹以及同名的.md文件：\n最后就可以打开text.md文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。注意：请不要自作聪明将text.md文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用\n\nhexo插入图片的原生语法使用 Hexo 的 asset_img 标签\n&#123;% asset_img 文件名.后缀 图片描述 %&#125;\n\n\n需要将图片放在 source/images/ 目录下（或 _config.yml 中 post_asset_folder: true 时与文章同名的文件夹中）\n文件名需要包含后缀（如 .jpg, .png 等）\n\n使用 HTML 的 标签&lt;img src=&quot;图片路径&quot; alt=&quot;图片描述&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;\n\n\n\n\n\n插入视频&lt;video width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;source src=video_path&gt;&lt;/video&gt;\n\n\nvideo_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。\nwidth和height是视频区块的宽度和高度，可自定义。\n\n引用和代码区块&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content...&#123;% endblockquote %&#125;\n\n例如：\nQuick Start\nluzhengli hello-worldluzhengli.github.io/2020/04/10/hello-world\n\n还有一种简单的引用语法：\n&gt; 这也是引用&gt;&gt; 引用1&gt;&gt; 饮用2\n\n\n这也是引用\n引用1\n饮用2\n\n代码用Hexo的太麻烦了\n用markdown原来的&#96;&#96;&#96;得了\n文章写完之后编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。\n生成&#x2F;删除静态文件\n 生成静态文件命令：hexo generate或 hexo g 删除静态文件命令：hexo clean\n\n正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。\n如果发生了一些错误，可以先删除静态文件，然后再重新生成。hexo g命令还提供了一个参数-f提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。\n启动本地端口\n 命令：hexo server或 hexo s\n\n"},{"title":"把Hexo博客配置到Github Pages下","url":"/posts/53748.html","content":"使用 Hexo+GitHub 搭建个人博客前情提要你需要自己去安装nodejs和git的环境，因为Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。\n这种教程csdn一搜一大堆啊，基本照着做都是下一步和最后的配置环境变量\n\nNode.js：https://nodejs.org/zh-cn\n\nGit：https://git-scm.com/downloads\n\n\n安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version 并回车，出现程序版本号即可。\n然后你需要自己去注册一个GitHub账号，这里强烈建议设置SSH密钥\n安装Hexo新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog\n安装Hexo使用 npm 一键安装 Hexo 博客程序：\n注意：建议之后所有使用命令行安装操作都使用 管理员模式下的cmd\nnpm install -g hexo-cli\n\n比较难绷的是安装时候界面没有任何反应，而且时间还不短\n初始化Hexo初始化并安装所需组件\nhexo init      # 初始化npm install    # 安装组件\n\n完成后依次输入下面命令，启动本地服务器进行预览：\nhexo g   # 生成页面hexo s   # 启动预览\n\n访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！\n\n如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。\n博客文件目录结构\n创建一个Github仓库来存放你的静态页面GitHub 主页右上角加号 -&gt; New repository：\n​\t注意，这里的仓库名字是 用户名.github.io   最好选上 “Initialize this repository with a README”\n此时如果你在这个仓库上配置博客的话，博客地址为：https://用户名.github.io\n部署到Github Pages本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。\n首先安装 hexo-deployer-git：\nnpm install hexo-deployer-git --save\n\n然后修改博客根目录下的 _config.yml 文件末尾的 Deployment 部分，修改成如下：\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: main\n\n这里说一下yml文件的格式，yml缩进有严格的格式要求，而且每个字段后的冒号之后必须有空格才能输入有效\n完成后运行 hexo d 将网站上传部署到 GitHub Pages。\n完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。\n绑定域名博客搭建完成使用的是 GitHub 的子域名（用户名.http://github.io），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。\n建议这里使用免实名的域名，实名一个域名比较麻烦，而且要等\n域名注册和解析\n域名注册和解析教程：Namesilo 域名购买及使用教程\n\n按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 用户名.github.io。\n\n绑定域名到 Hexo 博客进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如 http://www.example.com，保存名称为 “CNAME”，格式为 “所有文件”（无 .txt 后缀）。\n清除缓存等文件并重新发布网站：\nhexo clean   # 清除缓存文件等hexo g       # 生成页面hexo s       # 启动预览\n\n现在就可以使用自己的域名访问 Hexo 博客了。\n开启HTTPS配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。\n\nHTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！\n关于使用发布文章进入博客所在目录，右键打开 Git Bash Here，创建博文：\nhexo new &quot;My New Post&quot;\n\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。\n写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。\nhexo g   # 生成页面hexo d   # 部署发布\n\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。\n---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文\n\n\n\n常用命令hexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助\n\n我的另一篇博客也提到了hexo命令的基本用法，可以看看\nHexo命令的基本用法\n","categories":["教程","配置教程"],"tags":["Hexo相关","教程","部署"]},{"title":"自定义注解","url":"/posts/13512.html","content":"注解的基本结构以重写为例子了解基本结构package java.lang;import java.lang.annotation.*;/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: *  * &lt;ul&gt;&lt;li&gt; * The method does override or implement a method declared in a * supertype. * &lt;/li&gt;&lt;li&gt; * The method has a signature that is override-equivalent to that of * any public method declared in &#123;@linkplain Object&#125;. * &lt;/li&gt;&lt;/ul&gt; *  * @author  Peter von der Ah&amp;eacute; * @author  Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\n\n注解的名称：\npublic @interface Override &#123;&#125;\n\n注解的元注解\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)\n\n这两个注解是注解中用到最多的元注解\n总结：\n注解分为两部分 :\n\n元注解 ;\n\npublic @interface 注解名称 ;\n\n\n注解的本质按照 public @interface 注解名称 格式 , 写出一个注解 , 编译该注解代码生成 Annotation.class 字节码文件 ;\npublic @interface Annotation &#123;&#125;\n\n使用 javap 命令反编译 Annotation.class 字节码文件 , 查看该注解的实际代码 ;\n发现输出\npublic interface Annotation extends java.lang.annotation.Annotation &#123;&#125;\n\n所以说，注解的本质是一个 interface 接口 , 注解接口默认继承了 java.lang.annotation.Annotation 接口 ;\n有如下关键特性：\n\n注解接口隐式继承Annotation接口\n不能显式实现其他接口\n不能包含泛型参数\n不能抛出异常\n\n注解的属性注解的属性注解的本质是接口 , 接口中可以定义 常量 和 方法 ;\n在注解中定义 接口方法 , 就是 注解的属性 ;\n为注解添加属性 : 接口中的方法都是抽象方法 , 其中 public abstract 可以省略 ;\npublic @interface Annotation &#123;    public abstract String path();   // Annotation接口 实现的接口 Annotation 中定义的注解属性(抽象方法)&#125;\n\n使用\n@注解名称(属性名称 = 属性值)\n\n@Annotation(path = &quot;&quot;)Student(String name, int age)&#123;&#125;\n\n属性定义规则\npublic @interface RequestMapping &#123;    String path();                // 必需属性    String method() default &quot;GET&quot;;// 可选属性    String[] params() default &#123;&#125;; // 数组属性&#125;\n\n\n\n\n\n注解的属性类型注解中定义了属性 , 在使用注解时 , 需要 给 注解属性 赋值 ;\n定义 注解属性 时 , 可以 使用 default 关键字 指定属性默认值 \nint intValue() default 666;   // 制定 注解属性 intValue 值类型为 int 整型 , 默认值 666 \n\n\n如果 注解属性 指定了默认值 , 在使用注解时 , 可以选择 不为该属性赋值 ( 此时使用默认属性值 ) , 也可以进行赋值 ( 指定一个新的属性值 ) ;\n\n如果 注解属性 没有指定默认值 , 则使用 注解 时 , 必须为其指定一个默认值 , 否则编译时报错 ;\n\n\n注解属性 ( 接口方法 ) 返回值类型要求 :\n\n基本数据类型 : byte , short , int , long , float , double , char , boolean ;\n字符串类型 : String ;\n枚举类型 : enum ;\n注解类型 ;\n其他注解类型\n以上类型的数组形式 ，不允许多维数组\n\n禁止的类型：\n\n自定义对象类型\n泛型类型（如List）\nnull值（默认值不能为null）\n\n注解属性返回值必须是以上的类型 , 不能设置其它类型返回值 , 否则会报错 ;\n赋值简化操作：\n如果 注解属性 名称是 value , 并且 注解中只有 1 个属性 , 那么在使用 注解 为 注解属性 赋值时 , 可以省略注解名称 , 直接传入 注解属性值 ;\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;// 使用 SuppressWarnings 注解时 , 直接传入 “all” 参数 , 省略了注解属性名称 ;    @SuppressWarnings(&quot;all&quot;)    @Override    public String toString() &#123;        return super.toString();    &#125;// 注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\n\n注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\n自定义一个注解\n使用@interface来申明一个自定义注解时，他会自动继承ava.lang.annotation.Annotation接口。\n格式public @interface xxx(注解名称){定义注解参数内容}。\n\n// 1. 定义带参数的注解@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ApiVersion &#123;    String group() default &quot;default&quot;;    int[] versions();  // 必须显式赋值&#125;// 2. 使用注解@ApiVersion(group = &quot;user&quot;, versions = &#123;1, 2&#125;)public class UserController &#123;    @ApiVersion(versions = &#123;2&#125;) // 使用默认group    public void updateUser() &#123;...&#125;&#125;// 3. 通过反射处理注解Class&lt;UserController&gt; clazz = UserController.class;ApiVersion classAnnotation = clazz.getAnnotation(ApiVersion.class);if (classAnnotation != null) &#123;    System.out.println(&quot;Supported versions: &quot; +         Arrays.toString(classAnnotation.versions()));&#125;\n\n如果是注解有参数，需要在注解里面添加参数类型\n参数格式： 类型 + 名称();\n加了参数后，使用注解如果不添加参数的话会报错，除非添加默认值\n参数设计建议\n\n当只有一个参数时，建议命名为value\n数组参数建议提供空数组默认值（default &#123;&#125;）\n复杂参数使用注解嵌套：\n\n\n如果只有一个参数可以直接使用value命名，这样在使用注解的时候可以省略’名称&#x3D;“xx”’直接赋值\n注解的使用自定义注解的使用需要用到反射的原理\n//作用于类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface ClassAnno&#123;    String value();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoName&#123;    String name();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoAge&#123;    int age();&#125;public class CustomAnnotationExample &#123;    public static void main(String[] args) &#123;        // 获取类的注解信息        Class&lt;Person&gt; personClass = Person.class;   // 反射获取        if (personClass.isAnnotationPresent(ClassAnno.class)) &#123;            // 取出Annotation注解信息            ClassAnno classAnno = personClass.getAnnotation(ClassAnno.class);            System.out.println(&quot;类注解信息: &quot; + classAnno.value());        &#125;        // 获取属性的注解信息        // 需要注意的是，类是默认缺省的，是有访问权限的。而name和age是私有private的，无法直接获取到Filed对象，需要使用getDeclaredField以及getDeclaredAnnotation获取        Field[] fields = personClass.getDeclaredFields();  // getDeclaredFields()反射获取        for (Field field : fields) &#123;            if (field.isAnnotationPresent(FiledAnnoName.class)) &#123;                // 使用反射获取Student注解信息annotations 可以获取到注解里面的值是多少                FiledAnnoName filedAnnoName = field.getAnnotation(FiledAnnoName.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoName.name());            &#125;            if (field.isAnnotationPresent(FiledAnnoAge.class)) &#123;                FiledAnnoAge filedAnnoAge = field.getAnnotation(FiledAnnoAge.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoAge.age());            &#125;        &#125;    &#125;\n\n\n\n\n\n\n\n引用\n【Java 注解】自定义注解 ( 注解属性定义与赋值 )\njava如何优雅的自定义一个注解？\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"蓝桥杯3月月赛F题题解","url":"/posts/46832.html","content":"「蓝桥·算法双周赛」第二十七场蓝桥月赛最后一题题解(可能是首发？？nm，真比第三题简单吧)\n(求你们看看吧我对我的码风很自信)\n问题描述 \n二分枚举时间m，然后剩下的就是根据题意纯模拟  \n注意备份和等待能不能跨天进行，这是个坑点\n细节在注释里有\npackage 蓝桥月赛第27场;import java.util.Scanner;public class F &#123;\t\tprivate static int calculateDays(int m, int[] a, int[] b) &#123;\t\t// 如果没有电脑需要备份，返回 0 天    \tif(a.length == 0) return 0;    \t    \t// 如果 M 小于第一台电脑的备份时间    \tif(m &lt; a[0]) return Integer.MAX_VALUE;    \t    \t// 第一天    \tint days = 1;    \t// 备份第一台开始算剩余时间    \tint currentRemaining = m - a[0];    \t// 第一台都备份不上？？        if (currentRemaining &lt; 0) &#123;            return Integer.MAX_VALUE;        &#125;                for (int i = 1; i &lt;= a.length; i++) &#123;        \tint wait = b[i];   // 获取前一台电脑的等待时间        \t        \t// 处理等待时间        \t// 时间足够，直接减去        \tif(currentRemaining &gt;= wait) &#123;        \t\tcurrentRemaining -= wait;        \t// 不够只能过天了，计算剩余的等待时间        \t&#125;else &#123;        \t\t// 把当天能等的给等了        \t\twait -= currentRemaining;        \t\tdays++;        \t\tcurrentRemaining = m;   // 重置剩余时间        \t\t        \t\tint fullDays = wait / m;   // 计算等几天        \t\tdays += fullDays;        \t\twait -= fullDays * m;        \t\t        \t\tif(wait &gt; 0) &#123;        \t\t\t// 减去零头        \t\t\tcurrentRemaining = m - wait;        \t\t&#125;else &#123;        \t\t\tcurrentRemaining = m;  // 重置        \t\t&#125;        \t&#125;        \t        \t        \t// 处理备份时间        \t// 今天够备份        \tif(currentRemaining &gt;= a[i]) &#123;        \t\tcurrentRemaining -= a[i];        \t&#125;else &#123;        \t\t// 今天备份不完，备份不能留到第二天        \t\tdays++;        \t\tcurrentRemaining = m - a[i];        \t\t// 不行，时间太短，备份不完        \t\tif (currentRemaining &lt; 0) &#123;        \t\t\treturn Integer.MAX_VALUE;        \t\t&#125;        \t&#125;        \t        &#125;        return days;    &#125;\t\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\t\t\t// N 台电脑        int n = scanner.nextInt();        // 最多允许的天数T        int t = scanner.nextInt();        // 表示每台电脑的备份时间。        int[] a = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = scanner.nextInt();        &#125;                // 每台电脑备份完成后需要等待的时间。        int[] b = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            b[i] = scanner.nextInt();        &#125;        scanner.close();                // 最长备份时间        int maxA = 0;        for(int ai: a) &#123;        \tif (ai &gt; maxA) &#123;                maxA = ai;            &#125;        &#125;                if (maxA &gt; 3600) &#123;            System.out.println(-1);            return;        &#125;                // 开始二分 枚举m        int left = maxA;        int right = 3600;        int result = -1;                while(left &lt;= right) &#123;        \tint mid = (left + right) / 2;        \tint days = calculateDays(mid, a, b);        \tif (days &lt;= t) &#123;                result = mid;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;                System.out.println(result != -1 ? result : -1);\t&#125;&#125;\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]}]