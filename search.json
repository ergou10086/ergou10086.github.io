[{"title":"2025第十六届蓝桥杯Java省B题目加部分题解","url":"/posts/20522.html","content":"由于河北北京这边省赛那两天风很大的原因，所以导致蓝桥杯没有如期进行，所以说来做做已经考完了的人的比赛题目\r\n\r\nA. 逃离高塔\r\n\r\n\r\nA\r\n\r\n\r\n\r\nA\r\n\r\n首先如果不考虑溢出处理，用BigInteger估计一是比较慢二是方法写起来比较麻烦，所以还是取模取出个位数处理，因为只看个位数，所以取模不会对结果产生影响\r\npublic class A &#123;\tpublic static void main(String[] args) &#123;\t\tint res = 0;\t\tfor(int i = 1; i &lt;= 2025; i++) &#123;\t\t\t// 结果只取个位数，在每次乘方过程中都取模取出个位数，防止溢出\t\t\tint temp = (int) (((Math.pow(i, 2) % 10) * i) % 10);\t\t\tif(temp == 3) res++;\t\t&#125;\t\tSystem.out.print(res);\t\t// 202\t&#125;&#125;\r\nB. 消失的蓝宝\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n大模拟题，首先 N 肯定是从\r\n20250413开始遍历，但是直接遍历肯定要慢很多\r\n可以先打表发现，20260411 是第一个满足条件2 的数\r\n// 打表代码public class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor(long n = 20250413; n &lt; Long.MAX_VALUE; n++) &#123;\t\t\tif((n + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t\tif((n + 20240413) % 20250412 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);\t\t// 20260411\t&#125;&#125;\r\n所以从 20260411 开始，每次加 20250412\r\n确保满足条件2，然后判断条件1\r\npublic class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor (long N = 20260411; N &lt; Long.MAX_VALUE; N += 20250412) &#123;\t\t\tif ((N + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = N;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);    // 409876661809331\t&#125;&#125;\r\nC. 电池分组\r\n\r\n\r\nC\r\n\r\n\r\n\r\nC\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n两组电池异或和相等，异或 相同为\r\n0，不同为1，那么相等的数异或和为 0，要求能分成两组，\r\n那么就是意思组内所有数异或后为 0\r\npublic class C &#123;\tpublic static void main(String[] args) &#123;\t\tScanner sc = new Scanner(System.in);\t\tint T = sc.nextInt();\t\tfor(int i = 1; i &lt;= T; i++) &#123;\t\t\tint sum = 0;\t\t\tint N = sc.nextInt(); // 本组电池的数量\t\t\tfor (int j = 1; j &lt;= N; j++) &#123;\t\t\t\tint element = sc.nextInt();\t\t\t\tsum = sum ^ element;\t\t\t&#125;\t\t\tif(sum == 0) &#123;\t\t\t\tSystem.out.println(&quot;YES&quot;);\t\t\t&#125;else &#123;\t\t\t\tSystem.out.println(&quot;NO&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\r\nD. 魔法科考试\r\n\r\n\r\nimage-20250419141858122\r\n\r\n\r\n\r\nimage-20250419141858122\r\n\r\n\r\n\r\nimage-20250419141915330\r\n\r\n\r\n\r\nimage-20250419141915330\r\n\r\n朴素模拟发现只能过2/ 5的数据，那么该如何优化呢\r\nclass Solutions1&#123;\t// 质数筛\tboolean check(int p) &#123;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) return false;\t\t&#125;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\r\n首先，看到时间限制就知道这题不简单。\r\n我们在这里要注意以下几个点\r\n\r\n素数判定只需要判定这个数的算术平方根及以下的数是不是这个数的因数，这样更节省时间。\r\n对于已经判定过的数，不需要判断，所以可以打质数筛\r\nif\r\n判断是有顺序的（从左往右判断）所以素数判定放在最后，当前面不符时，会直接退出就不会再素数判定，节省时间。\r\n\r\n// AC代码import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.util.StringTokenizer;import java.util.*;public class Main &#123;\tpublic static void main(String[] args) &#123;\t\tnew Solutions1();\t&#125;&#125;class Solutions1&#123;\tint[] dx = new int[40004];\t// 质数筛\tboolean check(int p) &#123;\t\t// 已经判定过，就无须再判定\t\tif(dx[p] == 1) return false;\t\tif(dx[p] == 2) return true;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) &#123;\t\t\t\tdx[p] = 1;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t\tdx[p] = 2;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\t\t\tclass FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;/*3 42 3 103 4 5 1 */\r\nE. 爆破\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n题目大意：使用尽可能的小距离使 n 个圆连在一起。\r\n最小生成树，圆和圆的距离可以用圆心距离减半径，用 prim\r\n写吧，算法讲解都在注释里详细写下了\r\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    private int n;    private class cirlce implements Comparable&lt;cirlce&gt; &#123;        int x, y, r;        public cirlce() &#123;        &#125;        public cirlce(int x, int y, int r) &#123;            this.x = x;            this.y = y;            this.r = r;        &#125;        @Override        public int compareTo(cirlce o) &#123;            return this.x - o.x;        &#125;    &#125;    private cirlce[] cirlces = new cirlce[5005];    private double Getdist(int u, int v) &#123;        return Math.sqrt((cirlces[u].x - cirlces[v].x) * (cirlces[u].x - cirlces[v].x) + (cirlces[u].y - cirlces[v].y) * (cirlces[u].y - cirlces[v].y));    &#125;    private double prim() &#123;        boolean[] visited = new boolean[n];  // 用于标记每个顶点是否已经被加入到最小生成树中        double[] dist = new double[n];   // 距离数组        // 初始化        Arrays.fill(visited, false);        Arrays.fill(dist, Double.MAX_VALUE);         // 选择0号为起点，并且设为距离0        dist[0] = 0.0;        double sum = 0.0;    // 最小生成树的边总权重\t    // 每次选择一个顶点加入到最小生成树中        for (int i = 0; i &lt; n; i++) &#123;            int u = -1;            double minDist = Double.MAX_VALUE;   // 最小距离指针            // 找到距离最小生成树最近且未被访问的顶点            for (int j = 0; j &lt; n; j++) &#123;                if(!visited[j] &amp;&amp; dist[j] &lt; minDist)&#123;                    minDist = dist[j];                    u = j;                &#125;            &#125;            // 没有点可以移出去了，说明全部加入            if(u == -1)&#123;                break;            &#125;            visited[u] = true;            sum += minDist;\t\t   // 遍历所有未被访问的顶点，更新它们到最小生成树的距离            for(int v = 0; v &lt; n; v++)&#123;                if(!visited[v])&#123;                    double w;                    double spcr = Getdist(u, v);                    // 圆心之间距离小于等于半径之和，相交相切                    if(spcr &lt;= cirlces[u].r + cirlces[v].r)&#123;                        w = 0.0;   // 不需要搭桥                    &#125;else&#123;                        w = spcr - (cirlces[u].r + cirlces[v].r);                    &#125;                    // 松弛操作                    if(w &lt; dist[v])&#123;                        dist[v] = w;                    &#125;                &#125;            &#125;        &#125;        return sum;    &#125;    public Solutions() &#123;        FastReader sc = new FastReader();        n = sc.nextInt();        for (int i = 0; i &lt; n; i++) &#123;            cirlces[i] = new cirlce(sc.nextInt(), sc.nextInt(), sc.nextInt());        &#125;        double sum = prim();        System.out.printf(&quot;%.2f&quot;, sum);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\nF. 数组翻转\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n贪心，可以发现，答案只跟数组中每个数连续出现的次数有关，如果有两段一样且连续的数但是被分隔开了，那么肯定存在一种翻转方法翻转到答案的数值，所以答案就是统计这两段然后一乘\r\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    public Solutions() &#123;        FastReader in = new FastReader();        int n = in.nextInt();        int[] a = new int[n];        for (int a_i = 0; a_i &lt; n; a_i++) &#123;            a[a_i] = in.nextInt();        &#125;        // 桶，记录最大的两个连续值        int[][] backet = new int[1000086][2];        for(int i = 0; i &lt; n; i++)&#123;            int cp = 0;   // 出现次数            cp++;            // 发现了两个连续的相等的数            while(i &lt; n - 1 &amp;&amp; a[i] == a[i + 1])&#123;                cp++;                i++;   // 指针跳过相同的数            &#125;            // 第一段出现的更长            if(cp &gt; backet[a[i]][0])&#123;                backet[a[i]][1] = backet[a[i]][0];                backet[a[i]][0] = cp;            // 第二段出现的更长            &#125;else if(cp &gt; backet[a[i]][1])&#123;                backet[a[i]][1] = cp;            &#125;        &#125;        long res = 0;        for(int i = 0; i &lt; 1000003; i++)&#123;            // ai * 总段长 （backet[i][1] + backet[i][0]）            long temp = (long) i * (backet[i][1] + backet[i][0]);            if(temp &gt; res)&#123;                res = temp;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\nG. 2的幂\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n数组中所有元素的乘积是 2 的 k 次方倍数。\r\n\r\n要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。\r\n\r\n如果数组中所有元素的 2 的幂次之和大于k，已经符合了，输出0\r\n如果初始的 2 的幂次之和小于\r\nk，则需要通过重新选择或增加数组中的某些元素，来使总的 2 的幂次之和达到\r\nk。\r\n考虑dp\r\n\r\n使用一个 DP 数组 dp，其中 dp[j] 表示在增加的 2 的幂次之和为 j\r\n时，所需的最小增加的数的总和。\r\n遍历数组中的每个数 num，计算其在加上某个正整数后，新数能被 2 的 q\r\n次方整除的最小增量cost，并且能够获得的 2 的幂次增量 gain。\r\n更新 DP 数组，即通过考虑当前数的所有可能增加的选项来更新之前的 DP\r\n状态。\r\n如果 dp[re]（其中 re 是需要补充的 2\r\n的幂次）仍然是无穷大，说明无法达到目标，输出 -1\r\n\r\npackage 动态规划.subject.线性dp.P12160_蓝桥杯2025省JavaB_2的幂;import scala.reflect.internal.util.OwnerOnlyChmod;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions&#123;    // 计算一个数是 2 的几次幂    private int countTwos(int num) &#123;        int count = 0;        while(num % 2 == 0 &amp;&amp; num &gt; 0)&#123;            count++;            num /= 2;        &#125;        return count;    &#125;    public Solutions()&#123;        FastReader fs = new FastReader();        int n = fs.nextInt();        int k = fs.nextInt();    // 目标 2 的幂次        int[] a = new int[n + 1];        for (int i = 1; i &lt;= n; i++) a[i] = fs.nextInt();        // 初始状态 2 的幂次和        int total = 0;        for(int num: a)&#123;            total += countTwos(num);        &#125;        if(total &gt;= k)&#123;            System.out.println(0);            return;        &#125;        // 需要新增的2的幂次        int rp = k - total;  // 差2的rp次幂        int[] dp = new int[rp + 1];        Arrays.fill(dp, Integer.MAX_VALUE);        dp[0] = 0;   // 初始化dp[0]为0，意思是1为初态，不加        // 处理每个数        // 数组中所有元素的乘积是 2 的 k 次方倍数。        // 要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。        for (int i = 0; i &lt; n; i++) &#123;            int num = a[i];            int p = countTwos(num);    // 该数为2的几次幂            // 临时 DP 数组，避免同一组重复选择            int[] tempDp = dp.clone();            // 生成增量选项，开到30差不多            for (int q = p + 1; q &lt;= 30; q++) &#123;                long mp = (long)Math.pow(2, q);    // 2^q                if(mp &gt; 100000) break;   // 注意最大值限制                // 不小于 num 且是 2^q 倍数的最小数 sp                long sp = ((long)num + mp - 1) / mp * mp;                // 新数能被 2 的 q 次方整除的最小增量cost 和 能够获得的 2 的幂次增量 gain。                int cost = (int)(sp - num);                int gain = countTwos((int)sp) - p;                if (gain &lt;= 0) continue;                // 更新dp                for(int j = rp; j &gt;= gain; j--)&#123;                    // dp[j - gain] 不是无穷大，存在一种方式可以到达 j - gain 的 2 的幂次增量                    if(dp[j - gain] != Integer.MAX_VALUE)&#123;                        tempDp[j] = Math.min(tempDp[j], dp[j - gain] + cost);                    &#125;                &#125;            &#125;        &#125;        System.out.println(dp[rp] == Integer.MAX_VALUE? -1 : dp[rp]);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\nH. 研发资源分配\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n可以发现，题目思路类似于田忌赛马，贪心考虑，用下等马换掉对方的上等马\r\n例如题解 1 3 2 用 2 1 3，就是用 最下等的 1 抵掉了 最上等的 3\r\n而且由于是全排列，所以剩下的所有位置一定可以排出都比对方大的排列。\r\n// 我是真不知道为什么洛谷一直给我一个 WA 我也不知道哪里错了）public class Main &#123;    public static void main(String[] args) &#123;        new Solutions2();    &#125;&#125;// 1 2 3    2 3 1  1+2-3=0// 1 4 3 2   2 1 4 3  1-2+3+4=6// 1 3 2 4   2 4 3 1  1+2+3-4=2// 2 3 1 5 4   3 4 2 1 5   1+2+3-4+5// 经过了几个案例的打表，我们发现，总是存在这样一种排列，会使得资源份额的差值最大// 那么就是 对面最多只能拿到一天的分数，而且拿到的只能是等级最高的那天class Solutions2&#123;    public Solutions2()&#123;        FastReader sc = new FastReader();        int n = sc.nextInt();        int[] b = new int[n + 1];        for (int i = 1; i &lt;= n; i++) b[i] = sc.nextInt();        if (n == 1) &#123;            System.out.println(0);            return;        &#125;        long res = 0;        for (int i = 1; i &lt;= n; i++) &#123;            // 对面出动了最大的等级，我们使用最下等的去换取，这天的不要            if(b[i] == n)&#123;                res -= i;            &#125;else&#123;                // 别的情况我们都能凑出一种排列比他大，因为我们用最小的把他最大的给抵出去了                res += i;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\n\r\n\r\nimage-20250419164239152\r\n\r\n\r\n\r\nimage-20250419164239152\r\n\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"Butterfly主题常见的标签外挂","url":"/posts/53520.html","content":"\r\n引用自官方文档，自己总结速查或者其他使用\r\n\r\nGallery 相册图库\r\n相册组\r\n&lt;div class=&quot;gallery-group-main&quot;&gt;&#123;% galleryGroup &#x27;somePic&#x27;  &#x27;这是 somePic 相册,什么都存&#x27;  &#x27;/gallery/SomePic&#x27;  &#x27;/gallery/images/cover.png&#x27; %&#125;&#123;% galleryGroup &#x27;draw&#x27;  &#x27;这是 draw 相册,主要存我的画&#x27;  &#x27;/gallery/draw&#x27;  &#x27;/gallery/images/1.jpg&#x27; %&#125;&#123;% galleryGroup &#x27;cover&#x27;  &#x27;这是 cover 相册,主要存文章封面&#x27;  &#x27;/gallery/cover&#x27;  &#x27;/gallery/images/start.jpg&#x27; %&#125;&lt;/div&gt;\r\n至少我是这么写的\r\n&lt;div class=&quot;gallery-group-main&quot;&gt;  &#123;% galleryGroup 名称 描述 链接 封面图URL %&#125;  &#123;% galleryGroup 名称 描述 链接 封面图URL %&#125;&lt;/div&gt;\r\n本地相册\r\n&#123;% gallery [button] %&#125;  ![图片1](url1)  ![图片2](url2)&#123;% endgallery %&#125;\r\n\r\n参数：button 可选，设为\r\ntrue 显示加载更多按钮。\r\n\r\n远程相册\r\n&#123;% gallery url,远程JSON链接,[button] %&#125;&#123;% endgallery %&#125;\r\n\r\n示例：&#123;% gallery pics,https://api.com/photos.json,true %&#125;\r\n\r\nMermaid\r\n使用 mermaid 标签可以绘制 Flowchart（流程图）、Sequence\r\ndiagram（时序图 ）、Class Diagram（类别图）、State\r\nDiagram（状态图）、Gantt（甘特图）和 Pie\r\nChart（圆形图），具体可以查看mermaid 文档\r\n&#123;% mermaid %&#125;内容&#123;% endmermaid %&#125;\r\n&#123;% mermaid %&#125;pietitle Key elements in Product X&quot;Calcium&quot; : 42.96&quot;Potassium&quot; : 50.05&quot;Magnesium&quot; : 10.01&quot;Iron&quot; : 5&#123;% endmermaid %&#125;\r\n\n    pie\ntitle Key elements in Product X\n&quot;Calcium&quot; : 42.96\n&quot;Potassium&quot; : 50.05\n&quot;Magnesium&quot; : 10.01\n&quot;Iron&quot; : 5\n  \r\nTag-hide 隐藏内容标签\r\n功能：隐藏部分内容，通过按钮点击显示。\r\n场景：用于答案揭晓、长内容折叠等。\r\n行内隐藏（inline）\r\n&#123;% hideInline 内容,显示文本,背景色,文字色 %&#125;\r\n\r\n示例：查看答案答案是C\r\n\r\n块级隐藏（block）\r\n&#123;% hideBlock 显示文本,背景色,文字色 %&#125;  隐藏的内容（支持图片、代码块等）&#123;% endhideBlock %&#125;\r\n示例：\r\n查看详情这是隐藏的详细内容…\r\n\r\n折叠框\r\n&#123;% hideToggle 显示文本,背景色,文字色 %&#125;  折叠的内容&#123;% endhideToggle %&#125;\r\n显示文本折叠的内容\r\n\r\nTabs 标签页\r\n创建多标签页切换内容。\r\n&#123;% tabs 唯一名称, [索引] %&#125;  &lt;!-- tab 标签标题 @图标 --&gt;  标签内容  &lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\n\r\n参数\r\n\r\n\r\nimage-20250611161206553\r\n\r\n\r\n&#123;% tabs os-guide, 2 %&#125;  &lt;!-- tab Windows @fas fa-windows --&gt;  Windows 安装步骤...  &lt;!-- endtab --&gt;  &lt;!-- tab Mac @fab fa-apple --&gt;  Mac 安装步骤...  &lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\nWindowsMacWindows 安装步骤…Mac 安装步骤…\r\nButton 按钮\r\n功能：创建可定制的按钮，支持链接和图标。\r\n&#123;% btn 链接,文本,图标,颜色,样式,布局,位置,大小 %&#125;\r\n&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;\r\n\r\n\r\nimage-20250611161324067\r\n\r\n&lt;div class=&quot;btn-center&quot;&gt;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline blue larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline pink larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline red larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline purple larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline orange larger %&#125;&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline green larger %&#125;&lt;/div&gt;\r\n\r\nButterfly\r\nButterfly\r\nButterfly\r\nButterfly\r\nButterfly\r\nButterfly\r\nButterfly\r\n\r\nLabel 高亮标签\r\n功能：高亮文本，类似标签效果。\r\n&#123;% label 文本,颜色 %&#125;\r\n文本,颜色\r\n\r\n示例：重要更新,red\r\n效果：文本显示为带背景色的标签样式。\r\n\r\nTimeline 时间线\r\n功能：创建时间线布局，展示事件序列。\r\n&#123;% timeline 标题,颜色 %&#125;  &lt;!-- timeline 子标题 --&gt;  事件内容  &lt;!-- endtimeline --&gt;&#123;% endtimeline %&#125;\r\n示例;\r\n&#123;% timeline 项目历程,blue %&#125;  &lt;!-- timeline 2022.01 --&gt;  项目启动...  &lt;!-- endtimeline --&gt;  &lt;!-- timeline 2022.06 --&gt;  第一版发布...  &lt;!-- endtimeline --&gt;&#123;% endtimeline %&#125;\r\n\n        \n          项目历程\r\n\n        \n      \n        \n          2022.01\r\n\n        \n        项目启动…\r\n\n      \n        \n          2022.06\r\n\n        \n        第一版发布…\r\n\n      \r\nNote 标签（提示块）\r\n功能：创建带样式的提示信息块，类似 Bootstrap 的\r\nCallout。\r\n&#123;% note [class] [no-icon] [style] %&#125;内容&#123;% endnote %&#125;\r\n内容\r\n\r\n\r\n参数\r\n\r\nclass：可选，定义提示块颜色（default/primary/success/info/warning/danger）。\r\nno-icon：可选，隐藏图标。\r\nstyle：可选，定义样式（simple/modern/flat/disabled）。\r\n\r\n\r\n高级用法\r\n&#123;% note [color] [icon] [style] %&#125;内容&#123;% endnote %&#125;\r\n内容\r\n\r\n示例：\r\n&#123;% note warning simple %&#125;警告：此操作不可撤销&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-lightbulb&#x27; modern %&#125;建议：定期备份数据&#123;% endnote %&#125;\r\n警告：此操作不可撤销\r\n\r\n建议：定期备份数据\r\n\r\n效果**：显示带图标和颜色的提示块，样式根据参数变化。\r\nABCjs显示乐谱\r\n&#123;% score %&#125;X:1T:alternate headsM:CL:1/8U:n=!style=normal!K:C treble style=rhythm&quot;Am&quot; BBBB B2 B&gt;B | &quot;Dm&quot; B2 B/B/B &quot;C&quot; B4 |&quot;Am&quot; B2 nGnB B2 nGnA | &quot;Dm&quot; nDB/B/ nDB/B/ &quot;C&quot; nCB/B/ nCB/B/ |B8| B0 B0 B0 B0 |]%%text This translates to:[M:C][K:style=normal][A,EAce][A,EAce][A,EAce][A,EAce] [A,EAce]2 [A,EAce]&gt;[A,EAce] |[DAdf]2 [DAdf]/[DAdf]/[DAdf] [CEGce]4 |[A,EAce]2 GA [A,EAce] GA |D[DAdf]/[DAdf]/ D[DAdf]/[DAdf]/ C [CEGce]/[CEGce]/ C[CEGce]/[CEGce]/ |[CEGce]8 | [CEGce]2 [CEGce]2 [CEGce]2 [CEGce]2 |]GAB2 !style=harmonic![gb]4|GAB2 [K: style=harmonic]gbgb|[K: style=x]C/A,/ C/C/E C/zz2|w:Rock-y did-nt like that&#123;% endscore %&#125;\r\nX:1\nT:alternate heads\nM:C\nL:1/8\nU:n=!style=normal!\nK:C treble style=rhythm\n&quot;Am&quot; BBBB B2 B&gt;B | &quot;Dm&quot; B2 B/B/B &quot;C&quot; B4 |&quot;Am&quot; B2 nGnB B2 nGnA | &quot;Dm&quot; nDB/B/ nDB/B/ &quot;C&quot; nCB/B/ nCB/B/ |B8| B0 B0 B0 B0 |]\n%%text This translates to:\n[M:C][K:style=normal]\n[A,EAce][A,EAce][A,EAce][A,EAce] [A,EAce]2 [A,EAce]&gt;[A,EAce] |[DAdf]2 [DAdf]/[DAdf]/[DAdf] [CEGce]4 |[A,EAce]2 GA [A,EAce] GA |D[DAdf]/[DAdf]/ D[DAdf]/[DAdf]/ C [CEGce]/[CEGce]/ C[CEGce]/[CEGce]/ |[CEGce]8 | [CEGce]2 [CEGce]2 [CEGce]2 [CEGce]2 |]\nGAB2 !style=harmonic![gb]4|GAB2 [K: style=harmonic]gbgb|\n[K: style=x]\nC/A,/ C/C/E C/zz2|\nw:Rock-y did-nt like that\r\nSeries 系列文章\r\n在页面上显示系列文章\r\n&#123;% series %&#125;&#123;% series [series name] %&#125;\r\n在文章的 front-matter 上添加参数 series，并给与一个标识\r\n使用此标签外挂，会把相同标识的文章以列表的形式展示\r\n如果不写 series 标识，则默认为你使用此标签外挂所在的文章的 series\r\n标识\r\n例如\r\n&#123;% series   Spring之Spring Framework %&#125;\r\n\r\n","categories":["实用","配置相关"],"tags":["Hexo","markdown","教程"]},{"title":"CS好书整理汇总","url":"/posts/52820.html","content":"文章总体概括基于 CS自学指南\r\n进行整理，个人之后再根据个人学习和查阅记录整理\r\n由于版权原因，下面列举的图书中除了开源资源提供了链接，其他的资源请大家自行通过\r\nlibgen 查找。\r\n资源汇总\r\n\r\nFree\r\nProgramming Books: 开源编程书籍资源汇总\r\nCS\r\nTextbook Recommendations: 计算机科学方向推荐教材列表\r\nC\r\nBook Guide and List: C语言相关的编程书籍推荐列表\r\nC++\r\nBook Guide and List: C++语言相关的编程书籍推荐列表\r\nPython Book Guide and List:\r\nPython语言相关的编程书籍推荐列表\r\nComputer\r\nVision Textbook Recommendations: 计算机视觉方向推荐教材列表\r\nDeep\r\nLearning Textbook Recommendations: 深度学习方向推荐教材列表\r\n\r\n系统入门\r\n\r\nComputer Systems: A Programmer’s Perspective [豆瓣]\r\nPrinciples of Computer System Design: An Introduction [豆瓣]\r\n\r\n操作系统\r\n\r\n现代操作系统:\r\n原理与实现 [豆瓣]\r\n深入理解计算机系统\r\nOperating Systems:\r\nThree Easy Pieces [豆瓣]\r\nModern Operating Systems [豆瓣]\r\nOperating Systems: Principles and Practice [豆瓣]\r\n\r\n计算机网络\r\n\r\nComputer\r\nNetworks: A Systems Approach [豆瓣]\r\nComputer\r\nNetworking: A Top-Down Approach [豆瓣]\r\nHow Networks Work [豆瓣]\r\nHttp 权威指南\r\nTcp / Ip 详解\r\n\r\n分布式系统\r\n\r\nPatterns\r\nof Distributed System (Blog)\r\nDistributed\r\nSystems for Fun and Profit (Blog)\r\nDesigning Data-Intensive\r\nApplications: The Big Ideas Behind Reliable, Scalable, and Maintainable\r\nSystems [豆瓣]\r\n\r\n数据库系统\r\n\r\nArchitecture\r\nof a Database System [豆瓣]\r\nReadings in Database Systems\r\n[豆瓣]\r\nDatabase System Concepts : 7th Edition [豆瓣]\r\n数据库系统概念\r\nRedis\r\n设计与实现\r\n高性能\r\nMySQL\r\n\r\n编译原理\r\n\r\nEngineering a Compiler [豆瓣]\r\nCompilers: Principles, Techniques, and Tools [豆瓣]\r\nCrafting\r\nInterpreters[豆瓣][开源中文翻译]\r\n\r\n计算机编程语言\r\n\r\n计算机程序的构造和解释 [豆瓣]\r\nEssentials of Programming Languages\r\n[豆瓣]\r\nPractical\r\nFoundations for Programming Languages [豆瓣]\r\nSoftware\r\nFoundations [豆瓣] [北大相关课程]\r\nTypes and\r\nProgramming Languages [豆瓣] [北大相关课程]\r\n\r\n体系结构\r\n\r\n超标量处理器设计: Superscalar RISC Processor Design [豆瓣]\r\nComputer Organization and Design: The Hardware/Software Interface\r\n[MIPS\r\nEdition][ARM\r\nEdition][RISC-V\r\nEdition]\r\nComputer Architecture: A Quantitative Approach [豆瓣]\r\n\r\n理论计算机科学\r\n\r\nIntroduction to the Theory of Computation [豆瓣]\r\n\r\n密码学\r\n\r\nCryptography Engineering: Design Principles and Practical\r\nApplications [豆瓣]\r\nIntroduction to Modern Cryptography [豆瓣]\r\n\r\n逆向工程\r\n\r\n逆向工程核心原理 [豆瓣]\r\n加密与解密 [豆瓣]\r\n\r\n计算机图形学\r\n\r\nMonte Carlo theory, methods\r\nand examples[豆瓣]\r\nAdvanced Global Illumination [豆瓣]\r\nFundamentals of Computer Graphics [豆瓣]\r\nFluid\r\nSimulation for Computer Graphics [豆瓣]\r\nPhysically\r\nBased Rendering: From Theory To Implementation [豆瓣]\r\nReal-Time\r\nRendering [豆瓣]\r\n\r\n游戏引擎\r\n\r\n游戏编程模式: Game Programming Patterns [豆瓣]\r\n实时碰撞检测算法技术 [豆瓣]\r\nGame AI Pro Series [豆瓣]\r\nArtificial Intelligence for Games [豆瓣]\r\nGame Engine Architecture [豆瓣]\r\nGame Programming Gems Series [豆瓣]\r\n\r\n软件工程\r\n\r\nSoftware Engineering\r\nat Google [豆瓣]\r\n\r\n设计模式\r\n\r\n设计模式: 可复用面向对象软件的基础 [豆瓣]\r\n大话设计模式 [豆瓣]\r\nHead First Design Patterns 2nd ed. [豆瓣]\r\n\r\n深度学习\r\n\r\n深度学习 [豆瓣][Github]\r\n动手学深度学习 [豆瓣]\r\n神经网络与深度学习 [豆瓣]\r\n深度学习入门 [豆瓣]\r\n简单粗暴 TensorFlow 2 (Tutorial)\r\nSpeech and\r\nLanguage Processing [豆瓣]\r\n\r\n计算机视觉\r\n\r\nMultiple\r\nView Geometry in Computer Vision [豆瓣]\r\n视觉 SLAM 十四讲\r\n\r\n机器人\r\n\r\nProbabilistic\r\nRobotics [豆瓣]\r\n\r\n面试\r\n\r\n剑指 Offer：名企面试官精讲典型编程题 [豆瓣]\r\nCracking The Coding Interview [豆瓣]\r\n程序员代码面试指南\r\n\r\n算法与数据结构\r\n软件质量\r\n\r\n重构\r\n代码整洁之道\r\n架构整洁之道\r\n人月神话\r\n一个需要 10 天才能干完的活，不可能让 10 个人在 1\r\n天干完！\r\n\r\n\r\nJava 相关\r\nJavaSE\r\n\r\nJava 核心技术\r\n这个书分为开发基础和高级特性两本，还是挺好的\r\nOn Java\r\n貌似是那个 Java 编程思想 的新版本\r\nEffective Java\r\n唯一真神\r\n深入理解 Java 虚拟机\r\nJava\r\n并发编程之美\r\n实战\r\nJava 高并发程序设计\r\n虚拟机设计与实现:以 JVM\r\n为例\r\nJava\r\n性能权威指南\r\n\r\n分布式\r\n\r\n深入理解分布式系统\r\n数据密集型应用系统设计\r\n深入理解分布式事务\r\n微服务架构设计模式\r\n\r\nJava Web\r\n\r\nSpring 实战\r\n不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。\r\nSpring Boot 实战\r\nSpring 微服务实战\r\n这三本好像是 spring 三剑客\r\nNetty\r\n实战\r\n软件架构设计：大型网站技术架构与业务架构融合之道\r\n\r\n","categories":["学习类","CS书籍"],"tags":["学习类","计算机书籍","计算机理论技术"]},{"title":"绘隙碎笔","url":"/posts/29865.html","content":"​\r\n才三月份，石家庄就依旧进入繁盛的春天了啊。。。。在我的家乡长久生活的人，不知道会不会感叹这岁月的笔触实在是太快了。\r\n​\r\n又是一节我习惯绘画的课堂，坐在最靠窗户的一排，三月份已然有些许热气，拿出本来，感觉都温暖了许多。\r\n​\r\n我常于这光影交错处徘徊，看日光一寸寸移动，感觉把我生命的长度都不经意的丈量了。\r\n​\r\n所以我把这梦境画下，我又回到那个熟悉的楼里了，那个我可能再也不会有机会回去的，却满含怀念的建筑里。\r\n​\r\n她靠着下午五点半的夕阳，在梦里和我相遇吗。其实不然，在梦里只有楼和我，我却无法把自己画下，只能把祈莉作为我思索的对象，让她替我在一步一步的忧郁。\r\n\r\n\r\nShenBangQili\r\n\r\n\r\n\r\nShenBangQili\r\n\r\n\r\n&#123;% asset_img ShenBangQili.jpg example %&#125;\t\r\n​\r\n本人懈怠，绘画的热度感觉一日不如一日，也许我是想画吧，可是我用时间在绘画上的刻痕实在是太浅，被琐事纠缠的我，大概是无暇提笔哩。。。\r\n​ -2025.3.27 中午\r\n","categories":["杂谈","绘画相关"],"tags":["绘画相关","杂谈"]},{"title":"Hexo根目录下的_config.yml配置文件","url":"/posts/63024.html","content":"我们在使用hexo初始化一个项目的时候，在根目录下会有一个配置文件_config.yml，这个文件配置了所写博客里面的内容，我们从根目录的该文件来说明每个配置的作用\r\n头注释\r\n_config.yml文件在头部会有一些注释，Hexo Configuration下的两行表示hexo文档的相关文档，Docs指的是hexo的文档，Source指的是hexo的GitHub源码，方便供他人参考查阅\r\n# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/\r\n博客网站相关\r\nSite下面是网站相关的一些信息配置\r\n# Sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doelanguage: entimezone: &#x27;&#x27;\r\ntitle：网站的名字，会写在hexo\r\ngenerator命令生成后的public文件夹下的index.html文件的title标签里，作为你个人博客网站的标题，我们也可以在主题的首页左下角找到\r\nsubtitle：网站的副标题，生成的时候默认为空，一般会出现在你主标题的下面，也就是大约在背景图中间\r\ndescription：主要用于SEO，告诉搜索引擎一个关于站点的简单描述，在官方文档中建议在这段描述中增加自己的一些关键词\r\nkeywords：网站的关键词，使用半角逗号分隔开多个关键词，对SEO的优化有一定的作用\r\nauthor：顾名思义就是作者，这个也只是署个名而已，不会显式的看到\r\nlanguage：这里就写了网站使用的语言\r\ntimezone：网站对应的时区，一般情况下不用去刻意配置，会默认使用电脑的时区，但如果发布到其他地方的服务器，可能会使用当地服务器的时区，一般中国的时区可以设置为Asia/Shanghai或者北京\r\n博客网址相关\r\n# URL## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;url: http://example.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # 设置为false时会将末尾的index.html去掉  trailing_html: true # 设置为false时会将末尾的.html去掉，对index.html无效\r\nurl：指定博客的完整域名或 URL\r\n地址。当你将博客部署到互联网上时，访问者需要通过这个地址来访问你的博客，要确保\r\nurl\r\n地址准确无误，不然可能会导致博客内的链接（如文章内的图片链接、页面跳转链接等）无法正常访问\r\nroot：网站的根目录，指定博客在域名下的根目录，如果你的博客是直接部署在域名的根目录下，就将\r\nroot 设置为\r\n/；若博客部署在域名的子目录下，比如部署在\r\nhttp://example.com/blog 下，那么就需要把 root\r\n设置为 /blog/。正确设置 root\r\n很重要，不然会影响博客内资源（如 CSS、JavaScript\r\n文件等）的加载路径。\r\npermalink：文章的永久链接格式，一般是格式化日期字符串，可以在permalink这里配置，如默认中的配置，在hello\r\nworld文章中就会是这样的url\r\n\r\n当使用Font-matter中的值配置的时候（文章格式标签），可选的值有\r\n\r\n\r\nimg\r\n\r\n\r\npermalink_defaults:设置永久链接的默认值。当你在文章的\r\nFront -\r\nMatter（文章开头的元数据部分）中没有对某些永久链接相关的变量进行设置时，就会使用这里定义的默认值。不过在示例中，没有具体设置默认值，所以会采用\r\nHexo 的默认配置。\r\npretty_urls:就是如注释那样\r\n目录相关\r\n# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:\r\nsource_dir：存放hexo文章的文件夹，我们写的md文件都放在这个配置对应的文件夹下，默认值是source\r\npublic_dir：存放hexo g生成的文件，执行hexo\r\ng后根目录就会出现这个文件夹，默认值是public\r\ntag_dir：按标签存放文章的目录，默认值是tags，如果我们给文章添加标签，使用hexo\r\ng时public文件夹下就会多出一个tags文件夹（根据我们的配置文件夹名不同）\r\narchive_dir：归档文件夹，存放归档文件，默认值为archives\r\ncategory_dir：分类文件夹，按分类存放的文件，和上面的tags一样，只要在文章中的Font-matter添加了categories就会在使用hexo\r\ng构造时出现相应的文件夹\r\ncode_dir：Include code 文件夹，source_dir\r\n下的子目录，默认值为downloads/code\r\ni18n_dir：国际化（i18n）文件夹，默认值:lang\r\nskip_render：跳过指定文件的渲染，匹配到的文件将会被不做改动复制到public文件夹下，如果路径对应的是我们的文章，那会直接忽略掉该文章，我们这样设置来忽略掉hello-world.md文件\r\nskip_render: &quot;_posts/hello-world.md&quot;\r\n​ 然后hexo\r\ng之后可见生成的文件夹只有一些基础的内容，没有和hello-world.md相关的东西\r\n文章相关\r\n# Writingnew_post_name: :title.md default_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: false\r\nnew_post_name：新文章的默认名称，我们是使用hexo\r\nnew来构造文章的，生成的文章名就是通过这里配置的，默认为:title.md，也就是标题.md\r\ndefault_layout：预设布局，指定你新建文章的布局，布局决定了文章在渲染时使用的模板，hexo\r\nnew可以创建三种文件，post/帖子，draft/草稿，page/页面，这里设置默认值在使用hexo\r\nnew就可以直接创建对应默认类型的文章，设置了post就等同于说在命令行执行hexo\r\nnew 和执行hexo new post\r\n是一样的，也可以设置为draft和page\r\ntitlecase：控制是否将文章标题转换为标题大小写格式。当设置为\r\ntrue\r\n时，文章标题会被转换为标题大小写（即每个单词的首字母大写）；设置为\r\nfalse 则不进行转换，保持标题的原始大小写。\r\nexternal_link：\r\n\r\nenable：控制是否在新标签页中打开外部链接。设置为 true\r\n时，文章中的外部链接会在新标签页中打开；设置为 false\r\n则会在当前页面打开。\r\nfield：指定外部链接设置的应用范围。site\r\n表示该设置应用于整个网站。\r\nexclude：指定不应用此外部链接设置的域名或路径。这里为空字符串，表示没有排除的域名或路径。\r\n\r\nfilename_case：控制文件名的大小写规则。取值为\r\n0 时，文件名保持原始大小写；取值为 1\r\n时，文件名转换为小写；取值为 2 时，文件名转换为大写。\r\nrender_drafts：控制是否渲染草稿文章。草稿文章通常存放在\r\nsource/_drafts 目录下。设置为 true\r\n时，草稿文章会被渲染并显示在网站上；设置为 false\r\n则不会渲染草稿文章。\r\npost_asset_folder：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在source文件夹下建立一个统一的images文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，就可以设置为true，控制为每篇文章创建一个同名的资源文件夹。当设置为\r\ntrue 时，使用 hexo new\r\n命令创建文章时，会同时创建一个与文章同名的文件夹，用于存放该文章相关的图片、附件等资源；设置为\r\nfalse 则不会创建。\r\nrelative_link: 控制是否使用相对链接。设置为\r\ntrue 时，文章中的链接会使用相对路径；设置为\r\nfalse 则使用绝对路径。\r\nfuture：控制是否发布未来日期的文章。设置为\r\ntrue\r\n时，即使文章的发布日期设置为未来的某个时间，也会正常发布；设置为\r\nfalse 则不会发布未来日期的文章。\r\nhighlight：代码高亮的显示\r\n\r\nenable：控制是否启用代码高亮功能。设置为 true\r\n时，文章中的代码块会进行高亮显示；设置为 false\r\n则不进行高亮。\r\nline_number：控制是否显示代码块的行号。设置为 true\r\n时，代码块会显示行号；设置为 false 则不显示。\r\nauto_detect：控制是否自动检测代码块的语言。设置为 true\r\n时，Hexo 会尝试自动检测代码块的语言；设置为 false\r\n则需要在代码块中手动指定语言\r\ntable_replace：用n个空格来代表tab键，如果值为空，则不会代替tab键，这里为空字符串，表示不进行替换。\r\nwarp：是否将代码放在table标签里，默认为true\r\nhljs：控制是否使用 highlight.js 进行代码高亮。设置为\r\ntrue 时，使用 highlight.js 进行高亮；设置为\r\nfalse 则使用 Hexo 内置的高亮方式。\r\n\r\n主页设置\r\nindex_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date\r\nindex_generator：主页相关的设置\r\n\r\npath：主页对应的路径，默认为’’，即域名根目录就是主页的路径\r\nper_page：每页显示的帖子数，默认为10\r\norder_by：帖子的排序，默认为-date，即按日期倒序排\r\n\r\n分类和标签\r\n# Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名\r\ndefault_category：当你创建新文章时，如果没有在文章的\r\nFront -\r\nMatter（即文章开头的元数据部分）中明确指定文章的分类，那么这篇文章就会被自动归类到\r\ndefault_category 所指定的分类中。在这个例子里，默认分类是\r\nuncategorized，也就是 “未分类”。\r\ncategory_map：category_map\r\n用于设置分类的别名。在实际写文章和管理博客的过程中，你可能会使用一个比较简洁或者容易输入的分类名，但在博客的展示页面上，你希望使用更正式、美观或者表意更清晰的名称。这时就可以通过\r\ncategory_map 来实现分类名的映射。\r\n例如：\r\ncategory_map:  tech: 技术分享  life: 生活随笔\r\n当你在文章的 Front - Matter 中使用 categories: [tech]\r\n时，在博客的分类页面显示的分类名称将会是 “技术分享”，而不是\r\ntech。\r\ntag_map：tag_map 的作用与\r\ncategory_map\r\n类似，不过它是用于设置标签的别名。在写文章时，你可能会使用一些简单的标签名，但在博客展示时，希望使用更合适的名称，就可以通过\r\ntag_map 来进行映射。\r\n元数据元素\r\n# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true\r\n是否在页面开头插入下面的meta标签，默认为true\r\n\r\n\r\nimg\r\n\r\n日期和时间\r\n# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#x27;s date for updated date unless set in front-matteruse_date_for_updated: false\r\ndate_format：日期格式，默认为YYYY-MM-DD，即年月日\r\ntime_format：时间格式，默认为HH:mm:ss，即时分秒\r\nuse_date_for_updated：启用以后，如果 Front Matter\r\n中没有指定 updated（文件更新日期），post.updated 将会使用 date\r\n的值而不是文件的创建时间，默认值为true\r\n分页\r\n# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page\r\nper_page：分页时每页的文章数，如果为0则不分页，默认为10\r\npagination_dir分页的目录，默认为page，对应于public文件夹下的archives文件夹下的page文件夹，如果只有一页是不会生成这个文件夹的\r\n包括或不包括目录和文件\r\n# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:\r\ninclude：Hexo\r\n默认会忽略隐藏文件和文件夹（包括名称以下划线和 .\r\n开头的文件和文件夹，Hexo 的 _posts 和 _data\r\n等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source\r\n目录下。\r\nexclude：Hexo 会忽略这些文件和目录\r\nignore：忽略的文件,要注意的是，这里要写入的是数组，而yaml的数组要用-值表示数组中一个元素或者直接采用js中数组的写法[]\r\n主题\r\n# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 当前使用的主题名\r\n部署\r\n# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#x27;&#x27;\r\nhexo提供了快速方便的一键部署功能hexo\r\ndeploy，但我们至少需要在_config.yml文件中的deploy中至少配置一个type，比如\r\ndeploy:  type: git\r\ndeploy:  type: git  repo: &lt;repository url&gt; # 库地址  branch: [branch] # 分支名称  message: [message] # 自定义提交信息\r\n参考内容：\r\n部分内容转载自https://blog.csdn.net/zemprogram/article/details/104288872\r\nhexo官方中文文档\r\nhexo官方英文文档（有些中文文档没有的英文文档的才有）\r\nhexo fromt-matter\r\nhexo\r\n部署\r\n","categories":["实用","介绍说明"],"tags":["Hexo","网站技术","实用知识"]},{"title":"Hibernate框架之事务控制","url":"/posts/33452.html","content":"事务概述\r\nHibernate是对JDBC的轻量级封装，其主要功能是操作数据库。在操作数据库过程中，经常会遇到事务处理的问题，接下来就来介绍Hibernate中的事务管理。\r\n事务的并发问题\r\n在实际应用过程中，数据库是要被多个用户所共同访问的。在多个事务同时使用相同的数据时，可能会发生并发的问题，具体如下：\r\n\r\n脏读：一个事务读取到另一个事务未提交的数据。\r\n不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致在同一个事务中的多次查询结果不一致。\r\n虚读/幻读：一个事务读到了另一个事务已经提交的insert的数据，导致在同一个事务中的多次查询结果不一致。\r\n\r\n事务的隔离级别\r\n为了避免事务并发问题的发生，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。\r\n\r\n读未提交(Read Uncommitted，1级):\r\n一个事务在执行过程中，既可以访问其他事务提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。此隔离级别可防止丢失更新。\r\n读已提交(Read committed, 2级):\r\n一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别可有效防止脏读。\r\n可重复读(Repeatable Read, 4级):\r\n一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务(但允许读事务),写事务则禁止任何其他事务。此隔离级别可有效的防止不可重复读和脏读。\r\n序列化/串行化(Serializable,\r\n8级):提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。此隔离级别可有效的防止脏读、不可重复读和幻读。\r\n\r\n在使用数据库时候，隔离级别越高，安全性越高，性能越低。\r\n实际开发中，不会选择最高或者最低隔离级别，选择READ_COMMITTED(oracle默认)、REPEATABLE_READ(mysql默认)\r\nHibernate的事务控制\r\nHibernate事务代码规范写法\r\n代码结构\r\ntry &#123; 开启事务 提交事务&#125;catch() &#123; 回滚事务&#125;finally &#123; 关闭&#125;\r\n@Test    public void testTx() &#123;        SessionFactory sessionFactory = null;        Session session = null;        Transaction tx = null;        try &#123;            sessionFactory = HibernateUtils.getSessionFactory();            session = sessionFactory.openSession();            //开启事务            tx = session.beginTransaction();                        //添加            User user = new User();            user.setUsername(&quot;小马&quot;);            user.setPassword(&quot;250&quot;);            user.setAddress(&quot;美国&quot;);                        session.save(user);                        int i = 10/0;            //提交事务            tx.commit();        &#125;catch(Exception e) &#123;            e.printStackTrace();            //回滚事务            tx.rollback();        &#125;finally &#123;            //关闭操作            session.close();            sessionFactory.close();        &#125;    &#125;\r\nHibernate的事务管理\r\n在Hibernate中，可以通过代码来操作管理事务，如通过Transaction  tx=session.beginTransactiong();开启一个事务，持久化操作后，通过tx.commit();\r\n提交事务；如果事务出现异常，又通过tx.rollback();操作来撤销事务(事务回滚)。\r\n除了在代码中对事务开启，提交和回滚操作外，还可以在hibernate的配置文件中对事务进行配置。配置文件中，可以设置事务的隔离级别。其具体的配置方法是在hibernate.cfg.xml文件中的&lt;session-factory&gt;标签元素中进行的。配置方法如下所示。\r\n&lt;!-- 　　　　事务隔离级别       hibernate.connection.isolation = 4       1-Read uncommitted isolation       2-Read committed isolation       4-Repeatable read isolation       8-Serializable isolation      --&gt;        &lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt;\r\n到这里我们已经设置了事务的隔离级别，那么我们在真正进行事务管理的时候，需要考虑事务的应用场景，也就是说我们的事务控制不应该是在DAO层实现的，应该在Service层实现，并且在Service中调用多个DAO实现一个业务逻辑的操作。具体操作如下显示：\r\n\r\n\r\nimg\r\n\r\nHibernate绑定session\r\n在Dao层操作数据库需要用到session对象，在Service控制事务也是使用session对象完成.\r\n我们要确保Dao层和Service层使用的使用同一个session对象。\r\n有两种办法可以实现：\r\n\r\n在业务层获取到Session，并将Session作为参数传递给DAO。\r\n使用ThreadLocal将业务层获取的Session绑定到当前线程中，然后在DAO中获取Session的时候，都从当前线程中获取。\r\n\r\n使用第二种方式肯定是最优方案，具体的实现已经不用我们来完成了，hibernate的内部已经将这个事情做完了。我们只需要在hibernate.cfg.xml中完成一段配置即可。\r\n&lt;!-- 配置session与当前线程绑定 --&gt; &lt;!--  thread：Session对象的生命周期与本地线程绑定(推荐)        jta：Session对象的生命周期与JTA事务绑定        managed：hibernate委托程序来管理Session对象的生命周期。  --&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;\r\n注意：上述配置一般和sessionFactory.getCurrentSession()这个方法一起配合使用。getCurrentSession()方法用来绑定session和ThreadLocal，而且这个与线程绑定的session可以不用关闭，当事务提交时,session会自动关闭，不要手动调用close关闭。\r\n//提供一个方法返回与本地线程绑定的sessionpublic static Session getSession()&#123;\treturn sessionFactory.getCurrentSession();&#125;\r\ngetCurrentSession获取当前线程的session对象，创建session对象之后不需要调用close方法，在线程结束的时候会自动将session关闭，不需要手动关闭，否则会出现session\r\nwas closed 错误\r\npackage com.itzheng.hibernate.demo01;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itzheng.hibernate.utils.HibernateUtils;/* * 测试当前线程绑定的Session */public class HibernateDemo04 &#123;\t@Test\tpublic void demo01() &#123;\t\t//会按照配置的好的事务处理方式去存储数据\t\tSession session = HibernateUtils.getCurrentSession();//保证每一个对象在调用该方法的时候都使用的是同一个session\t\tTransaction transaction = session.beginTransaction();\t\tCustomer customer = new Customer();\t\tcustomer.setCust_name(&quot;王西&quot;);\t\tsession.save(customer);\t\ttransaction.commit();\t\t//session.close();不需要二次关闭session。因为在当前线程结束的时候就会关闭session对象，也就缓存\t&#125;&#125;\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Hibernate框架之介绍与初识Hibernate程序","url":"/posts/48900.html","content":"Hibernate介绍\r\nHibernate是一个开源的Java对象关系映射（ORM）框架，它提供了一种方便的方式将Java对象与关系型数据库进行映射和交互。通过Hibernate，开发人员可以使用面向对象的方式操作数据库，而不需要直接编写SQL查询语句\r\n架构图\r\n\r\nHibernate是一个开源的对象关系映射（ORM）框架，用于将Java对象映射到关系型数据库中的关系表。\r\n它提供了一种面向对象的方式来操作数据库，简化了开发人员对数据库的访问和管理\r\n如何理解提供了一种面向对象的方式来操作数据库。\r\n\r\n一方面：Hibernate可以将定义好的java类映射为数据库中的表，并将java类的实例化的对象，映射为对应表中的一行记录。\r\n另一方面：使用Hibernate，开发人员可以直接操作对象，不需要编写复杂的SQL语句。通过对象的属性和方法来进行数据的读取、修改和删除等操作。\r\n\r\nHibernate提供的核心功能和特性\r\nORM映射（可以将java对象与数据库表之间进行映射，实现对象和关系数据库之间的转换，支持各种映射策略和注解）；\r\n数据库查询（提供了一组丰富的API，用于执行数据库操作，包括插入、更新、删除、查询，还支持HQL和基于SQL的查询一级Criteria查询和原生SQL查询）；\r\n缓存机制(Hibernate内置了一级缓存和二级缓存机制，用于提供查询性能和减少数据库的访问。一级缓存是会话级别的缓存，保存了会话期间加载的实体对象。二级缓存是跨会话的缓存，可以在多个会话之间共享缓存数据）；\r\n事物管理（可以通过编程或声明式的方式管理数据库事物。支持标准的java事物API（JTA）和本地事物管理）；\r\n延迟加载（允许按需加载关联对象，提高查询性能。这意味着只有在需要访问关联对象时，才会从数据库中加载相应的数据。）；\r\n对象状态管理（通过跟踪对象的状态来管理对象的持久化。它提供了持久化、脱管和删除等状态之间的转换，使开发人员能够方便地操作对象。）\r\n对象的持久化\r\n把对象永久的保存到数据库中\r\n持久化包括和数据库相关的各种操作\r\n\r\n保存\r\n更新\r\n删除\r\n查询\r\n加载：加载特定的 OID，把一个对象从数据库加载到内存中\r\n\r\nOID：为了在系统中能找到所需对象，需要为对象分配一个唯一的标识号，在关系型数据库中称为主键，在对象术语中叫对象标识OID\r\nORM 对象关系映射\r\nORM主要解决对象-关系的映射\r\n\r\n类的一个对象可以对应一张表，对象对应表的行，属性对应位表的列\r\n\r\nORM的思想：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。\r\nORM 采用元数据来描述对象-关系映射细节,元数据通常采用XML\r\n格式,并且存放在专门的对象-关系映射文件中。描述数据的数据\r\n\r\n\r\nimage-20250510201350695\r\n\r\nHibernate框架的优点\r\n\r\n使开发更加面向对象化：Hibernate提供了一个面向对象的编程模型，使开发人员可以使用面向对象的思想来操作数据库。\r\n提高开发效率：Hibernate提供了许多强大的特性和工具：如自动生成数据库表结构，提供了公共的操作数据库的方法，让开发人员不用写SQL语句、缓存机制、事物管理。可以大大减少开发人员的工作量，提高开发效率。\r\n可移植性：Hibernate可以在不同的数据库系统上运行，如Mysql、Oracle、SQL\r\nServer等，开发人员可以使用统一的API和语法，无需关系底层数据库的差异。\r\n\r\nHibernate、jpa、jdbc他们三者之间是什么关系\r\n\r\njdbc：jdbc是Java提供的用于与关系型数据库进行交互的标准API，它提供了一组接口和类，使开发人员能够执行数据库的连接、查询、更新等操作。JDBC\r\n需要开发人员手动编写 SQL\r\n查询和处理数据库结果集，对于较低层次的数据库操作提供了灵活性。使开发人员能够执行数据库的连接、查询、更新等操作。JDBC\r\n需要开发人员手动编写 SQL\r\n查询和处理数据库结果集，对于较低层次的数据库操作提供了灵活性。\r\nJPA：JPA是Java持久化标准，定义了一组API和规范，提供了一种与数据库无关的方式来操作实体对象。JPA定义了实体、映射关系、查询语言和事物管理等方面的规范，使开发人员能够以面向对象的方式进行数据库的操作。\r\nHibernate：Hibernate实现了JPA规范，同时还提供了一些额外的功能和特性。Hibernate封装了底层的JDBC操作，提供了更高层次的抽象，来简化开发人员对数据库的访问。通过\r\nHIbernate\r\n开发人员可以通过配置和注解来定义实体和映射关系，使用面向对象的方式进行数据库操作。\r\n\r\nHibernate 是 JPA 的实现之一，而 JPA\r\n则是对数据库持久化操作的规范。JDBC\r\n是底层的数据库连接和操作技术，Hibernate 和 JPA 则在 JDBC\r\n的基础上提供了更高层次的抽象和便利性，使得开发人员能够以面向对象的方式进行数据库操作\r\n下载安装\r\n现在 Spring Boot JPA 集成的 Hibernate 进行数据持久化更加常见，\r\n一般不用安装，装好依赖就行了，配置文件配置properties就行。\r\n不用maven导入，jar包到 官网 下就行。\r\n下载网站：https://sourceforge.net/projects/hibernate/files/hibernate-orm/\r\nHibernate开发步骤\r\n\r\n\r\nimage-20250511142748170\r\n\r\n第一个例子——学生信息管理\r\n编写例子\r\n\r\n创建了一个Java项目（Maven或Gradle）\r\n添加了Hibernate依赖（如果是Maven项目，在pom.xml中添加）\r\n&lt;!-- Hibernate核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;    &lt;version&gt;5.6.14.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库驱动（这里使用H2内存数据库作为示例） --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;2.1.214&lt;/version&gt;&lt;/dependency&gt;\r\n创建实体类\r\n使用hibernate时候，不需要自己手动创建表，hibernate帮把表创建\r\nimport javax.persistence.*;@Entity@Table(name = &quot;students&quot;)public class Student &#123;        // Hibernate作为JPA的实现，支持这些标准JPA注解    // 注解表示了对象关系映射的基本信息    // Hibernate 要求实体类有一个属性是唯一的    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;name&quot;, nullable = false)    private String name;        @Column(name = &quot;email&quot;)    private String email;        @Column(name = &quot;age&quot;)    private Integer age;        // 必须有无参构造函数    public Student() &#123;&#125;        // 全参构造函数    public Student(String name, String email, Integer age) &#123;        this.name = name;        this.email = email;        this.age = age;    &#125;        // Getter和Setter方法    public Long getId() &#123;        return id;    &#125;        public void setId(Long id) &#123;        this.id = id;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public String getEmail() &#123;        return email;    &#125;        public void setEmail(String email) &#123;        this.email = email;    &#125;        public Integer getAge() &#123;        return age;    &#125;        public void setAge(Integer age) &#123;        this.age = age;    &#125;        @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\r\n使用xml或者纯注解配置\r\nHibernate配置文件 hibernate.cfg.xml\r\n是Hibernate框架中至关重要的部分，它负责初始化Hibernate并提供与数据库交互所需的所有配置信息。在这个配置文件中，开发者需要指定数据库连接的URL、用户名和密码，以及数据库使用的方言，这些信息是Hibernate能够正常工作所必须的。\r\n该配置文件的结构通常包含以下几个主要部分：\r\n\r\nhibernate-configuration\r\n：这是配置文件的根元素，其中可以包含一个或多个 session-factory\r\n元素。\r\nsession-factory ：定义了一个或多个 session-factory ，每一个\r\nsession-factory 都可以配置不同的数据库连接信息。\r\nproperty ：在 session-factory 内部，使用多个 property\r\n元素来指定Hibernate连接数据库所需的参数，如\r\nconnection.url 、 connection.username 、 connection.password 、\r\ndialect 等。\r\nmapping ：这个元素用于指定实体类与数据库表的映射关系，可以通过 class\r\n或 mapping-file 指定。\r\n\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库连接设置 --&gt;        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;org.h2.Driver&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:h2:mem:testdb&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.username&quot;&gt;sa&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.password&quot;&gt;&lt;/property&gt;                &lt;!-- JDBC连接池大小 --&gt;        &lt;property name=&quot;hibernate.connection.pool_size&quot;&gt;1&lt;/property&gt;                &lt;!-- SQL方言 - 告诉Hibernate使用哪种数据库语法 --&gt;        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.H2Dialect&lt;/property&gt;                &lt;!-- 在控制台显示SQL语句 --&gt;        &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;                &lt;!-- 自动创建/更新数据库表结构 --&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;                &lt;!-- 映射实体类 --&gt;        &lt;mapping class=&quot;com.example.Student&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;\r\n数据库连接和方言配置： 配置数据库连接信息是通过 hibernate.cfg.xml 中\r\nproperty 元素的几个关键属性来完成的。 connection.url\r\n指定了数据库的连接字符串， connection.username 和 connection.password\r\n分别指定了数据库的用户名和密码，而 dialect\r\n属性则指定了对应数据库的方言。\r\n方言配置对于Hibernate的SQL生成至关重要。方言是Hibernate为不同数据库提供的抽象，它知道如何生成特定数据库支持的SQL语法。这样，Hibernate可以为不同的数据库产生正确的SQL语句而无需修改代码。\r\n参数说明 ：\r\nconnection.url ：该属性定义了数据库的连接URL，格式取决于所使用的JDBC驱动程序。\r\nconnection.username 和 connection.password ：分别定义了访问数据库时所需的用户名和密码。\r\ndialect ：该属性指定了数据库方言的完全限定类名，Hibernate根据这个类来生成特定数据库的SQL语句。 \r\n使用properties配置文件和xml配置属于是一样的\r\n在纯注解方式下，我们可以完全摆脱hibernate.cfg.xml文件，使用Java配置类和JPA注解来配置Hibernate。\r\nimport java.util.Properties;import javax.sql.DataSource;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.AvailableSettings;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;public class HibernateUtil &#123;        private static SessionFactory sessionFactory;        public static SessionFactory getSessionFactory() &#123;        if (sessionFactory == null) &#123;            try &#123;                Configuration configuration = new Configuration();                                // 设置数据库连接属性                Properties settings = new Properties();                settings.put(AvailableSettings.DRIVER, &quot;org.h2.Driver&quot;);                settings.put(AvailableSettings.URL, &quot;jdbc:h2:mem:testdb&quot;);                settings.put(AvailableSettings.USER, &quot;sa&quot;);                settings.put(AvailableSettings.PASS, &quot;&quot;);                                // Hibernate特定属性                settings.put(AvailableSettings.DIALECT, &quot;org.hibernate.dialect.H2Dialect&quot;);                settings.put(AvailableSettings.SHOW_SQL, &quot;true&quot;);                settings.put(AvailableSettings.HBM2DDL_AUTO, &quot;update&quot;);                                configuration.setProperties(settings);                                // 添加实体类                configuration.addAnnotatedClass(Student.class);                                ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()                    .applySettings(configuration.getProperties()).build();                                sessionFactory = configuration.buildSessionFactory(serviceRegistry);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return sessionFactory;    &#125;        public static void shutdown() &#123;        if (sessionFactory != null) &#123;            sessionFactory.close();        &#125;    &#125;&#125;\r\n创建主程序进行 CURD 操作\r\n，创建SessionFactory对象import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import java.util.List;public class HibernateDemo &#123;        public static void main(String[] args) &#123;        // 1. 创建SessionFactory，对应hibernate基本配置信息        // 加载hibernate核心配置文件，Configuration类加载 hibernate.cfg.xml        SessionFactory sessionFactory = new Configuration()                .configure(&quot;hibernate.cfg.xml&quot;)                .buildSessionFactory();                try &#123;            // 2. 创建Session，创建SessionFactory对象            // 并且使用SessionFactory创建session对象，类似于连接            Session session = sessionFactory.openSession();                        // 3. 开始事务            Transaction transaction = session.beginTransaction();                        // 4. 创建学生对象并保存            Student student1 = new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20);            Student student2 = new Student(&quot;李四&quot;, &quot;lisi@example.com&quot;, 22);                        System.out.println(&quot;保存学生...&quot;);            // 调用session的方法实现添加            session.save(student1);            session.save(student2);                        // 5. 提交事务            transaction.commit();                        // 6. 查询所有学生            transaction = session.beginTransaction();            System.out.println(&quot;\\n查询所有学生...&quot;);            List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        // 7. 更新学生信息            System.out.println(&quot;\\n更新学生信息...&quot;);            Student studentToUpdate = session.get(Student.class, student1.getId());            studentToUpdate.setEmail(&quot;newemail@example.com&quot;);            session.update(studentToUpdate);                        // 8. 再次查询验证更新            System.out.println(&quot;\\n查询更新后的学生...&quot;);            Student updatedStudent = session.get(Student.class, student1.getId());            System.out.println(updatedStudent);                        // 9. 删除学生            System.out.println(&quot;\\n删除学生...&quot;);            session.delete(student2);                        // 10. 最终查询            System.out.println(&quot;\\n最终学生列表...&quot;);            students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        transaction.commit();                        // 11. 关闭Session            session.close();                    &#125; finally &#123;            // 12. 关闭SessionFactory            sessionFactory.close();        &#125;    &#125;&#125;\r\n这个例子使用了H2内存数据库，所以不需要额外安装数据库服务器，H2数据库非常适合学习和测试。\r\n这个简单的示例展示了Hibernate的核心功能：\r\n\r\n对象-关系映射：通过注解将Java类映射到数据库表\r\nCRUD操作：\r\n\r\n创建(Create)：session.save()\r\n读取(Read)：session.get()和HQL查询\r\n更新(Update)：session.update()\r\n删除(Delete)：session.delete()\r\n\r\n事务管理：通过Transaction对象管理\r\nHQL查询：使用面向对象的查询语言from Student\r\n\r\n使用新的配置方式，该如何写\r\nimport org.hibernate.Session;import org.hibernate.Transaction;public class HibernateAnnotationDemo &#123;        public static void main(String[] args) &#123;        // 获取SessionFactory        SessionFactory sessionFactory = HibernateUtil.getSessionFactory();        Session session = sessionFactory.openSession();                try &#123;            // 开始事务            Transaction transaction = session.beginTransaction();                        // 创建并保存学生            Student student1 = new Student(&quot;王五&quot;, &quot;wangwu@example.com&quot;, 21);            Student student2 = new Student(&quot;赵六&quot;, &quot;zhaoliu@example.com&quot;, 23);                        System.out.println(&quot;保存学生...&quot;);            session.save(student1);            session.save(student2);                        // 提交事务            transaction.commit();                        // 查询示例            transaction = session.beginTransaction();            System.out.println(&quot;\\n所有学生:&quot;);            List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        transaction.commit();                    &#125; finally &#123;            session.close();            HibernateUtil.shutdown();        &#125;    &#125;&#125;\r\n其中的注解声明\r\n\r\n\r\n\r\n注解\r\n来源\r\n说明\r\n\r\n\r\n\r\n\r\n@Entity\r\nJPA\r\n标记类为实体类，将映射到数据库表\r\n\r\n\r\n@Table\r\nJPA\r\n指定映射的表名\r\n\r\n\r\n@Id\r\nJPA\r\n标记主键字段\r\n\r\n\r\n@GeneratedValue\r\nJPA\r\n指定主键生成策略\r\n\r\n\r\n@Column\r\nJPA\r\n指定字段与列的映射关系\r\n\r\n\r\n@Transient\r\nJPA\r\n标记不持久化的字段\r\n\r\n\r\n\r\n\r\n涉及到的API\r\nConfiguration\r\n在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。\r\n\r\nHibernate 运行的底层信息：数据库的\r\nURL，用户名，密码，JDBC驱动类，数据库Diaiect，数据库连接池等，对应hibernate.cfg.xml\r\n文件\r\n持久化类与数据表的映射关系 hbm.xml文件\r\n\r\n在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。\r\nHibernate通常使用Configuration config = new Configuration().configure()；的方式创建实例，此种方式默认会去src下读取hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下：\r\nConfiguration config = new Configuration().configure(&quot;xml文件位置&quot;);\r\n传递 hibernate.properties 属性文件\r\nConfiguration config = new Configuration();\r\n此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示：\r\nConfiguration config = new Configuration().configure(&quot;/config/hibernate.cfg.xml&quot;);\r\nSessionFactory\r\nSessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。\r\n\r\n针对单个数据库映射关系经过编译后的内存镜像，是线程安全的。\r\nSessionFactory对象一且构造完毕，即被赋予特定的配置信息。\r\nSessionFactory是生成Session的工厂\r\n构造SessionFactory很消耗资源，一般情况下一个应用中只初始化一个SessionFactory对象。\r\nHibernate4 新增了一个ServiceRegistry接口，所有基于Hibernate\r\n的配置或者服务都必须统一向这个ServiceRegistry注册后才能效，但是\r\nHibernate5 又不需要了\r\n\r\nSessionFactory实例是通过Configuration对象获取的，其获取方法如下所示：\r\nSessionFactory sessionFactory = config.buildSessionFactory();\r\nSessionFactory具有以下特点：\r\n\r\n它是线程安全的，它的同一个实例能够供多个线程共享。\r\n它是重量级的，不能随意的创建和销毁它的实例。\r\n\r\n由于SessionFactory的这些特点，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，在实际项目使用中，通常会抽取出一个HibernateUtils的工具类，用来提供Session对象。\r\nSession\r\nSession是应用程序与数据库之间交互操作的一个单线程对象，是Hibernate运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。\r\n相当于 JDBC 的 Connection，持久化类与 Session\r\n关联起来之后就具有了持久化的能力\r\n创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下：\r\n// 采用openSession方法创建session =&gt; 获得全新sessionSession session = sessionFactory.openSession();// 采用getCurrentSession方法创建session =&gt; 获得与线程绑定的sessionSession session = sessionFactory.getCurrentSession();\r\n以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。\r\nSession是线程不安全的，多个并发线程同时操作一个Session实例时，就可能导致Session数据存在混乱（方法内部定义和使用Session时，不会出现线程问题）。因此设计软件架构时，应避免多个线程共享一个Sesion实例。同时它也是轻量级的，实例的创建和销毁不需要消耗太多的资源。它还有一个缓存，即Hibernate的一级缓存，这个缓存主要用于存放当前工作单元加载的对象。\r\n在Session中提供了大量的常用方法，具体如下：\r\n\r\nsave()、update()和saveOrUpdate()方法：用于增加和修改对象\r\ndelete()方法：用于删除对象\r\nget()和load()方法：根据主键查询\r\ncreateQuery()和createSQLQuery()方法：用于数据库操作对象\r\ncreateCriteria()方法：条件查询\r\n\r\nTransaction\r\nTransaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示：\r\nTransaction transaction = session.beginTransaction();\r\n在Transaction接口中，提供了事务管理的常用方法，具体如下：\r\n\r\ncommit()方法：提交相关联的session实例。\r\nrollback()方法：撤销事务操作\r\nwasCommitted()方法：检查事务是否提交\r\n\r\n**Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。\r\n发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发送错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Hibernate框架之实体类编写规则和Session","url":"/posts/21432.html","content":"持久化类\r\nHibernate是持久层的ORM映射框架，专注于数据的持久化工作。\r\n所谓的持久化，就是将内存中的数据永久存储到关系型数据库中。\r\n所谓的持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。\r\n其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。\r\n那么我们编写持久化类的时候有哪些要求呢？\r\n实体类编写规则\r\n我们在编写持久化类的时候需要有一下几点需要注意：\r\n\r\n持久化类需要提供无参数的构造方法。因为在\r\nHibernate 的底层需要使用反射生成类的实例。\r\n持久化类的属性需要私有，对私有的属性提供公有的get和set方法。\r\n因为在Hibernate底层会将查询到的数据进行封装。也就是说，实体类里面属性是私有的\r\n持久化类的属性要尽量使用包装的类型。\r\n因为包装类和基本数据类型的默认值不同，包装类的类型语义描述更清晰而基本数据类型不容易描述。举个例子：\r\n假设表中有一列员工工资，如果使用double类型，如果这个员工工资忘记录入到系统中，系统会将默认值0存入到数据库，如果这个员工的工资被扣完了，也会向系统中存入0.那么这个0就有了多重含义，而如果使用包装类类型就会避免以上情况。如果使用Double类型，忘记录入的工资就会存入null，而如果这个员工的工资被扣完了，就会存入0，不会产生歧义。\r\n持久化类要有一个唯一标识OID与表的主键对应，也就是要求实体类有属性作为唯一值（一般使用id值）\r\n因为Hibernate中需要通过这个唯一标识OID区分在内存中是否是同一个持久化类。在Java中通过地址区分是否是同一个对象，在关系型数据库的表中是通过主键区分是否是同一条记录。那么Hibernate就是通过这个OID来进行区分的。Hibernate是不允许在内存中出现两个OID相同的持久化对象的。\r\n持久化类尽量不要使用final进行修饰。\r\n因为Hibernate中有延迟加载的机制，这个机制中会产生代理对象，Hibernate产生代理对象使用的是字节码的增强技术完成的，其实就是产生了当前类的一个子类对象实现的。如果使用了final修饰持久化类。那么就不能产生子类，从而就不会产生代理对象，那么Hibernate的延迟加载策略（是一种优化手段）就会失效。\r\n\r\n持久化类我们已经可以正常编写了，但是在持久化类中需要有一个唯一标识OID与表的主键去建立映射关系。而且主键一般我们是不会让客户手动录入的，一般我们是由程序生成主键。那么Hibernate中也提供了相应的主键生成的方式，下面我们来看Hibernate的主键生成策略。\r\n主键生成策略\r\n主键的类型\r\n在讲解Hibernate的主键生成策略之前，先来了解两个概念，即自然主键和代理主键，具体如下：\r\n\r\n自然主键（少见）：把具体业务含义的字段作为主键，称之为自然主键。\r\n例如在customer表中，如果把name字段作为主键，其前提条件必须是：每一个客户的名字不允许为null，不允许客户重名，并且不允许修改客户姓名。尽管这也是可行的，但是不能满足不断变化的业务需求，一旦出现了允许客户重名的业务需求，就必须修改数据模型，重新定义表的主键，这给数据库的维护增加了难度。\r\n代理主键：把不具备业务含义的字段作为主键（一般是ID），称之为代理主键。\r\n该字段一般取名为”ID“，通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间。在上面的例子中，显然更合理的方式是使用代理主键。\r\n\r\n主键生成策略\r\nhibernate要求实体类里面有一个属性作为唯一值，对应表主键，主键可以不同生成策略\r\nHibernate中，提供了几个内置的主键生成策略，其常用主键生成策略的名称和描述如下：\r\n\r\n自然主键\r\n\r\nassigned：自然主键生成策略.\r\nhibernate不会管理主键值.由开发人员自己录入。如果不知道 id\r\n元素的generator属性，则默认使用该主键生成策略。\r\n\r\n代理主键\r\n\r\nidentity：主键自增.要求在数据库中把主键定义为自增长类型.录入时不需要指定主键.\r\nsequence：Oracle中的主键生成策略.\r\nincrement(了解)：主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值.只有当没有其他进程向同一张表中插入数据时才可以使用，不能在集群环境下使用。\r\nnative：hilo+sequence+identity 自动三选一策略.适合跨数据库平台开发\r\n自动增长\r\nuuid：产生随机字符串作为主键. 主键类型必须为string 类型.\r\n\r\n\r\n\r\n\r\nimg\r\n\r\n持久化对象的状态\r\n持久化对象的三种状态\r\nHibernate为了更好的来管理持久化类，将持久化类分成了三种状态：瞬时态、持久态和脱管态，一个持久化类的实例可能处于三种不同状态中的某一中。\r\n　　1、瞬时态（transient）\r\n​ 对象里面没有id值，对象与session没有关联，不处于 Session 的缓存中\r\n　　瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate的Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库的数据没有任何关联，仅是一个信息携带的载体。\r\n　　2、持久态（persistent）\r\n​ 对象里面有id值，对象与session关联，也是持久化对象\r\n　　持久态的对象存在持久化标识OID，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。\r\n　　3、脱管态（detached）\r\n​ 对象有id值，对象与session没有关联\r\n　　脱管态也称为离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。\r\n区分对象的三种状态\r\n@Test    public void demo1() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();                Customer customer = new Customer(); //瞬时态对象:没有持久化标识OID,没有被session管理        customer.setCust_name(&quot;王五&quot;);        session.save(customer); // 持久化对象:有持久化标识OID,被session管理                tx.commit();        session.close();                System.out.println(customer); //脱管态对象:有持久化标识OID,没有被session管理    &#125;\r\ncustomer对象由new关键字创建，此时还未与Session进行关联，它的状态称为瞬时态；在执行了session.save(customer)操作后，customer对象纳入了Session的管理范围，这时的customer对象变成了持久态对象，此时Session的事务还没有被提交；程序执行完commit()操作并关闭了Session后，customer对象与Session的关联被关闭，此时customer对象就变成了脱管态。\r\n三种状态的转换\r\n\r\n\r\nimg\r\n\r\n从图中可以看出，当一个对象被执行new关键字创建后，该对象处于瞬时态；当对瞬时态对象执行Session的save()或saveOrUpdate()方法后，该对象将被放入Session的一级缓存，对象进入持久态；当对持久态对象执行evict()、close()或clear()操作后，对象进入脱管态（游离态）；当直接执行Session的get()、load()、find()或iterate()等方法从数据库里查询对象时，查询到的对象也处于持久态；当对数据库中的记录进行update()、saveOrUpdate()以及lock()等操作后，此时脱管态的对象就过渡到持久态；由于瞬时态和脱管态的对象不在Session的管理范围，所以一段时间后会被JVM回收。\r\n持久化对象的三种状态可以通过调用Session中的一系列方法实现状态间的转换，具体如下：\r\n瞬时态转换到其他状态\r\n通过前面学习可知，瞬时态的对象由new关键字创建，瞬时态对象转换到其他状态总结如下：\r\n\r\n瞬时态转换为持久态：执行Session的save()或saveOrUpdate()方法。\r\n瞬时态转换为脱管态：为瞬时态对象设置持久化标识OID。\r\n\r\n　　由于持久化对象状态演化图中没有涉及到瞬时态转换到脱管态的情况，这里做下简要的说明，在前面的学习中可知，脱管态对象存在OID，但是没有Session的关联，也就是说脱管态和瞬时态的区别就是OID有没有值，所以可以通过为瞬时态对象设置OID，使其变成脱管态对象。\r\n持久态对象转换到其他状态\r\n持久化对象可以直接通过Hibernate中Session的get()、load()方法，或者Query查询从数据库中获得，持久态对象转换到其他状态总结如下：\r\n\r\n持久态转换为瞬时态：执行Session的delete()方法，需要注意的是被删除的持久化对象，不建议再次使用。\r\n持久态转换为脱管态：执行Session的evict()、close()或clear()方法。evict()方法用于清楚一级缓存中某一对象；close()方法用于关闭Session，清楚一级缓存；clear()方法用于清除一级缓存的所有对象。\r\n\r\n脱管态对象转换到其他状态\r\n脱管态对象无法直接获得，是由其他状态对象转换而来的，脱管态对象转换到其他状态总结如下：\r\n\r\n脱管态转换为持久态：执行Session的update()、saveOrUpdate()或lock()方法。\r\n脱管态转化为瞬时态：将脱管态对象的持久化标识OID设置为null。\r\n\r\n由于持久化对象状态演化图中没有涉及到脱管态转换到瞬时态的情况，这里做下简要的说明，跟瞬时态转换到脱管态的情况相似，脱管态和瞬时态的区别就是OID有没有值，所有可以通过将脱管态对象的OID设置为null，使其变成瞬时态对象。例如在session.close()操作后，加入代码customer.setCust_id(null)，customer对象将由脱管态转化为瞬时态。\r\n持久态对象能够自动更新数据库\r\n// 测试持久化类的持久化对象有自动更新数据库的能力    @Test    public void demo2() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();        // 获得持久化对象        Customer customer = session.get(Customer.class, 1l);        customer.setCust_name(&quot;王五&quot;);        // session.update(customer); // 不用手动调用update方法j就可以更新        tx.commit();        session.close();    &#125;\r\n执行测试我们会发现，我们并没有手动调用update方法，Hibernate就可以将数据自动更新了。持久态对象之所以有这样的一个功能，其实都依赖了HIbernate的一级缓存。\r\n\r\n这一部分参考\r\nhttps://www.cnblogs.com/yft-javaNotes/p/10244422.html\r\n\r\nHibernate的一级缓存\r\nhibernate的一级缓存默认打开的\r\nhibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围\r\nhibernate的一级缓存中，存储数据必须 持久态数据\r\nHibernate的缓存分为一级缓存和二级缓存（二级缓存现在不使用了），Hibernate的这两级缓存都位于持久化层，存储的都是数据库数据的备份。其中第一级缓存为Hibernate的内置缓存，不能被卸载。接下来围绕Hibernate的一级缓存进行详细的讲解。\r\nHibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的Java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应的数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate一级缓存的作用就是减少对数据库的访问次数。\r\n在Session接口的实现中包含一系列的Java集合，这些Java集合构成了Session缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。所以一级缓存也被称为Session的基本缓存。\r\nHibernate的一级缓存有如下特点：\r\n\r\n当应用程序调用Session接口的save()、update()、saveOrUpdate()时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。\r\n当调用Session接口的load()、get()方法，一级Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询的对象，再去数据库中查询相应的对象，并添加到一级缓存中。\r\n当调用Session的close()方法时，Session缓存会被清空。\r\n\r\n测试一级缓存\r\n// 证明Hibernate一级缓存的存在    @Test    public void demo3() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();        // 马上发送一条sql语句查询1号客户,并将数据存入缓存        Customer customer1 = session.get(Customer.class, 1l);        System.out.println(customer1);        // 没有发送sql语句,从缓存中取的数据        Customer customer2 = session.get(Customer.class, 1l);        System.out.println(customer2);        // true 一级缓存缓存的是对象的地址        System.out.println(customer1 == customer2);        tx.commit();        session.close();    &#125;\r\n以上代码中，第一次执行Session的get()方法获取customer1对象时，由于一级缓存中没有数据，所以Hibernate会向数据库发送一条sql语句，查询id为1的对象；当再次调用Session的get()方法获取customer2对象时，不会再发送sql语句，这是因为customer2对象是从一级缓存中获取的。\r\n当Session对象的生命周期还没有结束的时候,在查询相同的数据对象,会现在缓存之中寻找,如果有找到就直接使用缓存中的数据.\r\n\r\n\r\nimg\r\n\r\n接下来验证一下代码的执行结果是否和描述的一致。在Customer customer1 =\r\nsession.get(Customer.class,\r\n1l);这一行设置断点，用debug方式执行该方法，程序进入断点后点击单步跳过（F6），代码执行过System.out.println(customer1);语句后，控制台的输出结果如下：\r\n\r\n\r\nimg\r\n\r\n从上图的输出结果可以看出，customer2对象的查询结果被直接打印了，说明第二次调用Session对象的get()方法时，没有向数据库发送select语句，而是直接从一级缓存中获取customer2对象。\r\n之前我们介绍过，Hibernate的持久态对象能够自动更新数据库，其实就是依赖了一级缓存。那么一级缓存为什么就可以去更新数据库呢？其实是因为一级缓存的一块特殊区域——快照区。\r\n\r\n\r\nimg\r\n\r\nHIbernate向一级缓存放入数据时，同时复制一份数据放入到Hibernate的快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果这两个对象中的属性发送变化，则执行update语句，将缓存中的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。\r\n// 一级缓存中的快照区:持久态对象能够自动更新数据库    @Test    public void demo4() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();                Customer customer = session.get(Customer.class, 1l);        customer.setCust_name(&quot;张三&quot;);                // 比对缓存中和快照区的数据是否一致,如果一致,不更新数据库        // 如果不一致则自动更新数据库        tx.commit();        session.close();    &#125;\r\nHibernate Session\r\nSession 概述\r\nSession 是什么\r\n\r\n持久化管理器：负责执行所有持久化操作的核心接口\r\n短生命周期对象：通常一个业务操作对应一个Session\r\n一级缓存：维护了持久化对象的缓存\r\n工作单元：代表应用程序与数据库的一次会话\r\n\r\nSession 概述\r\n\r\nSession接口是Hibernate向应用程序提供的操纵数据库的最主要的接口，它提供了基本的保存，更新，删除和加载Java对象的方法\r\nSession 具有一个缓存, 位于缓存中的对象称为持久化对象,\r\n它和数据库中的相关记录对应。Session 能够在某些时间点,\r\n按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库,\r\n这一过程被称为刷新缓存(flush)。也叫一级缓存。\r\n在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了\r\nSession 缓存。 只要 Session 实例没有结束生命周期,\r\n且没有清理缓存，则存放在它缓存中的对象也不会结束生命周期。Session\r\n缓存可减少 Hibernate 应用程序访问数据库的频率。\r\nsession缓存的示例\r\n@Test    public void getUser()&#123;        User user=session.get(User.class,1);        User user2=session.get(User.class,1);        System.out.println(user);        System.out.println(user2);//查询出来的两条记录完全一样    &#125;\r\n站在持久化的角度，Hibemate把对象分为4种状态：持久化态，临时状态，游离状态，删除状态，Session的特定方法能使对象从一个状态转换到另一个状态.\r\n\r\nSession 核心方法\r\n对象状态管理方法\r\n\r\n\r\n\r\n方法\r\n说明\r\n对象状态变化\r\n\r\n\r\n\r\n\r\nsave()\r\n将临时对象持久化\r\n临时 → 持久\r\n\r\n\r\npersist()\r\n同save()，但无返回值\r\n临时 → 持久\r\n\r\n\r\nget()\r\n立即加载对象\r\n无 → 持久\r\n\r\n\r\nload()\r\n延迟加载对象\r\n无 → 代理(持久)\r\n\r\n\r\nupdate()\r\n更新脱管对象\r\n脱管 → 持久\r\n\r\n\r\nmerge()\r\n合并脱管对象状态\r\n脱管 → 持久\r\n\r\n\r\ndelete()\r\n删除对象\r\n持久 → 删除\r\n\r\n\r\nsaveOrUpdate()\r\n智能保存或更新\r\n临时/脱管 → 持久\r\n\r\n\r\nevict()\r\n从缓存移除对象\r\n持久 → 脱管\r\n\r\n\r\nclear()\r\n清空整个缓存\r\n所有持久 → 脱管\r\n\r\n\r\nflush()\r\n同步缓存与数据库\r\n保持状态\r\n\r\n\r\n\r\n查询方法\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\ncreateQuery()\r\n创建HQL查询\r\n\r\n\r\ncreateSQLQuery()\r\n创建原生SQL查询\r\n\r\n\r\ncreateCriteria()\r\n创建Criteria查询(已废弃)\r\n\r\n\r\nbyId()\r\n通过ID加载(5.2+)\r\n\r\n\r\n\r\n事务控制方法\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\nbeginTransaction()\r\n开始事务\r\n\r\n\r\ngetTransaction()\r\n获取当前事务\r\n\r\n\r\n\r\n缓存管理方法\r\nevict()：移除特定对象\r\nsession.evict(student); // 从缓存移除该对象\r\nclear()：清空整个缓存\r\nsession.clear(); // 清空所有缓存对象\r\ncontains()：检查对象是否在缓存\r\nboolean cached = session.contains(student);\r\nsession缓存的操作方法\r\n\r\n\r\nimg\r\n\r\nflush方法：\r\nsession会按照缓存中对象属性的变化来更新数据库中的记录，使数据库中记录和缓存中的对象保持一致，默认情况下，在以下时间点会刷新缓存：\r\n\r\n当应用程序调用Transaction.commit()方法时，该方法会先调用flush()方法，然后在\r\n向 数据库提交事务\r\n显示的调用flush()方法时\r\n当应用程序执行一些查询(HQL,\r\nCriteria)操作时，如果缓存中持久化对象的属性已经发生了变化，会先 flush\r\n缓存，以保证查询结果能够反映持久化对象的最新状态\r\n\r\nflush 缓存的例外情况:\r\n如果对象使用 native 生成器生成 OID, 那么当调用 Session 的 save()\r\n方法保存对象时, 会立即执行向数据库插入该实体的 insert 语句.\r\nflush()和commit()方法的区别：\r\nflush()方法会执行一系列的sql语句，但是不会提交事物；commit()在提交事物前，会先调用flush()方法，然后再提交事物，提交事物以为这将数据库的操作永久的保存下来\r\n测试flush方法\r\n@Testpublic void testFlush()&#123;    News vo = (News) this.session.get(News.class,1);    vo.setInfo(&quot;flush()方法测试&quot;);    this.session.flush();//调用flush()方法    System.out.println(vo);&#125;\r\n可以发现当调用了修改了缓存之中的对象,在调用了flush()方法之后,会执行update语句以来保证缓存之中的数据和数据库之中的数据保持同步\r\n\r\n\r\nimg\r\n\r\n数据库之中保存的数据\r\n\r\n\r\nimg\r\n\r\nrefresh：\r\nrefresh会强制发送select语句，\r\n以使数据库中的记录和缓存中的对象保持一致；如果在调用refresh方法前，手动的修改数据库中的记录，查询出来的结果还不是最新的，这跟数据库的数据的隔离级别是相关的，可以在配置文件中显示的修改事物的隔离级别，每一个隔离级别都对应一个整数；\r\n@Testpublic void testReFlush()&#123;    News vo = (News) this.session.get(News.class,1);    /*使用断点,暂停程序,暂停程序的时候修改数据库中的数据,查看最后输出的内容是否有变化*/    this.session.refresh(vo);    System.out.println(vo);&#125;\r\n在暂停的时候修改数据库中的info数据\r\n\r\n\r\nimg\r\n\r\n但是会发现最后输出的结果并不是修改过的数据，因为可重复读的隔离级别，事务持续期间，禁止其他事务对这个字段进行更新。\r\n\r\n\r\nimg\r\n\r\n缓存同步机制\r\n自动同步：在以下时机会自动flush：\r\n\r\n事务提交时\r\n执行查询前(确保查询结果准确)\r\n显式调用session.flush()\r\n\r\n手动同步：\r\nsession.flush(); // 强制同步缓存与数据库\r\nevict()\r\n从session缓存中把指定的持久化对象移除\r\n@Testpublic void testEvict()&#123;    //使用load()方法将数据库中的一个对象将在到缓存之中    News vo1 = (News)this.session.load(News.class,4);        //使用evict()方法将缓存中的对象清除    this.session.evict(vo1);    //当要使用该对象的时候,系统无法从缓存之中初始化该对象,就会出现异常    System.out.println(vo1);&#125;\r\n\r\n\r\nimg\r\n\r\nSession核心方法详解\r\n对实体类 CURD 操作\r\n添加操作\r\n通过调用session里面的save方法实现\r\nsave()方法最大的特点就是将一个临时对象变为持久化对象\r\n为对象分配ID\r\n在flush()缓存时会发送一条INSERT语句.\r\n@Testpublic void testSave()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);    System.out.println(vo);    this.session.save(vo);    System.out.println(vo);&#125;\r\n\r\n\r\nimg\r\n\r\n\r\n在save()执行前，设置ID的方法是无效的，在save()方法执行过后修改id，会出现异常\r\n\r\n@Testpublic void testSave()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);        //在save()方法执行前设置ID    vo.setId(12345);        System.out.println(vo);    this.session.save(vo);    // 在save()方法执行过后修改id，会出现异常    vo.setId(12345);    System.out.println(vo);&#125;\r\n\r\n\r\nimg\r\n\r\n持久化对象的ID是不能够被修改的\r\n\r\n\r\nimg\r\n\r\n通过调用 presist() 方法\r\npersist()方法也会执行INSERT操作，与save()类似，但无返回值\r\n在presist()方法执行之前,如果对象已经有ID值,则不会执行INSERT,而会抛出一个异常.\r\n@Testpublic void testPersist()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);    vo.setId(12345);    System.out.println(vo);    this.session.persist(vo);    System.out.println(vo);&#125;\r\n\r\n\r\nimg\r\n\r\n与save()的区别：\r\n\r\n不保证立即执行INSERT(可能在flush时执行)\r\n不返回ID，需通过对象获取\r\nJPA规范方法，行为更标准化\r\n\r\n查询操作\r\n调用session里面的get方法实现\r\n执行get()方法会立即加载对象，session.get(实体类的class, id值)是根据\r\nid 查询\r\n@Testpublic void testGet()&#123;    News getVo = (News)this.session.get(News.class,1);    System.out.println(getVo.getClass().getName());&#125;\r\n特点：\r\n\r\n立即发出SELECT语句\r\n对象不存在时返回null\r\n返回真实对象(非代理)\r\n\r\n调用session里面的load方法实现\r\n延迟加载，返回代理对象\r\n执行load方法，若不使用该对象，则不会立即执行查询操作，而返回一个代理对象.\r\n// 返回代理对象，不立即查询Student student = session.load(Student.class, 1L);System.out.println(&quot;尚未查询数据库&quot;);// 实际访问非ID属性时才触发查询System.out.println(student.getName());  \r\n可以发现使用load()方法得到的对象在没有使用的情况下是一个代理对象,这是因为使用load()方法得到的对象，在没有使用任何属性的情况下，不会立即加载,而是加载到内存之中，在有需要的时候再加载对象.\r\n\r\n延迟加载(访问非ID属性时查询)\r\n对象不存在时抛ObjectNotFoundException\r\n返回代理对象(运行时生成子类)\r\n\r\n若查询一个数据表中没有的记录,而且Session也没有被关闭,同时需要使用对象的时候.\r\n\r\n使用get方法查询会：返回null\r\n使用load方法查询：若不是用该对象的任何属性没有问题，若需要初始化，抛出异常.\r\n\r\n在需要初始化代理对象之前若关闭Session. load方法可能会抛出 异常\r\n@Testpublic void testLoad()&#123;    News  loadVo = (News)this.session.load(News.class,1888);    this.session.close();//在使用loadVO类之前关闭session    System.out.println(loadVo);&#125;\r\n抛出的异常org.hibernate.LazyInitializationException: could not initialize proxy - no Session(无法初始化代理,没有Session)\r\n\r\n\r\nimg\r\n\r\n更新操作\r\n自动脏检查更新\r\n最常用方式：Hibernate自动检测变化\r\nStudent student = session.get(Student.class, 1L);student.setName(&quot;王五&quot;);  // 修改属性student.setEmail(&quot;wangwu@example.com&quot;);// 无需调用update方法，提交时自动更新tx.commit();  // 触发UPDATE语句\r\n\r\nSession跟踪持久化对象的状态\r\nflush时比较快照，生成UPDATE语句\r\n\r\n调用session里面的update方法实现\r\n首先查询，修改值，然后调用 update 显式更新脱管对象\r\nupdate()方法相当于sql语句之中的Update语句\r\n\r\n\r\nimg\r\n\r\n若更新一个持久化对象，不必显示的调用update()方法，因为在调用Transaction的commit()方法时，会调用session的flush()\r\n更新一个游离对象，需要显示的调用update()方法，可以将一个游离对象转换为持久化对象\r\n当 update() 方法关联一个游离对象时, 如果在 Session\r\n的缓存中已经存在相同 OID 的持久化对象, 会抛出异常\r\n当 update() 方法关联一个游离对象时, 如果在数据库中不存在相应的记录,\r\n也会抛出异常.\r\n注意：\r\n\r\n无论要更新的游离对象是否与数据表中的记录是否一致,都会发送Update语句.\r\n\r\n@Testpublic void  testUpdate()&#123;    News temp =new News();    temp.setId(1);    temp.setTitle(&quot;update()方法测试&quot;);    temp.setPrice(550.2);    temp.setInfo(&quot;testUpdate&quot;);    temp.setPubDate(new Date());    this.session.update(temp);&#125;\r\n\r\n\r\nimg\r\n\r\n如何能让update方法不再盲目的触发update语句?在.hbm.xml文件的class节点设置一个select-before-update=“true”()但通常不使用该属性\r\n&lt;class name=&quot;News&quot; table=&quot;NEWS&quot; select-before-update=&quot;true&quot;&gt;\r\n\r\n如果数据表中没有对应的记录,但还调用了update方法,会抛出异常\r\n当update()方法关联一个游离对象时,如果在Session的缓存之中已经存在了相同的OID的持久化对象.会出现异常,因为在Session缓存中,不能够同时存在两个OID相同的对象，也就是说\r\n同ID对象已存在于Session时会抛异常\r\n@Test public void  testUpdate()&#123;     //使用get()方法得到一个持久化对象,此时这个对象会保存在session的缓存之中     News vo = (News) this.session.get(News.class,1);        //创建一个于vo的id相同的对象     News temp = new News();     temp.setId(vo.getId());     //使用update()方法关联这个temp对象     //由于此时的temp对象和vo对象的id都是相同的     //并且vo对象已经保存在了session之中     //所以当使用update()方法的时候,就会出现在同一session之中存在两个id相同的对象     this.session.update(temp); &#125;   \r\n\r\n\r\nimg\r\n\r\n应确保对象所有属性已设置(否则可能覆盖为null)\r\n\r\n调用session里面的merge方法实现\r\n更安全的更新方式\r\n将脱管对象的状态复制到持久化对象中\r\nStudent detachedStudent = new Student();detachedStudent.setId(1L);detachedStudent.setName(&quot;钱七&quot;);Session newSession = sessionFactory.openSession();newSession.beginTransaction();// 合并对象状态Student persistentStudent = (Student) newSession.merge(detachedStudent);// merge返回的是持久化对象，参数对象仍为脱管状态System.out.println(detachedStudent == persistentStudent);  // falsenewSession.getTransaction().commit();newSession.close();\r\n方法工作流程\r\n\r\n检查传入对象：\r\n\r\n如果为 null，直接返回 null\r\n如果是持久化状态，直接返回该对象（无操作）\r\n\r\n查找对应持久化对象：\r\n\r\n在 Session 缓存中查找同 ID 的实体\r\n如果找到，将脱管对象属性值复制到该持久化对象\r\n如果未找到，从数据库加载或创建新实例\r\n\r\n返回值处理：\r\n\r\n返回的是持久化对象（可能是缓存中的或新创建的）\r\n重要：传入的参数对象不会被关联到 Session\r\n\r\n状态同步：\r\n\r\n在 flush 时，生成的持久化对象会同步到数据库\r\n\r\n\r\nmerge() 与 update() 的对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\nmerge()\r\nupdate()\r\n\r\n\r\n\r\n\r\n同ID对象存在时\r\n合并属性值到持久化对象\r\n抛出NonUniqueObjectException\r\n\r\n\r\n返回值\r\n返回持久化对象\r\n无返回值\r\n\r\n\r\n参数对象状态\r\n保持脱管状态\r\n转为持久化状态\r\n\r\n\r\nSQL执行时机\r\n根据flush策略\r\n根据flush策略\r\n\r\n\r\n级联行为\r\n支持CascadeType.MERGE\r\n支持CascadeType.UPDATE/SAVE_UPDATE\r\n\r\n\r\n新对象处理\r\n可能转为save操作\r\n抛出TransientObjectException\r\n\r\n\r\n性能\r\n可能需要额外SELECT\r\n直接操作\r\n\r\n\r\n\r\n调用session里面的saveOrUpdate方法实现\r\nSession 的 saveOrUpdate() 方法同时包含了 save() 与 update()\r\n方法的功能，自动判断保存或更新\r\n\r\n\r\nimg\r\n\r\n// 新对象(无ID) - 执行INSERTStudent newStudent = new Student();newStudent.setName(&quot;孙八&quot;);session.saveOrUpdate(newStudent);// 脱管对象(有ID) - 执行UPDATEStudent detachedStudent = new Student();detachedStudent.setId(1L);detachedStudent.setName(&quot;周九&quot;);session.saveOrUpdate(detachedStudent);\r\n判断对象是不是临时对象：\r\n\r\nJava 对象的 OID 为 null\r\n映射文件中为 &lt;id&gt; 设置了 unsaved-value 属性,\r\n并且 Java 对象的 OID 取值与这个 unsaved-value 属性值匹配\r\n\r\n判断逻辑：\r\n\r\n对象ID为null → save()\r\n对象ID非null → update()\r\n\r\n如果OID不为null,但数据表中还没有和其对应的记录,会抛出一个异常.\r\n@Testpublic void testSaveOrUpdate()&#123;    News news = new News();    news.setId(123456);//此时数据库之中不存在此id的数据    this.session.saveOrUpdate(news);//如果调用saveOrUpdate()方法就会出现异常&#125;\r\n\r\n\r\nimg\r\n\r\n删除操作\r\n调用session中的delete() 方法\r\n删除持久化对象，只要OID和数据表中的一条记录对应，就执行delete操作\r\n如果OID和数据库中的一条记录保持一致，则执行删除操作，把对象从 Session\r\n缓存中删除,\r\n该对象进入删除状态，若OID在数据库中没有对应的记录，则抛出异常，Hibernate\r\n的 cfg.xml 配置文件中有一个 hibernate.use_identifier_rollback 属性,\r\n其默认值为 false, 若把它设为 true，改变 delete() 方法的运行行为:\r\ndelete() 方法会把持久化对象或游离对象的 OID 设置为 null,\r\n使它们变为临时对象，软删除\r\nStudent student = session.get(Student.class, 1L);// 删除对象session.delete(student);  // 转为Removed状态// 也可以直接删除(避免先查询)Student studentToDelete = new Student();studentToDelete.setId(2L);session.delete(studentToDelete);  // 按ID删除tx.commit();  // 执行DELETE语句\r\n注意事项：\r\n\r\n删除后对象变为Removed状态\r\n关联对象需考虑级联删除\r\n批量删除建议使用HQL更高效\r\n\r\nSession 方法的完整例子\r\n使用 spring data jpa\r\n添加依赖\r\n&lt;dependencies&gt;    &lt;!-- Spring Boot Starter Data JPA --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;!-- H2 数据库 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.h2database&lt;/groupId&gt;        &lt;artifactId&gt;h2&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- Lombok --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n应用配置 (application.yml)\r\nspring:  datasource:    url: jdbc:h2:mem:testdb    driver-class-name: org.h2.Driver    username: sa    password:   jpa:    hibernate:      ddl-auto: update    show-sql: true    properties:      hibernate:        format_sql: true\r\n定义实体类\r\nimport javax.persistence.*;import lombok.Data;@Data@Entity@Table(name = &quot;students&quot;)public class Student &#123;        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(nullable = false)    private String name;        private String email;        private Integer age;        @Version    private Integer version; // 乐观锁版本字段&#125;\r\nRepository 接口\r\nimport org.springframework.data.jpa.repository.JpaRepository;public interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;&#125;\r\n完整 Service 示例\r\nimport javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.transaction.Transactional;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class StudentService &#123;        @PersistenceContext    private EntityManager entityManager; // 相当于Hibernate Session        private final StudentRepository studentRepository;        public StudentService(StudentRepository studentRepository) &#123;        this.studentRepository = studentRepository;    &#125;        // ========== 创建操作 ==========        /**     * 使用EntityManager的persist方法     */    @Transactional    public Long createWithPersist(Student student) &#123;        entityManager.persist(student);        return student.getId(); // 返回生成的ID    &#125;        /**     * 使用Repository的save方法     */    @Transactional    public Student createWithSave(Student student) &#123;        return studentRepository.save(student);    &#125;        // ========== 读取操作 ==========        /**     * 使用EntityManager的find方法(相当于get)     */    @Transactional    public Student findById(Long id) &#123;        return entityManager.find(Student.class, id);    &#125;        /**     * 使用EntityManager的getReference方法(相当于load)     */    @Transactional    public Student lazyFindById(Long id) &#123;        return entityManager.getReference(Student.class, id);    &#125;        /**     * 使用Repository方法查询     */    public List&lt;Student&gt; findAllStudents() &#123;        return studentRepository.findAll();    &#125;        // ========== 更新操作 ==========        /**     * 自动脏检查更新     */    @Transactional    public Student updateWithDirtyChecking(Long id, String newName) &#123;        Student student = entityManager.find(Student.class, id);        student.setName(newName);        return student; // 事务提交时会自动更新    &#125;        /**     * 使用merge方法更新脱管对象     */    @Transactional    public Student updateWithMerge(Student detachedStudent) &#123;        return entityManager.merge(detachedStudent);    &#125;        // ========== 删除操作 ==========        /**     * 使用EntityManager的remove方法     */    @Transactional    public void deleteWithRemove(Long id) &#123;        Student student = entityManager.find(Student.class, id);        if (student != null) &#123;            entityManager.remove(student);        &#125;    &#125;        /**     * 使用Repository的delete方法     */    @Transactional    public void deleteWithRepository(Long id) &#123;        studentRepository.deleteById(id);    &#125;        // ========== 其他操作 ==========        /**     * 刷新对象状态     */    @Transactional    public Student refreshStudent(Long id) &#123;        Student student = entityManager.find(Student.class, id);        entityManager.refresh(student); // 从数据库重新加载        return student;    &#125;        /**     * 清空持久化上下文     */    @Transactional    public void clearPersistenceContext() &#123;        entityManager.clear();    &#125;        /**     * 立即刷新到数据库     */    @Transactional    public void flushChanges() &#123;        entityManager.flush();    &#125;&#125;\r\n测试控制器\r\nimport org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/api/students&quot;)public class StudentController &#123;        private final StudentService studentService;        public StudentController(StudentService studentService) &#123;        this.studentService = studentService;    &#125;        @PostMapping    public Long createStudent(@RequestBody Student student) &#123;        return studentService.createWithPersist(student);    &#125;        @GetMapping(&quot;/&#123;id&#125;&quot;)    public Student getStudent(@PathVariable Long id) &#123;        return studentService.findById(id);    &#125;        @GetMapping(&quot;/lazy/&#123;id&#125;&quot;)    public Student getStudentLazy(@PathVariable Long id) &#123;        Student student = studentService.lazyFindById(id);        System.out.println(&quot;Before access: Proxy object&quot;);        System.out.println(&quot;Name: &quot; + student.getName()); // 触发实际加载        return student;    &#125;        @GetMapping    public List&lt;Student&gt; getAllStudents() &#123;        return studentService.findAllStudents();    &#125;        @PutMapping(&quot;/&#123;id&#125;&quot;)    public Student updateStudent(@PathVariable Long id, @RequestBody Student student) &#123;        student.setId(id);        return studentService.updateWithMerge(student);    &#125;        @PatchMapping(&quot;/&#123;id&#125;&quot;)    public Student updateName(@PathVariable Long id, @RequestParam String name) &#123;        return studentService.updateWithDirtyChecking(id, name);    &#125;        @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void deleteStudent(@PathVariable Long id) &#123;        studentService.deleteWithRemove(id);    &#125;        @PostMapping(&quot;/refresh/&#123;id&#125;&quot;)    public Student refresh(@PathVariable Long id) &#123;        return studentService.refreshStudent(id);    &#125;&#125;\r\n测试用例\r\nimport javax.transaction.Transactional;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTest@Transactionalclass StudentServiceTest &#123;        @Autowired    private StudentService studentService;        @Test    void testFullCrudCycle() &#123;        // 1. 创建        Student student = new Student();        student.setName(&quot;Test Student&quot;);        student.setEmail(&quot;test@example.com&quot;);        student.setAge(20);                Long id = studentService.createWithPersist(student);        assertNotNull(id);                // 2. 查询        Student found = studentService.findById(id);        assertEquals(&quot;Test Student&quot;, found.getName());                // 3. 更新(自动脏检查)        found.setName(&quot;Updated Name&quot;);        // 不需要显式调用update方法                // 4. 验证更新        Student updated = studentService.findById(id);        assertEquals(&quot;Updated Name&quot;, updated.getName());                // 5. 删除        studentService.deleteWithRemove(id);                // 6. 验证删除        Student deleted = studentService.findById(id);        assertNull(deleted);    &#125;        @Test    void testMergeDetachedEntity() &#123;        // 1. 创建并持久化        Student student = new Student();        student.setName(&quot;Original&quot;);        Long id = studentService.createWithPersist(student);                // 2. 模拟脱管对象        Student detached = new Student();        detached.setId(id);        detached.setName(&quot;Detached&quot;);        detached.setAge(25);                // 3. 合并        Student merged = studentService.updateWithMerge(detached);                // 验证        assertEquals(id, merged.getId());        assertEquals(&quot;Detached&quot;, merged.getName());        assertEquals(25, merged.getAge());    &#125;&#125;\r\nSpring Data JPA 与 Hibernate Session 的关系\r\n\r\nEntityManager：JPA 标准接口，Spring\r\nData JPA 底层使用 Hibernate 实现\r\n\r\npersist() → Hibernate\r\nsave()/persist()\r\nmerge() → Hibernate merge()\r\nfind() → Hibernate get()\r\ngetReference() → Hibernate load()\r\nremove() → Hibernate delete()\r\n\r\nRepository 方法：\r\n\r\nsave()：实际执行 merge 语义\r\ndeleteById()：先查询再删除\r\n\r\n\r\n事务管理\r\n\r\n@Transactional 注解自动管理事务边界\r\n方法结束时自动提交，异常时回滚\r\n同一个事务内共享持久化上下文\r\n\r\n乐观锁冲突处理\r\n@Transactionalpublic Student updateWithOptimisticLock(Long id, String newName) &#123;    Student student = studentRepository.findById(id)        .orElseThrow(() -&gt; new RuntimeException(&quot;Student not found&quot;));        student.setName(newName);        try &#123;        return studentRepository.save(student);    &#125; catch (ObjectOptimisticLockingFailureException e) &#123;        // 处理并发修改冲突        throw new RuntimeException(&quot;数据已被其他用户修改，请刷新后重试&quot;);    &#125;&#125;\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Hibernate的其他API以及HQL查询.md","url":"/posts/48129.html","content":"Hibernate的其他API\r\nQuery\r\nQuery接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。\r\nHQL：Hibernate Query Language\r\n：Hibernate查询语言。这种语言与SQL的语法及其类似，是一个面向对象的查询语言。\r\nSQL的操作对象是数据表、列等数据库对象，而HQL操作对象是类、对象、属性等。\r\nQuery 接口用来执行 HQL，Query 接口实例可以从 Session 对象 session\r\n中生成：session.createQuery(String hql)\r\n// HQL 查询Query&lt;Student&gt; hqlQuery = session.createQuery(&quot;FROM Student WHERE age &gt; :age&quot;, Student.class);// 原生 SQL 查询Query&lt;Student&gt; sqlQuery = session.createNativeQuery(&quot;SELECT * FROM students WHERE age &gt; ?&quot;, Student.class);\r\n通过 JPA EntityManager 创建\r\n// JPQL 查询javax.persistence.Query jpqlQuery = entityManager.createQuery(&quot;SELECT s FROM Student s WHERE s.age &gt; :age&quot;);// 原生 SQL 查询javax.persistence.Query sqlQuery = entityManager.createNativeQuery(&quot;SELECT * FROM students&quot;);\r\nQuery对象在Session对象关闭之前有效，否则会抛出SessionException异常。因为Session对象就想ＪＤＢＣ中的Connection\r\n对象，即数据库的一次连接。关闭Connection对象，Statement对象就不能再使用，所以关闭Session后就不能再使用Query对象了。\r\nQuery经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。\r\n通过Query即可以执行hql语句:\r\nQuery query = session.createQuery(&quot;hql语句&quot;);\r\n又可以执行本地sql语句：\r\nSQLQuery sqlQuery = session.createSQLQuery(&quot;本地sql语句&quot;);\r\n其中SQLQuery是Query的子类\r\nQuery 接口的主要方法\r\nQuery 的主要方法：\r\nsetxxx():用于设置HQL语句中问号或者变量的值;\r\nsetString(int position,String value);\r\n设置HQL中的“？”的值，其中position代表“？”在HQL中的位置，value是要为“？”设置的值\r\nQuery query=session.createQuery(&quot;from UserInfoPO u where u.age&gt;? and u.useName like ?&quot;);query.setInteger(0, 22);     //使用&quot;?&quot;,第一个下标是从0开始的，给第一个问号赋值22query.setString(1, &quot;%志%&quot;);   //设置第二个问号的值为“%志%”\r\nsetString(String paraName,String value);\r\n设置HQL中“：”后所跟变量的值；其中\r\nparaName代表HQL中“：”后边的变量名，value是该变量的值：\r\nQuery query=session.createQuery(&quot;from UserInfoPO u where u.age&gt;：minAge and u.useName like:useName&quot;);query.setInteger(&quot;minAge&quot;, 22);       //设置minAge的值query.setString(&quot;userName&quot;, &quot;%志%&quot;);   //设置useName的值\r\nsetParameter()方法：参数绑定方法\r\n位置参数绑定\r\nQuery&lt;Student&gt; query = session.createQuery(    &quot;FROM Student WHERE age &gt; ?1 AND name LIKE ?2&quot;,     Student.class);query.setParameter(1, 18);query.setParameter(2, &quot;张%&quot;);\r\n命名参数绑定\r\nQuery&lt;Student&gt; query = session.createQuery(    &quot;FROM Student WHERE age &gt; :minAge AND age &lt; :maxAge&quot;,     Student.class);query.setParameter(&quot;minAge&quot;, 18);query.setParameter(&quot;maxAge&quot;, 25);\r\n分页控制方法：\r\nsetFirstResult：设定从哪一个对象开始检索，参数表示这个对象在查询结果中的索引位置，起始值为0，默认情况下，从查询结果的第一个对象开始检索\r\nsetMaxResults：一次检索最多返回多少数目\r\nQuery&lt;Student&gt; query = session.createQuery(&quot;FROM Student ORDER BY name&quot;, Student.class);query.setFirstResult(10); // 从第10条记录开始(0-based)query.setMaxResults(5);   // 最多返回5条记录List&lt;Student&gt; students = query.getResultList();\r\nlist()；返回查询结果，并把查询结果转换成list对象\r\nQuery query=session.createQuery(&quot;from UserInfoPO u where u.age&gt;：minAge and u.useName like:useName&quot;);           query.setInteger(&quot;minAge&quot;, 22);       //设置minAge的值           query.setString(&quot;userName&quot;, &quot;%志%&quot;);   //设置useName的值           List&lt;UserInfoPO&gt; list=query.list();                     for(int i=0;i&lt;list.size();i++)&#123;       \t   ui=(UserInfoPO)list.get(i);       \t   System.out.println(ui.getUserName());          &#125;\r\ngetResultList();：也可以获取结果列表\r\nList&lt;Student&gt; students = query.getResultList();\r\nexecuteUpdate()：执行更新，删除：\r\nQuery&lt;?&gt; updateQuery = session.createQuery(    &quot;UPDATE Student SET email = :email WHERE id = :id&quot;);updateQuery.setParameter(&quot;email&quot;, &quot;new@example.com&quot;);updateQuery.setParameter(&quot;id&quot;, 1L);int updatedCount = updateQuery.executeUpdate();\r\n标量结果\r\nQuery&lt;Long&gt; countQuery = session.createQuery(    &quot;SELECT COUNT(*) FROM Student&quot;, Long.class);long count = countQuery.getSingleResult();\r\n\r\n查询所有表当中信息\r\n\r\npublic class HibernateDemo5 &#123;\t@Test\t// Query\tpublic void demo01() &#123;\t\tSession session = HibernateUtils.getCurrentSession();\t\tTransaction transaction = session.beginTransaction();\t\t// 通过Session活动Query接口\t\tString hql = &quot;from Customer&quot;;\t\tQuery query = session.createQuery(hql);\t\tList&lt;Customer&gt; list = query.list();\t\tfor (Customer customer : list) &#123;\t\t\tSystem.out.println(customer);\t\t&#125;\t\ttransaction.commit();\t&#125;&#125;\r\n\r\n\r\nimg\r\n\r\n\r\n查询指定字符的数据（条件查询）\r\npublic class HibernateDemo5 &#123;\t@Test\t// Query\tpublic void demo01() &#123;\t\tSession session = HibernateUtils.getCurrentSession();\t\tTransaction transaction = session.beginTransaction();\t\t// 通过Session活动Query接口\t\t// String hql = &quot;from Customer&quot;;\t\tString hql = &quot;from Customer where cust_name like ?&quot;;\t\tQuery query = session.createQuery(hql);\t\tquery.setParameter(0, &quot;王%&quot;);\t\tList&lt;Customer&gt; list = query.list();\t\tfor (Customer customer : list) &#123;\t\t\tSystem.out.println(customer);\t\t&#125;\t\ttransaction.commit();\t&#125;&#125;\r\n\r\n\r\nimg\r\n\r\n分页查询\r\npublic class HibernateDemo5 &#123;\t@Test\t// Query\tpublic void demo01() &#123;\t\tSession session = HibernateUtils.getCurrentSession();\t\tTransaction transaction = session.beginTransaction();\t\t// 通过Session活动Query接口\t\t//分页查询\t\tString hql = &quot;from Customer&quot;;\t\tQuery query = session.createQuery(hql);\t\t//设置分页\t\tquery.setFirstResult(0);//相当于MySQL当中limit的第一个参数\t\tquery.setMaxResults(3);\t\t//query.setParameter(0, &quot;王%&quot;);\t\tList&lt;Customer&gt; list = query.list();\t\tfor (Customer customer : list) &#123;\t\t\tSystem.out.println(customer);\t\t&#125;\t\ttransaction.commit();\t&#125;&#125;\r\n\r\n\r\nimg\r\n\r\n\r\nCriteria与条件查询\r\nCriteria API\r\n是一种面向对象的查询方式，它允许你通过编程方式构建查询条件，而无需编写\r\nSQL 或 HQL。这种方式也被称为 QBC（Query By\r\nCriteria），即 “条件查询”\r\n使用QBC(Query By\r\nCriteria);更加面向对象的一种查询方式。\r\nCriteria接口与Query接口非常类似，也是Hibernate的查询接口，它允许创建并执行面向对象方式的查询。\r\nCriteria的主要作用：\r\n\r\nCriteria查询通过面向对象的设计，将数据查询条件封装为一个对象。简单的说，Criteria查询可以看成是传统SQL语言的对象化表示。\r\nCriteria接口完全封装了基于字符串形式的查询语句，它更擅长于执行动态查询。\r\n\r\n条件查询查询的步骤：\r\n\r\n获得Hibernate的Session对象。\r\n以Session对象创建Criteria对象。\r\n使用Restrictions的方法为Criteria对象设置查询条件，Order工具类的方法设置排序方式，Projections工具类的方法进行统计和分组。\r\n向Criterion查询添加Criterion查询条件。\r\n执行Criteria的list()或uniqueResult()方法返回结果集。\r\n\r\n核心组件\r\n\r\nCriteria：主查询接口，通过\r\nsession.createCriteria(EntityClass.class) 创建。\r\nCriterion：查询条件（如 eq,\r\nlike, gt 等），通过 Restrictions\r\n工具类生成。\r\nProjection：结果集投影（如 count,\r\navg, group by 等），通过\r\nProjections 工具类生成。\r\nOrder：排序规则，通过 Order.asc() 或\r\nOrder.desc() 创建。\r\nDetachedCriteria：独立于 Session\r\n的查询对象，可在多个 Session 中复用。\r\n\r\nimport org.hibernate.*;import org.hibernate.boot.registry.*;import org.hibernate.cfg.*;import org.hibernate.service.*; public class HibernateUtil &#123;    public static final SessionFactory sessionFactory;     static &#123;        try &#123;            // 使用默认的hibernate.cfg.xml配置文件创建Configuration实例            Configuration cfg = new Configuration().configure();            // 以Configuration实例来创建SessionFactory实例            ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();            sessionFactory = cfg.buildSessionFactory(serviceRegistry);        &#125; catch (Throwable ex) &#123;            System.err.println(&quot;Initial SessionFactory creation failed.&quot; + ex);            throw new ExceptionInInitializerError(ex);        &#125;    &#125;     // ThreadLocal可以隔离多个线程的数据共享，因此不再需要对线程同步    public static final ThreadLocal&lt;Session&gt; session = new ThreadLocal&lt;Session&gt;();     public static Session currentSession() throws HibernateException &#123;        Session s = session.get();        // 如果该线程还没有Session,则创建一个新的Session        if (s == null) &#123;            s = sessionFactory.openSession();            // 将获得的Session变量存储在ThreadLocal变量session里            session.set(s);        &#125;        return s;    &#125;     public static void closeSession() throws HibernateException &#123;        Session s = session.get();        if (s != null)            s.close();        session.set(null);    &#125;&#125;\r\n在条件查询中，Criteria接口代表一次查询，该查询本身不具备任何数据筛选功能，Session调用createCriteria(Class\r\nclazz)方法对某个持久化类创建条件查询实例。\r\n常用的Criteria操作方法：\r\n\r\nadd()方法：它用来设置查询的条件，可以根据查询条件的个数，追加任意个add()方法。\r\naddOrder()方法：用来设置查询结果集的排序规则，相当于SQL语句中的order\r\nby子句。\r\ncreateCriteria()方法：当需要从多张表中联合查询时可使用createCriteria()方法。\r\nsetFirstResult(int firstResult)：设置查询返回的第一行记录。\r\nsetMaxResults(int maxResults)：设置查询返回的记录数。\r\n\r\n//分页查询前10条Criteria criteria = session.createCriteria(Customer.class);criteria.addOrder( Order.asc(&quot;name&quot;) ); //排序方式criteria.setFirstResult(0);criteria.setMaxResults(10);List result = criteria.list（）\r\n常用查询条件\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n说明\r\n示例\r\n\r\n\r\n\r\n\r\neq(property, value)\r\n等于\r\nRestrictions.eq(\"age\", 20)\r\n\r\n\r\nne(property, value)\r\n不等于\r\nRestrictions.ne(\"name\", \"张三\")\r\n\r\n\r\ngt(property, value)\r\n大于\r\nRestrictions.gt(\"age\", 18)\r\n\r\n\r\nge(property, value)\r\n大于等于\r\nRestrictions.ge(\"score\", 90)\r\n\r\n\r\nlt(property, value)\r\n小于\r\nRestrictions.lt(\"age\", 30)\r\n\r\n\r\nle(property, value)\r\n小于等于\r\nRestrictions.le(\"price\", 100.0)\r\n\r\n\r\nlike(property, value)\r\n模糊查询（支持 % 和 _）\r\nRestrictions.like(\"name\", \"张%\")\r\n\r\n\r\nin(property, values)\r\n包含在集合中\r\nRestrictions.in(\"id\", Arrays.asList(1, 2, 3))\r\n\r\n\r\nisNull(property)\r\n为空\r\nRestrictions.isNull(\"email\")\r\n\r\n\r\nisNotNull(property)\r\n不为空\r\nRestrictions.isNotNull(\"phone\")\r\n\r\n\r\nand(criterion1, criterion2)\r\n逻辑与\r\nRestrictions.and(gt(\"age\", 18), like(\"name\", \"张%\"))\r\n\r\n\r\nor(criterion1, criterion2)\r\n逻辑或\r\nRestrictions.or(eq(\"status\", 1), isNull(\"deleted\"))\r\n\r\n\r\n\r\n\r\nHQL查询\r\nHQL查询语句\r\nHQL ——(Hibernate Query\r\nLanguage)：Hibernate语言查询它是完全面向对象的查询语句，查询功能非常强大，具备继承、多态和关联等特性\r\n。Hibernate官方推荐使用HQL进行查询。 QBC——(Query By\r\nCriteria)：标准化对象查询，以对象的方式进行查询，将查询语句封装为对象操作。优点：可读性好，符合Java\r\n程序员的编码习惯。 Native SQL\r\nQueries：原生SQL查询，直接使用数据库提供的SQL方言进行查询。\r\nHQL是Hibernate Query\r\nLanguage的缩写，HQL的语法与SQL相似，但HQL是一种面向对象的查询语言。SQL的操作对象是数据表、列等数据库对象，而HQL操作对象是类、对象、属性等。\r\nHibernate查询语言（HQL）是面向对象的查询语言，其结构与SQL查询相似，不同的是，HQL查询的主体是持久化类而不是数据表。\r\nHQL提供了一种应用和数据库之间的抽象，提高了可移植性。\r\nHQL子句本身大小写无关，但是其中出现的类名和属性名必须注意大小写。\r\nHQL是完全面向对象的查询语言，支持继承和多态等特性。\r\nHQL语句本身是不区分大小写的，也就是说HQL语句的关键字、函数都是不区分大小写的。但HQL语句中所有使用的包名、类名、实例名、属性名都区分大小写。\r\nHQL查询依赖于Query类，每个Query对象对应一个查询对象。查询步骤如下：\r\n\r\n获取Hibernate Session对象。\r\n编写HQL查询语句。\r\n以HQL语句为参数，调用session的createQuery方法，创建查询对象Query。\r\n如果HQL语句中带有参数，则调用Query的setXxx方法，对参数赋值。\r\n调用Query的list, unique Result等方法，查询获得结果。\r\n\r\nfrom子句\r\nfrom是最简单的HQL语句，也是最基本的HQL语句。from关键字后紧跟持久化类的类名。\r\nfrom Person表明从Person 持久化类中选出全部的实例。from Person as p | from Person p–\t为实体类指定别名\r\nfrom后还可以同时出现多个持久化类，此时将产生一个笛卡尔积或跨表的连接。但实际上这种用法很少使用，因为通常需要使用跨表连接时，可以考虑使用隐式连接或者显式连接，而不是直接在from后紧跟多个表名。\r\n基本查询结构\r\nSELECT [DISTINCT] 属性列表 FROM 实体名 [AS] 别名 [WHERE 条件] [GROUP BY 分组属性] [HAVING 分组条件] [ORDER BY 排序属性 [ASC|DESC]]\r\n// 查询所有学生String hql = &quot;FROM Student&quot;;Query&lt;Student&gt; query = session.createQuery(hql, Student.class);List&lt;Student&gt; students = query.getResultList();// 带别名的查询String hql = &quot;FROM Student AS s WHERE s.age &gt; 20&quot;;Query&lt;Student&gt; query = session.createQuery(hql, Student.class);\r\n关联和连接\r\n当程序需要从多个数据表中取得数据时，SQL语句将会考虑多表连接查询。Hibernate使用关联映射来处理底层数据表之间的连接，一旦提供了正确的关联映射后，当程序通过Hibernate进行持久化访问时，将可利用Hibernate关联来进行连接。\r\nHQL支持两种关联连接形式：显式和隐式。\r\n隐式连接不需要使用join关键字，使用英文点号（.）来隐式连接关联实体，而Hibernate底层将自动进行关联查询。\r\n// 查询部门名称为&quot;研发部&quot;的学生String hql = &quot;FROM Student s WHERE s.department.name = &#x27;研发部&#x27;&quot;;\r\n使用显示连接可以为相关联的实体，甚至是关联集合中的全部元素指定一个别名。\r\n\r\ninner join内连接，可简写为join\r\nleft outer join左外连接\r\nright outer join右外连接\r\nfull join全连接\r\n\r\nString hql=&quot;select p from person p inner join p.myevent e where e.title like&#x27;%上课%&#x27;&quot;;\r\n隐式连接和显式连接的区别：\r\n隐式连接底层将转换成SQL99的交叉连接，显式连接将转换成SQL99的inner\r\njoin、left join、right join等连接。\r\n隐式连接和显式连接查询后返回的结果不同。当HQL省略关键字select时，隐式连接返回的结果是多个被查询实体组成的集合；显示连接查询返回的是被查询的持久化对象和被关联的持久化对象组成的数组。\r\n\r\n隐式连接查询中，在HQL中，省略select，直接使用from开头 例如：from\r\nMessage m where m.topic.id=3\r\n对Message和Topic进行了连接查询，但是结果只包含Message的数据，结果为：List\r\n显示连接查询中，在HQL中，省略select，直接使用from开头 例如：from\r\nMessage m join m.topic t where t.id=3;\r\n对Message和Topic进行了连接查询，每条记录包含Message和Topic两个实体的数据，两个实体构成一个数组，多条记录构成集合，结果为：List&lt;Object[\r\n]&gt;\r\n\r\nSELECT子句\r\nselect子句用于选择指定的属性或直接选择某个实体，当然select选择的属性必须是from后持久化类包含的属性。\r\nselect选择的属性是实体类的属性；结果是一个集合，集合中的每个元素是一个Object数组：Object[]\r\n查询特定属性\r\n// 只查询姓名和年龄String hql = &quot;SELECT s.name, s.age FROM Student s&quot;;Query&lt;Object[]&gt; query = session.createQuery(hql, Object[].class);// 查询结果自动封装为对象List&lt;Object[]&gt; results = query.getResultList();results.forEach(row -&gt; &#123;    String name = (String) row[0];    Integer age = (Integer) row[1];    System.out.println(name + &quot;: &quot; + age);&#125;);\r\n使用 DTO\r\n// 创建DTO类public class StudentDTO &#123;    private String name;    private Integer age;    // 构造器、getter/setter&#125;// 查询并使用构造器String hql = &quot;SELECT NEW com.example.StudentDTO(s.name, s.age) FROM Student s&quot;;Query&lt;StudentDTO&gt; query = session.createQuery(hql, StudentDTO.class);\r\n聚合函数\r\nHQL中支持的聚合函数有：concat(str,str)、substring()、trim()、lower()、upper()、length()、abs()、sqrt()、mod()、count()、avg()、min()、max()、sum()、current_date()、current_time()、current_timestamp()、day()、\r\nmonth()、year()等。\r\n也可以支持数学运算和连接符号等\r\n同时也支持经验证SQL函数，如length()、lower()、upper()、trim()等\r\n可以使用distinct去除重复数据\r\n// 统计各年龄段学生数量String hql = &quot;SELECT s.age, COUNT(s) FROM Student s GROUP BY s.age&quot;;Query&lt;Object[]&gt; query = session.createQuery(hql, Object[].class);\r\nWHERE子句\r\nwhere子句用来筛选选中的结果，缩小选择范围。如果没有持久化实例命名别名，则可以直接使用属性名来引用属性。\r\nwhere子句中支持大部分SQL的表达式：\r\n设置参数\r\n// 冒号+参数名from Person p where p.age &lt;:max query.setInteger(“max”,20);// 问号为占位符from Person p where p.age &lt;？ query.setInteger(0,20);// 问号与指定数字位置from Person p where p.age &lt;？1query.setInteger(“1“,20);\r\n基本条件\r\n// 比较运算String hql = &quot;FROM Student s WHERE s.age &gt; 20&quot;;// 模糊查询String hql = &quot;FROM Student s WHERE s.name LIKE &#x27;张%&#x27;&quot;;// 范围查询String hql = &quot;FROM Student s WHERE s.age BETWEEN 18 AND 22&quot;;// 空值检查String hql = &quot;FROM Student s WHERE s.email IS NOT NULL&quot;;\r\n集合查询\r\n// IN 查询String hql = &quot;FROM Student s WHERE s.name IN (&#x27;张三&#x27;, &#x27;李四&#x27;)&quot;;// 集合大小String hql = &quot;FROM Student s WHERE s.projects.size &gt; 2&quot;;// 集合元素检查String hql = &quot;FROM Student s WHERE &#x27;数学&#x27; MEMBER OF s.courses&quot;;\r\nHQL子查询\r\n如果底层数据库支持子查询（所谓子查询就是，要查询的字段及信息在A表，条件在B表），则可以在HQL语句中使用子查询。与SQL中子查询相似的是，HQL中的子查询也需要使用()。\r\n如果子查询返回多条记录，则可以使用下面关键字：\r\n\r\nall：表示子查询语句返回的所有记录。\r\nany：表示子查询语句返回的任意一条结果。\r\nsome：与”any”等价。\r\nin：与”=any”等价。\r\nexists：表示子查询语句至少返回一条记录。\r\n\r\n如果在子查询中操作集合，HQL提供了一组操纵集合的函数和属性：\r\nsize()函数和size属性：获得集合中元素的数量。\r\nminIndex()函数和minIndex属性：对于建立了索引的集合获得最小索引值（关于集合索引参考第一部分映射值类型集合）。\r\nminElement()函数和minElement属性：对于包含基本类型的元素集合，获得集合中值最小的元素。\r\nmaxElement()函数和maxElement属性：对于包含基本类型元素的集合，获得集合中值最大的元素。\r\nelement()函数：获得集合中所有元素。\r\n更新和删除\r\n更新：执行删除操作调用Query接口的executeUpate()方法，然后提交事务\r\nHQL：Delete from Student where id = 10\r\n删除：执行删除操作调用Query接口的executeUpate()方法，然后提交事务\r\nHQL：update Student set age = 20,name=‘李四’ where id = 20\r\nSQL查询\r\nHibernate还支持使用原生SQL查询，使用原生SQL查询可以利用某些数据库的特性，或者需要将原有JDBC应用迁移到Hibernate应用上，也可能需要使用原生SQL查询。类似于HQL查询，原生SQL查询也支持将SQL语句放在配置文件中配置，从而提高程序的解耦。命名SQL查询还可以用于调用存储过程。\r\nSQL查询是通过SQLQuery接口来表示的，SQLQuery 接口是Query\r\n接口的子接口，因此完全可以调用Query 接口的方法：\r\n\r\nlist()：获取记录集。\r\nuniqueResult()：返回唯一记录。\r\naddEntity()：将查询到的数据封装为特定的实体。\r\nsetFirstResult()：设置结果集的起点。\r\nsetMaxResults()：设置获取记录的最大条数。\r\naddScalarˈskeɪlə ()：将查询的记录关联成标量值。\r\n\r\n执行SQL查询的步骤：\r\n\r\n获取Session对象。\r\n编写SQL语句。\r\n以SQL语句作为参数，调用Session的createSQLQuery()方法创建查询对象。\r\n调用SQLQuery对象的addScalar()或addEntity()方法将选出的结果与标量值或实体进行关联。\r\n如果SQL语句包含参数，则调用Query的setXxx()方法为参数赋值。\r\n调用Query的list()方法或uniqueResult()方法返回查询的结果集。\r\n\r\n标量查询\r\n最基本的SQL查询就是获得一个标量（数值）列表。\r\n标量查询（Scalar\r\nQuery）是指直接返回数据库列值（而非实体对象）的查询方式。\r\nsession.createSQLQuery(&quot;select * from student&quot;).list();\r\n默认情况下，查询语句将返回由Object数组组成的List，数据的每个元素时student表的列值，Hibernate会通过ResultSetMetadata来判定所返回数据列的实际顺序和类型。如果select后面只有一个字段，那么返回的List集合元素就不是数组，而只是单个的变量值。\r\n当执行 SQL 查询且未指定返回类型时，Hibernate 默认返回\r\nList，每个数组元素对应数据库的一列：\r\n// 默认行为：返回 Object [] 列表SQLQuery query = session.createSQLQuery(&quot;SELECT id, name, age FROM student&quot;);List&lt;Object[]&gt; results = query.list();// 遍历结果for (Object[] row : results) &#123;    Long id = (Long) row[0];       // 第一列    String name = (String) row[1]; // 第二列    Integer age = (Integer) row[2]; // 第三列    // 处理数据&#125;\r\n如果 SQL 中只选择一个字段，Hibernate 会直接返回\r\nList&lt;列类型&gt;：\r\nSQLQuery query = session.createSQLQuery(&quot;SELECT name FROM student&quot;);List&lt;String&gt; names = query.list(); // 直接返回 String 列表\r\n使用 addScalar() 指定返回类型\r\naddScalar() 方法用于明确指定返回列的类型，避免 Hibernate\r\n通过 ResultSetMetadata\r\n动态推断类型，从而提高性能，因此建议为这些数据列指定更明确的返回值类型。明确指定返回值类型通过addScalar()方法实现。addScalar()主要有两个作用：\r\n\r\n指定查询结果包含那些数据列——没有被addScalar()选出的列将不会包含在查询结果里面中。\r\n指定查询结果中数据列的数据类型。\r\n\r\nSQLQuery query = session.createSQLQuery(&quot;SELECT id, name, age FROM student&quot;);query.addScalar(&quot;id&quot;, StandardBasicTypes.LONG)    // 指定 id 为 Long 类型     .addScalar(&quot;name&quot;, StandardBasicTypes.STRING) // 指定 name 为 String 类型     .addScalar(&quot;age&quot;, StandardBasicTypes.INTEGER); // 指定 age 为 Integer 类型List&lt;Object[]&gt; results = query.list();\r\n此时Hibernate不再需要使用ResultSetMetadata来获取信息，而是直接从ResultSet中取出name列的值，并把name列的数据类型当成字符串处理。因此，即使使用了“*”作为查询的字段列表，但Hibernate查询的结果也只是name字段所组成的表。\r\n在原生SQL查询里，程序指定的原生SQL语句时标准的SQL语句，因此SQL语句中使用的就是数据表、数据列等对象，而不是持久化类、属性。\r\n实体查询\r\n前面的标量值查询只是返回一些标量的结果集，这种查询方式与使用JDBC查询的效果基本类似。查询返回多个记录行，每个记录对应一个列表的元素，每个列表元素是一个数组，每个数组元素对应当前行、当前列的值。\r\n如果查询返回了某个数据表的全部数据列，且该数据表有对应的持久化类映射，接下来就可把查询结果转换成实体。将查询结果转换成实体，可以使用SQLQuery提供的多个重载addEntity()方法。\r\n使用 addEntity(Class entityClass)\r\n方法将查询结果映射为实体\r\nList list = session.createSQLQuery(&quot;select * from animal&quot;)            .addEntity(Animal.class)            .list();\r\n注意事项：\r\n\r\n必须查询所有列：SQL\r\n中需包含实体类映射的所有字段（通常用 SELECT *）。\r\n外键列必须存在：若实体包含 @ManyToOne\r\n等关联，SQL 必须返回对应的外键列（如 owner_id）。\r\n列名与属性名需匹配：默认情况下，数据库列名需与实体属性名一致（或通过\r\n@Column 注解映射）。\r\n\r\n在原生SQL中一样支持使用参数，这些参数既可以使用问号+索引的占位符参数（?N），也可以使用名字参数。\r\n\r\n不仅如此，如果在SQL语句中显式使用了多表连接，则SQL语句可以选出多个数据表的数据。Hibernate还支持将查询结果转换成多个实体。如果要将查询结果转换成多个实体，则SQL字符串中应为不同数据表指定不同的别名，并调用addEntity(String\r\nalias,Class entityClass)方法将不同的数据表转换成不同实体。\r\n当 SQL 中使用列别名时，需通过 @Column 注解或\r\nResultTransformer 显式映射：\r\n// SQL 使用别名SQLQuery query = session.createSQLQuery(&quot;SELECT id AS animal_id, name FROM animal&quot;);// 方法一：在实体类的属性上添加 @Column 注解@Column(name = &quot;animal_id&quot;)private Long id;// 方法二：使用 ResultTransformerquery.setResultTransformer(Transformers.aliasToBean(Animal.class));\r\n不仅如此，Hibernate还可以将查询结果转换成非持久化实体（即普通的JavaBean），只要该JavaBean为这些数据提供了对应的setter和getter方法即可。Query接口提供了一个setResulltTransformer()方法，该方法可接受一个Transformers对象，通过使用该对象即可把查询到的结果集转换成JavaBean集。\r\n使用 Transformers.aliasToBean(Class) 将结果映射到普通\r\nJavaBean：\r\n// 创建 JavaBeanpublic class AnimalDTO &#123;    private Long id;    private String name;    private String ownerName;    // getter/setter 方法&#125;\r\nString sql = &quot;SELECT a.id, a.name, o.name AS ownerName &quot; +             &quot;FROM animal a JOIN owner o ON a.owner_id = o.id&quot;;SQLQuery query = session.createSQLQuery(sql);query.setResultTransformer(Transformers.aliasToBean(AnimalDTO.class));List&lt;AnimalDTO&gt; dtos = query.list();\r\n\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Intellij IDEA常用快捷键","url":"/posts/61684.html","content":"IDEA 中一些最常用的快捷键\r\nIDEA\r\n中提供了很多快捷键，点击File --&gt; Settings --&gt; keymap便可进入看到\r\nIDEA 提供的快捷键。我们也可以搜索和自定义所有快捷键，下面给出的是 IDEA\r\n中默认的快捷键；\r\nIDEA 官方文档\r\nhttps://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html\r\n代码编辑\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n快捷键 (Windows/Linux)\r\n快捷键 (Mac)\r\n\r\n\r\n\r\n\r\n删除当前行\r\nCtrl + Y\r\nCmd + Backspace\r\n\r\n\r\n复制当前行\r\nCtrl + D\r\nCmd + D\r\n\r\n\r\n注释/取消注释\r\nCtrl + /\r\nCmd + /\r\n\r\n\r\n多行注释\r\nCtrl + Shift + /\r\nCmd + Shift + /\r\n\r\n\r\n格式化代码\r\nCtrl + Alt + L\r\nCmd + Option + L\r\n\r\n\r\n自动补全代码\r\nCtrl + Space\r\nCtrl + Space\r\n\r\n\r\n快速修复错误\r\nAlt + Enter\r\nOption + Enter\r\n\r\n\r\n生成代码（Getter/Setter等）\r\nAlt + Insert\r\nCmd + N\r\n\r\n\r\n\r\n导航与查找\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n快捷键 (Windows/Linux)\r\n快捷键 (Mac)\r\n\r\n\r\n\r\n\r\n查找类\r\nCtrl + N\r\nCmd + O\r\n\r\n\r\n查找文件\r\nCtrl + Shift + N\r\nCmd + Shift + O\r\n\r\n\r\n全局搜索\r\nDouble Shift\r\nDouble Shift\r\n\r\n\r\n查找方法调用\r\nCtrl + Alt + H\r\nCtrl + Option + H\r\n\r\n\r\n跳转到定义\r\nCtrl + B / Ctrl + 左键\r\nCmd + B / Cmd + 左键\r\n\r\n\r\n返回上一次编辑位置\r\nCtrl + Alt + ←\r\nCmd + Option + ←\r\n\r\n\r\n\r\n重构\r\n\r\n\r\n\r\n功能\r\n快捷键 (Windows/Linux)\r\n快捷键 (Mac)\r\n\r\n\r\n\r\n\r\n重命名\r\nShift + F6\r\nShift + F6\r\n\r\n\r\n提取方法\r\nCtrl + Alt + M\r\nCmd + Option + M\r\n\r\n\r\n提取变量\r\nCtrl + Alt + V\r\nCmd + Option + V\r\n\r\n\r\n内联变量/方法\r\nCtrl + Alt + N\r\nCmd + Option + N\r\n\r\n\r\n\r\n\r\n将光标放在程序的某个变量上，可以看到该变量最新的数据。\r\n可以在 debug 过程中，动态地标记断点。\r\n\r\n调试\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n快捷键 (Windows/Linux)\r\n快捷键 (Mac)\r\n\r\n\r\n\r\n\r\n开始调试\r\nShift + F9\r\nCtrl + D\r\n\r\n\r\n单步执行（Step Over）\r\nF8\r\nF8\r\n\r\n\r\n进入方法（Step Into）\r\nF7\r\nF7\r\n\r\n\r\n继续执行（Resume）\r\nF9\r\nCmd + Option + R\r\n\r\n\r\n查看变量值\r\nAlt + F8\r\nOption + F8\r\n\r\n\r\n\r\n其他\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n快捷键 (Windows/Linux)\r\n快捷键 (Mac)\r\n\r\n\r\n\r\n\r\n快速生成 main 方法\r\n在一个类中输入 psvm 或者 main ，IDEA\r\n会自动生成主方法 main psvm + Tab\r\nmain + Tab\r\n\r\n\r\n快速生成 System.out.println()\r\n在任意方法中输入sout，IDEA 会自动生成打印语句\r\nsout + Tab\r\nsout + Tab\r\n\r\n\r\n快速生成 for 循环\r\n在任意方法中输入fori ，IDEA 会自动生成一个普通的 for\r\n循环体；fori + Tab\r\nfori + Tab\r\n\r\n\r\n优化导入\r\nCtrl + Alt + O\r\nCmd + Option + O\r\n\r\n\r\n查看最近文件\r\nCtrl + E\r\nCmd + E\r\n\r\n\r\n自动分配变量名\r\n在新建对象时在后面加.var\r\n\r\n\r\n\r\n\r\n自定义模板\r\n进入live template\r\n界面，还可以自定义模板，设置你自己喜欢的快捷键，可以使开发更加高效；\r\n按照键位分配\r\n\r\n引用自\r\nhttps://blog.csdn.net/qq_59961910/article/details/139085535\r\n\r\nCtrl + … 快捷键\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\n删除当前行\r\nCtrl + Y\r\n\r\n\r\n复制当前行，直接在下一行复制出当前行\r\nCtrl + D\r\n\r\n\r\n选中文本，连续按可扩大选中范围（以单词为单位）\r\nCtrl + W\r\n\r\n\r\n在当前行上方插入一行空行（需在行首使用）\r\nCtrl + Enter\r\n\r\n\r\n删除单词（一次删除整个单词）\r\nCtrl + Backspace\r\n\r\n\r\n展开 / 折叠当前方法块代码\r\nCtrl + “+”/“-”\r\n\r\n\r\n添加 / 取消单行注释（切换注释状态）\r\nCtrl + /\r\n\r\n\r\n添加 / 取消多行注释（切换注释状态）\r\nCtrl + Shift + /\r\n\r\n\r\n在当前文件中查找文本\r\nCtrl + F\r\n\r\n\r\n查找并替换文本（支持多行、代码 / 注释过滤、正则）\r\nCtrl + R\r\n\r\n\r\n查找最近打开的文件\r\nCtrl + E\r\n\r\n\r\n快速重写基类或接口中的方法\r\nCtrl + O\r\n\r\n\r\n代码提示（输入时提示关键字）\r\nCtrl + 空格\r\n\r\n\r\n代码模板提示（输入时提示快捷键）\r\nCtrl + J\r\n\r\n\r\n显示类结构图（类的继承层次）\r\nCtrl + H\r\n\r\n\r\n快速定位到指定行指定列\r\nCtrl + G\r\n\r\n\r\n快速定位到代码块开始位置\r\nCtrl + [\r\n\r\n\r\n快速定位到代码块结束位置\r\nCtrl + ]\r\n\r\n\r\n快速搜索和打开类\r\nCtrl + N\r\n\r\n\r\n快速定位源码（光标放在方法上，跳转到方法定义）\r\nCtrl + B\r\n\r\n\r\n快速转到当前类的父类\r\nCtrl + U\r\n\r\n\r\n\r\nAlt + … 快捷键\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\n快速补全代码\r\nAlt + /\r\n\r\n\r\n显示当前方法的声明\r\nAlt + Q\r\n\r\n\r\n快速提示完成（自动修正语法错误，功能强大，最常使用）\r\nAlt + Enter\r\n\r\n\r\n快速生成构造器、Getter/Setter 等方法（最常使用）\r\nAlt + Insert\r\n\r\n\r\n快速打开或隐藏 Project 面板\r\nAlt + 1\r\n\r\n\r\n快速显示类结构（显示类中所有属性和方法）\r\nAlt + 7\r\n\r\n\r\n快速切换代码视图\r\nAlt + ← / →\r\n\r\n\r\n在方法间快速移动定位（光标以方法为单位移动）\r\nAlt + ↑ / ↓\r\n\r\n\r\n\r\nShift + … 快捷键\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\n在当前行下方生成空行，光标自动移到空行行首\r\nShift + Enter\r\n\r\n\r\n快速定位高亮错误或警告位置\r\nF2 / Shift + F2\r\n\r\n\r\n批量修改变量名（先选中变量名，再执行快捷键）\r\nShift + F6\r\n\r\n\r\n\r\nCtrl + Alt + … 快捷键\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\n快速格式化代码\r\nCtrl + Alt + L\r\n\r\n\r\n自动缩进行\r\nCtrl + Alt + I\r\n\r\n\r\n优化导入的类和包（移除未使用的导入，合并重复导入）\r\nCtrl + Alt + O\r\n\r\n\r\n将选中代码用 if、while、try/catch 等代码块包装（功能强大）\r\nCtrl + Alt + T\r\n\r\n\r\n查找类 / 接口的实现类（若唯一则直接进入实现类）\r\nCtrl + Alt + B\r\n\r\n\r\n\r\nCtrl + Shift + … 快捷键\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\n去除代码块包装（与 Ctrl + Alt + T 反向操作）\r\nCtrl + Shift + Delete\r\n\r\n\r\n将光标所在代码块向上 / 下整体移动\r\nCtrl + Shift + ↑ / ↓\r\n\r\n\r\n快速运行当前程序（在哪个程序文件中执行，就运行该程序）\r\nCtrl + Shift + F10\r\n\r\n\r\n添加 / 取消多行注释（切换注释状态，第一次添加，第二次取消）\r\nCtrl + Shift + /\r\n\r\n\r\n合并两行代码（将光标所在行与下一行合并成一行）\r\nCtrl + Shift + J\r\n\r\n\r\n\r\n","categories":["实用","介绍说明"],"tags":["实用知识","常用知识","其他"]},{"title":"Hibernate,JPA 和 Spring Data JPA 之间的关系","url":"/posts/47644.html","content":"Hibernate， JPA 和 Spring Data\r\nJPA\r\n我们都知道Java 持久层框架访问数据库的方式大致分为两种。\r\n\r\n一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。\r\n另一种是以 Java\r\n实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的\r\nORM框架，如：Hibernate、Spring Data JPA。\r\n\r\nJPA\r\nJPA的全称是Java Persistence API，\r\n即Java持久化API，是SUN公司推出的一套基于ORM的规范。\r\n它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。\r\nJava在操作数据库的时候，底层使用的其实是JDBC，而JDBC是一组操作不同数据库的规范。我们的Java应用程序，只需要调用JDBC提供的API就可以访问数据库了，而JPA也是类似的道理。\r\nJPA统一了Java应用程序访问ORM框架的规范\r\nJPA为我们提供了以下规范：\r\n\r\nORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中\r\nJPA\r\n的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了\r\nJPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。\r\n\r\nHibernate\r\nHibernate是一个JPA规范的具体实现，是ORM类型的框架，对象映射模型。\r\nHibernate是Java中的对象关系映射解决方案。对象关系映射或ORM框架是将应用程序数据模型对象映射到关系数据库表的技术。Hibernate\r\n不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL\r\n数据类型的映射。\r\nHibernate 可以自动生成 SQL 语句，自动执行\r\n关系\r\nJPA规范本质上就是一种ORM规范，不是ORM框架，因为JPA并未提供ORM实现,JPA仅仅定义了一些接口\r\nHibernate除了作为ORM框架之外，它也是一种JPA实现。\r\nSpring Data\r\nSpring Data是Spring\r\n社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。\r\n它提供很多模板操作\r\n\r\nSpring Data Elasticsearch\r\nSpring Data MongoDB\r\nSpring Data Redis\r\nSpring Data Solr\r\n强大的 Repository，和定制的数据储存对象的抽象映射\r\n对数据访问对象的支持\r\n\r\nSpring Data JPA\r\n接口的再次封装抽象更多的可用接口\r\nSpring Data\r\nJPA是在JPA规范下提供了Repository层的再次封装，提供了更多可用的接口，然后底层通过Hibernate实现。\r\nJPA是一种规范，Hibernate是一个实现了JPA规范的框架，Spring Data\r\nJPA是对JPA简化操作的实现，实现了更多可用的接口，底层具体实现用了Hibernate。\r\nSpring Data JPA给我们提供的主要的类和接口\r\nRepository 接口：\r\n\r\nRepository\r\nCrudRepository\r\nJpaRepository\r\n\r\nRepository 实现类：\r\n\r\nSimpleJpaRepository\r\nQueryDslJpaRepository\r\n\r\n以上这些类和接口就是我们以后在使用Spring Data\r\nJPA的时候需要掌握的。\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识","Spring Data JPA"]},{"title":"JSON之基础部分与语法","url":"/posts/18280.html","content":"JSON基础部分\r\n什么是JSON\r\nJavaScript 对象表示法（JSON）是用于将结构化数据表示为 JavaScript\r\n对象的标准格式，通常用于在网站上表示和传输数据（例如从服务器向客户端发送一些数据，因此可以将其显示在网页上）\r\nJSON: JavaScript\r\nObject Notation(JavaScript\r\n对象表示法)\r\nJSON 是存储和交换文本信息的语法，类似 XML。\r\nJSON 比 XML 更小、更快，更易解析。\r\nJSON 是轻量级的文本数据交换格式\r\nJSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON\r\n仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。\r\n目前非常多的动态（PHP，JSP，.NET）编程语言都支持 JSON\r\nJSON 具有自我描述性，更易理解\r\nJSON 文本格式在语法上与创建 JavaScript 对象的代码相同。\r\nJSON 可以作为一个对象或者字符串存在，前者用于解读 JSON\r\n中的数据，后者用于通过网络传输 JSON 数据\r\n\r\n将字符串转换为原生对象称为反序列化（deserialization），而将原生对象转换为可以通过网络传输的字符串称为序列化（serialization）。\r\n\r\n由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval()\r\n函数，用 JSON 数据来生成原生的 JavaScript 对象。\r\n\r\nJSON 格式化工具：https://www.jyshare.com/front-end/53/\r\nJSON 转义/去除转义：https://www.jyshare.com/front-end/7683/\r\nJSON 在线解析工具：https://www.jyshare.com/front-end/7438/\r\nJSON 差异对比工具：https://www.jyshare.com/front-end/9557/\r\n\r\n\r\nJSON语法与结构\r\nJSON 语法是 JavaScript\r\n语法的子集\r\n\r\n数据在名称/值对中\r\n数据由逗号 , 分隔\r\n使用斜杆  来转义字符\r\n大括号 {} 保存对象\r\n中括号 [] 保存数组，数组可以包含多个对象\r\n\r\nJSON的两种结构：\r\nJSON 是一个字符串，其格式非常类似于 JavaScript\r\n对象字面量的格式。你可以在 JSON 中包含与标准 JavaScript\r\n对象相同的基本数据类型——字符串、数字、数组、布尔值和其他对象字面量。这使你可以构建一个数据层次结构，如下所示：\r\n&#123;  &quot;squadName&quot;: &quot;Super hero squad&quot;,  &quot;homeTown&quot;: &quot;Metro City&quot;,  &quot;formed&quot;: 2016,  &quot;secretBase&quot;: &quot;Super tower&quot;,  &quot;active&quot;: true,  &quot;members&quot;: [    &#123;      &quot;name&quot;: &quot;Molecule Man&quot;,      &quot;age&quot;: 29,      &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;,      &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;Madame Uppercut&quot;,      &quot;age&quot;: 39,      &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;,      &quot;powers&quot;: [        &quot;Million tonne punch&quot;,        &quot;Damage resistance&quot;,        &quot;Superhuman reflexes&quot;      ]    &#125;,    &#123;      &quot;name&quot;: &quot;Eternal Flame&quot;,      &quot;age&quot;: 1000000,      &quot;secretIdentity&quot;: &quot;Unknown&quot;,      &quot;powers&quot;: [        &quot;Immortality&quot;,        &quot;Heat Immunity&quot;,        &quot;Inferno&quot;,        &quot;Teleportation&quot;,        &quot;Interdimensional travel&quot;      ]    &#125;  ]&#125;\r\n\r\n对象：大括号\r\n&#123;&#125;保存的对象是一个无序的名称/值对集合。一个对象以左括号&#123;开始，\r\n右括号&#125;结束。每个”键”后跟一个冒号\r\n:，名称/值对使用逗号,分隔。\r\n数组：中括号[]保存的数组是值（value）的有序集合。一个数组以左中括号[开始，\r\n右中括号]结束，值之间使用逗号,分隔。\r\n\r\n值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、\r\nnull、对象（object）或者数组（array），它们是可以嵌套。\r\n\r\n\r\nJSON名称 / 键值对\r\nJSON 数据的书写格式是：\r\nkey : value\r\n名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：\r\n&quot;name&quot; : &quot;ErgouTree&quot;\r\n这很容易理解，等价于这条 JavaScript 语句：\r\nname = &quot;ErgouTree&quot;\r\nJSON 值可以是：\r\n\r\n数字（整数或浮点数）\r\n字符串（在双引号中）\r\n逻辑值（true 或 false）\r\n数组（在中括号中）\r\n对象（在大括号中）\r\nnull\r\n\r\nJSON 对象\r\n对象语法\r\nJSON 对象在大括号 {} 中书写，对象可以包含多个名称/值对：\r\n&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;\r\nkey 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字,\r\n对象, 数组, 布尔值或 null）。\r\nkey 和 value 中使用冒号 : 分割。\r\n每个 key/value 对使用逗号 , 分割。\r\n访问对象值\r\n你可以使用 点号. 和\r\n中括号[]来访问对象的值：\r\nvar myObj, x;myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;x = myObj[&quot;name&quot;];x = myObj.name;\r\n循环对象\r\n你可以使用 for-in 来循环对象的属性：\r\nvar myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;for (x in myObj) &#123;    document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125;\r\n嵌套JSON对象\r\nJSON 对象中可以包含另外一个 JSON 对象：\r\nmyObj = &#123;    &quot;name&quot;:&quot;runoob&quot;,    &quot;alexa&quot;:10000,    &quot;sites&quot;: &#123;        &quot;site1&quot;:&quot;www.runoob.com&quot;,        &quot;site2&quot;:&quot;m.runoob.com&quot;,        &quot;site3&quot;:&quot;c.runoob.com&quot;    &#125;&#125;\r\n你可以使用点号 .或者中括号[...]来访问嵌套的\r\nJSON 对象。\r\nx = myObj.sites.site1;// 或者x = myObj.sites[&quot;site1&quot;];\r\n修改值\r\n你可以使用点号 . 或中括号\r\n[]来通过赋值的方式修改 JSON 对象的值\r\nmyObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;;\r\n删除对象属性\r\n我们可以使用 delete 关键字来删除 JSON\r\n对象的属性：\r\ndelete myObj.sites.site1;delete myObj.sites[&quot;site2&quot;]\r\nJSON数组\r\n数组作为 JSON 对象\r\nJSON 数组在中括号中书写。\r\n中括号 [] 保存的数组是值（value）的有序集合，值之间使用逗号 ,\r\n分隔。\r\nJavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript\r\n的表达式，包括函数，日期，及 undefined。\r\n对象属性的值可以是一个数组\r\n&#123;&quot;name&quot;:&quot;网站&quot;,&quot;num&quot;:3,&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]&#125;// 访问x = myObj.sites[0];\r\n循环数组也可以使用，类似于 js 和 java的增强 for 循环\r\n修改和删除和对象一样\r\nmyObj.sites[1] = &quot;Github&quot;;delete myObj.sites[1];\r\nJSON.parse()\r\nJSON 通常用于与服务端交换数据。\r\n在接收服务器数据时一般是字符串。\r\n我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。\r\nJSON.parse(text[, reviver])\r\n参数说明：\r\n\r\ntext:必需， 一个有效的 JSON 字符串。\r\nreviver: 可选，一个转换结果的函数，\r\n将为对象的每个成员调用此函数。\r\n\r\nJSON解析实例\r\n例如我们从服务器接收了以下数据：\r\n&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;\r\n我们使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript\r\n对象：\r\nvar obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);\r\n解析完成后，我们就可以在网页上使用 JSON 数据了：\r\n&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt;var obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;：&quot; + obj.site;&lt;/script&gt;\r\n从服务端接收 JSON 数据\r\n我们可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript\r\n对象。\r\nvar xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123;    if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;        myObj = JSON.parse(this.responseText);        document.getElementById(&quot;demo&quot;).innerHTML = myObj.name;    &#125;&#125;;xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/json_demo.txt&quot;, true);xmlhttp.send();\r\n如果从服务端接收的是数组的 JSON 数据，则 JSON.parse 会将其转换为\r\nJavaScript 数组：\r\n异常解析\r\nJSON 不能存储 Date 对象。\r\n如果你需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为\r\nDate 对象。\r\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期: &quot; + obj.initDate;\r\n我们可以启用 JSON.parse 的第二个参数\r\nreviver，一个转换结果的函数，对象的每个成员调用此函数。\r\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text, function (key, value) &#123;    if (key == &quot;initDate&quot;) &#123;        return new Date(value);    &#125; else &#123;        return value;&#125;&#125;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期：&quot; + obj.initDate;\r\nJSON\r\n不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。\r\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:&quot;function () &#123;return 10000;&#125;&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.alexa = eval(&quot;(&quot; + obj.alexa + &quot;)&quot;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot; Alexa 排名：&quot; + obj.alexa();\r\nJSON.stringify()\r\nJSON 通常用于与服务端交换数据。\r\n在向服务器发送数据时一般是字符串。\r\n我们可以使用 JSON.stringify() 方法将 JavaScript\r\n对象转换为字符串。\r\n语法\r\nJSON.stringify(value[, replacer[, space]])\r\n参数说明：\r\n\r\nvalue:\r\n必需， 要转换的 JavaScript 值（通常为对象或数组）。\r\nreplacer:\r\n可选。用于转换结果的函数或数组。\r\n如果 replacer 为函数，则 JSON.stringify\r\n将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回\r\nundefined，则排除成员。根对象的键是一个空字符串：““。\r\n如果 replacer\r\n是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当\r\nvalue 参数也为数组时，将忽略 replacer 数组。\r\nspace:\r\n可选，文本添加缩进、空格和换行符，如果 space\r\n是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于\r\n10，则文本缩进 10 个空格。space 也可以使用非数字，如：\r\n\r\nJavaScipt对象转换\r\n例如我们向服务器发送以下数据：\r\nvar obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;\r\n使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：\r\nvar myJSON = JSON.stringify(obj);\r\n可以将 myJSON 发送到服务器：\r\nvar obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\n数组转换和对象转换差不多\r\nvar arr = [ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Facebook&quot; ];var myJSON = JSON.stringify(arr);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\n异常解析\r\nJSON 不能存储 Date 对象。\r\nJSON.stringify() 会将所有日期转换为字符串。\r\nJSON 不允许包含函数，JSON.stringify() 会删除 JavaScript\r\n对象的函数，包括 key 和 value。\r\nvar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\n我们可以在执行 JSON.stringify()\r\n函数前将函数转换为字符串来避免以上问题的发生：\r\nvar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\nJSON使用\r\n把 JSON 文本转换为\r\nJavaScript 对象\r\nJSON 最常见的用法之一，是从 web 服务器上读取 JSON\r\n数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript\r\n对象，然后在网页中使用该数据。\r\n实例：\r\n创建包含 JSON 语法的 JavaScript 字符串\r\nvar txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;;\r\n由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval()\r\n可用于将 JSON 文本转换为 JavaScript 对象。\r\neval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成\r\nJavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：\r\nvar txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;; var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); document.getElementById(&quot;name&quot;).innerHTML=obj.sites[0].name document.getElementById(&quot;url&quot;).innerHTML=obj.sites[0].url\r\n一些注意事项\r\n\r\nJSON 是一种纯数据格式，它只包含属性，没有方法。\r\nJSON 要求在字符串和属性名称周围使用双引号。单引号无效。\r\n甚至一个错位的逗号或分号就可以导致 JSON\r\n文件出错。你应该小心的检查你想使用的数据（虽然计算机生成的 JSON\r\n很少出错，只要生成程序正常工作）。你可以通过像 JSONLint 这样的应用程序来验证\r\nJSON。\r\nJSON 实际上可以是任何可以有效包含在 JSON\r\n中的数据类型的形式。比如，单个字符串或者数字就是有效的 JSON 对象。\r\n与 JavaScript 代码中对象属性可以不加引号不同，JSON\r\n中只有带引号的字符串可以用作属性。\r\n\r\n","categories":["前端技术","JSON"],"tags":["实用知识","前端技术","JSON","JavaScript","语法知识"]},{"title":"Java16新特性之Text Blocks文本块","url":"/posts/43636.html","content":"Java16中的新特性——文本块\r\n概述\r\nJava 16 于 2021 年 3\r\n月发布，其中包含了一系列新特性和改进。在这些更新中，文本块（Text\r\nBlocks）作为正式特性的正式引入是一项重要的改进，它极大地提高了处理多行字符串的便捷性和可读性。下面将详细介绍\r\nJava 16 中文本块的相关内容。\r\n文本块解决了Java长期以来的一个痛点：处理多行字符串时的繁琐和可读性问题。在文本块出现之前，开发者需要在每行末尾添加换行符(\\n)，使用加号(+)连接字符串，或者利用反斜杠（\\）来延续字符串并处理大量转义字符，这导致代码难以阅读和维护。\r\n文本块的引入不仅简化了多行字符串的表示，还显著提升了代码可读性，特别在处理HTML、JSON、SQL等结构化文本时效果尤为明显。这项特性最初在Java\r\n13和14中作为预览功能推出，经过社区反馈和改进后，终于在Java\r\n16中成为正式特性。\r\n文本块的语法\r\n文本块使用三个双引号（\"\"\"）作为界定符，中间可以直接包含多行文本。其语法格式如下：\r\nString text = &quot;&quot;&quot;              这是一个文本块示例。              它可以包含多行文本，              无需在每行末尾添加换行符。              &quot;&quot;&quot;;\r\n文本块的设计遵循以下核心原则：\r\n\r\n提高可读性：消除多行字符串中的转义字符和连接符\r\n保留格式：保持文本的原始缩进和换行结构\r\n简化开发：减少处理结构化文本（JSON/XML/SQL）的认知负担\r\n兼容性：确保与现有字符串类型完全兼容\r\n\r\n与传统字符串的比较\r\n下面通过一个对比示例，来看一下文本块与传统字符串在处理多行文本时的差异。\r\n传统方式处理JSON：\r\nString json = &quot;&#123;\\n&quot; +              &quot;    \\&quot;name\\&quot;: \\&quot;John\\&quot;,\\n&quot; +              &quot;    \\&quot;age\\&quot;: 30,\\n&quot; +              &quot;    \\&quot;address\\&quot;: &#123;\\n&quot; +              &quot;        \\&quot;street\\&quot;: \\&quot;123 Main St\\&quot;,\\n&quot; +              &quot;        \\&quot;city\\&quot;: \\&quot;New York\\&quot;\\n&quot; +              &quot;    &#125;\\n&quot; +              &quot;&#125;&quot;;\r\n使用文本块方式：\r\nString json = &quot;&quot;&quot;              &#123;                  &quot;name&quot;: &quot;John&quot;,                  &quot;age&quot;: 30,                  &quot;address&quot;: &#123;                      &quot;street&quot;: &quot;123 Main St&quot;,                      &quot;city&quot;: &quot;New York&quot;                  &#125;              &#125;              &quot;&quot;&quot;;\r\n可以明显看出，使用文本块后，代码更加简洁易读。\r\n文本块的优势\r\n\r\n提升可读性：文本块无需在每行添加换行符和连接符号，使代码结构更加清晰，更易于阅读和理解。\r\n减少转义字符的使用：在文本块中，一些常见的转义字符可以直接使用，无需额外转义，例如双引号（\"）。\r\n保留格式：文本块会保留文本的原始格式，包括缩进和换行，这在处理\r\nHTML、JSON、SQL 等格式的文本时非常有用。\r\n\r\n其中的使用细节和高级特性\r\n\r\n缩进处理\r\n文本块会自动处理缩进，以保证代码的美观。它会以开始标记后的第一个非空行为基准，自动调整文本的缩进。例如：\r\nString html = &quot;&quot;&quot;              &lt;html&gt;                  &lt;body&gt;                      &lt;p&gt;Hello, World!&lt;/p&gt;                  &lt;/body&gt;              &lt;/html&gt;              &quot;&quot;&quot;;\r\n在这个例子中，文本块内部的 HTML\r\n代码保持了正确的缩进，而不会在最终的字符串中引入额外的缩进。\r\n增强的转义处理\r\n虽然文本块减少了一些转义字符的使用，但在需要时，仍然可以使用传统的转义字符，如\r\n\\n（换行）、\\t（制表符）等。此外，文本块还引入了两个新的转义序列：\r\n\r\n\\s：表示一个空格。\r\n\\\"\\\"：表示一个双引号，无需像传统字符串那样使用\r\n\\\" 来转义\r\n\r\nString text = &quot;&quot;&quot;              名字: &quot;张三&quot;              特殊字符: \\&quot;&quot;&quot;              保留末尾空格:\\s              &quot;&quot;&quot;;\r\n动态内容嵌入\r\n文本块支持多种动态内容嵌入方式：\r\n文本块可以与其他字符串进行连接，使用加号（+）即可。例如\r\nString name = &quot;Alice&quot;;String message = &quot;&quot;&quot;                 你好，                 &quot;&quot;&quot; + name + &quot;&quot;&quot;                 ! 欢迎使用文本块。                 &quot;&quot;&quot;;\r\n也可以使用格式化方法\r\n对于动态内容，优先使用formatted()而非字符串连接\r\nString item = &quot;笔记本&quot;;int quantity = 3;String order = &quot;&quot;&quot;               订单明细:                 - 商品: %s                 - 数量: %d               &quot;&quot;&quot;.formatted(item, quantity);\r\n空行与空白处理\r\n\r\n开头的空行会被忽略\r\n末尾空行会被包含\r\n行尾空白默认被移除（使用\\s保留）\r\nString example = &quot;&quot;&quot;                                  第一行（前面有空行）                 第二行（后面有空格）\\s                                  &quot;&quot;&quot;;\r\n\r\n包含转义字符的文本块\r\n内部包含转义字符的文本块很特殊，下面一个示例看一下\r\nString text = &quot;&quot;&quot;              这是一个包含转义字符的文本块示例：              - 换行符：\\n              - 制表符：\\t              - 双引号：\\&quot;\\&quot;              - 反斜杠：\\\\              &quot;&quot;&quot;;System.out.println(text);\r\n在这个示例中，我们展示了如何在文本块中使用各种转义字符。需要注意的是，双引号（\"）在文本块中无需转义，除非需要表示连续的三个双引号（\"\"\"），此时应使用\r\n\\\"\\\"。\r\n性能考量\r\n文本块在编译时被处理为普通字符串，因此运行时性能与传统字符串完全相同。编译器会将文本块转换为常规字符串，移除公共缩进并处理转义序列，不会增加运行时开销。但是还是要避免大文本块，超过64KB的文本块会影响编译器性能\r\n\r\n文本块的 API 支持\r\nJava 16 还为文本块提供了一些新的 API\r\n方法，这些方法可以帮助开发人员更好地处理和转换文本块。\r\n\r\nstripIndent() 方法\r\n该方法用于移除文本块中每一行的公共前导空格，从而保留文本的相对缩进。\r\nString indentedText = &quot;&quot;&quot;                      这是一个有缩进的文本块。                          这一行有额外的缩进。                      这一行回到了原来的缩进级别。                      &quot;&quot;&quot;;String strippedText = indentedText.stripIndent();System.out.println(strippedText);\r\ntranslateEscapes() 方法\r\n该方法用于解析文本块中的转义序列，将其转换为对应的字符。\r\nString escapedText = &quot;&quot;&quot;                     这是一个包含转义字符的文本：                     换行符：\\\\n                     制表符：\\\\t                     &quot;&quot;&quot;;String translatedText = escapedText.translateEscapes();System.out.println(translatedText);\r\nformatted() 方法\r\n该方法用于格式化文本块，类似于 String.format()\r\n方法。\r\nString name = &quot;Bob&quot;;int age = 35;String message = &quot;&quot;&quot;                 你好，%s！                 你今年 %d 岁了。                 &quot;&quot;&quot;.formatted(name, age);System.out.println(message);\r\n\r\n实际应用场景\r\n1. JSON/XML处理\r\nString productJson = &quot;&quot;&quot;                    &#123;                        &quot;id&quot;: 101,                        &quot;name&quot;: &quot;无线耳机&quot;,                        &quot;price&quot;: 299.99,                        &quot;inStock&quot;: true                    &#125;                    &quot;&quot;&quot;;\r\n2. SQL查询\r\nString query = &quot;&quot;&quot;               SELECT o.order_id, c.customer_namejava               FROM orders o               JOIN customers c ON o.customer_id = c.customer_id               WHERE o.order_date &gt; &#x27;2023-01-01&#x27;               ORDER BY o.order_date DESC               &quot;&quot;&quot;;\r\n3. HTML模板\r\nString emailTemplate = &quot;&quot;&quot;                      &lt;html&gt;                      &lt;body&gt;                        &lt;h1&gt;尊敬的%s，&lt;/h1&gt;                        &lt;p&gt;您的账户余额为：&lt;strong&gt;¥%.2f&lt;/strong&gt;&lt;/pjava&gt;                        %s                      &lt;/body&gt;                      &lt;/html&gt;                      &quot;&quot;&quot;.formatted(userName, balance, getPromotionSection());\r\n4. 测试数据\r\nString csvData = &quot;&quot;&quot;                 ID,Name,Age,Occupation                 1,张三,28,工程师                 2,李四,32,设计师                 3,王五,25,分析师                 &quot;&quot;&quot;;\r\n","categories":["Java学习","JavaSE","Java新特性"],"tags":["语法知识","学习","JavaSE","语言方面"]},{"title":"Java17新特性之record关键字","url":"/posts/13693.html","content":"Java17 出现的各种新特性\r\n先介绍一下 Java17 都出现了哪些新特性\r\n密封类\r\n密封类(Sealed Classes)\r\n密封类允许你控制哪些类可以继承或实现某个类或接口，提供了比访问修饰符更精细的继承控制。\r\npublic sealed class Shape permits Circle, Rectangle, Triangle &#123;    // 基类实现&#125;public final class Circle extends Shape &#123;    private final double radius;    // 实现细节&#125;public final class Rectangle extends Shape &#123;    private final double width, height;    // 实现细节&#125;\r\n模式匹配增强\r\n在instanceof中使用模式匹配，减少了类型转换的样板代码：\r\n// Java 17之前if (obj instanceof String) &#123;    String s = (String) obj;    System.out.println(s.length());&#125;// Java 17if (obj instanceof String s) &#123;    System.out.println(s.length());&#125;\r\nSwitch 表达式的进一步完善\r\n对 Switch 表达式的进一步完善\r\n支持更复杂的模式匹配和表达式：\r\nString result = switch (day) &#123;    case MONDAY, FRIDAY, SUNDAY -&gt; &quot;6&quot;;    case TUESDAY -&gt; &quot;7&quot;;    case THURSDAY, SATURDAY -&gt; &quot;8&quot;;    case WEDNESDAY -&gt; &quot;9&quot;;&#125;;\r\n文本块\r\n文本块(Text Blocks) 多行字符串处理变得更加优雅\r\nString json = &quot;&quot;&quot;    &#123;        &quot;name&quot;: &quot;张三&quot;,        &quot;age&quot;: 30,        &quot;city&quot;: &quot;北京&quot;    &#125;    &quot;&quot;&quot;;\r\nRecords类\r\n提供了一种简洁的方式来创建不可变数据载体，类似于 Lombok：\r\npublic record Person(String name, int age, String email) &#123;    // 自动生成构造器、getter、equals、hashCode、toString&#125;// 使用Person person = new Person(&quot;李四&quot;, 25, &quot;lisi@example.com&quot;);System.out.println(person.name()); // 李四\r\n性能和垃圾收集改进\r\nZGC垃圾收集器增强 ZGC在Java\r\n17中得到了显著改进，提供了更低的延迟和更好的性能表现。\r\nG1垃圾收集器优化\r\n并行性能得到提升，减少了停顿时间。\r\nJava17 新特性之 record\r\n记录类\r\n概述\r\n其实 record 记录类是 Java14\r\n就引入的预览特性了，就打算用了，Java16正式发布，并且 Java17\r\n确认为长期支持的版本。record\r\n记录类是Java语言的一个重大特性。它提供了一种简洁的方式来创建不可变的数据载体类。\r\nRecord是一种特殊的类，专门用于存储数据。它自动生成构造器、访问器方法、equals()、hashCode()\r\n和 toString() 方法，大大减少了样板代码。类似于 Lombok\r\n中的各种注解\r\n\r\n\r\nrecord为定义class提供了一种紧凑的语法，被record定义的类是浅不可变数据的透明持有者。\r\n浅不可变数据是指这样的一种类，它们用来描述一种简单的数据结构，这种数据结构的属性都是final不可变的(即状态不可变)。\r\n因为final字段只是不能对变量重复赋值，变量引用的对象本身是有可能可以被修改的，比如这个状态是一个集合的话，向集合中添加/删除元素等操作是可以的。\r\n\r\n\r\n什么是”浅不可变”\r\n“浅不可变”意味着Record的字段引用本身不能改变，但字段所引用的对象内容可能仍然可以被修改。\r\n浅不可变指的是：\r\n\r\nRecord的字段引用是final的，不能重新赋值\r\n但字段所引用的对象内容可能仍然可以被修改，也就是说，若字段引用的对象是集合，那么内容是可以改变的\r\n\r\n这就像一个”只读的指针”，指针本身不能改变指向，但指向的内容可能是可变的。\r\n// 这个Record看起来&quot;不可变&quot;，但实际上有问题public record ShoppingCart(String userId, List&lt;String&gt; items) &#123;&#125;ShoppingCart cart = new ShoppingCart(&quot;user123&quot;, new ArrayList&lt;&gt;());// ❌ 这样做不行 - 字段是final的// cart.items = new ArrayList&lt;&gt;();// ✅ 但这样做可以 - 修改集合内容cart.items().add(&quot;苹果&quot;);cart.items().add(&quot;香蕉&quot;);// 结果：Record的&quot;状态&quot;实际上被改变了！\r\n为什么会这样？\r\nJava的final关键字只保证：\r\n\r\n基本类型：值不能改变（真正不可变）\r\n引用类型：引用不能改变（但引用的对象内容可能可变）\r\n\r\nfinal List&lt;String&gt; list = new ArrayList&lt;&gt;();// list = new ArrayList&lt;&gt;();  // ❌ 不能重新赋值list.add(&quot;item&quot;);             // ✅ 但可以修改内容\r\n一个完整的 Record 类关于浅不可变特性的例子如下\r\nimport java.util.*;import java.time.LocalDate;// 1. 基本数据类型 - 完全不可变public record PersonBasic(String name, int age) &#123;&#125;// 2. 浅不可变的问题示例public record StudentWithGrades(String name, List&lt;Integer&gt; grades) &#123;&#125;// 3. 更复杂的浅不可变示例public record Company(String name, List&lt;String&gt; employees, Map&lt;String, Integer&gt; salaries) &#123;&#125;// 4. 嵌套对象的浅不可变public record Address(String street, String city) &#123;&#125;public record PersonWithAddress(String name, Address address, List&lt;String&gt; hobbies) &#123;&#125;public class RecordImmutabilityDemo &#123;        public static void demonstrateShallowImmutability() &#123;        System.out.println(&quot;=== Record浅不可变特性演示 ===\\n&quot;);                // 1. 基本类型 - 完全不可变        demonstrateBasicImmutability();                // 2. 集合类型 - 浅不可变问题        demonstrateCollectionMutability();                // 3. 嵌套对象 - 浅不可变问题        demonstrateNestedObjectMutability();                // 4. 解决方案        demonstrateSolutions();    &#125;        private static void demonstrateBasicImmutability() &#123;        System.out.println(&quot;1. 基本数据类型的不可变性：&quot;);        PersonBasic person = new PersonBasic(&quot;张三&quot;, 25);                System.out.println(&quot;创建person: &quot; + person);                // 以下操作是不可能的，会编译错误：        // person.name = &quot;李四&quot;;  // 编译错误！字段是final的        // person.age = 30;      // 编译错误！字段是final的                // 只能通过创建新实例来&quot;修改&quot;        PersonBasic newPerson = new PersonBasic(&quot;李四&quot;, 30);        System.out.println(&quot;新person: &quot; + newPerson);        System.out.println(&quot;原person不变: &quot; + person);        System.out.println();    &#125;        private static void demonstrateCollectionMutability() &#123;        System.out.println(&quot;2. 集合字段的浅不可变问题：&quot;);                List&lt;Integer&gt; grades = new ArrayList&lt;&gt;();        grades.add(85);        grades.add(92);        grades.add(78);                StudentWithGrades student = new StudentWithGrades(&quot;王五&quot;, grades);        System.out.println(&quot;创建student: &quot; + student);                // 字段引用不能改变（这会编译错误）：        // student.grades = new ArrayList&lt;&gt;();  // 编译错误！                // 但是可以修改集合的内容！这就是&quot;浅不可变&quot;的问题        student.grades().add(95);  // 添加新成绩        student.grades().set(0, 90);  // 修改第一个成绩                System.out.println(&quot;修改后的student: &quot; + student);        System.out.println(&quot;注意：grades集合的内容被修改了，但引用没变！&quot;);        System.out.println();    &#125;        private static void demonstrateNestedObjectMutability() &#123;        System.out.println(&quot;3. 嵌套对象的浅不可变：&quot;);                Address address = new Address(&quot;中山路123号&quot;, &quot;北京&quot;);        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(Arrays.asList(&quot;读书&quot;, &quot;游泳&quot;));                PersonWithAddress person = new PersonWithAddress(&quot;赵六&quot;, address, hobbies);        System.out.println(&quot;创建person: &quot; + person);                // 不能改变字段引用：        // person.address = new Address(&quot;新地址&quot;, &quot;上海&quot;);  // 编译错误！        // person.hobbies = new ArrayList&lt;&gt;();             // 编译错误！                // 但可以修改集合内容：        person.hobbies().add(&quot;跑步&quot;);        person.hobbies().remove(&quot;读书&quot;);                // Address本身是Record，所以是不可变的        // person.address().street = &quot;新街道&quot;;  // 编译错误！Address字段也是final的                System.out.println(&quot;修改后的person: &quot; + person);        System.out.println(&quot;hobbies被修改了，但address保持不变&quot;);        System.out.println();    &#125;        private static void demonstrateSolutions() &#123;        System.out.println(&quot;4. 实现真正不可变的解决方案：&quot;);                // 方案1：防御性复制        System.out.println(&quot;方案1 - 防御性复制：&quot;);        List&lt;Integer&gt; originalGrades = new ArrayList&lt;&gt;(Arrays.asList(85, 92, 78));        SafeStudent safeStudent = new SafeStudent(&quot;安全学生&quot;, originalGrades);        System.out.println(&quot;创建安全学生: &quot; + safeStudent);                // 尝试修改原始列表        originalGrades.add(100);        System.out.println(&quot;修改原始列表后，安全学生不受影响: &quot; + safeStudent);                // 尝试修改返回的列表        try &#123;            safeStudent.grades().add(95);        &#125; catch (UnsupportedOperationException e) &#123;            System.out.println(&quot;无法修改返回的grades列表（只读）&quot;);        &#125;                System.out.println();                // 方案2：使用不可变集合        System.out.println(&quot;方案2 - 使用不可变集合：&quot;);        ImmutableStudent immutableStudent = new ImmutableStudent(            &quot;不可变学生&quot;,             List.of(85, 92, 78)  // 创建不可变列表        );        System.out.println(&quot;创建不可变学生: &quot; + immutableStudent);                try &#123;            immutableStudent.grades().add(95);        &#125; catch (UnsupportedOperationException e) &#123;            System.out.println(&quot;无法修改不可变列表&quot;);        &#125;    &#125;        public static void main(String[] args) &#123;        demonstrateShallowImmutability();    &#125;&#125;// 解决方案1：防御性复制record SafeStudent(String name, List&lt;Integer&gt; grades) &#123;    // 紧凑构造器中进行防御性复制    public SafeStudent &#123;        grades = new ArrayList&lt;&gt;(grades);  // 创建副本    &#125;        // 访问器也返回只读视图    public List&lt;Integer&gt; grades() &#123;        return Collections.unmodifiableList(grades);    &#125;&#125;// 解决方案2：使用不可变集合record ImmutableStudent(String name, List&lt;Integer&gt; grades) &#123;    public ImmutableStudent &#123;        // 确保传入的是不可变集合        grades = List.copyOf(grades);    &#125;&#125;// 危险的可变Record示例record MutableDataRecord(StringBuilder text, Date date, List&lt;String&gt; items) &#123;    public void demonstrateMutability() &#123;        System.out.println(&quot;=== 可变字段的危险性 ===&quot;);                // 所有这些修改都会影响Record的&quot;不可变性&quot;        text.append(&quot; - 被修改了！&quot;);        date.setTime(System.currentTimeMillis());        items.add(&quot;新添加的项目&quot;);                System.out.println(&quot;Record的内容被悄悄修改了！&quot;);    &#125;&#125;\r\nRecord 类的代码示例\r\n传统方式 vs Record方式\r\n传统的数据类写法：\r\npublic class PersonTraditional &#123;    private final String name;    private final int age;    private final String email;        public PersonTraditional(String name, int age, String email) &#123;        this.name = name;        this.age = age;        this.email = email;    &#125;        public String getName() &#123; return name; &#125;    public int getAge() &#123; return age; &#125;    public String getEmail() &#123; return email; &#125;        @Override    public boolean equals(Object obj) &#123;        if (this == obj) return true;        if (obj == null || getClass() != obj.getClass()) return false;        PersonTraditional that = (PersonTraditional) obj;        return age == that.age &amp;&amp;                Objects.equals(name, that.name) &amp;&amp;                Objects.equals(email, that.email);    &#125;        @Override    public int hashCode() &#123;        return Objects.hash(name, age, email);    &#125;        @Override    public String toString() &#123;        return &quot;PersonTraditional&#123;name=&#x27;&quot; + name + &quot;&#x27;, age=&quot; + age +                &quot;, email=&#x27;&quot; + email + &quot;&#x27;&#125;&quot;;    &#125;&#125;\r\n使用Record的简洁写法：\r\npublic record Person(String name, int age, String email) &#123;&#125;\r\n这两种方式功能完全相同，但Record版本只需要一行代码！\r\nRecord 类的基本语法\r\n声明一个 Record 类\r\npublic record RecordName(Type1 field1, Type2 field2, ...) &#123;    // 可选的方法体&#125;\r\n访问器方法\r\nRecord的访问器方法不是传统的getXxx()形式，而是直接使用字段名：\r\npublic record Student(String name, int grade, boolean isHonorStudent) &#123;&#125;// 使用Student student = new Student(&quot;张三&quot;, 95, true);System.out.println(student.name());        // 张三System.out.println(student.grade());       // 95System.out.println(student.isHonorStudent()); // true\r\nRecord的高级特性\r\n自定义构造器\r\n紧凑构造器(Compact Constructor)：\r\n它没有参数列表，主要用于对 Record\r\n类的字段进行验证和规范化。其实，虽然构造函数可以声明为没有正式形参列表的形式，但是此时默认使用完整的状态参数列表，也就实现了允许构造函数只执行参数的验证和规范化，而省略显式的字段初始化。\r\npublic record Temperature(double celsius) &#123;    // 紧凑构造器 - 用于验证和规范化    public Temperature &#123;        if (celsius &lt; -273.15) &#123;            throw new IllegalArgumentException(&quot;温度不能低于绝对零度&quot;);        &#125;        // 注意：这里不需要赋值，会自动执行    &#125;        // 便利方法    public double fahrenheit() &#123;        return celsius * 9.0 / 5.0 + 32;    &#125;        public double kelvin() &#123;        return celsius + 273.15;    &#125;&#125;\r\n标准构造器:\r\n标准构造器与传统类的构造器类似，需要显式地定义参数列表，并在构造器内部对字段进行赋值。同时，还可以定义额外的构造器来提供不同的初始化方式。\r\npublic record Point(int x, int y) &#123;    // 标准构造器    public Point(int x, int y) &#123;        if (x &lt; 0 || y &lt; 0) &#123;            throw new IllegalArgumentException(&quot;坐标不能为负数&quot;);        &#125;        this.x = x;        this.y = y;    &#125;        // 额外的构造器    public Point() &#123;        this(0, 0);    &#125;&#125;\r\n静态方法和实例方法\r\n静态工厂方法是一种创建对象的常用方式，它可以提供更具描述性的方法名，同时隐藏对象的创建细节。\r\npublic record Money(int yuan, int jiao, int fen) &#123;    // 静态工厂方法    public static Money of(double amount) &#123;        int totalFen = (int) Math.round(amount * 100);        return new Money(totalFen / 100, (totalFen % 100) / 10, totalFen % 10);    &#125;        // 实例方法    public double toDouble() &#123;        return yuan + jiao * 0.1 + fen * 0.01;    &#125;        public Money add(Money other) &#123;        int totalFen = this.toTotalFen() + other.toTotalFen();        return new Money(totalFen / 100, (totalFen % 100) / 10, totalFen % 10);    &#125;        private int toTotalFen() &#123;        return yuan * 100 + jiao * 10 + fen;    &#125;&#125;// 使用示例Money price1 = Money.of(12.35);Money price2 = new Money(5, 2, 8);Money total = price1.add(price2);\r\n实现接口\r\nRecord 类可以实现接口，这使得 Record 类可以像普通类一样参与多态。\r\npublic interface Drawable &#123;    void draw();&#125;// Circle 类实现了 Drawable 接口，并实现了 draw() 方法。// 通过实现接口，Circle 类可以作为 Drawable 类型的对象使用，从而实现多态。public record Circle(double radius, String color) implements Drawable &#123;    @Override    public void draw() &#123;        System.out.printf(&quot;绘制半径为%.2f的%s圆形%n&quot;, radius, color);    &#125;        public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;\r\n继承和嵌套 Record 类\r\n虽然 Record 类本身是隐式 final 的，不能被继承，但可以在\r\nRecord 类中嵌套使用 Record 类，以创建更复杂的数据结构。\r\n// 嵌套 Record 类示例public record Address(String street, String city, String zipCode) &#123;&#125;public record Person(String name, int age, Address address) &#123;    // 可以在外部 Record 类中定义方法来操作嵌套的 Record 类    public String getFullAddress() &#123;        return address.street() + &quot;, &quot; + address.city() + &quot;, &quot; + address.zipCode();    &#125;&#125;public class NestedRecordExample &#123;    public static void main(String[] args) &#123;        Address address = new Address(&quot;中山路123号&quot;, &quot;北京&quot;, &quot;100000&quot;);        Person person = new Person(&quot;张三&quot;, 25, address);        System.out.println(&quot;姓名: &quot; + person.name());        System.out.println(&quot;年龄: &quot; + person.age());        System.out.println(&quot;地址: &quot; + person.getFullAddress());    &#125;&#125;\r\nRecord与泛型\r\nRecord完全支持泛型：\r\npublic record Pair&lt;T, U&gt;(T first, U second) &#123;    public static &lt;T, U&gt; Pair&lt;T, U&gt; of(T first, U second) &#123;        return new Pair&lt;&gt;(first, second);    &#125;&#125;public record Result&lt;T&gt;(boolean success, T data, String message) &#123;    public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123;        return new Result&lt;&gt;(true, data, null);    &#125;        public static &lt;T&gt; Result&lt;T&gt; failure(String message) &#123;        return new Result&lt;&gt;(false, null, message);    &#125;&#125;// 使用示例Pair&lt;String, Integer&gt; nameAge = Pair.of(&quot;李四&quot;, 28);Result&lt;List&lt;String&gt;&gt; result = Result.success(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));\r\nrecord关键字实现密封接口的代码示例\r\npublic sealed interface Animal permits Cat, Dog&#123;    String eat();&#125;public record Cat(String name) implements Animal &#123;    @Override    public String eat() &#123;        return name+&quot;吃鱼&quot;;    &#125;&#125;public record Dog(String name) implements Animal &#123;    @Override    public String eat() &#123;        return name+&quot;吃骨头&quot;;    &#125;&#125;\r\nrecord关键字支持使用注解的代码示例\r\npublic record Dept(@Deprecated int id,@Deprecated String deptName) &#123;&#125;\r\nrecord 关键字代码示例的总结说明\r\n\r\nrecord关键字类似enum，也是一种特殊的class。\r\nrecord会自动生成一个隐式的带参构造方法，默认没有无参构造方法，但\r\nrecord\r\n允许声明没有参数列表的构造方法，默认使用完整的状态参数列表，这允许构造函数只执行参数的验证和规范化，而省略显式的字段初始化。\r\nrecord会自动为每个状态生成一个同名的get方法，注意方法名与变量名同名，不是getXxx。都是final字段自然没有set方法。\r\nrecord会自动根据状态字段重写hashcode、equals以及toString方法。\r\nrecord没有extend子句，所有record都直接继承java.lang.Record，但可以实现接口。\r\nrecord是隐式final的，不能有抽象方法，不可再被继承，以防止被子类扩展方法改变状态。\r\nrecord不能定义native方法，以防止record记录的状态被外部行为影响。\r\n\r\nRecord的限制\r\n不能做的事情\r\n\r\n不能继承其他类（但可以实现接口）\r\n不能被继承（隐式final）\r\n不能声明实例字段（除了组件字段）\r\n组件字段都是final的\r\n\r\n可以做的事情\r\n\r\n实现接口\r\n定义静态字段和方法\r\n定义实例方法\r\n使用泛型\r\n定义嵌套类型\r\n\r\npublic record DataContainer&lt;T&gt;(T data) &#123;    // 静态字段    private static final String DEFAULT_PREFIX = &quot;DATA_&quot;;        // 静态方法    public static &lt;T&gt; DataContainer&lt;T&gt; empty() &#123;        return new DataContainer&lt;&gt;(null);    &#125;        // 实例方法    public boolean isEmpty() &#123;        return data == null;    &#125;        public String getFormattedData() &#123;        return DEFAULT_PREFIX + (data != null ? data.toString() : &quot;NULL&quot;);    &#125;        // 嵌套记录    public record Metadata(String author, LocalDateTime created) &#123;&#125;&#125;\r\n性能考虑\r\nRecord类具有以下性能特征：\r\n\r\n内存效率：没有额外的开销，字段直接存储\r\n创建效率：构造器性能与普通类相同\r\nequals/hashCode优化：JVM可能对这些方法进行特殊优化\r\n不可变性：线程安全，可以安全地缓存hashCode\r\n\r\nRecord为Java带来了现代化的数据建模方式，大大减少了样板代码，提高了代码的可读性和维护性。它特别适合用于创建简单的数据容器、DTO对象和值对象，是Java语言演进中的一个重要里程碑。\r\n","categories":["Java学习","JavaSE","Java新特性"],"tags":["语法知识","学习","JavaSE","语言方面"]},{"title":"Java7新特性-switch支持String类型","url":"/posts/29333.html","content":"Java\r\n7新特性：Switch语句支持String详解\r\n1概述\r\n在Java\r\n7之前，switch语句只能用于基本数据类型（byte、short、char、int）和它们对应的包装类，以及枚举类型。Java\r\n7引入了一个重要的语言增强特性：switch语句支持String类型，这极大地提升了代码的可读性和开发效率。\r\n基本语法和使用\r\nswitch 原始语法\r\nswitch (stringVariable) &#123;    case &quot;value1&quot;:        // 执行代码块1        break;    case &quot;value2&quot;:        // 执行代码块2        break;    default:        // 默认执行代码块        break;&#125;\r\n简单示例\r\npublic class StringSwitchExample &#123;    public static void main(String[] args) &#123;        String day = &quot;Monday&quot;;                switch (day) &#123;            case &quot;Monday&quot;:                System.out.println(&quot;星期一，新的一周开始！&quot;);                break;            case &quot;Tuesday&quot;:                System.out.println(&quot;星期二，继续努力！&quot;);                break;            case &quot;Wednesday&quot;:                System.out.println(&quot;星期三，周中了！&quot;);                break;            case &quot;Thursday&quot;:                System.out.println(&quot;星期四，快到周末了！&quot;);                break;            case &quot;Friday&quot;:                System.out.println(&quot;星期五，TGIF！&quot;);                break;            case &quot;Saturday&quot;:            case &quot;Sunday&quot;:                System.out.println(&quot;周末，好好休息！&quot;);                break;            default:                System.out.println(&quot;无效的日期&quot;);                break;        &#125;    &#125;&#125;\r\n详细技术实现原理\r\n编译器实现机制\r\nJava编译器在处理String类型的switch语句时，实际上会将其转换为两个switch语句：\r\n\r\n第一个switch： 基于 String 的\r\nhashCode()值\r\n第二个switch： 基于 String\r\n的equals()方法进行精确匹配\r\n\r\n字节码转换示例\r\n让我们通过一个具体例子来理解编译器的转换过程：\r\n// 原始代码public String processCommand(String command) &#123;    switch (command) &#123;        case &quot;start&quot;:            return &quot;启动程序&quot;;        case &quot;stop&quot;:            return &quot;停止程序&quot;;        case &quot;restart&quot;:            return &quot;重启程序&quot;;        default:            return &quot;未知命令&quot;;    &#125;&#125;\r\n编译器会将上述代码转换为类似以下的逻辑：\r\n// 编译器生成的等价代码（简化版）public String processCommand(String command) &#123;    if (command == null) &#123;        // 处理null情况        return &quot;未知命令&quot;;    &#125;        // 第一层switch：基于hashCode    switch (command.hashCode()) &#123;        case 109757538: // &quot;start&quot;.hashCode()            if (command.equals(&quot;start&quot;)) &#123;                return &quot;启动程序&quot;;            &#125;            break;        case 3540994: // &quot;stop&quot;.hashCode()            if (command.equals(&quot;stop&quot;)) &#123;                return &quot;停止程序&quot;;            &#125;            break;        case 1097140605: // &quot;restart&quot;.hashCode()            if (command.equals(&quot;restart&quot;)) &#123;                return &quot;重启程序&quot;;            &#125;            break;    &#125;    return &quot;未知命令&quot;;&#125;\r\n哈希冲突处理\r\n当不同的字符串具有相同的hashCode时，编译器会在同一个case分支中处理多个字符串：\r\npublic class HashCollisionExample &#123;    public static void main(String[] args) &#123;        // 这两个字符串的hashCode相同        String str1 = &quot;Aa&quot;;        String str2 = &quot;BB&quot;;                System.out.println(&quot;Aa hashCode: &quot; + str1.hashCode()); // 2112        System.out.println(&quot;BB hashCode: &quot; + str2.hashCode()); // 2112                String input = &quot;Aa&quot;;        switch (input) &#123;            case &quot;Aa&quot;:                System.out.println(&quot;匹配到 Aa&quot;);                break;            case &quot;BB&quot;:                System.out.println(&quot;匹配到 BB&quot;);                break;            default:                System.out.println(&quot;未匹配&quot;);        &#125;    &#125;&#125;\r\n编译器生成的等价代码\r\n// 编译器处理哈希冲突的方式switch (input.hashCode()) &#123;    case 2112:        if (input.equals(&quot;Aa&quot;)) &#123;            System.out.println(&quot;匹配到 Aa&quot;);        &#125; else if (input.equals(&quot;BB&quot;)) &#123;            System.out.println(&quot;匹配到 BB&quot;);        &#125;        break;    default:        System.out.println(&quot;未匹配&quot;);&#125;\r\n性能考量\r\n\r\n时间复杂度：\r\n理论上接近O(1)，因为基于hashCode的查找\r\n空间复杂度： 编译器会生成查找表，占用额外内存\r\n与if-else链对比： 在分支较多时性能更好\r\n\r\n重要注意事项\r\nnull值处理\r\nString 类型的 switch\r\n语句不能处理null值，如果传入null会抛出\r\nNullPointerException：\r\npublic class NullHandlingExample &#123;    public static void processInput(String input) &#123;        // 错误的做法 - 会抛出NullPointerException        try &#123;            switch (input) &#123;                case &quot;yes&quot;:                    System.out.println(&quot;确认&quot;);                    break;                case &quot;no&quot;:                    System.out.println(&quot;取消&quot;);                    break;                default:                    System.out.println(&quot;未知输入&quot;);            &#125;        &#125; catch (NullPointerException e) &#123;            System.out.println(&quot;输入为null，抛出异常：&quot; + e.getMessage());        &#125;                // 正确的做法 - 预先检查null        if (input == null) &#123;            System.out.println(&quot;输入为空&quot;);            return;        &#125;                switch (input) &#123;            case &quot;yes&quot;:                System.out.println(&quot;确认&quot;);                break;            case &quot;no&quot;:                System.out.println(&quot;取消&quot;);                break;            default:                System.out.println(&quot;未知输入&quot;);        &#125;    &#125;        public static void main(String[] args) &#123;        processInput(null); // 演示null处理        processInput(&quot;yes&quot;); // 正常输入    &#125;&#125;\r\n大小写敏感性\r\nString类型的switch语句是大小写敏感的：\r\npublic class CaseSensitivityExample &#123;    public static void main(String[] args) &#123;        String command = &quot;START&quot;;                switch (command) &#123;            case &quot;start&quot;:                System.out.println(&quot;小写start匹配&quot;);                break;            case &quot;START&quot;:                System.out.println(&quot;大写START匹配&quot;);                break;            case &quot;Start&quot;:                System.out.println(&quot;首字母大写Start匹配&quot;);                break;            default:                System.out.println(&quot;未匹配任何情况&quot;);        &#125;                // 如果需要忽略大小写，可以预先转换        String normalizedCommand = command.toLowerCase();        switch (normalizedCommand) &#123;            case &quot;start&quot;:                System.out.println(&quot;忽略大小写后匹配成功&quot;);                break;            default:                System.out.println(&quot;仍未匹配&quot;);        &#125;    &#125;&#125;\r\n与Java 8+新特性的结合\r\n虽然switch支持String是Java\r\n7的特性，但它可以很好地与后续版本的特性结合使用：\r\n与Lambda表达式结合（Java 8+）\r\nimport java.util.function.Function;import java.util.Map;import java.util.HashMap;public class SwitchWithLambda &#123;    // 使用Map和Lambda替代复杂的switch    private static final Map&lt;String, Function&lt;String, String&gt;&gt; PROCESSORS =         new HashMap&lt;String, Function&lt;String, String&gt;&gt;() &#123;&#123;            put(&quot;upper&quot;, String::toUpperCase);            put(&quot;lower&quot;, String::toLowerCase);            put(&quot;reverse&quot;, s -&gt; new StringBuilder(s).reverse().toString());            put(&quot;length&quot;, s -&gt; String.valueOf(s.length()));        &#125;&#125;;        public static String processString(String operation, String input) &#123;        // 传统switch方式        switch (operation) &#123;            case &quot;upper&quot;:                return input.toUpperCase();            case &quot;lower&quot;:                return input.toLowerCase();            case &quot;reverse&quot;:                return new StringBuilder(input).reverse().toString();            case &quot;length&quot;:                return String.valueOf(input.length());            default:                return &quot;未知操作&quot;;        &#125;    &#125;        public static String processStringWithMap(String operation, String input) &#123;        // 使用Map和Lambda的方式        return PROCESSORS.getOrDefault(operation, s -&gt; &quot;未知操作&quot;).apply(input);    &#125;&#125;\r\n实际使用案例\r\n字符串的不匹配问题\r\npublic class DebuggingExample &#123;    public static void debugStringMatch(String input) &#123;        System.out.println(&quot;输入字符串: &#x27;&quot; + input + &quot;&#x27;&quot;);        System.out.println(&quot;字符串长度: &quot; + input.length());        System.out.println(&quot;字符串hashCode: &quot; + input.hashCode());                // 显示每个字符的ASCII值        System.out.print(&quot;字符ASCII值: &quot;);        for (int i = 0; i &lt; input.length(); i++) &#123;            System.out.print((int)input.charAt(i) + &quot; &quot;);        &#125;        System.out.println();                switch (input) &#123;            case &quot;test&quot;:                System.out.println(&quot;匹配到: test&quot;);                break;            case &quot;test &quot;: // 注意末尾空格                System.out.println(&quot;匹配到: test（带空格）&quot;);                break;            default:                System.out.println(&quot;未匹配任何case&quot;);                                // 调试：检查是否是空格问题                if (&quot;test&quot;.equals(input.trim())) &#123;                    System.out.println(&quot;去除空格后可以匹配test&quot;);                &#125;        &#125;    &#125;        public static void main(String[] args) &#123;        debugStringMatch(&quot;test&quot;);      // 正常匹配        debugStringMatch(&quot;test &quot;);     // 带空格        debugStringMatch(&quot;Test&quot;);      // 大小写不同    &#125;&#125;\r\n状态机实现\r\npublic class OrderStateMachine &#123;    public enum OrderEvent &#123;        PAY, SHIP, DELIVER, CANCEL, RETURN    &#125;        public String processOrderEvent(String currentState, OrderEvent event) &#123;        String eventStr = event.toString();                switch (currentState) &#123;            case &quot;PENDING&quot;:                switch (eventStr) &#123;                    case &quot;PAY&quot;:                        System.out.println(&quot;订单已支付，状态转为PAID&quot;);                        return &quot;PAID&quot;;                    case &quot;CANCEL&quot;:                        System.out.println(&quot;订单已取消，状态转为CANCELLED&quot;);                        return &quot;CANCELLED&quot;;                    default:                        throw new IllegalStateException(                            &quot;PENDING状态不支持事件: &quot; + eventStr);                &#125;                            case &quot;PAID&quot;:                switch (eventStr) &#123;                    case &quot;SHIP&quot;:                        System.out.println(&quot;订单已发货，状态转为SHIPPED&quot;);                        return &quot;SHIPPED&quot;;                    case &quot;CANCEL&quot;:                        System.out.println(&quot;订单已取消并退款，状态转为CANCELLED&quot;);                        return &quot;CANCELLED&quot;;                    default:                        throw new IllegalStateException(                            &quot;PAID状态不支持事件: &quot; + eventStr);                &#125;                            case &quot;SHIPPED&quot;:                switch (eventStr) &#123;                    case &quot;DELIVER&quot;:                        System.out.println(&quot;订单已送达，状态转为DELIVERED&quot;);                        return &quot;DELIVERED&quot;;                    default:                        throw new IllegalStateException(                            &quot;SHIPPED状态不支持事件: &quot; + eventStr);                &#125;                            case &quot;DELIVERED&quot;:                switch (eventStr) &#123;                    case &quot;RETURN&quot;:                        System.out.println(&quot;订单已退货，状态转为RETURNED&quot;);                        return &quot;RETURNED&quot;;                    default:                        System.out.println(&quot;订单已完成，无需状态变更&quot;);                        return currentState;                &#125;                            default:                throw new IllegalArgumentException(&quot;未知订单状态: &quot; + currentState);        &#125;    &#125;&#125;\r\n","categories":["Java学习","JavaSE","Java新特性"],"tags":["语法知识","学习","JavaSE","语言方面"]},{"title":"JavaWeb-http","url":"/posts/31243.html","content":"HTTP请求\r\n客户端–&gt;请求–&gt;服务器\r\n\r\n超文本传输协议（Hypertext Transfer\r\nProtocol，HTTP）是一个简单的请求-响应协议，是用于从万维网（WWW:World\r\nWide Web ）服务器传输超文本到本地浏览器的传送协议。\r\nHTTP是基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件,\r\n查询结果等）。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\r\nHTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。\r\n\r\n以请求百度为例\r\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\r\nAccept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9  语言Cache-Control: max-age=0Connection: keep-alive\r\n1.请求行\r\n请求行中的请求方式：GET\r\n\r\n\r\n\r\n请求头图\r\n\r\nGET请求方式\r\n请求方式：\r\n\r\n\r\n\r\nimage-20250414142250490\r\n\r\n2.消息头\r\n\r\n\r\n\r\nimage-20250414142603869\r\n\r\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接\r\nHTTP响应\r\n服务器–&gt;响应–&gt;客户端\r\n例子\r\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\r\n响应体\r\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的    sendRedirect方法，该方法同时设置状态代码为302。Set-Cookie:设置和页面关联的Cookie。\r\n响应状态码\r\n常见状态码\r\n200：请求响应成功\r\n301：请求重定向\r\n\r\n请求重定向(Redirect)：通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。\r\n\r\n404: 找不到资源\r\n500：服务器代码错误\r\nHTTP状态码分类\r\nHTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\r\n\r\n\r\n\r\nimage-20250414143407248\r\n\r\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaWeb","JavaEE","Web"]},{"title":"Java之动态代理","url":"/posts/60449.html","content":"设计模式–代理模式\r\n代理模式是常用的java设计模式，它允许你通过创建一个代理对象来控制对另一个对象（即目标对象）的访问，代理类与委托类有同样的接口。\r\n代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。\r\n代理对象充当了目标对象的接口，客户端通过代理对象与目标对象进行交互，而不是直接访问目标对象。\r\n代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。\r\n在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。代理模式可以在不改变目标对象代码的前提下，对目标对象的功能进行增强或扩展。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n可以发现，其中有\r\n\r\n代理对象\r\n被代理的行为\r\n被代理的对象\r\n行为的完全控制\r\n\r\n静态代理\r\n静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。\r\n简单实现\r\n首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。\r\n/** * 创建Person接口 * @author Gonjan */public interface Person &#123;    //上交班费    void giveMoney();&#125;\r\nStudent类实现Person接口。Student可以具体实施上交班费的动作。\r\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\r\nStudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为\r\n// 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为public class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        stu.giveMoney();    &#125;&#125;\r\n测试主类 public class StaticProxyTest &#123;    public static void main(String[] args) &#123;        //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成        Person zhangsan = new Student(&quot;张三&quot;);                //生成代理对象，并将张三传给代理对象        Person monitor = new StudentsProxy(zhangsan);                //班长代理上交班费        monitor.giveMoney();    &#125;&#125;\r\n这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。\r\n代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。\r\n代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。\r\n这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以很方便的加上一些其他用途\r\npublic class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        System.out.println(&quot;张三最近学习有进步！&quot;);  // 代理类顺便告诉张三最近学习有进步        stu.giveMoney();    &#125;&#125;\r\n可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。\r\n动态代理\r\n介绍\r\n代理类在程序运行时创建的代理方式被成为动态代理。\r\n我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。\r\n然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。\r\n相比于静态代理，\r\n动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\r\n比如说，想要在每个代理的方法前都加上一个处理方法：\r\npublic void giveMoney() &#123;      //调用被代理方法前加入处理方法      beforeMethod();      stu.giveMoney();  &#125;\r\n这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。\r\n简单实现\r\n在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。\r\n相关方法：\r\n创建一个InvocationHandler对象\r\n//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);\r\nInvocationHandler接口定义了一个invoke方法，当通过代理对象调用目标方法时，invoke\r\n方法会被调用。invoke\r\n方法接收三个参数：代理对象、被调用的方法对象以及方法的参数数组。在\r\ninvoke\r\n方法中，我们可以编写额外的逻辑，然后调用目标方法并返回结果。\r\n例如\r\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler接口 &#123;  // 实现InvocationHandler接口    private Object target;    public MyInvocationHandler(Object target) &#123;        // 存储目标对象。这个目标对象就是我们要为其添加额外功能的对象。        this.target = target;    &#125;    // 需要重写invoke方法    @Override    // Object proxy：代理对象本身   Method method：被调用的目标方法对象   Object[] args：调用目标方法时传递的参数数组    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        // 调用目标方法前的逻辑，例如记录日志        System.out.println(&quot;Before method invocation: &quot; + method.getName());        // 调用目标方法        Object result = method.invoke(target, args);   // 代理target对象实际方法        // 调用目标方法后的逻辑，例如记录日志        System.out.println(&quot;After method invocation: &quot; + method.getName());        return result;    &#125;&#125;\r\n使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass\r\nClass&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;);\r\n该类提供了静态方法用于创建动态代理类和代理对象。\r\n其中，newProxyInstance\r\n方法是创建代理对象的关键方法，它接收三个参数：类加载器、目标对象实现的接口数组以及\r\nInvocationHandler 实例。\r\n例如\r\nimport java.lang.reflect.Proxy;// 为传入的目标对象创建一个动态代理对象。public class ProxyFactory &#123;    public static Object createProxy(Object target) &#123;        return Proxy.newProxyInstance(                target.getClass().getClassLoader(),     // 类加载器// 动态代理只能为实现了接口的类创建代理对象，因此需要指定目标对象实现的接口，这样代理对象才能实现相同的接口。                target.getClass().getInterfaces(),   // 获取目标对象所实现的所有接口的数组                new MyInvocationHandler(target));    &#125;&#125;\r\n获得stuProxyClass\r\n中一个带InvocationHandler参数的构造器constructor\r\nConstructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);\r\n在 Java 反射机制中，Class\r\n类提供了一系列方法来获取类的构造器信息。这里通过\r\nPersonProxy.getConstructor(InvocationHandler.class) 来获取\r\nPersonProxy 类中，参数为\r\nInvocationHandler.class\r\n的构造器。getConstructor 方法会返回一个\r\nConstructor 对象，它代表了对应的构造器。\r\n通过构造器constructor来创建一个动态实例stuProxy\r\nPerson stuProxy = (Person) cons.newInstance(stuHandler);\r\nConstructor 类的 newInstance\r\n方法用于根据构造器来创建类的实例。这里传入了 stuHandler\r\n作为参数，stuHandler 应该是实现了\r\nInvocationHandler\r\n接口的对象实例。它会调用之前获取到的构造器（要求参数为\r\nInvocationHandler 类型 ）来初始化一个\r\nPersonProxy 实例，并将其强制转换为 Person\r\n类型（前提是 PersonProxy 类实现了 Person 接口\r\n）\r\n一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化\r\n//创建一个与代理对象相关联的InvocationHandler  InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);\r\n完整的动态代理例子\r\n定义一个Person接口，里面定义一个抽象方法giveMoney();\r\npublic interface Person &#123;    //上交班费    void giveMoney();&#125;\r\n创建需要被代理的实际类\r\nStudent类，实现了Person接口，是被代理的目标对象：\r\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;        try &#123;          //假设数钱花了一秒时间            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\r\n再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。\r\npublic class MonitorUtil &#123;        private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();        public static void start() &#123;        tl.set(System.currentTimeMillis());    &#125;        //结束时打印耗时    public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();        System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);    &#125;&#125;\r\n创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。再在invoke方法中执行被代理对象target的相应方法。\r\n所以说InvocationHandler\r\n负责处理代理对象方法的调用，当调用代理对象的方法时，实际上会调用\r\nInvocationHandler 的 invoke 方法。\r\n当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。\r\npublic class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123;   // invocationHandler持有的被代理对象    T target;        public StuInvocationHandler(T target) &#123;       this.target = target;    &#125;        /**     * proxy:代表动态代理对象     * method：代表正在执行的方法     * args：代表调用目标方法时传入的实参     */     @Override   // 实现 InvocationHandler 接口需要重写invoke方法    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;);          //代理过程中插入监测方法,计算该方法耗时        MonitorUtil.start();        Object result = method.invoke(target, args);        MonitorUtil.finish(method.getName());        return result;    &#125;&#125;\r\n我们使用简化的方式创建动态代理对象：\r\npublic class ProxyTest &#123;    public static void main(String[] args) &#123;        //创建一个实例对象，这个对象是被代理的对象        Person zhangsan = new Student(&quot;张三&quot;);        //创建一个与代理对象相关联的InvocationHandler        InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan);        //创建一个代理对象stuProxy来代理张三，代理对象的每个执行方法都会替换执行Invocation中的invoke方法        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；       //代理执行上交班费的方法        stuProxy.giveMoney();    &#125;&#125;\r\n过程讲解：\r\nstuHandler为代理对象相关联的InvocationHandler，将目标对象\r\n张三 传递给 StuInvocationHandler\r\n的构造函数。InvocationHandler\r\n的作用是处理代理对象方法的调用，当调用代理对象的方法时，会自动调用\r\nInvocationHandler 的 invoke 方法\r\n使用 Proxy.newProxyInstance 方法创建一个代理对象\r\nstuProxy，需要传入类加载器，实现的接口，指定处理代理对象方法调用的InvocationHandle对象，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\r\n之后调用代理对象的 giveMoney 方法，实际上会调用\r\nStuInvocationHandler 的 invoke 方法，在\r\ninvoke 方法中会先调用 MonitorUtil.start()\r\n记录开始时间，然后调用目标对象的 giveMoney 方法，最后调用\r\nMonitorUtil.finish() 计算并打印方法执行的耗时。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\r\n是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。\r\n例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而只做了很少的代码量。\r\n动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。\r\n因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行，这就涉及到java动态代理的原理了\r\n动态代理原理分析\r\nJava动态代理创建出来的动态代理类\r\n上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：\r\n/** * 返回一个指定接口的代理类实例，该实例会将方法调用分派到指定的调用处理器。 * * @param loader 定义代理类的类加载器 * @param interfaces 代理类要实现的接口列表 * @param h 调度方法调用的调用处理器 * @return 一个实现了指定接口的代理类实例，它会将方法调用分派给指定的调用处理器 * @throws IllegalArgumentException 如果违反了对该方法参数的任何限制 */public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)    throws IllegalArgumentException&#123;    // 检查调用处理器是否为 null，如果为 null 则抛出 NullPointerException    Objects.requireNonNull(h);    // 克隆接口数组，防止外部对原数组进行修改影响后续操作    final Class&lt;?&gt;[] intfs = interfaces.clone();    // 获取系统的安全管理器    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        // 如果存在安全管理器，检查调用者是否有创建代理类的权限        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    /*     * 查找或生成指定的代理类。     */    // 通过类加载器和接口数组获取代理类的 Class 对象    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * 使用指定的调用处理器调用其构造函数。     */    try &#123;        if (sm != null) &#123;            // 如果存在安全管理器，检查调用者是否有创建代理实例的权限            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        // 获取代理类的构造函数，该构造函数接收一个 InvocationHandler 类型的参数        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        // 保存传入的调用处理器        final InvocationHandler ih = h;        if (!Modifier.isPublic(cl.getModifiers())) &#123;            // 如果代理类不是公共类，则使用特权操作将构造函数设置为可访问            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;        // 使用构造函数创建代理类的实例，并传入调用处理器        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;        // 处理非法访问或实例化异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        // 处理构造函数调用抛出的异常        Throwable t = e.getCause();        if (t instanceof RuntimeException) &#123;            // 如果是运行时异常，直接抛出            throw (RuntimeException) t;        &#125; else &#123;            // 否则抛出内部错误            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        // 处理构造函数未找到的异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125;&#125;\r\nClass&lt;?&gt; cl = getProxyClass0(loader, intfs);\r\n\r\nloader：这是一个 ClassLoader\r\n对象，它指定了代理类应该使用哪个类加载器来加载。类加载器负责将类的字节码文件加载到\r\nJVM\r\n中，不同的类加载器可能会从不同的位置（如文件系统、网络等）加载类。通常，我们会使用被代理接口的类加载器，这样可以确保代理类和被代理接口在同一个类加载器的命名空间中，从而避免类加载的冲突。\r\nintfs：这是一个 Class[]\r\n数组，包含了代理类需要实现的接口列表。代理类会实现这些接口中定义的所有方法，当调用代理对象的这些方法时，实际上会将调用转发到\r\nInvocationHandler 的 invoke\r\n方法中进行处理。\r\n\r\n其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader,\r\nintfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，这个类文件时缓存在java虚拟机中的\r\n\r\n在 Java 动态代理中，Proxy.newProxyInstance\r\n方法的核心目标是创建一个实现了指定接口的代理对象。而\r\ngetProxyClass0\r\n方法就是用来生成这个代理对象所对应的代理类的。这个代理类是在运行时动态生成的，并且会被加载到\r\nJava\r\n虚拟机（JVM）中，后续的代理对象实例就是基于这个动态生成的类来创建的。\r\n\r\n那么是如何动态生成代理类的：\r\n\r\ngetProxyClass0\r\n方法会根据传入的类加载器和接口数组，在运行时动态生成一个代理类的字节码。这个代理类会实现\r\nintfs\r\n数组中指定的所有接口，并且会重写这些接口中的方法。在重写的方法中，会调用\r\nInvocationHandler 的 invoke\r\n方法，从而实现对目标方法的增强。\r\n这其中有一个缓存机制，为了提高性能，Java\r\n虚拟机对动态生成的代理类采用了缓存机制。也就是说，如果已经为相同的类加载器和接口列表生成过代理类，那么\r\ngetProxyClass0\r\n方法会直接从缓存中获取这个代理类，而不是再次生成。这样可以避免重复生成相同的代理类，减少开销。\r\n\r\n之后对这个class文件反编译\r\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.Person;// $Proxy0 是动态生成的代理类，它继承自 Proxy 类并实现了 Person 接口。Proxy 类是 Java 中所有代理类的基类// 它持有一个 InvocationHandler 类型的成员变量 h，用于处理方法调用public final class $Proxy0 extends Proxy implements Person&#123;  // 这些静态变量用于存储通过反射获取的方法对象。m3 对应 Person 接口的 giveMoney 方法，m0、m1、m2 分别对应 Object 类的 hashCode、equals 和 toString 方法。  private static Method m1;  private static Method m2;  private static Method m3;  private static Method m0;    /**  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，代理类的构造方法接收一个 InvocationHandler 类型的参数，并调用父类 Proxy 的构造方法将其传递给父类的 h 成员变量。这意味着代理类持有一个 InvocationHandler 对象，后续的方法调用将由该对象处理。  *  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。  *父类持有：protected InvocationHandler h;  *Proxy构造方法：  *    protected Proxy(InvocationHandler h) &#123;  *         Objects.requireNonNull(h);  *         this.h = h;  *     &#125;  *  */  public $Proxy0(InvocationHandler paramInvocationHandler)    throws   &#123;    super(paramInvocationHandler);  &#125;    //这个静态块本来是在最后的，我把它拿到前面来，方便描述   static  &#123;    try    &#123;      //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);      m3 = Class.forName(&quot;proxy.Person&quot;).getMethod(&quot;giveMoney&quot;, new Class[0]);      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);      return;    &#125;    catch (NoSuchMethodException localNoSuchMethodException)    &#123;      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());    &#125;    catch (ClassNotFoundException localClassNotFoundException)    &#123;      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());    &#125;  &#125;   /**  *   *当调用代理对象的 giveMoney 方法时，实际上会调用 InvocationHandler 对象的 invoke 方法，并将代理对象本身（this）、giveMoney 方法的 Method 对象（m3）和方法参数（这里为 null）作为参数传递给 invoke 方法。  *this.h.invoke(this, m3, null);这里简单，明了。  *InvocationHandler 对象持有被代理对象的引用，在 invoke 方法中可以调用被代理对象的相应方法，并可以在方法调用前后添加额外的逻辑，从而实现对被代理对象方法的增强。  */  public final void giveMoney()    throws   &#123;    try    &#123;      this.h.invoke(this, m3, null);      return;    &#125;    catch (Error|RuntimeException localError)    &#123;      throw localError;    &#125;    catch (Throwable localThrowable)    &#123;      throw new UndeclaredThrowableException(localThrowable);    &#125;  &#125;  //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。&#125;\r\njdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。\r\n我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。\r\n代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。\r\n引用\r\n[java动态代理实现与原理详细分析\r\nJava动态代理详细讲解-使用方式及应用场景\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","学习","JavaSE","语言方面"]},{"title":"JavaWeb之Filter过滤器","url":"/posts/42974.html","content":"Filter 介绍\r\n过滤器，顾名思义就是对事物进行过滤的，在Web中的过滤器，当然就是对请求进行过滤，对web服务器管理的所有web资源，我们使用过滤器，就可以对请求进行拦截，然后做相应的处理，实现许多特殊功能。如登录控制，权限管理，过滤敏感词汇等.\r\nServlet\r\nAPI中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过\r\nFilter\r\n技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，Filter接口源代码：\r\npublic abstract interface Filter&#123;    public abstract void init(FilterConfig paramFilterConfig) throws ServletException;    public abstract void doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain         paramFilterChain) throws IOException, ServletException;    public abstract void destroy();&#125;\r\nFilter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：\r\n- 调用目标资源之前，让一段代码执行。 -\r\n是否调用目标资源（即是否让用户访问web资源）。\r\nweb服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个\r\ndoFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。\r\n过滤器原理\r\n当我们使用过滤器时，过滤器会对游览器的请求进行过滤，过滤器可以动态的分为3个部分\r\n1.放行之前的代码，2.放行，3.放行后的代码\r\n\r\n第一部分代码会对游览器请求进行第一次过滤，然后继续执行\r\n第二部分代码就是将游览器请求放行，如果还有过滤器，那么就继续交给下一个过滤器\r\n第三部分代码就是对返回的Web资源再次进行过滤处理\r\n\r\n我们使用过滤器，也就是说，不止请求会经过过滤器，我们的响应也会经过过滤器。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n使用过滤器\r\n我们创建Filter，只需要继承Filter接口就行。\r\nimport javax.servlet.*;import java.io.IOException;@WebFilter(&quot;/*&quot;)public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;对request进行过滤&quot;);        //下面这行代码就是放行        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;对response进行过滤&quot;);    &#125;&#125;\r\n我们实现了一个 doFilter\r\n方法，这个方法就是我们写过滤代码的地方，具体逻辑就是和上面介绍的过滤器原理一样的。\r\n我简单介绍下上面的代码，WebFilter(\"/*\")\r\n表示对所有请求进行过滤,而在doFilter中的放行代码，也就是filterChain.doFilter(servletRequest,servletResponse);这行代码就是对拦截进行放行\r\n过滤器并不会管资源是否存在，而只会对配置的拦截路径进行拦截。拦截不仅会对请求进行拦截，而且还会对相应进行拦截。\r\n配置过滤器拦截路径\r\n配置Filter的拦截路径有2种方式，一种是注解，一种是xml方式，我们分别进行讲解\r\n注解方式\r\n我们如果使用注解来进行配置，那么我们就需要使用 @WebFilter ，直接看该注解的源码\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\nfilterName：该filter的名字\r\ninitParams：初始化参数\r\ndisplayName：filter显示名称\r\nservletNames：指定对哪些servlet进行过滤\r\nasyncSupported：是否支持异步模式\r\nurlPatterns：指定拦截路径\r\nvalue：指定拦截路径\r\n\r\nurlPatterns和value是一样的。urlPatterns和value只能配置一个，不能两个都配置，两个都配置就会报错。\r\n对于使用@WebFilter,里面的多个参数用\r\n, 进行分隔。\r\n如果我们仅仅需要配置一个拦截路径，那么我们可以直接简写@WebLister(“拦截路径”)，如@WebFilter(“/*”)就是拦截所有请求。\r\n@WebFilter(value = &#123;&quot;/login&quot;&#125;, filterName = &quot;filtersss&quot;)public class CharSetFilter implements Filter &#123;\r\n多个参数配置，需要分隔\r\nxml 方式\r\nxml方式可以说是和Servlet使用xml配置方式一样了\r\n&lt;filter&gt;    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.ergoutree.filter.MyFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\r\n把注解换成了xml标签来配置，里面属性都是一样的，这个和Servlet的配置方式基本一样\r\n过滤器生命周期\r\nFilter 的生命周期和 Servlet 也十分相似\r\n创建一个类\r\nimport javax.servlet.*;import java.io.IOException; public class LifeCycleFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\nFilter有3个阶段，分别是初始化，拦截和过滤，销毁。\r\n\r\n初始化阶段：当服务器启动时，我们的服务器(Tomcat)就会读取配置文件，扫描注解，然后来创建我们的Filter。\r\n拦截和过滤阶段：只要请求资源的路径和拦截的路径相同，那么过滤器就会对请求进行过滤，这个阶段在服务器运行过程中会一直循环。\r\n销毁阶段：当服务器(Tomcat)关闭时，服务器创建的Filter也会随之销毁。\r\n\r\nFilter的三个阶段就对应着Filter的3个方法，init 方法会在 Filter\r\n创建时调用，doFilter 方法会在请求和拦截匹配时调用，destroy 方法会在\r\nFilter 销毁时调用。\r\n@WebFilter(value = &#123;&quot;/login&quot;&#125;, filterName = &quot;filtersss&quot;)public class CharSetFilter implements Filter &#123;    private static final Logger LOGGER = Logger.getLogger(CharSetFilter.class.getName());    private static final String CHARSET = &quot;UTF-8&quot;;    public void init(FilterConfig config) throws ServletException &#123;        System.out.println(&quot;LoginOccasion过滤器初始化完成 - &quot; + new Date());    &#125;    public void destroy() &#123;        System.out.println(&quot;LoginOccasion过滤器被销毁 - &quot; + new Date());    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;        // 1. 预处理 - 在请求到达Servlet之前执行        System.out.println(&quot;LoginOccasion过滤器: 预处理开始&quot;);        // 获取客户端IP地址        String ipAddress = request.getRemoteAddr();        System.out.println(&quot;请求来自IP: &quot; + ipAddress + &quot; - &quot; + new Date());        request.setCharacterEncoding(CHARSET);        response.setCharacterEncoding(CHARSET);        response.setContentType(&quot;text/html; charset=&quot; + CHARSET);        if(request instanceof HttpServletRequest) &#123;            HttpServletRequest httpRequest = (HttpServletRequest) request;            System.out.println(&quot;访问的URL: &quot; + httpRequest.getRequestURL());            System.out.println(&quot;HTTP方法: &quot; + httpRequest.getMethod());        &#125;        // 记录请求开始时间        long startTime = System.currentTimeMillis();        // 2. 将请求传递给下一个过滤器或目标Servlet        chain.doFilter(request, response);        // 3. 后处理 - 在响应返回客户端之前执行        long endTime = System.currentTimeMillis();        System.out.println(&quot;请求处理耗时: &quot; + (endTime - startTime) + &quot;毫秒&quot;);        System.out.println(&quot;LoginOccasion过滤器: 后处理完成&quot;);    &#125;&#125;\r\nFilterConfig和FilterChain\r\nFilterConfig和FilterConfig这2个对象是由服务器(Tomcat)在创建和调用Filter对象时所传入的，这2个对象十分有用，FilterConfig对象可以读取我们配置的初始参数，FilterChain可以实现多个Filter之间的连接。\r\nFilterConfig\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n里面的方法就4个，下面我们分别进行讲解\r\n\r\ngetFilterName()：获取filter的名称\r\ngetServletContext()：获取ServletContext\r\ngetInitparamter(String var1)：获取配置的初始参数的值\r\ngetInitParamterNames()：获取配置的所有参数名称\r\n\r\n实际例子\r\n我们在init方法中使用FilterConfig来读取配置的数据库的信息，然后输出。\r\nimport javax.servlet.*;import java.io.IOException;import java.util.Enumeration; public class MyFilterConfig implements Filter &#123;     @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;-----------获取全部key:value------------&quot;);        //得到所有配置参数的名字        Enumeration&lt;String&gt; names = filterConfig.getInitParameterNames();        while (names.hasMoreElements()) &#123;            //得到每一个名字            String name = names.nextElement();            System.out.println(name+&quot; = &quot;+filterConfig.getInitParameter(name));        &#125;        System.out.println(&quot;-----------end.....------------&quot;);    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\nxml 配置\r\n&lt;filter&gt;        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;        &lt;filter-class&gt;com.clucky.filter.MyFilterConfig&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;driver&lt;/param-name&gt;            &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;url&lt;/param-name&gt;            &lt;param-value&gt;jdbc:mysql://localhost:3306/equip_employ_manage?serverTimezone=GMT&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;username&lt;/param-name&gt;            &lt;param-value&gt;root&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;password&lt;/param-name&gt;            &lt;param-value&gt;root&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n我们使用FilterConfig提供的方法就成功实现了功能，FilterConfig就是用来读取配置文件的。\r\n\r\nFilterChain\r\n在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在\r\nweb.xml 文件中的注册顺序，决定先调用哪个Filter，当第一个 Filter 的\r\ndoFilter 方法被调用时，web服务器会创建一个代表 Filter 链的FilterChain\r\n对象传递给该方法。在 doFilter 方法中，开发人员如果调用了 FilterChain\r\n对象的 doFilter 方法，则 web 服务器会检查 FilterChain\r\n对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n我们查看类图，可以发现 FilterChain\r\n就只有一个方法，其实这个方法就是用来对拦截进行放行的，如果有多个拦截器，那么就会继续调用下一个Filter进行拦截。doFilter\r\n方法需要传入个参数，一个是 ServletRequest ，一个是 ServletResponse\r\n参数，这个直接传入进行。\r\nTomcat 在调用过滤器时，默认就会传入 Request 和\r\nResponse，这个参数封装了请求和响应，我们直接使用就行。ServletResquest 和\r\nServletResponse 可以直接强转成 HttpServletRequest 和\r\nHttpServletResponse，然后使用相应的方法。\r\n将ServletRequest转成HttpServletRequest\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n应用实例\r\n我们前面一直都是一个Filter，现在我们来配置2个Filter，通过FilterChain来进行多个过滤。\r\n第一个 Filter\r\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Filter01 implements Filter &#123;     @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;调用过滤器01对请求进行过滤~~~~&quot;);        //放行,如果还有过滤器，那么就执行下一个过滤器        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;调用过滤器01对响应进行过滤~~~~&quot;);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\n第二个Filterl\r\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Filter02 implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;调用过滤器02对请求进行过滤~~~~&quot;);        //放行,如果还有过滤器，那么就执行下一个过滤器        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;调用过滤器02对响应进行过滤~~~~&quot;);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\n启动服务器，访问8080，查看控制台输出。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n我们可以看见Filter01先进行过滤，然后交给Filter02，然后访问资源，然后Filter02对响应进行过滤，然后Filter01对响应进行过滤。图示如下：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n多个 Filter 的执行顺序\r\n上面我们配置了2个过滤器，那么我们怎么知道那个过滤器先执行呢？\r\n\r\n如果我们是在web.xml中配置的过滤器，那么过滤器的执行顺序就是在web配置的顺序，配置在上面那么就会先执行。\r\n如果我们是使用@WebFilter进行配置的，那么执行顺序就是字符比较顺序来执行，例如有2个过滤器，一个是AFilter，一个是BFilter，那么AFilter就会先执行。\r\n如果注解和xml混用，那么在web.xml中配置的会先执行。\r\n\r\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaWeb","JavaEE"]},{"title":"Java枚举类型及其深入理解","url":"/posts/14594.html","content":"关于枚举类型\r\n什么是枚举类型\r\n枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型\r\n一般在实现枚举一些多次会被使用的常量时候，可以使用定义常量的方式，也就是\r\nfianl int\r\n枚举模式，这样的定义方式并没有什么错，但它存在许多不足，如在类型安全和使用方便性上并没有多少好处，如果存在定义int值相同的变量，混淆的几率还是很大的，编译器也不会提出任何警告\r\n例如星期中每天的枚举\r\n// 不使用枚举类public class DayWeek &#123;    public static final int MONDAY =1;    public static final int TUESDAY=2;    public static final int WEDNESDAY=3;    public static final int THURSDAY=4;    public static final int FRIDAY=5;    public static final int SATURDAY=6;    public static final int SUNDAY=7;&#125;//枚举类型，使用关键字enumenum Day &#123;    MONDAY, TUESDAY, WEDNESDAY,    THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;\r\n在定义枚举类型时我们使用的关键字是enum，与class关键字类似，只不过前者是定义枚举类型，后者是定义类类型。然后然后定义枚举的名称、可访问性、基础类型和成员等。枚举声明的语法如下：\r\nenum-modifiers enum enumname:enum-base &#123;    enum-body,&#125;\r\n其中，enum-modifiers 表示枚举的修饰符主要包括 public、private 和\r\ninternal；enumname 表示声明的枚举名称；enum-base 表示基础类型；enum-body\r\n表示枚举的成员，它是枚举类型的命名常数。\r\n要注意，任意两个枚举成员不能具有相同的名称，且它的常数值必须在该枚举的基础类型的范围之内，多个枚举成员之间使用逗号分隔。\r\n其中，如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是\r\nint。\r\n而且枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部，但要保证枚举表示的类型其取值是必须有限的，也就是说每个值都是可以枚举出来的，有限且可枚举。\r\n使用也很简单，直接引用就行这便是枚举类型的最简单模型。\r\npublic static void main(String[] args)&#123;        //直接引用        Day day = Day.MONDAY; &#125;\r\n枚举的实现原理\r\n实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型，而且该类继承自java.lang.Enum类\r\n来看看反编译的一个枚举类文件\r\n//反编译Day.classfinal class Day extends Enum&#123;    //编译器为我们添加的静态的values()方法    public static Day[] values()    &#123;        return (Day[])$VALUES.clone();    &#125;    //编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法    public static Day valueOf(String s)    &#123;        return (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);    &#125;    //私有构造函数    private Day(String s, int i)    &#123;        super(s, i);    &#125;     //前面定义的7种枚举实例    public static final Day MONDAY;    public static final Day TUESDAY;    public static final Day WEDNESDAY;    public static final Day THURSDAY;    public static final Day FRIDAY;    public static final Day SATURDAY;    public static final Day SUNDAY;    private static final Day $VALUES[];    static     &#123;            //实例化枚举实例        MONDAY = new Day(&quot;MONDAY&quot;, 0);        TUESDAY = new Day(&quot;TUESDAY&quot;, 1);        WEDNESDAY = new Day(&quot;WEDNESDAY&quot;, 2);        THURSDAY = new Day(&quot;THURSDAY&quot;, 3);        FRIDAY = new Day(&quot;FRIDAY&quot;, 4);        SATURDAY = new Day(&quot;SATURDAY&quot;, 5);        SUNDAY = new Day(&quot;SUNDAY&quot;, 6);        $VALUES = (new Day[] &#123;            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY        &#125;);    &#125;&#125;\r\n使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象\r\n编译器确实帮助我们生成了一个Day类(注意该类是final类型的，将无法被继承)而且\r\nJava 中的每一个枚举都继承自 java.lang.Enum\r\n类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum\r\n类的实例，这些枚举成员默认都被 final、public, static\r\n修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。\r\n除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，也就是说我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象。\r\n注意编译器还为我们生成了两个静态方法，分别是values()和\r\nvalueOf()\r\n枚举的常见方法\r\nEnum抽象类常见方法\r\nEnum是所有 Java\r\n语言枚举类型的公共基本类（注意Enum是抽象类），所有枚举实例都可以调用\r\nEnum 类的方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法名称\r\n描述\r\n\r\n\r\n\r\n\r\nvalues()\r\n以数组形式返回枚举类型的所有成员\r\n\r\n\r\nvalueOf()\r\n将普通字符串转换为枚举实例\r\n\r\n\r\ncompareTo()\r\n比较两个枚举成员在定义时的顺序\r\n\r\n\r\nordinal()\r\n获取枚举成员的索引位置\r\n\r\n\r\nname()\r\n返回此枚举常量的名称，在其枚举声明中对其进行声明\r\n\r\n\r\nstatic valueOf(Class enumType, String name)\r\n返回带指定名称的指定枚举类型的枚举常量。\r\n\r\n\r\n\r\n其他剩下的，别的抽象类和包装类都有的equals，toString，反射用的getDeclaringClass()这个类也有，不多介绍了。\r\nvalues()方法是由编译器自动添加到每个枚举类中的静态方法，而非\r\nEnum\r\n类本身的方法。它会返回一个包含枚举所有成员的数组，顺序与枚举定义的顺序一致。\r\n当你定义一个枚举类（如enum Season &#123; SPRING, SUMMER &#125;）时，编译器会自动为该类添加两个静态方法：\r\n\r\npublic static Season[] values()：返回枚举的所有实例。\r\npublic static Season valueOf(String name)：根据名称查找枚举实例。\r\n\r\n而valueOf(String name)是Enum\r\n类的静态方法，与Enum类中的valueOf方法的作用类似，用于根据名称获取枚举变量。字符串必须严格匹配枚举常量的名称，只不过编译器生成的valueOf方法更简洁些只需传递一个参数。这里我们还必须注意到，由于values()方法是由编译器插入到枚举类中的static方法，所以如果我们将枚举实例向上转型为Enum，那么values()方法将无法被调用，因为Enum类中并没有values()方法，valueOf()方法也是同样的道理，注意是一个参数的。\r\n这里主要说明一下ordinal()方法，该方法获取的是枚举变量在枚举类中声明的顺序，顺序排列是下标从0开始，从第一个枚举的变量开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化，注意在大多数情况下我们都不应该首先使用该方法。\r\n而compareTo(E o)方法则是比较枚举的大小，和其他的conpareTo一样，都是实现了\r\nComparable\r\n接口的方法，用于比较枚举常量的顺序，注意其内部实现是根据每个枚举的ordinal值大小进行比较。\r\nname()方法与toString()几乎是等同的，都是输出变量的字符串形式。\r\n至于valueOf(Class&lt;T&gt; enumType, String name)方法则是用于根据指定的枚举类型和名称获取对应的枚举常量，允许在运行时动态解析枚举常量。\r\n这个方法提供了一种反射方式来获取枚举实例，尤其适用于在运行时动态确定枚举类型的场景。注意，它是静态方法，直接通过\r\nEnum.valueOf()\r\n调用，无需枚举实例。在明确枚举类型的情况下，推荐优先使用\r\nEnumType.valueOf(name) 以提高代码可读性和类型安全性。\r\n举一个例子\r\nenum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumValueOfExample &#123;    public static void main(String[] args) &#123;        // 方式一：直接通过枚举类调用 valueOf (更常用)        Season spring = Season.valueOf(&quot;SPRING&quot;);        System.out.println(&quot;直接调用: &quot; + spring); // 输出: SPRING        // 方式二：通过 Enum 类的静态方法 valueOf (反射方式)        Season summer = Enum.valueOf(Season.class, &quot;SUMMER&quot;);        System.out.println(&quot;反射调用: &quot; + summer); // 输出: SUMMER        // 错误示例：名称不匹配        try &#123;            Season invalid = Enum.valueOf(Season.class, &quot;summer&quot;); // 小写&quot;s&quot;        &#125; catch (IllegalArgumentException e) &#123;            System.out.println(&quot;错误: &quot; + e.getMessage());             // 输出: No enum constant Season.summer        &#125;    &#125;&#125;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n调用方式\r\n适用场景\r\n异常处理\r\n\r\n\r\n\r\n\r\nEnumType.valueOf(name)\r\n直接通过枚举类调用\r\n已知具体枚举类型时使用\r\n编译时检查类型\r\n\r\n\r\nEnum.valueOf(Class, name)\r\n通过 Enum 类反射调用\r\n运行时动态确定枚举类型\r\n需手动处理 ClassNotFoundException\r\n\r\n\r\n\r\nEnum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的，不妨看看Enum类的主要源码\r\n//实现了Comparablepublic abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;        implements Comparable&lt;E&gt;, Serializable &#123;    private final String name; //枚举字符串名称    public final String name() &#123;        return name;    &#125;    private final int ordinal;//枚举顺序值    public final int ordinal() &#123;        return ordinal;    &#125;    //枚举的构造方法，只能由编译器调用    protected Enum(String name, int ordinal) &#123;        this.name = name;        this.ordinal = ordinal;    &#125;    public String toString() &#123;        return name;    &#125;    public final boolean equals(Object other) &#123;        return this==other;    &#125;    //比较的是ordinal值    public final int compareTo(E o) &#123;        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;        Enum&lt;E&gt; self = this;        if (self.getClass() != other.getClass() &amp;&amp; // optimization            self.getDeclaringClass() != other.getDeclaringClass())            throw new ClassCastException();        return self.ordinal - other.ordinal;//根据ordinal值比较大小    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    public final Class&lt;E&gt; getDeclaringClass() &#123;        //获取class对象引用，getClass()是Object的方法        Class&lt;?&gt; clazz = getClass();        //获取父类Class对象引用        Class&lt;?&gt; zuper = clazz.getSuperclass();        return (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper;    &#125;    public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,                                                String name) &#123;        //enumType.enumConstantDirectory()获取到的是一个map集合，key值就是name值，value则是枚举变量值           //enumConstantDirectory是class对象内部的方法，根据class对象获取一个map集合的值               T result = enumType.enumConstantDirectory().get(name);        if (result != null)            return result;        if (name == null)            throw new NullPointerException(&quot;Name is null&quot;);        throw new IllegalArgumentException(            &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);    &#125;    //.....省略其他没用的方法&#125;\r\n枚举类与Class对象\r\n上述我们提到当枚举实例向上转型为Enum类型后，values()方法将会失效，也就无法一次性获取所有枚举实例变量，因为，values()是\r\n编译器自动生成\r\n的静态方法，而非java.lang.Enum类的原生方法，Enum类本身只定义了所有枚举共有的方法（如name()、ordinal()），并未包含values()。values()是枚举类的\r\n专属静态方法，而非继承自Enum。\r\n当你将枚举实例向上转型为Enum时：\r\nEnum&lt;?&gt; season = Season.SPRING;  // 向上转型为 Enum// season.values();  // 编译错误！Enum 类型没有 values() 方法\r\n\r\n静态绑定：Java 的方法调用在编译期会根据变量的\r\n声明类型（而非实际类型）进行绑定。由于season的声明类型是Enum，而Enum类没有values()方法，因此编译器直接报错。\r\n类型信息丢失：向上转型后，变量season的具体枚举类型（如Season）被擦除，编译器只知道它是一个Enum，无法访问子类特有的方法。\r\n\r\n虽然向上转型后无法直接调用values()，但是由于Class对象的存在，即使不使用values()方法，还是有可能一次获取到所有枚举实例变量的，在Class对象中存在如下方法：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n返回类型\r\n方法名称\r\n方法说明\r\n\r\n\r\n\r\n\r\nT[]\r\ngetEnumConstants()\r\n返回该枚举类型的所有元素，如果Class对象不是枚举类型，则返回null。\r\n\r\n\r\nboolean\r\nisEnum()\r\n当且仅当该类声明为源代码中的枚举时返回 true\r\n\r\n\r\n\r\nEnum&lt;?&gt; season = Season.SPRING;Class&lt;?&gt; enumClass = season.getDeclaringClass();  // 获取枚举的声明类（推荐使用该方法）if (enumClass.isEnum()) &#123;    // 使用 getEnumConstants() 直接获取枚举常量数组    Enum&lt;?&gt;[] enumConstants = enumClass.getEnumConstants();    System.out.println(Arrays.toString(enumConstants));  // 输出: [SPRING, SUMMER, AUTUMN, WINTER]&#125;\r\n实际上这里使用EnumSet.allOf()是更常见的做法\r\nEnum&lt;?&gt; season = Season.SPRING;Class&lt;? extends Enum&gt; enumType = season.getDeclaringClass();  // 获取枚举类型// 使用 EnumSet 获取所有枚举常量EnumSet&lt;?&gt; allConstants = EnumSet.allOf(enumType);System.out.println(allConstants);  // 输出: [SPRING, SUMMER, AUTUMN, WINTER]\r\nEnumSet等枚举类的容器\r\n在 Java 中，针对枚举类型（enum），Java\r\n集合框架提供了两个特殊的容器类：EnumSet和EnumMap。它们专门为枚举类型设计，具有高效的性能和简洁的\r\nAPI。\r\nEnumSet是Set接口的实现类，专门用于存储枚举类型的元素。它的设计充分利用了枚举类型的特性（元素数量固定、可枚举），因此性能远高于普通的HashSet或TreeSet。\r\n更多内容关于这些容器的原理涉及到的内容太多了，打算单开一帖详细说明。\r\nEnumSet 的特性\r\n\r\n元素唯一性：同Set接口，EnumSet中不允许重复元素。\r\n元素类型限制：只能存储同一枚举类型的元素（编译时检查）。\r\n有序性：元素的迭代顺序与枚举常量在枚举类中的定义顺序一致。\r\n高性能：底层通过位向量（bit-vector）实现（类似\r\n“位运算”），添加、删除、查找元素的时间复杂度均为O(1)。\r\n不可变实现：提供了noneOf()、allOf()等方法创建可变实例，也可通过copyOf()等方法创建不可变实例（JDK\r\n9+）。\r\n\r\n但是，EnumSet没有公共构造方法，需通过静态工厂方法创建：\r\n\r\nEnumSet.noneOf(Class&lt;E&gt; elementType)：创建一个空的EnumSet，指定枚举类型。\r\nEnumSet.allOf(Class&lt;E&gt; elementType)：创建包含指定枚举类型所有元素的EnumSet。\r\nEnumSet.of(E e1, E e2, ...)：创建包含指定枚举元素的EnumSet。\r\nEnumSet.range(E from, E to)：创建包含从from到to（含）的所有枚举元素的EnumSet。\r\nEnumSet.copyOf(Collection&lt;E&gt; c)：复制一个集合中的枚举元素到EnumSet（要求集合元素为同一枚举类型）。\r\n\r\nimport java.util.EnumSet;// 定义一个枚举类enum Day &#123;    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;public class EnumSetDemo &#123;    public static void main(String[] args) &#123;        // 创建包含所有星期的EnumSet        EnumSet&lt;Day&gt; allDays = EnumSet.allOf(Day.class);        System.out.println(allDays); // [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]        // 创建包含指定元素的EnumSet        EnumSet&lt;Day&gt; workDays = EnumSet.of(Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, Day.THURSDAY, Day.FRIDAY);        System.out.println(workDays); // [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY]        // 创建范围元素的EnumSet（从MONDAY到FRIDAY）        EnumSet&lt;Day&gt; rangeDays = EnumSet.range(Day.MONDAY, Day.FRIDAY);        System.out.println(rangeDays); // 与workDays结果相同        // 复制另一个EnumSet        EnumSet&lt;Day&gt; weekend = EnumSet.copyOf(EnumSet.of(Day.SATURDAY, Day.SUNDAY));        System.out.println(weekend); // [SATURDAY, SUNDAY]        // 检查元素是否存在        System.out.println(workDays.contains(Day.SUNDAY)); // false    &#125;&#125;\r\n而EnumMap是Map接口的实现类，专门用于以枚举类型为键（Key）的映射。它同样利用枚举的特性，提供了比HashMap更高的性能和更简洁的实现。\r\nEnumMap 的特性\r\n\r\n键类型限制：键必须是同一枚举类型的实例（编译时检查）。\r\n有序性：键的迭代顺序与枚举常量在枚举类中的定义顺序一致。\r\n高性能：底层通过数组实现（数组索引对应枚举常量的顺序），查找、插入、删除的时间复杂度为O(1)。\r\n非同步：线程不安全，如需同步可使用Collections.synchronizedMap()包装。\r\n\r\nEnumMap的构造方法需要指定枚举类型的Class对象：\r\n\r\nEnumMap(Class&lt;K&gt; keyType)：创建一个空的EnumMap，指定键的枚举类型。\r\nEnumMap(EnumMap&lt;K, ? extends V&gt; m)：复制另一个EnumMap。\r\nEnumMap(Map&lt;K, ? extends V&gt; m)：复制普通Map（要求键为同一枚举类型）。\r\n\r\n其他方法与普通Map类似（put()、get()、keySet()、values()等）。\r\nimport java.util.EnumMap;import java.util.Map;// 定义枚举类型（键）enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumMapDemo &#123;    public static void main(String[] args) &#123;        // 创建EnumMap，指定键的枚举类型        EnumMap&lt;Season, String&gt; seasonDesc = new EnumMap&lt;&gt;(Season.class);        // 添加键值对        seasonDesc.put(Season.SPRING, &quot;春暖花开&quot;);        seasonDesc.put(Season.SUMMER, &quot;夏日炎炎&quot;);        seasonDesc.put(Season.AUTUMN, &quot;秋高气爽&quot;);        seasonDesc.put(Season.WINTER, &quot;冬雪皑皑&quot;);        // 获取值        System.out.println(seasonDesc.get(Season.SUMMER)); // 夏日炎炎        // 遍历键值对（顺序与枚举定义一致）        for (Map.Entry&lt;Season, String&gt; entry : seasonDesc.entrySet()) &#123;            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());        &#125;        // 输出：        // SPRING: 春暖花开        // SUMMER: 夏日炎炎        // AUTUMN: 秋高气爽        // WINTER: 冬雪皑皑        // 获取所有键/值        System.out.println(seasonDesc.keySet()); // [SPRING, SUMMER, AUTUMN, WINTER]        System.out.println(seasonDesc.values()); // [春暖花开, 夏日炎炎, 秋高气爽, 冬雪皑皑]    &#125;&#125;\r\nEnumSet和EnumMap是 Java\r\n为枚举类型量身定制的容器，充分利用了枚举的 “元素数量固定、可枚举”\r\n特性，性能远高于普通集合。\r\nEnumSet适合存储枚举元素的集合，支持高效的集合操作；EnumMap适合以枚举为键的映射，支持按枚举顺序遍历。\r\n在涉及枚举类型的场景中，优先使用EnumSet和EnumMap，而非HashSet/HashMap，可提升性能并增强代码可读性。\r\n枚举的更多用法和深入理解\r\n关于覆盖enum类方法\r\n在 Java 中，enum（枚举）是一种特殊的类，它继承自\r\njava.lang.Enum\r\n类。与普通类一样，枚举类也可以覆盖父类的方法（主要是 Enum\r\n类中的方法），或者自定义方法并进行覆盖（如果有枚举子类的话，不过枚举类默认是\r\nfinal 的，一般不能被继承，所以更多是覆盖自身或父类的方法）。\r\n枚举类最常覆盖的方法来自 Enum 类，主要包括：\r\n\r\ntoString() 方法 Enum 类的\r\ntoString()\r\n默认返回枚举常量的名称（即声明时的标识符）。覆盖该方法可以返回更具可读性的描述。\r\nequals() 和 hashCode()\r\n方法 Enum 类已经实现了\r\nequals()（基于引用相等，因为枚举常量是单例）和\r\nhashCode()，通常无需覆盖。但如果有特殊需求（比如自定义相等逻辑），可以覆盖，但需遵循两者的一致性（相等的对象必须有相同的哈希码）。\r\nclone() 方法 Enum 类的\r\nclone() 被声明为 protected 且会抛出\r\nCloneNotSupportedException，目的是防止枚举常量被克隆（保证单例性），一般不建议覆盖。\r\ncompareTo() 方法 Enum\r\n类的 compareTo()\r\n基于枚举常量的声明顺序（自然顺序），如果需要自定义排序逻辑，可以覆盖。\r\n\r\ntoString()\r\n是最常被覆盖的方法，因为默认的枚举名称可能不够直观，覆盖后可以返回更友好的描述。\r\nenum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER;    // 覆盖 toString() 方法，返回中文描述    @Override    public String toString() &#123;        switch (this) &#123;            case SPRING: return &quot;春天&quot;;            case SUMMER: return &quot;夏天&quot;;            case AUTUMN: return &quot;秋天&quot;;            case WINTER: return &quot;冬天&quot;;            default: return super.toString(); // 兜底        &#125;    &#125;&#125;public class EnumDemo &#123;    public static void main(String[] args) &#123;        System.out.println(Season.SPRING); // 输出：春天（而非默认的 SPRING）        System.out.println(Season.SUMMER); // 输出：夏天    &#125;&#125;\r\n覆盖 equals() 和 hashCode()\r\n方法需要谨慎使用\r\nEnum 类的 equals() 实现为\r\npublic final boolean equals(Object other) &#123;    return this == other; // 基于引用相等（枚举常量是单例，每个常量仅一个实例）&#125;\r\nhashCode() 实现为\r\npublic final int hashCode() &#123;    return super.hashCode(); // 即 Object 的 hashCode()，基于对象地址&#125;\r\n由于枚举常量是单例的，== 和 equals()\r\n效果一致，通常无需覆盖。但如果有特殊需求（比如根据枚举的属性判断相等），可以覆盖，但需注意：\r\n\r\nequals() 必须满足自反性、对称性、传递性。\r\nhashCode() 必须与 equals()\r\n保持一致（相等的对象必须有相同的哈希码）。\r\n\r\n注意，枚举类默认继承 Enum，且 Java\r\n不支持多继承，因此枚举类不能继承其他类，但可以实现接口。枚举类的构造方法必须是\r\nprivate（默认也是 private），不能是 public 或\r\nprotected，防止外部创建实例（保证单例性）。\r\nenum 类中定义抽象方法\r\n与常规抽象类一样，enum类允许我们为其定义抽象方法，然后使每个枚举实例都实现该方法，允许每个枚举常量提供自己的方法实现，它使枚举类能够根据不同的常量表现出不同的行为。\r\n\r\n注意abstract关键字对于枚举类来说并不是必须的\r\n\r\n枚举类可以声明抽象方法，但必须由每个枚举常量立即实现这些抽象方法。这类似于匿名内部类的语法。\r\n每个枚举常量实际上是枚举类的一个实例，当枚举类包含抽象方法时，每个常量都必须实现该抽象方法，否则会导致编译错误。\r\nenum Operation &#123;    ADD &#123;        @Override        public double calculate(double a, double b) &#123;            return a + b;        &#125;    &#125;,    SUBTRACT &#123;        @Override        public double calculate(double a, double b) &#123;            return a - b;        &#125;    &#125;,    MULTIPLY &#123;        @Override        public double calculate(double a, double b) &#123;            return a * b;        &#125;    &#125;,    DIVIDE &#123;        @Override        public double calculate(double a, double b) &#123;            if (b == 0) throw new ArithmeticException(&quot;除数不能为零&quot;);            return a / b;        &#125;    &#125;;    // 声明抽象方法    public abstract double calculate(double a, double b);&#125;public class EnumDemo &#123;    public static void main(String[] args) &#123;        double a = 10, b = 5;                // 遍历所有枚举常量并调用其实现的抽象方法        for (Operation op : Operation.values()) &#123;            System.out.printf(&quot;%s: %.2f %s %.2f = %.2f%n&quot;,                               op.name(), a, op.getSymbol(), b, op.calculate(a, b));        &#125;    &#125;&#125;\r\n在枚举类中声明抽象方法（如\r\npublic abstract double calculate(double a, double b)），和其他的抽象方法一样无需提供方法体。但是每个枚举常量（如\r\nADD,\r\nSUBTRACT）必须实现该抽象方法。实现方式类似于匿名内部类，使用大括号\r\n&#123;&#125;\r\n包裹方法实现。如果某个枚举常量未实现抽象方法，编译器会报错。\r\n通过这种方式就可以轻而易举地定义每个枚举实例的不同行为方式。我们可能注意到，enum类的实例似乎表现出了多态的特性，可惜的是枚举类型的实例终究不能作为类型传递使用，就像下面的使用方式，编译器是不可能答应的\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","常用知识","语法知识","学习","JavaSE","语言方面"]},{"title":"Java注解与Annotation类","url":"/posts/54622.html","content":"了解注解\r\nJava 注解（Annotation）又称 Java 标注，是 JDK5.0\r\n引入的一种注释机制。是提供一种为程序元素设置元数据的方法，这些信息可以被编译器、开发工具或运行时环境读取和处理。\r\n（程序元素：接口、类、属性、方法等； 元数据：描述数据的数据）\r\n关键特性：\r\n\r\n注解本身不包含业务逻辑，但可以通过反射机制在运行时获取并处理\r\n注解不影响程序本身的执行，但可以通过工具影响程序的行为\r\n注解可以包含命名参数，这些参数可以有默认值\r\n\r\n其实就是写在接口、类、属性、方法上的一个标签，或者说是一个特殊形式的注释，普通注释只是一个注释，而注解在代码运行时是可以被反射读取并进行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。\r\nJava 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc\r\n不同，Java 标注可以通过反射获取标注内容。\r\n在编译器生成类文件时，标注可以被嵌入到字节码中。Java\r\n虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义\r\nJava 标注。\r\n可以利用注解来自定义一些实现，比如在某个方法上加一个自定义注解，就可以实现方法日志的自动记录打印\r\n举例@Override:\r\n它的作用是告诉阅读者(开发人员、编译器)这个方法重写了父类的方法，对于开发人员只是一个标志，然而编译器如果发现方法标注了这个注解，就会检查这个方法到底是不是真的覆写了父类的方法，如果没有会报错，而如果不添加@Override注解，程序也是可以正常运行的，不过缺乏了静态的检查\r\n在spring框架中加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。\r\n注意：注解不能直接干扰程序代码的运行\r\n注解的作用\r\n话说当年非常流行xml配置的。优点呢就是整个项目的配置信息集中在一个文件中，从而方便管理，是集中式的配置。缺点也显而易见，当配置信息非常多的时候，配置文件会变得越来越大不易查看管理，特别是多人协作开发时会导致一定的相互干扰。\r\n现在都提倡解耦、轻量化或者说微小化，那么注解就顺应了这一需求，各个包或模块在内部方法或类上使用注解即可实现指定功能，缺点呢就是不方便统一管理，如果需要修改某一类功能，则需要整体搜索逐个修改，是分散式的存在各个角落。\r\nxml的方式是集中式的元数据，不需要和代码绑定的，而注解是一种分散式的元数据设置方式。\r\n开发者的视角可以解读出这个类/方法/属性的作用以及该怎么使用，而从框架的视角则可以解析注解本身和其属性实现各种功能，编译器的角度则可以进行一些预检查(@Override)和抑制警告(@SuppressWarnings)等。\r\n\r\n作为特定标记，用于告诉编译器一些信息\r\n编译时动态处理，如动态生成代码\r\n运行时动态处理，作为额外信息的载体，如获取注解信息\r\n\r\nAnnotation架构\r\nJava 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在\r\njava.lang.annotation 中。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n其中\r\n\r\n1 个 Annotation 和 1 个 RetentionPolicy 关联。\r\n\r\n可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。\r\n\r\nRetentionPolicy\r\n是一个枚举类型，它定义了注解的保留策略，也就是规定了注解在什么阶段是可用的。\r\n\r\n\r\n1 个 Annotation 和 1~n 个 ElementType 关联。\r\n\r\n对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性\r\n\r\nAnnotation 有许多实现类，包括：Deprecated, Documented,\r\nInherited, Override 等等。\r\n\r\n每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于\r\nElementType 属性，则有 1~n 个。\r\n\r\n\r\nAnnotation 组成部分\r\njava Annotation 的组成中，有 3\r\n个非常重要的主干类。它们分别是：Annotation ElementType\r\nRetentionPolicy\r\npackage java.lang.annotation;public interface Annotation &#123;    // 当两个注解对象满足以下条件时，认为它们相等：注解类型相同  所有注解元素的值都相等    boolean equals(Object obj);    int hashCode();    // 将当前注解对象转换为字符串表示形式,字符串表示通常包含注解的类型名称和所有注解元素的值。    String toString();       // 获取当前注解对象的注解类型。注解类型是一个 Class 对象，它表示定义该注解的接口。    Class&lt;? extends Annotation&gt; annotationType();   &#125;\r\npackage java.lang.annotation;public enum ElementType &#123;    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */&#125;\r\npackage java.lang.annotation;public enum RetentionPolicy &#123;    SOURCE,   /*源码级 Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /*类文件级 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /*运行级 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125;\r\n其中：\r\n\r\nAnnotation这个接口中，每 1 个 Annotation 对象，都会有唯一的\r\nRetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\r\nElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。当\r\nAnnotation 与某个 ElementType\r\n关联时，就意味着：Annotation有了某种用途\r\n就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。\r\n\r\nAnnotation 通用定义\r\n@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125;\r\n上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。\r\n定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1”\r\n来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1\r\n的。\r\njava常用的Annotation\r\n@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented  -- @Documented 所标注内容，是否包含在用户文档中javadoc@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention   -- @Retention只能被用来标注“Annotation类型”，用来指定Annotation的RetentionPolicy属性作用域。@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。\r\nAnnotation 的作用\r\n编译检查\r\nAnnotation 具有”让编译器进行编译检查的作用”。\r\n例如\r\n\r\n@SuppressWarnings, @Deprecated 和 @Override\r\n都具有编译检查作用。\r\n若某个方法被 @Override\r\n的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override\r\n标示，但父类中却没有”被 @Override\r\n标注”的同名方法，则编译器会报错。\r\n\r\n\r\n\r\nimg\r\n\r\n我们可以发现 getString() 函数会报错。这是因为\r\ngetString() 被 @Override\r\n所标注，但在OverrideTest 的任何父类中都没有定义\r\ngetString() 函数”。\r\n反射中使用Annotation\r\n在反射的 Class, Method, Field 等函数中，有许多于 Annotation\r\n相关的接口。我们可以在反射中解析并使用 Annotation。\r\n/** * Annotation在反射函数中的使用示例 */@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String[] value() default &quot;unknown&quot;;&#125;/** * Person类。它会使用MyAnnotation注解。 */class Person &#123;        /**     * empty()方法同时被 &quot;@Deprecated&quot; 和 &quot;@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注      * (01) @Deprecated，意味着empty()方法，不再被建议使用     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;     */    @MyAnnotation    @Deprecated    public void empty()&#123;        System.out.println(&quot;\\nempty&quot;);    &#125;        /**     * sombody() 被 @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，     * @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;     */    @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)    public void somebody(String name, int age)&#123;        System.out.println(&quot;\\nsomebody: &quot;+name+&quot;, &quot;+age);    &#125;&#125;public class AnnotationTest &#123;    public static void main(String[] args) throws Exception &#123;                // 新建Person        Person person = new Person();        // 获取Person的Class实例        Class&lt;Person&gt; c = Person.class;        // 获取 somebody() 方法的Method实例        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]&#123;String.class, int.class&#125;);        // 执行该方法        mSomebody.invoke(person, new Object[]&#123;&quot;lily&quot;, 18&#125;);        iteratorAnnotations(mSomebody);                // 获取 somebody() 方法的Method实例        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]&#123;&#125;);        // 执行该方法        mEmpty.invoke(person, new Object[]&#123;&#125;);                iteratorAnnotations(mEmpty);    &#125;        public static void iteratorAnnotations(Method method) &#123;        // 判断 somebody() 方法是否包含MyAnnotation注解        if(method.isAnnotationPresent(MyAnnotation.class))&#123;            // 获取该方法的MyAnnotation注解实例            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);            // 获取 myAnnotation的值，并打印出来            String[] values = myAnnotation.value();            for (String str:values)                System.out.printf(str+&quot;, &quot;);            System.out.println();        &#125;                // 获取方法上的所有注解，并打印出来        Annotation[] annotations = method.getAnnotations();        for(Annotation annotation : annotations)&#123;            System.out.println(annotation);        &#125;    &#125;&#125;\r\n注解的分类\r\n通常来说注解分为以下三类\r\n\r\n元注解 – java内置的注解，标明该注解的使用范围、生命周期等。\r\n标准注解 –\r\nJava提供的基础注解，标明过期的元素/标明是复写父类方法的方法/标明抑制警告。\r\n自定义注解 – 第三方定义的注解，含义和功能由第三方来定义和实现。\r\n\r\n元注解\r\n用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。\r\n元注解就是最基本不可分解的注解，我们不能去改变它只能使用它来定义自定义的注解。\r\n元注解包含以下五种： @Retention、@Target、@Documented、@Inherited、@Repeatable\r\n@Retention\r\n定义\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    RetentionPolicy value();&#125;\r\n标明自定义注解的生命周期，这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。它决定了注解在何时有效以及在何处可用。\r\n从编写Java代码到运行主要周期为源文件→\r\nClass文件 → 运行时数据，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为SOURCE\r\n→CLASS→RUNTIME。 -\r\nSOURCE：源代码java文件，不会包含在编译后的 class 文件中，编译时候会丢弃\r\n-\r\nCLASS：类文件级别保留，class文件中会保留注解，但是jvm加载运行时就没有了，是默认的保留策略\r\n-\r\nRUNTIME：运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的\r\n各个生命周期的用途：\r\n\r\nSOURCE级别：\r\n\r\n典型应用：Lombok的@Getter、@Setter\r\n特点：编译后完全消失，不会增加运行时负担\r\n使用场景：仅用于编译期检查或代码生成\r\n\r\nCLASS级别：\r\n\r\n典型应用：Android的@Keep注解\r\n特点：保留到class文件但不会被加载到JVM\r\n使用场景：字节码分析工具使用\r\n\r\nRUNTIME级别：\r\n\r\n典型应用：Spring的@Controller、@Service\r\n特点：可通过反射获取，影响运行时行为\r\n使用场景：框架开发中最常用\r\n\r\n\r\n// Lombok的@Getter示例 SOURCE级别@Retention(RetentionPolicy.SOURCE)public @interface Getter &#123;    AccessLevel value() default AccessLevel.PUBLIC;&#125;// 使用@Getterpublic class User &#123;    private String name;&#125;// 编译时会生成getName()方法，但注解本身不会保留\r\n@Target\r\n描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上(类、方法、属性、局部属性、参数…)\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    ElementType[] value();&#125;\r\nvalue是一个数组，可以有多个取值，说明同一个注解可以同时用于标注在不同的元素上。value的取值如下\r\n@Target可以指定更精确的应用目标，包括：\r\n@Target(&#123;    ElementType.TYPE,               // 类、接口、枚举    ElementType.FIELD,              // 字段（包括枚举常量）    ElementType.METHOD,             // 方法    ElementType.PARAMETER,          // 方法参数    ElementType.CONSTRUCTOR,        // 构造器    ElementType.LOCAL_VARIABLE,     // 局部变量    ElementType.ANNOTATION_TYPE,    // 注解类型    ElementType.PACKAGE,            // 包    ElementType.TYPE_PARAMETER,     // 类型参数（Java 8+）    ElementType.TYPE_USE            // 类型使用（Java 8+）&#125;)\r\n自定义一个注解@MyAnnotation1想要用在类或方法上，就可以如下定义\r\n/**    * 自定义注解，使用@Target指定该注解可以应用在哪些元素上    * 这里指定了TYPE(类/接口/枚举等)和METHOD(方法)上    */   @Retention(RetentionPolicy.RUNTIME)    // 运行时保留   @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)  // 只能用于类和方法上   public @interface MyAnnotation &#123;       String description() default &quot;&quot;;   // 注解属性默认值   &#125;   /**    * 测试类，演示@Target的使用    * 因为@MyAnnotation允许用在TYPE上，所以可以用在类声明上    */   @MyAnnotation(description = &quot;这是一个类级别的注解示例&quot;)   public static class AnnotationTest &#123;       // @MyAnnotation   用在属性上则会报错       public String name;       @MyAnnotation(description = &quot;这是一个方法级别的注解示例&quot;)       public void testMethod() &#123;           System.out.println(&quot;测试方法执行&quot;);       &#125;   &#125;\r\n获取其中的注解，只能获取到类和方法上的\r\npublic static void main(String[] args) &#123;        // 获取类上的注解        MyAnnotation classAnnotation = AnnotationTest.class.getAnnotation(MyAnnotation.class);        System.out.println(classAnnotation.description());        try&#123;            // 获取方法上的注释            Method method = AnnotationTest.class.getMethod(&quot;testMethod&quot;);            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);            System.out.println(annotation.description());        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;\r\n@Inherited\r\n表示是否可以被标注类的子类继承。当注解 Inheritable 被 @Inherited\r\n标注时，它具有继承性。否则，没有继承性。\r\n定义如下\r\n@Documented   // 说明该注解能出现在 javadoc 中。@Retention(RetentionPolicy.RUNTIME)   // 指定 Inherited 的策略是 RetentionPolicy.RUNTIME@Target(ElementType.ANNOTATION_TYPE)  // @Inherited 只能被用来标注 &quot;Annotation 类型&quot;// 它的用来修饰 Inherited，意味着 Inherited 实现了 Annotation 接口；即 Inherited 就是一个注解。public @interface Inherited &#123;    &#125;\r\n当一个类使用了带有 @Inherited\r\n的注解时，这个注解会被该类的子类继承。\r\n\r\n仅对类注解有效：@Inherited\r\n只对类级别的注解有效（即注解的 @Target 包含\r\nElementType.TYPE）\r\n不适用于接口：从父类继承的注解不会应用于实现接口的类\r\n不适用于方法等其他元素：方法上的注解不会被继承\r\n\r\n\r\n示例，通过反射获取注解\r\n// 定义一个可以被继承的注释@Inherited@Retention(RetentionPolicy.RUNTIME)  // 运行时保留，可以通过反射获取@Target(ElementType.TYPE)  // 只能用于类/接口/枚举上@interface InheritableAnnotation &#123;    String value() default &quot;父类注解&quot;;&#125;// 定义一个不可被继承的注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface NonInheritableAnnotation &#123;    String value() default &quot;不可继承的注解&quot;;&#125;// 父类，带有可继承和不可继承的注解@InheritableAnnotation(&quot;这是父类的可继承注解&quot;)@NonInheritableAnnotation(&quot;这是父类的不可继承注解&quot;)class ParentClass &#123;&#125;// 子类，继承自ParentClass，没有显式添加任何注解class ChildClass extends ParentClass &#123;&#125;\r\n打印注解的信息后可以发现：\r\n类 ParentClass 上的注解:  InheritableAnnotation:   NonInheritableAnnotation: 类 ChildClass 上的注解:  InheritableAnnotation: \r\n发现ChildClass 类没有继承\r\nNonInheritableAnnotation 注解\r\n@Repeatable\r\n定义如下\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123;    // 指定包含重复注解的容器注解类型    Class&lt;? extends Annotation&gt; value();&#125;\r\n标识某注解可以在同一个声明上使用多次。（Java 8+特性）\r\n示例：\r\n// 定义可重复注解@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;// 定义包含可重复注解的容器注解@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations &#123;    MyAnnotation[] value();&#125;// 使用可重复注解@MyAnnotation(&quot;First Annotation&quot;)@MyAnnotation(&quot;Second Annotation&quot;)class MyClass &#123;    // 类的内容&#125;public class RepeatableExample &#123;    public static void main(String[] args) &#123;        // 普通的获取类上的所有 MyAnnotation 注解        // 需要定义容器注解来存放重复注解        // 通过getAnnotationsByType()获取重复注解        MyAnnotation[] annotations = MyClass.class.getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation annotation : annotations) &#123;            System.out.println(annotation.value());        &#125;        // 使用MyAnnotations，获取类上的 MyAnnotations 注解        MyAnnotations container = MyClass.class.getAnnotation(MyAnnotations.class);        if (container != null) &#123;   // 语法糖，相当于是返回一个MyAnnotation[]            for (MyAnnotation annotation : container.value()) &#123;                System.out.println(annotation.value());            &#125;        &#125;    &#125;&#125;\r\n虽然我们标注的是多个@MyAnnotation，其实会给我们返回一个@MyAnnotations，相当于是Java帮我们把重复的注解放入了一个数组属性中\r\n@Documented\r\n定义如下\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\r\n标记注解是否包含在Javadoc中。被@Documented标注的注解会出现在生成的API文档里。\r\n\r\n无参数\r\n只影响文档生成\r\n常用于重要的API注解\r\n\r\n根据 Annotation 生成帮助文档：\r\n通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation\r\n标签出现在 javadoc 中。\r\n标准注解\r\n@Override\r\n定义\r\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\r\n标识方法覆写了父类或接口中的方法，提供编译时检查。\r\n\r\n仅用于方法\r\n编译时检查（非强制使用）\r\n源代码级别（不保留到class文件）\r\n可防止拼写错误导致意外创建新方法\r\n\r\n支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD,\r\nPACKAGE, PARAMETER, TYPE\r\n这个天天用，估计大伙都会都知道，很多人注解学习的起步就是@Override\r\n@Deprecated\r\n某个方法被 @Deprecated\r\n标注，则该方法不再被建议使用\r\n如果有开发人员试图使用或重写被 @Deprecated\r\n标示的方法，编译器会给相应的提示信息\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n定义如下\r\n@Documented  // 会出现在doc中@Retention(RetentionPolicy.RUNTIME)   // 指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。// @interface -- 它的用来修饰 Deprecated,即 Deprecated 就是一个注解public @interface Deprecated &#123;&#125;\r\n@SuppressWarnings\r\n让编译器对”它所标注的内容”的某些警告保持静默。\r\n\r\n\r\nimage-20250414173247356\r\n\r\n定义如下\r\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();  // SuppressWarnings 能指定参数&#125;\r\n@FunctionalInterface\r\n用于标识函数式接口\r\n定义：\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125;\r\n使用示例 @FunctionalInterfaceinterface Greeter &#123;    void greet(String name);        // 可以有默认方法    default void defaultGreet() &#123;        System.out.println(&quot;Hello, world!&quot;);    &#125;&#125;\r\n编译时会检查是否确实是函数式接口\r\n如果不是（有多个抽象方法），会报错\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","学习","JavaSE","语言方面"]},{"title":"Java难绷知识01之对象流","url":"/posts/54621.html","content":"Java难绷知识01之对象流\r\n本篇文章会探讨一些JavaIO流中比较容易被忽视的对象流，而且会相对的探讨其中的一些细节\r\n其中对于对象流的操作讲解会少一些，主要讨论的是一些细节\r\n在 Java IO 流中，对象流（ObjectInputStream对象输入流 和\r\nObjectOutputStream对象输出流）用于将对象进行序列化和反序列化操作\r\n对象流及其序列化\r\n首先，ObjectInputStream和ObjectOutputStream这两个类都属于是字节流，它们分别继承自InputStream和OutputStream\r\n对象输出流，ObjectOutputStream，用于对象的序列化，也就是把Java对象转换成字节序列，把字节序列写出到文件，以这种对象转换为字节序列的机制实现了对象存储\r\n序列化目的是能够将整个 Java\r\n对象（包括对象的状态，即成员变量的值）转换为字节流，以便在网络上传输或存储到文件中，之后还能稳定的从字节流中恢复出原来的对象。\r\n通过序列化，对象的状态信息（包括成员变量的值）可以被保存下来，以便后续传输或存储。\r\n对象输入流，ObjectInputStream，用于对象的反序列化，是将文件中的字节序列恢复为Java对象，以这种字节序列转换为对象的机制实现了对象读取\r\n反序列化时，系统会根据字节流中的信息重新构建对象的状态。\r\n\r\n在其基础上，我们再探讨序列化的一些细节\r\n对象序列化的条件\r\n要想使一个类的对象能够被序列化，该类必须实现 java.io.Serializable\r\n接口\r\n这是一个标记接口，没有任何方法需要实现。实现该接口，意味着告诉 Java\r\n虚拟机这个类的对象可以被序列化。\r\n\r\n\r\n点击查看代码\r\n\r\nimport java.io.*;// 定义一个实现Serializable接口的类class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;public class SerializationExample &#123;    public static void main(String[] args) &#123;        // 创建一个对象        Person person = new Person(&quot;Alice&quot;, 30);        // 序列化对象到文件        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) &#123;            oos.writeObject(person);            System.out.println(&quot;对象已成功序列化到文件 person.ser&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 从文件反序列化对象        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) &#123;            Person deserializedPerson = (Person) ois.readObject();            System.out.println(&quot;反序列化后的对象: &quot; + deserializedPerson);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n注意：\r\n每个可序列化的类都应该有一个serialVersionUID，用于验证序列化和反序列化过程中的版本兼容性\r\n使用transient关键字声明的成员变量不会被序列化\r\n序列化可能会引发安全问题\r\n对象流的使用细节\r\n对象流需要关闭吗\r\n先说结论，可以不关\r\n但是强烈建议关闭。这与 Java 流的资源管理机制紧密相关。\r\n涉及到对外部资源的读写操作，包括网络、硬盘等等的I/O流，如果在使用完毕之后不关闭，会导致资源泄漏以及可能会引起文件锁定等问题。\r\n当我们使用流进行数据操作时，它们会占用系统资源，如文件句柄、网络连接等。如果不关闭流，这些资源将不会被释放，可能导致资源泄漏问题。长时间运行的程序如果频繁出现资源泄漏，最终可能耗尽系统资源，导致程序崩溃或系统性能严重下降。\r\n而且关闭流可以确保所有已写入的数据被正确地传输到目标位置 例如，当使用\r\nObjectOutputStream\r\n将对象写入文件时，关闭流会保证缓冲区中的所有数据都被写入文件，避免数据丢失。\r\n通常建议使用try - with - resources语句来自动关闭流，示例代码如下\r\n\r\n\r\n\r\n示例代码\r\n\r\nimport java.io.*;class MyClass implements Serializable &#123;    private static final long serialVersionUID = 1L;    int data;    public MyClass(int data) &#123;        this.data = data;    &#125;&#125;public class SerializeExample &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass(42);        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myfile.ser&quot;))) &#123;            oos.writeObject(obj);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n对象流需要使用flush吗\r\n先说结论，不用\r\nObjectOutputStream内部维护了一个缓冲区。在调用writeObject方法时，数据首先会被写入缓冲区。调用flush方法可以强制将缓冲区中的数据立即写入底层输出流。然而，在大多数情况下，并不需要显式调用flush。因为当缓冲区满、流关闭或者调用某些特定方法（如writeObject在某些情况下会触发缓冲区数据的刷新）时，缓冲区的数据会自动被写入底层流。\r\n当然特意需要弄的时候可以弄\r\nserialVersionUID在对象流中的必要性\r\n凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量：\r\nprivate static final long serialVersionUID;\r\n来表明类的不同版本间的兼容性。\r\n在完成序列化操作后，如果对序列化对象进行了修改，那么我们再进行反序列化就会抛出InvalidClassException异常。\r\n因为serialVersionUID缺失（没有显式分配）或者serialVersionUID发生了变化，\r\nserialVersionUID的作用在此体现——对序列化对象进行版本控制，有关各版本反序加化时是否兼容。避免混乱。\r\nclass Person implements Serializable &#123;    private static final long serialVersionUID = 1234567890123456789L;    private String name;    private int age;    // 后续可以安全地对类结构进行一些兼容的修改&#125;\r\n一个类在没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。\r\n若类的实例变量做了修改，serialVersionUID\r\n可能发生变化。所以建议一般显式声明。\r\n序列化的一些细节\r\nstatic修饰的属性 不可以被序列化\r\n原因在于 static\r\n变量属于类，而不是类的实例。它们是类级别的共享数据，与对象的状态无关。\r\n序列化的目的是保存对象的状态，所以 static\r\n变量不会被包含在序列化的内容中。 class StaticExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private static int sharedValue = 10;    private int instanceValue;    public StaticExample(int instanceValue) &#123;        this.instanceValue = instanceValue;    &#125;&#125; 当我们序列化\r\nStaticExample 类的对象时，sharedValue 不会被序列化。\r\n在反序列化时，sharedValue\r\n的值将取决于类加载时的初始化状态，而不是序列化时的值\r\ntransient 修饰的属性不可以被序列化 transient\r\n关键字用于标记那些不希望被序列化的属性。\r\n这在某些场景下非常有用，比如当对象的某个属性包含敏感信息（如密码）或者该属性在反序列化后可以通过其他方式重新计算得到时。\r\nclass TransientExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String username;    private transient String password;    public TransientExample(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;&#125; 当对 TransientExample 对象进行序列化时，password\r\n的值不会被写入序列化流。这样可以保护敏感信息，防止其在序列化过程中被泄露。在反序列化后，password\r\n属性的值将为 null，程序可以重新设置该值。\r\n对象序列化的作用\r\n为什么JavaIO流要特意造出这么一个IO流\r\n当你需要把对象写入到文件或者读取的时候，其实我们更多的情况通常是保存对象的有效值字段，也就是对象的具体实例的字段，那么使用文件操作流FileOutputStream和字符输出流BufferedWriter或PrintStream就足够。这些流可以用于处理文件写入和基本数据类型及字符串的输出，但对象序列化有着独特且不可替代的作用\r\n网络传输对象\r\n对象序列化机制是Java内建的一种对象持久化方式，可以很容易实现在JVM中的活动对象与字节流之间进行转换\r\n在网络传输中，发送端将对象序列化成字节流，经过网络传输到网络的另一端，可以从字节流重新还原为对象，这个特点使得在进行端到端的网络传输数据时候，字节流和Java对象之间的转换稳定且快速。\r\n在其中分布式系统中，不同的节点之间需要进行对象的传递，对象序列化使得这种对象传输变得简单直接，确保了对象在不同\r\nJava 虚拟机之间的准确传输，即使这些 JVM 运行在不同的操作系统上。\r\nRMI 是 Java 的一种远程方法调用机制，它允许一个 JVM 中的对象调用另一个\r\nJVM 中的对象的方法。对象序列化也在其中起着关键作用\r\n确保对象深层次的复制和持久化\r\n当对一个对象进行序列化然后反序列化时，会得到一个与原对象状态完全相同但内存地址不同的新对象。可以实现在不影响原对象的情况下对对象进行操作，多线程下的数据处理的机制也有一定序列化和反序列化的影子。\r\n这种情况对于远程创建对象副本并且调度的时候十分方便，而且不会干扰对象内部包含的复杂的引用关系，合理使用对象流可以大大提高程序处理复杂数据的能力。\r\n在很多情况下，对象内部状态是需要被持久化的，序列化通过把对象写为字节流，保存的位置从JVM内存转移到文件系统，在需要的时候随时可以进行快速方便的还原\r\n例如：在一个游戏中，可以使用对象流将玩家的游戏进度（一个复杂的对象，包含玩家角色信息、游戏关卡等）保存到文件中，下次玩家启动游戏时可以恢复到上次的进度。\r\n对象流与其他流的关系\r\n与字节流的关系\r\n字符流是对象流的特例，它们处理的是字符数据的序列化和反序列化。\r\n字符流（Reader 和 Writer 及其子类，如 BufferedReader、BufferedWriter\r\n等）主要用于处理字符数据。Java 采用 Unicode\r\n编码来表示字符，字符流对其的输入输出有优化。而且字符流在处理数据时，会根据指定的字符编码进行字节和字符之间的转换\r\n而对象流可以将任何实现了 Serializable\r\n接口的对象进行序列化和反序列化，意味着对象流操作的数据是复杂的对象结构，包括对象的成员变量、对象之间的引用关系。\r\n##### 与缓冲流的关系 功能叠加：缓冲流（如\r\nBufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter）的主要作用是提高数据读写的效率，通过在内存中设置缓冲区，减少实际的\r\nI/O 操作次数。\r\n对象流可以和缓冲流结合使用，以提升对象序列化和反序列化的性能。\r\n可以将 ObjectOutputStream 包装在 BufferedOutputStream\r\n中，这样在写入对象时，数据会先写入缓冲区，当缓冲区满或流关闭时，才会一次性将数据写入底层输出流，从而减少磁盘\r\nI/O 操作的频率，提高写入效率。\r\n在处理大量对象的序列化或反序列化时，结合缓冲流能显著提升性能。不过反序列化涉及到的种种安全关系，这种情况，讨论一下就好。\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","学习","JavaSE","语言方面"]},{"title":"Java难绷知识02-抽象类中只能有或者必须有抽象方法吗以及抽象类的细节探讨","url":"/posts/44268.html","content":"Java难绷细节02—抽象类中只能有抽象方法吗\r\n首先回答标题抛出的问题——False\r\n显然，有抽象方法的类是抽象类，但是，抽象类中只能有抽象方法吗？\r\n抽象类可以包含抽象方法，也可以包含具体方法\r\n如果一个类包含至少一个抽象方法，用abstract关键字修饰，那么这个类必须被声明为抽象类。\r\n抽象类除了可以有抽象方法外，还可以包含具体的方法，即有方法体的方法。\r\n一个类用abstract修饰，那它就是抽象类了，但是不是说抽象类中必须有抽象方法，如果一个类像接口那样所有方法都有具体的实现，也可以用abstract修饰为抽象类\r\n那么反过来想，抽象方法只能写在抽象类中，但是抽象类中不一定要有抽象方法\r\n一个包含了抽象方法和具体方法的抽象类 public abstract class Shape &#123;    // 抽象方法    public abstract double getArea();    // 具体方法    public void displayInfo() &#123;        System.out.println(&quot;This is a shape.&quot;);    &#125;&#125; abstract class AbstractParent &#123;    // 具体方法    public void printMessage() &#123;        System.out.println(&quot;This is a message from AbstractParent.&quot;);    &#125;&#125;// 子类继承抽象类，非抽象子类需要实现抽象方法class Child extends AbstractParent &#123;    // 子类可以直接使用父类的具体方法，根据需要重写    @Override    public void printMessage() &#123;        System.out.println(&quot;This is a message from Child, overriding the parent method.&quot;);    &#125;&#125;\r\n另外，如果一个抽象类并没有包含任何抽象方法，那么它的子类即使不实现任何方法也是非抽象类\r\n总之，抽象类是一种特殊的类，它的存在主要是为了提供一个通用的框架或基类，让其他子类去继承和实现具体的功能，抽象类可以包含抽象方法和具体方法，但是有抽象方法的类必须是抽象类\r\n如果我这篇博客就说这一点东西就有种，“因为这点事就把大伙叫过来？”的蹩脚感觉\r\n于是我们接着探讨一些抽象类中的各种令人很难绷的住的细节\r\n为什么要有抽象类\r\n这个问题尽管乍看之下对实际开发的直接引导作用并非立竿见影，但深入剖析其中缘由，能让我们对\r\nJava\r\n语言的设计理念和面向对象编程的本质有更为透彻的理解（也能让我说出更多东西）\r\n抽象类和抽象方法的产生是为了维护继承链的逻辑，即抽象类相对于那些普通的类处于继承树的根部。抽象类和抽象方法的诞生，很大程度上是为了维护继承体系的逻辑完整性与合理性\r\n首先，类用于描述现实生活中一类事物。类中有属性、方法等成员\r\n那么，抽象类中，有用的就是方法的声明，方法主体存在的意义被弱化，这种情况下十分适合用于取规范一个子类应该具备一个怎样的方法，既可以定义需要子类去实现的抽象行为，以满足不同子类的个性化需求，又能实现一些通用的行为或属性，让子类能够共享这些功能，从而提高代码的复用性和可维护性。\r\n但是，抽象类中的非抽象方法如同在非抽象类中一样，正常继承使用。\r\n所以，抽象类通常用于作为其他类的父类，用来定义一些需要子类去实现的抽象行为\r\n主要目的是为了阻止其他类直接实例化这个类，同时为其子类提供一个通用的基类框架，用于实现一些通用的行为或属性。\r\n抽象类可以设计模板模式，其中的某些步骤由抽象方法表示，具体的实现留给子类，大大增加了可读性和简便程度。\r\n抽象类可以用于定义一组相关类的通用接口规范，通过抽象类，我们可以确保所有相关类都具有特定的行为，同时又允许它们根据自身特性进行个性化实现。\r\n抽象方法\r\n抽象方法只有方法声明，没有方法体（有爆Error），并且必须使用 abstract\r\n关键字修饰。 public abstract class Shape &#123;    public abstract double getSquare();&#125; #### 抽象方法的特点\r\n- 抽象方法必须存在于抽象类中 -\r\n包含抽象方法的类必须被声明为抽象类。这样做的目的是为了确保抽象方法不会被意外调用，因为抽象方法本身没有实际的执行代码，实例化该类时就可能调用到没有实现的方法，这会导致运行时错误。\r\n\r\n所有子类都需要实现抽象类中的抽象方法，除非子类本身也是抽象类。\r\n\r\n抽象类定义了一种抽象的概念，其中的抽象方法是这种概念下未完成的行为。子类继承抽象类，就继承了这种抽象概念及其未完成的行为。如果子类不实现抽象方法，那么这个子类仍然是不完整的，因为它没有完成抽象类中定义的行为。\r\n\r\n强制子类实现\r\n\r\n这个没啥好说的，当一个类继承自包含抽象方法的抽象类时，除非子类本身也是抽象类，否则它必须实现父类中的所有抽象方法。这是保证行为一致性的重要手段。\r\n\r\n\r\nabstract class Shape &#123;    public abstract double getArea();&#125;// 子类本身是抽象类，可以不实现getArea方法abstract class ThreeDShape extends Shape &#123;    // 这里没有实现getArea方法，因为ThreeDShape是抽象类&#125;class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\r\n\r\n抽象方法不能用private、final、static、native修饰。\r\n\r\n抽象方法不能被声明为\r\nstatic，静态方法属于类本身，而不是类的实例，而抽象方法的实现依赖于具体的子类实例。如果将抽象方法声明为静态，就无法通过子类实例来提供具体的实现。来回的限制区域错误会导致无法通过子类实例来提供具体的实现\r\nprivate修饰的成员只能在本类中访问，抽象方法的设计目的是为了让子类去实现，矛盾\r\nfinal修饰的方法不能被子类重写。如果一个方法同时被abstract和final修饰，就会产生矛盾\r\nnative方法表示该方法的实现是由本地代码提供的，Java\r\n本身不包含该方法的实现。抽象方法没有实现，就会出现冲突\r\n\r\n\r\n抽象类的一些各种细节\r\n1、抽象类不能被实例化\r\n首先抽象类是不能实例化的类\r\n抽象类存在的意义是作为一种抽象概念，为子类提供一个通用的框架，可能包含一些尚未具体实现的抽象方法，这些方法需要子类去实现\r\n如果抽象类可以被实例化，就可能调用到未实现的抽象方法，导致运行时错误\r\nabstract class Galgame &#123;    public abstract void run();&#125;\r\n如果允许Galgame被实例化，如Galgame galgame = new Galgame();\r\n当调用galgame.run()时，由于run方法没有具体实现，就会出现问题\r\n2、abstract不能static\r\n抽象方法可以使用 public 或 protected\r\n作为访问修饰符，但是static不行\r\n再次强调，抽象方法是一种只有声明没有实现的方法，需要子类去重写实现。它依赖于具体的子类实例来确定具体的行为。\r\n而静态方法属于类本身的方法，不依赖于任何类的实例，是通过类名直接调用。在类加载时就已经确定，其生命周期与类的生命周期相同。\r\n如果一个方法同时被abstract和static修饰，就会产生矛盾。\r\n因为抽象方法没有具体实现，不能直接调用。只有在创建了子类的实例，并将其赋值给父类类型的引用变量后，通过该引用变量调用抽象方法时，才会执行子类中重写的具体实现。而静态方法不依赖于实例，在类加载时就可调用，这样会导致内存的顺序出现问题，因为静态方法不依赖于对象实例，而抽象方法却依赖子类实例来提供具体实现\r\n反证法，如果是静态抽象方法，那么在类加载时就可调用，但此时由于它是抽象的，没有具体实现，调用必然出错。\r\n3、抽象类的构造器\r\n抽象类可以有构造器\r\n虽然抽象类不能被直接实例化，但它的构造器用于被子类调用\r\n因为抽象类中是可以有成员变量的\r\n当创建子类对象时，会先调用抽象类的构造器，然后再调用子类的构造器。这确保了在子类对象初始化之前，从抽象类继承的部分已经被正确初始化。\r\n4、可以有成员变量\r\n抽象类可以有成员变量的原因是抽象类中的成员变量可以用于存储子类共享或需要继承的状态信息，如果子类需要，抽象父类可以提供\r\n成员变量的访问控制：与普通类一样，抽象类中的成员变量可以有不同的访问修饰符\r\nabstract class Vehicle &#123;    private int wheels;    protected String color;    public int speed;    Vehicle(int wheels, String color, int speed) &#123;        this.wheels = wheels;        this.color = color;        this.speed = speed;    &#125;    public int getWheels() &#123;        return wheels;    &#125;    public abstract void move();&#125;class Car extends Vehicle &#123;    public Car(int wheels, String color, int speed) &#123;        super(wheels, color, speed);    &#125;    @Override    public void move() &#123;        System.out.println(&quot;The &quot; + color + &quot; car is moving.&quot;);    &#125;&#125;\r\n5、继承抽象类的抽象子类问题\r\n如果一个类继承自抽象类，但它本身也是抽象类，那么它可以选择不实现父类的抽象方法\r\nabstract class Shape &#123;    public abstract double getArea();&#125;abstract class ThreeDShape extends Shape &#123;    // 可以不实现getArea方法，因为ThreeDShape本身是抽象类&#125;// 而 Sphere 类继承自 ThreeDShape，作为具体类，它必须实现 getArea 方法。class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\r\n抽象类跟接口\r\n包括我而言，很多人不禁疑惑，为什么有了抽象类，还要干出一个接口来？？\r\n这俩都是一定程度上规范子类的方法，功能一眼看过去差不多\r\n这个我打算写一篇详细的文章，但是算了，没啥时间））我还要推gal，而且这不是一个需要长篇大论的问题，在这里和大家简单探讨一下\r\n其实是很简单的问题，但凡遇到了两种东西，功能很相似，通常情况就是这几种：使用场景不同，产生的最终结果不同，兼容性与更优性问题。\r\n突破继承限制与灵活性\r\n在 Java\r\n中，一个类只能继承一个直接父类。这是为了避免多重继承带来的诸如继承混乱问题（什么哈斯图，我正好在看离散）\r\n而接口则打破了这种限制，一个类可以实现多个接口。这使得类能够从多个不同的\r\n“行为集合”\r\n中获取规范，灵活性极大up，使得子类更好的拥有多种行为能力。\r\n功能侧重点差异\r\n抽象类虽然可以包含抽象方法，但也能有具体的属性和方法实现。这意味着抽象类在一定程度上仍然保留了对具体实现细节的描述。这是根据子类的需要，抽象类并不特别死的限制会带来很多方便和意想不到的特别之处\r\n接口是一种完全抽象的类型，它只包含抽象方法（Java 8\r\n及之后版本可包含默认方法和静态方法，但是本质绝对不会因为这个改动而改变），没有任何成员变量，只关注行为的定义，不涉及任何细节，只做出最少最需要的方法约束，更加纯粹地体现了一种行为规范，而且不用不行。\r\n场景差异\r\n当多个类之间存在一些共同的属性和行为，并且这些共同部分可以在抽象类中进行部分实现时，适合使用抽象类。也就是对于很多个类中，我抽象出了一些共有属性实现了一个类，之后的符合该属性的类，就按照抽象类的规定来实现。与行为约束相比，更偏向共性总结。\r\n而当需要为不相关的类添加一些通用行为时，接口更为合适。也就是接口这是一个规矩，有什么类需要实现这个规矩，我就用接口来规范它。\r\n扩展性差异\r\n如果在抽象类中添加新的方法，可能需要在所有子类中实现该方法，这对于已经存在的大量子类来说，维护成本较高，一个个改会比较累。\r\n对于接口，如果添加新的方法，（在 Java 8\r\n之前，实现该接口的类不会受到影响（除非强制要求实现新方法）），那么实现该接口的类会分为两种，一个是完全实现了接口的类，一个是未完全实现了接口的类。在\r\nJava 8\r\n及之后，新增的默认方法有了默认实现，实现接口的类可以选择是否重写这些默认方法，这使得接口在扩展时对已有实现类的影响较小，更易于维护和扩展。\r\n\r\n文章个人编辑较为匆忙，需要大家积极反馈来帮助这篇文章和我的更进一步\r\nQQ：1746928194，是喜欢画画的coder，欢迎来玩！\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","学习","JavaSE","语言方面"]},{"title":"Java难绷知识04--异常处理中的finally块","url":"/posts/683.html","content":"Java难绷知识04——异常处理中的finally块\r\n前情提要：该文章是个人花的时间最长，查询资料最多，可能是有关finally块的最长文章，希望大家能看下去\r\n一些前言\r\n在Java中，异常处理机制是程序设计中至关重要的一部分。它允许程序员在程序运行时捕获并处理错误，防止程序因为异常情况而突然崩溃。\r\ntry - catch -\r\nfinally结构是异常处理的核心部分。而finally块虽非必需，但为什么finally是异常处理中的最后一道防线\r\n我的想法主要认为finally的必要关键之处是能够确保代码健壮性。\r\n而且finally块中存在许多深入理解的地方，在这篇文章我将依旧侧重于finally在异常处理中的细节\r\n\r\ntry - catch -\r\nfinally结构及其基础内容\r\ntry - catch -\r\nfinally结构是Java异常处理的核心部分。它允许你在代码出现错误时进行适当的处理，而不是让程序崩溃。\r\n在这里只对其简单阐述，本篇文章侧重点是finally\r\n基本结构 try &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType e) &#123;    // 异常处理代码&#125; finally &#123;    // 无论是否发生异常，都会执行的代码&#125;\r\ntry语句\r\n作用：try语句块用于包含可能抛出异常的代码\r\n它是异常监控的起始点，我们需要将可能出现问题的代码段放在 try\r\n块内。\r\n其中：\r\n一个 try 块后必须至少跟一个 catch 块或者一个 finally\r\n块。不能单独存在 try 块。\r\ntry\r\n块内的代码一旦抛出异常，异常抛出点之后的代码将不会继续执行，程序流程会立即跳转到相应的\r\ncatch 块\r\n\r\ncatch语句:\r\n作用：catch 块用于捕获并处理 try 块中抛出的异常。每个 catch\r\n块指定了它能够捕获的异常类型。\r\n在 catch\r\n块内，你可以对捕获到的异常进行处理，例如记录日志、向用户显示更友好的错误信息、进行恢复操作等。捕获到的异常对象可以通过\r\ncatch 块的参数（如 e）来访问，通过这个对象可以获取异常的详细信息\r\n其中：\r\ncatch 块会按顺序检查，只有与抛出异常类型匹配（包括子类类型匹配）的 catch\r\n块才会被执行。\r\n示例代码如下： try &#123;    // 有一些语句抛出了 IOException &#125; catch (IOException e)) &#123;    // 那么 catch (IOException e) 块会先被执行    // 如果没有 catch (IOException e)，才会执行 catch (Exception e)&#125; catch (Exception e) &#123;    &#125;\r\n多个 catch 块顺序：在编写多个 catch 块时，子类异常的 catch\r\n块必须放在父类异常的 catch\r\n块之前。否则，编译器会报错，因为子类异常永远无法被捕获。例如，以下代码会报错：\r\ntry &#123;    // 有一些语句抛出了 IOException&#125; catch (Exception e) &#123;   &#125; catch (IOException e) &#123;    // 编译器会报错，因为子类异常永远无法被捕获&#125; catch语句可以有多个\r\n\r\nfinally语句\r\nfinally语句块是可选的\r\n无论try块是否抛出异常，finally块代码通常都会执行。\r\n它允许程序员在程序运行时捕获并处理错误，防止程序因为异常情况而突然崩溃。\r\n如下代码片段验证finally的执行情况 try &#123;    System.out.println(&quot;Inside try block&quot;);&#125; catch (Exception e) &#123;    System.out.println(&quot;Exception caught&quot;);&#125; finally &#123;    System.out.println(&quot;Finally block always executes&quot;);&#125;\r\n它主要用于放置必须执行的清理代码，如关闭文件流、释放数据库连接等。\r\nfinally块中的代码总是在try和catch执行之后、方法返回之前执行。即使在try或catch中出现了return语句，finally块依然会执行。\r\n\r\nfinally的基础知识\r\nfinally块的作用\r\n\r\n确保资源释放：\r\n\r\nfinally 块最主要的作用是确保无论 try 块中是否发生异常，也无论\r\ncatch\r\n块是否捕获到异常，特定的代码段（通常用于资源清理和关闭资源）都会被执行。这对于需要手动管理资源的情况（如文件流、数据库连接、网络连接等）至关重要，避免资源泄漏。\r\nfinally\r\n块常用于确保文件流、数据库连接、网络连接等资源的正确关闭。在 Java\r\n中，这些资源若不及时关闭，可能导致资源泄漏，长时间运行后会耗尽系统资源，使程序性能下降甚至崩溃。\r\n我认为这是finally块在异常中被设计出来的初衷，因为我们也不知道也需要一个异常后被正确处理的情况。\r\n虽然现在，大家使用更多的是使用try-with-resources语法，因为它能够自动管理资源，减少错误发生的概率。省事还高级。\r\n\r\n\r\n\r\n\r\n异常后执行清理工作：\r\n\r\nfinally块确保程序不会因为异常中断而漏掉必要的清理操作。这样可以避免资源泄漏或系统状态不一致的问题。\r\n其中，在涉及多层资源嵌套的场景中，finally\r\n块的作用更为突出，多层资源之间的关系密切复杂，在finally块中去有条理的解决即友好又省事。因为finally\r\n块确保了处理是成功还是因异常回滚，相关资源都能被正确释放。\r\n\r\n\r\n\r\n\r\n对某些操作的保证：finally 块会影响 return\r\n语句的执行流程，确保在返回值确定前执行必要的清理操作。即使try或catch语句中发生了return语句，finally块的代码依然会执行，保证了关键代码的执行。我们可以利用这个来处理异常发生后的操作。\r\n   public class FinallyWithReturnExample &#123;   public static int test() &#123;       try &#123;           // 当 try 块执行到 return 1 时，会先暂存返回值 1,然后执行 finally 块中的代码,最后再返回暂存的 1           return 1;       &#125; finally &#123;           // finally 块在 return 语句真正返回前执行,在有 return 的情况下，也能保证清理等必要收尾操作的执行，前提是你finally块中没有retrun语句           System.out.println(&quot;Finally block in test method&quot;);       &#125;   &#125;   \tpublic static void main(String[] args) &#123;       \tint result = test();       \tSystem.out.println(&quot;Result: &quot; + result);   \t&#125;&#125;\r\n\r\n\r\n\r\n维护程序状态一致性\r\n\r\n确保部分操作完成：在某些业务逻辑中，部分操作完成后需要执行特定的收尾操作以维护程序状态的一致性。\r\n恢复中间状态：在一些复杂的业务流程中，程序可能会在执行过程中进入临时的中间状态。finally\r\n块可用于在异常发生时恢复到之前的稳定状态。\r\n   public class OrderProcessingExample &#123;   private static String orderStatus = &quot;INITIAL&quot;;   public static void processOrder() &#123;   \t// try 块尝试处理订单并更新订单状态       try &#123;           orderStatus = &quot;PROCESSING&quot;;           // 模拟订单处理的复杂逻辑，可能抛出异常           if (Math.random() &gt; 0.5) &#123;               throw new RuntimeException(&quot;Order processing failed&quot;);           &#125;           orderStatus = &quot;COMPLETED&quot;;       &#125; catch (Exception e) &#123;           e.printStackTrace();       // finally 块会检查订单状态       &#125; finally &#123;       \t// 如果不是 COMPLETED，则将其恢复到 INITIAL 状态       \t// 保证程序状态的一致性和准确性。           if (!&quot;COMPLETED&quot;.equals(orderStatus)) &#123;               orderStatus = &quot;INITIAL&quot;;           &#125;           System.out.println(&quot;Final order status: &quot; + orderStatus);       &#125;   &#125;   \tpublic static void main(String[] args) &#123;       \tprocessOrder();   \t&#125;&#125;\r\n增强代码的健壮性与可维护性：finally\r\n块为异常处理提供了一个统一的出口，无论 try\r\n块中发生何种异常，都能在此进行统一的处理逻辑。这使得代码结构更加清晰，易于理解和维护。而且这样能够大量的减少代码重复。\r\n\r\n\r\n\r\n所以这就是为什么要有异常捕获结构中要有finally块。 \r\nfinally关键字的细节之处\r\n\r\n有异常但未被捕获时，finally块的执行情况\r\nfinally块的执行与异常是否被捕获和处理是相对独立的。即使异常未被捕获，finally块也会执行其代码。这确保了无论异常如何传播，finally块中的资源清理或其他关键代码都能得到执行。\r\n这里也可以看出finally块的必定会被执行的一个性质\r\nfinally块执行完毕后，向外传播的异常类型和try块中抛出的异常类型一致，不会因为finally块的存在而改变。但是，如果finally块中的代码抛出了异常，它会覆盖try块或catch块中已经抛出的异常\r\n例如，如果try块抛出IOException，即使经过finally块的执行，向外传播的依然是IOException。\r\n示例代码如下 public class FinallyThrowsExceptionExample &#123;    public static void main(String[] args) &#123;        try &#123;            methodThatThrowsException();        &#125; catch (Exception e) &#123;            System.out.println(&quot;Caught in main: &quot; + e.getMessage());        &#125;    &#125;\t\t// main方法捕获到的异常信息是Caught in main: Exception thrown in finally    public static void methodThatThrowsException() &#123;        try &#123;        \t// 原始try块中的异常被覆盖            throw new RuntimeException(&quot;Exception thrown in inner try&quot;);        &#125; finally &#123;            throw new RuntimeException(&quot;Exception thrown in finally&quot;);        &#125;    &#125;&#125;\r\n\r\n与 return 语句的交互\r\n首先，在 finally\r\n代码块中改变返回值并不会改变最后返回的内容，而且finally中的语句一定会执行\r\n\r\n1.当 try 代码块和 catch 代码块中有 return 语句时，finally\r\n仍然会被执行。且 try 代码块或 catch 代码块中的 return\r\n语句执行之前，都会先执行 finally 语句\r\npublic class TryReturnFinallyExample &#123;    public static int test() &#123;        try &#123;        \tint result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;        \treturn 2;        &#125; finally &#123;            System.out.println(&quot;Finally block in test method&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n\r\n2.finally 块中的代码可以访问和修改 try 块和 catch\r\n块中定义的局部变量，但这种修改不会影响 return 语句返回的值\r\npublic class CatchReturnFinallyVariableExample &#123;    public static int test() &#123;        try &#123;            int result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;            int num = 2;            return num;        &#125; finally &#123;        \t// finally 块将 num 修改为 3            num = 3;        &#125;    &#125;\t\t// 但 return 语句返回的还是 catch 块中 return 语句执行时 num 的值    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n\r\n如果此时，finally 块本身也有 return\r\n语句，会以一种较为复杂的方式处理局部变量\r\ntry和catch块中的局部变量：即便finally块可以访问并修改try和catch块中定义的局部变量，由于finally块中的return会主导返回值，所以这种修改对最终返回值的影响也会被finally块的return逻辑所掩盖。\r\n当在try块暂存return的结果时候，如果finally块修改了局部变量影响了返回值，但本质是finally块的return起了决定性作用。\r\n示例代码 public class FinallyModifyLocalVar &#123;    public static int test() &#123;        int num = 1;        try &#123;            return num;        &#125; finally &#123;            num = 3;            return num;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n\r\n\r\n如果 finally 块中有 return 语句，它会覆盖 try 或 catch 块中的 return\r\n语句。这意味着无论 try 或 catch 块中原本打算返回什么值，最终都会被\r\nfinally 块中的 return 值取代。\r\n\r\npublic class FinallyReturnOverrideExample &#123;    public static int test() &#123;        try &#123;        \t// 尽管 try 块原本要返回 1            return 1;        &#125; catch (Exception e) &#123;            return 2;        &#125; finally &#123;        \t// 但由于 finally 块中有 return 3，最终返回的值是 3。            return 3;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n所以说finally块中最好不要包含 return\r\n语句，要不然程序会提前退出,，而且使用 finally 块中的 return\r\n语句会使代码的逻辑变得混乱，因为它打破了正常的 try - catch - finally\r\n异常处理流程，使得代码的返回值不依赖于 try 或 catch\r\n块中的逻辑。可读性和可维护性会瞬间爆炸\r\n\r\n\r\n异常情况下的返回：如果try块抛出异常，catch块捕获并处理异常，finally块的return语句依然会生效，覆盖catch块中的return\r\n\r\npublic class FinallyReturnWithException &#123;    public static int test() &#123;        try &#123;            int result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;            return 2;        &#125; finally &#123;            return 3;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n在这里强调一下，如果出现了异常未捕获的情况，就是try块抛出异常且未被catch块捕获，那么finally块执行完毕后，finally块中的return会阻止异常继续传播，并且返回finally块中的值。（这种情况可能会隐藏程序中的异常，导致调试难度从Galgme变成黑暗之魂，别用）\r\n\r\n异常屏蔽\r\n首先要知道一个前提：\r\ntry 块抛出异常且 catch 块未捕获：当 try 块抛出异常，而 catch\r\n块没有捕获该异常时，finally 块依然会执行。执行完 finally\r\n块后，异常会继续向外层传递。\r\npublic class ExceptionFinallyInteractionExample &#123;    public static void test() &#123;        try &#123;            throw new RuntimeException(&quot;Exception in try block&quot;);        &#125; finally &#123;            System.out.println(&quot;Finally block in test method&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            test();        &#125; catch (RuntimeException e) &#123;            System.out.println(&quot;Caught in main method: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n\r\n如果finally块中的代码抛出了异常，它会覆盖try块或catch块中已经抛出的异常。\r\n所以我们应该尽量避免在finally块中抛出异常，因为会覆盖异常本身的情况，导致调试出现歧义\r\npublic class FinallyThrowsExceptionExample &#123;    public static void test() &#123;        try &#123;            throw new RuntimeException(&quot;Exception in try block&quot;);        &#125; finally &#123;            throw new RuntimeException(&quot;Exception in finally block&quot;);        &#125;    &#125;\t\t// main 方法捕获到的是 finally 块抛出的异常信息 Exception in finally block    public static void main(String[] args) &#123;        try &#123;            test();        &#125; catch (RuntimeException e) &#123;            System.out.println(&quot;Caught in main method: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n\r\nfinally中可能抛出异常的情况的处理\r\n&lt; 引用自\r\nhttps://blog.csdn.net/qq_44861675/article/details/106353369\r\n本人作补充\r\n有这样一段代码 package Stream_IntOut;import java.io.*;/** * 使用缓冲区输入流和缓冲区输出流实现复制文件的功能。 * 并简单处理IO异常 * */public class Practice3_BufferedWriter_BufferedReader_Copy &#123;    public static void main(String[]args)&#123;        FileWriter fw = null;        FileReader fr = null;        BufferedWriter bufw = null;        BufferedReader bufr = null;        try&#123;            fw = new FileWriter(&quot;E:\\\\file_copy2.txt&quot;);            fr = new FileReader(&quot;E:\\\\file.txt&quot;);            bufw = new BufferedWriter(fw);            bufr = new BufferedReader(fr);            String line;            while((line=bufr.readLine())!=null)&#123;                bufw.write(line);                //写入换行符                bufw.newLine();                //刷新一次流对象                bufw.flush();            &#125;        &#125;catch(IOException e)&#123;            e.printStackTrace();        &#125;finally &#123;            if(fr!=null)                try&#123;                    assert bufr != null;                    bufr.close();            &#125;catch (IOException e)&#123;                    throw new RuntimeException(&quot;无法关闭fr流对象&quot;);                &#125;            if(fw!=null)                try&#123;                    assert bufw != null;                    bufw.close();                &#125;catch (IOException e)&#123;                    throw new RuntimeException(&quot;无法关闭fw流对象&quot;);                &#125;        &#125;    &#125;&#125;\r\n我们可以从IDEA的提示里边看到一些东西: throw inside “finally”\r\nblock\r\n也就是说，finally块里边抛出异常是不建议的，java异常语句中的finally块通常用来做资源释放操作，finally块和普通代码块一样，无法同时使用return语句和throw语句，因为无法通过编译\r\n为什么不被建议？\r\nfinally块中的throw语句会覆盖try和catch语句中的异常\r\n实例代码 package 面试题;public class FinallyAndReturnAndThrow3 &#123;    public static void main(String[]args)&#123;        displayTest();    &#125;    private static void displayTest() &#123;        try&#123;            System.out.println(2/0);//异常发生        &#125;catch (Exception e)&#123;            System.out.println(&quot;displayTest&#x27;s catch&quot;);            throw new RuntimeException(&quot;除数为0&quot;);        &#125;finally &#123;            System.out.println(&quot;displayTest&#x27;s finally&quot;);            throw new RuntimeException(&quot;俺会覆盖catch的异常&quot;);        &#125;    &#125;&#125;\r\n在结果中，返回的异常是finally里面的，catch的异常并没有被抛出。同样的try中捕抓的异常也会被掩盖。\r\n在Java核心技术书中，作者建议在finally块中尽量不要使用会抛出异常的资源回收语句。\r\n那么在我们使用IO流时，常常在finally使用到throw，那该如何解决呢？\r\n其中一个方法，就是接下来说的，在finally块中使用try-catch块，进行多层嵌套的try\r\n- catch - finally情况\r\n但其实，大家更常用的方法就是 使用 Java 7\r\n的try-with-resources语句，在关闭资源时抛出的异常会被添加为原来异常的被抑制异常并展示，不会掩盖try块中的异常。\r\n\r\n多层嵌套的try - catch -\r\nfinally情况\r\n异常捕获顺序\r\n\r\n内层优先：当异常发生时，Java\r\n首先会尝试在最内层的try块对应的catch块中捕获异常。如果内层try块没有匹配的catch块，异常会向外层try块传播，寻找匹配的catch块。\r\n也需要遵循子类优先：在编写catch块时，捕获子类异常的catch块应该放在其父类异常的catch块之前。否则，子类异常的catch块永远不会被执行，编译器会报错。\r\n\r\nfinally块的执行顺序\r\n\r\n内层优先：无论异常是否发生，内层try块的finally块总是在内层try块结束时（正常结束或因异常结束）立即执行，然后才会执行外层try块的finally块。\r\n异常传递：如果内层try块的finally块抛出异常，这个异常会向外层传播，可能会掩盖内层try块中原本抛出的异常。为避免这种情况，可以在内层finally块中捕获并处理异常，或者使用辅助变量记录内层try块的异常，同时处理内层finally块抛出的异常。\r\n\r\n注意资源的关闭顺序，永远是在多层嵌套中需要注意的地方\r\n所以我建议使用try - with - resources语句，它会自动管理资源的关闭，并确保每个资源只被关闭一次。\r\n示例代码\r\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class NestedTryCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            try &#123;                InputStream inputStream = new FileInputStream(&quot;example.txt&quot;);                try &#123;                    int data;                    while ((data = inputStream.read())!= -1) &#123;                        System.out.print((char) data);                    &#125;                &#125; catch (IOException e) &#123;                    System.out.println(&quot;读取文件时出错: &quot; + e.getMessage());                &#125; finally &#123;                    try &#123;                        if (inputStream!= null) &#123;                            inputStream.close();                        &#125;                    &#125; catch (IOException e) &#123;                        System.out.println(&quot;关闭文件时出错: &quot; + e.getMessage());                    &#125;                &#125;            &#125; catch (FileNotFoundException e) &#123;                System.out.println(&quot;文件未找到: &quot; + e.getMessage());            &#125;        &#125; catch (Exception e) &#123;            System.out.println(&quot;发生其他异常: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n\r\n上一篇：Java难绷知识03–包装器类及其自动装箱和拆箱\r\n下一篇：Java难绷知识05——Swing中的事件调度线程和资源释放\r\n\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","学习","JavaSE","语言方面"]},{"title":"Java难绷知识05--Swing中的事件调度线程和资源释放","url":"/posts/15372.html","content":"Swing中的事件调度线程\r\n先了解一下Swing中的单线程模型\r\n单线程模型有什么作用\r\n虽然大伙认为Swing又丑又落后（但是我编写gui入门真的是从Swing开始）\r\nSwing 最初设计是单线程模型，这意味着所有与 Swing\r\n组件交互的代码都应该在同一个线程中执行。\r\n单线程模型避免了 Swing\r\n组件可能因为会多个线程同时访问和修改而导致数据不一致或界面闪退等问题\r\n而且单线程模型使得开发者无需处理复杂的线程同步问题，这是保持页面一致性的重要原因，同一时间只有一个线程可以操作组件，正常思维去调度下不会出现部分界面更新而其他部分未更新的情况。\r\n但是单线程模型会造成一个迟钝的API。为了达到单线程模型，有一个专门的线程用于和Swing组件交互，就是Swing事件调度线程（Event\r\nDispatchThread，EDT)。\r\n如果对单线程模型线程不清楚，可能在打造响应式界面和其他更多的扩展应用上会出很多问题。\r\n为什么要了解事件调度线程（EDT）\r\n因为，EDT 是 Swing 单线程模型的核心\r\n在Swing中，所有与 UI\r\n相关的操作，如创建组件、修改组件属性、添加或移除组件等，都必须在 EDT\r\n中执行，EDT 负责处理所有的 Swing\r\n事件，但是如果长时间运行的任务或者带有阻塞机制的任务在EDT\r\n中执行，会导致UI冻结，对EDT机制深入了解就会做出更正确的取舍。所以在Swing中执行耗时任务时，要在一个新线程中执行，不能阻塞EDT线程，否则会造成swing界面的不响应，那就卡死了。SwingWorker就是用来管理任务线程和EDT之间调度的一个工具类。在这里我们先不讲SwingWorker，因为这个东西我也不咋会。\r\n并且Swing 组件不是线程安全的，这意味着如果在非 EDT 线程中更新\r\nUI，会导致不可预测的行为（通常是卡死然后瞬间爆炸）\r\n而且在后台中，通常会有其他线程去操作Swing，EDT机制就是后台线程操作\r\nSwing\r\n组件的特定机制，即保持了单线程模型的完整性，而且也能利用多线程的优势来提高应用程序的性能。\r\nSwing中的三种线程\r\n一个swing程序包含三种类型的线程：初始化线程（Initial\r\nThread）、事件调度线程（Event Dispatch Thread）和任务线程（Worker\r\nThread）。\r\n初始化线程\r\n初始化线程读取程序参数并初始化一些对象。该线程主要目的是启动程序的图形用户界面(GUI)。\r\n初始化线程用于创建各种容器，组件并显示他们，一旦创建并显示，初始化线程的任务就结束了，程序的控制权就交给了UI。\r\n初始化线程的在main方法中启动点z：main方法在主线程中执行。这也是\r\nJava 应用程序的入口点。\r\n虽然主线程可以启动 Swing 应用程序，但直接在主线程中创建和操作 Swing\r\n组件是不推荐的，因为这可能导致界面不响应或出现线程安全问题。通常，主线程会将\r\nSwing 组件的创建和初始化工作委托给事件调度线程。\r\n如代码所示，同时我们在初始化一个图形界面的时候，都会直接在主方法的主线程里，直接调用如下代码来进行初始化\r\nnew TestFrame().setVisible(true);\r\n但是复杂的程序我不推荐这样处理，因为这里有两个线程在同时访问组件：1.\r\n主线程 2. 事件调度线程。\r\n如果是复杂的图形界面程序，就有可能出现这两个线程同时操作的情况，导致同步问题的产生。\r\n所以说我们创建和显示界面的工作，最好也交给事件调度线程\r\nSwingUtilities.invokeLater(new Runnable() &#123;    public void run() &#123;        new TestFrame().setVisible(true);    &#125;&#125;);\r\n事件调度线程\r\n事件调度线程主要负责GUI组件的绘制和更新，并响应用户的输入。\r\n大家学了Swing那肯定都学了事件监听，通过对事件监听的学习，我们了解到Swing是一个事件驱动的模型，所以说所有和事件相关的操作都放是放在事件调度线程\r\n(Event Dispatch)中进行的。\r\n在 Swing 应用程序启动时，EDT\r\n会自动启动。一般通过SwingUtilities.invokeLater方法将代码块提交到\r\nEDT 执行。例如：\r\nimport javax.swing.*;public class EDTExample &#123;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;EDT Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setVisible(true);        &#125;);    &#125;&#125;\r\n事件队列处理：\r\n每个EDT都会负责管理一个事件队列，用户每次对界面更新的请求都会排到事件队列中，然后等待EDT的处理。\r\nEDT 负责从一个特定的事件队列中取出事件，并将其分发给相应的 Swing\r\n组件进行处理。当用户与 Swing\r\n界面进行交互时，比如点击按钮、移动鼠标、输入键盘字符等操作，都会生成相应的事件对象，这些对象会被放入事件队列。EDT\r\n不断循环，从队列中取出事件，并调用组件注册的事件监听器中的对应方法\r\n由于 EDT\r\n是单线程处理事件，它保证了事件处理的顺序性。避免了多线程并发访问导致的不一致性和错误。\r\n保证Swing组件的线程安全\r\n单线程操作模型：Swing\r\n组件并非线程安全，这意味着如果多个线程同时尝试访问和修改同一个 Swing\r\n组件，可能会导致数据不一致、界面显示异常甚至程序崩溃等问题。EDT\r\n通过将所有与 Swing\r\n组件的交互操作限制在单个线程内执行，有效地避免了这些线程安全问题。\r\n协调 UI 更新：所有对 Swing\r\n组件可视化属性的修改，如改变组件的大小、位置、颜色等，都必须在 EDT\r\n中进行。这样可以保证在任何时刻，组件的状态都是可预测和一致的。\r\nimport javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class SingleThreadModelExample &#123;    private static JLabel label;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;Single - Thread Model Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setLayout(new FlowLayout());            JButton button = new JButton(&quot;Start Bad Thread&quot;);            label = new JLabel(&quot;Initial Text&quot;);            button.addActionListener(new ActionListener() &#123;                @Override                public void actionPerformed(ActionEvent e) &#123;                    // 错误做法：在非EDT线程中尝试更新Swing组件                    // 在非 EDT 线程中更新 Swing 组件可能出现问题                    Thread badThread = new Thread(() -&gt; &#123;                        // 这会导致异常，因为Swing组件不是线程安全的，不能在非EDT线程中更新                        // label.setText(&quot;This will cause an issue&quot;);                        // 正确做法：使用SwingUtilities.invokeLater在EDT中更新                        SwingUtilities.invokeLater(() -&gt; &#123;                            label.setText(&quot;Updated in EDT&quot;);                        &#125;);                    &#125;);                    badThread.start();                &#125;            &#125;);            frame.add(button);            frame.add(label);            frame.setVisible(true);        &#125;);    &#125;&#125;\r\n任务线程\r\n在上面我们一直在说，有阻塞能力或者耗时长的操作中我们不放在事件调度线程中执行，那么就放在任务线程\r\n任务线程用于执行耗时操作如网络连接、文件读写、复杂计算等，以避免阻塞\r\nEDT，保证 Swing 应用程序的界面始终保持响应性。\r\n这些操作一般都会在事件响应后发起，就会自动进入事件调度线程。\r\n而事件调度线程又是单线程模式，其结果就会是在执行这些长耗时任务的时候，界面就无响应了。\r\n工作者线程在完成任务后，如果需要更新 Swing\r\n组件，不能直接操作，而是要通过SwingUtilities.invokeLater方法将更新操作提交到\r\nEDT。\r\nimport javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class WorkerThreadExample &#123;    private static JLabel label;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;Worker Thread Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setLayout(new java.awt.FlowLayout());\t\t\t            // 点击按钮启动工作者线程，工作者线程完成模拟耗时操作后，通过SwingUtilities.invokeLater方法在 EDT 中更新标签的文本。            JButton button = new JButton(&quot;Start Worker&quot;);            label = new JLabel(&quot;Status: Not started&quot;);            frame.add(button);            frame.add(label);            frame.setVisible(true);            button.addActionListener(new ActionListener() &#123;                @Override                public void actionPerformed(ActionEvent e) &#123;                    new Thread(() -&gt; &#123;                        // 模拟耗时操作                        try &#123;                            Thread.sleep(3000);                        &#125; catch (InterruptedException ex) &#123;                            ex.printStackTrace();                        &#125;                        // 更新UI，必须在EDT中执行                        SwingUtilities.invokeLater(() -&gt; &#123;                            label.setText(&quot;Status: Completed&quot;);                        &#125;);                    &#125;).start();                &#125;            &#125;);        &#125;);    &#125;&#125;\r\nEDT线程的注意事项和细节\r\n事件调度线程的单线程的\r\n始终记住事件调度线程是单线程的。\r\n这是因为\r\nSwing里面的各种组件类都不是线程安全的，这就意味着，如果有多个线程，那么同一个组件的方法可能会被多个线程同时调用，这会导致同步问题以及错误数据的发生。\r\n为了规避同步问题，以及降低整个Swing设计的复杂度，提高Swing的相应速度，Swing中的\r\n事件调度线程被设计成为了单线程模式，即只有一个线程在负责事件的响应工作。\r\nEDT 的启动\r\n在 Swing 应用程序启动时，EDT\r\n会自动启动。当调用SwingUtilities.invokeLater或SwingUtilities.invokeAndWait时，实际上是将任务提交到\r\nEDT 的事件队列中。\r\n任何GUI的请求都必须由EDT线程来处理\r\n保证线程安全\r\nSwing 组件不是线程安全的。如果在非 EDT 线程中执行 UI\r\n相关操作，会导致不可预测的行为。\r\n使用SwingUtilities.invokeLater(Runnable doRun)方法将 UI\r\n操作代码封装在Runnable对象中提交给 EDT 执行。\r\nSwingUtilities.invokeLater(() -&gt; &#123;    JLabel label = new JLabel(&quot;New Label&quot;);    frame.add(label);    frame.revalidate();    frame.repaint();&#125;);\r\nEDT线程将所有的GUI组件绘制和更新请求以及事件请求都放入了一个事件队列中。通过事件队列的机制，就可以将并发的GUI请求转化为事件队列，从而按顺序处理，这样有效的保护了线程安全，所以说，尽管大多数swing\r\nAPI本身不是线程安全的，但是swing通过EDT线程和事件队列机制实现了保障线程安全。\r\n同理，不建议从其他线程直接访问UI组件及其事件处理器，这会破坏线程安全的保障，可能会导致界面更新和绘制错误。\r\n在非EDT线程中通过invokeLater和invokeAndWait方法向EDT线程的事件队列添加GUI请求\r\n有的时候需要在一个非EDT线程中调用swing\r\nAPI来处理GUI请求，显然我们不能直接访问GUI组件，就需要使用SwingUtilities.invokeLater和SwingUtilities.invokeAndWait方法向\r\nEDT 的事件队列添加 GUI 请求。\r\n通过invokeLater和invoke方法，可以从一个非EDT线程中，将GUI请求添加到EDT线程的事件队列中去。\r\ninvokeLater是异步的，调用该方法时，该方法将GUI请求添加到事件队列中后直接返回。InvokeAndWait是同步的，调用该方法时，该方法将GUI请求添加到事件队列中后，会一直阻塞，直到该请求被完成后才会返回。\r\n但是在 EDT\r\n线程中调用invokeAndWait可能会导致死锁，例如，如果 EDT\r\n在等待另一个线程释放资源，而这个线程又在等待 EDT\r\n执行invokeAndWait提交的任务，就会形成死锁。而且invokeAndWait会阻塞调用线程，可能会影响程序的整体性能。因此，要避免在\r\nEDT 中调用invokeAndWait。\r\n下面简单介绍这两个方法：\r\nSwingUtilities.invokeLater\r\n\r\ninvokeLater方法用于将一个Runnable任务添加到\r\nEDT 的事件队列末尾。EDT\r\n会在处理完当前队列中的所有事件后，尽快执行这个任务。这意味着提交的任务不会立即执行，而是在\r\nEDT 有空闲时才会被处理。\r\n适用于那些对执行时机要求不是特别严格的 GUI 更新操作。\r\nimport javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class InvokeLaterExample &#123;    private static JLabel label;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;InvokeLater Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setLayout(new FlowLayout());            JButton button = new JButton(&quot;Start Thread&quot;);            label = new JLabel(&quot;Initial Text&quot;);            button.addActionListener(new ActionListener() &#123;                @Override                public void actionPerformed(ActionEvent e) &#123;                    new Thread(() -&gt; &#123;                        // 模拟后台任务                        try &#123;                            // 模拟一个耗时 2 秒的任务                            Thread.sleep(2000);                        &#125; catch (InterruptedException ex) &#123;                            ex.printStackTrace();                        &#125;                        // 任务完成后，通过invokeLater方法将更新JLabel文本的操作添加到 EDT 的事件队列中                        SwingUtilities.invokeLater(() -&gt; &#123;                            label.setText(&quot;Text updated from background thread&quot;);                        &#125;);                    &#125;).start();                &#125;            &#125;);            frame.add(button);            frame.add(label);            frame.setVisible(true);        &#125;);    &#125;&#125;\r\n\r\nSwingUtilities.invokeAndWait\r\n\r\ninvokeAndWait方法同样用于将一个Runnable任务添加到\r\nEDT\r\n的事件队列，但与invokeLater不同的是，调用invokeAndWait的线程会阻塞，直到\r\nEDT\r\n执行完提交的任务。这确保了调用线程可以立即获取到任务执行的结果\r\n当非 EDT 线程需要依赖 GUI\r\n操作的结果继续执行后续逻辑时，适合使用invokeAndWait。\r\n```Java\r\nimport javax.swing.; import java.awt.; import\r\njava.awt.event.ActionEvent; import java.awt.event.ActionListener; import\r\njava.awt.event.WindowAdapter; import\r\njava.awt.event.WindowEvent;\r\n\r\npublic class InvokeAndWaitExample { private static JTextField\r\ntextField;\r\npublic static void main(String[] args) &#123;\r\n    SwingUtilities.invokeLater(() -&gt; &#123;\r\n        JFrame frame = new JFrame(&quot;InvokeAndWait Example&quot;);\r\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        frame.setSize(300, 200);\r\n        frame.setLayout(new FlowLayout());\r\n\r\n        JButton button = new JButton(&quot;Get Text&quot;);\r\n        textField = new JTextField(10);\r\n\r\n        button.addActionListener(new ActionListener() &#123;\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) &#123;\r\n                new Thread(() -&gt; &#123;\r\n                    try &#123;\r\n                        // 后台线程通过invokeAndWait获取JTextField中的文本\r\n                        String text = SwingUtilities.invokeAndWait(() -&gt; &#123;\r\n                            return textField.getText();\r\n                        &#125;);\r\n                        // 由于invokeAndWait会阻塞后台线程，直到 EDT 执行完获取文本的任务，所以可以确保获取到准确的文本值并显示在对话框中。\r\n                        JOptionPane.showMessageDialog(frame, &quot;Text from field: &quot; + text);\r\n                    &#125; catch (Exception ex) &#123;\r\n                        ex.printStackTrace();\r\n                    &#125;\r\n                &#125;).start();\r\n            &#125;\r\n        &#125;);\r\n\r\n        frame.add(textField);\r\n        frame.add(button);\r\n        frame.setVisible(true);\r\n    &#125;);\r\n&#125;\r\n避免在 EDT 中执行耗时操作\r\nEDT 负责处理所有的 Swing 事件和 UI 更新。\r\nEDT的事件队列的机制在保障了线程安全的同时，也引入了一个新的问题：假设事件队列中某一个GUI请求执行时间非常长，那么由于队列的特点，队列中的后续GUI请求都会被阻塞，导致界面无法响应用户输入，出现界面冻结的情况。\r\n考虑到用户体验性，应使用独立的任务线程来执行耗时计算或输入输出密集型任务\r\n所以，将耗时操作放在任务线程中执行，在任务线程完成任务后，如果需要更新\r\nUI，再通过SwingUtilities.invokeLater将更新操作提交到\r\nEDT。\r\n调试 EDT 相关问题\r\n检测跨线程操作：使用工具如 Java VisualVM 或 Eclipse\r\n的调试工具，可以检测是否存在在非 EDT 线程中访问 Swing 组件的情况\r\n监控 EDT 性能：如果怀疑 EDT\r\n出现性能问题（如界面响应缓慢），可以通过分析事件处理代码的执行时间，查找是否存在耗时操作在\r\nEDT 中执行。可以使用简单的日志记录或性能分析工具（ YourKit Java\r\nProfiler）来辅助诊断。\r\n\r\n上一篇：Java难绷知识03–异常处理中的finally块\r\n下一篇：Java难绷知识06——Scanner等输出的细节\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","学习","JavaSE","语言方面"]},{"title":"Log4j2日志记录框架的使用与配置文件的解析","url":"/posts/47832.html","content":"Log4j2如何使用\r\n什么是日志\r\n日志(Log)是软件系统运行时记录的重要事件、状态信息和操作轨迹的机制。它是软件开发、测试和维护过程中不可或缺的工具，具有以下特点和作用：\r\n\r\n问题诊断：当系统出现异常或错误时，日志提供了问题发生的上下文信息，帮助开发人员快速定位问题根源\r\n行为追踪：记录用户操作和系统行为，便于审计和追踪业务流程\r\n性能监控：通过记录关键操作的时间戳，可以分析系统性能瓶颈\r\n安全审计：记录系统访问和敏感操作，满足合规性要求\r\n运行状态记录：保存系统运行期间的重要状态变化，便于事后分析\r\n\r\n日志通常分为不同级别，便于过滤和分类处理：\r\n\r\nFATAL/ERROR：错误，严重错误事件，可能导致系统崩溃或功能失效\r\nWARN：警告，输出警告的信息，潜在的有害情况，需要引起注意但不会立即影响系统运行\r\nINFO：信息，输出重要的运行时信息，记录系统正常运行状态\r\nDEBUG：调试，一般在开发中都设置的最低级别，详细的调试信息，用于开发阶段问题排查\r\nTRACE：追踪，最低的日志级别，最详细的跟踪信息，记录程序执行的详细路径\r\n\r\n级别高的日志会自动屏蔽级别低的日志\r\n日志的输出目的地指定了日志将会打印到控制台还是文件中，输出格式控制了日志信息的显示内容\r\nLog4j2作为Java生态中最流行的日志框架之一，提供了强大的日志记录能力，能够满足上述所有日志需求。\r\n简介\r\nLog4j的1.x版本虽然已经被广泛使用于很多应用程序中，但由于出现内存泄漏等bug，代码难以维护，以及需要使用老版本的jdk等劣势，在2015年8月已经玩完。它的替代品，SLF4J，Logback，Log4j2对日志框架做了很多必要的改进。\r\n历史上出现了很多的日记框架，如：\r\nLog4j：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki\r\nGülcü首创的，现在则是Apache软件基金会的一个项目。\r\nLog4j是几种Java日志框架之一。\r\nLog4j2：Apache Log4j 2是apache开发的一款Log4j的升级产品。\r\nCommons\r\nLogging：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta\r\nCommons Logging，后更名为Commons Logging。\r\nSlf4j：类似于Commons\r\nLogging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging\r\nFacade for Java，缩写Slf4j）。\r\nLogback：一套日志组件的实现(Slf4j阵营)。\r\nJul(Java Util Logging)：自Java1.4以来的官方日志实现。\r\n安装\r\n在开发中使用Log4j2日志记录框架需要引入的jar包如下：\r\nlog4j-api-2.13.0.jarlog4j-core-2.13.0.jar\r\nmaven中配置xml如下\r\n&lt;properties&gt;    &lt;logging.log4j.version&gt;2.13.0&lt;/logging.log4j.version&gt;&lt;/properties&gt; &lt;dependencies&gt;    &lt;!-- Log4j2日志记录框架 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n配置文件\r\n在项目的src根目录下，创建log4j2.xml配置文件。配置信息如下：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;     &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\r\n日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR\r\n&lt;\r\nFATAL，如果设置为WARN，则低于WARN的信息都不会输出。对于Loggers中level的定义同样适用。\r\n下面是Appender配置，Appender可以理解为日志的输出目的地，这里配置了一个类型为Console的Appender，也就是输出到控制台。Console节点中的PatternLayout定义了输出日志时的格式。\r\nLog4j提供的转换模式：\r\n\r\n%m 输出代码中指定的消息。\r\n%p 输出优先级，即DEBUG,INFO,WARN,ERROR,FATAL。\r\n%r 输出自应用启动到输出该log信息耗费的毫秒数。\r\n%c 输出所属的类目,通常就是所在类的全名。\r\n%t 输出产生该日志事件的线程名。\r\n%n 输出一个回车换行符，Windows平台为“”，Unix平台为“”。\r\n%d\r\n输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{dd\r\nMMM yyyy HH:mm:ss,SSS}，输出类似：02 Nov 2012 14:34:02,781)。\r\n%l\r\n输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数，\r\n如：Testlog.main(TestLog.java:10)。\r\n%F 输出日志消息产生时所在的文件名称。\r\n%L 输出代码中的行号。\r\n%x 输出和当前线程相关联的NDC(嵌套诊断环境)，像java\r\nservlets多客户多线程的应用中。\r\n%% 输出一个”%“字符。\r\n\r\n最后是Logger的配置，这里只配置了一个Root Logger。\r\n可以用如下代码测试\r\npublic static void main(String[] args)&#123;    Logger logger = LogManager.getLogger(LogFunction.class);    logger.trace(&quot;trace level&quot;);    logger.debug(&quot;debug level&quot;);    logger.info(&quot;info level&quot;);    logger.warn(&quot;warn level&quot;);    logger.error(&quot;error level&quot;);    logger.fatal(&quot;fatal level&quot;);&#125;\r\nSpring中整合Log4j2日志框架\r\nLog4j2依赖导入\r\n引入Log4j2的依赖\r\n&lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;\r\n在引入log4j2时，需要排除掉Logback日志框架的依赖即。\r\n&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\r\nlog4j2一般可以通过xml,json,yaml或者properties形式文件来实现，我们这边主要介绍xml文件格式。因为log4j\r\n2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,“.json”或者”.jsn”。\r\n系统选择配置文件的优先级(从先到后)如下：\r\n(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件。\r\n(2).classpath下的名为log4j2-test.xml的文件。\r\n(3).classpath下名为log4j2.json 或者log4j2.jsn的文件。\r\n(4).classpath下名为log4j2.xml的文件。\r\n我们一般默认使用log4j2.xml进行命名。如果本地要测试，可以把log4j2-test.xml放到classpath，而正式环境使用log4j2.xml，则在打包部署的时候不要打包log4j2-test.xml即可。\r\nLog4j2的路径相关\r\n默认路径\r\n引入log4j2依赖后，默认在src/main/resources目录下加入log4j2.xml配置文件对日志进行配置即可，然后在application.yml中进行访问路径的配置。\r\n示例如下：\r\n\r\nlog4j2.xml部署位置\r\n在代码工程中的src/main/resources目录下放入配置文件。\r\nyml配置\r\n\r\n#日志配置 无特殊需求无需更改logging:  config:  classpath:log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\r\n那么如何自定义部署位置\r\n当然我们也可以在微服务部署的config/目录下放置，然后在application.yml中进行访问路径的配置。\r\n举例：我们的micro-service01部署中配置的log4j2.xml路径。\r\n\r\nlog4j2.xml部署位置\r\n\r\n[userA@linux01 config]$ pwd/home/userA/SpringBoot/micro-service01/config[userA@linux01 config]$ lltotal 24-rwxr-xr-x 1 userA userA 5938 Sep  9 16:30 application.yml-r-------- 1 userA userA 8342 Sep  8 16:33 log4j2.xml\r\n\r\nyml配置\r\n\r\n#日志配置 无特殊需求无需更改logging:  config: /home/userA/SpringBoot/micro-service01/config/log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\r\nLog4j2.xml配置详解\r\n缺省默认配置文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;&lt;Appenders&gt;    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;        &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;    &lt;/Console&gt;&lt;/Appenders&gt;&lt;Loggers&gt;    &lt;Root level=&quot;error&quot;&gt;        &lt;AppenderRef ref=&quot;Console&quot; /&gt;    &lt;/Root&gt;&lt;/Loggers&gt;&lt;/Configuration&gt;\r\n解读：\r\n全局配置：\r\n\r\n仅输出 ERROR\r\n及以上级别的日志（Root level=\"error\"）。\r\n使用名为 Console 的Appender（控制台输出）。\r\n\r\n日志格式：\r\n14:25:30.456 [main] ERROR com.example.MyClass - This is an error message\r\n\r\n%d&#123;HH:mm:ss.SSS&#125; → 时间（时:分:秒.毫秒）。\r\n[%t] → 线程名（如 [main]）。\r\n%-5level → 左对齐的日志级别（如\r\nERROR）。\r\n%logger&#123;36&#125; → 类名（长度限制为36字符）。\r\n%msg%n → 日志内容 + 换行。\r\n\r\n配置文件节点解析\r\n\r\n**根节点 &lt;Configuration**&gt;\r\n&lt;Configuration status=&quot;WARN&quot;&gt;\r\n\r\n作用：整个配置文件的根节点。\r\n两个属性：\r\n\r\nstatus：用来指定log4j2本身的打印日志的级别，用于调试配置文件问题。可选值：TRACE,\r\nDEBUG, INFO, WARN,\r\nERROR, FATAL。\r\n其他可选属性：monitorInterval=\"30\"用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s\r\n\r\n有两个子节点：Appenders和Loggers(表明可以定义多个Appender和Logger)。\r\n\r\n日志输出器Appenders节点，常见的有三种子节点：Console、RollingFile、File。\r\n&lt;Appenders&gt;  &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;    &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;  &lt;/Console&gt;&lt;/Appenders&gt;\r\n\r\n作用：定义日志输出的目的地（如控制台、文件等）。\r\n子节点类型：\r\n\r\n&lt;Console&gt;：定义输出到控制台的Appender。\r\n\r\nname：唯一标识符,指定Appender的名字。（后续通过\r\nAppenderRef 引用）。\r\ntarget：输出目标，可选\r\nSYSTEM_OUT（标准输出）或\r\nSYSTEM_ERR（标准错误）。一般只设置默认：SYSTEM_OUT。\r\nPatternLayout：输出格式，不设置默认为:%m%n。\r\n\r\n&lt;File&gt;：输出到文件（支持滚动日志）。用来定义输出到指定位置的文件的Appender。\r\n\r\nname：指定Appender的名字\r\nfileName：指定输出日志的目的文件带全路径的文件名。\r\nPatternLayout：输出格式，不设置默认为:%m%n。\r\n\r\n&lt;RollingFile&gt;节点用来定义超过指定大小自动删除旧的创建新的的Appender。\r\n\r\nname：指定Appender的名字。\r\nfileName：指定输出日志的目的文件带全路径的文件名。\r\nPatternLayout：输出格式，不设置默认为:%m%n。\r\nfilePattern：指定新建日志文件的名称格式。\r\nPolicies：指定滚动日志的策略，就是什么时候进行新建日志文件输出日志。\r\nTimeBasedTriggeringPolicy：Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1\r\nhour。modulate=true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am。\r\nSizeBasedTriggeringPolicy：Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小。\r\nDefaultRolloverStrategy：用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。\r\n\r\n其他：&lt;Socket&gt;\r\n&lt;Kafka&gt; &lt;JDBC&gt; 等\r\n\r\n&lt;PatternLayout&gt;：定义日志格式。\r\n\r\npattern：格式模板，常用占位符：\r\n\r\n%d：日期时间（可指定格式如\r\n%d&#123;yyyy-MM-dd HH:mm:ss&#125;）。\r\n%t：线程名。\r\n%-5level：左对齐的日志级别（长度5）。\r\n%logger&#123;36&#125;：Logger名称（最大长度36）。\r\n%msg：日志消息。\r\n%n：换行符。\r\n\r\n\r\n\r\n日志记录器&lt;Loggers&gt;\r\n&lt;Loggers&gt;  &lt;Root level=&quot;error&quot;&gt;    &lt;AppenderRef ref=&quot;Console&quot; /&gt;  &lt;/Root&gt;&lt;/Loggers&gt;\r\n\r\n作用：定义日志的采集规则（哪些级别的日志被记录，输出到哪些Appender）。常见的有两种：Root和Logger。\r\n核心节点：\r\n\r\nRoot节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出。\r\nlevel：日志输出级别，共有8个级别，按照从低到高为：All\r\n&lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt;\r\nOFF。\r\nAppenderRef：Root的子节点，用来指定该日志输出到哪个Appender。\r\nLogger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。\r\nlevel：日志输出级别，共有8个级别，按照从低到高为：All\r\n&lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt;\r\nOFF。\r\nname：用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点。\r\nAppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=\"false\"只在自定义的Appender中进行输出。\r\n\r\n\r\n关于日志level\r\n共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt;\r\nWarn &lt; Error &lt; Fatal &lt; OFF。\r\n\r\nAll：最低等级的，用于打开所有日志记录。\r\nTrace：是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出。\r\nDebug：指出细粒度信息事件对调试应用程序是非常有帮助的。\r\nInfo：消息在粗粒度级别上突出强调应用程序的运行过程。\r\nWarn：输出警告及warn以下级别的日志。\r\nError：输出错误信息日志。\r\nFatal：输出每个严重的错误事件将会导致应用程序的退出的日志。\r\nOFF：最高等级的，用于关闭所有日志记录。\r\n\r\n程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。\r\n\r\n比较完整的log4j2.xml配置模板\r\n配置模板1:\r\n不同级别日志分离存储带日志滚动归档，历史日志分析\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;!--先定义所有的appender--&gt;    &lt;appenders&gt;        &lt;!--这个输出控制台的配置--&gt;         &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;        &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;        &lt;/File&gt;        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/info.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/warn.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/error.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;loggers&gt;        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;        &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;root level=&quot;all&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\r\n配置模板2\r\n基础控制台 + 文件日志（带滚动策略）\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- status=&quot;WARN&quot; 表示 Log4j2 自身日志级别，调试时可设为 TRACE --&gt;&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;Appenders&gt;        &lt;!-- 控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 滚动文件日志 (每天滚动，最多保留7天) --&gt;        &lt;RollingFile name=&quot;RollingFile&quot;                      fileName=&quot;logs/app.log&quot;                      filePattern=&quot;logs/app-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout&gt;                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;            &lt;/PatternLayout&gt;            &lt;Policies&gt;                &lt;!-- 每天午夜滚动日志 --&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;                &lt;!-- 单个日志文件最大 100MB --&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- 最多保留 7 天的日志 --&gt;            &lt;DefaultRolloverStrategy max=&quot;7&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- Spring 框架日志控制 --&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- Hibernate 日志控制 --&gt;        &lt;Logger name=&quot;org.hibernate&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 项目代码日志 (包路径根据实际情况修改) --&gt;        &lt;Logger name=&quot;com.example&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 根日志配置 --&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n配置模板3\r\n按环境区分配置（开发/生产）\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Properties&gt;        &lt;!-- 通过环境变量切换配置 --&gt;        &lt;Property name=&quot;log.level&quot;&gt;$&#123;sys:spring.profiles.active:-dev&#125;&lt;/Property&gt;        &lt;Property name=&quot;logPath&quot;&gt;logs&lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!-- 彩色控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;cyan&#125; %highlight&#123;%-5level&#125; %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 生产环境专用文件日志 --&gt;        &lt;RollingFile name=&quot;ProdFile&quot;                      fileName=&quot;$&#123;logPath&#125;/prod.log&quot;                     filePattern=&quot;$&#123;logPath&#125;/prod-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;500 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 开发环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;dev&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;DEBUG&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;        &lt;!-- 生产环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;prod&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;WARN&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;                &lt;AppenderRef ref=&quot;ProdFile&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n配置模板4\r\n高性能异步日志\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;!-- 启用异步日志 --&gt;    &lt;AsyncLoggerConfig includeLocation=&quot;true&quot; /&gt;    &lt;Appenders&gt;        &lt;!-- 异步文件追加器 --&gt;        &lt;RollingRandomAccessFile name=&quot;AsyncFile&quot;                                fileName=&quot;logs/async.log&quot;                                filePattern=&quot;logs/async-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;ISO8601&#125; %-5level [%t] %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;200 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;!-- 控制台快速输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 异步记录器配置 --&gt;        &lt;AsyncLogger name=&quot;com.example&quot; level=&quot;INFO&quot; includeLocation=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/AsyncLogger&gt;        &lt;!-- SQL 日志单独记录 --&gt;        &lt;Logger name=&quot;jdbc.sqlonly&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;WARN&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n模板5\r\nJSON 格式日志（适用于 ELK 收集）\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;JsonLayout compact=&quot;true&quot; eventEol=&quot;true&quot;&gt;                &lt;KeyValuePair key=&quot;app&quot; value=&quot;MySpringApp&quot;/&gt;                &lt;KeyValuePair key=&quot;env&quot; value=&quot;$&#123;sys:spring.profiles.active&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/Console&gt;        &lt;File name=&quot;JsonFile&quot; fileName=&quot;logs/app.json&quot;&gt;            &lt;JsonLayout complete=&quot;false&quot; compact=&quot;false&quot;&gt;                &lt;KeyValuePair key=&quot;timestamp&quot; value=&quot;$$&#123;date:yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#125;&quot;/&gt;                &lt;KeyValuePair key=&quot;thread&quot; value=&quot;%t&quot;/&gt;                &lt;KeyValuePair key=&quot;level&quot; value=&quot;%level&quot;/&gt;                &lt;KeyValuePair key=&quot;logger&quot; value=&quot;%logger&quot;/&gt;                &lt;KeyValuePair key=&quot;message&quot; value=&quot;%message&quot;/&gt;                &lt;KeyValuePair key=&quot;exception&quot; value=&quot;%ex&#123;full&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/File&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 结构化日志专用配置 --&gt;        &lt;Logger name=&quot;com.example.api&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n自定义配置文件夹位置\r\nlog4j2默认在classpath下查找配置文件，可以修改配置文件的位置。在非web项目中：\r\npublic static void main(String[] args) throws IOException&#123;    File file = new File(&quot;D:/log4j2.xml&quot;);    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));    final ConfigurationSource source = new ConfigurationSource(in);    Configurator.initialize(null, source);     Logger logger = LogManager.getLogger(&quot;mylog&quot;);&#125;\r\n如果是web项目，在web.xml中添加：\r\n&lt;context-param&gt;    &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt;    &lt;param-value&gt;/WEB-INF/conf/log4j2.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;listener&gt;    &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;&lt;/listener&gt;\r\n\r\n上述内容部分引用自\r\nhttps://blog.csdn.net/pan_junbiao/article/details/104313938\r\n推荐教程\r\n推荐几篇我在网上找到的，写的很好的学习教程：\r\n学习资料1：详解log4j2(上)\r\n- 从基础到实战\r\n学习资料2：详解log4j2(下)\r\n- Async/MongoDB/Flume Appender 按日志级别区分文件输出\r\n学习资料3：SpringBoot—整合log4j2入门和log4j2.xml配置详解\r\n\r\n简单示例\r\n在项目的src根目录下的resources文件夹创建如下log4j2.xml文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;    &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\r\n日志功能测试类\r\npublic class TestUser &#123;    // 创建Logger    private Logger logger = LoggerFactory.getLogger(TestUser.class);    @Test    public void test() &#123;        // 加载spring配置文件，对象创建        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 获取创建的对象        User user = (User)context.getBean(&quot;user&quot;);        System.out.println(&quot;1:&quot; + user);    // 输出了对象的地址        // 使用对象调用方法完成测试        System.out.println(&quot;2:&quot;);        user.add();        // 手动写日志        logger.info(&quot;@执行调用成功&quot;);        // 追踪        logger.trace(&quot;trace level&quot;);        logger.debug(&quot;debug level&quot;);        logger.info(&quot;info level&quot;);        logger.warn(&quot;warn level&quot;);        logger.error(&quot;error level&quot;);    &#125;\r\n输出结果\r\n\r\n\r\nimage-20250416203626062\r\n\r\n\r\n\r\nimage-20250416203626062\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework","日志与调试"]},{"title":"Little Busters!EX游戏攻略","url":"/posts/28134.html","content":"前言\r\n请注意！ 本攻略转载自“LBEX中文化攻略Ver1.01”，侵删 制作：抛雨挥虹\r\n修订：中野梓喵 攻略：Pyhh\r\nLBEX流程图攻略转自 https://bbs.inapom.com/3096.html 是Steam English\r\nEdition版本的\r\n\r\n游戏简介\r\nLittle\r\nBusters！EX（リトルバスターズ!エクスタシー）是VisualArt’s/KEY继1999年的KANON，2000年的AIR，2004年的Clannad，2005年的智代after，2007年的Little\r\nBusters!之后，2008年7月25日发售的新作。 Little Busters-EX和Little\r\nBusters!不同的地方在于Little\r\nBusters!里的配角二木佳奈多和笹濑川佐佐美升为可攻略女主角，另外再加一个可攻略新女主角朱鹭户沙耶，新的迷你游戏与音乐也是追加要素。\r\n一般把原本的Little Busters!称为“无印”(没有EX印记的意思)，而Little\r\nBusters！EX称为EX。\r\n游戏名称：リトルバスターズ!エクスタシー (Little Busters!EX)\r\n制作公司：VisualArt’s/KEY\r\n游戏类型：AVG/ADV\r\n年龄限制：18X 游戏语音：全程语音\r\n故事简介：\r\n主角直枝理树与其青梅竹马的朋友棗恭介、棗铃、井之原真人、宫沢谦吾一起过着全寄宿制的高中生活。他们从小就结成了一个与恶势力作斗争，号称正义的使者的队伍，名为“Little\r\nBusters”。升上高中后，他们依然像以前一样过着快乐的每一天，理树也渴望与伙伴们的日子能够永远持续下去。\r\n一天，恭介提议要组成一个棒球队伍，像从前一样再热闹地玩一次。于是理树他们就开始寻找队员，挥洒着青春的光彩…\r\n\r\n注意事项\r\n1.是否开启棒球练习和战斗排位赛都不会对攻略有影响。如果在游戏中开启了则在攻略上没有「闲逛」「挑战」「到处走走」之类的选项均可自行选择。此攻略在战斗排位赛和棒球练习OFF的情况下制作。\r\n2.如想在第一次游戏就攻略沙耶,佳奈多,佐佐美,需在游戏起始询问「你知道世界的秘密吗?」选「是」；如果没玩过此游戏建议选「否」。\r\n3.如果在游戏起始询问「你知道世界的秘密吗?」选「否」，在攻略标上符号“★”的部分是必须完成Refrain之后才能攻略。\r\n4.用( )括号括住的选项是在特定的情况下才会出现，如果在游戏时攻略上带(\r\n)的选项没出现请忽略。\r\n5.攻略过的女主角再攻略一次时有些选项会变成灰色不能选择，不能再进入已攻略过的角色线(铃和小毬除外)，到Refrain之后会恢复。\r\n6.本攻略为最速攻略，只保证收集全部CG以及Scene，不保证剧情的100%达成，追求完整剧情的同学请自行探索。\r\n\r\n流程图版本攻略\r\n这里是共通线的，人物线在对应的位置\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n共通线\r\n5月14日Mon\r\n出声招呼 不怎么好 不怎么好\r\n不怎么好 不怎么好\r\n\r\n5月15日Tue\r\n借 去找她\r\n存档A 就这样看着 用别的笔记代替\r\n\r\n5月16日Wed\r\n追铃 暂时看着 赶紧找人 接受 去凑热闹 结束算了 帮忙找\r\n\r\n5月17日Thu\r\n找找看吧 沉默 去追铃 暂时先看着 去屋顶\r\n-——————————————————————————-\r\n5月18日Fri\r\n存档B 我 西园 留在中庭 她到底问了什么呢？ 西园 去买果汁 接受\r\n(感觉到了敌意) 制止她\r\n-——————————————————————————-\r\n5月19日Sat\r\n去找铃 站着看一会 (还是很在意)\r\n(到屋外去)\r\n(帮忙) 参与进去 中庭 (结束) 帮忙\r\n\r\n5月20日Sun\r\n去\r\n(找人) 恭介 存档① 普通的甜甜圈\r\n↓CG回收(如不需100%CG达成率可以忽略此步骤)\r\n※在此处选择不同的选项在24日活动室里小毬的小裤裤CG会有变化\r\n※在选择其中一个选项后继续剧情直到24日对应→CG回收的步骤\r\n→第1次读取存档①后选择\r\n有巧克力条纹的甜甜圈\r\n→第2次读取存档①后选择\r\n软软的草莓的甜甜圈\r\n-——————————————————————————-\r\n5月21日Mon\r\n(认真阅读) 去买果汁去 去找找看 善意 去听听她们在说什么 铃\r\n\r\n5月22日Tue\r\n去叫她 回教室 存档② 去中庭 (劝谦吾) 听听她们在说什么 对着库特点头。\r\n去\r\n-——————————————————————————-\r\n5月23日Wed\r\n和库特打招呼 上前打招呼 存档③ 制止她 存档④ 去屋顶 买果汁去\r\n去听听在谈些什么 和恭介他们一起吃 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 帮忙 回教室 去听听她们在说些什么 →CG回收\r\n※在活动室获取第1张小毬的CG后\r\n→第1次读取存档①\r\n※获取此处第2张小毬的CG后\r\n→第2次读取存档① ※获取此处第3张小毬的CG后继续下面的剧情 小毬 库特\r\n-——————————————————————————-\r\n5月25日Fri\r\n就这样决定了\r\n(躲进去) 谢绝 结束\r\n(兔子)\r\n(乔)\r\n\r\n5月27日Sun\r\n存档⑤\r\n※共通线结束，开始角色线\r\n\r\n\r\n神北 小毬\r\n5月27日Sun\r\n那下个晴天再去不就行了吗\r\n\r\n5月28日Mon\r\n去屋顶 ●小毬 给恭介发短信 上网找找 拉好 询问关于梦的事情 找来谷问\r\n存档⑥\r\n小毬TRUE END\r\n不直面这些不行 小毬TRUE END\r\n\r\n小毬BAD END\r\n上述END后 读取存档⑥ 把这些抛到脑后就好 这就是守护了吧 小毬BAD END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n能美 库特莉亚芙卡\r\n读取存档⑤\r\n5月27日Sun\r\n库特TRUE END\r\n要不要我来拿东西呢？ 铃的 ●库特莉亚芙卡 叶留佳和西园\r\n去调查下关于昨晚的疑问 存档⑦ 现在，就想回应她 对她说，回去吧 库特TRUE\r\nEND\r\n\r\n上述END后 库特BAD END\r\n读取存档⑦ 现在就回应她这样好吗 对她说，希望她能留下来 库特BAD END\r\n★以下攻略必须完成Refrain线后开启\r\n\r\n库特TRUE END２\r\n以下攻略必须完成Refrain线后开启\r\n读取存档⑦ 现在，就想回应她 听听库特自己希望怎么样 小卖部\r\n查找语言学的书架 ※库特CG回收 库特TRUE END２\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n库特挂科整理(给有需求的人使用)\r\n\r\n\r\nimg\r\n\r\n\r\n三枝 叶留佳\r\n读取存档②\r\n5月22日Tue\r\n去食堂 我先 叶留佳 (去追恭介) 听听她们在说什么 对着库特摇头。 去\r\n\r\n5月23日Wed\r\n进教室 上前打招呼 制止她 去食堂 帮忙 买果汁去 去听听在谈些什么\r\n和恭介他们一起吃 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 去找猫 去听听她们在说些什么 叶留佳 美鱼\r\n\r\n5月25日Fri\r\n就这样决定了 (躲进去) 谢绝 结束 (乔) (外星人)\r\n\r\n5月28日Mon (叶留佳TRUE END)\r\n中庭的自动贩卖机 去问问发生什么事了 ●叶留佳 去委员会室 询问真相\r\n去确认一下 继续找叶留佳 回答说看名单找到的 有 我明白了 觉得可以 蓝莓之类\r\n进一步的 用手\r\n→CG回收\r\n※获取用手的CG后在菜单选择返回上一选择肢\r\n用嘴 接收条件 存档⑧ 不放弃 叶留佳TRUE END\r\n\r\n叶留佳BAD END\r\n上述END后 读取存档⑧ 放弃 期望 叶留佳BAD END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n来谷 唯湖\r\n读取存档②\r\n5月22日Tue\r\n去后院 仔细听 (去追恭介) 听听她们在说什么 对着库特摇头。 去\r\n\r\n5月23日Wed\r\n进教室 上前打招呼 制止她 去食堂 拒绝 买果汁去 去听听在谈些什么\r\n(打扫一下吧) 和恭介他们一起吃 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 回教室 去听听她们在说些什么 来谷 库特\r\n\r\n5月25日Fri\r\n就这样决定了 (躲进去) 拒绝 结束\r\n\r\n5月28日Mon （来谷TRUE END）\r\n不说 ●来谷 死不承认\r\n存档⑨\r\n↓下面3个选项的顺序可随意选择（包括人物也可以自由选择，叶留佳也可以作为选项之一）\r\n库特 美鱼 小毬\r\n↑上面3个选项的顺序可随意选择 恭介 就是前面 就算是那样… 老实回答\r\n来谷TRUE END\r\n★以下攻略必须完成Refrain线之后开启\r\n\r\n来谷TRUE END２\r\n以下攻略必须完成Refrain线之后开启\r\n读取存档⑨\r\n↓下面3个选项的顺序可随意选择，建议多S/L几次选择不同的顺序会有很有趣的剧情\r\n库特 美鱼\r\n小毬\r\n↑上面3个选项的顺序可随意选择（包括人物也可以自由选择，叶留佳也可以作为选项之一）\r\n恭介\r\n就是前面\r\n就算是那样… 老实回答 ※下面的选项在三周目以后追加\r\n记得这个名字\r\n※来谷CG回收 来谷TRUE END２\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n西园 美鱼\r\n读取存档④\r\n5月23日Wed\r\n去中庭 和真人玩 去听听在谈些什么 上前搭话 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 去中庭 回教室 去听听她们在说些什么 美鱼 小毬\r\n\r\n5月25日Fri\r\n就这样决定了 (跑过走廊) 拒绝 结束 (兔子) (乔)\r\n\r\n5月27日Sun\r\n那下个晴天再去不就行了吗\r\n\r\n5月28日Mon （美鱼TRUE END）\r\n去中庭 ●美鱼\r\n↓下面5个选项的顺序可随意选择 库特 小毬 铃 恭介 真人\r\n↑上面5个选项的顺序可随意选择 美鸟 存档⑩ 善意 美鱼TRUE END\r\n\r\n美鱼TRUE END２\r\n上述END后\r\n读取存档⑩ 善意\r\n※美鱼Hscene 美鱼TRUE END２\r\n读取存档⑩ 恶意\r\n※美鸟Hscene 美鸟END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n棗 铃 BAD END\r\n※在第一次攻略 棗铃时无法避免BAD END\r\n※完成Refrain后再攻略此路线时将不会再出现BAD END而直接进入棗\r\n铃END1\r\n\r\n读取存档③\r\n5月23日Wed\r\n继续帮忙 和真人玩 集中精神练习 (继续用那种眼神盯着看)\r\n和恭介他们一起吃 再来一碗 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 去找猫 去练习 铃 库特\r\n\r\n5月25日Fri\r\n跟铃商量 (躲进去) 拒绝 结束 (外星人) (兔子)\r\n\r\n5月27日Sun （铃BAD END）\r\n那下个晴天再去不就行了吗 ●铃 鼓励她 举手 铃BAD END\r\n※完成铃BAD END和小毬、库特、叶留佳、来谷、美鱼的END后将开启棗\r\n铃END１\r\n\r\n棗 铃 END１\r\n※此路线必须先完成棗铃BAD\r\nEND和小毬、库特、叶留佳、来谷、美鱼的END后才能开启\r\n※此路线为开启Refrain的最后条件，在标题画面选Start→New\r\nGame开始\r\n\r\n5月14日Mon\r\n就这样看着 不怎么好 不怎么好 不怎么好 不怎么好\r\n-——————————————————————————-\r\n5月15日Tue\r\n不借 去找她 出声招呼 用别的笔记代替\r\n-——————————————————————————-\r\n5月16日Wed\r\n追铃 搭话 赶紧找人 让他自己去 结束算了 不要管太多了\r\n\r\n5月17日Thu\r\n没有 制止 去追铃 打个招呼 不去屋顶\r\n\r\n5月18日Fri\r\n返回食堂 和真人玩 (感觉到了敌意) 制止她\r\n\r\n5月19日Sat\r\n去找铃 出声打招呼 与真人玩 老实待着 还有作业…\r\n\r\n5月20日Sun\r\n去\r\n(找人) 恭介 软软的草莓的甜甜圈\r\n\r\n5月21日Mon\r\n和真人玩 就此结束 铃\r\n\r\n5月22日Thu\r\n和真人玩 去后院 劝谦吾 认真练习 去\r\n\r\n5月23日Wed\r\n上前打招呼\r\n存档⑪\r\n继续帮忙 买果汁去 集中精神练习 继续用那种眼神盯着看 打扫一下吧\r\n上前打招呼 在一旁看着 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 去找猫 去练习 不阻止 铃 小毬\r\n\r\n5月25日Fri （铃END１）\r\n跟铃商量 (躲进去) 拒绝 结束 (兔子) (乔) ●铃 鼓励她 举手 中庭 去\r\n铃END１ ※ＥＤ后 从此坚强地活下去\r\n\r\nRefrain\r\n※此路线必须完成铃END１后开启，在标题画面选择Refrain\r\n\r\n5月21日Mon\r\n靠头脑\r\n\r\n5月23日Wed\r\n问他\r\n\r\n5月24日Thu （铃END２）\r\n问他看看 他想起来左手受伤了 ●修学旅行 带着铃逃走 铃END２\r\n\r\n铃TRUE END &amp; Little\r\nBusters!TRUE END\r\n※ＥＤ后\r\n●Epilogue 不好 ●修学旅行 冷静下来 去折树枝 之后再来 去大家的包里找\r\n思考一下 救恭介 Little Busters!TRUE END\r\n铃TRUE END &amp; Little Busters!TRUE END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\nLittle Busters! TRUE\r\nEND的其他回收\r\n※完成一次Refrain线后在标题画面选择Start里Refrain\r\n\r\n5月21日Mon\r\n靠头脑\r\n\r\n5月23日Wed\r\n问他\r\n\r\n5月24日Thu\r\n问他看看 他想起来左手受伤了 ●修学旅行\r\n带着铃逃走 ●Epilogue\r\n嗯\r\n※ＥＤ后 不好\r\n●修学旅行 冷静下来 去折树枝 之后再来 去大家的包里找 思考一下 救恭介\r\n铃TRUE END Little Busters! TRUE END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n笹濑川 佐佐美\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n读取存档⑪\r\n5月23日Wed\r\n制止她 拒绝 买果汁去 集中精神练习 练习 不管 去食堂要紧 算了\r\n去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 回教室 去练习 阻止她 小毬 美鱼\r\n\r\n5月25日Fri\r\n跟铃商量 (躲进去) 请他帮忙 结束 (外星人) (乔)\r\n\r\n10月23日Tue （佐佐美TRUE END）\r\n脸被拧了 ●佐佐美 猫食 默不作声地拿出猫粮 娶她 库特 存档C 待在她身边\r\n我也…\r\n※佐佐美Hscene 佐佐美TRUE END\r\n\r\n佐佐美GOOD END\r\n上述END后 读取存档C 就这样让她一个人静一静 还有其他的答案 佐佐美GOOD\r\nEND\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n二木 佳奈多\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n读取存档B\r\n5月18日Fri\r\n我 小毬 返回食堂 差不多该走了 和真人玩 感觉到了好意 制止她\r\n\r\n5月19日Sat\r\n不管她 还是很在意 到屋外去 帮忙\r\n参与进去 帮忙\r\n\r\n5月20日Sun\r\n去\r\n(找人) 真人 有巧克力条纹的甜甜圈\r\n\r\n5月21日Mon\r\n随便读一下 到外面去呼吸新鲜空气 就此结束 叶留佳\r\n\r\n5月22日Tue\r\n平时的那家伙又出现了！ 回教室 去后院 去追恭介 认真练习 对着库特摇头。\r\n去\r\n\r\n5月23日Wed\r\n和库特打招呼 去食堂 帮忙 买果汁去 集中精神练习 练习 (打扫一下吧)\r\n去食堂要紧 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 去找猫 去练习 叶留佳 库特\r\n\r\n5月25日Fri\r\n就这样决定了 (跑过走廊) 拒绝 结束 (兔子) (外星人)\r\n\r\n5月28日Mon （佳奈多TRUE END）\r\n去帮忙 ●佳奈多 去宿舍会帮忙\r\n存档D 不出去 不出去 不叫 电影赠票 问问关于泡菜的问题 喜欢你\r\n※佳奈多Hscene 佳奈多TRUE END\r\n\r\n佳奈多BAD END\r\n上述END后\r\n读取存档D\r\n出去\r\n佳奈多BAD END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n朱鹭户 沙耶(理树通常ver)\r\n\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n※射击游戏OFF\r\n\r\n读取存档A\r\n5月15日Tue\r\n出声招呼\r\n※如果此处出现询问「想要能再次攻略沙耶线吗?」选「是」开启沙耶线 去取\r\n返回学校\r\n\r\n5月16日Wed\r\n乞求帮助 结束算了 不好 金字塔\r\n\r\n5月17日Thu\r\n没有\r\n制止\r\n不放弃\r\n\r\n5月18日Fri\r\n默不作声 喜欢 恭介\r\n\r\n※在迷宫部分，符号“&gt;”表示提示\r\n\r\n■地下１层 &gt;右上方的房间 我\r\n\r\n■地下２层\r\n\r\n\r\nimg\r\n\r\n&gt;中间的房间 往右转\r\n\r\n5月19日Sat\r\n确实也有感到有趣的时候\r\n\r\n■地下３层 \r\n&gt;右上方尽头的房间 老老实实地去 石头(此处选项可随意选择)\r\n\r\n■地下４层 \r\n&gt;左上方3个房间中顶部的房间 到房间外面去调查\r\n\r\n5月20日Sun\r\n想和朱鹭户同学待在一起 问她喜欢什么样的男人 有巧克力条纹的甜甜圈\r\n\r\n■地下５层\r\n\r\n\r\nimg\r\n\r\n&gt;右下方的房间 用冰来雕刻出这条龙的形象 更加努力 更加努力\r\n\r\n■地下６层\r\n &gt;其中一边黄色地点→另一边黄色地点→红色点的房间\r\n重新看一次这层的地图 王\r\n\r\n\r\n&gt;返回其中一边黄色地点 &gt;打通地图成“王”字 &gt;右上方的空房间\r\n打开这个房间的棺材 去找木乃伊\r\n&gt;在各个房间寻找\r\n\r\n5月21日Mon\r\n(随便读一下) 库特 库特 我和恭介在交往中 真人 就此结束\r\n\r\n5月22日Tue\r\n说 去后院 去追恭介 握她的手\r\n\r\n■地下７层\r\n\r\n\r\nimg\r\n\r\n&gt;把迷宫全部走遍 试着碰她的手\r\n&gt;在迷宫内侧移动 试着抚摸她的头\r\n&gt;回到起点的房间 &gt;按一笔书规则在迷宫内侧走“８”字 \r\n\r\n■地下８层\r\n\r\n\r\nimg\r\n\r\n&gt;右下方尽头\r\n\r\n■地下８层\r\n&gt;右下方尽头 开枪\r\n&gt;在各处寻找\r\n\r\n■重播\r\n※为完成此路线必须按步骤GAME OVER数次\r\n※每次GAME OVER选择REPLAY继续游戏\r\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\r\n\r\n存档E 调查地板 调查后面的黑板\r\n\r\n■地下１层\r\n &gt;绿色的房间 拉绳索\r\n左\r\n&gt;回到绿色的房间\r\n拉绳索\r\n正中\r\n&gt;回到绿色的房间\r\n拉绳索\r\n右\r\n&gt;回到绿色的房间\r\n问问理树的意见\r\n\r\n■地下２层\r\n &gt;黄色的房间\r\n听听理树的意见\r\n&gt;绿色的房间 试试看 &gt;回到绿色的房间\r\n&gt;再回到绿色的房间 跳进去\r\n\r\n■地下３层 \r\n&gt;绿色的房间 飞身退避 &gt;回到绿色的房间 登上石像\r\n\r\n■地下４层 \r\n&gt;绿色的房间\r\n进入沸水里 还是要进去 &gt;红色的房间→绿色的房间\r\n\r\n■地下５层\r\n &gt;红色的房间 去弄清楚 &gt;绿色的房间 寻找别的方法\r\n&gt;红色的房间 脱掉衣服 连内裤都脱掉 &gt;绿色的房间\r\n\r\n■地下６层\r\n\r\n\r\nimg\r\n\r\n&gt;经过4个房间后向迷宫正中心移动\r\n\r\n\r\nimg\r\n\r\n&gt;往黄色的地点进行爆破→绿色的房间→红色的房间 移动\r\n&gt;绿色的房间 打开这个房间的棺材\r\n\r\n■地下７层 \r\n&gt;在迷宫内侧走“８”字 问问理树君的意见\r\n\r\n\r\nimg\r\n\r\n&gt;在迷宫内侧走“５”字\r\n\r\n■地下８层 &gt;右下方尽头\r\n\r\n※在标题画面选择Start里New Game继续\r\n5月14日Mon\r\n出声招呼 可以\r\n(可以)\r\n(可以)\r\n(可以)\r\n\r\n5月15日Tue\r\n不借 不管她 去取 返回学校\r\n\r\n5月16日Wed\r\n自己想办法上去 结束算了 不好\r\n\r\n5月17日Thu (沙耶END)\r\n取下来 没有 制止 沙耶END\r\n\r\n沙耶线的流程图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n※如果之前未攻略过沙耶线，此路线结束后请攻略朱鹭户沙耶(笨蛋理树ver)，回收CG和部分内容会有变化。\r\n\r\n朱鹭户 沙耶(笨蛋理树ver)①\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n读取存档A\r\n5月15日Tue\r\n出声招呼\r\n※如果此处出现询问「想要能再次攻略沙耶线吗?」选「是」开启沙耶线\r\n去取 返回学校\r\n\r\n5月16日Wed\r\n乞求帮助 结束算了 我会逃掉的 和她合作 太阳塔 罗森\r\nFamima\r\n\r\n5月17日Thu\r\n没有 沉默\r\n※射击游戏OFF 不放弃\r\n\r\n5月18日Fri\r\n呼喊 呼唤爱 对她说谎 最喜欢了 绝对是恭介\r\n\r\n※在迷宫部分，符号“&gt;”表示提示\r\n\r\n■地下１层\r\n &gt;先去岔路上方的房间  &gt;之后进入岔路右边的房间 朱鹭户\r\n坚持要跳\r\n\r\n■地下２层\r\n &gt;先走一遍迷宫外侧 \r\n&gt;最后进入中间的房间 往左转 回转一圈\r\n\r\n5月19日Sat\r\n不比 十分有趣\r\n\r\n■地下３层\r\n&gt;为了把地图全部发现在各个地方走一遍 \r\n&gt;反复5次左右进入有陷阱的房间 \r\n&gt;最后进入右上方尽头的房间 让朱鹭户去 布(此处选项可随意选择)\r\n\r\n■地下４层\r\n&gt;为把地图全部发现在各个地方走一遍\r\n\r\n\r\nimg\r\n\r\n&gt;最后进入左上方3个房间中顶部的房间 到房间外面去调查\r\n\r\n5月20日Sun\r\n想和朱鹭户同学待在一起 问她喜欢什么样的男人 其实我年纪比你大啊？\r\n(试一下)\r\n有巧克力条纹的甜甜圈\r\n\r\n■地下５层\r\n&gt;为把地图全部发现在各个地方走一遍 \r\n&gt;最后进入右下方的房间 边赏龙边喝冰镇酒 更加努力 更加努力\r\n\r\n■地下６层 \r\n&gt;其中一边黄色地点→另一边黄色地点→红色点的房间 重新看一次这层的地图 死\r\n &gt;返回其中一边黄色地点\r\n&gt;打通地图成“王”字→右边的空房间→右边另一间空房间 打开这个房间的棺材\r\n去找木乃伊 &gt;在各个房间寻找\r\n\r\n5月21日Mon\r\n(随便读一下) 西园 铃 我和恭介在交往中 来谷 西园 就此结束\r\n\r\n5月22日Tue\r\n蒙混过去 去食堂 最后再去 去追恭介 握她的手\r\n\r\n■地下７层\r\n &gt;把迷宫全部走遍 试试碰她的手 &gt;在迷宫内侧移动\r\n试试抚摸她的头\r\n&gt;回到起点的房间\r\n&gt;反复走错路6次以上(例如向前走一步然后向后走一步) \r\n&gt;按一笔书规则在迷宫内侧走“８”字\r\n\r\n■地下８层\r\n&gt;把迷宫全部走一遍  &gt;右下方尽头\r\n\r\n■地下８层\r\n&gt;右下方尽头 开枪 &gt;在各处寻找\r\n\r\n●重播 ※为完成此路线必须按步骤GAME\r\nOVER数次\r\n※每次GAME OVER选择REPLAY继续游戏\r\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\r\n\r\n朱鹭户 沙耶(笨蛋理树ver)②\r\n存档E\r\n移动桌子 试着移动桌子 调查后面的黑板\r\n\r\n■地下１层\r\n\r\n&gt;重复3次进入红色的房间(进入房间REPLAY后再返回此房间如此类推)\r\n&gt;之后进入绿色的房间 拉绳索\r\n左\r\n&gt;回到绿色的房间\r\n拉绳索\r\n正中\r\n&gt;回到绿色的房间\r\n拉绳索\r\n右\r\n&gt;回到绿色的房间\r\n问问理树的意见\r\n\r\n■地下２层\r\n &gt;重复3次进入红色的房间 &gt;之后进入绿色的房间 还是自己上\r\n&gt;回到绿色的房间 紧抱住把手 &gt;回到绿色的房间\r\n\r\n■地下３层\r\n &gt;重复3次进入红色的房间 &gt;之后进入绿色的房间 用枪应战\r\n&gt;回到绿色的房间 &gt;再回到绿色的房间 拿剑 &gt;回到绿色的房间\r\n\r\n■地下４层\r\n &gt;先进入绿色的房间 进入沸水里 还是要进去\r\n&gt;回到绿色的房间 想别的办法 &gt;红色的房间\r\n&gt;逃脱之后再回到红色的房间 不相信 &gt;回到红色的房间 相信理树君\r\n&gt;逃脱后进入绿色的房间\r\n\r\n■地下５层\r\n &gt;红色的房间 去弄清楚 &gt;之后绿色的房间 用冰雕出龙\r\n&gt;红色的房间 裸足下去 &gt;回到红色的房间 脱掉衣服 不要越过这条线\r\n&gt;回到红色的房间 脱掉衣服 &gt;绿色的房间\r\n\r\n■地下６层\r\n\r\n\r\nimg\r\n\r\n&gt;经过4个房间后向迷宫正中心移动\r\n\r\n\r\nimg\r\n\r\n&gt;往黄色的地点进行爆破→绿色的房间→红色的房间 打开这个房间的棺材\r\n&gt;往黄色的地点移动→绿色的房间 打开这个房间的棺材\r\n\r\n■地下７层\r\n &gt;在迷宫内侧走“８”字 问问理树君的意见  &gt;在迷宫内侧走“５”字\r\n\r\n■地下８层\r\n&gt;右下方尽头\r\n\r\n※在标题画面选择Start里New Game继续\r\n5月14日Mon\r\n出声招呼 可以 (可以) (可以) (可以)\r\n\r\n5月15日Tue\r\n不借 不管她 去取 返回校舍\r\n\r\n5月16日Wed\r\n自己想办法上去 结束算了 不怎么好\r\n\r\n5月17日Thu (沙耶BAD END)\r\n存档F 不取下来 没有 制止 沙耶BAD END\r\n\r\n※如果在Refrain之前\r\n(沙耶TRUE END)\r\n读取存档F 取下来 没有 制止 沙耶TRUE END\r\n\r\n※如果在Refrain之后 (沙耶TRUE\r\nEND)\r\n读取存档F 取下来 没有 就这么等待着\r\n存档G 是沙耶同学赢了 制止 沙耶TRUE END\r\n\r\n读取存档G (沙耶CG回收)\r\n是我赢了 沙耶CG回收\r\n\r\n※这样能避免一部分CG和选项不出现\r\n情况是在完成Refrain后而且是笨蛋理树，需要笨蛋沙耶推进。\r\n如果按照上述攻略到Refrain后再来攻略的话将会全部出现\r\n\r\nSchoolRevo 学园革命线\r\n※此路线必须完成一次沙耶END后才能开启\r\n\r\n●重播 ※为完成此路线必须按步骤GAME\r\nOVER数次\r\n※每次GAME OVER选择REPLAY继续游戏\r\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\r\n\r\n读取存档E\r\n移动桌子 试着移动桌子 调查后面的黑板\r\n\r\n■地下１层\r\n※必须开启射击游戏，难度自行选择 \r\n&gt;重复3次以上进入红色的房间(进入房间后REPLAY再返回此房间如此类推)\r\n※直到沙耶说「搞什么，谁会喜欢啊！！」为止\r\n&gt;绿色的房间 拉绳索\r\n左\r\n&gt;回到绿色的房间\r\n拉绳索\r\n正中\r\n&gt;回到绿色的房间\r\n拉绳索\r\n右\r\n&gt;回到绿色的房间\r\n问问理树的意见\r\n\r\n■地下２层\r\n &gt;重复3次以上进入红色的房间\r\n※直到沙耶说「很好，来吧—！！ 毒蛇们、COME ON–！！」为止\r\n&gt;绿色的房间 还是自己上 &gt;回到绿色的房间 紧抱住把手\r\n&gt;回到绿色的房间\r\n\r\n■地下３层\r\n &gt;按黄色的路线移动(为避免进入绿色的房间)\r\n&gt;重复3次以上进入红色的房间\r\n※直到沙耶说「喂，来吧—-！！」为止 &gt;绿色的房间\r\n用枪应战 &gt;回到绿色的房间 &gt;再回到绿色的房间 拿剑\r\n&gt;回到绿色的房间\r\n\r\n■地下４层\r\n &gt;绿色的房间 进入沸水里 还是要进去 &gt;回到绿色的房间\r\n进入沸水里 还是要进去 &gt;回到绿色的房间 进入沸水里 还是要进去\r\n※看到沙耶说「开水、我–来–啦–！！」为止 &gt;红色的房间\r\n&gt;逃脱之后再回到红色的房间 不相信 &gt;回到红色的房间 不相信\r\n&gt;回到红色的房间 不相信 ※看到沙耶说「水、COME\r\nON—-！」为止 &gt;回到红色的房间 相信理树君 &gt;绿色的房间\r\n\r\n■地下５层\r\n &gt;红色的房间 去弄清楚\r\n&gt;绿色的房间 用冰雕出龙\r\n&gt;红色的房间 裸足下去\r\n&gt;回到红色的房间 裸足下去\r\n&gt;回到红色的房间 裸足下去\r\n※看到沙耶说「哟嚯———–…」为止\r\n&gt;回到红色的房间 脱掉衣服 不要越过这条线\r\n&gt;回到红色的房间 脱掉衣服 &gt;绿色的房间\r\n\r\n■地下６层\r\n &gt;经过4个房间后向迷宫正中心移动  &gt;往黄色的地点进行爆破→绿色的房间→红色的房间\r\n打开这个房间的棺材\r\n&gt;回到红色的房间 打开这个房间的棺材\r\n&gt;回到红色的房间 打开这个房间的棺材\r\n※看到沙耶说「我来送死了！ 嘿，陷阱COME\r\nON—-！！」为止\r\n&gt;绿色的房间 打开这个房间的棺材\r\n\r\n■地下７层\r\n&gt;现在！！必须要做的就是让沙耶不断去被镭射光XXOO\r\n(向前走一步然后往后走一步即可实现)\r\n※直到沙耶说「很好，镭射光，COME ON—！」\r\n※看屏幕出现\r\n  沙耶M觉醒,能发动Ecstasy模式\r\n于是我们的革命战争开始了！！\r\n &gt;在迷宫内侧走“８”字 问问理树君的意见\r\n\r\n■地下８层 (SchoolRevo END)\r\n &gt;右下方的路口\r\n※在与时风战斗时Ecstasy模式发动后并不能够无限回复生命，被击中6次就会失败，建议在战斗前存档\r\n当受到几次伤害之后Ecstasy模式发动，打败时风瞬 SchoolRevo END\r\n\r\n真人 肌肉线\r\n※此路线即使不攻略也不会对其他路线有影响\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n5月14日Mon\r\n就这样看着 不怎么好 不怎么好 不怎么好 不怎么好\r\n\r\n5月15日Tue\r\n不借 不管她 用别的笔记代替\r\n\r\n5月16日Wed\r\n用手机读取QR code 让他自己去 结束算了 帮忙找\r\n\r\n5月17日Thu\r\n没有 沉默\r\n进入手机网站\r\n接着读吧(×133) (去追铃) (就这样看着) 去屋顶\r\n\r\n5月18日Fri\r\n我 西园 (留在中庭) 她到底问了什么呢？ 西园 去食堂 和真人玩\r\n(感觉到了敌意) 制止她\r\n\r\n5月19日Sat\r\n(不看) 与真人玩 和真人玩 帮忙\r\n\r\n5月20日Sun\r\n去\r\n(找人) 真人 普通的甜甜圈\r\n\r\n5月21日Mon\r\n(随便读一下) 和真人玩 (去练习) 就此结束 真人 铃\r\n\r\n5月22日Tue\r\n清扫用具的整理 和真人玩 去食堂 我先 真人 去追恭介 听听她们在说什么\r\n对着库特点头. 和恭介他们一起玩\r\n真的\r\n\r\n5月23日Wed\r\n和库特打招呼\r\n去食堂 拒绝 和真人玩 去听听在谈些什么 打扫一下吧 上前搭话\r\n去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 回教室 去听听她们在说些什么 库特 美鱼\r\n\r\n5月25日Fri\r\n就这样决定了 (躲进去) 拒绝 结束 (兔子) (乔)\r\n\r\n5月27日Sun （真人 肌肉END）\r\n要不要我来拿东西呢？ 真人的\r\n我和真人 (去调查下关于昨晚的疑问) 肌肉 肌肉 肌肉 就算如此还是肌肉\r\n真人 肌肉END\r\n\r\n游戏攻略常见问题\r\n■Ｑ.看不到库特线的TRUE END2。\r\n□Ａ.在游戏起始的讯问「你知道世界的秘密吗?」选「是」在完成库特TRUE\r\nEND1和BAD END后会出现\r\n​ 追加选项。选「否」需要完成库特TRUE END1和BAD\r\nEND以及Refrain后会出现追加选项。\r\n■Ｑ.攻略沙耶线到后期直接回到了标题画面。\r\n□Ａ.从最初遇见沙耶处继续攻略会有不同剧情。\r\n■Ｑ.无法取回沙耶剩余的CG和Hscene。\r\n□Ａ.走笨蛋理树线的话可以回收不足的CG。\r\n​\r\n在完成因各种陷阱死去的沙耶线路重播(Replay)后，再一次进入沙耶线会追加选项。\r\n■Ｑ.无法再次进入朱鹭户沙耶线。\r\n□Ａ.Clear所有角色(包括EX追加角色)并完成Refrain线，之后选择“New\r\nGame”到5月15日会追加\r\n​ 「想要能再次攻略沙耶线吗?」的询问。\r\n■Ｑ.无法取回佳奈多的剩余CG。 □Ａ.在叶留佳线获得。\r\n■Ｑ.来谷的CG没有填满。 □Ａ.请在Refrain之后再一次攻略来谷。\r\n■Ｑ.没有铃的Hscene啊。\r\n□Ａ.Refrain完后再开一次Refrain，这次记得向铃求婚哦。\r\n■Ｑ.小毬线Clear之后还差一张CG。\r\n□Ａ.铃END1之后，22日的选项选择「去」女生宿舍。\r\n※如果在“知道世界的秘密”的情况下2周目回收可能。\r\n■Ｑ.小毬不同种类的内裤CG回收不能。\r\n□Ａ.20日的甜甜圈选项会影响24日小毬CG的变化。请按攻略走3次。\r\n■Ｑ.找不到佐佐美的Hscene。 □Ａ.进入路线以后请按攻略进行。\r\n(猫食→默不作声地拿出猫粮→娶她→待在她身边→我也…)\r\n■Ｑ.虽然看到了美鸟的Hscene，但是没看到美鱼的。(世界的秘密：不知道)\r\n□Ａ.请在最后的选项之前「善意or恶意」存档\r\n美鱼END之后读取存档选择「善意」。\r\n※(世界的秘密：知道)只需一次就能看到Hscene。\r\n■Ｑ.怎样决定攻略的顺序才好呢？\r\n□Ａ.※不知道世界的秘密的情况下，推荐以下攻略顺序\r\n共通线→(铃BAD\r\nor小毬or库特or叶留佳or来谷or西园)→铃END1→Refrain→\r\n​ (库特TRUE2＆来谷TRUE2 or\r\nRefrain)or佐佐美or佳奈多or沙耶\r\n\r\n※知道世界的秘密的情况下(沙耶、佐佐美、佳奈多在Refrain前后都可以攻略)\r\n​ 共通线→沙耶or佳奈多or佐佐美or(铃BAD\r\nor小毬or库特or叶留佳or来谷or西园)→\r\n​ 铃END1→Refrain→(来谷TRUE2 or\r\nRefrain)→沙耶(为了回收不同的CG)\r\n\r\n\r\n\r\nimg\r\n\r\n\r\nErgouTree 进行整理\r\n","categories":["其他","galgame相关","攻略"],"tags":["其他","galgame","攻略","杂项"]},{"title":"Java难绷知识03--包装器类及其自动装箱和拆箱","url":"/posts/24697.html","content":"Java难绷知识03——包装器类及其自动装箱和拆箱\r\n本篇文章和之前的倾向稍微有些不同，这篇文章我不仅要讨论一些容易头疼的细节，而且我打算尝试讨论一下如何理解Java中的包装类以及自动拆箱和自动装箱\r\n\r\n自动装箱（Autoboxing）和自动拆箱（Unboxing）是在基本数据类型和它们对应的包装类之间“转换”的一个包装过程，其中\r\n装箱：基本数据类型包装成对应的包装类\r\n拆箱：包装类拆包装成基本数据类型\r\n自动拆装箱下，上述转换在代码中是隐式的，由编译器自动完成。 \r\n为什么Java要引入包装类，来包装起来数据类型\r\n其实很简单，原因就是因为：Java的面向对象语言，一切面向对象\r\n为了让基本类型也具有对象的特征，Java引入了包装器类，使得它具有了对象的性质\r\n\r\n统一数据类型处理\r\n基本数据类型不是对象，无法使用对象的特性,包装类将基本数据类型包装成对象，使其能够融入面向对象的编程体系\r\n在集合框架中，如ArrayList、HashMap等，它们只能存储对象类型。如果要将基本数据类型存储到这些集合中，就需要使用对应的包装类。\r\n\r\n使其支持多态\r\n包装类使得基本数据类型也能参与多态的实现。通过向上转型，不同的包装类对象可以被统一处理。\r\n例如，所有的包装类都继承自Number类（Boolean除外），可以在需要Number类型的地方使用Integer、Double等包装类对象，来满足Number的特别支持，也就是满足多态\r\n\r\n使其支持泛型和反射机制\r\n支持泛型\r\n在泛型代码中，类型参数必须是引用类型，不能是基本数据类型。这与泛型的实现原理有关，在编译后，泛型类型信息会被擦除，替换为其限定的类型，所以基本数据类型无法直接参与这种类型擦除机制。引入了包装器类\r\n用ArrayList存储整数时使用泛型作为例子 import java.util.ArrayList;import java.util.List;public class GenericWithWrapper &#123;    public static void main(String[] args) &#123;        // 使用Integer包装类在泛型中存储整数        List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();        intList.add(10);        int num = intList.get(0); // 自动拆箱    &#125;&#125;\r\n有兴趣可以试试String丢进去会咋样瞬间爆炸\r\n\r\n支持反射\r\n反射允许程序在运行时获取和操作类的信息\r\n那你基本数据类型就没法支持了，众所周知反射在java里面有多有用，所以引入了包装器类\r\n包装类为基本数据类型提供了对应的类对象，使得可以通过反射操作基本数据类型\r\n包装类在反射机制中为基本数据类型提供对象层面的操作能力\r\n通过Class.forName(“java.lang.Integer”)获取Integer包装类的Class对象，然后利用反射机制调用其构造函数创建Integer对象，同样，也可以通过反射调用包装类的方法。\r\npublic class ReflectionInWrapper &#123;    public static void main(String[] args) &#123;        try &#123;            // 获取Integer类的Class对象            Class&lt;?&gt; wrapperClass = Class.forName(&quot;java.lang.Integer&quot;);            // 通过反射调用构造函数创建对象            Object instance = wrapperClass.getConstructor(int.class).newInstance(10);            System.out.println(instance);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n基本数据类型及其细节\r\n为什么还要重新讲一下8\r\n种基本数据类型，很简单，因为他们是Java语言的基础，并且在自动装箱（autoboxing）和自动拆箱（unboxing）机制中扮演着关键角色（毕竟进行的是基本数据类型和引用数据类型的“转换”）\r\n #### 不厌其烦的八种基本数据类型\r\nJava是一种强类型语言，第一次变量赋值称为变量的初始化 8\r\n种基本数据类型可以分类为如下三类： 字符类型 char 布尔类型 boolean\r\n数值类型 byte、short、int、long、float、double \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n基本数据类型\r\n所占字节数（大小）\r\n备注\r\n\r\n\r\n\r\n\r\nbyte\r\n1字节\r\n表示范围 -128 到 127\r\n\r\n\r\nshort\r\n2字节\r\n表示范围 -32,768 到 32,767\r\n\r\n\r\nint\r\n4字节\r\n范围是-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)\r\n\r\n\r\nlong\r\n8字节\r\n范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807\r\n(2^63-1)\r\n\r\n\r\nfloat\r\n4字节\r\n大约 7 位有效数字\r\n\r\n\r\ndouble\r\n8字节\r\n大约 15 - 17 位有效数字\r\n\r\n\r\nchar\r\n2字节\r\n采用 Unicode 编码\r\n\r\n\r\nboolean\r\n通常占用 1 位\r\n\r\n\r\n\r\n\r\n\r\n类型转换问题（向上和向下取型）\r\n为什么上面我还要列个表格，就是要注意，在进行自动拆装箱和类型转换时，要注意数据的范围和精度问题，可能会隐藏一些类型转换错误。\r\n在 Java\r\n的基本数据类型中，类型转换分为自动类型转换（向上转型）和强制类型转换（向下转型）。\r\n自动类型转换（向上转型）：当把一个取值范围小的类型赋值给取值范围大的类型时，会自动进行转换。\r\n强制类型转换（向下转型）：当把一个取值范围大的类型赋值给取值范围小的类型时，需要进行强制类型转换，这可能会导致数据丢失。\r\n当基本数据类型自动装箱为包装器类时，也遵循自动类型转换的规则，转换的是包装器类所继承的类，例如，byte\r\n装箱为 Byte，Byte 可以自动向上转型为 Number（因为 Byte 继承自\r\nNumber）。\r\n当从包装器类自动拆箱为基本数据类型时，如果要进行向下转型，同样需要强制类型转换。\r\n跨类型的包装器转换：对于数值类型的包装器类，有时需要进行跨类型的转换。例如，将\r\nInteger 转换为 Double。这需要先拆箱再装箱。\r\nInteger intValue = 10;// 先拆箱为int，再装箱为DoubleDouble doubleValueFromInt = new Double(intValue); \r\nboolean 类型及其包装类 Boolean\r\n与其他基本数据类型和包装类之间不存在类型转换关系。boolean 类型只有 true\r\n和 false 两个值，不能转换为数值类型或其他类型。\r\nchar 类型及其包装类 Character 可以与数值类型进行一些转换。 char\r\n本质上是一个无符号的 16 位整数，所以 char 可以自动转换为 int 类型。\r\nCharacter charValue = &#x27;A&#x27;;int intValueFromChar = charValue; // 自动装箱后，Character可自动转换为int\r\n\r\n有关溢出\r\n在基本数据类型下，进行同类型数值运算的时候溢出并不会抛异常，也没有任何提示，需要注意\r\n包装器类下溢出的情况代码 public class WrapperOverflowExample &#123;    public static void main(String[] args) &#123;        Integer maxInt = Integer.MAX_VALUE;        // 尝试增加1        Integer result = maxInt + 1;        System.out.println(&quot;运算结果: &quot; + result);    &#125;&#125; 以上例而言，Integer.MAX_VALUE 是\r\nint 类型能表示的最大值。当对 maxInt 加 1 时，会发生溢出，结果变为\r\nInteger.MIN_VALUE，这和直接使用 int 基本数据类型进行运算溢出的情况一致。\r\n所以处理极大数的时候，我们偏向使用 BigInteger 和 BigDecimal 类\r\nJava中的数值类型不存在无符号的，它们的取值范围是固定的 \r\n伏笔\r\n实际上，Java中还存在另一种基本类型void，它也有对应的包装类java.lang.Void，不过他很特殊，我们无法直接对它们进行操作，这个在下面我会特意说\r\n\r\n基本数据类型及其包装类\r\n八种基本数据类型都分别都有对应的包装类，如下表\r\n\r\n\r\n\r\n基本数据类型\r\n包装类\r\n缓存值范围\r\n\r\n\r\n\r\n\r\nboolean\r\njava.lang.Boolean\r\ntrue和false\r\n\r\n\r\nbyte\r\njava.lang.Byte\r\n-128～127\r\n\r\n\r\nchar\r\njava.lang.Character\r\n0 ~ 127\r\n\r\n\r\nfloat\r\njava.lang.Float\r\n没有缓存\r\n\r\n\r\nint\r\njava.lang.Integer\r\n-128～127\r\n\r\n\r\nlong\r\njava.lang.Long\r\n-128～127\r\n\r\n\r\nshort\r\njava.lang.Short\r\n-128～127\r\n\r\n\r\ndouble\r\njava.lang.Double\r\n没有缓存\r\n\r\n\r\n\r\n有关记忆：在这八个类名中，除了Integer和Character类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。\r\n\r\n包装类的方法与常量\r\n首先，使用和声明包装器类需要实例化，因为包装器类对象，需要进行实例化，才能对变量数据进行处理。\r\n包装类提供了丰富的方法和常量方便对基本数据类型进行操作\r\n方法\r\n构造方法（在 Java 9 及之后不推荐使用） Integer(int value)Integer i = new Integer(1000);\r\n\r\n因为我们更多使用静态工厂方法：（也就是valueOf进行装箱） 例如\r\nvalueOf(byte b)：返回一个表示指定 byte 值的 Byte 实例。例如：Byte byteObj = Byte.valueOf((byte)5);valueOf(String s)：返回表示字符串指定值的相应包装类实例，其值由字符串参数解析得到例如：Integer intFromString = Integer.valueOf(&quot;123&quot;);，但字符串必须是合法的数值表示，否则会抛出 NumberFormatException。\r\n\r\n解析方法：\r\nparseXxx()\r\n该方法用于将字符串解析为对应的基本数据类型。字符串必须是合法的数值表示形式，否则会抛出\r\nNumberFormatException int num = Integer.parseInt(&quot;123&quot;);double d = Double.parseDouble(&quot;3.14&quot;);\r\n特殊的一点，在parseBoolean(String s)，将字符串参数解析为 boolean\r\n值时候\r\n如果输入的字符串不是 “true”（不区分大小写），该方法将返回 false。\r\n这种设计使得 Boolean.parseBoolean\r\n方法在处理非标准布尔字符串输入时，有一个明确且一致的返回值，不会抛出异常，而是统一返回\r\nfalse。\r\n\r\n转换方法：\r\nXxxValue()\r\n该方法以Xxx类型返回输入的Byte、Short、Integer、Long、Float、Double\r\n的值\r\n例如： shortValue()以 short 类型返回此 Short、Integer、Long、Float、Double 的值。Long l = 20L; short s = l.shortValue();\r\n其中在Character中，还有一些字符判断方法和字符转换方法，看一下就会用，也没啥特殊之处需要注意，就不在这里说了。\r\n\r\n常量\r\nMIN_VALUE 和 MAX_VALUE\r\n每个数值型包装类和Character都有这两个常量，分别表示该类型能够表示的最大值和最小值。\r\n例如，Integer.MAX_VALUE 表示 int\r\n类型能表示的最大整数值，Double.MIN_VALUE 表示 double\r\n类型能表示的最小正非零值（接近零）。\r\n在Character中，Character.MIN_VALUE 表示 char 类型能表示的最小 Unicode\r\n代码点（‘000’），Character.MAX_VALUE 表示 char 类型能表示的最大 Unicode\r\n代码点（‘’）。\r\n在Character中，Character.MIN_VALUE和Character.MAX_VALUE分别表示所缓存的最大值\r\n\r\nTRUE 和 FALSE\r\n两个常量分别表示布尔值 true 和 false。它们是 Boolean\r\n类的静态成员，用于获取对应的 Boolean 对象。\r\n在使用 Boolean 对象时，推荐使用这两个常量，而不是通过 new\r\nBoolean(true) 或 new Boolean(false)\r\n创建对象，因为后者会创建新的对象实例，可能会引起问题 \r\n基本数据类型和包装类需要注意的问题\r\n缓存机制：部分包装类（如\r\nInteger、Byte、Short、Long、Character）在一定范围内会缓存对象。就拿Integer来说，Integer缓存了\r\n-128 到 127 之间的整数。这意味着在这个范围内，相同值的对象是共享的。\r\nInteger a = 100; Integer b = 100; System.out.println(a == b); // 输出 true，因为 a 和 b 引用的是缓存中的同一个对象Integer c = 200; Integer d = 200; System.out.println(c == d); // 输出 false，因为 200 超出缓存范围，c 和 d 是不同的对象\r\n\r\n自动拆装箱\r\n如何理解自动拆装箱\r\n从用途上理解其实就是下述这样，自动装箱就是将基本数据类型自动转换为封装类型，自动拆箱是将封装类型自动转换为基本数据类型。\r\n但是其实编译器的自动执行情况如下：\r\n自动装箱，相当于Java编译器替我们执行了 Integer.valueOf(XXX);\r\n自动拆箱，相当于Java编译器替我们执行了Integer.intValue(XXX)\r\n/ 自动装箱 Autoboxing// Xxx.valueOf(xxx i)// 编译器会转成 Integer.valueOf(int i) 进行自动装箱Integer i = 100;Integer j = Integer.valueOf(100);System.out.println(&quot;i == j --&gt; &quot; + (i == j));j = Integer.valueOf(i);System.out.println(&quot;i == j --&gt; &quot; + (i == j));// 直接创建包装器类型的对象Integer k = new Integer(100);System.out.println(&quot;i == k --&gt; &quot; + (i == k));// 拆箱 Unboxing// Xxx..xxxValue()// 编译器会转成 Integer.intValue() 进行拆箱int m = i;System.out.println(&quot;i == m --&gt; &quot; + (i == m));\r\n\r\n参考：https://www.cnblogs.com/wpbxin/p/14311010.html\r\n\r\n\r\n什么时候会发生自动拆装箱\r\n 赋值操作 = ： 原始数据类型与对应包装器类型之间的相互赋值操作 =\r\n，会自动装箱(拆箱)\r\n注意：注：原始数据类型赋值给 Long ，都需要明确标出是长整型\r\n\r\n作为方法参数：\r\n例如包装器类型.equals(原始数据类型)，原始数据类型会自动装箱。\r\nInteger.equals(1)\r\n如果方法参数接收的是原始数据类型，则传入包装器类型时会拆箱；如果方法参数接收的是包装器类型，则传入原始数据类型时会自动装箱。\r\n作为方法返回值：\r\n方法返回值是包装器类型：如果返回的是原始数据类型，会自动装箱\r\n方法返回值是原始数据类型：如果返回的是包装器类型，会拆箱。\r\n\r\n算术运算和比较运算:\r\n在对包装类对象进行算术运算（如加、减、乘、除等）或比较运算（如\r\n==、&gt;、&lt;\r\n等）时，会发生自动拆箱。因为这些运算符通常只适用于基本数据类型。\r\nInteger num3 = 10;Integer num4 = 20;int sum = num3 + num4; // num3 和 num4 自动拆箱为基本数据类型 int 后进行加法运算boolean isGreater = num3 &gt; num4; // num3 和 num4 自动拆箱为基本数据类型 int 后进行比较运算\r\n\r\n集合操作:\r\n当向集合（如 List、Set、Map\r\n等）中添加基本数据类型时，会发生自动装箱，因为集合只能存储对象。\r\n当从集合中获取元素并赋值给基本数据类型变量时，会发生自动拆箱。\r\nimport java.util.ArrayList;import java.util.List;public class CollectionExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int num = 5;        list.add(num);         // 这里将 int 类型的 num 自动装箱为 Integer 后添加到 list 中        int retrievedNum = list.get(0);         // 这里将从 list 中获取的 Integer 对象自动拆箱为 int 类型并赋给 retrievedNum    &#125;&#125;\r\n\r\n一定要注意Java自动拆装箱的类型敏感问题，空指针问题和性能敏感问题\r\n\r\n自动拆装箱需要注意的问题和细节\r\n\r\n空指针异常：\r\n当对一个 null 值的包装类对象进行自动拆箱时，会抛出\r\nNullPointerException; 因为自动拆箱实际是调用包装类对象的 xxxValue\r\n方法，null 对象无法调用该方法。\r\n\r\n装箱拆箱有开销：\r\n自动装箱和拆箱过程涉及对象的创建与销毁，相较于直接操作基本数据类型，会带来额外的性能开销。在性能敏感的场景（如频繁的循环操作）中，应尽量减少自动拆装箱的使用。\r\n可以用如下代码了解自动拆装箱的性能开销 long startTime = System.currentTimeMillis();for (int i = 0; i &lt; 1000000; i++) &#123;    Integer wrapper = i;     int primitive = wrapper; &#125;long endTime = System.currentTimeMillis();System.out.println(&quot;Time taken: &quot; + (endTime - startTime) + &quot; ms&quot;);\r\n\r\n方法重载与自动拆装箱：\r\n在方法重载的情况下，自动拆装箱可能导致选择错误的方法。\r\n例如，当有一个方法接受 int 参数，另一个方法接受 Integer\r\n参数时，传递一个 Integer 对象可能会调用接受 Integer\r\n参数的方法，而不是自动拆箱后调用接受 int 参数的方法。\r\npublic class AutoBoxingOverload &#123;    public static void print(Object obj) &#123;        System.out.println(&quot;Object method: &quot; + obj);    &#125;    public static void print(int num) &#123;        System.out.println(&quot;int method: &quot; + num);    &#125;    public static void main(String[] args) &#123;        Integer i = 10;        print(i);         // 调用 print(Object obj) 方法，可能与预期不符    &#125;&#125;\r\n\r\n运算：\r\n当 ==\r\n运算符的两个操作数都是包装器类型引用，则比较指向的是否是同一个对象，而如果其中有一个操作数是原始数据类型（包含表达式结果）则比较的是数值（即会触发自动拆箱）。\r\n不同类型的包装器不能 == 比较，报错提示：Incompatible operand types\r\nLong and Integer\r\n\r\n有关void和Void\r\nvoid 是 Java 中的一种特殊数据类型，它表示 “无类型” 或 “空类型”\r\nJava不能声明 void 类型的变量，void 不能作为数组元素类型。\r\n\r\nVoid包装类:\r\nVoid 是 void\r\n对应的包装类，它是一个不可实例化的类（其构造函数是私有的）。Void\r\n类主要用于与 Java 反射机制和泛型等特性交互。\r\n\r\n特殊之处如下：\r\nVoid 类没有公共的构造函数，所以无法创建 Void 类的实例。 因为 void\r\n本身表示无值，创建 Void 实例没有实际意义。\r\n唯一常量 TYPE：Void 类包含一个公共的静态成员 TYPE 它是一个\r\nClass 类型的对象，用于表示 void 类型本身。\r\n在反射中获取一个返回 void 的方法的返回类型 import java.lang.reflect.Method;public class VoidExample &#123;    public void voidMethod() &#123;&#125;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method method = VoidExample.class.getMethod(&quot;voidMethod&quot;);        if (method.getReturnType() == Void.TYPE) &#123;            System.out.println(&quot;The method returns void.&quot;);        &#125;    &#125;&#125;\r\n\r\n不要混淆 Void 与 void：虽然 Void 是 void\r\n的包装类，但它们的使用场景和语义有很大区别。void\r\n用于声明方法返回类型或在特定语义中表示无值，而 Void\r\n主要用于在需要对象表示 void 类型的场景\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","学习","JavaSE","语言方面"]},{"title":"MATLAB part1-入门介绍和基础语法","url":"/posts/null.html","content":"MATLAB 基础\r\nMATLAB简介\r\nMATLAB是MathWorks开发的一种编程语言。它最初是一种矩阵编程语言，线性代数编程很简单。它既可以在交互式会话下运行，也可以作为批处理作业运行。\r\nMATLAB是美国MathWorks公司出品的商业数学软件，用于数据分析、无线通信、深度学习、图像处理与计算机视觉、信号处理、量化金融与风险管理、机器人，控制系统等领域。\r\nMATLAB是matrix&amp;laboratory两个词的组合，意为矩阵工厂（矩阵实验室），软件主要面对科学计算、可视化以及交互式程序设计的高科技计算环境。它将数值分析、矩阵计算、科学数据可视化以及非线性动态系统的建模和仿真等诸多强大功能集成在一个易于使用的视窗环境中，为科学研究、工程设计以及必须进行有效数值计算的众多科学领域提供了一种全面的解决方案，并在很大程度上摆脱了传统非交互式程序设计语言（如C、Fortran）的编辑模式。\r\nMATLAB和Mathematica、Maple并称为三大数学软件。它在数学类科技应用软件中在数值计算方面首屈一指。行矩阵运算、绘制函数和数据、实现算法、创建用户界面、连接其他编程语言的程序等。MATLAB的基本数据单位是矩阵，它的指令表达式与数学、工程中常用的形式十分相似，故用MATLAB来解算问题要比用C，FORTRAN等语言完成相同的事情简捷得多，并且MATLAB也吸收了像Maple等软件的优点，使MATLAB成为一个强大的数学软件。在新的版本中也加入了对C，FORTRAN，C++，JAVA的支持。\r\n它允许矩阵操作；功能和数据绘制；算法的实现；创建用户界面；与使用其他语言（包括C，C\r\n++，Java和FORTRAN）编写的程序进行交互；分析数据；开发算法；并创建模型和应用程序。具有许多内置命令和数学函数，可帮助您进行数学计算，生成图和执行数值方法。\r\nMATLAB的计算数学能力\r\nMATLAB用于计算数学的各个方面。以下是一些最常用的数学计算方法\r\n\r\n处理矩阵和数组\r\n2-D和3-D绘图和图形\r\n线性代数\r\n代数方程\r\n非线性函数\r\n统计数据\r\n数据分析\r\n微积分和微分方程\r\n数值计算\r\n集成(Integration)\r\n变换(Transforms)\r\n曲线拟合\r\n各种其他特殊功能\r\n\r\nMATLAB的功能\r\n以下是MATLAB的基本功能\r\n\r\n它是用于数值计算，可视化和应用程序开发的高级语言。\r\n它还为交互式探索，设计和问题解决提供了一个交互式环境。\r\n它为线性代数，统计，傅立叶分析，滤波，优化，数值积分和求解常微分方程提供了庞大的数学函数库。\r\n它提供了用于使数据可视化的内置图形以及用于创建自定义图的工具。\r\nMATLAB的编程接口为开发工具提供了改善代码质量可维护性和最大化性能的工具。\r\n它提供了用于使用自定义图形界面构建应用程序的工具。\r\n它提供了将基于MATLAB的算法与外部应用程序和语言（例如C，Java，.NET和Microsoft\r\nExcel）集成在一起的功能。\r\n\r\n了解 MATLAB 环境\r\n启动MATLAB后，桌面将以其默认布局显示\r\n\r\n\r\nimage-20250531084550535\r\n\r\n桌面具有以下面板-\r\n\r\nCurrent Folder\r\n−此面板允许您访问项目文件夹和文件。\r\n\r\n\r\nimage-20250531084612222\r\n\r\nCommand\r\nWindow−这是可以在命令行输入命令的主要区域。它由命令提示符（&gt;&gt;）指示。\r\n\r\n\r\nimage-20250531084749518\r\n\r\n编辑器，编写MATLAB脚本的主要区域\r\n\r\n\r\nimage-20250531084713742\r\n\r\nWorkspace\r\n−工作区显示了从文件创建和/或导入的所有变量。\r\n\r\n\r\nimage-20250531084800974\r\n\r\nCommand History\r\n−此面板显示或返回在命令行输入的命令\r\n\r\nMATLAB 基本语法\r\nMATLAB环境的行为就像一个超级复杂的计算器。您可以在&gt;&gt;命令提示符下输入命令。\r\nMATLAB是一个解释型环境。换句话说，您给出了一个命令，MATLAB立即执行了该命令。\r\n在MATLAB中使用分号（;）\r\n分号（;）表示语句结束。但是，如果要隐藏和隐藏表达式的MATLAB输出，请在表达式后添加分号。\r\n当您单击Execute按钮或键入Ctrl +\r\nE时，MATLAB将立即执行它，并且返回结果\r\n\r\n\r\nimage-20250531085054115\r\n\r\n添加注释\r\n百分比符号（％）用于指示注释行。例如，\r\n\r\n\r\nimage-20250531085155030\r\n\r\n您还可以使用块注释运算符％{和％}编写注释块。\r\nMATLAB编辑器包括工具和上下文菜单项，可帮助您添加，删除或更改注释的格式。\r\n常用运算符和特殊字符\r\nMATLAB支持以下常用运算符和特殊字符\r\n\r\n\r\n\r\n运算符\r\n目的\r\n\r\n\r\n\r\n\r\n+\r\n加; 加法运算符。\r\n\r\n\r\n-\r\n减; 减法运算符。\r\n\r\n\r\n*****\r\n标量和矩阵乘法运算符。\r\n\r\n\r\n.*\r\n数组乘法运算符。\r\n\r\n\r\n^\r\n标量和矩阵求幂运算符。\r\n\r\n\r\n.^\r\n数组求幂运算符。\r\n\r\n\r\n****\r\n左除法运算符。\r\n\r\n\r\n/\r\n右除法运算符。\r\n\r\n\r\n**.**\r\n数组左除法运算符。\r\n\r\n\r\n./\r\n数组右除法运算符。\r\n\r\n\r\n:\r\n冒号；生成规则间距的元素并表示整行或整列。\r\n\r\n\r\n( )\r\n圆括号；封闭函数参数和数组索引；重写优先级。\r\n\r\n\r\n[ ]\r\n括号；附件数组元素。\r\n\r\n\r\n.\r\n小数点。\r\n\r\n\r\n…\r\n省略号；行连续运算符\r\n\r\n\r\n,\r\n逗号；分隔一行中的语句和元素\r\n\r\n\r\n;\r\n分号; 分隔列并抑制显示。\r\n\r\n\r\n%\r\n百分号；指定注释并指定格式。\r\n\r\n\r\n**_**\r\n引用符号和转置运算符。\r\n\r\n\r\n._\r\nNonconjugated转置运算符。\r\n\r\n\r\n=\r\n赋值运算符。\r\n\r\n\r\n\r\n特殊变量和常量\r\nMATLAB支持以下特殊变量和常量\r\n\r\n\r\n\r\n名称\r\n意义\r\n\r\n\r\n\r\n\r\nans\r\n最近计算的答案。\r\n\r\n\r\neps\r\n浮点精度。\r\n\r\n\r\ni,j\r\n虚数单位√-1。\r\n\r\n\r\nInf\r\n无穷。\r\n\r\n\r\nNaN\r\n未定义的数值结果（不是数字）。\r\n\r\n\r\npi\r\nπ\r\n\r\n\r\n\r\n命名变量\r\n变量名称由字母组成，后跟任意数量的字母，数字或下划线。\r\nMATLAB是 case-sensitive。\r\n变量名称可以是任意长度，但是，MATLAB仅使用前N个字符，其中N由函数给定\r\nnamelengthmax。\r\n保存 - save 命令\r\nsave命令用于将工作空间中的所有变量保存为当前目录中扩展名为.mat的文件\r\nMATLAB 脚本需要保存后才能运行\r\n以后可以随时使用load命令重新加载文件\r\nsave myfileload myfile\r\n","categories":["数学类","MATLAB"],"tags":["语法知识","学习","语言方面","数学","物理","数学建模"]},{"title":"MATLAB part3-数据类型与运算符","url":"/posts/35680.html","content":"MATLAB 数据类型\r\nMATLAB 采用了动态类型系统，这意味着您不需要像 C++ 或 Java\r\n那样预先声明变量的类型。当您创建一个新变量时，MATLAB\r\n会自动推断其类型并分配相应的内存空间。这种设计使得 MATLAB\r\n使用起来非常直观和灵活。\r\n% 无需声明类型，MATLAB自动推断x = 5;          % 自动识别为double类型name = &#x27;Alice&#x27;; % 自动识别为char类型flag = true;    % 自动识别为logical类型\r\nMATLAB 不需要任何类型声明或维度语句。每当 MATLAB\r\n遇到一个新的变量名，它就创建变量并分配适当的内存空间。\r\n如果变量已经存在，那么MATLAB将用新内容替换原始内容，并在必要时分配新的存储空间。\r\n这种动态特性与Python非常相似，但MATLAB有其独特的矩阵导向设计。在MATLAB中，所有数据本质上都是矩阵或数组，即使是单个数字也被视为1×1的矩阵。\r\n例如\r\nErgou = 55464\r\n上面的语句创建一个名为“Ergou”的1比1矩阵，并将值55464存储在其中。\r\nMATLAB中可用的数据类型\r\nMATLAB提供了15种基本数据类型。每种数据类型都存储矩阵或数组形式的数据。此矩阵或数组的大小最小为0×0，并且可以增长到任意大小的矩阵或数组。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n序号\r\n数据类型和说明\r\n\r\n\r\n\r\n\r\n1\r\nint88位有符号整数\r\n\r\n\r\n2\r\nuint88位无符号整数\r\n\r\n\r\n3\r\nint1616位有符号整数\r\n\r\n\r\n4\r\nuint1616位无符号整数\r\n\r\n\r\n5\r\nint3232位有符号整数\r\n\r\n\r\n6\r\nuint3232位无符号整数\r\n\r\n\r\n7\r\nint6464位有符号整数\r\n\r\n\r\n8\r\nuint6464位无符号整数\r\n\r\n\r\n9\r\nsingle单精度数值数据\r\n\r\n\r\n10\r\ndouble双精度数值数据\r\n\r\n\r\n11\r\nlogical逻辑值1或0，分别表示true和false\r\n\r\n\r\n12\r\nchar字符数据（字符串存储为字符向量）\r\n\r\n\r\n13\r\ncell\r\narray索引单元格数组，每个单元格能够存储不同维度和数据类型的数组\r\n\r\n\r\n14\r\nstructure类似于C的结构，每个结构都具有能够存储不同维度和数据类型的数组的命名字段\r\n\r\n\r\n15\r\nfunction\r\nhandle指向函数的指针\r\n\r\n\r\n16\r\nuser\r\nclasses从用户定义的类构造的对象\r\n\r\n\r\n17\r\njava\r\nclasses从Java类构造的对象\r\n\r\n\r\n\r\n整数类型\r\nMATLAB提供了8种不同的整数类型，分为有符号和无符号两大类：\r\n有符号整数类型：\r\n\r\nint8: 8位有符号整数，取值范围：-128 到 127\r\nint16: 16位有符号整数，取值范围：-32,768 到\r\n32,767\r\nint32: 32位有符号整数，取值范围：-2,147,483,648 到\r\n2,147,483,647\r\nint64:\r\n64位有符号整数，取值范围：-9,223,372,036,854,775,808 到\r\n9,223,372,036,854,775,807\r\n\r\n无符号整数类型：\r\n\r\nuint8: 8位无符号整数，取值范围：0 到 255\r\nuint16: 16位无符号整数，取值范围：0 到 65,535\r\nuint32: 32位无符号整数，取值范围：0 到\r\n4,294,967,295\r\nuint64: 64位无符号整数，取值范围：0 到\r\n18,446,744,073,709,551,615\r\n\r\n% 整数类型示例small_int = int8(100);        % 创建8位有符号整数large_uint = uint64(123456);  % 创建64位无符号整数% 查看变量信息whos small_int large_uint\r\n浮点数类型\r\nsingle（单精度浮点数）：\r\n\r\n32位IEEE 754标准\r\n大约7位十进制精度\r\n取值范围：约 ±1.18×10^-38 到 ±3.40×10^38\r\n\r\ndouble（双精度浮点数）：\r\n\r\n64位IEEE 754标准\r\n大约15-16位十进制精度\r\n取值范围：约 ±2.23×10^-308 到 ±1.80×10^308\r\nMATLAB的默认数值类型\r\n\r\n% 浮点数示例single_num = single(3.14159);  % 单精度double_num = 3.14159265359;    % 双精度（默认）% 精度比较fprintf(&#x27;Single precision: %.10f\\n&#x27;, single_num);fprintf(&#x27;Double precision: %.15f\\n&#x27;, double_num);\r\n逻辑类型（logical）\r\n逻辑类型是MATLAB中的布尔类型，只能存储true(1)或false(0)值。它在条件判断、数组索引和逻辑运算中扮演重要角色。\r\n% 逻辑类型示例is_positive = true;is_negative = false;% 逻辑数组logic_array = [true, false, true, false];% 用于数组索引numbers = [1, -2, 3, -4, 5];positive_mask = numbers &gt; 0;  % 返回逻辑数组positive_numbers = numbers(positive_mask);  % 提取正数\r\n字符类型（char）\r\n在MATLAB中，字符数据以字符数组的形式存储。每个字符占用16位（2字节），支持Unicode字符\r\n% 字符类型示例single_char = &#x27;A&#x27;;              % 单个字符char_array = &#x27;Hello World&#x27;;     % 字符数组（字符串）chinese_chars = &#x27;你好，世界&#x27;;    % 支持中文% 字符数组操作str1 = &#x27;Hello&#x27;;str2 = &#x27;World&#x27;;combined = [str1, &#x27; &#x27;, str2];   % 字符串连接\r\n复合数据类型\r\n单元数组（Cell Array）\r\n单元数组是MATLAB中最灵活的数据结构，可以在同一个数组中存储不同类型和大小的数据。\r\n% 单元数组示例mixed_cell = &#123;42, &#x27;Hello&#x27;, [1,2,3], true&#125;;% 访问单元数组元素number = mixed_cell&#123;1&#125;;      % 获取数字42text = mixed_cell&#123;2&#125;;        % 获取字符串&#x27;Hello&#x27;array = mixed_cell&#123;3&#125;;       % 获取数组[1,2,3]% 复杂单元数组student_data = &#123;    &#x27;Alice&#x27;, 25, [85, 90, 88], true;    &#x27;Bob&#x27;,   23, [78, 82, 85], false;    &#x27;Carol&#x27;, 24, [92, 89, 94], true&#125;;\r\n结构体（Structure）\r\n结构体类似于其他编程语言中的记录或对象，通过字段名来访问数据。\r\n% 结构体示例student.name = &#x27;Alice&#x27;;student.age = 20;student.grades = [85, 90, 88];student.is_graduate = false;% 结构体数组students(1).name = &#x27;Alice&#x27;;students(1).age = 20;students(2).name = &#x27;Bob&#x27;;students(2).age = 22;% 访问结构体字段first_student_name = students(1).name;all_names = &#123;students.name&#125;;  % 提取所有姓名\r\n函数句柄（Function Handle）\r\n函数句柄是指向函数的指针，允许您将函数作为变量传递。\r\n% 函数句柄示例sqrt_handle = @sqrt;          % 内置函数句柄result = sqrt_handle(16);     % 调用函数，result = 4% 匿名函数句柄square = @(x) x.^2;squared_values = square([1,2,3,4]);  % [1,4,9,16]% 将函数句柄作为参数传递function result = apply_function(func, data)    result = func(data);endnumbers = [1,2,3,4];squared = apply_function(@(x) x.^2, numbers);\r\n数据类型转换\r\nMATLAB提供了用于将值从一种数据类型转换为另一种数据的各种函数。下表显示了数据类型转换函数\r\n\r\n\r\n\r\n函数\r\n作用\r\n\r\n\r\n\r\n\r\nchar\r\n转换为字符数组（字符串）\r\n\r\n\r\nint2str\r\n将整数数据转换为字符串\r\n\r\n\r\nmat2str\r\n将矩阵转换为字符串\r\n\r\n\r\nnum2str\r\n将数字转换为字符串\r\n\r\n\r\nstr2double\r\n将字符串转换为双精度值\r\n\r\n\r\nstr2num\r\n将字符串转换为数字\r\n\r\n\r\nnative2unicode\r\n将数字字节转换为 Unicode 字符\r\n\r\n\r\nunicode2native\r\n将Unicode字符转换为数字字节\r\n\r\n\r\nbase2dec\r\n将N进制数字符串转换为十进制数\r\n\r\n\r\nbin2dec\r\n将二进制数字符串转换为十进制数\r\n\r\n\r\ndec2base\r\n将十进制数转换为字符串中的N进制数\r\n\r\n\r\ndec2bin\r\n将十进制转换为字符串中的二进制数\r\n\r\n\r\ndec2hex\r\n将字符串中的十进制数转换为十六进制数\r\n\r\n\r\nhex2dec\r\n将十六进制数字字符串转换为十进制数字\r\n\r\n\r\nhex2num\r\n将十六进制数字字符串转换为双精度数字\r\n\r\n\r\nnum2hex\r\n将单精度和双精度转换为IEEE十六进制字符串\r\n\r\n\r\ncell2mat\r\n将单元格数组转换为数值数组\r\n\r\n\r\ncell2struct\r\n将单元数组转换为结构数组\r\n\r\n\r\ncellstr\r\n从字符数组创建字符串的单元格数组\r\n\r\n\r\nmat2cell\r\n将数组转换为单元格大小可能不同的单元格\r\n\r\n\r\nnum2cell\r\n将数组转换为大小一致的单元格数组\r\n\r\n\r\nstruct2cell\r\n将结构转换为单元格数组\r\n\r\n\r\n\r\n显式类型转换\r\nMATLAB提供了丰富的类型转换函数，能够在不同数据类型之间进行转换。\r\n% 基本数值转换x = 3.14159;x_int = int32(x);           % 转换为32位整数：3x_single = single(x);       % 转换为单精度x_uint8 = uint8(x * 100);   % 转换为无符号8位整数：314% 处理溢出big_number = 300;small_int = int8(big_number);  % 结果被截断为127（int8最大值）% 数值转字符串number = 42;str_int = int2str(number);      % &#x27;42&#x27;str_num = num2str(3.14159);     % &#x27;3.1416&#x27;str_mat = mat2str([1,2,3]);     % &#x27;[1 2 3]&#x27;% 字符串转数值str = &#x27;123.45&#x27;;num_double = str2double(str);   % 123.45num_value = str2num(str);       % 123.45% 处理转换错误invalid_str = &#x27;abc&#x27;;result = str2double(invalid_str);  % 返回NaN% 进制转换示例decimal_num = 255;binary_str = dec2bin(decimal_num);    % &#x27;11111111&#x27;hex_str = dec2hex(decimal_num);       % &#x27;FF&#x27;octal_str = dec2base(decimal_num, 8); % &#x27;377&#x27;% 从其他进制转回十进制bin_str = &#x27;1010&#x27;;decimal = bin2dec(bin_str);           % 10hex_str = &#x27;FF&#x27;;decimal = hex2dec(hex_str);           % 255\r\n隐式类型转换\r\nMATLAB在某些情况下会自动进行类型转换：\r\n% 混合运算的隐式转换int_val = int8(10);double_val = 3.14;result = int_val + double_val;  % 结果为double类型% 逻辑值在数值运算中的转换logical_val = true;numeric_result = logical_val + 5;  % 结果为6（true被转换为1）\r\n数据类型的确定\r\nMATLAB提供了各种功能来识别变量的数据类型。\r\n下表提供了确定变量的数据类型的功能\r\n\r\n\r\n\r\n函数\r\n作用\r\n\r\n\r\n\r\n\r\nis\r\n检测状态\r\n\r\n\r\nisa\r\n确定输入是否为指定类的对象\r\n\r\n\r\niscell\r\n确定输入是否为单元格数组\r\n\r\n\r\niscellstr\r\n确定输入是否为字符串的单元格数组\r\n\r\n\r\nischar\r\n确定项目是否为字符数组\r\n\r\n\r\nisfield\r\n确定输入是否为结构数组字段\r\n\r\n\r\nisfloat\r\n确定输入是否为浮点数组\r\n\r\n\r\nishghandle\r\n适用于处理图形对象句柄\r\n\r\n\r\nisinteger\r\n确定输入是否为整数数组\r\n\r\n\r\nisjava\r\n确定输入是否为Java对象\r\n\r\n\r\nislogical\r\n确定输入是否为逻辑数组\r\n\r\n\r\nisnumeric\r\n确定输入是否为数值数组\r\n\r\n\r\nisobject\r\n确定输入是否为MATLAB对象\r\n\r\n\r\nisreal\r\n检查输入是否为实数数组\r\n\r\n\r\nisscalar\r\n确定输入是否为标量\r\n\r\n\r\nisstr\r\n确定输入是否为字符数组\r\n\r\n\r\nisstruct\r\n确定输入是否为结构数组\r\n\r\n\r\nisvector\r\n确定输入是否为向量\r\n\r\n\r\nclass\r\n确定对象的类别\r\n\r\n\r\nvalidateattributes\r\n检查数组的有效性\r\n\r\n\r\nwhos\r\n列出工作空间中的变量，包括大小和类型\r\n\r\n\r\n\r\n基本类型检测函数\r\n% 创建不同类型的数据num_data = 42;str_data = &#x27;Hello&#x27;;cell_data = &#123;1, &#x27;two&#x27;, 3&#125;;struct_data = struct(&#x27;name&#x27;, &#x27;Alice&#x27;, &#x27;age&#x27;, 25);% 类型检测fprintf(&#x27;num_data是数值类型: %d\\n&#x27;, isnumeric(num_data));fprintf(&#x27;str_data是字符类型: %d\\n&#x27;, ischar(str_data));fprintf(&#x27;cell_data是单元数组: %d\\n&#x27;, iscell(cell_data));fprintf(&#x27;struct_data是结构体: %d\\n&#x27;, isstruct(struct_data));% 获取具体类型fprintf(&#x27;num_data的具体类型: %s\\n&#x27;, class(num_data));fprintf(&#x27;str_data的具体类型: %s\\n&#x27;, class(str_data));\r\n高级类型检测\r\n% 检测数组特性data = [1, 2, 3, 4, 5];fprintf(&#x27;是否为向量: %d\\n&#x27;, isvector(data));fprintf(&#x27;是否为标量: %d\\n&#x27;, isscalar(data));fprintf(&#x27;是否为实数: %d\\n&#x27;, isreal(data));% 检测复数complex_data = 3 + 4i;fprintf(&#x27;是否为实数: %d\\n&#x27;, isreal(complex_data));fprintf(&#x27;是否为复数: %d\\n&#x27;, ~isreal(complex_data));% 使用isa进行精确类型检测fprintf(&#x27;是否为double类型: %d\\n&#x27;, isa(data, &#x27;double&#x27;));fprintf(&#x27;是否为数值类型: %d\\n&#x27;, isa(data, &#x27;numeric&#x27;));\r\n常见问题\r\n\r\n类型转换中的精度丢失\r\n% 问题：精度丢失original = 3.14159265359;converted = single(original);fprintf(&#x27;原始值: %.15f\\n&#x27;, original);fprintf(&#x27;转换后: %.15f\\n&#x27;, double(converted));\r\n整数溢出\r\n% 问题：溢出small_int = int8(100);overflow_result = small_int + int8(50);  % 结果被截断fprintf(&#x27;溢出结果: %d\\n&#x27;, overflow_result);safe_result = int16(small_int) + int16(50);\r\n逻辑索引的误用\r\n% 问题：混淆逻辑索引和线性索引data = [1, 2, 3, 4, 5];logical_mask = data &gt; 3;        % [false, false, false, true, true]linear_indices = find(data &gt; 3); % [4, 5]% 正确使用filtered_data1 = data(logical_mask);    % 使用逻辑索引filtered_data2 = data(linear_indices);  % 使用线性索引\r\n\r\n数据类型实例\r\n\r\n数据验证与错误处理\r\nfunction processed_data = process_numeric_data(input_data)    % 输入验证    if ~isnumeric(input_data)        error(&#x27;输入必须是数值类型&#x27;);    end        if ~isreal(input_data)        warning(&#x27;输入包含复数，将只处理实部&#x27;);        input_data = real(input_data);    end        % 数据处理    processed_data = input_data * 2;end\r\n混合数据结构的使用\r\n% 创建一个包含学生信息的复合数据结构function student_db = create_student_database()    % 使用结构体数组存储学生信息    students = struct();        % 学生1    students(1).id = uint32(1001);    students(1).name = &#x27;Alice Johnson&#x27;;    students(1).age = uint8(20);    students(1).grades = single([85.5, 90.0, 88.3]);    students(1).is_active = true;    students(1).courses = &#123;&#x27;Math&#x27;, &#x27;Physics&#x27;, &#x27;Chemistry&#x27;&#125;;        % 学生2    students(2).id = uint32(1002);    students(2).name = &#x27;Bob Smith&#x27;;    students(2).age = uint8(22);    students(2).grades = single([78.2, 82.7, 85.1]);    students(2).is_active = false;    students(2).courses = &#123;&#x27;Biology&#x27;, &#x27;Chemistry&#x27;, &#x27;English&#x27;&#125;;        student_db = students;end\r\n\r\nMATLAB 运算符\r\n运算符是MATLAB编程语言的基础构建块，它们告诉MATLAB解释器如何执行特定的数学、逻辑或比较操作。MATLAB的设计理念是”一切皆矩阵”，因此其运算符既可以处理标量数据，也可以高效地处理矩阵和数组数据。这种设计使得MATLAB在科学计算和工程应用中表现出色。\r\n\r\nMATLAB中的运算符可以分为以下几个主要类别：\r\n\r\n算术运算符：执行基本的数学运算\r\n关系运算符：进行比较操作\r\n逻辑运算符：执行布尔逻辑运算\r\n按位运算符：对数据的二进制位进行操作\r\n集合运算符：处理集合间的关系\r\n特殊运算符：包括索引、赋值等操作\r\n\r\n\r\n算术运算符\r\nMATLAB 提供了丰富的算术运算符，支持矩阵运算和元素级运算\r\nMATLAB 中的算术运算符分为两类：\r\n\r\n矩阵运算符：按照线性代数规则对矩阵进行运算。\r\n数组运算符：对数组的对应元素进行运算，要求参与运算的数组具有相同的尺寸。\r\n\r\n矩阵运算符 vs 数组运算符\r\n\r\n矩阵运算符遵循严格的线性代数规则：\r\n\r\n矩阵乘法要求第一个矩阵的列数等于第二个矩阵的行数\r\n矩阵除法涉及求逆矩阵或解线性方程组\r\n矩阵幂运算是数学意义上的矩阵幂\r\n\r\n数组运算符（带点号的运算符）对对应元素进行操作：\r\n\r\n要求参与运算的数组具有相同的维度（或其中一个是标量）\r\n运算是逐元素进行的\r\n更直观，类似于其他编程语言中的数组操作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n说明\r\n\r\n\r\n\r\n\r\n+\r\n加法或一元加号。A+B 将存储在变量 A 和 B 中的值相加。A 和 B\r\n必须具有相同的大小，除非其中一个是标量。标量可以添加到任何大小的矩阵中。\r\n\r\n\r\n-\r\n减法或一元减法。A - B 从 A 中减去 B 的值。A 和 B\r\n必须具有相同的大小，除非其中一个是标量。标量可以从任何大小的矩阵中减去。\r\n\r\n\r\n*\r\n矩阵乘法。C = A*B 是矩阵 A 和 B 的线性代数积。更准确地说，$C(i,j)=\\sum_{k =\r\n1}^{n}A(i,k)B(k,j)$。对于非标量 A 和 B，A 的列数必须等于 B\r\n的行数。标量可以与任意大小的矩阵相乘。\r\n\r\n\r\n.*\r\n数组乘法。A.*B 是数组 A 和 B 的逐元素乘积。A 和 B\r\n必须具有相同的大小，除非其中一个是标量。\r\n\r\n\r\n/\r\n斜杠或矩阵右除法。B/A 与 B*inv (A) 大致相同。更准确地说，B/A = (A’\r\n B’)’ 。\r\n\r\n\r\n./\r\n数组右除法。A./B 是元素 A (i,j)/B (i,j) 的矩阵。A 和 B\r\n必须具有相同的大小，除非其中一个是标量。\r\n\r\n\r\n\\\r\n反斜杠或矩阵左除法。如果 A 是方阵，则 A与 inv (A)*B\r\n大致相同，只是计算方式不同。如果 A 是一个 n 乘 n 的矩阵，而 B 是一个包含\r\nn 个分量的列向量，或者是一个包含多个这样的列的矩阵，那么 X = A是方程 AX\r\n= B 的解。如果 A 的比例严重或几乎是单数，则会显示一条警告消息。\r\n\r\n\r\n.\\\r\n数组左除法。A.是元素 B (i,j)/A (i,j) 的矩阵。A 和 B\r\n必须具有相同的大小，除非其中一个是标量。\r\n\r\n\r\n^\r\n矩阵幂。如果 p 是标量，那么 X^p 是 p 的幂。如果 p\r\n是整数，则通过重复平方计算幂。如果整数是负数，则 X 先倒数。对于 p\r\n的其他值，计算涉及特征值和特征向量，因此如果 [V, D] = eig (X)，那么 X^p\r\n= V*D.^p/V 。\r\n\r\n\r\n.^\r\n数组幂。A.^B 是元素 A (i,j) 为 B (i,j) 次方的矩阵。A 和 B\r\n必须具有相同的大小，除非其中一个是标量。\r\n\r\n\r\n’\r\n矩阵转置。A’ 是 A 的线性代数转置。对于复矩阵，这是复共轭转置。\r\n\r\n\r\n.’\r\n数组转置。a.’ 是 a 的数组转置。对于复杂的矩阵，这不涉及共轭。\r\n\r\n\r\n\r\n示例\r\n% 矩阵运算示例A = [1, 2; 3, 4];B = [5, 6; 7, 8];% 矩阵乘法C_matrix = A * B;        % 结果: [19, 22; 43, 50]% 数组乘法（逐元素）C_element = A .* B;      % 结果: [5, 12; 21, 32]% 矩阵幂A_squared = A^2;         % 矩阵A的平方A_element_squared = A.^2; % A中每个元素的平方% 复数转置示例complex_matrix = [1+2i, 3-i; 4+i, 5];conjugate_transpose = complex_matrix&#x27;;   % 复共轭转置simple_transpose = complex_matrix.&#x27;;     % 仅转置% 除法运算示例vector1 = [10, 20, 30];vector2 = [2, 4, 5];division_result = vector1 ./ vector2;    % [5, 5, 6]% 标量与矩阵运算scalar = 5;matrix = [1, 2, 3; 4, 5, 6];scaled_matrix = scalar * matrix;         % 标量乘法自动广播\r\n运算优先级\r\nMATLAB 中的算术运算符优先级与数学中的基本一致：\r\n\r\n括号 ()\r\n幂运算 ^ 和 .^\r\n乘法 、除法 / 和 、数组乘 .、数组除 ./ 和 .\r\n\r\n加法 + 和减法 -\r\n\r\n关系运算符\r\n关系运算符还可以处理标量和非标量数据。数组的关系运算符执行两个数组之间的逐元素比较，并返回相同大小的逻辑数组，其中元素设置为逻辑1(true)，关系为true，元素设置为逻辑0(false)。\r\n\r\n\r\n\r\n运算符\r\n说明\r\n\r\n\r\n\r\n\r\n&lt;\r\n小于\r\n\r\n\r\n&lt;=\r\n小于或等于\r\n\r\n\r\n&gt;\r\n大于\r\n\r\n\r\n&gt;=\r\n大于或等于\r\n\r\n\r\n==\r\n等于\r\n\r\n\r\n~=\r\n不等于\r\n\r\n\r\n\r\n% 标量比较a = 10;b = 5;result1 = a &gt; b;           % trueresult2 = a == b;          % falseresult3 = a ~= b;          % true% 数组比较array1 = [1, 5, 3, 8, 2];array2 = [2, 4, 3, 6, 7];% 逐元素比较comparison = array1 &gt; array2;   % [false, true, false, true, false]equal_elements = array1 == array2; % [false, false, true, false, false]% 与标量比较greater_than_3 = array1 &gt; 3;    % [false, true, false, true, false]% 在条件语句中使用if a &gt; b    fprintf(&#x27;a (%d) 大于 b (%d)\\n&#x27;, a, b);else    fprintf(&#x27;a (%d) 不大于 b (%d)\\n&#x27;, a, b);end% 复杂条件complex_condition = (a &gt; 5) &amp;&amp; (b &lt; 10);fprintf(&#x27;复杂条件结果: %d\\n&#x27;, complex_condition);\r\n特殊比较情况\r\n% NaN的比较nan_value = NaN;result_nan = nan_value == nan_value;  % false! NaN不等于任何值，包括自己result_isnan = isnan(nan_value);      % true，使用isnan函数检测% 浮点数比较的注意事项float1 = 0.1 + 0.2;float2 = 0.3;direct_compare = float1 == float2;    % 可能为false（浮点精度问题）safe_compare = abs(float1 - float2) &lt; eps; % 安全的浮点比较% 字符串比较str1 = &#x27;hello&#x27;;str2 = &#x27;world&#x27;;str_compare = str1 == str2;          % 逐字符比较，返回逻辑数组str_equal = strcmp(str1, str2);      % 整体字符串比较，返回标量\r\n逻辑运算符\r\n逻辑运算符用于组合或修改逻辑条件。MATLAB提供两种类型的逻辑运算符：元素级运算符和短路运算符。\r\n元素级逻辑运算符：\r\n这些运算符对逻辑数组的每个元素进行操作，适用于数组处理。\r\n\r\n\r\n\r\n运算符\r\n名称\r\n说明\r\n示例\r\n\r\n\r\n\r\n\r\n&amp;\r\n逻辑与（AND）\r\n两个操作数都为真时结果为真\r\nA &amp; B\r\n\r\n\r\n|\r\n逻辑或（OR）\r\n至少一个操作数为真时结果为真\r\nA | B\r\n\r\n\r\n~\r\n逻辑非（NOT）\r\n取反操作，真变假，假变真\r\n~A\r\n\r\n\r\n\r\n短路逻辑运算符\r\n这些运算符只对标量逻辑值进行操作，具有短路特性（提前终止评估）。\r\n\r\n\r\n\r\n运算符\r\n名称\r\n说明\r\n短路特性\r\n\r\n\r\n\r\n\r\n&amp;&amp;\r\n短路与\r\n标量逻辑与\r\n左操作数为假时，不评估右操作数\r\n\r\n\r\n||\r\n短路或\r\n标量逻辑或\r\n左操作数为真时，不评估右操作数\r\n\r\n\r\n\r\n逻辑运算符详细用法\r\n% 元素级逻辑运算logical_array1 = [true, false, true, false];logical_array2 = [true, true, false, false];% 逻辑与运算and_result = logical_array1 &amp; logical_array2;  % [true, false, false, false]% 逻辑或运算or_result = logical_array1 | logical_array2;   % [true, true, true, false]% 逻辑非运算not_result = ~logical_array1;                  % [false, true, false, true]% 短路逻辑运算（仅适用于标量）a = 5;b = 0;% 短路与if (b ~= 0) &amp;&amp; (a/b &gt; 2)  % b为0时，不会计算a/b，避免除零错误    disp(&#x27;条件成立&#x27;);else    disp(&#x27;条件不成立或发生短路&#x27;);end% 短路或if (a &gt; 0) || (b &gt; 0)     % a&gt;0为真，不再检查b&gt;0    disp(&#x27;至少一个数为正&#x27;);end\r\n逻辑运算的高级应用\r\n% 使用逻辑运算进行数组过滤data = [1, -2, 3, -4, 5, 6, -7, 8];% 找出正数positive_mask = data &gt; 0;positive_numbers = data(positive_mask);  % [1, 3, 5, 6, 8]% 复合条件：找出大于2且小于7的数compound_mask = (data &gt; 2) &amp; (data &lt; 7);filtered_data = data(compound_mask);     % [3, 5, 6]% 使用any和all函数has_negative = any(data &lt; 0);            % true，存在负数all_positive = all(data &gt; 0);            % false，不是所有数都为正% 逻辑索引的实际应用matrix = [1, 2, 3; 4, 5, 6; 7, 8, 9];% 将所有大于5的元素设为0matrix(matrix &gt; 5) = 0;\r\n按位运算\r\n按位运算符对整数的二进制表示进行位级操作。这些运算符主要用于底层编程、数据压缩、加密等应用。\r\n按位运算符对位进行运算并执行逐位运算。＆，|和^的真值表如下\r\n\r\n\r\n\r\np\r\nq\r\np＆q\r\np | q\r\np ^ Q\r\n\r\n\r\n\r\n\r\n0\r\n0\r\n0\r\n0\r\n0\r\n\r\n\r\n0\r\n1\r\n0\r\n1\r\n1\r\n\r\n\r\n1\r\n1\r\n1\r\n1\r\n0\r\n\r\n\r\n1\r\n0\r\n0\r\n1\r\n1\r\n\r\n\r\n\r\n完整按位运算符和函数列表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n函数名\r\n说明\r\n语法\r\n示例\r\n\r\n\r\n\r\n\r\nbitand\r\n按位与\r\nbitand(A, B)\r\nbitand(5, 3) → 1\r\n\r\n\r\nbitor\r\n按位或\r\nbitor(A, B)\r\nbitor(5, 3) → 7\r\n\r\n\r\nbitxor\r\n按位异或\r\nbitxor(A, B)\r\nbitxor(5, 3) → 6\r\n\r\n\r\nbitcmp\r\n按位补码\r\nbitcmp(A, n)\r\nbitcmp(5, 8) → 250\r\n\r\n\r\nbitshift\r\n位移\r\nbitshift(A, k)\r\nbitshift(5, 2) → 20\r\n\r\n\r\nbitget\r\n获取指定位\r\nbitget(A, bit)\r\nbitget(5, 1) → 1\r\n\r\n\r\nbitset\r\n设置指定位\r\nbitset(A, bit, val)\r\nbitset(5, 2, 0) → 1\r\n\r\n\r\n\r\n按位运算详细用法\r\n% 按位运算基础示例a = uint8(5);    % 二进制: 00000101b = uint8(3);    % 二进制: 00000011% 按位与运算and_result = bitand(a, b);    % 结果: 1 (00000001)% 按位或运算or_result = bitor(a, b);      % 结果: 7 (00000111)% 按位异或运算xor_result = bitxor(a, b);    % 结果: 6 (00000110)% 按位补码（取反）complement = bitcmp(a, 8);    % 8位补码，结果: 250 (11111010)% 位移操作left_shift = bitshift(a, 2);  % 左移2位，结果: 20 (00010100)right_shift = bitshift(a, -2); % 右移2位，结果: 1 (00000001)% 单个位操作bit_value = bitget(a, 3);     % 获取第3位，结果: 1new_value = bitset(a, 2, 0);  % 将第2位设为0，结果: 1\r\n按位运算符对整数的二进制表示进行位级操作。这些运算符主要用于底层编程、数据压缩、加密等应用。\r\n按位运算符列表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n函数名\r\n说明\r\n语法\r\n示例\r\n\r\n\r\n\r\n\r\nbitand\r\n按位与\r\nbitand(A, B)\r\nbitand(5, 3) → 1\r\n\r\n\r\nbitor\r\n按位或\r\nbitor(A, B)\r\nbitor(5, 3) → 7\r\n\r\n\r\nbitxor\r\n按位异或\r\nbitxor(A, B)\r\nbitxor(5, 3) → 6\r\n\r\n\r\nbitcmp\r\n按位补码\r\nbitcmp(A, n)\r\nbitcmp(5, 8) → 250\r\n\r\n\r\nbitshift\r\n位移\r\nbitshift(A, k)\r\nbitshift(5, 2) → 20\r\n\r\n\r\nbitget\r\n获取指定位\r\nbitget(A, bit)\r\nbitget(5, 1) → 1\r\n\r\n\r\nbitset\r\n设置指定位\r\nbitset(A, bit, val)\r\nbitset(5, 2, 0) → 1\r\n\r\n\r\n\r\n按位运算详细用法\r\n% 按位运算基础示例a = uint8(5);    % 二进制: 00000101b = uint8(3);    % 二进制: 00000011% 按位与运算and_result = bitand(a, b);    % 结果: 1 (00000001)% 按位或运算or_result = bitor(a, b);      % 结果: 7 (00000111)% 按位异或运算xor_result = bitxor(a, b);    % 结果: 6 (00000110)% 按位补码（取反）complement = bitcmp(a, 8);    % 8位补码，结果: 250 (11111010)% 位移操作left_shift = bitshift(a, 2);  % 左移2位，结果: 20 (00010100)right_shift = bitshift(a, -2); % 右移2位，结果: 1 (00000001)% 单个位操作bit_value = bitget(a, 3);     % 获取第3位，结果: 1new_value = bitset(a, 2, 0);  % 将第2位设为0，结果: 1\r\n按位运算的实际应用\r\n% 权限系统示例（使用位标志）READ_PERMISSION = uint8(1);      % 00000001WRITE_PERMISSION = uint8(2);     % 00000010EXECUTE_PERMISSION = uint8(4);   % 00000100% 设置多个权限user_permissions = bitor(READ_PERMISSION, bitor(WRITE_PERMISSION, EXECUTE_PERMISSION));% 检查是否有读权限has_read = bitand(user_permissions, READ_PERMISSION) ~= 0;% 移除写权限user_permissions = bitand(user_permissions, bitcmp(WRITE_PERMISSION, 8));% 数据压缩示例：将两个4位数合并为一个8位数high_nibble = uint8(12);  % 高4位low_nibble = uint8(5);    % 低4位combined = bitor(bitshift(high_nibble, 4), low_nibble);  % 197% 解压缩extracted_high = bitshift(combined, -4);extracted_low = bitand(combined, 15);  % 15 = 00001111\r\n集合运算符\r\n集合运算符用于处理集合间的关系，如并集、交集、差集等。这些操作在数据分析和处理中非常有用。\r\n集合运算函数列表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n函数名\r\n说明\r\n语法\r\n示例\r\n\r\n\r\n\r\n\r\nunion\r\n并集\r\nunion(A, B)\r\n返回A和B的并集\r\n\r\n\r\nintersect\r\n交集\r\nintersect(A, B)\r\n返回A和B的交集\r\n\r\n\r\nsetdiff\r\n差集\r\nsetdiff(A, B)\r\n返回在A中但不在B中的元素\r\n\r\n\r\nsetxor\r\n对称差集\r\nsetxor(A, B)\r\n返回在A或B中但不在两者交集中的元素\r\n\r\n\r\nismember\r\n成员检查\r\nismember(A, B)\r\n检查A的元素是否在B中\r\n\r\n\r\nunique\r\n唯一元素\r\nunique(A)\r\n返回A中的唯一元素\r\n\r\n\r\nissorted\r\n排序检查\r\nissorted(A)\r\n检查A是否已排序\r\n\r\n\r\n\r\n集合运算详细用法\r\n% 定义两个集合set_A = [1, 2, 3, 4, 5];set_B = [3, 4, 5, 6, 7];% 并集运算union_result = union(set_A, set_B);        % [1, 2, 3, 4, 5, 6, 7]% 交集运算intersect_result = intersect(set_A, set_B); % [3, 4, 5]% 差集运算diff_A_B = setdiff(set_A, set_B);          % [1, 2]diff_B_A = setdiff(set_B, set_A);          % [6, 7]% 对称差集symmetric_diff = setxor(set_A, set_B);     % [1, 2, 6, 7]% 成员检查membership = ismember(set_A, set_B);       % [0, 0, 1, 1, 1]is_member = ismember(3, set_A);            % 1 (true)% 唯一元素提取duplicate_array = [1, 2, 2, 3, 3, 3, 4];unique_elements = unique(duplicate_array); % [1, 2, 3, 4]\r\n集合运算的高级应用\r\n% 处理字符串集合names_group1 = &#123;&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;&#125;;names_group2 = &#123;&#x27;Bob&#x27;, &#x27;David&#x27;, &#x27;Eve&#x27;&#125;;common_names = intersect(names_group1, names_group2);  % &#123;&#x27;Bob&#x27;&#125;all_names = union(names_group1, names_group2);unique_to_group1 = setdiff(names_group1, names_group2); % &#123;&#x27;Alice&#x27;, &#x27;Charlie&#x27;&#125;% 数据清洗应用survey_data = [1, 2, 2, 3, 1, 4, 3, 2, 5, 1];[unique_responses, ~, idx] = unique(survey_data);response_counts = accumarray(idx, 1);fprintf(&#x27;调查结果统计:\\n&#x27;);for i = 1:length(unique_responses)    fprintf(&#x27;选项 %d: %d 次\\n&#x27;, unique_responses(i), response_counts(i));end% 多集合操作setA = [1, 2, 3];setB = [2, 3, 4];setC = [3, 4, 5];% 三个集合的交集triple_intersect = intersect(intersect(setA, setB), setC);% 至少在两个集合中出现的元素temp1 = intersect(setA, setB);temp2 = intersect(setA, setC);temp3 = intersect(setB, setC);at_least_two = union(union(temp1, temp2), temp3);\r\n特殊运算符详解\r\n除了基本的算术、关系、逻辑运算符外，MATLAB还提供了一些特殊的运算符。\r\n索引和赋值运算符\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n运算符\r\n名称\r\n说明\r\n示例\r\n\r\n\r\n\r\n\r\n()\r\n普通索引\r\n访问数组元素或调用函数\r\nA(1,2), func(x)\r\n\r\n\r\n{}\r\n单元数组索引\r\n访问单元数组内容\r\nC&#123;1,2&#125;\r\n\r\n\r\n.\r\n结构体字段访问\r\n访问结构体字段\r\nstudent.name\r\n\r\n\r\n=\r\n赋值\r\n将值赋给变量\r\nx = 5\r\n\r\n\r\n:\r\n冒号运算符\r\n创建向量或全选索引\r\n1:10, A(:,2)\r\n\r\n\r\n\r\n特殊运算符用法示例\r\n% 冒号运算符的多种用法vector1 = 1:10;              % [1, 2, 3, ..., 10]vector2 = 1:2:10;            % [1, 3, 5, 7, 9]vector3 = 10:-1:1;           % [10, 9, 8, ..., 1]% 在矩阵索引中使用冒号matrix = magic(4);row_2 = matrix(2, :);        % 第2行的所有元素col_3 = matrix(:, 3);        % 第3列的所有元素submatrix = matrix(1:2, 2:3); % 子矩阵% 单元数组操作cell_array = &#123;[1,2,3], &#x27;hello&#x27;, true, magic(2)&#125;;first_content = cell_array&#123;1&#125;;     % 获取第一个单元的内容cell_array&#123;2&#125; = &#x27;world&#x27;;           % 修改第二个单元的内容% 结构体操作person.name = &#x27;Alice&#x27;;person.age = 25;person.scores = [85, 90, 88];name = person.name;                % 访问字段person.city = &#x27;Beijing&#x27;;           % 添加新字段\r\n运算符综合应用示例\r\n示例1：数据分析与处理\r\nfunction analyze_student_data()    % 模拟学生成绩数据    students = struct(&#x27;name&#x27;, &#123;&#125;, &#x27;math&#x27;, &#123;&#125;, &#x27;english&#x27;, &#123;&#125;, &#x27;science&#x27;, &#123;&#125;);        % 添加学生数据    students(1) = struct(&#x27;name&#x27;, &#x27;Alice&#x27;, &#x27;math&#x27;, 85, &#x27;english&#x27;, 78, &#x27;science&#x27;, 92);    students(2) = struct(&#x27;name&#x27;, &#x27;Bob&#x27;, &#x27;math&#x27;, 76, &#x27;english&#x27;, 89, &#x27;science&#x27;, 84);    students(3) = struct(&#x27;name&#x27;, &#x27;Charlie&#x27;, &#x27;math&#x27;, 92, &#x27;english&#x27;, 85, &#x27;science&#x27;, 88);    students(4) = struct(&#x27;name&#x27;, &#x27;Diana&#x27;, &#x27;math&#x27;, 88, &#x27;english&#x27;, 92, &#x27;science&#x27;, 90);        % 提取所有成绩    math_scores = [students.math];    english_scores = [students.english];    science_scores = [students.science];        % 计算总分和平均分    total_scores = math_scores + english_scores + science_scores;    average_scores = total_scores / 3;        % 使用逻辑运算符找出优秀学生（平均分&gt;85）    excellent_mask = average_scores &gt; 85;    excellent_students = &#123;students(excellent_mask).name&#125;;        % 使用关系运算符进行排名    [sorted_scores, sort_indices] = sort(total_scores, &#x27;descend&#x27;);        fprintf(&#x27;学生成绩分析报告:\\n&#x27;);    fprintf(&#x27;==================\\n&#x27;);    for i = 1:length(students)        idx = sort_indices(i);        fprintf(&#x27;排名 %d: %s - 总分: %d, 平均分: %.1f\\n&#x27;, ...                i, students(idx).name, sorted_scores(i), average_scores(idx));    end        fprintf(&#x27;\\n优秀学生 (平均分&gt;85): &#x27;);    fprintf(&#x27;%s &#x27;, excellent_students&#123;:&#125;);    fprintf(&#x27;\\n&#x27;);end\r\n示例2：图像处理应用\r\nfunction process_image_data()    % 创建模拟图像数据（8位灰度图像）    image_data = uint8(randi([0, 255], 100, 100));        % 使用按位运算进行图像处理    % 提取高4位（粗量化）    high_bits = bitshift(image_data, -4);    coarse_image = bitshift(high_bits, 4);        % 使用逻辑运算创建掩码    bright_mask = image_data &gt; 128;        % 亮像素掩码    dark_mask = ~bright_mask;              % 暗像素掩码        % 使用算术运算符进行图像增强    enhanced_image = image_data;    enhanced_image(bright_mask) = enhanced_image(bright_mask) * 0.8;  % 降低亮部    enhanced_image(dark_mask) = enhanced_image(dark_mask) * 1.2;      % 增强暗部        % 边界检查，避免溢出    enhanced_image = min(enhanced_image, 255);    enhanced_image = max(enhanced_image, 0);        fprintf(&#x27;图像处理完成:\\n&#x27;);    fprintf(&#x27;原图像素值范围: %d - %d\\n&#x27;, min(image_data(:)), max(image_data(:)));    fprintf(&#x27;增强后像素值范围: %d - %d\\n&#x27;, min(enhanced_image(:)), max(enhanced_image(:)));    fprintf(&#x27;亮像素数量: %d\\n&#x27;, sum(bright_mask(:)));    fprintf(&#x27;暗像素数量: %d\\n&#x27;, sum(dark_mask(:)));end\r\n示例3：科学计算应用\r\nfunction scientific_computation_demo()    % 使用复数运算符处理信号    t = 0:0.01:2*pi;    signal1 = cos(2*pi*t) + 1i*sin(2*pi*t);  % 复指数信号    signal2 = exp(1i*2*pi*t);                % 等价表示        % 验证欧拉公式    euler_verification = abs(signal1 - signal2) &lt; eps;    all_equal = all(euler_verification);        % 矩阵运算在线性代数中的应用    A = [2, 1; 1, 3];    b = [5; 7];        % 解线性方程组 Ax = b    x_solution = A \\ b;              % 使用矩阵\r\n","categories":["数学类","MATLAB"],"tags":["语法知识","学习","语言方面","数学","物理","数学建模"]},{"title":"MATLAB part4-条件语句和循环语句","url":"/posts/41860.html","content":"MATLAB 条件语句\r\n决策结构要求程序员应指定一个或多个要由程序评估或测试的条件，如果确定条件为真，则应指定要执行的一个或多个语句，如果条件为真，则可以选择要执行的其他语句。条件确定为假。\r\n以下是大多数编程语言中常见的典型决策结构的一般形式：\r\nflowchart TD\n    start[Start] --&gt; condition&#123;condition&#125;\n    condition --&gt;|condition is true| conditional_code[conditional code]\n    conditional_code --&gt; end[End]\n    condition --&gt;|condition is false| end\r\n1. if 语句\r\nif\r\n语句是最基本的条件语句，用于在条件为真时执行特定的代码块。\r\n基本语法\r\nif condition    % 当条件为真时执行的代码    statementsend\r\n代码示例\r\n% 示例1：简单的数值比较x = 10;if x &gt; 5    disp(&#x27;x 大于 5&#x27;);end% 示例2：判断数字的正负性number = -3.5;if number &gt; 0    disp(&#x27;这是一个正数&#x27;);endif number &lt; 0    disp(&#x27;这是一个负数&#x27;);endif number == 0    disp(&#x27;这是零&#x27;);end% 示例3：字符串比较name = &#x27;MATLAB&#x27;;if strcmp(name, &#x27;MATLAB&#x27;)    disp(&#x27;欢迎使用 MATLAB!&#x27;);end\r\n2. if-else 语句\r\nif-else\r\n语句提供了两个执行路径：当条件为真时执行一个代码块，当条件为假时执行另一个代码块。\r\n基本语法\r\nif condition    % 条件为真时执行    statements1else    % 条件为假时执行    statements2end\r\n代码示例\r\n% 示例1：判断奇偶数num = 15;if mod(num, 2) == 0    fprintf(&#x27;%d 是偶数\\n&#x27;, num);else    fprintf(&#x27;%d 是奇数\\n&#x27;, num);end% 示例2：成绩等级判定score = 85;if score &gt;= 60    disp(&#x27;及格&#x27;);else    disp(&#x27;不及格&#x27;);end% 示例3：温度判断temperature = 25;if temperature &gt; 30    disp(&#x27;天气很热&#x27;);else    disp(&#x27;天气还好&#x27;);end\r\n3. if-elseif-else 语句\r\n当需要测试多个条件时，可以使用 elseif\r\n来创建多分支结构。\r\n基本语法\r\nif condition1    % 条件1为真时执行    statements1elseif condition2    % 条件2为真时执行    statements2elseif condition3    % 条件3为真时执行    statements3else    % 所有条件都为假时执行    statements4end\r\n代码示例\r\n% 示例1：详细的成绩等级判定score = 88;if score &gt;= 90    grade = &#x27;A&#x27;;elseif score &gt;= 80    grade = &#x27;B&#x27;;elseif score &gt;= 70    grade = &#x27;C&#x27;;elseif score &gt;= 60    grade = &#x27;D&#x27;;else    grade = &#x27;F&#x27;;endfprintf(&#x27;分数: %d, 等级: %s\\n&#x27;, score, grade);% 示例2：季节判断month = 7;if month &gt;= 3 &amp;&amp; month &lt;= 5    season = &#x27;春季&#x27;;elseif month &gt;= 6 &amp;&amp; month &lt;= 8    season = &#x27;夏季&#x27;;elseif month &gt;= 9 &amp;&amp; month &lt;= 11    season = &#x27;秋季&#x27;;else    season = &#x27;冬季&#x27;;endfprintf(&#x27;第%d月是%s\\n&#x27;, month, season);% 示例3：BMI指数判断weight = 70; % kgheight = 1.75; % mbmi = weight / (height^2);if bmi &lt; 18.5    category = &#x27;体重过轻&#x27;;elseif bmi &lt; 25    category = &#x27;正常体重&#x27;;elseif bmi &lt; 30    category = &#x27;超重&#x27;;else    category = &#x27;肥胖&#x27;;endfprintf(&#x27;BMI: %.2f, 分类: %s\\n&#x27;, bmi, category);\r\n4. switch 语句\r\nswitch\r\n语句用于基于变量的值执行不同的代码块，特别适合处理多个离散值的情况。\r\n基本语法\r\nswitch expression    case value1        statements1    case value2        statements2    case &#123;value3, value4, value5&#125;        statements3    otherwise        statements4end\r\n代码示例\r\n% 示例1：星期几的判断day = 3;switch day    case 1        dayName = &#x27;星期一&#x27;;    case 2        dayName = &#x27;星期二&#x27;;    case 3        dayName = &#x27;星期三&#x27;;    case 4        dayName = &#x27;星期四&#x27;;    case 5        dayName = &#x27;星期五&#x27;;    case &#123;6, 7&#125;        dayName = &#x27;周末&#x27;;    otherwise        dayName = &#x27;无效的日期&#x27;;endfprintf(&#x27;第%d天是%s\\n&#x27;, day, dayName);% 示例2：计算器功能a = 10;b = 5;operation = &#x27;+&#x27;;switch operation    case &#x27;+&#x27;        result = a + b;        fprintf(&#x27;%.2f + %.2f = %.2f\\n&#x27;, a, b, result);    case &#x27;-&#x27;        result = a - b;        fprintf(&#x27;%.2f - %.2f = %.2f\\n&#x27;, a, b, result);    case &#x27;*&#x27;        result = a * b;        fprintf(&#x27;%.2f * %.2f = %.2f\\n&#x27;, a, b, result);    case &#x27;/&#x27;        if b ~= 0            result = a / b;            fprintf(&#x27;%.2f / %.2f = %.2f\\n&#x27;, a, b, result);        else            disp(&#x27;除数不能为零&#x27;);        end    otherwise        disp(&#x27;不支持的运算符&#x27;);end% 示例3：字符串匹配color = &#x27;red&#x27;;switch lower(color)    case &#123;&#x27;red&#x27;, &#x27;crimson&#x27;, &#x27;scarlet&#x27;&#125;        disp(&#x27;这是红色系&#x27;);    case &#123;&#x27;blue&#x27;, &#x27;navy&#x27;, &#x27;azure&#x27;&#125;        disp(&#x27;这是蓝色系&#x27;);    case &#123;&#x27;green&#x27;, &#x27;lime&#x27;, &#x27;forest&#x27;&#125;        disp(&#x27;这是绿色系&#x27;);    otherwise        disp(&#x27;未知颜色&#x27;);end\r\nMATLAB 循环语句\r\n循环语句允许我们重复执行一段代码，直到满足某个条件为止。MATLAB提供了几种不同类型的循环结构来满足不同的编程需求。\r\n1. for 循环\r\nfor\r\n循环用于已知循环次数的情况，是最常用的循环结构之一。\r\n基本语法\r\nfor variable = start:step:end    % 循环体    statementsend% 或者遍历数组/向量for variable = array    % 循环体    statementsend\r\n代码示例\r\n% 示例1：基本的数值循环disp(&#x27;1到10的数字:&#x27;);for i = 1:10    fprintf(&#x27;%d &#x27;, i);endfprintf(&#x27;\\n&#x27;);% 示例2：指定步长的循环disp(&#x27;0到20的偶数:&#x27;);for i = 0:2:20    fprintf(&#x27;%d &#x27;, i);endfprintf(&#x27;\\n&#x27;);% 示例3：递减循环disp(&#x27;倒计时:&#x27;);for i = 10:-1:1    fprintf(&#x27;%d &#x27;, i);enddisp(&#x27;发射!&#x27;);% 示例4：遍历数组numbers = [2, 4, 6, 8, 10];sum_total = 0;for num = numbers    sum_total = sum_total + num;endfprintf(&#x27;数组元素的和: %d\\n&#x27;, sum_total);% 示例5：嵌套循环 - 打印乘法表disp(&#x27;九九乘法表:&#x27;);for i = 1:9    for j = 1:i        fprintf(&#x27;%d×%d=%d\\t&#x27;, j, i, i*j);    end    fprintf(&#x27;\\n&#x27;);end% 示例6：处理矩阵matrix = [1, 2, 3; 4, 5, 6; 7, 8, 9];disp(&#x27;原矩阵:&#x27;);disp(matrix);% 将所有元素乘以2for i = 1:size(matrix, 1)    for j = 1:size(matrix, 2)        matrix(i, j) = matrix(i, j) * 2;    endenddisp(&#x27;乘以2后的矩阵:&#x27;);disp(matrix);\r\n2. while 循环\r\nwhile\r\n循环在条件为真时重复执行代码块，适用于不确定循环次数的情况。\r\n基本语法\r\nwhile condition    % 循环体    statements    % 通常需要修改条件中的变量end\r\n代码示例\r\n% 示例1：基本的while循环count = 1;while count &lt;= 5    fprintf(&#x27;第%d次循环\\n&#x27;, count);    count = count + 1;end% 示例2：求数字的阶乘n = 5;factorial = 1;i = 1;while i &lt;= n    factorial = factorial * i;    i = i + 1;endfprintf(&#x27;%d的阶乘是: %d\\n&#x27;, n, factorial);% 示例3：猜数字游戏（模拟版）target = 42;guess = 0;attempts = 0;guesses = [25, 50, 40, 42]; % 模拟用户猜测guess_index = 1;while guess ~= target &amp;&amp; guess_index &lt;= length(guesses)    guess = guesses(guess_index);    attempts = attempts + 1;        if guess &lt; target        fprintf(&#x27;猜测 %d: 太小了!\\n&#x27;, guess);    elseif guess &gt; target        fprintf(&#x27;猜测 %d: 太大了!\\n&#x27;, guess);    else        fprintf(&#x27;猜测 %d: 恭喜你猜对了!\\n&#x27;, guess);    end        guess_index = guess_index + 1;endfprintf(&#x27;总共用了 %d 次猜测\\n&#x27;, attempts);% 示例4：斐波那契数列n = 10;a = 0;b = 1;count = 1;fprintf(&#x27;斐波那契数列的前%d项:\\n&#x27;, n);fprintf(&#x27;%d &#x27;, a);while count &lt; n    fprintf(&#x27;%d &#x27;, b);    temp = a + b;    a = b;    b = temp;    count = count + 1;endfprintf(&#x27;\\n&#x27;);% 示例5：数值收敛判断x = 2;tolerance = 1e-6;max_iterations = 100;iteration = 0;fprintf(&#x27;使用牛顿法求sqrt(2):\\n&#x27;);while iteration &lt; max_iterations    x_new = 0.5 * (x + 2/x);    error = abs(x_new - x);        fprintf(&#x27;迭代 %d: x = %.8f, 误差 = %.2e\\n&#x27;, iteration+1, x_new, error);        if error &lt; tolerance        fprintf(&#x27;收敛成功!\\n&#x27;);        break;    end        x = x_new;    iteration = iteration + 1;end\r\n3. 循环控制语句\r\n3.1 break 语句\r\nbreak 语句用于立即退出循环。\r\n% 示例1：寻找第一个大于50的平方数for i = 1:20    square = i^2;    if square &gt; 50        fprintf(&#x27;第一个大于50的平方数是 %d^2 = %d\\n&#x27;, i, square);        break;    endend% 示例2：在while循环中使用breaksum_val = 0;i = 1;while true  % 无限循环    sum_val = sum_val + i;    if sum_val &gt; 100        fprintf(&#x27;当i=%d时，累加和首次超过100，和为%d\\n&#x27;, i, sum_val);        break;    end    i = i + 1;end\r\n3.2 continue 语句\r\ncontinue\r\n语句用于跳过当前迭代的剩余部分，直接进入下一次循环。\r\n% 示例1：打印1到10中的奇数disp(&#x27;1到10中的奇数:&#x27;);for i = 1:10    if mod(i, 2) == 0        continue;  % 跳过偶数    end    fprintf(&#x27;%d &#x27;, i);endfprintf(&#x27;\\n&#x27;);% 示例2：计算正数的平均值numbers = [5, -2, 8, -1, 3, 0, 7, -4];positive_sum = 0;positive_count = 0;for num = numbers    if num &lt;= 0        continue;  % 跳过非正数    end    positive_sum = positive_sum + num;    positive_count = positive_count + 1;endif positive_count &gt; 0    average = positive_sum / positive_count;    fprintf(&#x27;正数的平均值: %.2f\\n&#x27;, average);else    disp(&#x27;没有正数&#x27;);end\r\n4. 复杂循环应用示例\r\n4.1 质数判断和生成\r\n% 生成1到100之间的所有质数disp(&#x27;1到100之间的质数:&#x27;);primes = [];for num = 2:100    is_prime = true;        % 检查是否为质数    for i = 2:sqrt(num)        if mod(num, i) == 0            is_prime = false;            break;        end    end        if is_prime        primes = [primes, num];    endendfprintf(&#x27;找到 %d 个质数:\\n&#x27;, length(primes));for i = 1:length(primes)    fprintf(&#x27;%d &#x27;, primes(i));    if mod(i, 10) == 0  % 每10个数换行        fprintf(&#x27;\\n&#x27;);    endendfprintf(&#x27;\\n&#x27;);\r\n4.2 矩阵操作\r\n% 创建一个随机矩阵并找出最大值的位置matrix = rand(5, 5) * 100;matrix = round(matrix);disp(&#x27;随机矩阵:&#x27;);disp(matrix);max_val = -inf;max_row = 0;max_col = 0;% 遍历矩阵找最大值for i = 1:size(matrix, 1)    for j = 1:size(matrix, 2)        if matrix(i, j) &gt; max_val            max_val = matrix(i, j);            max_row = i;            max_col = j;        end    endendfprintf(&#x27;最大值 %d 位于第 %d 行第 %d 列\\n&#x27;, max_val, max_row, max_col);\r\n4.3 数值分析应用\r\n% 使用梯形法则计算定积分% 计算 f(x) = x^2 在 [0, 1] 上的积分a = 0;  % 下限b = 1;  % 上限n = 1000;  % 分割数h = (b - a) / n;% 函数定义f = @(x) x.^2;% 梯形法则integral_approx = (f(a) + f(b)) / 2;for i = 1:n-1    x = a + i * h;    integral_approx = integral_approx + f(x);endintegral_approx = integral_approx * h;% 理论值integral_exact = 1/3;fprintf(&#x27;数值积分结果: %.6f\\n&#x27;, integral_approx);fprintf(&#x27;理论值: %.6f\\n&#x27;, integral_exact);fprintf(&#x27;误差: %.6f\\n&#x27;, abs(integral_approx - integral_exact));\r\n总结\r\nMATLAB的条件语句和循环语句为程序提供了强大的控制流功能：\r\n条件语句：\r\n\r\nif 语句：处理简单条件判断\r\nif-else 语句：提供二选一的执行路径\r\nif-elseif-else 语句：处理多条件分支\r\nswitch 语句：适合处理离散值的多分支选择\r\n这些条件语句之间可以互相嵌套，包括与下面的循环语句\r\n\r\n循环语句：\r\n\r\nfor 循环：适用于已知循环次数的情况\r\nwhile 循环：适用于条件驱动的循环\r\nbreak 和\r\ncontinue：提供循环控制的灵活性\r\n\r\n","categories":["数学类","MATLAB"],"tags":["语法知识","学习","语言方面","数学","物理","数学建模"]},{"title":"MATLAB part2-变量和命令.md","url":"/posts/13781.html","content":"MATLAB 变量\r\n变量命名\r\n在 MATLAB 环境中，每个变量都是一个数组或矩阵。MATLAB\r\n变量命名规则：\r\n\r\n必须以字母开头\r\n可以包含字母、数字和下划线\r\n区分大小写\r\n长度不超过 63 个字符\r\n\r\n可以通过简单的方式分配变量。\r\nx2 = 3;   thirus_normary = 19;\r\n变量基础\r\n在MATLAB环境中，每个变量都是一个数组或矩阵。\r\n可以通过简单的方式分配变量。例如，\r\nx2 = 3;\t       %定义x2并用值初始化它\r\nMATLAB将执行上述语句并返回结果 x2 = 3\r\n这个变量的含义是它创建一个名为x2的1乘1矩阵，并将值 3\r\n存储在其元素中。\r\n注意\r\n\r\n将变量输入系统后，您以后可以参考它。\r\n变量在使用前必须具有值。\r\n当表达式返回未分配给任何变量的结果时，系统会将其分配给名为ans的变量，该变量可在以后使用。\r\n\r\nsqrt(78)\r\nMATLAB将执行上述语句并返回以下结果\r\nans =  8.8318\r\n多项分配\r\n可以在同一行上进行多个分配（使用逗号分隔）：\r\na = 12; b = 7; c = a * b  % 最后一个表达式结果会显示\r\n或者使用括号分组\r\n[a, b, c] = deal(12, 7, a*b); % 使用deal函数批量赋值\r\nwho 和 whos 命令\r\nwho命令显示您已使用的所有变量名。\r\nwho\r\nMATLAB将执行上述语句并返回以下结果\r\n您的变量为:ans  th   x    x2   y   \r\nwhos命令显示了有关变量的更多信息\r\n\r\n当前内存中的变量\r\n每个变量的类型\r\n分配给每个变量的内存\r\n它们是否为复杂变量\r\n\r\nName      Size            Bytes  Class     Attributesans       1x1                 8  double              th        1x1                 8  double              x         1x1                 8  double              x2        1x1                 8  double              y         1x1                 8  double   \r\nclear 命令\r\nclear命令用于从内存中删除变量：\r\nclear x2;     % 删除指定变量clear a b c;  % 删除多个变量clear;        % 清除所有变量clear all;    % 清除所有变量，包括全局变量\r\n变量持久化\r\n使用save和load命令实现变量的磁盘存储与恢复：\r\nsave(&#x27;mydata.mat&#x27;);      % 保存所有变量到文件save(&#x27;mydata.mat&#x27;, &#x27;a&#x27;, &#x27;b&#x27;); % 只保存指定变量clear;                   % 清除内存变量load(&#x27;mydata.mat&#x27;);      % 从文件恢复变量\r\n内存管理技巧\r\n\r\n使用whos监控内存使用\r\n大矩阵运算后使用clear释放内存\r\n使用save将暂时不用的变量存入文件\r\n避免创建不必要的大型中间变量\r\n\r\n% 高效计算示例result = zeros(1000, 1000);for i = 1:1000    % 直接计算到结果矩阵，避免中间变量    result(i, :) = sin((1:1000) * i / 1000);end\r\n长作业与续行符\r\n可以使用省略号 (…) 将长语句扩展到多行：\r\n% 物理公式示例initial_velocity = 0;acceleration = 9.8;time = 20;final_velocity = initial_velocity + acceleration * time ...    + 0.5 * acceleration * time^2; % 续行符前可以有运算符\r\n格式控制命令\r\nMATLAB 提供多种输出格式控制：\r\n\r\n\r\n\r\n命令\r\n描述\r\n示例输出 (π)\r\n\r\n\r\n\r\n\r\nformat short\r\n短格式（默认，4 位小数）\r\n3.1416\r\n\r\n\r\nformat long\r\n长格式（16 位小数）\r\n3.141592653589793\r\n\r\n\r\nformat bank\r\n银行格式（2 位小数）\r\n3.14\r\n\r\n\r\nformat shortE\r\n短格式科学计数法\r\n3.1416e+00\r\n\r\n\r\nformat longE\r\n长格式科学计数法\r\n3.141592653589793e+00\r\n\r\n\r\nformat rat\r\n有理格式（分数表示）\r\n355/113\r\n\r\n\r\nformat hex\r\n十六进制格式\r\n400921fb54442d18\r\n\r\n\r\n\r\n默认情况下，MATLAB显示带有四个小数位值的数字。这就是所谓的short\r\nformat。\r\n但是，如果要提高精度，则需要使用format命令。\r\n例如\r\nformat long命令在小数点后显示16位数字。\r\nformat short命令是默认格式，默认，4 位小数\r\nformat longx = 7 + 10/3 + 5 ^ 1.2format shortx  % 切换回短格式显示\r\nMATLAB将执行上述语句并返回以下结果\r\n17.231981640639408\r\n变量类型与赋值特性\r\nMATLAB 是动态类型语言，变量类型由赋值自动确定：\r\na = 42;          % 双精度数值b = &#x27;hello&#x27;;     % 字符数组（字符串）c = [1 2 3; 4 5 6]; % 2×3矩阵d = true;        % 逻辑值e = &#123;1, &#x27;text&#x27;, [1+2i]&#125;; % 元胞数组f = struct(&#x27;name&#x27;, &#x27;MATLAB&#x27;, &#x27;version&#x27;, 2025); % 结构体\r\n注意：\r\n\r\n变量在使用前必须赋值\r\n变量名不能与 MATLAB 内置函数名冲突（如sin,\r\npi等）\r\n赋值语句不需要分号结尾，但分号可抑制输出\r\n\r\n特殊变量\r\nMATLAB 保留了一些特殊变量：\r\n\r\n\r\n\r\n变量名\r\n描述\r\n\r\n\r\n\r\n\r\nans\r\n最近未赋值的计算结果\r\n\r\n\r\npi\r\n圆周率 π\r\n\r\n\r\ni, j\r\n虚数单位 √(-1)\r\n\r\n\r\nInf\r\n无穷大\r\n\r\n\r\nNaN\r\n非数字（Not a Number）\r\n\r\n\r\neps\r\n浮点数精度\r\n\r\n\r\nrealmax\r\n最大正浮点数\r\n\r\n\r\nrealmin\r\n最小正浮点数\r\n\r\n\r\n\r\nMATLAB 命令\r\nMATLAB是一个用于数值计算和数据可视化的交互式程序。您可以通过在命令窗口的MATLAB提示符\r\n‘&gt;&gt;’ 处键入命令来输入命令。\r\n在本节中，我们将提供常用的通用MATLAB命令列表。\r\n用于管理会话的命令\r\nMATLAB提供了用于管理会话的各种命令。下表提供了所有此类命令\r\n\r\n\r\n\r\n命令\r\n目的\r\n\r\n\r\n\r\n\r\nclc\r\n清除命令窗口。\r\n\r\n\r\nclear\r\n从内存中删除变量。\r\n\r\n\r\nexist\r\n检查文件或变量的存在。\r\n\r\n\r\nglobal\r\n声明变量为全局变量。\r\n\r\n\r\nhelp\r\n搜索帮助主题。\r\n\r\n\r\nlookfor\r\n在帮助条目中搜索关键字。\r\n\r\n\r\nquit\r\n停止MATLAB。\r\n\r\n\r\nwho\r\n列出当前变量。\r\n\r\n\r\nwhos\r\n列出当前变量（长显示）。\r\n\r\n\r\n\r\n用于系统的命令\r\nMATLAB提供了各种有用的命令来处理系统，例如将当前工作作为文件保存在工作区中，并在以后加载文件。\r\n它还为其他与系统相关的活动提供各种命令，例如显示日期，在目录中列出文件，显示当前目录等。\r\n下表显示了一些常用的与系统相关的命令\r\n\r\n\r\n\r\n命令\r\n目的\r\n\r\n\r\n\r\n\r\ncd\r\n更改当前目录。\r\n\r\n\r\ndate\r\n显示当前日期。\r\n\r\n\r\ndelete\r\n删除文件。\r\n\r\n\r\ndiary\r\n开启/关闭日记文件录制。\r\n\r\n\r\ndir\r\n列出当前目录中的所有文件。\r\n\r\n\r\nload\r\n从文件加载工作区变量。\r\n\r\n\r\npath\r\n显示搜索路径。\r\n\r\n\r\npwd\r\n显示当前目录。\r\n\r\n\r\nsave\r\n将工作空间变量保存在文件中。\r\n\r\n\r\ntype\r\n显示文件的内容。\r\n\r\n\r\nwhat\r\n列出当前目录中的所有MATLAB文件。\r\n\r\n\r\nwklread\r\n读取.wk1电子表格文件。\r\n\r\n\r\n\r\n输入和输出命令\r\nMATLAB提供以下与输入和输出相关的命令\r\n\r\n\r\n\r\n命令\r\n目的\r\n\r\n\r\n\r\n\r\ndisp\r\n显示数组或字符串的内容。\r\n\r\n\r\nfscanf\r\n从文件中读取格式化的数据。\r\n\r\n\r\nformat\r\n控制屏幕显示格式。\r\n\r\n\r\nfprintf\r\n执行对屏幕或文件的格式化写入。\r\n\r\n\r\ninput\r\n显示提示并等待输入。\r\n\r\n\r\n;\r\n禁止丝网印刷。\r\n\r\n\r\n\r\nfscanf和fprintf命令的行为像C的scanf和printf函数。它们支持以下格式代码-\r\n\r\n\r\n\r\n格式代码\r\n目的\r\n\r\n\r\n\r\n\r\n%s\r\n格式化为字符串。\r\n\r\n\r\n%d\r\n格式化为整数。\r\n\r\n\r\n%f\r\n格式化为浮点值。\r\n\r\n\r\n%e\r\n以科学计数形式格式化为浮点值。\r\n\r\n\r\n%g\r\n以最紧凑的格式进行格式化：％f或％e。\r\n\r\n\r\n***\r\n在输出字符串中插入新行。\r\n\r\n\r\n**\r\n在输出字符串中插入一个选项卡。\r\n\r\n\r\n\r\n格式函数具有以下用于数字显示的形式-\r\n\r\n\r\n\r\n格式功能\r\n最多显示\r\n\r\n\r\n\r\n\r\nformat short\r\n四个小数位(默认值)。\r\n\r\n\r\nformat long\r\n16位小数。\r\n\r\n\r\nformat short e\r\n五位数加指数。\r\n\r\n\r\nformat long e\r\n16位数字加指数。\r\n\r\n\r\nformat bank\r\n两个小数位数。定点货币形式\r\n\r\n\r\nformat +\r\n正数，负数或零。\r\n\r\n\r\nformat rat\r\n有理近似。小数分数表示\r\n\r\n\r\nformat compact\r\n禁止某些换行符。\r\n\r\n\r\nformat loose\r\n重置为不太紧凑的显示模式。\r\n\r\n\r\n\r\n高级输入输出技术\r\nMATLAB 提供了更灵活的数据导入 / 导出函数：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n适用场景\r\n\r\n\r\n\r\n\r\nimportdata\r\n自动识别并导入文本文件、电子表格或图像数据\r\n\r\n\r\nreadtable\r\n读取表格数据到 table 对象，支持标题行、缺失值处理等\r\n\r\n\r\nwritetable\r\n将 table 对象写入文件（CSV、XLSX 等）\r\n\r\n\r\ncsvread/csvwrite\r\n简化的 CSV 文件读写函数\r\n\r\n\r\nxlswrite/xlsread\r\n读写 Excel 文件（需安装 Excel 或兼容组件）\r\n\r\n\r\n\r\n向量，矩阵和数组命令\r\n下表显示了用于处理数组，矩阵和向量的各种命令-\r\n\r\n\r\n\r\n命令\r\n目的\r\n\r\n\r\n\r\n\r\ncat\r\n连接数组。\r\n\r\n\r\nfind\r\n查找非零元素的索引。\r\n\r\n\r\nlength\r\n计算元素数。\r\n\r\n\r\nlinspace\r\n创建规则间隔的矢量。\r\n\r\n\r\nlogspace\r\n创建对数间隔的向量。\r\n\r\n\r\nmax\r\n返回最大元素。\r\n\r\n\r\nmin\r\n返回最小的元素。\r\n\r\n\r\nprod\r\n每列的乘积。\r\n\r\n\r\nreshape\r\n更改大小。\r\n\r\n\r\nsize\r\n计算数组大小。\r\n\r\n\r\nsort\r\n对每一列进行排序。\r\n\r\n\r\nsum\r\n对每列求和。\r\n\r\n\r\neye\r\n创建一个单位矩阵。\r\n\r\n\r\nones\r\n创建一个数组。\r\n\r\n\r\nzeros\r\n创建一个零数组。\r\n\r\n\r\ncross\r\n计算矩阵叉积。\r\n\r\n\r\ndot\r\n计算矩阵点积。\r\n\r\n\r\ndet\r\n计算数组的行列式。\r\n\r\n\r\ninv\r\n计算矩阵的逆。\r\n\r\n\r\npinv\r\n计算矩阵的伪逆。\r\n\r\n\r\nrank\r\n计算矩阵的秩。\r\n\r\n\r\nrref\r\n计算精简行梯形表格。\r\n\r\n\r\ncell\r\n创建单元格数组。\r\n\r\n\r\ncelldisp\r\n显示单元格数组。\r\n\r\n\r\ncellplot\r\n显示单元格数组的图形表示形式。\r\n\r\n\r\nnum2cell\r\n将数字数组转换为单元格数组。\r\n\r\n\r\ndeal\r\n匹配输入和输出列表。\r\n\r\n\r\niscell\r\n标识单元格数组。\r\n\r\n\r\n\r\n绘图命令\r\nMATLAB提供了许多用于绘制图形的命令。下表显示了一些常用的绘图命令-\r\n\r\n\r\n\r\n命令\r\n目的\r\n\r\n\r\n\r\n\r\naxis\r\n设置轴限制。\r\n\r\n\r\nfplot\r\n函数的智能绘图。\r\n\r\n\r\ngrid\r\n显示网格线。\r\n\r\n\r\nplot\r\n生成xy图。\r\n\r\n\r\nprint\r\n打印图或将图保存到文件中。\r\n\r\n\r\ntitle\r\n将文本放在图的顶部。\r\n\r\n\r\nxlabel\r\n在x轴上添加文本标签。\r\n\r\n\r\nylabel\r\n将文本标签添加到y轴。\r\n\r\n\r\naxes\r\n创建轴对象。\r\n\r\n\r\nclose\r\n关闭当前图。\r\n\r\n\r\nclose all\r\n关闭所有地块。\r\n\r\n\r\nfigure\r\n打开一个新的图形窗口。\r\n\r\n\r\ngtext\r\n通过鼠标启用标签放置。\r\n\r\n\r\nhold\r\n冻结当前图。\r\n\r\n\r\nlegend\r\n用鼠标放置图例。\r\n\r\n\r\nrefresh\r\n重新绘制当前图形窗口。\r\n\r\n\r\nset\r\n指定对象（例如轴）的属性。\r\n\r\n\r\nsubplot\r\n在子窗口中创建图。\r\n\r\n\r\ntext\r\n在图中放置字符串。\r\n\r\n\r\nbar\r\n创建条形图。\r\n\r\n\r\nloglog\r\n创建对数-对数图。\r\n\r\n\r\npolar\r\n创建极坐标图。\r\n\r\n\r\nsemilogx\r\n创建半对数图。（对数横坐标）。\r\n\r\n\r\nsemilogy\r\n创建半对数图。（对数纵坐标）。\r\n\r\n\r\nstairs\r\n创建楼梯图。\r\n\r\n\r\nstem\r\n创建茎图。\r\n\r\n\r\n\r\n% 图形美化示例x = linspace(0, 2*pi, 100);y1 = sin(x);y2 = cos(x);% 创建图形并设置属性figure(&#x27;Position&#x27;, [100 100 800 400])  % 设置窗口位置和大小plot(x, y1, &#x27;LineWidth&#x27;, 2, &#x27;Color&#x27;, [0.5 0.7 0.9])  % 设置线宽和颜色hold onplot(x, y2, &#x27;--&#x27;, &#x27;LineWidth&#x27;, 2, &#x27;Color&#x27;, [0.9 0.6 0.3])  % 虚线和不同颜色% 添加标题和标签title(&#x27;Sin and Cos Functions&#x27;, &#x27;FontSize&#x27;, 14)xlabel(&#x27;x&#x27;, &#x27;FontSize&#x27;, 12)ylabel(&#x27;Amplitude&#x27;, &#x27;FontSize&#x27;, 12)% 添加图例和网格legend(&#x27;sin(x)&#x27;, &#x27;cos(x)&#x27;, &#x27;Location&#x27;, &#x27;best&#x27;)grid on% 设置坐标轴范围和刻度axis([0 2*pi -1.2 1.2])xticks(0:pi/2:2*pi)xticklabels(&#123;&#x27;0&#x27;, &#x27;\\pi/2&#x27;, &#x27;\\pi&#x27;, &#x27;3\\pi/2&#x27;, &#x27;2\\pi&#x27;&#125;)% 添加注释text(pi/2, 1, &#x27;\\leftarrow \\sin(\\pi/2)=1&#x27;, &#x27;HorizontalAlignment&#x27;, &#x27;left&#x27;)text(pi, -1, &#x27;\\leftarrow \\cos(\\pi)=-1&#x27;, &#x27;HorizontalAlignment&#x27;, &#x27;left&#x27;)\r\n交互式绘图命令\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n功能\r\n\r\n\r\n\r\n\r\nginput\r\n通过鼠标在图形上获取坐标点\r\n\r\n\r\nzoom\r\n启用图形缩放功能\r\n\r\n\r\npan\r\n启用图形平移功能\r\n\r\n\r\ndatacursormode\r\n在图形上显示数据光标，获取精确坐标值\r\n\r\n\r\nimpixelinfo\r\n在图像上显示像素信息\r\n\r\n\r\ncolorbar\r\n添加颜色条，显示颜色映射关系\r\n\r\n\r\ncolormap\r\n设置图形的颜色映射表，支持 jet、hsv、gray 等多种预设\r\n\r\n\r\n\r\n图形导出与保存\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n功能\r\n\r\n\r\n\r\n\r\nsaveas\r\n将当前图形保存为指定格式的文件\r\n\r\n\r\nprint\r\n更灵活的图形导出命令，支持分辨率、纸张大小等参数控制\r\n\r\n\r\nexportgraphics\r\nMATLAB R2020b 及以后版本提供的导出命令，优化了图形保存质量\r\n\r\n\r\n\r\n% 图形保存示例fig = figure;plot(x, y);title(&#x27;My Plot&#x27;);% 传统方法print(&#x27;myplot.png&#x27;, &#x27;-dpng&#x27;, &#x27;-r300&#x27;);  % 300 DPI PNG% 推荐方法 (R2020b及以后)exportgraphics(fig, &#x27;myplot.png&#x27;, &#x27;Resolution&#x27;, 300);\r\nMATLAB M文件\r\n到目前为止，我们已经使用MATLAB环境作为计算器。但是，MATLAB还是一种强大的编程语言，也是一种交互式计算环境。MATLAB还允许您将一系列命令写入文件并以完整的单元形式执行文件，例如编写函数和调用它。\r\nMATLAB允许编写两种程序文件\r\n\r\n脚本：脚本文件是扩展名为 .m\r\n的程序文件。在这些文件中，您编写了一系列要一起执行的命令。脚本不接受输入，也不返回任何输出。它们对工作区中的数据进行操作。\r\n函数：函数文件也是扩展名为 .m\r\n的程序文件。函数可以接受输入并返回输出。内部变量是函数的局部变量。\r\n\r\n您可以使用MATLAB编辑器或任何其他文本编辑器来创建.m文件。在本节中，我们将讨论脚本文件。脚本文件包含多行MATLAB命令和函数调用。您可以通过在命令行中输入脚本名称来运行脚本。\r\n如果使用命令提示符，请键入edit命令提示符。这将打开编辑器。您可以直接输入edit，然后输入文件名（扩展名为.m）\r\nedit Oredit &lt;filename&gt;\r\n上面的命令将在默认的MATLAB目录中创建文件。如果要将所有程序文件存储在特定文件夹中，则必须提供完整路径。\r\n让我们创建一个名为progs的文件夹。在命令提示符（&gt;&gt;）处键入以下命令，这和\r\nbash 的命令是差不多的\r\nmkdir progs    % create directory progs under default directorychdir progs    % changing the current directory to progsedit  prog1.m  % creating an m file named prog1.m\r\n","categories":["数学类","MATLAB"],"tags":["语法知识","学习","语言方面","数学","物理","数学建模"]},{"title":"MATLAB part5-数据导入和数据输出","url":"/posts/39953.html","content":"MATLAB 数据导入（ImportData）\r\n数据导入是指将存储在外部文件中的数据加载到MATLAB工作空间中的过程。\r\nMATLAB支持导入多种格式的数据文件，包括：\r\n\r\n文本文件：.txt、.csv、.dat等\r\n电子表格：.xlsx、.xls等\r\n科学数据格式：.mat、.h5、.nc等\r\n图像文件：.jpg、.png、.tiff等\r\n音频文件：.wav、.mp3等\r\n\r\nMATLAB 提供了丰富的数据 I/O\r\n函数，支持多种文件格式，包括文本文件、Excel\r\n文件、图像文件、音频文件等，方便用户根据不同的需求选择合适的导入方法。\r\nimportdata函数\r\nimportdata函数是MATLAB中最通用的数据导入函数，能够自动识别文件格式并采用相应的导入策略。这使得用户在导入数据时无需手动指定文件格式，大大提高了数据导入的效率。\r\n该importdata功能允许加载不同格式的各种数据文件。它具有以下五种形式\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n功能\r\n语句\r\n\r\n\r\n\r\n\r\n从指定文件导入数据到数组A\r\nA = importdata(filename)\r\n\r\n\r\n从系统剪贴板而不是文件加载数据。\r\nA = importdata(‘-pastespecial’)\r\n\r\n\r\n指定列分隔符导入\r\n**A = importdata(___, delimiterIn)**\r\n\r\n\r\n指定分隔符和头行数导入\r\n**A = importdata(___, delimiterIn, headerlinesIn)**\r\n\r\n\r\n返回检测到的分隔符和头行信息\r\n**[A, delimiterOut, headerlinesOut] = importdata(___)**\r\n\r\n\r\n\r\n% ===== 示例1：基本文本文件导入 =====% 假设有一个名为&#x27;sample_data.txt&#x27;的文件，内容如下：% Name, Age, Score% Alice, 25, 85.5% Bob, 30, 92.3% Charlie, 28, 78.9% 导入数据data = importdata(&#x27;sample_data.txt&#x27;);% 检查导入结果的结构if isstruct(data)    fprintf(&#x27;数据类型：结构体\\n&#x27;);    fprintf(&#x27;数值数据维度：%d x %d\\n&#x27;, size(data.data));    fprintf(&#x27;文本数据行数：%d\\n&#x27;, length(data.textdata));        % 显示数值数据    disp(&#x27;数值数据：&#x27;);    disp(data.data);        % 显示文本数据（包括头行）    disp(&#x27;文本数据：&#x27;);    disp(data.textdata);else    disp(&#x27;导入的是纯数值数据&#x27;);    disp(data);end% ===== 示例2：CSV文件导入 =====% 创建示例CSV文件csvData = [1, 2, 3; 4, 5, 6; 7, 8, 9];csvwrite(&#x27;example.csv&#x27;, csvData);% 导入CSV文件importedCSV = importdata(&#x27;example.csv&#x27;);fprintf(&#x27;CSV数据：\\n&#x27;);disp(importedCSV);% ===== 示例3：指定分隔符导入 =====% 创建用制表符分隔的文件tabData = [&#x27;1&#x27; char(9) &#x27;2&#x27; char(9) &#x27;3&#x27; newline ...           &#x27;4&#x27; char(9) &#x27;5&#x27; char(9) &#x27;6&#x27; newline ...           &#x27;7&#x27; char(9) &#x27;8&#x27; char(9) &#x27;9&#x27;];fid = fopen(&#x27;tab_separated.txt&#x27;, &#x27;w&#x27;);fprintf(fid, &#x27;%s&#x27;, tabData);fclose(fid);% 使用制表符作为分隔符导入tabImported = importdata(&#x27;tab_separated.txt&#x27;, &#x27;\\t&#x27;);fprintf(&#x27;制表符分隔的数据：\\n&#x27;);disp(tabImported);% ===== 示例4：处理带头行的文件 =====% 创建带头行的数据文件headerData = [&#x27;Temperature,Humidity,Pressure&#x27; newline ...              &#x27;Unit: C,Unit: %,Unit: hPa&#x27; newline ...              &#x27;25.5,60.2,1013.25&#x27; newline ...              &#x27;26.8,58.7,1012.80&#x27; newline ...              &#x27;24.9,62.1,1014.15&#x27;];fid = fopen(&#x27;weather_data.txt&#x27;, &#x27;w&#x27;);fprintf(fid, &#x27;%s&#x27;, headerData);fclose(fid);% 导入时指定跳过前2行头信息[weatherData, delimiter, headerLines] = importdata(&#x27;weather_data.txt&#x27;, &#x27;,&#x27;, 2);fprintf(&#x27;检测到的分隔符：%s\\n&#x27;, delimiter);fprintf(&#x27;检测到的头行数：%d\\n&#x27;, headerLines);fprintf(&#x27;天气数据：\\n&#x27;);disp(weatherData);\r\nExcel文件导入\r\nExcel文件是最常见的数据存储格式之一，MATLAB提供了多种方法来处理Excel文件。\r\n使用readtable函数\r\nreadtable 函数是推荐的 Excel 文件导入方法，它可以将\r\nExcel 文件中的数据读取为表格形式，方便后续的数据处理和分析。\r\n% ===== Excel文件导入示例 =====% 方法1：使用readtable（推荐）% 创建示例Excel数据studentData = table([&#x27;Alice&#x27;; &#x27;Bob&#x27;; &#x27;Charlie&#x27;], [25; 30; 28], [85.5; 92.3; 78.9], ...                   &#x27;VariableNames&#x27;, &#123;&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;Score&#x27;&#125;);writetable(studentData, &#x27;students.xlsx&#x27;);% 读取Excel文件students = readtable(&#x27;students.xlsx&#x27;);fprintf(&#x27;学生数据表：\\n&#x27;);disp(students);% 访问特定列names = students.Name;ages = students.Age;scores = students.Score;fprintf(&#x27;平均年龄：%.1f\\n&#x27;, mean(ages));fprintf(&#x27;平均分数：%.1f\\n&#x27;, mean(scores));% 方法2：使用xlsread（较老的方法）[numData, textData, rawData] = xlsread(&#x27;students.xlsx&#x27;);fprintf(&#x27;数值数据：\\n&#x27;);disp(numData);fprintf(&#x27;文本数据：\\n&#x27;);disp(textData);% 方法3：读取特定工作表和范围% 假设Excel文件有多个工作表writetable(studentData, &#x27;multi_sheet.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;Sheet1&#x27;);writetable(studentData, &#x27;multi_sheet.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;BackupData&#x27;);% 读取指定工作表sheet1Data = readtable(&#x27;multi_sheet.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;Sheet1&#x27;);backupData = readtable(&#x27;multi_sheet.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;BackupData&#x27;);% 读取指定范围rangeData = readtable(&#x27;students.xlsx&#x27;, &#x27;Range&#x27;, &#x27;A1:C3&#x27;);fprintf(&#x27;指定范围的数据：\\n&#x27;);disp(rangeData);\r\n专用导入函数\r\nMATLAB\r\n为不同类型的文件提供了专用的导入函数，这些函数可以更高效地处理特定类型的数据。\r\n% 文本文件data = readtable(&#x27;data.csv&#x27;, &#x27;Delimiter&#x27;, &#x27;,&#x27;, &#x27;HeaderLines&#x27;, 1);% Excel文件[num, txt, raw] = xlsread(&#x27;data.xlsx&#x27;, &#x27;Sheet1&#x27;, &#x27;A1:C10&#x27;);% 图像文件img = imread(&#x27;image.jpg&#x27;);imshow(img);% 音频文件[y, Fs] = audioread(&#x27;sound.wav&#x27;);sound(y, Fs);\r\n以文本文件专用函数为例子\r\n% ===== 文本文件导入的其他方法 =====% readmatrix - 读取数值矩阵numMatrix = [1, 2, 3; 4, 5, 6; 7, 8, 9];writematrix(numMatrix, &#x27;matrix_data.txt&#x27;);importedMatrix = readmatrix(&#x27;matrix_data.txt&#x27;);fprintf(&#x27;导入的矩阵：\\n&#x27;);disp(importedMatrix);% readcell - 读取混合数据为元胞数组mixedData = &#123;&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;City&#x27;; &#x27;Alice&#x27;, 25, &#x27;NYC&#x27;; &#x27;Bob&#x27;, 30, &#x27;LA&#x27;&#125;;writecell(mixedData, &#x27;mixed_data.txt&#x27;);importedCell = readcell(&#x27;mixed_data.txt&#x27;);fprintf(&#x27;混合数据：\\n&#x27;);disp(importedCell);% textscan - 格式化文本读取fid = fopen(&#x27;formatted_data.txt&#x27;, &#x27;w&#x27;);fprintf(fid, &#x27;Alice 25 85.5\\nBob 30 92.3\\nCharlie 28 78.9\\n&#x27;);fclose(fid);fid = fopen(&#x27;formatted_data.txt&#x27;, &#x27;r&#x27;);scannedData = textscan(fid, &#x27;%s %d %f&#x27;);fclose(fid);fprintf(&#x27;格式化读取结果：\\n&#x27;);fprintf(&#x27;姓名：&#x27;); disp(scannedData&#123;1&#125;&#x27;);fprintf(&#x27;年龄：&#x27;); disp(scannedData&#123;2&#125;&#x27;);fprintf(&#x27;分数：&#x27;); disp(scannedData&#123;3&#125;&#x27;);\r\n底层文件I / O\r\nimportdata函数是一个高级函数。MATLAB中的底层文件I/O函数允许对文件的读写数据进行最大程度的控制。但是，这些函数需要更详细的文件信息才能有效地工作。\r\nMATLAB为字节或字符级别的读写操作提供以下函数\r\n\r\n\r\n\r\n函数\r\n描述\r\n\r\n\r\n\r\n\r\nfclose\r\n关闭一个或所有打开的文件\r\n\r\n\r\nfeof\r\n文件结尾测试\r\n\r\n\r\nferror\r\n有关文件I/O错误的信息\r\n\r\n\r\nfgetl\r\n从文件中读取行，删除换行符\r\n\r\n\r\nfgets\r\n从文件中读取行，保留换行符\r\n\r\n\r\nfopen\r\n打开文件，或获取有关打开文件的信息\r\n\r\n\r\nfprintf\r\n将数据写入文本文件\r\n\r\n\r\nfread\r\n从二进制文件读取数据\r\n\r\n\r\nfrewind\r\n将文件位置指示器移动到打开文件的开头\r\n\r\n\r\nfscanf\r\n从文本文件读取数据\r\n\r\n\r\nfseek\r\n移动到文件中的指定位置\r\n\r\n\r\nftell\r\n在打开文件中的位置\r\n\r\n\r\nfwrite\r\n将数据写入二进制文件\r\n\r\n\r\n\r\n导入具有底层I / O的文本数据文件\r\n\r\nMATLAB 提供以下功能用于文本数据文件的底层导入：\r\n\r\nfscanf 函数读取文本或 ASCII\r\n文件中的格式化数据。可以根据指定的格式字符串从文件中读取数据，例如\r\n'%s %d %f' 表示读取一个字符串、一个整数和一个浮点数。\r\nfgetl 和 fgets\r\n的时间，其中，一个换行字符的每一行分离功能读取的文件的一行。fgetl\r\n会去除行末的换行符，而 fgets 会保留换行符。\r\nfread\r\n函数读取字节或位级别的数据流。可以用于读取二进制文件或文本文件的原始字节数据。\r\n\r\n\r\n% 底层 I/O 读取文本文件示例fid = fopen(&#x27;data.txt&#x27;, &#x27;r&#x27;);if fid ~= -1    while ~feof(fid)        line = fgetl(fid);        disp(line);    end    fclose(fid);else    error(&#x27;无法打开文件&#x27;);end\r\nMATLAB 数据输出\r\n数据导出(或输出)在 MATLAB 的意思是写入文件。MATLAB 允许您在另一个读取\r\nASCII 文件的应用程序中使用您的数据。为此，MATLAB\r\n提供了几个数据导出选项。\r\n可以创建以下类型的文件：\r\n\r\n数组中的矩形、分隔的 ASCII\r\n数据文件。常用于将数值数据以文本形式保存，方便其他程序读取。\r\n击键的日记（或日志）文件和结果文本输出。可以记录 MATLAB\r\n命令窗口中的操作和输出结果。\r\n使用底层函数（如 fprintf）的专用 ASCII\r\n文件。可以根据需要自定义文件的格式和内容。\r\nMEX 文件，用于访问以特定文本文件格式写入的 C / C ++ 或 Fortran\r\n例程。可以在 MATLAB 中调用 C、C++ 或 Fortran 编写的函数。\r\n\r\nMATLAB支持多种输出格式，选择合适的格式取决于：\r\n\r\n目标应用程序：是否需要被Excel、其他编程语言或特定软件读取\r\n数据特性：数值数据、文本数据还是混合数据\r\n文件大小：是否需要压缩或高效存储\r\n精度要求：是否需要保持完整的数值精度\r\n\r\n除此之外，还可以将数据导出到电子表格。\r\n有两种方法可以将数字数组导出为定界的ASCII数据文件\r\n\r\n使用save函数并指定-ascii限定符\r\n使用dlmwrite函数\r\n\r\n使用save函数输出ASCII文件\r\nsave函数配合-ascii选项是输出数值数据最简单的方法。\r\n% ===== save函数ASCII输出示例 =====% 创建示例数据temperatureData = [    25.5, 26.2, 24.8, 27.1, 25.9;    26.8, 27.5, 25.3, 28.2, 26.7;    24.9, 25.6, 23.7, 26.4, 25.1];% 基本ASCII保存save(&#x27;temperature.txt&#x27;, &#x27;temperatureData&#x27;, &#x27;-ascii&#x27;);fprintf(&#x27;数据已保存到 temperature.txt\\n&#x27;);% 验证保存结果savedData = load(&#x27;temperature.txt&#x27;);fprintf(&#x27;保存的温度数据：\\n&#x27;);disp(savedData);% 高精度保存（16位精度）preciseData = pi * rand(3, 3);save(&#x27;precise_data.txt&#x27;, &#x27;preciseData&#x27;, &#x27;-ascii&#x27;, &#x27;-double&#x27;);fprintf(&#x27;高精度数据：\\n&#x27;);disp(preciseData);% 读取并比较精度loadedPrecise = load(&#x27;precise_data.txt&#x27;);fprintf(&#x27;精度差异（应接近0）：\\n&#x27;);disp(abs(preciseData - loadedPrecise));% 制表符分隔保存save(&#x27;tab_separated_output.txt&#x27;, &#x27;temperatureData&#x27;, &#x27;-ascii&#x27;, &#x27;-tabs&#x27;);fprintf(&#x27;制表符分隔文件已创建\\n&#x27;);\r\n使用dlmwrite函数\r\ndlmwrite函数提供了更多的格式控制选项，特别适合需要自定义分隔符的场景。\r\n% ===== dlmwrite函数详细示例 =====% 创建销售数据示例salesMatrix = [    1001, 1500, 2000, 1800;  % Q1销售额    1200, 1600, 2100, 1900;  % Q2销售额    1100, 1400, 1900, 1700;  % Q3销售额    1300, 1700, 2200, 2000   % Q4销售额];% 基本逗号分隔输出dlmwrite(&#x27;sales_comma.csv&#x27;, salesMatrix, &#x27;delimiter&#x27;, &#x27;,&#x27;);fprintf(&#x27;逗号分隔文件已创建\\n&#x27;);% 自定义分隔符（分号）dlmwrite(&#x27;sales_semicolon.csv&#x27;, salesMatrix, &#x27;delimiter&#x27;, &#x27;;&#x27;);fprintf(&#x27;分号分隔文件已创建\\n&#x27;);% 指定精度dlmwrite(&#x27;sales_precision.txt&#x27;, salesMatrix, &#x27;delimiter&#x27;, &#x27;\\t&#x27;, &#x27;precision&#x27;, 6);fprintf(&#x27;高精度制表符分隔文件已创建\\n&#x27;);% 追加数据到现有文件newQuarterData = [1400, 1800, 2300, 2100];dlmwrite(&#x27;sales_comma.csv&#x27;, newQuarterData, &#x27;delimiter&#x27;, &#x27;,&#x27;, &#x27;-append&#x27;);fprintf(&#x27;新季度数据已追加\\n&#x27;);% 验证追加结果appendedData = csvread(&#x27;sales_comma.csv&#x27;);fprintf(&#x27;追加后的完整数据：\\n&#x27;);disp(appendedData);% 带偏移的写入dlmwrite(&#x27;offset_example.txt&#x27;, [999, 888], &#x27;delimiter&#x27;, &#x27;,&#x27;, ...         &#x27;roffset&#x27;, 2, &#x27;coffset&#x27;, 1);fprintf(&#x27;带偏移的数据已写入\\n&#x27;);% 读取验证偏移效果offsetResult = dlmread(&#x27;offset_example.txt&#x27;, &#x27;,&#x27;);fprintf(&#x27;偏移写入结果：\\n&#x27;);disp(offsetResult);\r\nExcel文件输出\r\nExcel输出对于与办公软件交互非常重要，MATLAB提供了多种Excel输出方法。\r\n使用最基本的xlswrite\r\ndata = &#123;&#x27;Name&#x27;,&#x27;Age&#x27;; &#x27;John&#x27;,28; &#x27;Mary&#x27;,32&#125;;xlswrite(&#x27;output.xlsx&#x27;, data, &#x27;Sheet1&#x27;, &#x27;A1&#x27;);\r\n使用writetable函数\r\n% ===== Excel输出综合示例 =====% 创建完整的业务数据表employeeData = table();employeeData.EmployeeID = (1001:1010)&#x27;;employeeData.Name = &#123;&#x27;Alice Johnson&#x27;; &#x27;Bob Smith&#x27;; &#x27;Charlie Brown&#x27;; &#x27;Diana Prince&#x27;;                      &#x27;Edward Norton&#x27;; &#x27;Fiona Green&#x27;; &#x27;George Lucas&#x27;; &#x27;Helen Troy&#x27;;                      &#x27;Ivan Petrov&#x27;; &#x27;Jane Doe&#x27;&#125;;employeeData.Department = categorical(&#123;&#x27;IT&#x27;; &#x27;HR&#x27;; &#x27;Finance&#x27;; &#x27;IT&#x27;; &#x27;Marketing&#x27;;                                      &#x27;HR&#x27;; &#x27;Finance&#x27;; &#x27;IT&#x27;; &#x27;Marketing&#x27;; &#x27;Finance&#x27;&#125;);employeeData.Salary = [75000; 68000; 72000; 78000; 65000;                        70000; 74000; 80000; 67000; 73000];employeeData.StartDate = datetime(&#123;&#x27;2020-01-15&#x27;; &#x27;2019-03-22&#x27;; &#x27;2021-07-10&#x27;; &#x27;2020-11-05&#x27;;                                  &#x27;2021-02-28&#x27;; &#x27;2019-09-15&#x27;; &#x27;2020-06-01&#x27;; &#x27;2021-04-20&#x27;;                                  &#x27;2020-08-12&#x27;; &#x27;2021-01-30&#x27;&#125;);employeeData.Performance = [4.2; 3.8; 4.0; 4.5; 3.7; 4.1; 3.9; 4.3; 3.6; 4.0];% 基本Excel输出writetable(employeeData, &#x27;employee_data.xlsx&#x27;);fprintf(&#x27;员工数据已保存到Excel文件\\n&#x27;);% 指定工作表名称writetable(employeeData, &#x27;company_data.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;Employees&#x27;);fprintf(&#x27;数据已保存到指定工作表\\n&#x27;);% 多工作表输出% 按部门分组departments = unique(employeeData.Department);for i = 1:length(departments)    deptData = employeeData(employeeData.Department == departments(i), :);    sheetName = char(departments(i));    writetable(deptData, &#x27;department_reports.xlsx&#x27;, &#x27;Sheet&#x27;, sheetName);    fprintf(&#x27;部门 %s 的数据已保存\\n&#x27;, sheetName);end% 统计摘要输出summary_stats = table();summary_stats.Department = departments;summary_stats.EmployeeCount = zeros(length(departments), 1);summary_stats.AvgSalary = zeros(length(departments), 1);summary_stats.AvgPerformance = zeros(length(departments), 1);for i = 1:length(departments)    deptData = employeeData(employeeData.Department == departments(i), :);    summary_stats.EmployeeCount(i) = height(deptData);    summary_stats.AvgSalary(i) = mean(deptData.Salary);    summary_stats.AvgPerformance(i) = mean(deptData.Performance);endwritetable(summary_stats, &#x27;department_reports.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;Summary&#x27;);fprintf(&#x27;部门统计摘要已保存\\n&#x27;);% 显示摘要fprintf(&#x27;部门统计摘要：\\n&#x27;);disp(summary_stats);\r\n使用writematrix和writecell\r\n% ===== 矩阵和元胞数组Excel输出 =====% 数值矩阵输出correlationMatrix = corrcoef(rand(10, 5));writematrix(correlationMatrix, &#x27;correlation_analysis.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;Correlation&#x27;);fprintf(&#x27;相关性矩阵已保存\\n&#x27;);% 元胞数组输出（混合数据类型）reportData = &#123;    &#x27;Metric&#x27;, &#x27;Q1&#x27;, &#x27;Q2&#x27;, &#x27;Q3&#x27;, &#x27;Q4&#x27;, &#x27;Total&#x27;;    &#x27;Revenue&#x27;, 150000, 165000, 180000, 170000, 665000;    &#x27;Expenses&#x27;, 120000, 130000, 140000, 135000, 525000;    &#x27;Profit&#x27;, 30000, 35000, 40000, 35000, 140000;    &#x27;Margin %&#x27;, 20.0, 21.2, 22.2, 20.6, 21.1&#125;;writecell(reportData, &#x27;quarterly_report.xlsx&#x27;, &#x27;Sheet&#x27;, &#x27;Financial Summary&#x27;);fprintf(&#x27;季度报告已保存\\n&#x27;);% 带格式控制的输出xlswrite(&#x27;formatted_output.xlsx&#x27;, reportData, &#x27;Summary&#x27;, &#x27;A1&#x27;);fprintf(&#x27;格式化输出完成\\n&#x27;);\r\n专业格式输出\r\nJSON格式输出\r\n% ===== JSON格式数据输出 =====% 创建结构化数据projectData.project_name = &#x27;Data Analysis Pipeline&#x27;;projectData.version = &#x27;2.1.0&#x27;;projectData.created_date = datestr(now, &#x27;yyyy-mm-dd&#x27;);projectData.team_members = &#123;&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;&#125;;projectData.modules = struct(&#x27;data_import&#x27;, true, &#x27;analysis&#x27;, true, &#x27;visualization&#x27;, false);projectData.parameters = struct(&#x27;threshold&#x27;, 0.05, &#x27;iterations&#x27;, 1000, &#x27;method&#x27;, &#x27;regression&#x27;);% 转换为JSON并保存jsonStr = jsonencode(projectData);fid = fopen(&#x27;project_config.json&#x27;, &#x27;w&#x27;);fprintf(fid, &#x27;%s&#x27;, jsonStr);fclose(fid);fprintf(&#x27;项目配置已保存为JSON格式\\n&#x27;);% 美化JSON输出prettyJson = jsonencode(projectData, &#x27;PrettyPrint&#x27;, true);fid = fopen(&#x27;project_config_pretty.json&#x27;, &#x27;w&#x27;);fprintf(fid, &#x27;%s&#x27;, prettyJson);fclose(fid);fprintf(&#x27;格式化JSON配置已保存\\n&#x27;);% 显示JSON内容fprintf(&#x27;JSON配置内容：\\n%s\\n&#x27;, prettyJson);\r\n图像/音频输出\r\n% 图像imwrite(img, &#x27;output.png&#x27;, &#x27;PNG&#x27;);% 音频audiowrite(&#x27;output.wav&#x27;, y, Fs);\r\n自定义格式输出\r\n% ===== 自定义格式输出示例 =====% 创建实验数据experimentData = struct();experimentData.experiment_id = &#x27;EXP_2024_001&#x27;;experimentData.timestamp = datetime(&#x27;now&#x27;);experimentData.conditions = &#123;&#x27;Control&#x27;, &#x27;Treatment_A&#x27;, &#x27;Treatment_B&#x27;&#125;;experimentData.measurements = rand(3, 10) * 100;  % 3个条件，每个10次测量experimentData.statistics = struct();% 计算统计信息for i = 1:length(experimentData.conditions)    condition = experimentData.conditions&#123;i&#125;;    data = experimentData.measurements(i, :);    experimentData.statistics.(condition) = struct(...        &#x27;mean&#x27;, mean(data), ...        &#x27;std&#x27;, std(data), ...        &#x27;min&#x27;, min(data), ...        &#x27;max&#x27;, max(data), ...        &#x27;n&#x27;, length(data));end% 自定义格式报告输出fid = fopen(&#x27;experiment_report.txt&#x27;, &#x27;w&#x27;);fprintf(fid, &#x27;实验报告\\n&#x27;);fprintf(fid, &#x27;========================================\\n&#x27;);fprintf(fid, &#x27;实验编号: %s\\n&#x27;, experimentData.experiment_id);fprintf(fid, &#x27;实验时间: %s\\n&#x27;, datestr(experimentData.timestamp));fprintf(fid, &#x27;========================================\\n\\n&#x27;);fprintf(fid, &#x27;实验条件和结果:\\n&#x27;);fprintf(fid, &#x27;----------------------------------------\\n&#x27;);for i = 1:length(experimentData.conditions)    condition = experimentData.conditions&#123;i&#125;;    stats = experimentData.statistics.(condition);        fprintf(fid, &#x27;\\n条件: %s\\n&#x27;, condition);    fprintf(fid, &#x27;  样本数量: %d\\n&#x27;, stats.n);    fprintf(fid, &#x27;  平均值: %.2f\\n&#x27;, stats.mean);    fprintf(fid, &#x27;  标准差: %.2f\\n&#x27;, stats.std);    fprintf(fid, &#x27;  最小值: %.2f\\n&#x27;, stats.min);    fprintf(fid, &#x27;  最大值: %.2f\\n&#x27;, stats.max);        % 输出原始数据    fprintf(fid, &#x27;  原始数据: &#x27;);    fprintf(fid, &#x27;%.2f &#x27;, experimentData.measurements(i, :));    fprintf(fid, &#x27;\\n&#x27;);endfprintf(fid, &#x27;\\n========================================\\n&#x27;);fprintf(fid, &#x27;报告生成时间: %s\\n&#x27;, datestr(now));fclose(fid);fprintf(&#x27;实验报告已生成\\n&#x27;);\r\n常见问题\r\n中文乱码处理\r\n在导入包含中文的数据文件时，可能会出现中文乱码的问题。可以通过设置文件的编码格式来解决。\r\nopts = detectImportOptions(&#x27;data.csv&#x27;);opts.Encoding = &#x27;UTF-8&#x27;; % 或 &#x27;GB2312&#x27;data = readtable(&#x27;data.csv&#x27;, opts);\r\n缺失数据处理\r\n在实际数据中，可能会存在缺失值。可以使用\r\nstandardizeMissing 函数将特定的值标记为缺失值，然后使用\r\nfillmissing 函数填充缺失值。\r\ndata = standardizeMissing(data, &#123;&#x27;NA&#x27;, &#x27;&#x27;, &#x27;.&#x27;, &#x27;NaN&#x27;&#125;);data = fillmissing(data, &#x27;constant&#x27;, 0); % 用 0 填充缺失值\r\n日期格式转换\r\n在导入包含日期的数据时，可能需要将日期字符串转换为 MATLAB\r\n的日期时间类型。可以使用 detectImportOptions\r\n函数检测导入选项，并使用 setvartype\r\n函数设置日期变量的类型。\r\nopts = detectImportOptions(&#x27;data.csv&#x27;);opts = setvartype(opts, &#x27;Date&#x27;, &#x27;datetime&#x27;);data = readtable(&#x27;data.csv&#x27;, opts);\r\n大数据处理\r\n当处理大型数据集时，一次性将整个数据集加载到内存中可能会导致内存不足的问题。可以使用\r\ndatastore\r\n函数创建数据存储对象，然后逐块读取数据进行处理。\r\n% 使用 datastore 处理大型数据集ds = datastore(&#x27;largefile.csv&#x27;);while hasdata(ds)    chunk = read(ds);    % 处理数据块end\r\n格式对照表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n文件类型\r\n导入函数\r\n导出函数\r\n备注\r\n\r\n\r\n\r\n\r\nCSV/TXT\r\nreadtable\r\nwritetable\r\n推荐处理表格数据\r\n\r\n\r\nExcel\r\nreadtable/xlsread\r\nwritetable/xlswrite\r\n注意Office版本兼容性\r\n\r\n\r\n图像\r\nimread\r\nimwrite\r\n支持多种图像格式\r\n\r\n\r\n音频\r\naudioread\r\naudiowrite\r\n需指定采样率\r\n\r\n\r\nMAT文件\r\nload\r\nsave\r\nMATLAB专用二进制格式\r\n\r\n\r\nHDF5\r\nh5read\r\nh5write\r\n科学数据常用格式\r\n\r\n\r\n\r\n","categories":["数学类","MATLAB"],"tags":["语法知识","学习","语言方面","数学","物理","数学建模"]},{"title":"MySql中的约束","url":"/posts/23211.html","content":"约束\r\n概述\r\n约束（Constraints）是用于限制表中数据的规则，确保数据的完整性和一致性。\r\n\r\n安全性约束\r\n完整性约束：确保数据的准确和可靠\r\n\r\n实体完整性约束（主键约束）\r\n域完整性约束（数据类型）\r\n引用完整性约束（外键约束）\r\n用户自定义完整性约束（check 约束）\r\n\r\n\r\n主键约束（PRIMARY\r\nKEY）\r\n作用：唯一标识表中的每一行，确保数据的唯一性\r\n基本特性\r\n\r\n唯一性：关系中任意元组的主键值必须唯一\r\n\r\n主键列的值必须唯一且不能为 NULL。\r\n一个表只能有一个主键，但主键可以由多个列组成（复合主键）。\r\n关系中任意元组的主键值必须唯一（unique）\r\n\r\n非空性：关系中任意元组在主键值必须非空\r\n\r\n关系中任意元组在主键值必须非空（not null）\r\n\r\n不可更改性：主键值一旦设定，通常不应修改\r\n\r\n-- 创建表时指定主键CREATE TABLE users (    id INT AUTO_INCREMENT PRIMARY KEY,    username VARCHAR(50) NOT NULL);-- 添加复合主键CREATE TABLE order_items (    order_id INT,    product_id INT,    quantity INT,    PRIMARY KEY (order_id, product_id));-- 修改表添加主键ALTER TABLE employees ADD PRIMARY KEY (emp_id);-- 删除主键约束ALTER TABLE employees DROP PRIMARY KEY;\r\n主键选择策略\r\n\r\n自然主键：使用业务中有意义的字段（如身份证号）\r\n代理主键：使用无意义的自增ID（推荐）\r\n复合主键：多个字段组合作为主键\r\n\r\n域完整性约束\r\n规则：关系中某属性取值必须在合法的范围内\r\n实现：\r\n\r\n一般通过数据类型来实现域完整性约束。不同的数据类型限制了属性可以接受的值的类型和范围。\r\nCREATE TABLE products (    price DECIMAL(10,2) NOT NULL,  -- 价格必须为数字    in_stock BOOLEAN DEFAULT TRUE   -- 布尔类型约束);\r\n用户自定义完整性约束。\r\nCREATE TABLE employees (    age INT CHECK (age &gt;= 18 AND age &lt;= 65),    email VARCHAR(100) CHECK (email LIKE &#x27;%@%.%&#x27;));\r\n为列设置默认值，当插入数据时如果没有指定该列的值，数据库将自动使用默认值。\r\nENUM 类型\r\nCREATE TABLE orders (    status ENUM(&#x27;pending&#x27;, &#x27;processing&#x27;, &#x27;shipped&#x27;, &#x27;delivered&#x27;) DEFAULT &#x27;pending&#x27;);\r\n\r\n作用：用于确保表中列（属性）取值有效性和正确性的一种机制\r\n唯一约束（UNIQUE）\r\n\r\n作用：确保列中的值唯一，但允许 NULL\r\n值。\r\n特点：\r\n\r\n一个表可以有多个唯一约束。\r\n唯一约束可以作用于单列或多列（复合唯一约束）。\r\n\r\n\r\n与主键的区别\r\n\r\n\r\n\r\n特性\r\n主键约束\r\n唯一约束\r\n\r\n\r\n\r\n\r\nNULL值\r\n不允许\r\n允许（但只能有一个NULL）\r\n\r\n\r\n数量\r\n每表一个\r\n每表多个\r\n\r\n\r\n索引类型\r\n聚集索引\r\n非聚集索引\r\n\r\n\r\n\r\nCREATE TABLE users (    email VARCHAR(100) UNIQUE,  -- 单列唯一约束    username VARCHAR(50),    CONSTRAINT uc_username_email UNIQUE (username, email)  -- 复合唯一约束);\r\n非空约束（NOT NULL）**\r\n\r\n作用：确保列中的值不能为 NULL。\r\n特点：\r\n\r\n非空约束只能作用于单列。\r\n\r\n\r\n-- 创建表时指定CREATE TABLE customers (    name VARCHAR(100) NOT NULL,    phone VARCHAR(20) NOT NULL);-- 修改现有列ALTER TABLE customers MODIFY COLUMN email VARCHAR(100) NOT NULL;-- 配合DEFAULT使用CREATE TABLE orders (    order_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP);\r\n默认约束（DEFAULT）\r\n\r\n作用：为列设置默认值，当插入数据时未指定该列的值时，使用默认值。\r\n特点：\r\n\r\n默认值可以是常量、表达式或函数。\r\n\r\n\r\n常用默认值：\r\nCREATE TABLE logs (    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,    status VARCHAR(20) DEFAULT &#x27;active&#x27;,    counter INT DEFAULT 0);\r\n动态默认值：\r\n-- 使用函数作为默认值CREATE TABLE documents (    doc_number VARCHAR(50) DEFAULT CONCAT(&#x27;DOC-&#x27;, UUID()),    created_date DATE DEFAULT CURDATE());\r\n外键约束（FOREIGN\r\nKEY）\r\n\r\n作用：确保表之间的引用完整性，用于关联两个表。\r\n规则：设F是关系R的外键，则R中任意元组的F属性值必须满足：F\r\n为空或F不为空，其值必须在 S 中存在\r\n特点：\r\n\r\n外键列的值必须存在于被引用表的主键或唯一键中。\r\n外键可以为 NULL。\r\n\r\n\r\n完整语法\r\nCREATE TABLE child_table (    id INT PRIMARY KEY,    parent_id INT,    FOREIGN KEY (parent_id)         REFERENCES parent_table(id)        ON DELETE action_type        ON UPDATE action_type);\r\n检查约束（CHECK）\r\n\r\n作用：确保列中的值满足指定条件。\r\n特点：\r\n\r\nMySQL 8.0.16 及以上版本支持 CHECK 约束。\r\n条件可以是逻辑表达式。\r\n\r\n\r\nCREATE TABLE employees (    salary DECIMAL(10,2) CHECK (salary &gt; 0),    hire_date DATE CHECK (hire_date &gt;= &#x27;2000-01-01&#x27;),    department VARCHAR(50),    CONSTRAINT chk_dept CHECK (department IN (&#x27;IT&#x27;, &#x27;HR&#x27;, &#x27;Finance&#x27;)));-- 表级检查约束ALTER TABLE products ADD CONSTRAINT chk_price CHECK (price &gt; cost * 1.2);\r\n动递增约束（AUTO_INCREMENT）\r\n\r\n作用：自动为列生成唯一的递增值，通常用于主键列。\r\n特点：\r\n\r\n只能用于整数类型的列。\r\n每个表只能有一个 AUTO_INCREMENT\r\n列。\r\n\r\n\r\n复合约束\r\n\r\n作用：将多个列组合在一起作为约束条件。\r\n常见类型：\r\n\r\n复合主键：多个列共同作为主键。\r\n复合唯一约束：多个列共同确保唯一性。\r\n\r\n\r\nCREATE TABLE orders(    order_id INT,    product_id INT,    PRIMARY KEY (order_id, product_id));\r\n约束操作\r\n约束的添加\r\nALTER TABLE 表名 ADD CONSTRAINT 约束名 约束类型 (列名);\r\n约束的删除\r\nALTER TABLE 表名 DROP CONSTRAINT 约束名;\r\n约束的命名\r\nCREATE TABLE 表名 (    列名 数据类型,    CONSTRAINT 约束名 约束类型 (列名));\r\n查看约束\r\n-- 从information_schema.TABLE_CONSTRAINTS系统表中获取信息-- TABLE_SCHEMA用于指定数据库名，需替换为实际的数据库名称-- TABLE_NAME用于指定表名，需替换为实际的表名称SELECT * FROM information_schema.TABLE_CONSTRAINTSWHERE TABLE_SCHEMA = &#x27;your_db&#x27; AND TABLE_NAME = &#x27;your_table&#x27;;\r\n修改约束\r\n-- 修改检查约束（MySQL中需要先删除再添加）ALTER TABLE employees DROP CHECK chk_salary;ALTER TABLE employees ADD CONSTRAINT chk_salary CHECK (salary &gt; 0);\r\n约束演示\r\n-- 约束建表CREATE TABLE Bin_user(    id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,   -- 多个约束空格分开    name VARCHAR(10) NOT NULL UNIQUE COMMENT &#x27;姓名&#x27;,    age INT CHECK ( age &gt;= 0 AND age &lt;= 120 ) COMMENT &#x27;年龄&#x27;,    status CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;状态&#x27;,    gender CHAR(1)  COMMENT &#x27;性别&#x27;)COMMENT &#x27;用户表&#x27;;-- 主键约束的自动增长INSERT INTO Bin_user (name, age, status, gender) VALUES (&#x27;Tom1&#x27;, 18, &#x27;1&#x27;, &#x27;M&#x27;), (&#x27;SJD&#x27;, 23, &#x27;1&#x27;, &#x27;W&#x27;);-- name的非空约束INSERT INTO Bin_user (name, age, status, gender) VALUES (NULL, 18, &#x27;1&#x27;, &#x27;M&#x27;);-- name的唯一约束INSERT INTO Bin_user (name, age, status, gender) VALUES (&#x27;Tom1&#x27;, 18, &#x27;1&#x27;, &#x27;M&#x27;);-- age的检查约束INSERT INTO Bin_user (name, age, status, gender) VALUES (&#x27;Tom1&#x27;, -18, &#x27;1&#x27;, &#x27;M&#x27;);-- status的默认约束INSERT INTO Bin_user (name, age, gender) VALUES (&#x27;Tom1&#x27;, 18, &#x27;M&#x27;);\r\n外键约束\r\n添加外键\r\nCREATE TABLE 表名(\t字段名 数据类型，    。。。    [CONSTRAIN] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名))\r\n示例\r\nCREATE TABLE customers (    id INT AUTO_INCREMENT PRIMARY KEY, -- 客户ID，主键    name VARCHAR(100) NOT NULL,        -- 客户姓名    email VARCHAR(100) UNIQUE          -- 客户邮箱，唯一);CREATE TABLE orders (    order_id INT AUTO_INCREMENT PRIMARY KEY, -- 订单ID，主键    order_date DATE NOT NULL,               -- 订单日期    amount DECIMAL(10, 2) NOT NULL,         -- 订单金额    customer_id INT,                        -- 客户ID，外键    FOREIGN KEY (customer_id) REFERENCES customers(id) -- 外键约束);INSERT INTO customers (name, email) VALUES(&#x27;张三&#x27;, &#x27;zhangsan@example.com&#x27;),(&#x27;李四&#x27;, &#x27;lisi@example.com&#x27;);INSERT INTO orders (order_date, amount, customer_id) VALUES(&#x27;2023-10-01&#x27;, 100.50, 1), -- 订单属于客户ID为1的张三(&#x27;2023-10-02&#x27;, 200.75, 2); -- 订单属于客户ID为2的李四-- 测试外键约束INSERT INTO orders (order_date, amount, customer_id) VALUES(&#x27;2023-10-03&#x27;, 150.00, 99); -- 99 不存在于 customers 表中DELETE FROM customers WHERE id = 1;   -- 尝试删除 customers 表中被 orders 表引用的数据\r\n外键约束的级联操作\r\n可以通过 ON DELETE 和 ON UPDATE\r\n子句定义外键的级联行为。例如：\r\n\r\nON DELETE CASCADE：当主表中的记录被删除时，自动删除从表中的相关记录。\r\nON UPDATE CASCADE：当主表中的记录被更新时，自动更新从表中的相关记录。\r\n\r\n示例：使用\r\nON DELETE CASCADE\r\nCREATE TABLE orders (    order_id INT AUTO_INCREMENT PRIMARY KEY,    order_date DATE NOT NULL,    amount DECIMAL(10, 2) NOT NULL,    customer_id INT,    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE);\r\n测试：\r\n\r\n删除 customers 表中的一条记录：\r\nDELETE FROM customers WHERE id = 1;\r\n检查 orders 表：\r\nSELECT * FROM orders;\r\n结果：customer_id 为 1\r\n的订单也会被自动删除。\r\n\r\n外键约束的删除和更新行为\r\n\r\nNO ACTION：\r\n父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则不允许删除/更新\r\nRESTRICT\r\n：父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则不允许删除/更新\r\nNO\r\nACTION/RESTRICT（默认）会阻止执行会破坏引用完整性的操作\r\nCASCADE\r\n父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则也删除/更新外键在子表中的记录\r\nSET BULL\r\n父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则设置子表中该外键值为null（外键允许null）\r\nSET DEFAULT\r\n：父表变更的时候，子表将外键设置成一个默认的值\r\nNO ACTION和RESTRICT是默认的\r\n\r\n如何设置\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE；\r\n约束实践\r\n学校管理系统约束\r\n\r\nstudents\r\n表：用于存储学生的基本信息，如学生编号、姓名、出生日期、所属专业编号等。学校可以通过该表管理学生档案，了解学生基本情况。\r\ncourses\r\n表：用于记录课程相关信息，包括课程代码、课程名称、学分、所属系部编号等。学校利用此表进行课程管理，如排课、课程信息维护等。\r\nenrollments\r\n表：用于记录学生的选课情况，包括选课记录编号、学生编号、课程代码、学期、成绩等。通过该表可以了解学生的选课动态，统计课程选修人数，核算学生成绩等。\r\n\r\nmysql语句：\r\nCREATE TABLE students (    student_id CHAR(10) PRIMARY KEY CHECK (student_id REGEXP &#x27;^[A-Z]&#123;2&#125;[0-9]&#123;8&#125;$&#x27;),    name VARCHAR(100) NOT NULL,    birth_date DATE NOT NULL CHECK (birth_date &lt;= DATE_SUB(CURRENT_DATE, INTERVAL 16 YEAR)),    major_id INT,    FOREIGN KEY (major_id) REFERENCES majors(major_id));\r\n\r\nstudent_id 列：数据类型为\r\nCHAR(10) ，作为学生的唯一标识。设置为主键，同时通过\r\nCHECK 约束确保其值符合正则表达式\r\n^[A-Z]&#123;2&#125;[0-9]&#123;8&#125;$ ，即学生编号必须是 2\r\n个大写字母开头，后面跟着 8 位数字。\r\nname 列：数据类型为\r\nVARCHAR(100) ，用于存储学生姓名，NOT NULL\r\n约束表示该字段不能为空。\r\nbirth_date 列：数据类型为\r\nDATE ，用于记录学生出生日期，NOT NULL\r\n约束要求不能为空。CHECK\r\n约束限定出生日期必须是当前日期往前推至少 16\r\n年以前，确保录入的出生日期符合正常入学年龄逻辑。\r\nmajor_id 列：数据类型为\r\nINT ，用于存储学生所属专业的编号。通过\r\nFOREIGN KEY 约束引用 majors 表中的\r\nmajor_id\r\n，建立与专业表的关联关系，保证学生所属专业编号在专业表中存在。\r\n\r\nCREATE TABLE courses (    course_code VARCHAR(10) PRIMARY KEY,    title VARCHAR(100) NOT NULL,    credit TINYINT NOT NULL CHECK (credit BETWEEN 1 AND 5),    department_id INT NOT NULL,    FOREIGN KEY (department_id) REFERENCES departments(department_id));\r\n\r\ncourse_code 列：数据类型为\r\nVARCHAR(10) ，作为课程的唯一标识，设置为主键。\r\ntitle 列：数据类型为\r\nVARCHAR(100) ，用于存储课程名称，NOT NULL\r\n约束表示不能为空。\r\ncredit 列：数据类型为\r\nTINYINT ，用于记录课程学分，NOT NULL\r\n约束要求不能为空。CHECK 约束限定学分在 1 到 5\r\n之间，符合常见课程学分设置范围。\r\ndepartment_id 列：数据类型为\r\nINT ，用于存储课程所属系部的编号，NOT NULL\r\n约束表示不能为空。通过 FOREIGN KEY 约束引用\r\ndepartments 表中的 department_id\r\n，建立与系部表的关联，保证课程所属系部编号在系部表中存在。\r\n\r\nCREATE TABLE enrollments (    enrollment_id INT AUTO_INCREMENT PRIMARY KEY,    student_id CHAR(10) NOT NULL,    course_code VARCHAR(10) NOT NULL,    semester VARCHAR(20) NOT NULL,    grade CHAR(2) CHECK (grade IN (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;F&#x27;, NULL)),    UNIQUE KEY (student_id, course_code, semester),    FOREIGN KEY (student_id) REFERENCES students(student_id),    FOREIGN KEY (course_code) REFERENCES courses(course_code));\r\n\r\nenrollment_id 列：数据类型为\r\nINT\r\n，设置为自增长（AUTO_INCREMENT），作为选课记录的唯一标识，是该表的主键。\r\nstudent_id 列：数据类型为\r\nCHAR(10) ，用于记录选课学生的编号，NOT NULL\r\n约束表示不能为空。通过 FOREIGN KEY 约束引用\r\nstudents 表中的 student_id\r\n，确保选课学生编号在学生表中存在。\r\ncourse_code 列：数据类型为\r\nVARCHAR(10) ，用于记录所选课程的代码，NOT NULL\r\n约束表示不能为空。通过 FOREIGN KEY 约束引用\r\ncourses 表中的 course_code\r\n，保证所选课程代码在课程表中存在。\r\nsemester 列：数据类型为\r\nVARCHAR(20) ，用于记录选课的学期，NOT NULL\r\n约束表示不能为空。\r\ngrade 列：数据类型为\r\nCHAR(2) ，用于记录学生该课程的成绩。CHECK\r\n约束限定成绩只能是\r\n'A'、'B'、'C'、'D'、'F'\r\n或空值，符合常见成绩记录规则。\r\nUNIQUE KEY (student_id, course_code, semester)：组合唯一键约束，确保每个学生在每个学期对每门课程的选课记录唯一，防止重复选课记录出现。\r\n\r\n","categories":["学习类","数据库","MySql","MySql基础"],"tags":["实用知识","常用知识","数据库","MySql","语言基础"]},{"title":"MySql的数据类型","url":"/posts/33441.html","content":"MySQL数据类型\r\nMySQL\r\n支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。\r\nMySQL 支持所有标准 SQL 数值数据类型。\r\n这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和\r\nNUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。\r\n关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。\r\nBIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和\r\nBDB表。\r\n数值和数据类型\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n大小\r\n范围（有符号）\r\n范围（无符号）\r\n用途\r\n\r\n\r\n\r\n\r\nTINYINT\r\n1 Bytes\r\n(-128，127)\r\n(0，255)\r\n小整数值\r\n\r\n\r\nSMALLINT\r\n2 Bytes\r\n(-32 768，32 767)\r\n(0，65 535)\r\n大整数值\r\n\r\n\r\nMEDIUMINT\r\n3 Bytes\r\n(-8 388 608，8 388 607)\r\n(0，16 777 215)\r\n大整数值\r\n\r\n\r\nINT或INTEGER\r\n4 Bytes\r\n(-2 147 483 648，2 147 483 647)\r\n(0，4 294 967 295)\r\n大整数值\r\n\r\n\r\nBIGINT\r\n8 Bytes\r\n(-9,223,372,036,854,775,808（-(2^63)），9 223 372 036 854 775\r\n807（(2^63)-1）)\r\n(0，18 446 744 073 709 551 615)\r\n极大整数值\r\n\r\n\r\nFLOAT\r\n4 Bytes\r\n(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351\r\nE-38，3.402 823 466 351 E+38)\r\n0，(1.175 494 351 E-38，3.402 823 466 E+38)\r\n单精度 浮点数值\r\n\r\n\r\nDOUBLE\r\n8 Bytes\r\n(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4\r\nE-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7\r\nE+308)\r\n0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7\r\nE+308)\r\n双精度 浮点数值\r\n\r\n\r\nDECIMAL 定点类型\r\n对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2\r\n依赖于M和D的值，M：总位数，D：小数位数\r\n依赖于M和D的值\r\n小数值\r\n\r\n\r\n\r\n整数类型\r\nMySQL 支持 SQL 标准整数类型\r\nINTEGER（或INT）和 SMALLINT.\r\n作为标准的扩展，MySQL 还支持整数类型\r\nTINYINT、MEDIUMINT和 BIGINT。\r\nMySQL 支持的整数类型所需的存储和范围\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n存储（字节）\r\n有符号最小值\r\n最小值无符号\r\n有符号最大值\r\n最大值无符号（UNSIGNED）\r\n\r\n\r\n\r\n\r\nTINYINT\r\n1个\r\n-128\r\n0\r\n127\r\n255\r\n\r\n\r\nSMALLINT\r\n2个\r\n-32768\r\n0\r\n32767\r\n65535\r\n\r\n\r\nMEDIUMINT\r\n3个\r\n-8388608\r\n0\r\n8388607\r\n16777215\r\n\r\n\r\nINT\r\n4个\r\n-2147483648\r\n0\r\n2147483647\r\n4294967295\r\n\r\n\r\nBIGINT\r\n8个\r\n-2^63\r\n0\r\n2^63-1\r\n2^64-1\r\n\r\n\r\n\r\n定点类型\r\nDECIMAL和NUMERIC 类型存储精确的数字数据值\r\n。当保持精确的精度很重要时使用这些类型\r\n在DECIMAL列声明中，可以（并且通常）指定精度和小数位数。例如：\r\nsalary DECIMAL(5,2)\r\n在此示例中，5是精度，2是标度。精度表示为值存储的有效位数，标度表示小数点后可以存储的位数。\r\n如果小数位数为\r\n0，则DECIMAL值不包含小数点或小数部分。\r\n浮点类型（近似值）\r\nFLOAT DOUBLE——MySQL\r\n对单精度值使用四个字节，对双精度值使用八个字节。\r\nBIT——比特值类型\r\nBIT数据类型用于存储位值。一种允许存储-bit\r\n值的类型。范围从 1 到 64。\r\n如果您将值分配给长度小于位的列，则该值将在左侧填充零。例如，为列分配一个值实际上与分配\r\n.\r\nBIT(*M*)Mb'101'``BIT(6)``b'000101'\r\n日期和时间类型\r\n表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。\r\n每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。\r\n常用的日期有如下三个：\r\n\r\ndate :日期 ‘yyyy-mm-dd’ ，占用三字节。\r\ndatetime 时间日期格式 ‘yyyy-mm-dd HH:ii:ss’ 表示范围从 1000 到 9999\r\n，占用八字节。\r\ntimestamp ：时间戳，从1970年开始的 yyyy-mm-dd HH:ii:ss 格式和\r\ndatetime 完全一致，占用四字节。 表示现在的时间。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n大小 ( bytes)\r\n范围\r\n格式\r\n用途\r\n\r\n\r\n\r\n\r\nDATE\r\n3\r\n1000-01-01/9999-12-31\r\nYYYY-MM-DD\r\n日期值\r\n\r\n\r\nTIME\r\n3\r\n‘-838:59:59’/‘838:59:59’\r\nHH:MM:SS\r\n时间值或持续时间\r\n\r\n\r\nYEAR\r\n1\r\n1901/2155\r\nYYYY\r\n年份值\r\n\r\n\r\nDATETIME\r\n8\r\n‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’\r\nYYYY-MM-DD hh:mm:ss\r\n混合日期和时间值\r\n\r\n\r\nTIMESTAMP\r\n4\r\n‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC 结束时间是第\r\n2147483647 秒，北京时间 2038-1-19\r\n11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07\r\nYYYY-MM-DD hh:mm:ss\r\n混合日期和时间值，时间戳\r\n\r\n\r\n\r\n字符串类型\r\n字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。\r\n\r\n\r\n\r\n类型\r\n大小\r\n用途\r\n\r\n\r\n\r\n\r\nCHAR\r\n0-255 bytes\r\n定长字符串\r\n\r\n\r\nVARCHAR\r\n0-65535 bytes\r\n变长字符串\r\n\r\n\r\nTINYBLOB\r\n0-255 bytes\r\n不超过 255 个字符的二进制字符串\r\n\r\n\r\nTINYTEXT\r\n0-255 bytes\r\n短文本字符串\r\n\r\n\r\nBLOB\r\n0-65 535 bytes\r\n二进制形式的长文本数据\r\n\r\n\r\nTEXT\r\n0-65 535 bytes\r\n长文本数据\r\n\r\n\r\nMEDIUMBLOB\r\n0-16 777 215 bytes\r\n二进制形式的中等长度文本数据\r\n\r\n\r\nMEDIUMTEXT\r\n0-16 777 215 bytes\r\n中等长度文本数据\r\n\r\n\r\nLONGBLOB\r\n0-4 294 967 295 bytes\r\n二进制形式的极大文本数据\r\n\r\n\r\nLONGTEXT\r\n0-4 294 967 295 bytes\r\n极大文本数据\r\n\r\n\r\n\r\nchar(n) 和 varchar(n) 中括号中 n\r\n代表字符的个数，一个定长一个不定长。\r\nvarchar长度可以指定为0到65535之间的值，但是有1 - 3\r\n个字节用于记录数据大小，所以说有效字节数是65532。\r\n当我们的表的编码是utf8时，varchar(n)的参数n最大值是65532/3=21844，（因为utf中，一个字符占用3个字节），如果编码是gbk，varchar(n)的参数n最大是65532/2=32766（因为gbk中，一个字符占用2字节）。\r\n\r\n\r\nimage-20250318083228988\r\n\r\nCHAR 和 VARCHAR\r\n类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。\r\n枚举与集合类型（Enumeration\r\nand Set Types）\r\nENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。\r\nenum(&#39;选项1&#39;,&#39;选项2&#39;,&#39;选项3&#39;,...);\r\n  该设定只是提供了若干个选项的值，最终一个单元格中，实际只存储了其中一个值；而且出于效率考虑，这些值实际存储的是“数字”，因为这些选项的每个选项值依次对应如下数字：1,2,3,…最多65535个；当我们添加枚举值时，也可以添加对应的数字编号。\r\nSET: 集合类型，用于存储多个值，可以选择多个预定义的集合。\r\nset(&#39;选项值1&#39;,&#39;选项值2&#39;,&#39;选项值3&#39;, ...);\r\n  该设定只是提供了若干个选项的值，最终一个单元格中，设计可存储了其中任意多个值；而且出于效率考虑，这些值实际存储的是“数字”，因为这些选项的每个选项值依次对应如下数字：1,2,4,8,16,32，…最多64个。\r\n\r\n空间数据类型（Spatial Data\r\nTypes）\r\nGEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING,\r\nMULTIPOLYGON, GEOMETRYCOLLECTION:\r\n用于存储空间数据（地理信息、几何图形等）。\r\n","categories":["学习类","数据库","MySql","MySql基础"],"tags":["实用知识","常用知识","数据库","MySql","语言基础"]},{"title":"MATLAB part6-向量和矩阵","url":"/posts/42454.html","content":"\r\nMATLAB 向量和矩阵基础\r\n向量和矩阵是MATLAB的核心数据结构，MATLAB的名称就来源于”Matrix\r\nLaboratory”（矩阵实验室）。理解向量和矩阵的操作是掌握MATLAB的关键基础。\r\nMATLAB中的所有数据都以矩阵形式存储：\r\n\r\n标量：1×1的矩阵\r\n行向量：1×n的矩阵\r\n列向量：n×1的矩阵\r\n矩阵：m×n的矩阵\r\n高维数组：多维矩阵\r\n\r\nMATLAB提供了丰富的函数来创建、操作和分析向量和矩阵，这些功能使得复杂的数学运算变得简单直观。\r\n向量的创建和基本操作\r\n向量创建方法\r\n向量是一维数组，在MATLAB中可以是行向量或列向量。创建向量有多种方法，每种方法适用于不同的场景。\r\n% ===== 向量创建方法示例 =====% 方法1：直接输入（行向量）row_vector = [1, 2, 3, 4, 5];fprintf(&#x27;行向量：&#x27;);disp(row_vector);% 方法2：分号分隔创建列向量col_vector = [1; 2; 3; 4; 5];fprintf(&#x27;列向量：\\n&#x27;);disp(col_vector);% 方法3：使用冒号操作符创建等差序列sequence1 = 1:5;        % 步长为1，从1到5sequence2 = 0:0.5:3;    % 步长为0.5，从0到3sequence3 = 10:-2:0;    % 步长为-2，从10到0（递减）fprintf(&#x27;等差序列1：&#x27;); disp(sequence1);fprintf(&#x27;等差序列2：&#x27;); disp(sequence2);fprintf(&#x27;等差序列3：&#x27;); disp(sequence3);% 方法4：使用linspace创建线性等分向量linear_space = linspace(0, 10, 11);  % 从0到10，等分为11个点fprintf(&#x27;线性等分向量：&#x27;); disp(linear_space);% 方法5：使用logspace创建对数等分向量log_space = logspace(0, 2, 5);  % 从10^0到10^2，等分为5个点fprintf(&#x27;对数等分向量：&#x27;); disp(log_space);% 方法6：使用专用函数创建特殊向量zeros_vec = zeros(1, 5);        % 零向量ones_vec = ones(1, 5);          % 单位向量random_vec = rand(1, 5);        % 随机向量normal_vec = randn(1, 5);       % 正态分布随机向量fprintf(&#x27;零向量：&#x27;); disp(zeros_vec);fprintf(&#x27;单位向量：&#x27;); disp(ones_vec);fprintf(&#x27;随机向量：&#x27;); disp(random_vec);fprintf(&#x27;正态分布向量：&#x27;); disp(normal_vec);\r\n向量基本属性和操作\r\n% ===== 向量基本属性示例 =====% 创建示例向量data_vector = [2, 5, 1, 8, 3, 9, 4, 7, 6];% 基本属性fprintf(&#x27;向量长度：%d\\n&#x27;, length(data_vector));fprintf(&#x27;向量大小：%dx%d\\n&#x27;, size(data_vector, 1), size(data_vector, 2));fprintf(&#x27;元素总数：%d\\n&#x27;, numel(data_vector));% 向量统计信息fprintf(&#x27;最大值：%.2f\\n&#x27;, max(data_vector));fprintf(&#x27;最小值：%.2f\\n&#x27;, min(data_vector));fprintf(&#x27;平均值：%.2f\\n&#x27;, mean(data_vector));fprintf(&#x27;中位数：%.2f\\n&#x27;, median(data_vector));fprintf(&#x27;标准差：%.2f\\n&#x27;, std(data_vector));fprintf(&#x27;方差：%.2f\\n&#x27;, var(data_vector));fprintf(&#x27;总和：%.2f\\n&#x27;, sum(data_vector));fprintf(&#x27;乘积：%.2f\\n&#x27;, prod(data_vector));% 查找操作[max_val, max_idx] = max(data_vector);[min_val, min_idx] = min(data_vector);fprintf(&#x27;最大值 %.2f 位于索引 %d\\n&#x27;, max_val, max_idx);fprintf(&#x27;最小值 %.2f 位于索引 %d\\n&#x27;, min_val, min_idx);% 查找特定条件的元素greater_than_5 = find(data_vector &gt; 5);fprintf(&#x27;大于5的元素索引：&#x27;); disp(greater_than_5);fprintf(&#x27;大于5的元素值：&#x27;); disp(data_vector(greater_than_5));\r\n向量索引和切片\r\n% ===== 向量索引和切片示例 =====% 创建测试向量test_vector = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];% 基本索引fprintf(&#x27;第3个元素：%d\\n&#x27;, test_vector(3));fprintf(&#x27;最后一个元素：%d\\n&#x27;, test_vector(end));fprintf(&#x27;倒数第二个元素：%d\\n&#x27;, test_vector(end-1));% 多个索引selected_elements = test_vector([1, 3, 5, 7]);fprintf(&#x27;选中的元素：&#x27;); disp(selected_elements);% 范围索引（切片）slice1 = test_vector(2:5);      % 第2到第5个元素slice2 = test_vector(1:2:end);  % 每隔一个元素取一个slice3 = test_vector(end:-1:1); % 反向所有元素fprintf(&#x27;切片1（2到5）：&#x27;); disp(slice1);fprintf(&#x27;切片2（步长为2）：&#x27;); disp(slice2);fprintf(&#x27;切片3（反向）：&#x27;); disp(slice3);% 逻辑索引logical_mask = test_vector &gt; 50;filtered_elements = test_vector(logical_mask);fprintf(&#x27;大于50的元素：&#x27;); disp(filtered_elements);% 修改元素modified_vector = test_vector;modified_vector(3) = 999;       % 修改单个元素modified_vector(1:3) = 0;       % 修改多个元素fprintf(&#x27;修改后的向量：&#x27;); disp(modified_vector);\r\n矩阵的创建和基本操作\r\n矩阵创建方法\r\n矩阵是二维数组，MATLAB提供了多种创建矩阵的方法。\r\n% ===== 矩阵创建方法示例 =====% 方法1：直接输入matrix1 = [1, 2, 3; 4, 5, 6; 7, 8, 9];fprintf(&#x27;直接输入矩阵：\\n&#x27;);disp(matrix1);% 方法2：使用分号分隔行matrix2 = [1, 2, 3           4, 5, 6           7, 8, 9];fprintf(&#x27;多行输入矩阵：\\n&#x27;);disp(matrix2);% 方法3：使用专用函数创建特殊矩阵zeros_matrix = zeros(3, 4);         % 零矩阵ones_matrix = ones(3, 4);           % 全1矩阵eye_matrix = eye(4);                % 单位矩阵diag_matrix = diag([1, 2, 3, 4]);   % 对角矩阵rand_matrix = rand(3, 4);           % 随机矩阵randn_matrix = randn(3, 4);         % 正态分布随机矩阵fprintf(&#x27;零矩阵：\\n&#x27;); disp(zeros_matrix);fprintf(&#x27;全1矩阵：\\n&#x27;); disp(ones_matrix);fprintf(&#x27;单位矩阵：\\n&#x27;); disp(eye_matrix);fprintf(&#x27;对角矩阵：\\n&#x27;); disp(diag_matrix);fprintf(&#x27;随机矩阵：\\n&#x27;); disp(rand_matrix);% 方法4：从向量创建矩阵vector_data = 1:12;reshaped_matrix = reshape(vector_data, 3, 4);  % 重新整形为3x4矩阵fprintf(&#x27;重新整形的矩阵：\\n&#x27;);disp(reshaped_matrix);% 方法5：矩阵拼接A = [1, 2; 3, 4];B = [5, 6; 7, 8];horizontal_concat = [A, B];  % 水平拼接vertical_concat = [A; B];    % 垂直拼接fprintf(&#x27;水平拼接：\\n&#x27;); disp(horizontal_concat);fprintf(&#x27;垂直拼接：\\n&#x27;); disp(vertical_concat);\r\n矩阵基本属性\r\n% ===== 矩阵基本属性示例 =====% 创建示例矩阵sample_matrix = [1, 4, 7, 2;                  8, 3, 6, 9;                  5, 1, 4, 3];% 基本属性[rows, cols] = size(sample_matrix);fprintf(&#x27;矩阵大小：%d x %d\\n&#x27;, rows, cols);fprintf(&#x27;总元素数：%d\\n&#x27;, numel(sample_matrix));% 矩阵维度信息fprintf(&#x27;行数：%d\\n&#x27;, size(sample_matrix, 1));fprintf(&#x27;列数：%d\\n&#x27;, size(sample_matrix, 2));% 矩阵统计信息fprintf(&#x27;矩阵最大值：%.2f\\n&#x27;, max(sample_matrix(:)));fprintf(&#x27;矩阵最小值：%.2f\\n&#x27;, min(sample_matrix(:)));fprintf(&#x27;矩阵平均值：%.2f\\n&#x27;, mean(sample_matrix(:)));fprintf(&#x27;矩阵总和：%.2f\\n&#x27;, sum(sample_matrix(:)));% 按行列统计row_sums = sum(sample_matrix, 2);     % 每行的和col_sums = sum(sample_matrix, 1);     % 每列的和row_means = mean(sample_matrix, 2);   % 每行的平均值col_means = mean(sample_matrix, 1);   % 每列的平均值fprintf(&#x27;每行的和：&#x27;); disp(row_sums&#x27;);fprintf(&#x27;每列的和：&#x27;); disp(col_sums);fprintf(&#x27;每行的平均值：&#x27;); disp(row_means&#x27;);fprintf(&#x27;每列的平均值：&#x27;); disp(col_means);\r\n矩阵索引和切片\r\n% ===== 矩阵索引和切片示例 =====% 创建测试矩阵test_matrix = [11, 12, 13, 14, 15;               21, 22, 23, 24, 25;               31, 32, 33, 34, 35;               41, 42, 43, 44, 45];fprintf(&#x27;原始矩阵：\\n&#x27;);disp(test_matrix);% 单个元素索引element = test_matrix(2, 3);  % 第2行第3列fprintf(&#x27;第2行第3列的元素：%d\\n&#x27;, element);% 整行或整列row2 = test_matrix(2, :);     % 第2行所有元素col3 = test_matrix(:, 3);     % 第3列所有元素fprintf(&#x27;第2行：&#x27;); disp(row2);fprintf(&#x27;第3列：&#x27;); disp(col3&#x27;);% 子矩阵提取submatrix1 = test_matrix(1:2, 2:4);    % 前两行，第2到4列submatrix2 = test_matrix([1,3], [2,4,5]); % 第1、3行，第2、4、5列fprintf(&#x27;子矩阵1：\\n&#x27;); disp(submatrix1);fprintf(&#x27;子矩阵2：\\n&#x27;); disp(submatrix2);% 逻辑索引logical_matrix = test_matrix &gt; 25;elements_gt_25 = test_matrix(logical_matrix);fprintf(&#x27;大于25的元素：&#x27;); disp(elements_gt_25&#x27;);% 线性索引（将矩阵按列展开的索引）linear_idx = sub2ind(size(test_matrix), 2, 3);  % 转换为线性索引element_linear = test_matrix(linear_idx);fprintf(&#x27;线性索引%d对应的元素：%d\\n&#x27;, linear_idx, element_linear);% 修改矩阵元素modified_matrix = test_matrix;modified_matrix(2, 3) = 999;           % 修改单个元素modified_matrix(1, :) = 0;             % 修改整行modified_matrix(:, 5) = [100; 200; 300; 400];  % 修改整列fprintf(&#x27;修改后的矩阵：\\n&#x27;);disp(modified_matrix);\r\n向量和矩阵运算\r\n基本算术运算\r\nMATLAB支持两种类型的运算：矩阵运算和元素运算。\r\n% ===== 基本算术运算示例 =====% 创建示例矩阵A = [1, 2, 3; 4, 5, 6];B = [7, 8, 9; 10, 11, 12];C = [1, 2; 3, 4; 5, 6];fprintf(&#x27;矩阵A：\\n&#x27;); disp(A);fprintf(&#x27;矩阵B：\\n&#x27;); disp(B);fprintf(&#x27;矩阵C：\\n&#x27;); disp(C);% 矩阵加法和减法addition = A + B;subtraction = A - B;fprintf(&#x27;A + B：\\n&#x27;); disp(addition);fprintf(&#x27;A - B：\\n&#x27;); disp(subtraction);% 矩阵乘法（线性代数意义）matrix_mult = A * C;  % 2x3 × 3x2 = 2x2fprintf(&#x27;A * C（矩阵乘法）：\\n&#x27;); disp(matrix_mult);% 元素级运算（点运算）element_mult = A .* B;        % 对应元素相乘element_div = A ./ B;         % 对应元素相除element_power = A .^ 2;       % 每个元素平方fprintf(&#x27;A .* B（元素相乘）：\\n&#x27;); disp(element_mult);fprintf(&#x27;A ./ B（元素相除）：\\n&#x27;); disp(element_div);fprintf(&#x27;A .^ 2（元素平方）：\\n&#x27;); disp(element_power);% 标量运算scalar_mult = A * 3;          % 每个元素乘以3scalar_add = A + 10;          % 每个元素加10scalar_power = A .^ 0.5;      % 每个元素开平方fprintf(&#x27;A * 3：\\n&#x27;); disp(scalar_mult);fprintf(&#x27;A + 10：\\n&#x27;); disp(scalar_add);fprintf(&#x27;A .^ 0.5：\\n&#x27;); disp(scalar_power);\r\n矩阵函数运算\r\n% ===== 矩阵函数运算示例 =====% 创建示例数据angle_matrix = [0, pi/4, pi/2; pi, 3*pi/4, 2*pi];positive_matrix = [1, 4, 9; 16, 25, 36];% 三角函数sin_result = sin(angle_matrix);cos_result = cos(angle_matrix);tan_result = tan(angle_matrix);fprintf(&#x27;角度矩阵：\\n&#x27;); disp(angle_matrix);fprintf(&#x27;sin函数结果：\\n&#x27;); disp(sin_result);fprintf(&#x27;cos函数结果：\\n&#x27;); disp(cos_result);% 指数和对数函数exp_result = exp([1, 2, 3]);      % e的幂log_result = log(positive_matrix); % 自然对数log10_result = log10(positive_matrix); % 常用对数sqrt_result = sqrt(positive_matrix);   % 平方根fprintf(&#x27;指数函数结果：&#x27;); disp(exp_result);fprintf(&#x27;自然对数结果：\\n&#x27;); disp(log_result);fprintf(&#x27;平方根结果：\\n&#x27;); disp(sqrt_result);% 取整函数decimal_matrix = [1.2, 2.7, -1.3; -2.8, 3.1, 4.9];floor_result = floor(decimal_matrix);  % 向下取整ceil_result = ceil(decimal_matrix);    % 向上取整round_result = round(decimal_matrix);  % 四舍五入fix_result = fix(decimal_matrix);      % 向零取整fprintf(&#x27;原始矩阵：\\n&#x27;); disp(decimal_matrix);fprintf(&#x27;向下取整：\\n&#x27;); disp(floor_result);fprintf(&#x27;向上取整：\\n&#x27;); disp(ceil_result);fprintf(&#x27;四舍五入：\\n&#x27;); disp(round_result);fprintf(&#x27;向零取整：\\n&#x27;); disp(fix_result);\r\n线性代数运算\r\n% ===== 线性代数运算示例 =====% 创建方阵进行线性代数运算square_matrix = [4, 2, 1; 2, 5, 3; 1, 3, 6];vector_b = [1; 2; 3];fprintf(&#x27;方阵A：\\n&#x27;); disp(square_matrix);fprintf(&#x27;向量b：\\n&#x27;); disp(vector_b);% 矩阵转置transpose_A = square_matrix&#x27;;fprintf(&#x27;A的转置：\\n&#x27;); disp(transpose_A);% 矩阵行列式det_A = det(square_matrix);fprintf(&#x27;A的行列式：%.4f\\n&#x27;, det_A);% 矩阵的逆if det_A ~= 0    inv_A = inv(square_matrix);    fprintf(&#x27;A的逆矩阵：\\n&#x27;); disp(inv_A);        % 验证逆矩阵    identity_check = square_matrix * inv_A;    fprintf(&#x27;A * inv(A)（应为单位矩阵）：\\n&#x27;); disp(identity_check);end% 矩阵的秩rank_A = rank(square_matrix);fprintf(&#x27;A的秩：%d\\n&#x27;, rank_A);% 矩阵的迹（对角元素之和）trace_A = trace(square_matrix);fprintf(&#x27;A的迹：%.4f\\n&#x27;, trace_A);% 特征值和特征向量[eigenvectors, eigenvalues] = eig(square_matrix);fprintf(&#x27;特征值：\\n&#x27;); disp(diag(eigenvalues));fprintf(&#x27;特征向量：\\n&#x27;); disp(eigenvectors);% 解线性方程组 Ax = bsolution_x = square_matrix \\ vector_b;  % 等价于 inv(A) * bfprintf(&#x27;线性方程组的解：\\n&#x27;); disp(solution_x);% 验证解verification = square_matrix * solution_x;fprintf(&#x27;验证Ax（应等于b）：\\n&#x27;); disp(verification);\r\n高级矩阵操作\r\n矩阵分解\r\n矩阵分解是线性代数中的重要概念，在数值计算和数据分析中有广泛应用。\r\n% ===== 矩阵分解示例 =====% 创建测试矩阵A = [4, 2, 1; 2, 5, 3; 1, 3, 6];fprintf(&#x27;原始矩阵A：\\n&#x27;); disp(A);% LU分解[L, U, P] = lu(A);fprintf(&#x27;L矩阵（下三角）：\\n&#x27;); disp(L);fprintf(&#x27;U矩阵（上三角）：\\n&#x27;); disp(U);fprintf(&#x27;P矩阵（置换矩阵）：\\n&#x27;); disp(P);fprintf(&#x27;验证PA = LU：\\n&#x27;); disp(P*A - L*U);% Cholesky分解（适用于正定矩阵）if all(eig(A) &gt; 0)  % 检查是否为正定矩阵    R = chol(A);    fprintf(&#x27;Cholesky分解R：\\n&#x27;); disp(R);    fprintf(&#x27;验证A = R&#x27;&#x27;*R：\\n&#x27;); disp(A - R&#x27;*R);end% QR分解[Q, R] = qr(A);fprintf(&#x27;Q矩阵（正交矩阵）：\\n&#x27;); disp(Q);fprintf(&#x27;R矩阵（上三角矩阵）：\\n&#x27;); disp(R);fprintf(&#x27;验证A = Q*R：\\n&#x27;); disp(A - Q*R);% 奇异值分解（SVD）[U, S, V] = svd(A);fprintf(&#x27;U矩阵：\\n&#x27;); disp(U);fprintf(&#x27;S矩阵（奇异值）：\\n&#x27;); disp(S);fprintf(&#x27;V矩阵：\\n&#x27;); disp(V);fprintf(&#x27;验证A = U*S*V&#x27;&#x27;：\\n&#x27;); disp(A - U*S*V&#x27;);% 特征值分解[V_eig, D_eig] = eig(A);fprintf(&#x27;特征向量矩阵V：\\n&#x27;); disp(V_eig);fprintf(&#x27;特征值对角矩阵D：\\n&#x27;); disp(D_eig);fprintf(&#x27;验证A*V = V*D：\\n&#x27;); disp(A*V_eig - V_eig*D_eig);\r\n矩阵变换和操作\r\n% ===== 矩阵变换和操作示例 =====% 创建示例矩阵original_matrix = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];fprintf(&#x27;原始矩阵：\\n&#x27;); disp(original_matrix);% 矩阵重构reshaped = reshape(original_matrix, 2, 6);  % 重构为2x6fprintf(&#x27;重构为2x6：\\n&#x27;); disp(reshaped);% 矩阵旋转rotated_90 = rot90(original_matrix);        % 逆时针旋转90度rotated_180 = rot90(original_matrix, 2);    % 旋转180度fprintf(&#x27;旋转90度：\\n&#x27;); disp(rotated_90);fprintf(&#x27;旋转180度：\\n&#x27;); disp(rotated_180);% 矩阵翻转flipped_lr = fliplr(original_matrix);       % 左右翻转flipped_ud = flipud(original_matrix);       % 上下翻转fprintf(&#x27;左右翻转：\\n&#x27;); disp(flipped_lr);fprintf(&#x27;上下翻转：\\n&#x27;); disp(flipped_ud);% 矩阵排序unsorted_matrix = [3, 1, 4; 2, 5, 1; 6, 2, 3];sorted_each_col = sort(unsorted_matrix);        % 按列排序sorted_each_row = sort(unsorted_matrix, 2);     % 按行排序[sorted_vals, indices] = sort(unsorted_matrix(:)); % 全矩阵排序fprintf(&#x27;原始矩阵：\\n&#x27;); disp(unsorted_matrix);fprintf(&#x27;按列排序：\\n&#x27;); disp(sorted_each_col);fprintf(&#x27;按行排序：\\n&#x27;); disp(sorted_each_row);% 矩阵循环移位shifted_matrix = circshift(original_matrix, [1, 2]); % 向下1行，向右2列fprintf(&#x27;循环移位：\\n&#x27;); disp(shifted_matrix);% 矩阵块操作block_matrix = blkdiag([1,2; 3,4], [5,6; 7,8], 9); % 块对角矩阵fprintf(&#x27;块对角矩阵：\\n&#x27;); disp(block_matrix);\r\n稀疏矩阵\r\n对于大部分元素为零的矩阵，使用稀疏矩阵可以节省内存和提高计算效率。\r\n% ===== 稀疏矩阵示例 =====% 创建稀疏矩阵i = [1, 2, 3, 4, 5];           % 行索引j = [1, 3, 2, 4, 1];           % 列索引s = [10, 20, 30, 40, 50];      % 非零元素值sparse_matrix = sparse(i, j, s, 5, 5);fprintf(&#x27;稀疏矩阵：\\n&#x27;);disp(full(sparse_matrix));  % 转换为完整矩阵显示% 稀疏矩阵信息fprintf(&#x27;非零元素个数：%d\\n&#x27;, nnz(sparse_matrix));fprintf(&#x27;稀疏度：%.2f%%\\n&#x27;, (1 - nnz(sparse_matrix)/numel(sparse_matrix)) * 100);% 从完整矩阵创建稀疏矩阵full_matrix = [1, 0, 0, 4; 0, 2, 0, 0; 0, 0, 3, 0; 5, 0, 0, 6];sparse_from_full = sparse(full_matrix);fprintf(&#x27;从完整矩阵创建的稀疏矩阵：\\n&#x27;);disp(full(sparse_from_full));% 稀疏矩阵运算A_sparse = sparse([1,2,3], [1,2,3], [1,2,3], 3, 3);B_sparse = sparse([1,2,3], [3,2,1], [3,2,1], 3, 3);sum_sparse = A_sparse + B_sparse;mult_sparse = A_sparse * B_sparse;fprintf(&#x27;稀疏矩阵A：\\n&#x27;); disp(full(A_sparse));fprintf(&#x27;稀疏矩阵B：\\n&#x27;); disp(full(B_sparse));fprintf(&#x27;A + B：\\n&#x27;); disp(full(sum_sparse));fprintf(&#x27;A * B：\\n&#x27;); disp(full(mult_sparse));% 查找非零元素[rows, cols, vals] = find(sparse_matrix);fprintf(&#x27;非零元素位置和值：\\n&#x27;);for k = 1:length(vals)    fprintf(&#x27;(%d,%d) = %.1f\\n&#x27;, rows(k), cols(k), vals(k));end\r\n\r\n","categories":["数学类","MATLAB"],"tags":["语法知识","学习","语言方面","数学","物理","数学建模"]},{"title":"Python的推导式、迭代器和生成器","url":"/posts/9954.html","content":"Python推导式\r\n\r\n列表推导式: [expression for item in iterable]\r\n集合推导式: &#123;expression for item in iterable&#125;\r\n字典推导式:\r\n&#123;key_expression: value_expression for item in iterable&#125;\r\nitem是一个变量，用于遍历iterable中的元素\r\n\r\n#列表推导式：list_com = [x**2 for x in range(10) if x**2 &lt; 40]list_com# [0, 1, 4, 9, 16, 25, 36]#集合推导式 ,代表什么意思set_com = &#123;x**2 if x**2 % 2==0 else x**2 + 1 for x in range(10)&#125;set_com# &#123;0, 2, 4, 10, 16, 26, 36, 50, 64, 82&#125;#字典推导式dict_com = &#123;x: x**2 for x in range(10) if x != 3&#125;dict_com# &#123;0: 0, 1: 1, 2: 4, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125;\r\n推导式中添加if判断的语法：\r\n在 Python\r\n推导式中，if判断有两种用法，分别用于过滤元素和条件赋值\r\n\r\nif condition 用于过滤元素\r\n语法：[expression for item in iterable if condition]\r\n作用：只保留满足condition的元素，类似筛选\r\n# 生成偶数列表evens = [x for x in range(10) if x % 2 == 0]# 等价于：[0, 2, 4, 6, 8]\r\nif-else 表达式用于条件赋值\r\n语法：[expression if condition else expr_else for item in iterable]\r\n作用：根据condition的结果，为每个元素选择不同的表达式值。\r\n# 将负数转换为 0，正数保持不变：nums = [-1, 2, -3, 4]result = [x if x &gt;= 0 else 0 for x in nums]# 等价于：[0, 2, 0, 4]\r\n\r\n# `L = [&#x27;Hello&#x27;, &#x27;World&#x27;, 18, &#x27;Apple&#x27;, None]`将字符串中字母变为小写，其余元素不变。L = [&#x27;Hello&#x27;, &#x27;World&#x27;, 18, &#x27;Apple&#x27;, None]#第一种解法：[L[i].lower() if type(L[i]) is str else L[i] for i in range(5)]#isinstance(x, str)#第二种解法[x.lower() if isinstance(x, str) else x for x in L]# `keys = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]` `values = [1, 2, 3]`，根据给出的keys和values，用字典推导式生成新字典。keys = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]values = [1, 2, 3]#第一种解法&#123;keys[i]: values[i] for i in range(len(keys))&#125;#第二种解法&#123;k: v for k, v in zip(keys, values)&#125;# `words = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;, &#x27;you&#x27;]`，用集合推导式求出words中的元素长度都有哪些。words = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;, &#x27;you&#x27;]&#123;len(x) for x in words&#125;\r\nPython迭代器和可迭代对象\r\n\r\n迭代器：它是一个对象，它实现了__iter__() 和\r\n__next__()方法。\r\n可迭代对象：只实现了__iter__() 方法。\r\n\r\n__iter__() 方法返回迭代器对象本身，而\r\n__next__()\r\n方法返回容器中的下一个值。当没有更多的元素时，__next__()方法则抛出一个\r\nStopIteration 异常。\r\n原来我们如何判断一个对象是不是可迭代对象呢？\r\nfrom collections.abc import Iterable, Iteratorprint(isinstance([1, 2, 3], Iterable))#  使用 isinstance() 函数检查列表 [1, 2, 3] 是否是可迭代对象print(isinstance([1, 2, 3], Iterator))#  检查这个对象是否是一个迭代器\r\n按照定义，我们分别自己创建①可迭代对象和②迭代器对象。\r\n#①class Color():    def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):        pass\r\n#②class Color(object):    def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):        return self    def __next__(self):        self.index += 1        if self.index &gt;= len(self.colors):            raise StopIteration        return self.colors[self.index]\r\n#用类实现__iter__方法class Color():        def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):        pass#         return self#创建对象c1_object = Color()# 判断是否为可迭代对象print(isinstance(c1_object, Iterable))       # True# 判断是否为迭代器print(isinstance(c1_object, Iterator))    # False\r\nclass Color():    def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):# 返回迭代器对象本身，使得Color类的实例成为一个迭代器         return self            def __next__(self):         self.index += 1         if self.index &gt;= len(self.colors):             raise StopIteration         return self.colors[self.index]    #创建对象c2_object = Color()# 判断是否为可迭代对象print(isinstance(c2_object, Iterable))        # True# 判断是否为迭代器print(isinstance(c2_object, Iterator))      # True\r\n列表、集合和字典迭代器：\r\n\r\n用内置函数iter()生成对应的迭代器\r\n再用内置函数next()迭代数据\r\n\r\nli = [1, 2, 3]   #&#123;1: &#x27;k&#x27;, 2: &#x27;l&#x27;, 3: &#x27;p&#x27;&#125; #iter_lio = iter(li)# for i in iter_lio:#     print(i)next(iter_lio)next(iter_lio)next(iter_lio)\r\n注意事项：\r\n\r\n迭代器或生成器遍历完一遍之后，不能再次遍历；若想再次遍历需要重新生成另外的迭代器或生成器。\r\n\r\n用for循环迭代输出列表和列表迭代器，输出的都是一样的吗？如果一样，那为什么还要使用迭代器呢？\r\n\r\n使用 for\r\n循环迭代列表和直接使用列表迭代器，其输出结果相同，但迭代器有其独特优势。迭代器支持懒加载，按需生成数据，节省内存，特别适用于处理大数据集。它们能够维护状态，记住迭代位置，实现多次迭代，并提供可扩展性，允许自定义迭代行为。迭代器在逐行读取大文件或处理流数据时尤为有用，因为它们不需要一次性加载所有数据。总之，迭代器是\r\nPython 中实现高效和灵活数据处理的关键工具。\r\n\r\nimport timestart = time.time()li = [x for x in range(1,10)]#[1,2,3,4,5] #[x for x in range(1,6)]for i in li:     print(i)print(f&quot;li:&#123;time.time() - start&#125; s&quot;)    start2 = time.time()my_li = iter(li)for j in my_li:     print(j)print(f&quot;my_li:&#123;time.time() - start2&#125; s&quot;)\r\n常用的迭代器函数\r\n\r\nrange(start, stop, step)\r\nzip(*iterables, strict=False)\r\nstrict默认匹配元素的最短长度，多余的自动忽略\r\nmap(function, iterable)\r\n将函数应用于一个或多个可迭代对象的每一项\r\nenumerate(iterable, start=0)\r\n返回一个枚举对象,start是默认的起始索引\r\nisinstance(z, Iterator) 的作用是判断变量 z\r\n是否是一个迭代器。如果是迭代器，返回 True；否则返回 False。\r\n\r\n#zip()迭代器li0 = [1, 2, 3]li1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]z = zip(li0, li1)z0 = zip(li0, li1)print(isinstance(z, Iterator), z)#直接用for循环遍历for i in z:    print(&#x27;i--:&#x27;, i)#或者把迭代器放到容器中lz = list(z0)for j in lz:    print(&#x27;j--:&#x27;, j)   # 使用zip将两个列表组合names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]ages = [25, 30, 35]for name, age in zip(names, ages):    print(f&quot;&#123;name&#125; is &#123;age&#125; years old.&quot;)\r\n#map()传一个可迭代对象# import mathnum = [4, 9, 1, 16, 7] #推导式def a(x):    return x**0.5num_map = map(a, num) #math.sqrtlist(num_map)#map()传多个可迭代对象num = [4, 9, 1, 16, 7]def mysquare():    for i in range(5):        yield i**2squa = mysquare() # 创建生成器对象squa，调用生成器函数mysquaredef add(x, y):    return x + yadd_map = map(add, num, squa)  #匿名函数 lambda x, y: x+ylist(add_map)\r\n#enumeratefrom collections.abc import Iterable, Iteratorseasons = [&#x27;Spring&#x27;, &#x27;Summer&#x27;, &#x27;Fall&#x27;, &#x27;Winter&#x27;]enu = enumerate(seasons)  # start = 1print(isinstance(enu, Iterator))for i in enu:    print(i)\r\n生成器和生成器表达式\r\n\r\n生成器是一种特殊的迭代器。\r\n生成器表达式就是推导式把外包围换成小括号。但推导式是一次生成数据，数据量太大的情况下，生成器表达式对内存更友好。\r\n\r\n#使用yield语句\\关键字，只能在函数内部定义def reverse(data):    # 使用 for 循环遍历 data 的索引，从最后一个元素开始向前遍历到第一个元素    for index in range(len(data)-1, -1, -1):        yield data[index]        for char in reverse(&#x27;Python！&#x27;):    print(char)\r\n#生成器例子：def generate_squares():    for i in range(4):        yield i**2 # 每次生成一个平方数，并暂停函数执行，直到下一次调用ge = generate_squares()# 检查ge是否是迭代器（Iterator），并打印生成器对象print(isinstance(ge, Iterator), ge)# 第一次运行生成器for i in ge:    print(i)# 第二次运行生成器ge = generate_squares()for i in ge:    print(i)#或者把迭代器放到容器中gg = list(ge)\r\n#生成器表达式la = (2**x for x in range(8))list(la)# 生成一个以3为底，5到60为幂次的生成器。xx = (3**x for x in range(5, 61))list(xx)  #生成器要显示输出结果，需要用构造函数转换输出\r\n练习：\r\n\r\nstr_p = ['xiAoMi', 'HUawEi', 'BaIdu', 'xUnFEi']，使用map()把列表中的字符串都变为小写字母。\r\nstr_p = [&#x27;xiAoMi&#x27;, &#x27;HUawEi&#x27;, &#x27;BaIdu&#x27;, &#x27;xUnFEi&#x27;]def ss(s):    return s.lower()p = list(map(ss, str_p))\r\ndic = &#123;'a': 11, 'b': 20, 'c': 99, 'd': 67&#125;，用enumerate()输出字典的索引（从1开始）和对应的键值对。\r\ndic = &#123;&#x27;a&#x27;: 11, &#x27;b&#x27;: 20, &#x27;c&#x27;: 99, &#x27;d&#x27;: 67&#125;for i, (key, value) in enumerate(dic.items(), start=1):    print(i, key, value)\r\na1 = [1, 0, 3, 5] a2 = [2, 10, 11, 4]\r\na3 = [3, 6, 7, 18]\r\n，要求返回三个列表元素的总和，使用map()和zip()。\r\na1 = [1, 0, 3, 5]a2 = [2, 10, 11, 4]a3 = [3, 6, 7, 18]# 使用zip()函数将三个列表组合成一个元组序列zipped = zip(a1, a2, a3)# 使用map()函数对每个元组中的所有元素求和summed = list(map(sum, zip(a1, a2, a3)))\r\ntup = (1,2,3,4,5,6,7)，要求把tup元组中所有偶数位置上的元素都改为0，返回处理后的新元组。\r\ntup = (1,2,3,4,5,6,7)tuple(0 if i%2==0 else j for i,j in enumerate(tup))\r\n\r\n总结\r\n\r\n什么情况下用推导式？\r\n\r\n\r\n基于现有序列的简单变换和过滤后创建新的序列：当你需要对一个序列进行简单的变换（如乘以2、取平方等）或过滤（如只选择大于某个值的元素）时，推导式可以提供一种更简洁、更易读的方式来创建新的序列。\r\n需要一次性生成整个序列：当你需要生成的序列不是特别大，且可以一次性加载到内存中时，推导式是一个好选择。\r\n\r\n\r\n什么情况下用生成器？\r\n\r\n\r\n处理大数据集：当你处理的数据集非常大，一次性加载到内存中不现实时，生成器可以按需生成数据，从而节省内存。\r\n需要一个按需生成元素的序列：生成器非常适合于那些元素生成过程复杂或耗时的情况，因为它可以延迟计算，直到元素实际需要时才生成。\r\n\r\n\r\n什么情况下用迭代器？\r\n\r\n\r\n需要遍历容器中的所有元素：当你需要遍历一个容器中的所有元素时，迭代器提供了一种高效的方法。\r\n尤其是不需要一次性将所有元素加载到内存中时：迭代器允许你逐个访问元素，而不需要将整个容器加载到内存中，这对于处理大型数据集特别有用。\r\n\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python基础部分","url":"/posts/39185.html","content":"Python程序基础\r\nPython程序构成\r\nPython程序可分解为模块、语句、表达式和对象。\r\n\r\nPython程序由模块组成，模块对应于扩展名为.py的源文件。\r\n模块由语句组成，运行Python程序时，按照模块中的语句顺序依次执行。\r\n语句包含表达式。表达式由操作数和运算符组成。\r\n表达式用于创建和处理\r\n对象。\r\n\r\n\r\n\r\nimage-20250513193726574\r\n\r\n对象\r\n对象是Python中对数据的抽象。\r\n每个对象都有identity、type和value。\r\n对象和变量\r\n\r\n对象是python中的各种数据，存在于计算机内存中的一个内存块中。\r\n变量是用来指向（绑定）对象的，也称为对象的引用。\r\n变量名必须为有效的标识符。\r\n\r\n标识符\r\n\r\n标识符是程序中为了区分或引用各种数据而定义的名称，如变量名、常量名、函数名、类名、模块名等。\r\n关键字（保留字）是特殊的标识符，在Python中有特定的含义，开发人员不能定义和关键字相同的标识符。\r\n\r\n变量名命名规则\r\n\r\n由字母、数字或下划线组成，\r\n数字不能做开头\r\n不能以Python关键字作为变量名\r\n变量名要有意义\r\n变量名区分大小写\r\n建议使用驼峰法或加下划线方式命名\r\n\r\n变量赋值\r\n\r\n等号”=“用来给变量赋值。\r\nPython 中的变量赋值不需要类型声明。\r\n每个变量在使用前都必须赋值，变量赋值后才创建成功。\r\n\r\n字面量（literal）\r\n\r\n用于某种数据类型固定值的表示法。\r\nPython基于字面量创建相应数据类型的对象。\r\n\r\na = 123s = &#x27;az78&#x27;l = [4, &#x27;f&#x27;]\r\n表达式\r\n表达式是一段能计算的代码片段，由操作数（如变量、常量）和运算符（如+、*、()）构成。\r\nPrimary\r\n是语言中最紧密绑定的操作，即表达式中优先级最高、最先被计算的部分。（primary\r\n::= atom | attributeref | subscription | slicing | call）\r\n“最紧密绑定”是指在表达式的运算顺序中，这部分会首先被解析或计算。\r\n语法规则（使用 BNF 表示）：\r\nprimary ::= atom | attributeref | subscription | slicing | call\r\n各部分含义：\r\n\r\natom：原子操作，如变量、常量、字面量（如42、\"hello\"）。\r\nattributeref：属性引用，如obj.attr。\r\nsubscription：下标操作，如list[0]。\r\nslicing：切片操作，如list[1:3]。\r\ncall：函数 / 方法调用，如func()。\r\n\r\n::=\r\n表示“定义为”或“被指定为”，用来定义一个语法规则的左边可以被右边的一个或多个符号序列替换。\r\n|：表示 “或”，即左边的符号可以被右边的任一选项替换\r\n这种定义方式是巴科斯-诺尔范式（Backus-Naur Form, BNF）和扩展巴科斯-诺尔范式（Extended Backus-Naur Form, EBNF）的一部分，它们是用于描述编程语言语法的形式化方法。\r\n操作数和运算符通过一定规则构成表达式\r\n操作数包含Primary，Primary包含atom。\r\n最基本元素（atom）\r\n\r\nidentifier 标识符\r\nliteral 字面量\r\nenclosure（翻译为包围、围住的意思）小括号、方括号或花括号的封闭结构\r\n\r\n属性引用\r\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = ageperson = Person(&quot;Alice&quot;, 30)# 访问对象的属性print(person.name)  print(person.age)\r\nPython代码规范\r\nPEP8 Python编码规范：https://www.python.org/dev/peps/pep-0008/\r\n缩进\r\n- Python\r\n使用缩进来表示代码的逻辑结构，一般使用Tab键或4个空格作为一个缩进级别。\r\n- 优先使用空格缩进，tab制表符一般用于已经使用了制表符的代码中。\r\n-\r\n有括号的参数缩进：与开始括号垂直对齐，或者回车到下一行后再额外添加4个空格。\r\n#缩进演示示例def imn(x):    a = 9    if x != 0:        a = a/ax        print(&#x27;ok!&#x27;)    return a### 有括号的参数缩进def long_function_name(var_one,                        var_two,                        var_three,                       var_four):    print(var_one)foo = long_function_name(&quot;aaa&quot;,                          &quot;bb&quot;,                         &quot;vv&quot;,                         &quot;ww&quot;)  \r\n跨行语句\r\n当一行的内容太多时，为了增加代码的可读性，可让一条语句跨多行显示。\r\nPEP8规范推荐每行的最大长度为79个字符\r\n\r\n使用反斜杠\\换行\r\n使用括号()换行\r\n\r\n注意：使用反斜杠换行之后，反斜杠后面不能再添加任何字符（包括空格）或注释语句。\r\n换行在二元运算符之前还是之后呢？\r\n答案是都可以，但是推荐在二元运算符之前。 即：\r\nincome = (gross_wages         + taxable_interest         + (dividends - qualified_dividends)         - ira_deduction         - student_loan_interest)\r\n空格\r\n\r\n在运算符两边添加空格\r\n+,*,=,-,+=,==,&gt;,in,is not, and等。\r\n复杂表达式中，建议在具有最低优先级的操作符两端添加空格。\r\n在函数的参数列表中，参数默认值等号 =\r\n两边不添加空格。\r\n\r\nPython语句\r\n\r\nPython语句分为简单语句和复合语句。\r\n简单语句包括表达式语句、赋值语句、import语句等等\r\n复合语句包括if语句、while语句、for语句等等\r\n\r\n导入语句需要单独在一行上\r\n多条简单语句可用分号（;）隔开，写到一行\r\n如果条件语句、循环语句、函数定义和类定义比较短，可放在同一行\r\n流程控制代码规范\r\n程序的流程\r\n\r\n输入→处理→输出\r\n无论程序的规模如何，每个程序都可以分为以上三部分：程序通过输入接收待处理的数据（Input），然后执行相应的处理过程（Process），最后通过输出返回处理结果（Output）。该过程通常称为IPO程序编写方法。\r\n\r\n程序流程图\r\n\r\n程序流程图又称（程序框图），是描述程序运行具体步骤的图形表示。 \r\n\r\n程序的控制结构\r\n\r\n顺序结构\r\n\r\n程序中各语句按其出现的先后次序执行，称之为顺序结构。\r\n\r\n选择结构\r\n\r\n选择结构可以根据条件来控制代码的执行分支，也成为分支结构。\r\nPython使用 if 语句实现分支结构。\r\n#单分支结构x = int(input(&quot;请输入x的值：&quot;))y = int(input(&quot;请输入y的值：&quot;))if(x &gt; y):    a = x - y    print(&quot;a的值为：&quot;,a)    #双分支结构import matha = float(input(&quot;请输入三角形的边长a：&quot;))b = float(input(&quot;请输入三角形的边长b：&quot;))c = float(input(&quot;请输入三角形的边长c：&quot;))if(a + b &gt; c and b + c &gt; a and a + c &gt; b):    h = (a+b+c) / 2    area = math.sqrt(h * (h-a) * (h-b) * (h-c))    print(str.format(&quot;三角形的三条边分别为：a=&#123;0&#125;,b=&#123;1&#125;,c=&#123;2&#125;&quot;, a, b, c))    print(str.format(&quot;三角形的面积=&#123;0&#125;&quot;, area))else:    print(&quot;输入的三条边无法构成三角形，请重新输入。&quot;)# 多分支结构x = int(input(&quot;请输入x的坐标：&quot;))y = int(input(&quot;请输入y的坐标：&quot;))if(x &gt; 0 and y &gt; 0):    print(&quot;该点位于第一象限&quot;)elif(x &lt; 0 and y &gt; 0):    print(&quot;该点位于第二象限&quot;)elif(x &lt; 0 and y &lt; 0):    print(&quot;该点位于第三象限&quot;)elif(x &lt; 0 and y &lt; 0):    print(&quot;该点位于第四象限&quot;)else:    print(&quot;该点位于坐标轴上&quot;)\r\n\r\n循环结构\r\n\r\n循环结构用来重复执行一条或多条语句。\r\nPython使用for语句和while语句来实现循环结构。\r\ni = 1while(i &lt;= 5):    k = 1    while(k &lt;= 5-i):        print(&quot; &quot;, end = &quot;&quot;)        k = k + 1    j = 1    while(j &lt;= i):        print(i, end = &quot; &quot;)        j = j + 1    print()    i = i + 1def sum_100():    sum = 0    for i in range(1,101):        sum += i    return sumsum_100 = sum_100()print(sum_100)\r\n\r\n\r\nimage-20250513195423897\r\n\r\nfor\r\n循环用于迭代序列（即列表、元组、字典、集合或字符串等）。这与其他编程语言中的\r\nfor\r\n关键字不太相似，而是更像其他面向对象编程语言中的迭代器方法。\r\n\r\n\r\n循环结构中的跳转语句\r\n\r\nbreak语句 （立即终止循环，跳出循环，执行循环后的代码。）\r\ncontinue语句 （跳过当前循环的剩余部分，并开始下一次循环。）\r\npass语句\r\n（用于占位或作为语法要求的空代码块，在循环中，不做任何事情）\r\nbreak 和 continue 语句的使用，通常是与 if 条件语句配合的，当满足 if\r\n条件语句的时候，结束整个循环或者结束本轮循环。\r\n\r\n# 将 break 用于 for 循环# 对 1 到 20 的数字求和，当和大于 100 时，便停止求和numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]count = 0for var in numbers:    count += var    if count &gt;= 100:        breakprint(&quot;count = &quot;, count)# continue# 对 20 以内的偶数求和numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]count = 0for var in numbers:    # 奇数，除以2的余数不为0，也就是不能被2整除    if var % 2 != 0:        # 当数字为奇数时，退出本次循环        continue    count += varprint(&quot;count = &quot;, count)\r\nrange()函数\r\n\r\nrange类型表示一个不可变的数字序列，通常用于在for循环中循环特定次数。\r\n语法：range(start, stop[, step])\r\n\r\nstart：序列的起始值（包含）。默认为 0。\r\nstop：序列的结束值（不包含）。必须指定。\r\nstep：序列的步长（即相邻两个值之间的差）。默认为 1。\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的数据类型","url":"/posts/58610.html","content":"Python的数据类型\r\n\r\n数值（Numbers）\r\n字符串（String）\r\n元组（Tuple）\r\n列表（List）\r\n集合（Set）\r\n字典（Dictionary）\r\n……\r\n其他数据类型\r\n\r\n字节类型（Bytes）：b’Hello’\r\n字节数组（Byte Arrays）： bytearray(b’Hello’)\r\n空类型（None）：没有返回的函数值\r\n未执行的（NotImplemented）：在运算时，对象不支持，返回该值\r\n省略号（Ellipsis）：用于Numpy的切片或者表示无限循环\r\n\r\n\r\nPython数据类型-数值型\r\nPython数值型介绍\r\n\r\n整型（int）：123\r\n布尔型（bool）：False(0)、True(1)\r\n浮点型（float）：123.04\r\n复数型（complex）：3 + 7j、real + imagj\r\n\r\n复数的一些常见应用场景包括：\r\n\r\n工程学：在电气工程中，复数用于分析交流电路，其中电压和电流随时间变化。复数使得可以轻松地处理电路中的电阻、电感、电容和它们的相位关系。\r\n物理学：在量子力学中，波函数通常是复数。复数用于描述粒子的位置和动量等物理量。\r\n数学：在纯数学中，复数用于解决不能在实数域内解决的问题，如在复平面上分析多项式方程的根。\r\n信号处理：在数字信号处理中，复数用于表示频率和相位信息，以及进行傅里叶变换等操作。\r\n计算机图形学：复数可以用于计算二维图形的旋转和平移。\r\n其中的虚部j表示乘以根号下-1（即虚数单位），这意味着这个复数在复平面上距离原点3个单位向右（实部），4个单位向上（虚部）。\r\n\r\n对象由identity、type和value标识\r\na = b = c = d = print(id(a), type(a), a)print(id(b), type(b), b)print(id(c), type(c), c)print(id(d), type(d), d)\r\n\r\n\r\nimage-20250513195950732\r\n\r\nPython整数的存储\r\n在内存中，变量存放到栈区，相对应的数据存放到常量区或堆区。\r\n整型有一个“小整数池”（small integer pool）\r\n\r\n这个区域是为了快速访问和存储小整数而设计的，它是一个固定的范围，用于缓存频繁使用的小整数。\r\n整型的缓存区范围通常为[-5,256]\r\n不同版本的python范围可能稍有不同\r\n\r\n如果变量值是整数且不在“小整数池”的范围呢？如果是浮点型、布尔型或复数型呢？\r\n新创建的变量和原来的id还会一样吗？\r\nx = 10 + 9jy = 10 + 9jprint(id(x))print(id(y))# del x# del yq = 10 + 9jprint(id(q))\r\ndef ppoi():    x = 980 + 23j    y = 980 + 23j    print(id(x))    print(id(y))    del x    del y    q = 980 + 23j    print(id(q))    ppoi()\r\ndef ppoi():    x = 287    y = 287    print(id(x))    print(id(y))#     del x#     del y    def ppo():    q = 287    print(id(q))    ppoi()ppo()\r\nPython的交互模式下，一行一行执行代码\r\n\r\n不会检查内存中是否存在相同的变量值，所以相同的变量值也可能会出现id值不同。\r\n\r\n若在同一个代码块中\r\n\r\n首先检查内存中是否存在当前变量值，若存在则直接指向；若不存在会重新分配空间。\r\n\r\n总结：\r\n\r\n常量区的数据范围为[-5,256]，此区域内的数据有驻留机制\r\n堆区的数据：在一个代码块中，数据的地址会暂时存储不被垃圾回收；不同代码块则会重新分配\r\n\r\n类型转换函数 （类似构造函数）\r\n\r\nint() int()函数主要用于将一个值转换为整数\r\n\r\n浮点数转换时，向下取整。\r\n布尔值转换时，True对应1，False对应0。\r\n复数只有当虚数部分为0时才能转换，例如3+0j。\r\n参数为字符串时，字符串内容必须为整数值。\r\nf1 = float(120)print(f1)f2 = float(True)print(f2)f3 = float(&#x27;120&#x27;)print(f3)f4 = float(&#x27;Infinity&#x27;)#无穷大print(f4)f5 = float(&#x27;NaN&#x27;)print(f5)\r\n\r\nbool()\r\n\r\n\r\nimage-20250513200511537\r\n\r\nfloat()\r\ncomplex()\r\n#布尔类型b1 = bool(0) # 0和1print(b1)b2 = bool(98)# &#x27;xyz123&#x27;print(b2)#复数类型c1 = complex(3, 5)print(c1)\r\n\r\n一些问题\r\n1.整型之间进行（加,减,乘,除,取余,幂次）运算，最后得到的是整型吗？\r\n2.浮点型之间进行（加,减,乘,除,取余,幂次）运算，最后得到的是浮点型吗?\r\n3.布尔型变量之间可以进行布尔运算，整型和浮点型变量之间可以吗？\r\n4.复数型的实部和虚部具体是什么数据类型？\r\nPython数据类型-字符串\r\nPython字符串介绍\r\n字符串是什么？\r\n\r\n字符串是一种以Unicode编码的序列，是一种\r\n有顺序 的 不可变 的序列。 Unicode\r\n规范https://www.unicode.org/\r\n旨在罗列人类语言所用到的所有字符，并赋予每个字符唯一的编码。该规范一直在进行修订和更新，不断加入新的语种和符号。\r\n\r\n字符串的创建\r\n\r\n用单引号、双引号或三引号包围起来创建字符串。\r\n\r\n单引号受限制的情况下，需要用双引号或三引号\r\n\r\n#单引号受限制的情况,字符串中包含单引号# str1 = &#x27;He&#x27;s a good boy.&#x27;#改成双引号：message = &quot;He&#x27;s a good boy.&quot;print(message)#改成三引号：三引号（&#x27;&#x27;&#x27; 或 &quot;&quot;&quot;）可以用来定义多行字符串，# 也可以用来避免单引号和双引号的冲突message = &quot;&quot;&quot;He&#x27;s a &quot;good&quot; boy.&quot;&quot;&quot;print(message)#长字符串中间有换行的可以用三引号word = &#x27;&#x27;&#x27;Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.&#x27;&#x27;&#x27;\r\n\r\n字符串中包含双引号则可以用单引号包围\r\n如下情况必须使用三引号\r\n\r\n字符串中既包含单引号又包含双引号时\r\n作为文档字符串时\r\n定义多行字符串时\r\n\r\n\r\n\r\n#1. 例如&quot;It&#x27;s my book.&quot;、    &quot;hello&#x27;p&#x27;ython&quot;、    &quot;o&#x27;&quot;str4 = &#x27;&#x27;&#x27;&quot;It&#x27;s my book.&quot;&#x27;&#x27;&#x27; print(str4)#2. 在Python中，函数、类的开头可以包含一个文档字符串，用于说明代码的用途和行为。def my_function():    &quot;&quot;&quot;这是一个文档字符串，用三引号包围，用于解释函数的用途。&quot;&quot;&quot;    pass#3. 多行的字符串：黄河之水天上来，奔流到海不复回。str5 = &quot;&quot;&quot;黄河之水天上来，奔流到海不复回。&quot;&quot;&quot;print(str5)\r\n\r\n用类型构造函数str()创建字符串\r\n#数值型转化为字符串a = 123print(a, type(a))str6 = str(a)print(str6, type(str6))\r\n\r\n转义字符\r\n\r\n以\\开头的字符叫转义字符，通过转义字符可以正确表示具有二义性的字符或无法显示的控制字符。\r\n例如：It's my book.中的'既是普通字符又是标识字符串的符号。\r\n在'前加上\\，可以使字符仅作为普通字符出现，避免二义性。\r\n\r\n#打印字符串&quot;Let&#x27;s go!&quot;print(&#x27;&quot;Let\\&#x27;s go!&quot;&#x27;)print(&quot;\\&quot;Let&#x27;s go!\\&quot;&quot;)\r\n常用的转义字符：\r\n\r\n\\n（换行符）\r\n\\t（Tab制表符）\r\n\\r（回车）\r\n\\'（单引号）\r\n\\\"（双引号）\r\n\\\\（反斜线）\r\n\r\nPEP8规范建议：\r\n为了增加代码的可读性，对于字符串内部的引号，尽量使用与内部不同的引号标识字符串，而不是使用转义字符。\r\n如果不想让转义字符生效，怎么办？\r\n#在字符串前面加r或Rprint(r&#x27;D:\\thedir\\one\\now&#x27;)print(R&#x27;D:\\thedir\\two\\now&#x27;)\r\n字符串的索引和切片\r\n1.通过索引获取字符串中的元素\r\n\r\n正索引：元素位置（下标）从左往右从0开始，依次递增。\r\n负索引：元素位置（下标）从右往左从-1开始，依次递减。\r\n\r\n\r\n\r\nimage-20250513201552242\r\n\r\n2.切片是一种高级索引\r\n切片可以灵活获取字符串的多个元素\r\n#切片操作尝试s = &quot;string&quot;s[1:3]#字符串的切片操作s = &quot;string&quot;#步长为正数的情况：print(s[::2])#步长为负数的情况：print(s[1::-1])\r\n切片的定义：\r\n切片是用于截取索引片段获得序列中元素的方法。\r\n切片的表示形式：\r\nsequence[start : end : step]\r\nstart→起始索引值，省略时代表索引值为0；\r\nend→结束索引值（不包含在内），省略时代表索引值为end+1；\r\nstep→步长，两个相邻元素间的步长为1，步长为1时可省略。步长为负数时，反转序列。\r\nstep的两个重要功能：\r\n\r\n跳过某些元素\r\n反转序列\r\n\r\n注意：\r\n字符串是不可变的，不能用索引和切片给字符串重新赋值。\r\n索引和切片总结：\r\n\r\n索引只能获取单个元素，切片可以获取多个元素。\r\n切片适用于所有序列，不仅仅是字符串。\r\n字符串不可变，不能用索引或切片给字符串重新赋值。\r\n\r\n字符串的拼接\r\n\r\n用 + 拼接\r\n用 * 拼接\r\n格式化拼接 %\r\n格式化拼接 format()\r\n格式化拼接 f-string（Python 3.6及更高版本）\r\njoin()方法\r\n\r\n#用+拼接两个字符串str1 = &quot;hello&quot;str2 = &quot;你好&quot;str3 = str1 + str2print(str3)#重复操作符（`*`）：用于将字符串重复指定次数str0 = &#x27;s+&#x27;str1 = str0 * 20print(&#x27;str1:&#x27;,str1)str2 = str0 * -2print(&#x27;str2:&#x27;,str2)#格式化拼接name = &#x27;Mary&#x27;city = &#x27;New York&#x27;age = &#x27;thirty years old&#x27;#%letter = &#x27;My name is %s, and I come from %s&#x27; % (name, city) print(letter)#format()answer = &#x27;Hi,&#123;&#125;, I also come from &#123;&#125;&#x27;.format(name, city)print(answer)#f-stringmessage = f&quot;Her name is &#123;name&#125;, and she is &#123;age&#125; years old.&quot;print(message)\r\nformat()更多用法：\r\n\r\nprint(\"My name is &#123;1&#125; and I am &#123;0&#125; years old.\".format(age, name))\r\n#位置索引占位符\r\nprint(\"My name is &#123;name&#125; and I am &#123;age&#125; years old.\".format(name=name, age=age))\r\n#指定变量名\r\nprint(\"The value of pi is approximately &#123;:.2f&#125;.\".format(num))\r\n#格式化数字： {:,}千位符\r\n\r\njoin()的语法格式：\r\nstr.join(iterable)\r\n其中str是分隔符，用于连接iterable中的元素。\r\nstr.join(iterable)s = &#x27; &#x27;  #使用空格做分隔符say1 = (&#x27;长路&#x27;, &#x27;漫漫&#x27;, &#x27;,&#x27;, &#x27;其修&#x27;, &#x27;远兮&#x27;)#[&#x27;长路&#x27;, &#x27;漫漫&#x27;, &#x27;，&#x27;, &#x27;其修&#x27;, &#x27;远兮&#x27;] say2 = s.join(say1)print(say2)def re(str1, str2):    str1 = str1[::-1]    str2 = str2[::-1]#     s0 = &#x27;Reverse:&#x27; + str1 + &#x27; &#x27; + str2    #用+拼接#     s1 = &#x27; &#x27;.join((str1, str2))#     ss1 = &#x27;Reverse:&#x27; + s1         #用join拼接法        #格式化拼接方法：    #     return f&#x27;Reverse:&#123;str1&#125; &#123;str2&#125;&#x27;   #     return &#x27;Reverse:%s %s&#x27; % (str1, str2)#     return &#x27;Reverse:&#123;&#125; &#123;&#125;&#x27;.format(str1, str2)    return ss1aa = re(&#x27;one&#x27;,&#x27;two&#x27;)\r\n总结：\r\n\r\n+拼接方法，常用于字符串变量之间的相加。\r\n\r\n格式化拼接方法，代码具有可读性和可维护性。\r\n\r\njoin()方法，适用于拼接的字符串较多时。\r\n\r\n成员关系操作符（in、not\r\nin）\r\n\r\n成员关系运算符用来判断一个字符串是否包含在另一个字符串中。\r\n\r\nv_str = &#x27;water.tif, app.jpg, wechat.png, google.gif, football.jfif&#x27;# print(&#x27;.psd&#x27; in v_str)# print(&#x27;.psd&#x27; not in v_str)#空字符串呢？print(&#x27;&#x27; not in v_str)print(&#x27;&#x27; in v_str)\r\n字符串对象的常用方法\r\n- 字符串类型判断\r\ns.isnumeric() #是否只包含数字字符s.isalpha()  #是否全为字母s.islower()  #字母是否全为小写s.isupper()  #字母是否全为大写\r\n\r\n字符串大小写转换\r\n\r\ns.lower()  #转为小写s.upper()  #转为大写s.swapcase()  #大小写呼唤s.capitalize() #在整个字符串中首字母大写，其余小写s.title()  #对每个字符串中的单词而言\r\n\r\n字符串拆分、组合及去空格\r\n\r\nsplit(sep=None, maxsplit=-1) #按sep（默认为空格）分割字符串，maxsplit是分割的最大次数，返回列表。strip()     #移除两端空格或指定字符lstrip()    #移除左端空格或指定字符rstrip()    #移除右端空格或指定字符\r\n# 函数接收一个任意字符串s，要求删除两侧的空白字符，把字符串中连续多个空格替换为1个空格，返回处理后的新字符串。例如，s为&#x27;a    bb   c &#x27;时返回&#x27;a bb c&#x27;。def stri(s):    s = s.strip()    s = s.split()    s = &#x27; &#x27;.join(s)    return ss = &#x27;a   bb   c  &#x27;s1 = stri(s)s1\r\n\r\n字符串的查找和替换\r\n\r\ns.find()     #查找指定字符串n，返回n的起始下标，没有则返回-1s.replace(old, new) #替换字符串中的指定子串,old为旧子串，new为新子串。enumerate(iterable)   #返回字符串元素的索引和对应的元素值,常用于for循环中\r\n# 函数接收一个表示日期时间的字符串s，格式为&#x27;2020-02-18 22:02:22&#x27;，要求删除每一部分的前导0，返回格式为&#x27;2020-2-18 22:2:22&#x27;的字符串。不能导入任何模块，注意年月日和时分秒之间有且只有一个空格。def main(s):    # 分割年月日和时分秒    date_part, time_part = s.split()    # 处理年月日部分    year, month, day = map(int, date_part.split(&#x27;-&#x27;))    date_formatted = f&#x27;&#123;year&#125;-&#123;month&#125;-&#123;day&#125;&#x27;    # 处理时分秒部分    hour, minute, second = map(int, time_part.split(&#x27;:&#x27;))    time_formatted = f&#x27;&#123;hour&#125;:&#123;minute&#125;:&#123;second&#125;&#x27;    # 输出格式化后的字符串    result = f&#x27;&#123;date_formatted&#125; &#123;time_formatted&#125;&#x27;    print(result)# 调用主函数s = &#x27;2020-02-18 22:02:22&#x27;ss = main(s)\r\nPython的数据类型之元组\r\n\r\n元组是一种有序的、不可变的序列。\r\n元组的创建方法：\r\n\r\n显式的直接创建\r\n使用类型构造函数创建\r\n\r\n\r\n1. 显式的直接创建元组\r\n\r\n使用 () 包围数据创建元组，各元素之间用逗号隔开。\r\n\r\n# 使用 () 创建一个空元组# 非空元组，元素可以是任意类型# 创建一个包含多个元素的元组my_tuple = (1, &quot;hello&quot;, 3.14, True)print(my_tuple) \r\n元组的两种特殊表示情况：\r\n\r\n元组只有一个元素的时候，不能省略逗号\r\n元组也可以没有圆括号包围\r\n\r\n# 元组元素只有一个时single_element_tuple = (10,)  # 注意逗号print(type(single_element_tuple)) \r\n没有原括号包围也可以创建元组（PEP8不推荐此方法，代码可读性较低）\r\n# 没有圆括号包围tuple_without_parentheses = 10, 20, 30print(type(tuple_without_parentheses)) print(tuple_without_parentheses)  # 输出：(10, 20, 30)\r\n2. 使用类型构造函数创建\r\n\r\n使用类型构造函数 tuple()\r\n将其他可迭代对象转换成元组类型。\r\n\r\ntuple(可迭代对象)#tuple()类型构造函数的实现\r\n可迭代对象\r\n\r\n实现了__iter__()方法\r\n是指可以在循环中逐一返回其元素的对象\r\n\r\n目前学到的可迭代对象：字符串、元组。\r\n判断一个对象是不是可迭代对象，可以用isinstance()函数，此函数的作用是类型检查。\r\nisinstance(判断对象, collections.abc.Iterable)\r\nIterable类型存在于collections.abc模块中\r\n# 定义一些测试对象import collectionstest_objects = [    [1, 2, 3],  # 列表    (1, 2, 3),  # 元组    &#123;1, 2, 3&#125;,  # 集合    &quot;hello&quot;,    # 字符串    &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;,  # 字典    123,        # 整数    45.67,      # 浮点数    True,       # 布尔值    None        # None]# 判断每个对象是否是可迭代对象for obj in test_objects:    if isinstance(obj, collections.abc.Iterable):        print(f&quot;&#123;repr(obj)&#125; 是可迭代对象&quot;)    else:        print(f&quot;&#123;repr(obj)&#125; 不是可迭代对象&quot;)\r\n元组的序列操作\r\n元组的序列操作\r\n\r\n索引访问\r\n\r\ntp1 = (1, 3, 5, 7, 9, 11, 13)tp1[0]tp1[3]\r\n\r\n切片操作\r\n\r\ntp1[2:5]  #5,7,9tp1[-3:]  # 9,11,13\r\n\r\n连接\r\n\r\ntp2 = (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)tp1 + tp2\r\n\r\n重复操作\r\n\r\ntp2 * 2\r\n\r\n成员关系操作\r\n\r\n2 in tp12 not in tp1\r\n\r\n比较运算操作(==、!=、&gt;、&gt;=、&lt;、&lt;=)\r\n\r\ntp1 == tp2tp1 != tp2\r\n元组解包\r\n\r\n将元组赋值给多个变量，这个过程被称作元组解包\r\n\r\na, b, c = (&#x27;1s&#x27;, &#x27;2s&#x27;, &#x27;3s&#x27;)print(a, b, c)#*c 是不定长的对象a, b, *c = (&#x27;1s&#x27;, &#x27;2s&#x27;, &#x27;3s&#x27;, &#x27;4s&#x27;, &#x27;5s&#x27;, &#x27;6s&#x27;)print(a, b, c)# 1s 2s [&#x27;3s&#x27;, &#x27;4s&#x27;, &#x27;5s&#x27;, &#x27;6s&#x27;]\r\npython数据类型之列表\r\n\r\n列表是一种有序的、可变的序列。\r\n创建方法：\r\n\r\n显式的直接创建\r\n使用类型构造函数\r\n\r\n\r\n显式的直接创建\r\n\r\n使用方括号（[]）创建列表，各元素之间用逗号隔开。\r\n# 创建一个空列表empty_list = []#非空列表，元素可以是任意类型# 创建一个包含整数的列表list_of_integers = [1, 2, 3, 4, 5]# 创建一个包含字符串的列表list_of_strings = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]# 创建一个包含不同数据类型的列表mixed_list = [1, &quot;hello&quot;, 3.14, True]\r\n\r\n列表的元素：\r\n\r\n列表的元素可以是不同类型（包括列表）\r\n列表中具有相同值的元素允许出现多次\r\n\r\n使用类型构造函数创建\r\n\r\n使用类型构造函数 list()\r\n将其他可迭代对象转换成列表类型。\r\n\r\n\r\nlist(可迭代对象)\r\n\r\n# 从字符串创建字符列表char_list = list(&quot;hello&quot;)print(char_list) \r\n用切片和索引修改列表的值\r\nls0 = [1, 2, 3, 4, 5, 6]ls0[3] = 0ls0[1:4] = [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;p&#x27;]#改变列表中元素的数据ls0 = [1, 2, 3, 4, 5, 6]ls0[3] = 0print(ls0)ls0[1:4] = [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;p&#x27;]print(ls0)\r\n\r\n字符串和元组不能改变切片的值，因为字符串和元组都是不可变的。列表是可变数据，所以可以通过更新切片，改变列表元素的值。\r\n\r\nindex 方法会返回元素第一次出现的下标\r\n# 查找列表中某元素的下标i = ls0.index(6)print(i)\r\n列表的添加和拼接\r\n\r\nls.append()\r\nls.extend(iterable)\r\nls.insert(index, object)\r\n+ 和 +=\r\n\r\n#append()ls1 = [1, 2, 3]ls1.append(4)print(ls1)#extend()方法需要一个可迭代对象作为参数。ls2 = [1, 2, 3, 5]#ls2.extend([4])ls2.extend((4,))print(ls2)#insert()ls3 = [1, 2]ls3.insert(8, [9])ls3\r\n# 函数main(lst)接收包含若干正整数的列表lst，要求返回所有奇数下标元素之和与所有偶数下标元素之和组成的元组，例如lst为[1234，5，13，65]时返回(70，1247)。def main(lst):    # 初始化奇数下标和偶数下标的和    sum_odd_index = 0    sum_even_index = 0        # 遍历列表，索引从0开始    for index, value in enumerate(lst):        # 判断索引是奇数还是偶数        if index % 2 == 0:            sum_even_index += value  # 偶数下标，累加到偶数下标和        else:            sum_odd_index += value  # 奇数下标，累加到奇数下标和        # 返回一个元组，包含奇数下标元素之和与偶数下标元素之和    return (sum_odd_index, sum_even_index)# 测试函数lst = [1234, 5, 13, 65]result = main(lst)print(result)  # 输出应该是 (70, 1247)\r\n列表的移除和删除\r\n\r\nls.pop()\r\nls.remove()\r\nls.clear()\r\n关键字del\r\n\r\n#pop：按照下标进行移除ls1 = [&#x27;a&#x27;, &#x27;b&#x27;, 3]ls1.pop(2)# remove：按照元素值进行删除ls2 = [&#x27;a&#x27;, &#x27;b&#x27;, (1, 2)]ls2.remove(&#x27;b&#x27;)# 清空列表元素ls3 = [0, 1, 2, 3]#删除整个列表ls3.clear()#关键字del：直接删除变量 或者 通过索引删除列表内的元素ls4 = [5, 6, 7]del ls4[1]\r\n列表的排序\r\n\r\n使用列表对象方法 sort()\r\n对原列表进行排序，改变原列表\r\n使用内置的排序函数 sorted()\r\n返回排好序的列表副本，原列表不变（也可用于元组和字典）\r\n这两种方式默认的排序都是升序的\r\n\r\n#降序的参数list.sort(*, key=None, reverse=False)sorted(iterable, key=None, reverse=False)\r\n# 现有一个列表# pt = [&quot;Python&quot;,&quot;C&quot;, &quot;Java&quot;, &quot;C++&quot;, &quot;Go&quot;, &quot;Rust&quot;]#给列表的元素排序，按照元素的长度从大到小排序，用两种方法分别实现。pt = [&quot;Python&quot;, &quot;C&quot;, &quot;Java&quot;, &quot;C++&quot;, &quot;Go&quot;, &quot;Rust&quot;]# 使用列表的 sort() 方法排序pt.sort(key=len, reverse=True)print(pt)# 使用 sorted() 函数排序sorted_pt = sorted(pt, key=len, reverse=True)print(sorted_pt)\r\n到目前为止，我们学到的可变的数据类型只有列表，接下来我们从列表内存角度来理解列表的可变性。\r\n\r\n\r\nimage-20250513203606483\r\n\r\nlist1 = [1, 2, 3, 4, 5, 6]print(list1, id(list1))#用切片或索引改变列表元素list1[0] = &#x27;a&#x27;print(list1, id(list1))#在原列表中做添加append、删除remove的操作list1.append(7)print(list1, id(list1))\r\n\r\n\r\nimage-20250513203630504\r\n\r\n总结：\r\n\r\n列表是可变序列，修改原列表的数据时，整个列表的id值不发生改变。\r\n一旦有新的列表产生，就会开辟新的内存地址，即使和原列表一模一样也会开辟新空间。\r\n\r\nPython数据类型之集合\r\n\r\n集合是一个无序的、不重复的元素集。\r\n创建方法：1.显式的直接创建 2.使用类型构造函数\r\n\r\n显式的直接创建\r\n\r\n使用大括号&#123;&#125;创建，各元素之间用逗号隔开。\r\n\r\n#创建空集合empty_set = set()  # 使用set()函数创建空集合\r\n用{}不能创建空集合，{}\r\n是Python中字典的语法，用于定义键值对。如果{}是空的,Python会默认它是一个空字典，而不是空集合。\r\n#错误创建非空集合set1 = &#123;1,(22,34,0),[33,90,0,&#x27;2&#x27;]&#125;set1\r\n用花括号创建的集合，其元素只能是可哈希的元素。\r\n\r\n可哈希对象（bool、int、float、complex、str、tuple、frozenset等）\r\n不可哈希的对象（list、set、dict）\r\n注意：也不能含有不可哈希对象\r\n\r\n使用类型构造函数创建\r\n\r\n使用类型构造函数 set()\r\n或frozenset()将其他类型转换成列表类型。\r\nset()和frozenset()的参数需要满足：是可迭代对象，并且该可迭代对象中都是可哈希对象。\r\n\r\n目前学到的可迭代对象：字符串、元组、列表、集合。\r\n\r\n创建空集合只能使用set()或frozenset()\r\nset() 是可变的，你可以对它进行添加、删除等操作。\r\nfrozenset() 是不可变的，一旦创建，不能修改。\r\n\r\n# 用set()创建空集合empty_set = set()print(empty_set)  print(type(empty_set))  #使用 frozenset() 创建空集合empty_frozenset = frozenset()print(empty_frozenset)  print(type(empty_frozenset)) ## 创建非空集合my_set = &#123;1, 2, 3, 4, 5&#125;print(my_set)  # 使用列表创建非空集合my_set = set([1, 2, 3, 4, 5])print(my_set)  # 使用元组创建非空集合my_set = set((1, 2, 3, 4, 5))print(my_set)  # 使用字符串创建非空集合（自动去重）my_set = set(&quot;hello&quot;)print(my_set)  # 使用列表创建非空 frozensetmy_frozenset = frozenset([1, 2, 3, 4, 5])print(my_frozenset)  # 使用字符串创建非空 frozensetmy_frozenset = frozenset(&quot;hello&quot;)print(my_frozenset)  #&#123;1, 2, 3, 4, 5&#125;#&#123;1, 2, 3, 4, 5&#125;#&#123;1, 2, 3, 4, 5&#125;#&#123;&#x27;h&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;l&#x27;&#125;#frozenset(&#123;1, 2, 3, 4, 5&#125;)#frozenset(&#123;&#x27;h&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;l&#x27;&#125;)\r\n总结：\r\n\r\n集合的创建方法有两种，一种是用&#123;&#125;创建，另一种是set()或frozenset()函数创建，其中frozenset()是不可变的集合。\r\nset()和frozenset()的参数必须是可迭代对象，且该对象中元素必须为可哈希对象。\r\n\r\n集合添加元素\r\n\r\nset.add() ——添加单个元素\r\nset.update() ——可添加多个元素\r\n\r\na = &#123;1, 2, 3&#125;a.add(&#x27;world&#x27;)  ##添加一个元素print(id(a),a)a.update(&#x27;world&#x27;)print(id(a),a)# a.update([99,22,33])# 顺序是随机的# print(a)\r\n集合删除元素\r\n\r\nset.remove() ——一次只能删除一个元素，若删除的元素不存在则会报错\r\nset.discard() ——一次只能删除一个元素，若删除的元素不存在不报错\r\nset.pop() ——默认删除第一个元素\r\nset.clear() ——清空集合元素\r\n\r\n#1.remove一次只能删除一个元素，删除的元素不存在则会报错r = &#123;&#x27;清风&#x27;,&#x27;明月&#x27;,20,28&#125;# r.remove(282)# print(&#x27;remove:&#x27;,r)#2.discard一次只能删除一个元素，删除的元素不存在不报错# r.discard(28)# print(&#x27;discard:&#x27;,r)#3.pop默认删除第一个元素p = &#123;90,1,2,3,5&#125;print(p)p.pop()print(p)#4.clear是清空集合元素a = &#123;&#x27;happy&#x27;,&#x27;new&#x27;,123&#125;a.clear()print(a)    #为什么返回的是一个set()呢，而不是&#123;&#125;呢？\r\n集合类型操作符（用于可变集合和不可变集合）\r\n\r\n集合等价/不等价： ==、!=\r\n（只要它们包含相同的元素，比较就会返回 True）\r\n子集/超集判定：\r\n&lt;、&lt;=、&gt;、&gt;=\r\n\r\n#1.集合的等价、不等价\r\n\r\nset(&#x27;book&#x27;) == frozenset(&#x27;book&#x27;)# True\r\n集合的数学操作\r\n\r\n交集 “&amp;” “set1.intersection(set2)”\r\n并集 “|” “set1.union(set2)”\r\n差集 “-” “set1.difference(set2)”\r\n对称差集 “^” “set1.symmetric_difference(set2)”\r\n\r\ns = set(&#x27;abcde&#x27;)t = frozenset(&#x27;defgh&#x27;)print(s &amp; t)print(s | t)print(s - t)#返回存在于s中但不在t中的元素print(s ^ t)#返回s和t中不同的元素，去除了重复元素s = set(&#x27;abcde&#x27;)t = frozenset(&#x27;defgh&#x27;)print(s.intersection(t))print(s.union(t))print(s.difference(t))print(s.symmetric_difference(t))\r\n其他的集合常用方法：\r\n\r\ns.issubset(t) # 如果s是t的子集，返回True\r\ns.issuperset(t) # 如果s是t的超集，返回True\r\n\r\n#如果集合 A 中的所有元素都在集合 B 中，那么集合 A 被称为集合 B 的子集。# 定义两个集合A = &#123;1, 2, 3&#125;B = &#123;1, 2, 3, 4, 5&#125;# 检查 A 是否是 B 的子集is_subset = A.issubset(B)print(is_subset)  # 输出：True#如果集合 B 中的所有元素都在集合 A 中，那么集合 A 被称为集合 B 的超集。# 定义两个集合A = &#123;1, 2, 3, 4, 5&#125;B = &#123;1, 2, 3&#125;# 检查 A 是否是 B 的超集is_superset = A.issuperset(B)print(is_superset)  # 输出：True\r\nPython数据类型之字典\r\n\r\n是一种以键值对为元素的无序组合，键和值之间用冒号隔开，字典元素之间以逗号隔开。\r\n创建方法：\r\n\r\n\r\n显式的直接创建\r\n使用类型构造函数\r\n\r\n字典是Python中一种映射数据结构，映射是根据键（key）查找其映射值（value）的过程。\r\n\r\n字典中的键（key）必须是可哈希对象\r\n可哈希对象：bool、int、float、complex、str、tuple、frozenset\r\n\r\n显式的直接创建\r\n\r\n使用花括号&#123;&#125;创建字典，各元素之间用逗号隔开。\r\n\r\n#1. 创建一个空字典,使用 dict() 函数创建空字典empty_dict_2 = dict()#2. 用&#123;&#125;创建，按照字典形式添加元素empty_dict_1 = &#123;&#125;#3. 键（key）必须是可哈希对象（数值型、字符串、元组(元素也必须为可哈希)、frozenset）# 数值型作为键num_dict = &#123;1: &#x27;one&#x27;, 2: &#x27;two&#x27;&#125;# 字符串作为键str_dict = &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;# 元组作为键（元组内的元素也必须为可哈希对象）tuple_dict = &#123;(1, 2): &#x27;pair&#x27;, (&#x27;a&#x27;, &#x27;b&#x27;): &#x27;another pair&#x27;&#125;# frozenset 作为键frozenset_dict = &#123;frozenset([1, 2]): &#x27;frozenset example&#x27;&#125;#4. 字典的键（key）出现多次的情况# 创建一个字典my_dict = &#123;&#125;# 添加一些键值对my_dict[&#x27;key1&#x27;] = &#x27;value1&#x27;my_dict[&#x27;key2&#x27;] = &#x27;value2&#x27;my_dict[&#x27;key1&#x27;] = &#x27;new value1&#x27;  # 这里的 &#x27;key1&#x27; 会覆盖之前的 &#x27;key1&#x27;\r\n字典中键的规则\r\n\r\n不允许一个键对应多个值\r\n键必须是可哈希的（列表、字典这样的可变类型是不可哈希的，所以不能作为键）\r\n所有不可变类型都是可哈希的（不可包含可变元素），都可以作为字典的键，但字典中的键通常是字符串\r\ndict(元组)、dict(列表)里面的元素必须为序列，且子序列中元素顺序要满足键值对的顺序。\r\n\r\nPython中的不可变数据类型默认是可哈希的，包括：\r\n\r\n整数（int）\r\n浮点数（float）\r\n布尔值（bool）\r\n字符串（str）\r\n元组（tuple）（注意，元组中的所有元素也必须是可哈希的）\r\n冰冻集合（frozenset）（冰冻集合本身是可哈希的，但它是不可变的集合类型）\r\n\r\n相反，以下数据类型是不可哈希的，因此不能用作字典的键或添加到字典中：\r\n\r\n列表（list）\r\n集合（set）\r\n字典（dict）\r\n\r\n类型构造函数dict()创建字典\r\n\r\ndict(键=值)\r\ndict(元组)\r\ndict(列表)\r\n\r\ndict_0 = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;# dict(键=值) dict_1 = dict(four=2)dict_0 = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;#dict(元组) dict_2 = dict((&#x27;o1&#x27;,&#x27;t2&#x27;,&#x27;h3&#x27;))print(dict_2)dict_0 = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;#dict(列表)dict_3 = dict([&#x27;o1&#x27;,&#x27;t2&#x27;,&#x27;h3&#x27;])print(dict_3)\r\n使用fromkeys() 创建字典\r\ndict.fromkeys(iterable, value)\r\n\r\n用一个可迭代对象作为字典的键\r\n第二个参数用来设置字典每个键值对的值，如果忽略的话值默认为None\r\n\r\ndict7 = &#123;&#125;.fromkeys((&#x27;x&#x27;, &#x27;y&#x27;), 1)  # 给所有key一个默认值dict8 = dict.fromkeys(&#123;&#x27;x&#x27;,1,2,3&#125;,2)print(dict7)print(dict8)\r\n# 现有一个列表list_1，要求把list_1的重复元素去掉，返回一个新列表list_2，新列表中的元素保持在原列表中首次出现的相对顺序。不要使用循环和推导式。def remove_duplicates(list_1):    return list(dict.fromkeys(list_1))#使用 dict.fromkeys() 方法来移除列表中的重复元素。这个方法利用了字典键的唯一性来自动移除重复的元素。list_1 = [1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]list_2 = remove_duplicates(list_1)print(list_2) \r\n字典元素的增加和修改\r\n\r\n字典变量名[key] = value\r\n如果key不存在则为字典增加一项，如果key存在则修改对应的value值。\r\n\r\n#元素增加dic = &#123;&quot;name&quot;:&quot;高山流水&quot;, &quot;age&quot;: &quot;2&quot;&#125;dic[&quot;sex&quot;]=&quot;girl&quot;print(dic)#元素修改dic[&quot;age&quot;]=3dic[&quot;sex&quot;]=&quot;boy&quot;print(dic)# &#123;&#x27;name&#x27;: &#x27;高山流水&#x27;, &#x27;age&#x27;: &#x27;2&#x27;, &#x27;sex&#x27;: &#x27;girl&#x27;&#125;# &#123;&#x27;name&#x27;: &#x27;高山流水&#x27;, &#x27;age&#x27;: 3, &#x27;sex&#x27;: &#x27;boy&#x27;&#125;\r\n删除指定key对应的value\r\n\r\ndel 字典变量名[key]\r\n\r\ndel dic[&quot;name&quot;]print(dic)# &#123;&#x27;age&#x27;: 3, &#x27;sex&#x27;: &#x27;boy&#x27;&#125;\r\n字典的查询\r\n\r\n根据键名查询\r\n查询所有的键名\r\n查询所有键的值\r\n查询所有键值对\r\n\r\n# 1.根据键名查询dic[&quot;age&quot;]print(dic[&quot;age&quot;])#2.查询所有的键名dic.keys()print(dic.keys())#3.查询所有键的值dic.values()print(dic.values())#4.dic.items() 返回的迭代器中的每个元素都是一个键值对，形式为 (key, value)dic_i = dic.items()print(dic_i)for key, value in dic_i:    print(key, value)\r\n函数接收一个任意字符串s，要求返回其中只出现了1次的字符组成的新字符串，每个字符保持原来的相对顺序。例如，s为’Beautiful\r\nis better than ugly.’时返回’Bfsbrhngy.’\r\ndef unique_chars(s):    char_count = &#123;&#125;    for char in s:        if char in char_count:            char_count[char] += 1        else:            char_count[char] = 1    result = &#x27;&#x27;    for char in s:        if char_count[char] == 1:            result += char    return results = &#x27;Beautiful is better than ugly.&#x27;print(unique_chars(s))  # 输出：&#x27;Bfsbrhngy.&#x27;\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python常用模块之正则表达式与时间日期模块","url":"/posts/24790.html","content":"Python的模块、包和库\r\n\r\n模块（Module）通常以.py为扩展名，可以被其他程序通过import语句导入使用。\r\n包（Package）包含多个模块，必须包含一个特殊的__init__.py文件，这个文件可以为空，但它的存在表明这个目录可以被作为一个包来使用。\r\n库（Library）是一组完成特定功能的模块或包的集合，第三方库是Python强大生态系统的重要组成部分，它们提供了各种各样的工具和框架，使得Python成为一个功能丰富的编程语言。\r\n\r\nre模块\r\n\r\n使用 re\r\n模块来处理正则表达式，正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。\r\n\r\n简单的正则\r\n\r\n.：匹配除换行符 外的任意一个字符。\r\n\r\n^：匹配字符串的开头。\r\n$：匹配字符串的结尾。\r\n*：匹配前一个字符的0次或多次重复。\r\n+：匹配前一个字符的1次或多次重复。\r\n?：匹配前一个字符的0次或1次重复。\r\n{}：指定匹配次数的范围。\r\n[]：匹配方括号内的任意一个字符。注意：^放在[]内部时表示取反。\r\n：转义字符，用于匹配特殊字符本身。\r\n|：逻辑或，匹配两个模式中的任意一个。\r\n()：分组，用于限定匹配范围或指定优先级。\r\n\r\n字符类正则\r\n\r\n匹配任何十进制数字，等价于字符类 [0-9] 。\r\n：匹配任何非数字字符，等价于字符类 [^0-9] 。\r\n：匹配任何空白字符（空格），等价于字符类 [ 。\r\n：匹配任何非空白字符（不是空格），等价于字符类 [^ 。\r\n：匹配任何字母、数字、下划线字符，等价于字符类 [a-zA-Z0-9_] 。\r\n：匹配任何非字母、数字、下划线字符，等价于字符类 [^a-zA-Z0-9_]\r\n。\r\n\r\n应用实例：\r\n\r\n用户名验证：要求用户名只包含字母、数字和下划线\r\n密码格式验证：要求密码长度为8-12个字符\r\n手机号码验证：要求中国大陆的手机号码格式\r\n\r\nimport reresult=re.match(r&#x27;\\w+&#x27;,&#x27;455hj5h6_&#x27;)print(result)result1=re.match(r&#x27;^.&#123;8,12&#125;$&#x27;,&#x27;455hj5456&#x27;)print(result1)result2=re.match(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;13755452515&#x27;)print(result2)\r\n正则表达式的应用\r\n\r\n数据清理：通过删除或替换不需要的字符、空格或符号来清理数据集。\r\n文本规范化：将文本数据标准化为一致的格式，例如将日期转换为标准格式或统一数值的表示。\r\n特征提取：从文本中提取可用作 ML 模型特征的特定模式或标记。\r\n数据验证：确保输入数据在输入模型之前符合指定的格式。\r\n标记化：将文本分割成单词、短语、符号或其他称为标记的有意义的元素。\r\n文本分类预处理：文本分类的预处理步骤，例如从社交媒体帖子中提取主题标签或提及。\r\n命名实体识别\r\n(NER)：识别文本中的关键元素并将其分类为预定义的类别，例如人名、组织或位置的名称。\r\n情绪分析：识别可能表明情绪的特定短语或符号。\r\n自动响应的模式匹配：识别客户查询或反馈中的模式以生成自动响应。\r\n搜索和信息检索：增强数据集中的搜索算法，以根据模式匹配查找信息或对信息进行分类。\r\n\r\n正则表达式编译成对象\r\n\r\nre\r\n模块提供了正则表达式引擎的接口，可以让你将正则编译为对象，然后用它们来进行匹配。\r\n\r\nimport rep = re.compile(&#x27;abv?&#x27;)r=p.match(&#x27;abvvvccabvvvc&#x27;)print(r)\r\n正则表达式对象常用的方法-查找\r\n\r\nmatch()：从字符串的开头匹配，返回一个匹配成功的字符串\r\nimport rep = re.compile(&#x27;abv?&#x27;)m_m = p.match(&#x27;abvvvccabvvvc&#x27;)print(m_m)#相当于，等价于m_rm = re.match(&#x27;abv?&#x27;, &#x27;abvvccabvvvc&#x27;)print(m_rm)\r\nsearch()：扫描整个字符串，返回一个匹配成功的字符串。\r\nimport rep = re.compile(&#x27;abv?&#x27;)m_p = p.search(&#x27;vvccabvvvc&#x27;)print(m_p)#相当于，等价于m_rp = re.search(&#x27;abv?&#x27;, &#x27;vvccabvvvc&#x27;)print(m_rp)\r\nmatch和search的区别：\r\n\r\nmatch是从头开始匹配的，如果没有则匹配失败\r\nsearch是匹配整个字符串，没有位置限定\r\n\r\nfindall()：找到正则匹配的所有子字符串，返回字符串列表。\r\np1 = re.compile(r&#x27;\\d+&#x27;)m_f = p1.findall(&#x27;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#x27;)print(m_f)##相当于，等价于m_rf = re.findall(r&#x27;\\d+&#x27;, &#x27;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#x27;)print(m_rf)\r\nfinditer()：找到正则匹配的所有子字符串，并将它们返回为一个迭代器iterator。\r\n\r\niterator_f = p1.finditer(&#x27;12 drummers drumming, 11 ... 10 ...&#x27;)print(iterator_f)for m in iterator_f:    print(m.span())    #相当于，等价于    iterator_rf = re.finditer(r&#x27;\\d+&#x27;, &#x27;12 drummers drumming, 11 ... 10 ...&#x27;)print(iterator_rf)for mr in iterator_rf:    print(mr.span())\r\n正则表达式对象常用的方法-替换\r\n\r\nre.sub(pattern, repl, string, count=0,\r\nflags=0)：返回已替换的字符串中的匹配项。\r\nre.subn(pattern, repl, string, count=0,\r\nflags=0)：返回一个元组，元组的第一项为替换的字符串，第二项为替换了几处。\r\n\r\ntext = &quot;aBc,ABC,aBfD&quot;result = re.sub(&#x27;aBc?&#x27;, &#x27;***&#x27;, text)print(result)result_n = re.subn(&#x27;aBc?&#x27;, &#x27;***&#x27;, text)print(result_n)\r\n正则表达式对象常用的方法-分割\r\n\r\nre.split(pattern, string, maxsplit=0,\r\nflags=0)：返回根据指定的正则表达式分割后的字符串\r\n\r\nstext =  &#x27;and,  Act %  Bar。 fooD&#x27;result_s = re.split(r&#x27;\\s*[,%。]\\s*&#x27;, stext)print(result_s)\r\n输出正则表达式对象的值和位置\r\n\r\nm.group()：返回正则匹配的字符串\r\nm.start()：返回匹配的开始位置\r\nm.end()：返回匹配的结束位置\r\nm.span()：返回包含匹配 (start, end) 位置的元组\r\n\r\nm2 = m_m.group()print(m2)m22 = m_rm.group()print(m22)# m3 = m_m.start()# print(m3)\r\n正则表达式方法中的flags参数\r\n\r\nre.I(re.IGNORECASE)：忽略大小写。\r\nimport repattern = r&#x27;hello&#x27;text = &#x27;Hello, World!&#x27;match = re.search(pattern, text, flags=re.I)print(match.group())# Hello\r\nre.S(re.DOTALL)：使 . 匹配任意字符，包括换行符。\r\nimport repattern = r&#x27;hello.+world&#x27;text = &#x27;&#x27;&#x27;helloworld&#x27;&#x27;&#x27;match = re.search(pattern, text, flags=re.s)print(match.group()) # hello# world\r\nre.M(re.MULTILINE)：多行匹配，影响 ^ 和 $ 的行为。\r\nimport re# text = &#x27;123\\n456\\n789&#x27;text = &#x27;&#x27;&#x27;123456789&#x27;&#x27;&#x27;result = re.findall(r&#x27;^\\d+&#x27;, text, flags=re.MULTILINE)print(result)  # [&#x27;123&#x27;, &#x27;456&#x27;, &#x27;789&#x27;]\r\nre.X(re.VERBOSE)：忽略正则表达式中的空白和注释。\r\nimport repattern = re.compile(r&#x27;&#x27;&#x27;    \\d+  # 匹配数字    [a-z]+  # 匹配小写字母&#x27;&#x27;&#x27;, flags=re.VERBOSE)result = pattern.match(&#x27;123abc&#x27;)print(result.group())  # 123abc\r\n\r\n贪婪匹配和惰性匹配\r\n\r\n贪婪匹配（Greedy）是正则表达式默认的匹配方式，它尽可能地匹配最长的字符串。\r\n懒惰匹配（Lazy），也称为非贪婪匹配，它尽可能地匹配最短的字符串。\r\n\r\nimport rep = &quot;讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 https://xinghuo.xfyun.cn/ 2024-04-11 10:07:25&quot;#贪婪匹配G = re.match(r&#x27;讯飞.*大模型&#x27;, p)print(G.group())#懒惰匹配L = re.match(r&#x27;讯飞.*?大模型&#x27;, p)print(L.group())# 讯飞星火认知大模型-AI大语言模型-星火大模型# 讯飞星火认知大模型\r\n综合案例：\r\n处理数据集：用正则表达式将所有的文本数据中的逗号替换成空格，文本文件为‘re.txt’\r\nimport rewith open(input_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:    content = f.read()        # 使用正则表达式替换逗号processed_content = re.sub(r&#x27;,&#x27;, &#x27; &#x27;, content)        # 写入新文件with open(output_file, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f.write(processed_content)\r\n用正则式匹配身份证号\r\nimport re&#x27;&#x27;&#x27;各部分说明：[1-9]\\d&#123;5&#125;: 地区码，第一位不能为0(19|20): 年份前两位\\d&#123;2&#125;: 年份后两位(0[1-9]|1[0-2]): 月份01-12(0[1-9]|[12]\\d|3[01]): 日期01-31\\d&#123;3&#125;: 序号[0-9Xx]: 校验码&#x27;&#x27;&#x27;res=re.match(r&#x27;^[1-9]\\d&#123;5&#125;(19|20)\\d&#123;2&#125;(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;[0-9Xx]$&#x27;,&#x27;110101199003079833&#x27;)print(res)\r\ntime（时间）模块与\r\ndatetime（日期）模块\r\ntime（时间）模块\r\n\r\nUTC时间：世界时间\r\n本地时间：本地区的时间（东8区）\r\ntime模块：https://docs.python.org/3/library/time.html#module-time\r\ndatetime模块：https://docs.python.org/3/library/datetime.html#\r\n\r\nimport time#时间戳timestamp = time.time()print(timestamp) #1970年1月1日0时0分0秒（UTC时间）到当前时间的秒数\r\n时间戳一般用于计算时间差的\r\n#控制程序的执行速度或者模拟耗时操作print(&quot;某主播说：家人们，马上开始下福袋雨了啊！&quot;)time.sleep(3)print(&quot;福袋1发布&quot;)time.sleep(3)print(&quot;福袋2发布&quot;)time.sleep(3)print(&quot;福袋3发布&quot;)time.sleep(3)print(&quot;福袋4发布&quot;)\r\ndatetime（日期）模块\r\ndatetime 是 Python\r\n内置的用于处理日期和时间的模块，提供了多种类和方法来操作时间数据。\r\nfrom datetime import datetimet = datetime.now()print(t, type(t))   #注意这里的时间不是字符串，是一个datetime类型\r\n# 获取 datetime 对象的各个部分print(t.year)    # 年：2025print(t.month)   # 月：5print(t.day)     # 日：14print(t.hour)    # 时：14print(t.minute)  # 分：30print(t.second)  # 秒：22\r\ntimedelta 表示两个 datetime\r\n对象之间的时间差，可用于时间的加减运算。\r\nfrom datetime import datetime,timedeltav1 = datetime.now()print(v1, type(v1)) #时间的相加（datetime + timedelta）v2 = v1 + timedelta(days=15, minutes=5)print(v2, type(v2))\r\n\r\ndatetime类型可以相加吗？等于什么？ datetime 对象本身不能直接相加\r\n但可以和 timedelta 对象相加，结果是一个新的 datetime 对象\r\ndatetime类型可以相减吗？等于什么？ datetime 可以减去另一个\r\ndatetime，得到 timedelta 对象（表示时间差） datetime 也可以减去\r\ntimedelta，得到新的 datetime 对象\r\n\r\n使用\r\nstrftime 方法将 time 对象 和 datetime 对象格式化为字符串\r\n\r\n%Y：大写 Y 代表四位数的年份（例如，2023）； %y：小写 y\r\n代表两位数的年份（例如，23）。\r\n%m：小写 m 代表月份（01到12）。\r\n%d：小写 d 代表月份中的一天（01到31）。\r\n%H：大写 H 代表小时（24小时制，00到23）。\r\n%M：大写 M 代表分钟（00到59）。\r\n%S：大写 S 代表秒（00到59）。\r\n\r\nfrom datetime import datetime, timedeltad1 = datetime.now()print(d1) dstr = d1.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)print(dstr)import timecurrent_time = time.localtime()  # 获取当前时间print(current_time, type(current_time))tstr = time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;, current_time)print(tstr)\r\n日期解析（strptime）\r\n解析（str →\r\ndatetime）：\r\ndate_str = &quot;2025-05-14 14:30:22&quot;parsed = datetime.strptime(date_str, &quot;%Y-%m-%d %H:%M:%S&quot;)  # 转为 datetimeprint(parsed, type(parsed))  # 输出：2025-05-14 14:30:22 &lt;class &#x27;datetime.datetime&#x27;&gt;\r\n时区处理\r\n默认的 datetime\r\n对象是无时区信息的（tzinfo=None）。如需处理时区，可使用\r\npytz 或 Python 3.9+ 内置的 zoneinfo 模块：\r\nfrom datetime import datetimefrom zoneinfo import ZoneInfo  # Python 3.9+# 创建带时区的 datetime 对象now_utc = datetime.now(ZoneInfo(&quot;UTC&quot;))now_shanghai = datetime.now(ZoneInfo(&quot;Asia/Shanghai&quot;))print(now_utc.tzinfo)    # 输出：UTCprint(now_shanghai)      # 输出：2025-05-14 22:30:22+08:00\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的文件操作","url":"/posts/31408.html","content":"Python的文件操作\r\n\r\n文件的打开与关闭\r\n文件的读取与写入\r\n\r\n文件的打开\r\n\r\n内置函数：open(文件名, 模式)\r\nos模块的函数：os.open(文件名, 模式)\r\nwith open(文件名, 模式) as file\r\n\r\n文件的关闭\r\n\r\nfileobject.close() fileobject是文件对象\r\nos.close(file) 关闭文件\r\n\r\nfile_1 = open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;)print(&#x27;file_1---&#x27;, file_1, type(file_1))#关闭文件之后，python才能释放对该文件的控制，可以去尝试删除该文件file_1.close()\r\n默认的文件编码encoding一般依赖于系统的区域设置和Python的版本。\r\ncp936代表GBK编码\r\n标准编码参考：https://docs.python.org/3/library/codecs.html\r\nimport io    #io.open()是内置函数open的别名，本质是一样的file = io.open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;)print(&#x27;file---&#x27;, file, type(file))\r\nimport osfile_2 = os.open(&#x27;file_2.txt&#x27;, os.O_RDWR|os.O_CREAT) #os.O_RDONLYprint(&#x27;file_2--&#x27;, file_2, type(file_2))os.close(file_2)# os.remove(&#x27;file_2.txt&#x27;)\r\n区别：\r\n\r\nopen()函数返回的是一个文件对象，而os.open()函数返回的是一个文件描述符（即整数）。\r\npython内置的open()函数主要用于处理文本文件，而os.open()函数主要用于处理二进制文件和低级文件操作。\r\n\r\n使用with语句即python的上下文管理器，它可以自动关闭文件，而用open()函数则需要手动关闭文件。\r\nwith open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;rb+&#x27;) as f:    content = f.read()    print(content)\r\n文件的打开模式\r\n\r\n‘r’：只读模式\r\n‘w’：覆盖写模式，不存在则创建，存在则完全覆盖\r\n‘a’：追加写模式，不存在则创建，存在则在文件最后追加内容\r\n‘x’：排他性创建模式：如果文件不存在，创建并打开写模式的文件。如果文件已存在，操作将失败。\r\n‘b’：二进制文件模式\r\n‘+’：在原功能基础上增加同时读写功能，可与r/w/a组合。\r\n\r\n思考下列代码分别属于什么打开模式：\r\n\r\nopen(‘file.txt’, ‘w’) 写入模式\r\nopen(‘file.txt’, ‘w+’) 读写模式\r\nopen(‘file.txt’, ‘rb’) 二进制读取模式\r\nopen(‘file.txt’, ‘rb+’) 二进制读写模式\r\n\r\n文件的读取与写入\r\n\r\nread()读取文件内容\r\nreadline()返回文件的一行内容，格式为字符串\r\nreadlines()返回文件所有行内容，格式为列表\r\nwrite()写入文件内容\r\nwritelines()将一个字符串列表写入文件\r\n\r\n#read()读取文件内容with open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;) as f:    content = f.read()    print(content)\r\n#readline()读取一行内容f = open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;)print(f.readline(5))# while True:#     line = f.readline()  #f.readline(4) 读取前几个字符#     if not line:#         break#     print(line, type(line))\r\n#readlines()逐行读整个文件内容，包括换行符with open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;) as f:    fa = f.readlines()    print(fa, type(fa))\r\n# w覆盖写入，write()参数必须为字符串，如果想换行，必须加上换行符\\nwith open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;w&#x27;) as file:    file.write(&#x27;Hello, World!&#x27;)\r\n# 写入字符串列表，如果想换行，必须加上换行符\\nwith open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;w&#x27;) as file:    lines = [&#x27;Hello,\\n&#x27;, &#x27;World2!&#x27;,&#x27;black Monkey&#x27;]  #\\n    file.writelines(lines)\r\n绝对路径和相对路径\r\n\r\n绝对路径是从根目录开始的完整路径。它提供了到达指定文件或目录的具体位置，不依赖于当前工作目录的位置。\r\n系统中的绝对路径E:\\jupyter\\python，python中的绝对路径r\"E:\\jupyter\\python\"或者E:/jupyter/python或者E:\\\\jupyter\\\\open\r\n相对路径是相对于当前工作目录的路径。它通过相对位置来指定文件或目录，简化了路径的表达，但其具体位置依赖于当前的工作目录。\r\n\r\nos模块常用的路径操作\r\n\r\n获取当前路径名\r\n#1.获取当前路径名import osprint(os.getcwd())print(os.path.abspath(os.curdir))  #返回绝对路径 os.path.abspath \r\n获取父目录路径名\r\nprint(os.path.dirname(&#x27;../python/6.1 Python的文件操作.ipynb&#x27;))print(os.path.dirname(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;, &#x27;op&#x27;, &#x27;file.txt&#x27;)))\r\n返回指定路径下的文件和目录列表\r\n#3. 返回指定路径下的文件和目录列表#&#x27;.&#x27;或&#x27;./&#x27;代表当前路径   #&#x27;..&#x27;或&#x27;../&#x27;代表上一级路径print(os.listdir(&#x27;..&#x27;))   \r\n创建目录\r\n#4.在当前文件夹下创建单层目录os.mkdir(&#x27;new1123&#x27;)\r\n合并两个或多个路径名组件\r\nimport os#5. 合并两个或多个路径名组件print(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;))#合并一个没有的目录，需要重新创建目录# os.mkdir(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;))print(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;,&#x27;./&#x27;, &#x27;file.txt&#x27;))with open(&#x27;new1123&#x27;, &#x27;w&#x27;) as fs:    fs.write(&#x27;111222333&#x27;)\r\n统一规范化路径分隔符\r\n#6.统一规范化路径分隔符file_op = os.path.join(&#x27;../&#x27;, &#x27;open&#x27;,&#x27;./&#x27; , &#x27;file.txt&#x27;)uni_op = file_op.replace(os.sep, &#x27;/&#x27;)  #直接对字符串进行替换normalized_path = os.path.normpath(file_op)  #用方法规范化print(uni_op) print(normalized_path) \r\n判断文件是否存在\r\n#7.判断文件是否存在if os.path.exists(&#x27;F:\\\\file_2.txt&#x27;):    print(&#x27;yes&#x27;)else:    print(&#x27;no&#x27;)\r\n\r\n更多的os操作请查看官方文档：https://docs.python.org/3/library/os.html#module-os\r\ncsv格式文件的读取和写入\r\n\r\ncsv是逗号分隔符文本格式，常用于Excel和数据库的数据导入和导出。\r\ncsv的读取：csv.reader(csvfile, dialect='excel', **fmtparams)#csvfile文件对象；dialect指定csv格式；fmtparams用于指定特定格式覆盖dialect的格式\r\ncsv.reader()创建的是可迭代对象\r\n\r\n#csv的读取import csvwith open(&#x27;F:\\\\stu.csv&#x27;) as f:    f_csv = csv.reader(f)        for row in f_csv:        print(row)\r\n\r\ncsv的写入：csv.writer(csvfile, dialect='excel', **fmtparams)\r\ncsv文件.writerow(row) #写入一行\r\ncsv文件.writerows(rows) #写入多行\r\n\r\nheader = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;sex&#x27;, &#x27;work&#x27;]datas = [[&#x27;8090&#x27;, &#x27;juney&#x27;, &#x27;male&#x27;, &#x27;teacher&#x27;],[&#x27;8091&#x27;, &#x27;marry&#x27;, &#x27;female&#x27;, &#x27;nurse&#x27;]]with open(&#x27;F:\\\\stu.csv&#x27;, &#x27;w&#x27;) as f:    w_csv = csv.writer(f)    w_csv.writerow(header)    w_csv.writerows(datas)\r\n在Windows上的换行符为\\r\\n，而在Linux和MacOS上的换行符为\\n。\r\nopen()中有个参数’newline’控制如何处理换行符。\r\n可令newline=''\r\n此参数在不同操作系统间提供一致的换行符处理，避免了跨平台文本文件处理中的问题。\r\nnewline参数只对文本模式有效，对二进制模式无效。\r\nheader = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;sex&#x27;, &#x27;work&#x27;]datas = [[&#x27;8090&#x27;, &#x27;juney&#x27;, &#x27;male&#x27;, &#x27;teacher&#x27;],[&#x27;8091&#x27;, &#x27;marry&#x27;, &#x27;female&#x27;, &#x27;nurse&#x27;]]with open(&#x27;F:\\\\stocks1.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as f:    w_csv = csv.writer(f)    w_csv.writerow(header)    w_csv.writerows(datas)\r\n读取’green_red’文件夹下的’train’文件夹，然后读取里面的csv文件，把里面的前10行数据放到新的列表中。\r\nimport csvwith open(&#x27;green_red/train/Glass_train.csv&#x27;, &#x27;r+&#x27;) as fcsv:    fs = csv.reader(fcsv)    li_fs = list(fs)    li_csv = []    for i, v in enumerate(li_fs):        li_csv.append(li_fs[i])        if i == 9:            break        print(li_csv)  \r\n对象序列化和pickle模块\r\n\r\n序列化是Python对象转换为数据格式，以便在不同的环境中存储、传输和重建。\r\n反序列化是从磁盘文件或所接收到的数据形式恢复，得到相应对象的过程。\r\n对象序列化广泛用于各种分布式并行处理系统。\r\npickle模块可以实现对象的序列化。\r\n\r\nimport pickle#序列化data = &#123;&#x27;key&#x27;: &#x27;value&#x27;, &#x27;num&#x27;: 123&#125;# 对象转换为字节流，&#x27;b&#x27;代表二进制模式with open(&#x27;data.pickle&#x27;, &#x27;wb&#x27;) as file:    # 使用pickle的dump函数将数据序列化并保存到文件    pickle.dump(data, file)    #反序列化with open(&#x27;data.pickle&#x27;, &#x27;rb&#x27;) as file:    # 使用pickle的load函数从文件加载数据    data_loaded = pickle.load(file)print(data_loaded)\r\n应用实例：\r\n\r\n将一个整数列表[1, 2, 3, 4,\r\n5]序列化到一个名为numbers.pkl的文件中。\r\n从numbers.pkl文件中反序列化该列表，并将其打印出来。\r\n\r\nimport pickle# 要序列化的整数列表numbers_list = [1, 2, 3, 4, 5]# 序列化整数列表到文件 numbers.pkl 中with open(&#x27;numbers.pkl&#x27;, &#x27;wb&#x27;) as file:    # 使用 pickle.dump 函数将列表序列化并保存到文件    pickle.dump(numbers_list, file)    print(&quot;列表已序列化到文件 numbers.pkl 中。&quot;)# 从文件 numbers.pkl 中反序列化列表with open(&#x27;numbers.pkl&#x27;, &#x27;rb&#x27;) as file:    # 使用 pickle.load 函数从文件加载并反序列化列表    loaded_numbers_list = pickle.load(file)    print(&quot;列表已从文件 numbers.pkl 中反序列化。&quot;)    print(&quot;反序列化后的列表内容：&quot;, loaded_numbers_list)\r\n文件的筛选：\r\n\r\nfile.endswith() #以…结尾的文件名\r\nfile.startswith() #以…开始的文件名\r\n\r\n# 假设我们有一个文件名列表filenames = [&#x27;example.txt&#x27;, &#x27;data.csv&#x27;, &#x27;image.png&#x27;, &#x27;notes.txt&#x27;]# 筛选出所有以 &#x27;.txt&#x27; 结尾的文件text_files = [file for file in filenames if file.endswith(&#x27;.txt&#x27;)]print(text_files)\r\n# 假设我们有一个文件名列表filenames = [&#x27;report2024.txt&#x27;, &#x27;summary2024.csv&#x27;, &#x27;image2024.png&#x27;, &#x27;notes2024.txt&#x27;]# 筛选出所有以 &#x27;report&#x27; 开始的文件report_files = [file for file in filenames if file.startswith(&#x27;report&#x27;)]print(report_files) \r\nPython的异常捕获\r\n错误与异常\r\n错误\r\n\r\n错误（Error）可以分为语法错误和逻辑错误，当运行时出现报错信息，此时就产生了异常（Exception）。\r\n#语法错误在编译阶段就会报错def op(a): a = 1list([1,2,3)\r\n\r\n异常\r\n\r\n程序运行时检测到的错误称为异常，异常不一定导致严重的后果，而是显示错误信息。\r\n\r\nPython中常见的异常\r\n更多的内置异常类请参考官方文档：https://docs.python.org/3/library/exceptions.html#index-2\r\n\r\nNameError：尝试访问一个未声明的变量\r\nZeroDivisionError：除数为0\r\nSyntaxError：解释器语法错误\r\nIndexError：请求的索引超出序列范围\r\nTypeError：类型错误\r\nKeyError：请求一个不存在的字典键\r\nFileNotFoundError：请求不存在的文件或目录时\r\nFileExistsError：创建一个已经存在的文件或目录时\r\n\r\n异常处理\r\n\r\ntry-except语句\r\n\r\ntry:    try_suite   # 检测是否有异常except exceptiontype:    except_suite  # 异常处理代码\r\n\r\n首先，执行 try 子句，如果没有触发异常，则跳过 except 子句，try\r\n语句执行完毕。\r\n如果在执行 try\r\n子句时发生了异常，则跳过该子句中剩下的部分。判断异常类型与 except\r\n指定的异常是否匹配，若匹配则会执行 except\r\n子句。若不匹配，异常就会被递交至上一级，也就是由该段代码的调用者去处理。如果最后还是无法解决的话，就会出现错误，导致程序崩溃。\r\nexcept可以有不同的异常类型，但最多只有一个处理程序会被执行。第一个匹配到的异常类型将被处理，其他匹配到的异常类型将不会被处理。\r\n\r\nexcept (RuntimeError, TypeError, NameError):    pass\r\n\r\n如果想要处理所有匹配到的异常类型，并且在每个异常类型中执行不同的代码，可以使用多个except语句，每个语句处理一个特定的异常类型。\r\n\r\ntry:    passexcept RuntimeError:    return &quot;RuntimeError occurred&quot;except TypeError:    return &quot;TypeError occurred&quot;except NameError:    return &quot;NameError occurred&quot;\r\ntry:    import mathp    type_e = float(25)    s = math.sqrt(type_e)except (ImportError, TypeError):    print(&quot;发生了一个异常&quot;)    # import math# type_e = float(2)# s = math.sqrt(type_e)# print(s)#放到try-except里try:    import mathoo    type_e = float(2)    s = math.sqrt(type_e)except TypeError:    print(&#x27;🐖🐖🐖float-TypeError&#x27;)except ImportError:    print(&#x27;🐇🐇🐇import-ImportError&#x27;)    print(s)\r\n2.try-except-else语句\r\ntry:    try_suite   # 检测是否有异常except exceptiontype as name:    except_suite  # 异常处理代码else:    else_suite   #没有发生异常时执行\r\ndef divide(x, y):    try:        y -= 1        result = x / y    except Exception as e:        return e    else:        return result        print(divide(3, 1))print(divide(3, 3))\r\n\r\ntry-finally 语句\r\n\r\ntry:    ...finally:    ...\r\n\r\ntry-except-else-finally语句\r\n\r\ntry:    ...except MyException:    ...else:    ...finally:    ...\r\n无论异常是否发生，无论异常是否被捕捉到，finally后的语句块一定会被执行。\r\n#不管try返回了什么值，如果finally中也有返回值，则最终返回finally的。def bool_return():    try:        return True    finally:        return Falsebool_return()     \r\n#如果try语句要执行break、continue或return语句，finally子句将在break、continue或return语句执行之前执行try:    print(&quot;这是try块中的内容&quot;)    for i in range(5):        print(&#x27;i:&#x27;, i)        if i == 2:            break    except Exception as e:    print(&quot;发生了一个异常&quot;, e)    finally:    print(&quot;这是finally块中的内容&quot;)\r\n#如果try发生异常，执行完finally语句后，会重新抛出异常def divide(x, y):    try:        result = x / y    except ZeroDivisionError:        print(&quot;division by zero!&quot;)    else:        print(&quot;result is&quot;, result)    finally:        print(&quot;executing finally clause&quot;)# divide(2, 1)# divide(2, 0)divide(&quot;2&quot;, &quot;1&quot;)\r\n#如果finally子句执行break、continue或return语句，则不会重新引发异常def example():    try:        a = 1 / 0    except Exception as e:        print(&#x27;eeee:eeee&#x27;)        return e    finally:        print(&quot;...&quot;)        return &quot;finally&quot;                   result = example()print(result)\r\n抛出异常\r\n\r\n根据程序的运行状态或满足的条件，主动引发一个指定的异常，而不是等待Python解释器在执行过程中遇到错误时自动抛出异常。\r\n使用raise语句抛出异常，此异常可以是BaseException的子类、由BaseException派生的自定义类或异常类的实例。\r\n直接使用异常类raise ValueError；派生Exception类的自定义异常类class MyError(Exception): pass; raise MyError；使用异常类的实例raise ValueError('输入值有误')；\r\n\r\ntry:    raise NameError(&#x27;HiThere&#x27;)except NameError:    print(&#x27;An exception flew by!&#x27;)    raise\r\n异常链\r\n\r\nPython中的异常链是指显式地将异常链接在一起，将一个异常链接到另一个异常的能力。当一个异常作为另一个异常的直接后果而发生时，这个特性特别有用。通过链接异常，开发人员可以提供更多的上下文和更清晰的回溯，从而更容易调试。\r\n用from语句链接异常，并与raise语句合用形成基本结构：raise NewException from exception。\r\n在某些情况下，不想关注其他异常，可以使用from None。\r\n\r\n捕获所有类型的异常\r\n\r\nBaseException是所有异常的公共基类。\r\nBaseException的一个子类 Exception\r\n是所有非致命异常的基类，所有内置的、非系统退出的异常都派生自这个类。所有用户定义的异常也从这个类派生。\r\nSystemExit、KeyboardInterrupt是用户希望中断程序时的异常；GeneratorExit是生成器或协议中断时的异常。\r\n处理异常最常见的模式是 打印 或 记录异常。\r\n\r\n捕获BaseException可能会意外地捕获到SystemExit和KeyboardInterrupt等异常，这可能会导致程序在应该正常退出或响应用户中断的情况下继续运行。Exception确保不阻碍正常的程序退出，也能专注于处理程序中可能发生的错误。\r\n所以通常情况下我们使用Exception去捕获几乎所有的异常情况。\r\n使用Exception捕获异常时，通常后面加一个异常参数e（也可以是其他的变量名），它用于打印异常的具体细节。\r\n文件读取与异常捕获实例：\r\n编写一个Python脚本，尝试读取一个不存在的文件。\r\n使用try-except语句捕获并处理FileNotFoundError异常。\r\n使用else子句打印一条成功读取文件的消息。\r\n使用finally子句确保文件被正确关闭。\r\ntry:    # 尝试打开一个不存在的文件    with open(&#x27;non_existent_file.txt&#x27;, &#x27;r&#x27;) as file:        content = file.read()except FileNotFoundError:    # 如果文件不存在，捕获 FileNotFoundError 异常    print(&quot;文件未找到，请检查文件名是否正确。&quot;)else:    # 如果没有异常发生，打印成功读取文件的消息    print(&quot;文件读取成功！&quot;)    print(content)finally:    # 无论是否发生异常，都执行 finally 块中的代码    print(&quot;操作完成。&quot;)\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之函数之函数简介与参数","url":"/posts/21821.html","content":"函数\r\n\r\n单一功能的封装。\r\n实现代码复用。\r\n\r\nPython语言中使用函数分为两个步骤：定义函数和调用函数。\r\n\r\n定义函数，即根据函数的输入、输出和数据处理完成函数代码的编写。\r\n定义函数只是规定了函数会执行什么操作，但并不会真正去执行。\r\n调用函数，即真正去执行函数中的代码，是根据传入的数据完成特定的运算，并将运算结果返回到函数调用位置的过程。\r\n\r\n定义函数\r\ndef functionname([parameters]):    &quot;&quot;&quot;docstring    &quot;&quot;&quot;    function_suite    [return [expression]]\r\n函数命名规范和变量命名一样\r\n\r\n必须使用字母或者下划线_开头\r\n仅能含有字母、数字和下划线\r\n\r\n调用函数\r\n语法格式：函数名称(), 括号中传入参数值。\r\ndef print_things(name):    print(name , &#x27;hello,world!&#x27;)print_things(&quot;ppx&quot;)\r\n函数的返回值\r\n定义了函数之后，我们调用它来获得返回值\r\ndef square_new(x):    x * x    return   # 在执行return语句终止函数时没有伴随一条表达式print(square_new(3))\r\ndef square_new(x):    x * x    # 没有return语句print(square_new(3))\r\n函数调用过之后进行返回的值，就是返回值。\r\n\r\n如果不显式使用 return 语句或 return\r\n语句不使用表达式，那么函数返回None\r\n要从函数中返回多个值，只要简单地返回一个元组即可。\r\n\r\ndef division():    &quot;&quot;&quot;求商与余数    &quot;&quot;&quot;    a = 9 % 4    b = (9 - a) / 4    return b, ab, a = division()print(b)print(a)\r\n观察 return 语句，尽管看起来\r\ndivision()返回了多个值，但实际上它只创建了一个元组而已。实际上元组是通过逗号来组成的，不是圆括号。\r\n当调用的函数返回了元组，通常会将结果赋值给多个变量，实际上就是简单的元组解包。返回的值也可以赋给一个单独的变量\r\nx = division()print(x)  # x就代表整个元组\r\n函数是一等对象\r\n“一等对象”定义为满足下列条件的程序实体：\r\n\r\n在运行时创建\r\n能赋值给变量或数据结构中的元素\r\n能作为参数传给函数\r\n能作为函数的返回结果\r\n\r\n把函数视作对象\r\n# 创建并测试一个函数，然后读取它的__doc__属性，再检查它的类型def factorial(n):    &quot;&quot;&quot;return n!&quot;&quot;&quot;    print(f&quot;计算 &#123;n&#125; 的阶乘&quot;)    return 1 if n &lt; 2 else n * factorial(n - 1)\r\n每个函数都有一个 __doc__\r\n属性，用于存储函数的文档字符串（docstring）。文档字符串是对函数功能、参数、返回值等的描述，有助于代码的可读性和维护性。\r\nprint(factorial.__doc__)\r\n在我们定义的 factorial 函数中，文档字符串是\r\n\"return n!\"，打印 factorial.__doc__\r\n会输出这个字符串，帮助其他开发者（甚至是未来的自己）理解函数的功能。\r\n在 Python 中，函数是 function 类型的对象。我们可以使用\r\ntype 函数来检查一个函数的类型：\r\nprint(type(factorial))\r\n执行上述代码会输出 &lt;class 'function'&gt;，表明\r\nfactorial 是一个函数对象。\r\n还可以通过别的名称使用函数，再把函数作为参数传递\r\nfact = factorialfact(5)\r\n展示了函数对象的“一等”本性，我们可以把factorial函数赋值给变量fact，然后通过变量名调用。\r\n还可以把它作为参数传递：\r\n# map函数返回一个可迭代对象，里面的元素是把第一个参数（一个函数）应用到# 第二个参数（一个可迭代对象，这里是 range(11)）中各个元素上得到的结果map(factorial, range(5))# help(map)list(map(factorial, range(5)))\r\n高阶函数\r\n接受函数为参数，或者把函数作为结果返回的函数是高阶函数（higher-order\r\nfunction）\r\n示例1：根据单词长度给一个列表排序,只需把\r\nlen函数传给key参数。\r\nfruits = [&#x27;strawberry&#x27;, &#x27;fig&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;raspberry&#x27;, &#x27;banana&#x27;]sorted(fruits, key=len)help(sorted)\r\n任何单参数函数都能作为key参数的值。\r\n总结\r\n\r\n函数定义以 def 关键词开头，后接函数标识符、圆括号()和冒号\r\n圆括号之间用于定义输入参数（可选）\r\n函数体必须缩进，第一行可以使用文档字符串（用于存放函数说明）\r\n函数是一等对象\r\n调用函数时,Python\r\n会执行函数内部的代码，函数执行完之后，返回到主程序。\r\n\r\n函数的参数\r\n从函数定义和调用的角度可以将参数分为：\r\n\r\n形式参数\r\n实际参数\r\n\r\n从参数在函数中的具体使用可分为下面 4 种类型：\r\n\r\n位置参数：def func(a, b): pass\r\n关键字参数：def func(a, b=1): pass\r\n任意位置参数：def func(a, b=1, *c): pass\r\n任意关键字参数：def func(a, b=1, *c, **d): pass\r\n\r\n位置参数\r\n位置参数是 Python\r\n函数调用中最基础的参数传递方式，它通过参数的位置来确定实参与形参的对应关系。调用函数时，传入的实参顺序必须与函数定义时形参的顺序严格一致。\r\ndef add_numbers(a, b):    &quot;&quot;&quot;返回两个数的和&quot;&quot;&quot;    return a + bresult = add_numbers(3, 5)print(result)\r\n在上述代码中，add_numbers函数定义了两个形参a和b。调用函数时，实参3对应形参a，实参5对应形参b\r\n，这就是通过位置建立的参数对应关系。如果调用时改变实参顺序，如add_numbers(5, 3)，虽然也能正确执行，但传递的参数含义会发生变化。\r\n关键字参数\r\n关键字参数允许在调用函数时通过参数名指定对应的值，这样可以避免因位置顺序错误导致的参数传递混乱，并且实参顺序可以与函数定义时形参顺序不同。\r\ndef greet(name, message):    &quot;&quot;&quot;打印问候语&quot;&quot;&quot;    print(f&quot;&#123;name&#125;, &#123;message&#125;&quot;)# 正常顺序使用关键字参数greet(name=&quot;Alice&quot;, message=&quot;欢迎！&quot;)# 打乱顺序使用关键字参数greet(message=&quot;你好！&quot;, name=&quot;Bob&quot;)\r\n上述代码中，greet函数有name和message两个形参。调用时通过name=值、message=值的形式明确指定参数对应关系，即使交换实参顺序，也不影响参数的正确传递。\r\n位置参数和关键字参数还可以混合使用，但要遵循位置参数必须在前、关键字参数在后的原则。例如：\r\ndef divide(dividend, divisor):    &quot;&quot;&quot;返回除法结果&quot;&quot;&quot;    return dividend / divisor# 混合使用示例result = divide(10, divisor=2)print(result)\r\n这里10是位置参数对应dividend，divisor=2是关键字参数，位置和关键字参数各司其职，共同完成函数调用。\r\n默认参数\r\n默认参数是指在函数定义时，为形参指定一个默认值。当调用函数时，如果没有为该形参传递对应的实参，那么这个形参就会自动使用预先设定的默认值。\r\ndef say_hello(name=&quot;陌生人&quot;):    &quot;&quot;&quot;打印问候语，若未传入名字则使用默认值&quot;&quot;&quot;    print(f&quot;你好，&#123;name&#125;!&quot;)# 未传入参数，使用默认值say_hello()# 传入参数，覆盖默认值say_hello(&quot;Charlie&quot;)\r\n在say_hello函数中，name形参的默认值为\"陌生人\"。当直接调用say_hello()时，name使用默认值；而调用say_hello(\"Charlie\")时，name被赋值为\"Charlie\"，默认值被覆盖。\r\n任意位置参数\r\n任意位置参数可以接受任意数量的位置参数。\r\n将一组可变数量的位置参数集合成参数值的元组。\r\ndef calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    print(numbers)    return sumcalc(1, 2, 3, 4, 5, 6)calc(1, 2, 3, 4, 5, 6, 7, 8)\r\n任意关键字参数\r\n任意关键字参数允许传入0个或任意个含参数名的参数\r\n这些关键字参数在函数内部自动组装为一个字典。\r\ndef person(name, age, **kw):    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw) \r\n这时候你可以传入任意个数的关键字参数：\r\nperson(&#x27;Jane&#x27;, 6, city=&#x27;shijiazhuang&#x27;, gender=&#x27;F&#x27;, weight=&#x27;30kg&#x27;)\r\nname: Jane age: 6 other: &#123;&#x27;city&#x27;: &#x27;shijiazhuang&#x27;, &#x27;gender&#x27;: &#x27;F&#x27;, &#x27;weight&#x27;: &#x27;30kg&#x27;&#125;\r\n使用**可以将多个关键字参数收集到一个字典中，参数的名字是字典的键，值是字典的值。\r\n通常把 任意位置参数 和\r\n任意关键字参数 称为 可变参数 或\r\n不定长参数。\r\n一般不定长参数会写成 *args 和 **kwargs\r\n\r\n只有星号是必要的，args 和 kwargs 是约定俗成的\r\n\r\n拆分参数列表\r\n如果一个函数所需要的参数已经存储在了列表、元组或字典中，则可以直接从列表、元组或字典中拆分出来函数所需要的这些参数。\r\n列表、元组拆分出来的结果作为位置参数\r\ndef calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    print(numbers)    return sum\r\n# 参数已经存储在列表 l1 或元组 l2l1 = [1, 2, 3]l2 = (1, 2, 3, 4, 5, 6)# calc(l1[0], l1[1], l1[2])calc(*l2)\r\n\r\n注释掉的 calc(l1[0], l1[1], l1[2])\r\n是一种传统的函数调用方式，需要依次写出列表中的每个元素作为参数传入。但这种方式在列表元素较多时会很繁琐。\r\ncalc(*l2) 这里使用了 * 操作符对元组\r\nl2 进行解包（拆分）。* 操作符会将元组\r\nl2 中的元素逐一提取出来，作为位置参数传递给\r\ncalc 函数，等同于 calc(1, 2, 3, 4, 5, 6)\r\n。这样就实现了从元组中拆分参数来调用函数，避免了手动逐个列出参数的麻烦，当参数数量较多或者参数存储在列表、元组中时，这种方式更加简洁高效。\r\n\r\n字典拆分出来的结果作为关键字参数\r\ndef person(name, age, **kw):    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)    # 参数已经存储在字典 extra 中extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;person(&#x27;Jack&#x27;, 6, **extra)# name: Jack age: 6 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;\r\n函数的实参传递\r\nPython中“一切皆对象”，所有赋值操作都是“引用的赋值”。\r\nPython实参总是通过引用传递的(通过对象传递)。当函数调用提供一个实参时，Python\r\n将实参对象的*引用*(而不是对象本身)复制到相应的形参中。\r\n这将大大提高性能。函数经常对大型对象进行操作——频繁地复制它们将消耗大量计算机内存并显著降低程序性能。\r\n将对象传递给函数\r\n# 定义一个 cube 函数来显示其参数的标识，并返回该参数值的立方def cube(number):    print(&#x27;id(number):&#x27;, id(number))    return number ** 3# 首先创建整型变量 x,后续使用 x 作为函数实参；# x引用（指向）存储数值 7 的整数对象。x = 7# 获取对象标识id(x)# 使用参数 x 调用 cube, x指向存储数值 7 的整数对象。cube(x)# id(x): 4311131544# id(number): 4311131544# 343\r\ncube 的形参number的标识与前面 x\r\n显示的相同。因为每个对象都有唯一的标识，所以，在 cube 执行时，实参 x\r\n和形参 number 都引用同一个对象。因此，当 cube\r\n在计算中使用形参number时，它将从调用者中的原始对象中获取number值。\r\n# 还可以使用 Python 中的 is 操作符证明实参和形参引用相同的对象x = 7 # x是全局变量def cube(number):    print(&#x27;number is x:&#x27;, number is x)    return number ** 3cube(x)# number is x: True# 343\r\n从参数对象的类型来看可以将参数分为以下两类：\r\n\r\n传递可变对象的引用\r\n传递不可变对象的引用\r\n\r\n传递不可变对象的引用\r\n当一个函数接收一个不可变对象的引用作为参数时（例如整数、浮点数、字符串或元组），这意味着一旦它们被创建，其值就不能被修改。\r\n当把不可变对象作为参数传递给函数时，函数接收到的是该对象的引用。但即便在函数内部操作这个引用，也无法改变原始对象的值。\r\n例如，将一个整数传递给函数，在函数内对这个整数进行重新赋值等操作，不会影响到函数外部原始的整数变量。因为对不可变对象的操作，实际上是重新创建了一个新的对象，而不是修改原来的对象。\r\nb = 12print(id(b))def test0(m):    print(id(m))    m += 1     # 实际上创建了一个新对象，然后将新对象的引用赋值给形参 m    print(id(m))    print(m)test0(b)print(b)print(m)\r\n传递可变对象的引用\r\n列表、字典等在 Python 里是可变对象，它们的值可以被修改。\r\n当把可变对象作为参数传递给函数时，传递的同样是对象的引用。函数可以通过这个引用直接修改对象内部的值。\r\n传递参数是不论是可变对象还是不可变对象，实际传递的还是对象的引用。\r\n注意：在定义函数时，不要把可变的数据类型（列表、字典）当作关键字参数的参数值。\r\ndef test0(n, alist=[]):    alist.append(n)    return alistprint(test0(1))print(test0(2)) #[1, 2]print(test0(3)) #[1, 2, 3]\r\n如何避免这种情况\r\ndef test0(n, alist=None):    if alist is None:        alist = []    alist.append(n)    return alistprint(test0(1)) #[1]print(test0(2)) #print(test0(3))\r\n函数参数示例：\r\n现在有一个分类器，我们用它来解决二分类问题，现在在测试集上的测试结果如下：\r\npredicted_labels = [1, 0, 0, 1, 0, 1, 1, 0, 0, 0]\r\n真实标签为：\r\ntrue_labels = [1, 0, 1, 1, 0, 1, 0, 0, 0, 1]\r\n请设计一个函数，用来进行模型评估，输入为预测标签列表和真实标签列表，输出模型预测正确率，查准率和查全率。\r\ndef evaluate_classifier(predicted_labels, true_labels):    &quot;&quot;&quot;    评估二分类模型的性能        参数:    predicted_labels: 模型预测的标签列表    true_labels: 真实的标签列表        返回:    dict: 包含准确率(accuracy)、精确率(precision)和召回率(recall)的字典    &quot;&quot;&quot;    if len(predicted_labels) != len(true_labels):        raise ValueError(&quot;预测标签和真实标签的长度必须相同&quot;)        # 初始化计数器    true_positives = 0    # 真正例    false_positives = 0   # 假正例    false_negatives = 0   # 假负例    total_samples = len(true_labels)    correct_predictions = 0        # 计算各类样本数量    for pred, true in zip(predicted_labels, true_labels):        if pred == true:            correct_predictions += 1                if pred == 1 and true == 1:            true_positives += 1        elif pred == 1 and true == 0:            false_positives += 1        elif pred == 0 and true == 1:            false_negatives += 1        # 计算评估指标    accuracy = correct_predictions / total_samples        # 处理精确率的边界情况（避免除以零）    if (true_positives + false_positives) == 0:        precision = 0    else:        precision = true_positives / (true_positives + false_positives)        # 处理召回率的边界情况（避免除以零）    if (true_positives + false_negatives) == 0:        recall = 0    else:        recall = true_positives / (true_positives + false_negatives)        return &#123;        &quot;accuracy&quot;: accuracy,        &quot;precision&quot;: precision,        &quot;recall&quot;: recall    &#125;# 使用你提供的数据predicted_labels = [1, 0, 0, 1, 0, 1, 1, 0, 0, 0]true_labels = [1, 0, 1, 1, 0, 1, 0, 0, 0, 1]results = evaluate_classifier(predicted_labels, true_labels)print(f&quot;准确率 (Accuracy): &#123;results[&#x27;accuracy&#x27;]:.3f&#125;&quot;)print(f&quot;精确率 (Precision): &#123;results[&#x27;precision&#x27;]:.3f&#125;&quot;)print(f&quot;召回率 (Recall): &#123;results[&#x27;recall&#x27;]:.3f&#125;&quot;)\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之匿名函数，闭包与装饰器","url":"/posts/63235.html","content":"匿名函数\r\nlambda函数\r\n匿名函数（也称为lambda函数）是一种可以在需要时快速定义的小型函数。\r\nsq = lambda x: x * xsq(2)\r\n这里用到的 lambda\r\n表达式与下面的函数定义有着相同的功能：\r\ndef sq(x):    return(x * x)sq(2)print((lambda x: x * x)(2))\r\nlambda表达式的基本语法如下：\r\n         lambda arg1，arg2，arg3...: &lt;表达式&gt;\r\n                    \r\n   其arg1/arg2/arg3为函数的参数\r\n   &lt;表达式&gt;相当于函数体\r\n   函数返回值：表达式的计算结果\r\n注意：\r\n\r\nlambda实际生成了一个函数对象。\r\nlambda表达式只允许包含一个表达式。\r\n\r\nlambda函数的使用：\r\n可以作为另一个函数的参数传递，用于定制特定的行为。\r\nnums = [1, 2, 3, 4, 5]result = list(map(lambda x: x + 1, nums))print(result)\r\n参数中可以使用lambda作为参数的还有map()等。\r\n使用lambda表达式反转拼写，然后依此给单词列表排序\r\nfruits = [&#x27;strawberry&#x27;, &#x27;fig&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;raspberry&#x27;, &#x27;banana&#x27;]sorted(fruits, key=lambda word: word[::-1])\r\n除了作为参数传递给高阶函数之外，Python 很少使用匿名函数。\r\nlambda句法只是语法糖：与\r\ndef语句一样，lambda表达式会创建函数对象。\r\n总结：\r\n\r\n匿名函数是Python中的一种快速定义小型函数的方式\r\n它没有函数名，使用lambda关键字定义\r\n匿名函数可以简化代码、作为函数参数传递以及在列表推导中应用\r\n\r\n闭包\r\n\r\n闭包的定义\r\n在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。\r\n闭包的构成条件 在函数嵌套的前提下\r\n内部函数使用了外部函数的变量或者参数 外部函数返回了内部函数\r\n闭包的作用 可以保存外部函数内的变量，不会随着外部函数调用完而销毁\r\n由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。\r\n\r\n#在函数嵌套的前提下def outer():    num1=10     def inner():        re=num1+10 #内部函数使用了外部函数的变量或者参数        print(re)    return inner   #外部函数返回了内部函数,这个使用外部函数变量的内部函数称为闭包#获取闭包对象new_fun=outer() #这个new_fun就是闭包#执行闭包new_fun()\r\n举例：\r\n假如有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值。\r\n例如，商品历史周期内的平均价格，每天添加一个新的价格，目前为止均价的计算要考虑商品全部价格。\r\n# 计算移动平均值的类class Averager():    def __init__(self):        self.series = []    def __call__(self, new_value):         self.series.append(new_value)         total = sum(self.series)         return total/len(self.series)# 计算移动平均值的高阶函数。# 当调用make_averager函数时，返回的是averager函数对象。# 每次averager被调用时，它会将传递的参数追加到series，并计算当前的平均数。def make_averager():      total = 0    count = 0        def averager(new_value):                 count = count + 1  #本意想修改外部函数，其实是再闭包内定义了一个局部变量        total += new_value         return total/count    return averager# Averager的实例是可调用对象avg = Averager()print(avg(10))print(avg(11))print(avg(12))avg2 = make_averager()print(avg2(10))print(avg2(11))print(avg2(12))\r\naverager 是定义在 make_averager\r\n内部的函数，形成了闭包\r\n在averager内部，series是一个自由变量。\r\n这是一个技术术语，指未在本地作用域中绑定的变量。\r\n\r\n\r\nimage-20250514153301357\r\n\r\n&#x27;&#x27;&#x27;Python 在 __code__ 属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称。series 的绑定在返回的 avg 函数的 __closure__ 属性中。avg.__closure__ 中的各个元素对应于avg.__code__.co_freevars 中的一个名称。这些元素是 cell 对象，有个 cell_contents 属性，保存着真正的值。&#x27;&#x27;&#x27;print(avg.__code__.co_varnames)print(avg.__code__.co_freevars)print(avg.__closure__) # doctest: +ELLIPSISprint(avg.__closure__[0].cell_contents)\r\n示例：\r\n创建一个闭包实现计数器\r\n编写一个闭包函数，它应该提供一个计数器功能。每次调用该闭包时，它应返回下一个整数。\r\n例如，首次调用返回 1，下一次调用返回 2，依此类推。\r\n提示： 使用一个非局部变量来存储当前计数。\r\ncounter() 1counter() 2counter() 3\r\ndef create_counter():    count = 0  # 非局部变量，用于存储当前计数值    def counter():        nonlocal count  # 声明 count 是外层函数的变量        count += 1     # 每次调用时增加计数        return count   # 返回新的计数值    return counter  # 返回闭包函数# 创建计数器counter = create_counter()# 测试计数器print(counter())  # 输出 1print(counter())  # 输出 2print(counter())  # 输出 3\r\n总结\r\n\r\n闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。\r\n注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。\r\n\r\n装饰器\r\n装饰器是 Python\r\n中一种强大且灵活的语法结构，本质上是一个闭包函数。它可以在不改变原函数代码和调用方式的前提下，为函数增添新的功能。这就好比给一个物品添加装饰，在不改变物品本身核心功能的基础上，让它具备更多特性。\r\n装饰器在代码的可维护性、复用性和可读性方面都有很大帮助，广泛应用于日志记录、性能测试、权限验证等场景。\r\n\r\n是一种函数，有内置的装饰器，也可以自定义装饰器，本质上就是一个闭包函数。\r\n可以在不改变函数调用方式的情况下给函数增加对应功能\r\n通过@加上命名进行使用，作用在函数声明的前面，如下：\r\n\r\n@propertydef value(self):    return self._value\r\n简单来说，装饰器函数接收一个函数作为参数，然后返回一个新的函数。新函数通常会在执行原函数前后添加额外的逻辑，从而实现功能增强。\r\n内置装饰器示例\r\nPython 有一些内置装饰器，例如@property\r\n，它用于将类中的方法转换为属性调用的形式，让代码更加简洁直观。\r\nclass Person:    def __init__(self, age):        self._age = age    @property    def age(self):        return self._ageperson = Person(30)print(person.age)  # 像访问属性一样访问方法\r\n@property\r\n装饰器把age方法装饰成了一个属性，调用person.age时，实际上调用的是被装饰的age方法，但看起来就像在访问一个普通属性，提升了代码的易用性。\r\n自定义装饰器示例\r\n下面通过一个简单的例子来展示如何自定义装饰器，实现函数执行时间的计算功能。\r\nimport timedef timer(func):    def wrapper():        start_time = time.time()        func()        end_time = time.time()        print(f&quot;函数 &#123;func.__name__&#125; 执行耗时: &#123;end_time - start_time&#125; 秒&quot;)    return wrapper@timerdef say_hello():    time.sleep(2)    print(&quot;Hello!&quot;)say_hello()\r\n\r\n定义装饰器函数 timer\r\n\r\ntimer 函数接收一个函数 func\r\n作为参数，这是装饰器的基本形式，即接收被装饰的函数。\r\n内部定义了一个 wrapper 函数，wrapper\r\n函数就是闭包函数，它可以访问外部函数 timer 作用域内的\r\nfunc 变量。\r\n在 wrapper 函数中，首先记录开始时间\r\nstart_time = time.time() ，然后调用原函数\r\nfunc() ，再记录结束时间 end_time = time.time()\r\n，最后计算并打印函数执行的耗时。\r\ntimer 函数最后返回 wrapper 函数对象。\r\n\r\n使用装饰器\r\n\r\n@timer 语法将 timer 装饰器应用到\r\nsay_hello 函数上，这等同于执行\r\nsay_hello = timer(say_hello) 。\r\n调用 say_hello() 时，实际上调用的是\r\nwrapper 函数，wrapper 函数会在执行\r\nsay_hello 函数的前后添加计算时间的逻辑，从而实现了在不改变\r\nsay_hello\r\n函数本身代码和调用方式的情况下，为其增添了计算执行时间的功能。\r\n\r\n\r\n带参数的装饰器\r\n有时候我们需要给装饰器传递参数，来定制不同的装饰逻辑。下面是一个带参数的装饰器示例，用于根据不同的日志级别打印函数调用信息。\r\ndef logger(level):    def decorator(func):        def wrapper():            if level == &quot;DEBUG&quot;:                print(f&quot;DEBUG: 调用函数 &#123;func.__name__&#125;&quot;)            elif level == &quot;INFO&quot;:                print(f&quot;INFO: 调用函数 &#123;func.__name__&#125;&quot;)            func()        return wrapper    return decorator@logger(level=&quot;INFO&quot;)def greet():    print(&quot;Welcome!&quot;)greet()\r\n\r\n定义带参数的装饰器外层函数 logger\r\n\r\nlogger 函数接收一个参数 level\r\n，用于指定日志级别。\r\n它返回另一个函数 decorator ，decorator\r\n函数才是真正接收被装饰函数的装饰器函数。\r\n\r\ndecorator 函数\r\n\r\n接收被装饰的函数 func ，内部定义 wrapper\r\n函数。\r\nwrapper 函数根据传入的 level\r\n参数进行不同的日志打印，然后调用原函数 func 。\r\ndecorator 函数返回 wrapper 函数。\r\n\r\n使用带参数的装饰器\r\n\r\n@logger(level=\"INFO\") 这种形式先调用\r\nlogger 函数并传入 level\r\n参数，得到具体的装饰器函数，再将其应用到 greet\r\n函数上。这样就实现了根据不同参数定制装饰器行为的功能。\r\n\r\n\r\n总结：\r\n\r\n装饰器可以在不改变原函数的定义和调用方式的基础上，增强函数的功能。\r\n严格来说，装饰器只是语法糖。装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。\r\n装饰器能把被装饰的函数替换成其他函数。\r\n\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的浅复制与深复制","url":"/posts/22323.html","content":"Python的浅复制与深复制\r\n\r\n对于不可变对象来说，因其值不可变，复制一个副本对它的作用不大。但对于可变对象来说，因其值可变，很多时候复制一个副本可以保存它未改变前的值，用来做对比或者做数据备份。\r\n创建一个副本，这里涉及到浅复制和深复制。\r\n\r\n浅复制与深复制的构造方法\r\n\r\n首先都需要导入copy模块\r\n浅复制：copy.copy(x)\r\n深复制：copy.deepcopy(x)\r\n\r\n其中浅复制还可以用切片实现：\r\n\r\n例如：a = [1,2,3] ; aa = a[:]\r\n\r\n浅复制与深复制的区别\r\n\r\n浅复制：复制内层容器时不会单独开辟空间，而是引用原来的地址。\r\n深复制：复制内层不可变的容器时不会单独开辟空间，引用其原地址；若是内层可变的容器，则会单独开辟空间\r\n\r\n容器：\r\n\r\n可以在里面装下多个元素的，可以用in, not\r\nin关键字判断元素是否包含在容器中的。\r\n常见的容器有：字符串、元组、列表、字典、集合。\r\n\r\nhttp://www.pythontutor.com\r\n是一个可以一边执行代码一边查看对象引用情况的网站。\r\n我们构造一个含有内层容器的对象[0,1,[2,99],4]，然后在线查看深、浅复制分别都是如何复制的。\r\n#构造对象，并进行浅复制和深复制import copy a = [0,1,(2,[9,8]),4]aa = copy.copy(a)    #切片也是浅复制a[:]aaa = copy.deepcopy(a)print(id(a[2][1]))print(id(aa[2][1]))print(id(aaa[2][1]))\r\n那么，改变原值时，浅复制和深复制的内容会如何改变？\r\n#构造含内层容器的对象import copy a = [0,1,[2,99],4]#aa = copy.copy(a)aaa = copy.deepcopy(a)#改变内层容器的值print(id(a))a[2][0] = 8print(id(a[2][0]))print(id(aa[2][0]))print(id(aaa[2][0]))# print(id(a[2][0]) == id(aa[2][0]))# print(id(a[2][0]) == id(aaa[2][0]))\r\n\r\n改变原值的内层容器里的值时，浅复制会随之改变，深复制则不会。\r\n\r\n理解深浅复制的区别：\r\n\r\n现给出一个列表lsa = [12, 'abc', [8, 0]]，对lsa分别进行浅复制赋值给lsb，进行深复制赋值给lsc，然后改lsa中的[8, 0]为[9, 0]，请问lsb和lsc中的值改变了吗？为什么？\r\nlist_a = [1, &quot;hello&quot;, [2, 3]]print(id(list_a[2]))list_b = copy.copy(list_a)print(id(list_b[2]))list_c = copy.deepcopy(list_a)print(id(list_c[2]))list_a[2] = [4,5]print(id(list_a[2]))print(id(list_b[2]))print(id(list_c[2]))\r\n在执行上述操作后，lsb中的子列表会随之改变，而lsc中的子列表则保持不变。具体分析如下：\r\n\r\nlsb = copy.copy(lsa)创建了列表的浅副本。浅复制会复制顶层对象，但嵌套的子对象（如列表[8, 0]）仍指向原对象。因此，lsb和lsa的顶层元素是独立的，但它们共享嵌套的子列表。\r\nlsc = copy.deepcopy(lsa)创建了列表的深副本。深复制会递归复制所有嵌套对象，生成完全独立的对象树。因此，lsc中的子列表是lsa中子列表的独立副本。\r\n\r\n所以执行当执行lsa[2] = [9, 0]时：\r\n\r\nlsb的变化：\r\nlsb的顶层结构与lsa分离，但共享子列表。修改lsa[2]只是替换了lsa的第三个元素的引用，而lsb[2]仍指向原嵌套列表[8, 0]。因此，lsb中的值不会改变。\r\nlsc的变化：\r\n深复制生成的lsc完全独立于lsa。修改lsa[2]不会影响lsc的任何元素。因此，lsc中的值保持不变。\r\n\r\n结论：\r\n\r\nlsb中的值：[8, 0]（未改变）\r\nlsc中的值：[8, 0]（未改变）\r\n原因：浅复制共享嵌套对象，而深复制完全独立。修改lsa的子列表引用不会传播到复制对象。\r\n\r\n\r\n","categories":["语言基础学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之对象和类","url":"/posts/62472.html","content":"对象和类\r\n由对象说起\r\n对象与对象名称之间的区别\r\n把变量理解为附加在对象上的标注。创建对象之后才会把变量分配给对象\r\n例：变量 a 和 b 引用同一个列表，而不是那个列表的副本\r\na = [1, 2, 3]b = ab.append(4)b\r\n\r\n\r\nimage-20250514154637571\r\n\r\n类与实例\r\n在Python中通常使用class语句来定义一个类（类对象）\r\nclass定义的对象（类）可以用于产生新的对象（实例）。\r\nclass Person():    pass    someone = Person()print(id(someone), type(someone))\r\n上面的例子中Person是我们创建的一个新的类，通过调用Person()可以获得一个Person类型的实例对象，将其赋值为someone，就成功创建了一个与所有内置对象类型不同的对象someone，它的类型为__main__.Person。到这里，可以将Python中一切的对象分为两种：\r\n\r\n可以用来生成新对象的类，包括内置的int、str以及上面定义的Person等；\r\n由类生成的实例对象，包括内置类型的数字、字符串、以及上面定义的类型为__main__.Person的someone。\r\n\r\n类中的属性对应前面所学习的变量，而类中的方法对应前面所学习的函数。\r\n通过类，可以把数据和操作封装在一起，从而使得程序结构更加清晰，这也就是所谓的类的封装性。\r\n在类的内部，使用def关键字可以为类定义一个方法，\r\n与一般函数定义不同，方法必须包含参数self，且为第一个参数。\r\nclass Person():    name = &#x27;TZ&#x27;    sex = &#x27;F&#x27;    def jump(self):        print(&#x27;Jumping!&#x27;)tz = Person()tz.jump()tz.nametz.sex\r\n特殊的对象初始化方法__init__\r\n# 初始化一个 Person 类的 name 属性class Person():    def __init__(self, name):        self.name = namesomeone = Person(&#x27;小明&#x27;)print(someone)print(someone.name)  # 访问类属性\r\n上面代码执行流程：\r\n\r\n查看Person类的定义；\r\n在内存中实例化（创建）一个新的对象；\r\n调用对象的__init__方法，将这个新创建的对象作为self参数传入，并将另一个参数（‘小明’）作为name传入；\r\n将name的值存入对象；\r\n返回这个新的对象；\r\n将名字someone与这个对象关联。\r\n\r\n提示：每次创建对象时，系统都会在内存中选择一块区域分配给对象，每次选择的内存通常是不一样的。因此，实际运行时会看到一个不同的\r\nPerson 对象地址。\r\nclass Person():    def __init__(self, name, age):                self.name = name        self.age = age    def get_name(self):        return self.name    def set_name(self, name):        self.name = name    def get_age(self):        return self.age    def set_age(self, age):        self.age = age\r\n注意：在类的内部，使用def关键字可以为类定义一个方法，\r\n当调用一个特定对象的方法时，Python\r\n隐式地传递对该对象的引用作为方法的第一个参数。\r\n因此，在一个类中，所有方法必须包含参数self，且为第一个参数。\r\n类中的方法只能使用该引用（self）来访问对象的属性和其他方法。\r\n总结：\r\n\r\n对象既包含数据（称为特性/属性），也包含代码（称为方法）\r\n类是对象的模板，从类制作对象的过程，称为类的实例化\r\n在类的内部，方法定义时必须包含参数self，且为第一个参数\r\n__init__是初始化方法，当创建了实例时会调用该方法\r\n类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线,\r\n实例名和模块名都采用小写格式，并在单词之间加上下划线\r\n\r\n实例\r\n创建一个名为 BankAccount 的类, 要求：\r\n\r\n属性： balance（表示账户余额）\r\n方法： deposit(amount)，用于存款，返回账户余额。\r\nwithdraw(amount)，用于取款，返回账户余额，若余额不足则返回“余额不足”信息。\r\nget_balance()，用于返回当前余额。\r\n\r\n创建实例，并调用上述方法。\r\nclass BankAccount:    def __init__(self):        self.balance = 0  # 初始化账户余额为0    def deposit(self, amount):        if amount &gt; 0:            self.balance += amount            return self.balance        else:            print(&quot;存款金额必须大于0&quot;)            return self.balance    def withdraw(self, amount):        if amount &gt; 0:            if self.balance &gt;= amount:                self.balance -= amount                return self.balance            else:                return &quot;余额不足&quot;        else:            print(&quot;取款金额必须大于0&quot;)            return self.balance    def get_balance(self):        return self.balance# 创建BankAccount类的实例account = BankAccount()# 调用存款方法print(account.deposit(1000))# 调用取款方法print(account.withdraw(300))# 调用获取余额方法print(account.get_balance())\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Servlet与http","url":"/posts/62509.html","content":"软件架构与网络通信\r\n软件架构：\r\n\r\nB/S：浏览器端-服务器端（JavaEE体系）\r\n客户端不用再去开发，开发更加快速\r\nC/S：客户端-服务器端\r\n\r\n资源分类：\r\n\r\n静态资源：所有用户访问后得到的结果是一样的，称为静态资源\r\n\r\n如html css js\r\n\r\n动态资源：每个用户访问相同资源后，得到的结构可能不一样，称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器\r\n\r\n如 servlet php jsp\r\n\r\n\r\n网络通信三要素：\r\n\r\nIP：电子设备在网络中的唯一标识\r\n端口:应用程序在计算机中的唯一标识\r\n传输协议：规定了通信的规则\r\n\r\n基础协议：tcp udp\r\n\r\n\r\n\r\n\r\nimage-20250413200701460\r\n\r\n\r\n\r\nimage-20250413200701460\r\n\r\nhttp概述\r\nhttp：超文本传输协议\r\n传输协议：定义了客户端和服务器端通信的时候发送数据的格式\r\n特点： - 基于TCP/IP的高级协议 - 默认端口号是80 -\r\n基于请求响应模型，一次请求对应一次响应 -\r\n无状态的，每次请求之间相互独立\r\nhttp的请求消息和请求行\r\n请求消息数据格式：\r\n\r\n请求行\r\n明确请求的基本信息（操作类型、目标资源、协议版本）\r\n请求方式 请求url 请求协议/版本\r\n请求方法：\r\n常见方法（Servlet 中常用）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n含义\r\n特点\r\n是否有请求体\r\n\r\n\r\n\r\n\r\nGET\r\n请求获取资源\r\n请求参数在请求行，数据通过 URL\r\n传递，明文可见，长度有限制（浏览器通常限制 8KB）\r\n无\r\n\r\n\r\nPOST\r\n提交数据（如表单）\r\n数据放在请求体中，适合传输大量数据，安全性较高\r\n有\r\n\r\n\r\nPUT\r\n更新资源（全量更新）\r\n需指定资源完整路径，幂等性（多次操作结果一致）\r\n有\r\n\r\n\r\nDELETE\r\n删除资源\r\n指定 URL 对应的资源，幂等性\r\n无\r\n\r\n\r\nHEAD\r\n获取资源头部信息\r\n仅返回响应头，不返回响应体，用于快速检查资源是否存在\r\n无\r\n\r\n\r\n\r\n请求url：协议://主机:端口/路径?查询参数#锚点\r\n\r\n协议：固定为http或https（如http://）\r\n主机：服务器域名（如www.example.com）或\r\nIP 地址（如192.168.1.1）\r\n端口：可选，默认80（HTTP）或443（HTTPS），如8080\r\n路径：资源在服务器上的路径（如/user/login）\r\n查询参数：可选，格式为key=value&amp;key2=value2，通过?与路径分隔\r\n锚点：客户端浏览器使用，用于定位页面内元素，服务器不处理\r\nServlet服务器接收的 URL 部分：不包含锚点，仅到查询参数为止\r\n\r\n请求头\r\n携带请求的附加信息（客户端环境、请求参数、安全信息等）\r\n请求头名称：请求头值\r\n通用头字段：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n字段名\r\n含义\r\n示例\r\nServlet 获取方法\r\n\r\n\r\n\r\n\r\nHost\r\n目标服务器的主机和端口（必传）\r\nlocalhost:8080\r\nrequest.getHeader(\"Host\")\r\n\r\n\r\nUser-Agent\r\n客户端信息（浏览器 / 操作系统）\r\nMozilla/5.0 (Windows NT 10.0) Chrome/110.0.0.0\r\nrequest.getHeader(\"User-Agent\")\r\n\r\n\r\nReferer\r\n来源页面 URL（防盗链，统计）\r\nhttp://example.com/login.html\r\nrequest.getHeader(\"Referer\")\r\n\r\n\r\nAccept\r\n客户端接受的响应内容类型\r\ntext/html,application/json\r\nrequest.getHeader(\"Accept\")\r\n\r\n\r\n\r\n可以在服务器端获取User-Agent该头的信息，解决浏览器端兼容性问题\r\n与请求体相关的头字段：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n字段名\r\n含义\r\n示例\r\nServlet 关联\r\n\r\n\r\n\r\n\r\nContent-Type\r\n请求体的数据格式和编码\r\napplication/x-www-form-urlencoded; charset=UTF-8（表单数据）\r\nmultipart/form-data; boundary=xxx（文件上传）\r\n通过request.getContentType()获取\r\n\r\n\r\nContent-Length\r\n请求体的字节长度\r\n1024\r\n通过request.getContentLength()获取\r\n\r\n\r\n\r\n请求空行\r\n作为请求头和请求体的分隔符，必须存在且仅包含一个换行符（\\r\\n）\r\n请求体\r\n封装POST请求消息的请求体的，GET请求没有请求体\r\n空行之后（可选，非必须），存放请求的具体数据（如表单提交的参数、上传文件内容等）\r\n\r\n数据格式\r\n\r\n\r\napplication/x-www-form-urlencoded：表单默认格式，键值对编码为key=value&amp;key2=value2，不支持文件上传\r\nmultipart/form-data：文件上传专用格式，通过boundary分隔不同字段，支持二进制数据\r\napplication/json：JSON\r\n格式数据，需在Content-Type头中声明\r\n\r\n\r\nServlet 中获取请求体数据\r\n\r\n\r\n普通表单数据：通过request.getParameter(\"参数名\")直接获取（自动解码）\r\nJSON\r\n数据：需通过request.getReader()或request.getInputStream()手动解析\r\n文件上传：需使用MultipartHttpServletRequest（需配置MultipartResolver）\r\n\r\n\r\n响应消息数据格式\r\nRequest请求原理\r\n\r\n\r\nimage-20250413202921595\r\n\r\n\r\n\r\nimage-20250413202921595\r\n\r\nrequest对象和response对象的原理：\r\n由服务器创建，我们仅使用\r\nrequest对象获取请求消息，response对象来设置响应消息\r\nrequest对象继承体系的结构\r\nServlet中的HttpServletRequest对象是处理HTTP请求的核心接口\r\n基本继承层次：\r\njavax.servlet.ServletRequest (接口)       ↑javax.servlet.http.HttpServletRequest (接口)       ↑org.apache.catalina.connector.RequestFacade (Tomcat实现类)\r\nServletRequest接口\r\n这是最基础的请求接口，定义了通用的请求方法，不限于HTTP协议：\r\n\r\n核心方法：\r\n\r\ngetParameter(String name) - 获取请求参数\r\ngetAttribute(String name) - 获取请求属性\r\nsetAttribute(String name, Object o) - 设置请求属性\r\ngetInputStream() - 获取输入流\r\ngetReader() - 获取字符读取器\r\ngetContentType() - 获取内容类型\r\ngetLocalAddr() - 获取服务器IP地址\r\n\r\n\r\nHttpServletRequest接口\r\n继承自ServletResponse接口，专门用来封装HTTP响应消息。\r\n由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。：\r\n\r\nHTTP相关方法：\r\n\r\ngetHeader(String name) - 获取请求头\r\ngetMethod() - 获取HTTP方法(GET/POST等)\r\ngetCookies() - 返回一个cookie对象数组\r\ngetSession() - 返回与这个请求相关的会话对象\r\ngetRequestURI() - 获取请求URI\r\ngetQueryString() - 返回请求URL中的查询字符串\r\ngetContextPath() - 返回请求上下文的请求URI部分\r\ngetServletPath() - 获取Servlet路径\r\n\r\n\r\n实现类 (以Tomcat为例)\r\nTomcat中的具体实现类结构：\r\nRequest (org.apache.catalina.connector.Request)       ↑RequestFacade (org.apache.catalina.connector.RequestFacade)\r\n\r\nRequest：Tomcat内部的实际实现类，包含大量内部方法\r\nRequestFacade：提供给Servlet开发者的门面类，遵循门面模式，隐藏了内部复杂实现\r\n\r\njavax.servlet.http包内容\r\nHttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：\r\npublic abstract class HttpServlet extends GenericServlet implements Serializable \r\nHttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\nHttpServlet抽象类\r\nHttpServlet 抽象类是继承于 GenericServlet 抽象类而来的。\r\n使用 HttpServlet 抽象类时，还需要借助分别代表 Servlet 请求和 Servlet\r\n响应的 HttpServletRequest 和 HttpServletResponse 对象。\r\nHttpServletRequest 接口扩展于 javax.servlet.ServletRequest\r\n接口，HttpServletResponse 接口扩展于javax.servlet.servletResponse\r\n接口。\r\npublic interface HttpServletRequest extends ServletRequest\r\npublic interface HttpServletResponse extends ServletResponse\r\n其中，HttpServlet 抽象类覆盖了 GenericServlet 抽象类中的Service(\r\n)方法，并且添加了一个自己独有的Service(HttpServletRequest\r\nrequest，HttpServletResponse方法。\r\n这是 GenericServlet 抽象类中定义的service方法：\r\npublic abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\r\nHttpServlet 实现的这个 service 方法\r\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    HttpServletRequest request;    HttpServletResponse response;    try &#123;        request = (HttpServletRequest)req;        response = (HttpServletResponse)res;    &#125; catch (ClassCastException var6) &#123;        throw new ServletException(&quot;non-HTTP request or response&quot;);    &#125;     this.service(request, response);&#125;\r\nHttpServlet 中的 service 方法把接收到的 ServletRequsest\r\n类型的对象转换成了 HttpServletRequest 类型的对象，把ServletResponse\r\n类型的对象转换成了 HttpServletResponse 类型的对象。\r\n之所以能够这样强制的转换，是因为在调用Servlet的Service方法时，Servlet容器总会传入一个\r\nHttpServletRequest 对象和 HttpServletResponse\r\n对象，预备使用HTTP。因此，转换类型当然不会出错了。\r\n转换之后，service方法把两个转换后的对象传入了另一个service方法\r\n// 参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String method = req.getMethod();    long lastModified;    // 解析HttpServletRequest中的方法参数，并调用以下方法之一，每一种方法都表示一个Http方法。doGet和doPost是最常用的    if (method.equals(&quot;GET&quot;)) &#123;        lastModified = this.getLastModified(req);        if (lastModified == -1L) &#123;            this.doGet(req, resp);        &#125; else &#123;            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if (ifModifiedSince &lt; lastModified) &#123;                this.maybeSetLastModified(resp, lastModified);                this.doGet(req, resp);            &#125; else &#123;                resp.setStatus(304);            &#125;        &#125;    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;        lastModified = this.getLastModified(req);        this.maybeSetLastModified(resp, lastModified);        this.doHead(req, resp);    &#125; else if (method.equals(&quot;POST&quot;)) &#123;        this.doPost(req, resp);    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;        this.doPut(req, resp);    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;        this.doDelete(req, resp);    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;        this.doOptions(req, resp);    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;        this.doTrace(req, resp);    &#125; else &#123;        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[]&#123;method&#125;;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    &#125;&#125;\r\n通过request获取内容\r\n通过request获得请求行\r\n请求行包含HTTP方法、URI和协议版本，例如：GET /test?name=value HTTP/1.1\r\n// 获取请求方法(GET/POST/PUT/DELETE等)String method = request.getMethod();// 获取请求URL(不包含协议、域名和端口)String requestURL = request.getRequestURL().toString(); // 获取请求URI(相对于Context Path的部分)String requestURI = request.getRequestURI();// 获取查询字符串(问号后面的部分)String queryString = request.getQueryString();// 获取协议和版本String protocol = request.getProtocol(); // HTTP/1.1// 获取上下文路径(web应用的根路径)String contextPath = request.getContextPath();// 获取Servlet路径String servletPath = request.getServletPath();\r\n获取请求头信息\r\n请求头包含了客户端环境和请求的附加信息\r\n// 获取指定请求头的值String userAgent = request.getHeader(&quot;User-Agent&quot;);String accept = request.getHeader(&quot;Accept&quot;);// 获取所有请求头名称的枚举Enumeration&lt;String&gt; headerNames = request.getHeaderNames();// 遍历所有请求头while(headerNames.hasMoreElements()) &#123;    String name = headerNames.nextElement();    String value = request.getHeader(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取Int类型的请求头值int contentLength = request.getIntHeader(&quot;Content-Length&quot;);// 获取日期类型的请求头值long date = request.getDateHeader(&quot;If-Modified-Since&quot;);// 获取多值请求头Enumeration&lt;String&gt; languages = request.getHeaders(&quot;Accept-Language&quot;);\r\n获取请求体\r\n请求体主要出现在POST、PUT等请求中，包含客户端发送的数据\r\n获取表单数据\r\n// 获取单个表单参数值String username = request.getParameter(&quot;username&quot;);// 获取多值参数(如复选框)String[] hobbies = request.getParameterValues(&quot;hobby&quot;);// 获取所有参数名的枚举Enumeration&lt;String&gt; paramNames = request.getParameterNames();// 获取所有参数的MapMap&lt;String, String[]&gt; paramMap = request.getParameterMap();// 遍历所有参数paramMap.forEach((key, values) -&gt; &#123;    System.out.print(key + &quot;: &quot;);    for(String value : values) &#123;        System.out.print(value + &quot; &quot;);    &#125;    System.out.println();&#125;);\r\n获取原始请求体\r\n// 获取输入流读取原始数据ServletInputStream inputStream = request.getInputStream();BufferedReader reader = request.getReader();// 示例：读取JSON请求体StringBuilder sb = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123;    sb.append(line);&#125;String jsonBody = sb.toString();\r\n获取其他请求信息\r\n// 获取客户端IP地址String clientIP = request.getRemoteAddr();// 获取客户端主机名String clientHost = request.getRemoteHost();// 获取客户端端口int clientPort = request.getRemotePort();// 获取服务器信息String serverName = request.getServerName();int serverPort = request.getServerPort();// 获取请求的会话HttpSession session = request.getSession();// 获取Cookie数组Cookie[] cookies = request.getCookies();// 获取内容类型String contentType = request.getContentType();// 获取字符编码String encoding = request.getCharacterEncoding();// 设置字符编码(处理中文乱码)request.setCharacterEncoding(&quot;UTF-8&quot;);\r\n示例\r\n处理JSON请求\r\nprotected void doPost(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 设置字符编码    request.setCharacterEncoding(&quot;UTF-8&quot;);        // 读取JSON请求体    StringBuilder sb = new StringBuilder();    try (BufferedReader reader = request.getReader()) &#123;        String line;        while ((line = reader.readLine()) != null) &#123;            sb.append(line);        &#125;    &#125;        // 解析JSON    JSONObject json = new JSONObject(sb.toString());    String username = json.getString(&quot;username&quot;);    // 处理业务逻辑...&#125;\r\nRequest乱码问题的解决方法\r\nServlet默认编码是ISO-8559-1，需要手动修改编码方式为UTF-8编码\r\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);  // 解决post提交方式的乱码parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);    //  解决get提交的方式的乱码\r\n通过Response设置响应\r\nHttpServletResponse对象是Servlet中用于构建HTTP响应的核心接口，它提供了丰富的方法来设置响应状态、响应头和响应体\r\n设置响应状态\r\n设置状态码\r\n// 设置成功状态码(200)response.setStatus(HttpServletResponse.SC_OK);// 设置404未找到response.setStatus(HttpServletResponse.SC_NOT_FOUND);// 设置500服务器错误response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);// 设置302重定向(已废弃，推荐使用sendRedirect)response.setStatus(HttpServletResponse.SC_FOUND);\r\n设置状态码和错误消息\r\n// 设置状态码和自定义错误消息response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;资源不存在&quot;);// 仅设置状态码(使用默认错误消息)response.sendError(HttpServletResponse.SC_FORBIDDEN);\r\n设置响应头\r\n基本响应头设置\r\n// 设置单个响应头response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 添加响应头(可设置多个同名头)response.addHeader(&quot;Set-Cookie&quot;, &quot;name=value&quot;);// 设置Int类型响应头response.setIntHeader(&quot;Content-Length&quot;, 1024);// 设置日期类型响应头response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis() + 3600000);\r\n常用响应头快捷方法\r\n// 设置内容类型和字符编码(等同于setHeader(&quot;Content-Type&quot;, ...))response.setContentType(&quot;text/html;charset=UTF-8&quot;);// 设置内容长度(等同于setIntHeader(&quot;Content-Length&quot;, ...))response.setContentLength(1024);// 设置字符编码(单独设置)response.setCharacterEncoding(&quot;UTF-8&quot;);\r\n设置响应体\r\n获取输出流\r\n// 获取字节输出流(用于二进制数据)// 获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。ServletOutputStream outputStream = response.getOutputStream();// 获取字符输出流(用于文本数据)// 获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。PrintWriter writer = response.getWriter();\r\n注意，其中response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。\r\n重定向相关\r\n302重定向\r\n// 简单重定向(相对路径)response.sendRedirect(&quot;newPage.html&quot;);// 重定向到绝对URLresponse.sendRedirect(&quot;http://example.com/newPath&quot;);// 重定向到上下文路径下的资源response.sendRedirect(request.getContextPath() + &quot;/secured/page.jsp&quot;);\r\n请求转发(服务器内部)\r\n// 获取转发器RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/target.jsp&quot;);// 转发请求和响应dispatcher.forward(request, response);\r\n示例\r\nRESTful API响应\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);        try (PrintWriter out = response.getWriter()) &#123;        JSONObject json = new JSONObject();        json.put(&quot;status&quot;, &quot;success&quot;);        json.put(&quot;data&quot;, new JSONObject()            .put(&quot;id&quot;, 123)            .put(&quot;name&quot;, &quot;张三&quot;)            .put(&quot;email&quot;, &quot;zhangsan@example.com&quot;));                out.print(json.toString());    &#125;&#125;\r\n文件下载\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        String fileName = &quot;example.pdf&quot;;    String filePath = &quot;/path/to/files/&quot; + fileName;        response.setContentType(&quot;application/pdf&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        try (InputStream in = new FileInputStream(filePath);         OutputStream out = response.getOutputStream()) &#123;                byte[] buffer = new byte[4096];        int length;        while ((length = in.read(buffer)) &gt; 0) &#123;            out.write(buffer, 0, length);        &#125;    &#125;&#125;\r\n乱码问题\r\nresponse缓冲区的默认编码也是iso8859-1\r\nresponse.setCharacterEncoding(&quot;utf-8&quot;);  // 更改response的编码方式为UTF-8\r\n更改response的编码方式为UTF-8，只是其中一步，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。\r\n// 通知浏览器使用utf8response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);\r\nresponse.setContentType(“text/html;charset=UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text/html;charset=UTF-8”)方法即可。\r\n\r\nServlet的工作流程\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n关于Web基础部分\r\nJavaWeb-http\r\n引用文章\r\nJavaWeb——HTTP详解\r\nJavaWeb——Servlet\r\n菜鸟教程Servlet部分\r\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Web","Servlet"]},{"title":"Python面向对象之类的继承，类中封装和可管理属性","url":"/posts/49265.html","content":"类的继承\r\n从已有类中衍生出新的类，添加或修改部分功能，能提高代码复用。\r\n子类是从父类派生出来的新类。\r\n子类继承了父类的属性和方法，并且可以添加自己的属性和方法。\r\nclass A():    def foo(self):        print(&#x27;A.foo&#x27;)    def zoo(self):        print(&#x27;A.zoo&#x27;)        class B(A): #  B 类将继承 A 类的所有属性和方法。    def fooo(self):        super().foo() # 使用 super() 函数调用父类 A 的 foo方法。        print(&#x27;B.foo&#x27;)    def bar(self):        print(&#x27;B.bar&#x27;)        a = A()b = B()b.bar()a = A()b = B()# a.foo()# b.fooo()# b.zoo()   # 继承自类 A，可以直接使用类 A 的所有方法。# b.foo()# b.bar()\r\n使用super( )从父类得到帮助\r\nclass Person():    def __init__(self, name):        print(&quot;Initializing Person&quot;)        self.name = name    class EmailPerson(Person):    def __init__(self, name, email):        print(&quot;Initializing EmailPerson&quot;)        super().__init__(name)        self.email = email        zhangsan = EmailPerson(&quot;zhangsan&quot;, &quot;123@aaa.com&quot;)print(zhangsan.email)# Initializing EmailPerson# Initializing Person# 123@aaa.com\r\n\r\nclass EmailPerson(Person): 定义了\r\nEmailPerson 类，它继承自 Person 类，这意味着\r\nEmailPerson 类拥有 Person\r\n类的属性和方法。\r\n__init__ 是子类的构造方法，接收 name 和\r\nemail 两个参数。首先打印子类的初始化信息，然后使用\r\nsuper().__init__(name) 调用父类的 __init__\r\n方法，将 name\r\n参数传递给父类构造函数，完成父类部分的初始化工作，最后将\r\nemail 赋值给子类特有的实例属性 self.email\r\n。这里 super()\r\n函数的作用是获取父类的定义，从而调用父类的方法，避免在子类中重复编写父类已有的初始化逻辑。\r\n\r\n方法重写\r\n是指子类可以对从父类中继承过来的方法进行重新定义，从而使得子类对象可以表现出与父类对象不同的行为。\r\n例：创建一个名为”Person”的父类，具有属性”name”和”age”。添加一个名为”get_info”的方法，打印人的姓名和年龄。\r\n然后，创建一个名为”Student”的子类，继承自Person类，并添加一个额外的属性”grade”。在Student类中重写”get_info”方法，也打印出成绩。\r\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age    def get_info(self):        print(&quot;姓名:&quot;, self.name)        print(&quot;年龄:&quot;, self.age)class Student(Person):    def __init__(self, name, age, grade):        super().__init__(name, age)        self.grade = grade    def get_info(self):        super().get_info()        print(&quot;成绩:&quot;, self.grade)\r\n多态\r\n多态，是指在执行同样代码的情况下，系统会根据对象实际所属的类去调用相应类中的方法。\r\n在 Python\r\n中编写一个函数，传递实参前其参数的类型并不确定，在函数中使用形参进行操作时只要传入的对象能够支持该操作程序就能正常执行\r\n。\r\n例：鸭子类型\r\n在程序设计中，鸭子类型（duck\r\ntyping）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。支持“鸭子类型”的语言的解释器/编译器会在解释或编译时推断对象的类型。在鸭子类型中，关注的不是对象所属的类，而是一个对象能够如何使用。\r\nclass Person: # 定义 Person 类    def CaptureImage(self):  # 定义 CaptureImage 方法        print(&#x27;Person 类中的 CaptureImage 方法被调用!&#x27;)class Camera: # 定义 Camera 类    def CaptureImage(self): # 定义 CaptureImage 方法        print(&#x27;Camera 类中的 CaptureImage 方法被调用!&#x27;)def CaptureImageTest(arg): # 定义 CaptureImageTest 方法    arg.CaptureImage() # 通过 arg 调用 CaptureImagep = Person() # 定义 Person 类对象 pc = Camera() # 定义 Camera 类对象 cCaptureImageTest (p)CaptureImageTest (c)\r\n通过统一的方法接口，可以方便地调用不同类中的相同方法。\r\n实例\r\n创建两个不相关的类，分别命名为 ”Book” 和 “DVD”，它们都具有一个方法\r\nplay，但 Book 的 play 方法返回 “Reading the book” 而 DVD 的 play\r\n方法返回 “Playing the DVD”。创建一个函数\r\nstart_playing，接受一个对象并调用其 play 方法，展示鸭子类型。\r\nclass Book:    def play(self):        return &quot;Reading the book&quot;class DVD:    def play(self):        return &quot;Playing the DVD&quot;def start_playing(obj):    return obj.play()# 创建Book和DVD的实例book = Book()dvd = DVD()# 调用start_playing函数print(start_playing(book))print(start_playing(dvd))\r\n类中的封装\r\n在面向对象编程里，类的封装是一种重要特性。它一方面把属性和方法集合在一起，形成一个逻辑单元，让代码结构更清晰；另一方面，它还能把类里一些不希望被外部随意访问、只在类内部使用的属性和方法隐藏起来，提高代码的安全性和稳定性。\r\n\r\n集合了对应的属性和方法\r\n将类中私有的、只在内部使用的属性和方法进行隐藏\r\n\r\n第一是约定任何以单下划线_开头的名字都应该是内部实现。\r\nclass A():    def __init__(self):        self._internal = 0          self.public = 1      def public_method(self):        pass    def _internal_method(self):        passa = A()a._internal_method()\r\n\r\n属性和方法定义：在 A\r\n类中，_internal 是属性，_internal_method\r\n是方法，它们都以单下划线开头，表明是内部使用的。而 public\r\n属性和 public_method\r\n方法没有下划线，是供外部正常访问的。\r\n访问情况：虽然 Python\r\n不会从语法层面阻止外部访问这些带单下划线开头的属性和方法，像\r\na._internal_method()\r\n这样的调用是可以执行的，但这不符合规范。这只是一种约定，提醒开发者这些是类的内部实现细节，最好不要在外部调用，否则可能破坏类的设计逻辑，让代码变得脆弱、难以维护。而且这种约定不仅适用于类，模块名（如\r\n_private_module ）和模块级别函数（如\r\nsys._getframe() ）也适用，使用时要谨慎。\r\n\r\n第二，使用双下划线__开始\r\n当属性或方法以双下划线 __ 开头时，Python\r\n会对其名称进行特殊处理。\r\n会导致访问名称变成其他形式（名称改写／name mangling）。\r\nclass B():    def __init__(self):        self.__private = 0    def __private_method(self):        print(self.__private)    def public_method(self):        self.__private_method()        passb = B()b.__dict__  # Python会把属性名存入实例的__dict__属性中\r\n\r\n名称改写：在 B\r\n类中，__private 属性和 __private_method\r\n方法，Python 会将它们重命名为 _B__private 和\r\n_B__private_method 。查看实例 b 的\r\n__dict__\r\n属性（它存储了实例的属性信息），就能发现这种改写后的名称。\r\n目的：这种机制主要是为了在继承时防止子类意外覆盖父类的私有属性和方法。比如：\r\n\r\nclass C(B):    def __init__(self):        super().__init__()        self.__private = 1   # does not override B.__private    # does not override B.__private_method()            def __private_method(self):        passc = C()c.__dict__ # c._B__private_method()\r\n在子类 C 中，__private 和\r\n__private_method 同样会被改写，变成\r\n_C__private 和 _C__private_method ，和父类\r\nB\r\n中对应的名称不一样，所以不会覆盖父类的私有属性和方法。\r\nPython 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多\r\nPython 程序员严格遵守的约定，他们不会在类外部访问这种属性。\r\n当你定义的一个变量和某个保留关键字冲突，可以使用单下划线作为后缀：\r\n总结：\r\n\r\n_和__都可以定义私有属性\r\n使用__来定义的属性，调用时需要将命名方式调整为_ClassName__methodName\r\n__方法适用于需要在子类中进行隐藏的情况\r\n\r\n创建可管理属性\r\n可管理属性是Python面向对象编程中一个强大的特性，它允许你控制对类属性的访问、修改和删除操作。\r\n在面向对象编程中，我们有时需要对属性的访问进行控制：\r\n\r\n在设置属性时进行类型检查或验证\r\n在获取属性时进行计算或格式化\r\n防止某些属性被删除\r\n创建只读属性\r\n\r\n在对实例属性的获取和设定上，有时候我们希望增加一些额外的处理过程（比如类型检查或者验证）。这种机制可以用于对”私有”属性进行访问和修改。\r\n使用property\r\n要自定义对属性的访问，一种简单的方式是将其定义为\r\nproperty\r\nproperty把类中定义的函数当做一种属性来使用。\r\nproperty()函数可以创建一个属性，它允许你定义getter、setter和deleter方法。\r\nproperty(fget=None, fset=None, fdel=None, doc=None)\r\n\r\nfget: 获取属性值的函数\r\nfset: 设置属性值的函数\r\nfdel: 删除属性的函数\r\ndoc: 属性的文档字符串\r\n\r\n下面的示例代码定义了一个property，增加了对属性的验证。\r\nclass Person():    def __init__(self, first_name):        self.first_name = first_name  # 这里会调用setter方法    def get_first_name(self):        print(&quot;get_first_name is called.&quot;)        return self._first_name    def set_first_name(self, value):        print(&quot;set_first_name is called.&quot;)        if not isinstance(value, str):            raise TypeError(&#x27;Expected a string&#x27;)        self._first_name = value    def del_first_name(self):        print(&quot;del_first_name is called.&quot;)        raise AttributeError(&quot;Can&#x27;t delete attribute&quot;)    first_name = property(get_first_name, set_first_name, del_first_name, &quot;first_name property&quot;)    # 每次对 first_name 这个属性进行访问（获取值、设置值或删除属性）时，都会触发对应的方法。    # 实际的数据存储在 _first_name 属性中。a = Person(21)# print(a._first_name)# a.__dict__\r\n上例中，使用property()定义了一个属性first_name\r\n\r\nproperty()的第一个参数是getter方法，第二个参数是setter方法，第三个参数是deleter方法\r\nproperty\r\n的一个关键特征是它看上去跟普通的属性（attribute）没什么两样，但是访问它的时候会自动触发getter、setter、deleter方法。\r\n\r\n在实现一个 property\r\n的时候，底层数据（如果有的话）仍然需要存储在某个地方\r\n\r\n在getter和setter方法中，你会看到对_firse_name的操作，这也是实际数据保存的地方\r\n数据实际存储在_first_name中（注意前面的下划线表示这是内部属性）。\r\n\r\n为什么__init__()方法中设置了self.first_name而不是self._first_name\r\n\r\n在这个例子中，创建一个 property\r\n的目的就是在设置attribute的时候进行检查\r\n这样设置是为了在初始化的时候也进行这种类型检查\r\n通过设置self.first_name，自动调用setter方法，这个方法里面会进行参数的检查，否则就是直接访问self._first_name了\r\n在__init__方法中设置self.first_name而不是self._first_name，这样会调用setter方法进行验证。\r\n\r\n使用装饰器\r\n另一种定义属性的方法是使用装饰器\r\n装饰器语法提供了更简洁的方式来定义可管理属性。\r\nclass Person():    def __init__(self, first_name):        self.first_name = first_name              # 只有在`first_name`属性被创建后    # 后面的两个装饰器`@first_name.setter`和`@first_name.deleter`才能被定义    @property    def first_name(self):        return self._first_name    @first_name.setter    def first_name(self, value):        print(&quot;setter&quot;)        if not isinstance(value, str):            raise TypeError(&#x27;Expected a string&#x27;)        self._first_name = value    @first_name.deleter    def first_name(self):        raise AttributeError(&quot;Can&#x27;t delete attribute&quot;)a = Person(&quot;Mark&quot;)print(a.first_name)# a.first_name = 42\r\n\r\n装饰器顺序：\r\n\r\n必须先定义@property方法（getter）\r\n然后才能定义@xxx.setter和@xxx.deleter\r\n\r\n方法命名：\r\n\r\n所有相关方法必须使用相同的名称\r\n这是装饰器语法要求的\r\n\r\n文档字符串：\r\n\r\n可以在@property方法中添加文档字符串\r\n通过help(Person.first_name)可以查看\r\n\r\n\r\n上述代码中有三个相关联的方法，这三个方法的名字都必须一样。@property用于指示getter方法，它使得first_name成为一个属性。@first_name.setter用于指示setter方法，@first_name.deleter用于指示deleter方法。需要强调的是只有在first_name属性被创建后，后面的两个装饰器@first_name.setter和@first_name.deleter才能被定义。\r\n注意：不要写没有做任何其他额外操作的property。\r\n另外，property还可以用于创建动态计算的属性，这些属性不会实际存储，而是在访问时计算\r\nimport mathclass Circle():    def __init__(self, radius):        self.radius = radius    @property          # 实现只读，只能访问(get)，无法修改(set)    def area(self):        return math.pi * self.radius ** 2    @property    def perimeter(self):        return 2 * math.pi * self.radiusc = Circle(4.0)     # 创建一个 Circle 实例print(c.radius)     # 打印半径print(c.area)       # 注意这里没有（）print(c.perimeter)  # 注意这里没有（）\r\n特点\r\n\r\n只读属性：如果没有定义setter，属性就是只读的\r\n统一访问接口：无论是存储属性还是计算属性，访问方式都一样\r\n延迟计算：只在访问时计算，节省内存\r\n\r\n在这里，我们通过使用property，将所有的访问接口形式统一起来，对半径、周长和面积的访问都能够简单地以属性的形式进行访问，而不必将属性访问和方法调用混在一起使用了。\r\n如果你没有指定某一特性的*setter*属性（@area.setter），那么将无法在类的外部对它的值进行设置。这对于只读的特性非常有用：\r\n总结：\r\n\r\n类的定义中使用@property可以实现属性的获取（“getter”）\r\n类的定义中使用@setter可以实现属性的设置(“setter”)\r\n\r\n可管理属性是Python面向对象编程中非常强大的特性，它允许你：\r\n\r\n控制属性的访问、设置和删除行为\r\n添加验证逻辑和类型检查\r\n创建动态计算的属性\r\n实现只读属性\r\n保持统一的访问接口\r\n\r\n无论是使用property()函数还是装饰器语法，都能有效地增强类的封装性和安全性。选择哪种方式主要取决于个人偏好和代码的可读性，装饰器语法通常更为简洁明了。\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Servlet与会话管理","url":"/posts/45466.html","content":"为什么进行会话管理\r\nWeb应用程序基于HTTP协议\r\n\r\nHTTP基于请求/响应模式\r\n\r\n所有请求都是相互独立的，无连续性的\r\n\r\nHTTP是无连接的协议\r\n\r\n限制每次连接只处理一个请求\r\n\r\nHTTP是无状态的协议\r\n\r\n协议对于事务处理没有记忆能力\r\n\r\n\r\n对于简单的页面浏览或信息获取，HTTP协议即可胜任，但是对于需要客户端和服务器端多次交互的网络应用，则必须记住客户端状态\r\n会话就是一个客户端连续不断地和服务器端进行请求/响应的一系列交互\r\n何为会话\r\n多次请求间建立关联的方式称为会话管理，或会话跟踪\r\n会话状态，指服务器与浏览器在会话过程中产生的状态信息\r\n会话管理是管理浏览器客户端和服务器端之间会话过程中产生的会话数据。\r\n会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话，主要有四种会话跟踪方法，设置隐藏表单字段，URL重写，Cookie和Session。常用的会话跟踪技术是Cookie和Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。\r\n浏览器客户端和服务器端的会话管理涉及的技术有Cookie技术与Session技术，两者的区别在于：\r\n- Cookie技术将会话数据保存在浏览器客户端 -\r\nSession技术将会话数据保存在服务器端\r\n会话的实现过程\r\nHTTP没有提供任何记住客户端的途径，服务器如何建立、维护与客户端的会话\r\n\r\n\r\nimage-20250415081247045\r\n\r\n\r\n\r\nimage-20250415081247045\r\n\r\nCookie技术\r\n如何理解Cookie技术\r\nCookie实际上是存放在客户端浏览器的一小块文本。\r\n客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来记录用户状态。\r\nCookie的工作原理主要的记录用户状态，客户端浏览器第一次请求服务器后，服务器会颁发一个Cookie(name\r\n=\r\nErgouTree，该Cookie就相当于那唯一的卡号)响应给客户端浏览器，以后客户端的每次请求都会带上这个Cookie，这样服务器就可以根据这唯一的Cookie识别不同的用户。\r\n特点\r\n\r\nCookie技术将会话数据保存在浏览器客户端。\r\nCookie数据只能是非中文的字符串类型的数据\r\n浏览器可以保存多个Cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie\r\n每个Cookie的大小限制为4KB\r\n\r\nCookie核心API\r\nCookie(String name, String value)   // 用户创建Cookie对象的构造函数void setPath(String uri)    // 设置cookie的有效访问路径，这个可以在浏览器内看，设置-&gt;内容设置-&gt;Cookie-&gt;查看所有Cookie和网站void setMaxAge(int expiry)    // 设置cokie的存活时间void setValue(String newValue)   // 设置cookie的值Cookie[] request.getCookies()    // 接收cookievoid response.addCookie(Cookie cookie)    // 发送cookie到浏览器端保存\r\nCookie的创建\r\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);response.addCookie(cookie);   // Cookie从servlet里发送到浏览器端\r\n创建Cookie对象，利用Cookie的构造函数来创建Cookie，Cookie的构造函数有两个参数，name和value，必须要有这两个参数，value固定为String类型的。\r\nCookie 是存放在浏览器端的，所以还需要把 Cookie 从 servlet\r\n里发送到浏览器端，利用response里的addCookie方法可以做到，原理是通过在响应中设置\r\nset-Cookie 标头，以 Key/Value 键值对的形式发送到浏览器\r\n你可以使用google浏览器查看响应头中的set-Cookie标头，你能看到你刚刚添加的Cookie和它的属性值\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n响应首部中黄色的部分就是从Servlet发送到浏览器的Cookie\r\n请求首部中红色划线部分是浏览器发回到服务器的Cookie，这个不是你刚创建的Cookie，因为你创建的Cookie刚发送到浏览器，之后你再请求一次就可以在请求首部看到你刚创建的Cookie。\r\nCookie的获取\r\n在Servlet中只能使用getCookies方法获取所有的Cookie，没有通过Cookie名来获取Cookie的方法。所以需要你自己来编写代码实现。\r\n&lt;%    // 如何获取Cookie    Cookie[] cookies = request.getCookies();   // 返回值类型为Cookie[]    if (cookies != null) &#123;        for (int i = 0; i &lt; cookies.length; i++) &#123;            System.out.println(cookies[i].getName() + &quot;: &quot; + cookies[i].getValue());        &#125;    &#125;%&gt;\r\nCookie的修改与删除　\r\nCookie并不提供修改，删除操作。\r\n如果要修改某个Cookie，需要新建一个同名的Cookie，并添加到response中就会覆盖原来的Cookie。\r\n下面的两行代码就可把username的value值 “kindleheart”改为”Hush”。\r\n// 修改Cookie的示例方法protected void modifyCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 假设我们要将用户名从旧值改为&quot;Hush&quot;    Cookie cookie = new Cookie(&quot;username&quot;, &quot;Hush&quot;);    cookie.setPath(&quot;/Demo&quot;);  // 设置与原始Cookie相同的路径    cookie.setMaxAge(7 * 24 * 60 * 60); // 保持相同的有效期    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已修改&quot;);&#125;\r\n删除Cookie的实现\r\n如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。\r\n// 删除Cookie的标准方法protected void deleteCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 1. 创建一个同名Cookie    Cookie cookie = new Cookie(&quot;username&quot;, &quot;&quot;);    // 设置值为空        // 2. 设置path与原始Cookie一致（重要！）    cookie.setPath(&quot;/Demo&quot;);        // 3. 设置生存期为0（立即失效）    cookie.setMaxAge(0);        // 4. 添加到响应中    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已删除&quot;);&#125;\r\n修改和删除Cookie时，新建的Cookie除value，maxAge之外的所有属性，例如name，path，domain等，都要与原Cookie完全一样。否则，浏览器会把这两个Cookie视为不同的Cookie，不允许覆盖，导致修改删除失败。\r\n服务的完整示例\r\n@Override   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       request.setCharacterEncoding(&quot;UTF-8&quot;);       // 获取表单数据       String username = request.getParameter(&quot;username&quot;);       String password = request.getParameter(&quot;pwd&quot;);       String rememberMe = request.getParameter(&quot;rememberMe&quot;);       // 简单的验证（实际项目中应该连接数据库验证）       if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;           // 登录成功           // 如果用户选择了&quot;记住我&quot;           if(&quot;true&quot;.equals(rememberMe)) &#123;               // 创建Cookie保存用户名               Cookie usernameCookie = new Cookie(&quot;username&quot;, username);               // 设置Cookie有效期为7天               usernameCookie.setMaxAge(7 * 24 * 60 * 60);               response.addCookie(usernameCookie);           &#125;else&#123;               // 用户没有选择记住我，删除可能存在的Cookie               Cookie usernameCookie = new Cookie(&quot;username&quot;, &quot;&quot;);               usernameCookie.setMaxAge(0); // 立即过期               response.addCookie(usernameCookie);           &#125;           // 创建会话           HttpSession session = request.getSession();           session.setAttribute(&quot;username&quot;, username);           // 重定向到欢迎页面           response.sendRedirect(&quot;&quot;);       &#125;else&#123;           // 登录失败           response.sendRedirect(&quot;index.jsp?error=1&quot;);       &#125;   &#125;\r\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 初始化变量    String name = &quot;&quot;;    boolean isRemembered = false;        // 获取Cookie    Cookie[] cookies = request.getCookies();    if (cookies != null) &#123;        for (Cookie cookie : cookies) &#123;            // 查找用户名Cookie            if(cookie.getName().equals(&quot;username&quot;))&#123;                name = cookie.getValue();                isRemembered = true;            &#125;        &#125;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;用户登录&lt;/h2&gt;    &lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;        账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;1&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;        记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;        登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\r\nCookie的属性\r\n除了name与value之外，Cookie还有其它的一些可选属性，比如注释、路径和域限定符、最大生存时间和版本号。\r\n每个属性对应着一个get方法和一个set方法。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n有效期\r\nCookie的maxAge决定着Cookie的有效期，单位为秒，默认值为-1。\r\nCookie中通过getMaxAge()方法与setMaxAge()方法来读写maxAge属性。\r\n\r\nmaxAge &gt; 0：表示Cookie会在 maxAge 秒之后自动失效。浏览器会将\r\nmaxAge\r\n为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在\r\nmaxAge 秒之前，登录网站时该Cookie仍然有效。\r\nmaxAge &lt; 0，则表示该Cookie仅仅在关闭窗口前有效。maxAge\r\n为负数的Cookie，为临时Cookie，不会被持久化，不会被写到Cookie文件中，而是保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。\r\nmaxAge =\r\n0，有效时间为0，就表示为删除Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除。\r\n\r\nCookie的域名\r\nCookie是不可跨域名的，同一个一级域名下的两个二级域名如\r\nwww.kindleheart.com 和 images.kindleheart.com\r\n也不能互相使用Cookie，因为二者的域名并不严格相同。如果想所有kindleheart.com名下的二级域名都可以使用该Cookie，可以设置domain参数。\r\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setDomain(&quot;.kindleheart.com&quot;);response.addCookie(cookie);\r\nCookie的路径\r\ndomain属性决定访问Cookie的域名，而path属性决定允许访问Cookie的路径(ContextPath)。\r\n如果只允许Demo工程下的程序使用Cookie，可以这么写：\r\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setPath(&quot;/Demo&quot;);response.addCookie(cookie);\r\nSeesion\r\n核心API\r\nHttpSession getSession()    ——    得到session对象HttpSession getSession(boolean create)    ——  当create参数为true时，如果获取不到对应session对象就为浏览器创建一个session对象；如果create参数为false时，如果获取不到对应session对象就返回null。   void setAttribute(String name, Object value)    ——    保存会话数据到session对象Object getAttribute(String name)    ——    从session对象中获取会话数据void removeAttribute(String name)    ——     清除session对象中对应的会话数据void setMaxInactiveInterval(int interval)    ——    设置session的有效时间，默认情况是30分钟void invalidate()    ——    销毁session对象String getId()    ——    得到session编号\r\n理解Session\r\nCookie可以让服务器跟踪每个客户端的访问，Cookie存放在客户端浏览器，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多，那么无形地会增加了客户端与服务器端的数据传输量，而Session正是解决这个问题的。\r\nSession存放在服务器端，同一个客户每次和服务器端进行交互时，不需要每次传回所有的Cookie值，而是只要传回一个ID，这个ID是客户端第一次访问时生成的，而且每个客户端都是唯一的，这样每个客户端都有了一个唯一的ID，客户端只需要传回这个ID就行了，这个ID通常是name为JSESSIONID的一个Cookie。\r\n实际上有以下三种方式使得Session正常工作。\r\n\r\n基于Cookie，如果没有修改Context容器的Cookies标识，则默认也是支持的。客户端每次请求的时候，Cookie会被返回到服务器，利用请求头中的Cookie标头。　　\r\n基于URL Path Parameter(URL重写)，默认支持。\r\n浏览器不支持Cookie或者用户把浏览器的Cookie功能关闭了，浏览器就会把该用户的Session的ID信息(JSESSIONID)重写到用户请求的URL参数中，服务器再从URL参数中解析出Session的ID。、\r\n首先我们把浏览器的Cookie关闭，再使用HttpServletRequest类提供的encodeURL(String url)实现地址重写，下面是一个计录浏览次数的小例子：\r\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       response.setContentType(&quot;text/html;charset=utf-8&quot;);       HttpSession session = request.getSession();       int count = 0;       if(session.getAttribute(&quot;count&quot;) != null) &#123;           int c = (int) session.getAttribute(&quot;count&quot;);           count = c + 1;       &#125;       session.setAttribute(&quot;count&quot;, count);       PrintWriter out = response.getWriter();       out.println(&quot;&lt;html&gt;&quot;);       out.println(&quot;&lt;body&gt;&quot;);       out.println(&quot;&lt;h1&gt;登入&quot; + count + &quot;次&lt;/h1&gt;&quot;);       //URL重写把JSESSIONID发送到服务器       out.println(&quot;&lt;a href=&#x27;&quot; + response.encodeURL(&quot;IndexServlet&quot;) + &quot;&#x27;&gt;click me&lt;/a&gt;&quot;);       out.println(&quot;&lt;/body&gt;&quot;);       out.println(&quot;&lt;/html&gt;&quot;);       out.close();   &#125;  \r\n在浏览器的地址栏URL里文件名后面URL参数前面可以看到 jsessionid =\r\nXXX。　\r\n注意：如果浏览器支持Cookie，那么Tomcat仍然会解析Cookie里的中的Session\r\nID，并会覆盖URL中的Session ID，也就是你在URL就中看不到 jsessionid =\r\nXXX了。\r\n基于SSL，默认不支持，只有connector.getAttribute(“SSLEnabled”)为TRUE时才支持。\r\n\r\nSession的生命周期\r\n\r\nSession的创建\r\n\r\n\r\nSession在用户第一次请求服务器的时候自动创建，只有访问Servlet，JSP等动态资源才会创建，访问HTML，IMAGE等静态资源并不会创建Session，如果没有创建成功，也可以使用request.getSession(true)强制创建Session。\r\n\r\n\r\nSession的获取\r\n\r\n\r\n通过HttpServletRequest对象的getSession方法获取一个HttpSession实例。\r\n//获取此会话HttpSession session = request.getSession();\r\n\r\n\r\nSession的撤销\r\nSession的撤销有三种可能的情况：\r\n\r\nSession超时，Session的默认有效期为30分钟，你如果30分钟内没有请求服务器，Session就会撤销，你30分钟内请求了服务器，服务器就认为你active了一次，重新计算有效期。\r\n可以在web.xml文件里或者使用setMaxInactiveInterval(20 *  60)方法设置Session的有效期，注意的是web.xml文件里参数以分为单位，15分钟，setMaxInactiveInterval(20 * 60)中的参数以秒为单位，这里是20分钟。\r\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;session-config&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;  &lt;/session-config&gt;&lt;/web-app&gt;\r\n//设置Session的有效期为20分钟session.setMaxInactiveInterval(20 * 60);\r\n通过会话对象使用invalidate方法使Session无效。\r\n//使此会话无效session.invalidate();\r\n程序结束\r\n\r\n\r\nSession的属性操作\r\n\r\nSession增加属性\r\nSession中的属性也是以键值对的形式存储的，用setAttibute(name, value)方法添加属性，value是Object对象的，所以value不限于String类型，可以是任何数据类型。\r\n//添加一个name为count的属性，值为250int count = 250;session.setAttribute(&quot;count&quot;, count);\r\nSession获取属性值\r\n//获取name为count的value值，需要强转int count = (int) session.getAttribute(&quot;count&quot;);\r\nSession修改属性\r\nSession修改属性，直接使用setAttibute(name, value)方法覆盖相同name的Session即可。\r\n//把name为count的属性值由250修改到520session.setAttribute(&quot;count&quot;, 250);session.setAttribute(&quot;count&quot;, 520);\r\nSession删除属性\r\nSession删除属性，使用removeAttribute(name)方法，删除对应name的属性。\r\n//删除name为count的属性session.removeAttribute(&quot;count&quot;);\r\n\r\n应用实例\r\n@Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;pwd&quot;);        String rememberMe = request.getParameter(&quot;rememberMe&quot;);        // 简单的登录验证        if(isValidUser(username, password)) &#123;            // 创建或获取session            HttpSession session = request.getSession();            // 存储登录状态            session.setAttribute(&quot;isLoggedIn&quot;, true);            session.setAttribute(&quot;username&quot;, username);            // 如果用户选择了&quot;记住我&quot;            if(&quot;true&quot;.equals(rememberMe)) &#123;                session.setAttribute(&quot;rememberMe&quot;, true);                // 设置session超时时间（7天）                session.setMaxInactiveInterval(7 * 24 * 60 * 60);            &#125;else &#123;                // 不记住则移除属性                session.removeAttribute(&quot;rememberMe&quot;);                // 使用默认的超时时间            &#125;            // 重定向到欢迎页面            response.sendRedirect(&quot;welcome.jsp&quot;);        &#125; else &#123;            // 登录失败            response.sendRedirect(&quot;index.jsp?error=1&quot;);        &#125;    &#125;\r\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 检查session中是否有记住的用户名    String name = &quot;&quot;;    boolean isRemembered = false;    HttpSession existingSession = request.getSession(false);    if (existingSession != null &amp;&amp; existingSession.getAttribute(&quot;rememberMe&quot;) != null) &#123;   \t    // 取出session中存储的用户名，一般只是取出，不修改        name = (String) existingSession.getAttribute(&quot;rememberMe&quot;);        isRemembered = true;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录(Session版)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;用户登录(Session版)&lt;/h2&gt;&lt;% if (&quot;1&quot;.equals(request.getParameter(&quot;error&quot;))) &#123; %&gt;&lt;p style=&quot;color:red;&quot;&gt;用户名或密码错误!&lt;/p&gt;&lt;% &#125; %&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;    账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;    记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;    登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\r\n比较ServletContext，HttpServletRequest和HttpSession\r\nServletContext\r\n\r\n范围最大,应用程序级别的,整个应用程序都能访问；\r\n是Servlet上下文对象，在服务器启动阶段解析web.xml文件创建ServletContext对象，在同一个web\r\napp中所有的Servlet对象共享同一个ServletContext对象。该对象一旦创建不会被销毁，除非将服务器停掉。\r\n一般存储在该对象中的数据首先是所有用户共享的，不会被修改的，少量数据。\r\nServletContext对象传递数据可以跨Servlet、跨请求、跨用户(跨会话)传递数据。\r\n\r\nHttpSession\r\n\r\n次之,会话级别的，在当前的浏览器中都能訪问，不论是在同一浏览器开多少窗体，都能够访问，可是换个浏览器就不行了，就必须又一次创建session；\r\n每一个用户都有一个这样的对象，是一个用户级别的对象，存储在该对象中的数据一般都是该用户专属的数据\r\nHttpSession对象传递数据可以跨Servlet、跨请求(这些请求必须属于同一个会话)、但是不能跨用户传递数据。\r\n\r\nHttpServletRequest\r\n\r\n范围最小,请求级别,请求结束,变量的作用域也结束（也就是仅仅是一次访问,访问结束，这个也结束）。\r\n是请求对象，一次请求一个对象，每一次请求都会新建一个请求对象，是一个请求级别的对象，存储该对象中的数据一般都是请求级别的数据，一次请求之后这个数据就不再使用的数据可以存储在该对象中\r\nHttpServletRequest对象传递数据可以跨Servlet，但是不能跨请求，更不能跨用户传递数据。\r\n\r\n尽量从小范围向大范围使用。(考虑原则：request&lt; session &lt;\r\napplication)\r\nServletContext、HttpSession、HttpServletRequest接口的对比：\r\n以上都是范围对象:\r\n\r\nServletContext application; 是应用范围\r\nHttpSession session; 是会话范围\r\nHttpServletRequest request; 是请求范围\r\n\r\n三个范围的排序：application &gt; session &gt; request\r\n\r\napplication完成跨会话共享数据\r\nsession完成跨请求共享数据，但是这些请求必须在同一个会话当中\r\nrequest完成跨Servlet共享数据，但是这些Servlet必须在同一个请求当中【转发】\r\n\r\n使用原则：有小到大尝试，优先使用小范围。例如：\r\n\r\n登录成功之后，已经登录的状态需要保存起来，可以将登录成功的这个状态保存到session对象中。\r\n登录成功状态不能保存到request范围中，因为一次请求对应一个新的request对象。\r\n登录成功状态也不能保存到application范围中，因为登录成功状态是属于会话级别的，不能所有用户共享。\r\n\r\nCookie与Session的比较\r\nCookie与Session都是为了保持用户访问的连续状态，之所以为了要保持这种状态，一方面是为了实现业务方便，另一方面就是简化服务器端的程序设计，提高访问性能。但是两者的实现原理不太一样，各自都有优点和缺陷，下面通过比较说明这两者的特点和适用场合。\r\n\r\n存取方式上\r\nCookie中只能保持ASCLL字符串，如果存取Unicode字符或者二进制数据，需要进行UTF-8，GBK，或者BASE64等方式的编码，而Session中可以存取任何类型的数据。\r\n隐私安全上\r\nCookie存放在客户端浏览器，对客户端是可见的，客户端的一些程序可能会窥探复制甚至修改Cookie中的内容。而Session存放在服务器端，对用户是透明的，不存在敏感信息泄露的危险。\r\n有效期上\r\nCookie可以设置长期有效，浏览器关闭也有效，虽然Session可以设置很长的有效期，但是Session依赖名为JSESSIONID的Cookie，该Cookie的maxAge默认为-1，浏览器关闭Cookie就失效，所以该Session也就失效了。\r\n服务器的负担上\r\nSession存放在服务器端，每个用户都会产生一个Session。如果并发非常大的网站，会产生大量的Session，消耗大量内存，因此像Baidu，Google这样并发量极高的网站是不会使用Session来追踪会话的，而Cookie保存在客户端，不占用服务器资源，对于并发量极高的网站Cookie是更好的选择。\r\n从浏览器支持上\r\nCookie是需要浏览器支持的，如果浏览器不支持Cookie，就需要使用Session以及URL地址重写。\r\n从跨域名上\r\nCookie支持跨域名访问，只要设置domain属性即可，但Session不能够跨域名访问，Session仅在他的域名下有效。\r\n\r\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Servlet"]},{"title":"Python面向对象之变量的作用域","url":"/posts/10432.html","content":"变量的作用域\r\n局部变量和全局变量。\r\n变量的作用域是指变量的作用范围，即定义一个变量后，在哪些地方可以使用这个变量。\r\n按照作用域的不同，Python 中的变量可分为局部变量和全局变量。\r\n例：我们定义并测试一个函数，它读取两个变量的值。\r\n# 读取两个变量的值。变量a是函数的参数；变量b，这个函数没有定义它。def f1(a):    print(a)    print(b)b = 5f1(2)# 2# 5\r\n局部变量：在一个函数中定义的变量就是局部变量（包括形参），其作用域是从定义局部变量的位置至函数结束位置。\r\n全局变量：在所有函数外定义的变量就是全局变量，其在所有函数中都可以使用。\r\ndef f1(a):    print(a)    print(b)b = 6     #如果先给全局变量b赋值，然后再调用f1,就不会出错。f1(3)\r\nb = 6def f2(a):    print(a)    b = 7    print(b)    b = 9  # Python编译函数定义体时，判断b是局部变量，因为在函数中给它赋值了。f2(3)# 3# 7\r\n这不是缺陷，而是设计选择：Python\r\n不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\r\nglobal\r\n如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global\r\n声明：\r\nb = 6def f3(a):    global b    print(a)    print(b)    b = 9f3(3)b# 3# 6# 9\r\nnonlocal\r\n在Python\r\n中，函数的定义可以嵌套，即在一个函数的函数体中可以包含另一个函数的定义\r\n通过 nonlocal\r\n关键字，可以使内层的函数直接使用外层函数中定义的变量。\r\ndef outer_function():    counter = 0          def inner_function():        nonlocal counter  # 声明 counter 是非局部的        counter += 1        return counter    return inner_functionfunc = outer_function()func()print(func())# 2\r\n总结：\r\n\r\n局部变量与全局变量。\r\nPython\r\n不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\r\nglobal 和 nonlocal 关键字。\r\n\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Servlet学习之核心接口,工作原理和配置","url":"/posts/4234.html","content":"什么是Servlet\r\n运行在服务器端的程序\r\nservlet是一个接口，定义了Java类被浏览器访问到的规则（接口）\r\nServlet是用java编写的服务器端的程序，主要是交互式的浏览和修改数据，生成动态Web内容，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上\r\nServlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\r\nStruts2的核心用的是Filter（过滤器），而SpringMVC的核心用的就是Servlet。\r\n// WebServlet注解表示这是一个Servlet，并映射到地址/:@WebServlet(urlPatterns = &quot;/&quot;)public class HelloServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;        // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;&#125;\r\n一个Servlet总是继承自HttpServlet，然后重写doGet()或doPost()方法。注意到doGet()方法传入了HttpServletRequest和HttpServletResponse两个对象，分别代表HTTP请求和响应。我们使用Servlet\r\nAPI时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为HttpServletRequest和HttpServletResponse就已经封装好了请求和响应\r\n工作模式\r\n\r\n客户端发送请求至服务器\r\n服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器\r\n服务器将响应返回客户端\r\n\r\nAPI预览\r\nServlet API 包含以下4个Java包：\r\n1.javax.servlet\r\n其中包含定义servlet和servlet容器之间契约的类和接口。\r\n2.javax.servlet.http 其中包含定义HTTP Servlet\r\n和Servlet容器之间的关系。\r\n3.javax.servlet.annotation\r\n其中包含标注servlet，Filter,Listener的标注。它还为被标注元件定义元数据。\r\n4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。\r\n使用Servlet\r\nServlet技术的核心是Servlet，它是所有Servlet类必须直接或者间接实现的一个接口。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。\r\n工作原理\r\n​\r\nServlet接口定义了Servlet与servlet容器之间的契约：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。\r\n​\r\n但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\r\n​\r\n用户请求致使Servlet容器调用Servlet的Service()方法,并传入一个ServletRequest对象和一个ServletResponse对象。\r\nServletRequest中封装了当前的Http请求,ServletResponse表示当前用户的Http响应.\r\n​\r\n对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。\r\n接口中定义的方法\r\npublic interface Servlet &#123;    // 这是 Servlet 的初始化方法，在 Servlet 实例被创建之后，容器会调用此方法对 Servlet 进行初始化操作。    void init(ServletConfig var1) throws ServletException; \t    // 用于获取 Servlet 的配置信息，会返回由Servlet容器传给init（ ）方法的ServletConfig对象    ServletConfig getServletConfig(); \t    // 用来处理客户端的请求并生成响应。当有客户端请求到达时，Servlet 容器会调用这个方法。    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; \t    // 用于返回 Servlet 的描述信息    String getServletInfo(); \t    // 这是 Servlet 的销毁方法，在 Servlet 实例被销毁之前，容器会调用此方法，用于释放 Servlet 占用的资源    void destroy();&#125;\r\n执行原理\r\n当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\r\n查找Web.xml文件，是否有对应的标签体的内容，如果有，则在对应的全类名\r\ntomcat会将其字节码加载进内存然后构建对象，调用其方法\r\nServlet的生命周期\r\n上述接口中定义的方法内，init( ),service( ),destroy(\r\n)是Servlet生命周期的方法。\r\nServlet容器（例如TomCat）会根据下面的规则来调用这三个方法：\r\n\r\n当Servlet第一次被请求时，Servlet容器就会开始调用 init()\r\n方法，初始化一个Servlet对象出来,这个方法在后续请求中不会在被Servlet容器调用。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。\r\nservice(\r\n)方法，每当请求Servlet时，Servlet容器就会调用这个方法，第一次请求时，Servlet容器会先调用init(\r\n)方法初始化一个Servlet对象出来，然后会调用它的service(\r\n)方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。\r\ndestory,当要销毁Servlet时，Servlet容器就会调用这个方法，一般在这个方法中会写一些清除代码，只有服务器正常关闭的时候，才会执行destory方法\r\n演示代码\r\n@Overridepublic void init(ServletConfig servletConfig) throws ServletException &#123;    System.out.println(&quot;Servlet正在初始化&quot;);&#125; @Overridepublic ServletConfig getServletConfig() &#123;    return null;&#125; @Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;    //专门向客服端提供响应的方法    System.out.println(&quot;Servlet正在提供服务&quot;); &#125; @Overridepublic String getServletInfo() &#123;    return null;&#125; @Overridepublic void destroy() &#123;    System.out.println(&quot;Servlet正在销毁&quot;);&#125;\r\n\r\n其中servlet的创建时期是可以被指定的\r\n&lt;!-- 指定servlet的创建时期，负数为第一次访问时期，0或正数为服务器启动时期--&gt;&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;\r\nServlet中的 init\r\n方法只执行一次，说明一个Servlet中只存在一个对象，是单例的，多个用户同时访问可能存在线程安全的隐患，所以尽量不要再其中定义成员变量，也不要对其赋值\r\nTomcat部分\r\n普通的Java程序是通过启动JVM，然后执行main()方法开始运行。但是Web应用程序有所不同，我们无法直接运行war文件，必须先启动Web服务器，再由Web服务器加载我们编写的HelloServlet，这样就可以让HelloServlet处理浏览器发送的请求。\r\nTomcat本身的目录层次结构\r\n\r\n\r\nimg\r\n\r\nTomcat提供了一个部署其服务器在你本地电脑上的功能\r\n​\r\n实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机\r\n​\r\n执行Tomcat的main()方法，然后由Tomcat负责加载我们的.war文件，并创建一个HelloServlet实例，最后以多线程的模式来处理HTTP请求。\r\n​\r\n如果Tomcat服务器收到的请求路径是/（假定部署文件为ROOT.war），就转发到HelloServlet并传入HttpServletRequest和HttpServletResponse两个对象。\r\n配置Servlet\r\nweb.xml配置\r\nweb.xml 文件是用于配置 Web 应用程序的核心文件，它能对\r\nServlet、过滤器、监听器等组件进行配置\r\nServlet 定义\r\n&lt;servlet&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.ergoutree.servletexpdemo.demo1.FastGo&lt;/servlet-class&gt;&lt;/servlet&gt;\r\n\r\n标签：该标签的作用是定义一个 Servlet。在一个\r\nweb.xml 文件中，可以定义多个 Servlet。\r\n标签：这里为 Servlet 指定一个名称，也就是\r\nServletExpDemo。这个名称属于逻辑名称，主要用于在\r\nweb.xml 文件的其他部分引用该 Servlet。\r\n标签：它指定了 Servlet 类的全限定名，即\r\norg.ergoutree.servletexpdemo.demo1.FastGo。当 Web\r\n容器启动时，会依据这个全限定名来加载并实例化该 Servlet 类。\r\n\r\nServlet 映射\r\n&lt;servlet-mapping&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\r\n\r\n标签：此标签的功能是将 Servlet 与一个或多个 URL\r\n模式进行映射。当客户端发送请求时，Web 容器会根据请求的 URL 找到对应的\r\nServlet。\r\n标签：这里引用了之前定义的 Servlet 的名称，也就是\r\nServletExpDemo。\r\n标签：它指定了与该 Servlet 关联的 URL 模式，即\r\n/demo1。当客户端请求的 URL 匹配这个模式时，Web\r\n容器就会将请求转发给 ServletExpDemo 所对应的 Servlet\r\n类（也就是org.ergoutree.servletexpdemo.demo1.FastGo）进行处理。\r\n\r\n原理及其示例\r\n原理说明\r\n当客户端向 Web 应用程序发送 HTTP 请求时，Web 容器（像 Tomcat\r\n这类）会按照以下步骤处理请求：\r\n\r\n解析请求 URL：Web 容器对客户端请求的 URL\r\n进行解析，从中提取出请求的路径部分。\r\n查找 Servlet 映射：Web 容器在 web.xml\r\n文件里查找与请求路径相匹配的 ``。\r\n定位 Servlet：若找到匹配的\r\n，Web 容器会根据对应的 找到之前定义的 Servlet。\r\n实例化并调用 Servlet：Web 容器加载并实例化该\r\nServlet 类，然后调用其 service() 方法来处理请求。\r\n返回响应：Servlet\r\n处理完请求后，将响应返回给客户端。\r\n\r\n示例\r\n假设客户端发送的请求 URL 为\r\nhttp://localhost:8080/yourApp/demo1，Web\r\n容器会进行如下操作：\r\n\r\n解析出请求路径为 /demo1。\r\n在 web.xml 文件中找到\r\n为 `/demo1` 的。\r\n根据\r\n`为ServletExpDemo，找到对应的 Servlet 类org.ergoutree.servletexpdemo.demo1.FastGo`。\r\n加载并实例化 FastGo 类，调用其 service()\r\n方法处理请求。\r\n将处理结果返回给客户端。\r\n\r\nSerlvet3.0的注解配置\r\n@WebServlet\r\n的属性列表：\r\n\r\n\r\nimage-20250412202207184\r\n\r\n核心注解@WebServlet\r\n取代  和 ，直接绑定 URL 模式与\r\nServlet 类。\r\n@WebServlet(    name = &quot;userServlet&quot;, // Servlet 名称（可选）    urlPatterns = &#123;&quot;/user&quot;, &quot;/api/user&quot;&#125;, // 支持多 URL 模式    loadOnStartup = 1, // 容器启动时立即加载（替代 &lt;load-on-startup&gt;）    initParams = &#123;        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;) // 初始化参数    &#125;,    asyncSupported = true // 启用异步支持（默认 false）)public class UserServlet extends HttpServlet &#123; ... &#125;\r\n\r\nurlPatterns：支持精确匹配\r\n(/user)、通配符 (/api/*)、后缀匹配\r\n(*.do)。\r\nloadOnStartup：值越小优先级越高，控制 Servlet\r\n初始化顺序。\r\nasyncSupported：异步处理开关，需配合\r\nAsyncContext 使用（后文详解）。\r\n\r\n@WebFilter：声明过滤器\r\n替代 \r\n和，定义请求预处理和后处理逻辑。\r\n@WebFilter(    filterName = &quot;auditFilter&quot;,    urlPatterns = &quot;/*&quot;, // 过滤所有请求    servletNames = &#123;&quot;userServlet&quot;&#125;, // 针对特定 Servlet    dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.ASYNC&#125;)public class AuditFilter implements Filter &#123; ... &#125;\r\n\r\ndispatcherTypes：控制过滤器作用的请求类型（如\r\nFORWARD、ERROR）。\r\n执行顺序问题：注解无法直接指定顺序，需通过类名自然排序或结合\r\nweb.xml 的 ``。\r\n\r\n@WebListener：事件监听器\r\n简化监听器的声明，覆盖 Servlet 上下文、会话、请求等生命周期事件。\r\n@WebListenerpublic class AppContextListener implements ServletContextListener &#123;    @Override    public void contextInitialized(ServletContextEvent sce) &#123;        // 应用启动逻辑    &#125;&#125;\r\n异步处理\r\n在 @WebServlet 或 @WebFilter 中设置\r\nasyncSupported = true。\r\n流程：\r\n\r\n开启异步上下文：AsyncContext asyncContext = request.startAsync()。\r\n提交耗时任务到其他线程（如数据库查询、远程调用）。\r\n任务完成时，通过 asyncContext.complete()\r\n或返回响应。\r\n\r\n@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)public class AsyncServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;        AsyncContext ctx = req.startAsync();        CompletableFuture.runAsync(() -&gt; &#123;            // 模拟耗时操作            ctx.getResponse().getWriter().write(&quot;Async Response&quot;);            ctx.complete();        &#125;);    &#125;&#125;\r\n模块化部署介绍\r\nServlet 3.0 模块化特性：\r\n\r\n允许将 Web 组件（Servlet、Filter、Listener）打包为 JAR 文件，置于\r\nWEB-INF/lib 目录。\r\n容器自动扫描 JAR 中的 META-INF/web-fragment.xml\r\n和注解，实现“即插即用”\r\n\r\n注意情况\r\n如果使用@WebServlet Annotation（注解）来配置Servlet，需要注意：\r\n① 不要在 web.xml 文件的根元素（&lt;web-app—/&gt;）中指定\r\nmetadata-complete=“true”； ② 不要在 web.xml 文件中再次配置该 Servlet\r\n相关属性\r\nServletRequest 和 ServletResponse 为\r\nServlet\r\n提供了处理客户端请求和发送响应的能力；ServletConfig 为\r\nServlet 提供了配置信息；ServletContext 为\r\nServlet 提供了整个 Web\r\n应用程序的上下文环境。它们共同协作，使得 Servlet\r\n能够正常运行并处理客户端的请求。\r\nServletRequset接口\r\nServlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice(\r\n)方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\r\nServletRequest接口的部分内容：\r\npublic interface ServletRequest &#123;    int getContentLength();//返回请求主体的字节数    String getContentType();//返回主体的MIME类型    String getParameter(String var1);//返回请求参数的值&#125;\r\nServletResponse接口\r\njavax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service(\r\n)方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service(\r\n)方法。\r\nServletResponse隐藏了向浏览器发送响应的复杂过程。在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。\r\nServletResponse内部定义的方法：\r\npublic interface ServletResponse &#123;    String getCharacterEncoding(); \t// 在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型,加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。    String getContentType(); \t// 发送二进制数据的    ServletOutputStream getOutputStream() throws IOException; \t// PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。    PrintWriter getWriter() throws IOException;     void setCharacterEncoding(String var1);     void setContentLength(int var1);     void setContentType(String var1);     void setBufferSize(int var1);     int getBufferSize();     void flushBuffer() throws IOException;     void resetBuffer();     boolean isCommitted();     void reset();     void setLocale(Locale var1);     Locale getLocale();&#125;\r\nServletConfig接口\r\n当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init(\r\n)方式传入一个ServletConfig对象。\r\n其中几个方法如下：\r\n\r\n\r\nimg\r\n\r\nServletContext对象\r\nServletContext对象表示Servlet应用程序，是Servlet的上下文对象。每个Web应用程序都只有一个ServletContext对象。\r\n在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。\r\n通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。\r\n有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中\r\nServletContext中的下列方法负责处理属性：\r\nObject getAttribute(String var1);  // 获取 ServletContext 中指定名称的属性值 // 用于获取 ServletContext 中所有属性的名称。返回的是一个 Enumeration 对象，通过它可以遍历所有属性的名称。Enumeration&lt;String&gt; getAttributeNames(); void setAttribute(String var1, Object var2);    // 向 ServletContext 中设置一个属性 void removeAttribute(String var1);    // 从 ServletContext 中移除指定名称的属性\r\nServlet是否为线程安全\r\n线程安全问题指的是多线程在并发执行时会不会出现问题。由于Web容器只会创建一个Servlet实例，所以多个用户发起请求时，会有多个线程处理Servlet代码，因此Servlet是线程不安全的。\r\n考虑以下代码：\r\n@WebServlet(name = &quot;ThreadSafeServlet&quot;, urlPatterns = &quot;/ThreadSafeServlet&quot;)public class ThreadSafeServlet extends HttpServlet &#123;    private String name;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        name = request.getParameter(&quot;name&quot;);        try &#123;            Thread.sleep(10000);//使线程沉睡10秒        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        response.getWriter().println(&quot;name:&quot; + name);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doPost(request, response);    &#125;&#125;\r\n10秒内在两个不同的浏览器窗口中的表单输入name并提交，假如在A浏览器中输入111，B浏览器中输入222，最后会发现A和B浏览器显示的name都是222。这是因为在第一个线程睡眠时，第二个线程修改了name的值，所有最后显示都是222，那么就产生了线程不安全问题。\r\n实际上Servlet，Context上下文作用域，HttpSession都是线程不安全的，只有request请求和局部变量是线程安全的。\r\n关于Servlet与http相关的应用，下一部分是这个\r\nServlet与http\r\n关于Web基础部分\r\nJavaWeb-http\r\n引用文章\r\nJavaWeb——HTTP详解\r\nJavaWeb——Servlet\r\n菜鸟教程Servlet部分\r\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Servlet"]},{"title":"Spring Framework part2--IoC容器之IoC原理","url":"/posts/undefined.html","content":"Spring Framework\r\npart2–IoC容器之IoC原理\r\n在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。\r\n什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。\r\n例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。\r\n通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。\r\nSpring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。\r\nIoC容器，主要关于Spring容器如何对组件进行生命周期管理和配置组装服务。\r\nIoC原理\r\nSpring提供的容器又称为IoC容器，什么是IoC？\r\nIoC全称Inversion of\r\nControl，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。\r\n控制翻转IoC\r\nIoC是一种设计思想，能够指导我们能设计出松耦合，更优良的程序，提高程序的扩展力\r\nSpring 通过\r\nIoC容器来管理所有Java对象的实例化和初始化，控制对象和对象之间的依赖关系，我们将由IoC容器管理的Java对象称为\r\nSpring Bean，他与使用关键字 new 创建的 Java 对象没有任何区别\r\n容器中存放我们的Bean（java中的对象），创建到销毁过程都是容器进行管理的\r\n控制反转，反转的是什么\r\n\r\n把对象的创建权力交出去，交给第三方容器\r\n将对象和对象之间的关系的维护权交出去，交给第三方容器负责\r\n\r\n控制反转如何实现\r\n\r\nDI 依赖注入\r\n\r\n容器放bean对象，使用的是 map 集合\r\nIoC容器过程示例图\r\n\r\n依赖注入\r\nDI 依赖注入 实现了控制反转的思想\r\n依赖注入\r\n\r\nSpring创建对象的过程中，将对象依赖属性通过配置进行注入\r\n\r\n常见方式包括以下两种\r\n\r\n第一种，set注入\r\n第二种，构造注入\r\n\r\n所以，IoC就是一直控制反转的思想，而 DI 是对IoC的一种具体实现\r\nBean管理说的是：Bean对象的创建，以及Bean对象中属性的值（Bean对象之间关系的维护）\r\nIoC容器在Spring的实现\r\nIoC容器中管理的组件也叫Bean，创建Bean之前，首先要创建IoC容器，Spring提供了IoC容器的两组实现方式\r\n\r\nBeanFactory\r\n顶层接口，IoC容器的基本实现，是Spring内部使用的接口，面向Spring本身，不提供给开发人员使用\r\nApplicationContext\r\nBeanFactory的子接口，提供了更多的高级特性\r\n主要实现类如下\r\n\r\n\r\n\r\n1\r\n\r\n\r\n\r\n\r\nimage-20250419180928366\r\n\r\n\r\n传统\r\nJava 组件协作 与 IoC 控制反转 的对比会在下述例子中体现\r\n一个电商系统需要处理订单，订单服务（OrderService）依赖支付服务（PaymentService）完成支付逻辑。\r\n传统方式：硬编码依赖\r\n// 支付服务实现public class PaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment...&quot;);    &#125;&#125;// 订单服务直接创建依赖对象public class OrderService &#123;    private PaymentService paymentService = new PaymentService(); // 硬编码依赖    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方代码public class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        orderService.createOrder();    &#125;&#125;\r\n紧耦合：OrderService 直接实例化\r\nPaymentService，若需替换支付实现（如改用支付宝或微信支付），必须修改\r\nOrderService 的代码。\r\n上述每个组件都采用了一种简单的通过new创建实例并持有的方式，但是这种方式有着很大的缺点：\r\n\r\n随着更多的组件被引入，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。\r\n没有必要让不同的两个类分别创建相同功能的实例，完全可以共享同一个，但谁负责创建，谁负责获取其他组件已经创建的，不好处理\r\n实例化一个组件其实很难，因为各种依赖关系可能存在\r\n测试某个组件，例如OrderService，是复杂的，因为必须要在支付环境下执行。\r\n\r\n从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\r\n因此，核心问题是：\r\n\r\n谁负责创建组件？\r\n谁负责根据依赖关系组装组件？\r\n销毁时，如何按依赖顺序正确销毁？\r\n\r\n解决这一问题的核心方案就是IoC。\r\nIoC 方式：通过依赖注入解耦\r\n// 定义支付接口（面向接口编程）public interface PaymentService &#123;    void processPayment();&#125;// 支付宝实现public class AlipayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;// 微信支付实现public class WechatPayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Wechat Pay...&quot;);    &#125;&#125;// 订单服务通过构造函数注入依赖public class OrderService &#123;    private PaymentService paymentService;    // 依赖由外部传入（控制权反转）    public OrderService(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方通过容器（如 Spring）管理依赖public class Main &#123;    public static void main(String[] args) &#123;        // 由容器决定具体实现（如配置为 AlipayService）        PaymentService paymentService = new AlipayService();        OrderService orderService = new OrderService(paymentService);        orderService.createOrder();    &#125;&#125;\r\n\r\n解耦：OrderService 不再关心\r\nPaymentService 的具体实现，只需依赖接口。\r\n灵活性：更换支付方式时，只需修改外部配置（如 Spring\r\n的 Bean 定义），无需改动 OrderService 代码。\r\n可测试性：在单元测试中，可以注入\r\nMockPaymentService 模拟不同场景。\r\n\r\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。\r\n为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如\r\nOrderService 自己并不会创建\r\npaymentService，而是等待外部通过createOrder方法来注入一个OrderService\r\npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;        System.out.println(&quot;Order created!&quot;);    &#125;&#125;\r\n不直接用 new，而是注入一个\r\npaymentService，带来了一系列好处\r\n\r\n可维护性显著提升\r\n\r\n在传统方式中，若要更换支付服务的实现，比如从当前的简单支付服务切换到支付宝支付服务，就需要直接修改\r\nOrderService 类的代码。而在 IoC\r\n模式下，由于采用了注入机制，OrderService\r\n类本身不需要做任何修改。\r\n假设我们有一个新的 AlipayPaymentService 类\r\npublic class AlipayPaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;\r\n在调用方代码中，我们只需要注入新的支付服务实例即可\r\npublic class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        AlipayPaymentService alipayPaymentService = new AlipayPaymentService();        orderService.createOrder(alipayPaymentService);    &#125;&#125;\r\n这样，当业务需求发生变化时，我们可以轻松地替换支付服务的实现，而不会影响到\r\nOrderService\r\n类的内部逻辑，大大提高了代码的可维护性。\r\n\r\n可测试性大幅增强\r\n\r\n在传统方式下，测试 OrderService\r\n类时，由于它直接依赖于\r\nPaymentService，必须在真实的支付环境下进行测试，这不仅增加了测试的复杂性，还可能带来不必要的风险\r\n而在 IoC 模式下，我们可以使用模拟对象（Mock\r\nObject）来进行测试。例如，使用 JUnit 和 Mockito\r\n框架，我们可以创建一个模拟的 PaymentService\r\n对象，并将其注入到 OrderService 中进行测试：\r\nimport org.junit.jupiter.api.Test;import static org.mockito.Mockito.*;public class OrderServiceTest &#123;    @Test    public void testCreateOrder() &#123;        // 创建模拟的 PaymentService 对象        PaymentService mockPaymentService = mock(PaymentService.class);        OrderService orderService = new OrderService();        // 调用 createOrder 方法并注入模拟对象        orderService.createOrder(mockPaymentService);        // 验证 PaymentService 的 processPayment 方法是否被调用        verify(mockPaymentService, times(1)).processPayment();    &#125;&#125;\r\n\r\n依赖关系管理更加清晰\r\n\r\n在 IoC 模式下，所有组件的创建和依赖关系的组装都由 IoC\r\n容器负责，应用程序只需要使用已经创建好并配置好的组件。在 IoC\r\n模式下,通过配置文件或注解的方式将这些依赖关系清晰地表达出来，由 IoC\r\n容器根据这些配置信息来创建和组装组件。这样，开发人员只需要关注组件的功能实现，而不需要关心组件之间的依赖关系，降低了系统的复杂度。\r\n\r\n\r\n因此，IoC又称为依赖注入（DI：Dependency\r\nInjection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\r\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现\r\n&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。\r\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\r\n依赖注入方式\r\n我们从上面的代码可以看到，依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。\r\n很多Java类都具有带参数的构造方法，如果我们把 OrderService\r\n改造为通过构造方法注入，那么实现代码如下：\r\npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;&#125;\r\nSpring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。\r\n无侵入容器\r\n在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\r\n\r\n应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\r\n测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Boot中使用Hibernate框架","url":"/posts/9323.html","content":"在Spring\r\nBoot项目中使用Hibernate\r\nSpring Data JPA是Spring框架提供的简化JPA(Java Persistence\r\nAPI)操作的模块，而Hibernate是最流行的JPA实现之一\r\nHibernate是一个流行的ORM（对象关系映射）框架，它可以将Java对象映射到数据库表，从而方便地进行持久化操作。\r\n在Spring\r\nBoot项目中，集成Hibernate可以帮助我们更轻松地进行数据库操作。\r\n在Spring\r\nBoot项目中如何使用这两者，先写一个例子，我会在项目中，边写边用详细的注释来分析\r\n项目示例\r\n依赖导入\r\n&lt;dependencies&gt;    &lt;!-- Spring Boot Starter Data JPA (包含Hibernate) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;!-- 数据库驱动，这里以MySQL为例 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- 其他你可能需要的依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n进行配置文件的配置\r\n# 应用名称，建议与项目模块名一致spring.application.name=SpringAndHibernate # 数据库连接配置（HikariCP 连接池）spring.datasource.url=jdbc:mysql://localhost:3306/hibernate_demo?createDatabaseIfNotExist=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai# 说明：# - createDatabaseIfNotExist=true：开发环境自动创建数据库（生产环境需删除）# - serverTimezone=Asia/Shanghai：使用中国标准时区，避免时间转换问题spring.datasource.username=root # 数据库用户名（生产环境建议使用独立权限用户）spring.datasource.password=zjm10086 # 数据库密码（敏感信息，生产环境建议通过环境变量注入）spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # MySQL 8.0+ 驱动类spring.datasource.hikari.maximum-pool-size=10 # 最大连接数（开发环境默认 10，生产环境可调整为 20-50）spring.datasource.hikari.minimum-idle=5 # 最小空闲连接数（默认与 max 一致，可按需调整）spring.datasource.hikari.idle-timeout=30000 # 空闲连接超时时间（毫秒，默认 60000）# Hibernate 配置（JPA 标准）spring.jpa.hibernate.ddl-auto=update   # 开发环境自动更新表结构（生产环境用 validate）spring.jpa.show-sql=true    # 开发环境显示 SQL（生产环境关闭）spring.jpa.properties.hibernate.format_sql=true     # 格式化 SQL 输出，便于阅读spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect # MySQL 8.0+ 方言# 以下为可选配置（按需启用）：# spring.jpa.properties.hibernate.cache.use_second_level_cache=true # 二级缓存# spring.jpa.properties.hibernate.generate_statistics=true # 生成性能统计信息# 日志配置（Logback 级别控制）logging.level.org.hibernate.SQL=DEBUG    # 显示执行的 SQL 语句logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE   # 显示 SQL 参数绑定细节# 生产环境建议配置：# logging.level.org.hibernate.SQL=INFO# logging.level.org.hibernate.type.descriptor.sql.BasicBinder=INFO\r\n参数说明：\r\n\r\nspring.datasource.*：配置数据源的基本信息。\r\nspring.jpa.hibernate.ddl-auto：控制Hibernate的DDL操作（如update、create、none）。\r\nspring.jpa.show-sql：是否显示SQL语句。\r\nspring.jpa.properties.hibernate.*：Hibernate的高级配置。\r\n\r\n这里使用了MySQL数据库，可以根据实际情况进行修改。其中，spring.jpa.hibernate.ddl-auto属性指定了Hibernate如何自动生成数据库表，create-drop表示每次启动应用程序时都会创建表，并在关闭应用程序时删除表。\r\nddl-auto选项说明：\r\n\r\ncreate:\r\n每次启动都重新创建表结构，数据会丢失\r\ncreate-drop:\r\n加载hibernate时创建，退出时删除表结构\r\nupdate:\r\n加载hibernate自动更新数据库结构，保留数据\r\nvalidate:\r\n加载hibernate时，验证创建数据库表结构，会和数据库中的表进行比较，不会创建新表，但是会插入新值\r\nnone`: 不执行任何操作。 永远以数据表字段为准\r\n\r\n创建实体类\r\n使用JPA注解定义实体类，用于映射到数据库表：\r\npackage edu.software.ergoutree.springandhibernate.model;import jakarta.persistence.*;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * 学生实体类 - 映射数据库中的学生表 * 该类使用JPA注解定义了与数据库表的映射关系， * 并通过Lombok注解简化了JavaBean的常规代码。 * * @Entity 声明该类为JPA实体类 * @Table 指定对应数据库表名为&quot;students&quot; * @Data 自动生成getter/setter、toString、equals和hashCode方法 * @NoArgsConstructor 自动生成无参构造函数 * @AllArgsConstructor 自动生成包含所有字段的构造函数 */@Entity@Data@Table(name = &quot;students&quot;)@NoArgsConstructor@AllArgsConstructorpublic class Student &#123;    /**     * 学生唯一标识     * @Id 声明该字段为主键     * @GeneratedValue 指定主键生成策略为自增（对应数据库自增字段）     */    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    /**     * 学生姓名     * @Column 定义字段映射属性：     * - nullable = false: 不允许为空     * - length = 100: 最大长度100字符     */    @Column(name = &quot;name&quot;, nullable = false, length = 100)    private String name;    /**     * 学生邮箱     * @Column 定义字段映射属性：     * - unique = true: 要求邮箱地址唯一     */    @Column(name = &quot;email&quot;, unique = true)    private String email;    /**     * 学生年龄     * 使用包装类Integer允许值为null     */    @Column(name = &quot;age&quot;)    private Integer age;    /**     * 用于创建新学生的构造函数     * 不包含id字段，因为id由数据库自动生成     * @param name 学生姓名（必填）     * @param email 学生邮箱（必填且唯一）     * @param age 学生年龄（可选）     */    public Student(String name, String email, Integer age) &#123;        this.name = name;        this.email = email;        this.age = age;    &#125;&#125;\r\n其中@Entity表示这是一个JPA实体类，@Table(name =\r\n“students”)指定实体类对应数据库表名为students，@Id表示数据库的标识字段，也就是主键，@GeneratedValue注解指定了主键的生成策略，@Column指定对应数据库字段。\r\n创建DAO层\r\n创建一个简单的Repository，用于访问数据库：\r\nDAO层需要继承JpaRepository接口，这样才能根据方法名自动获得基本的CRUD操作，该接口有两个参数化类型，第一个表示实体类的类型，第二个表示主键的类型，也就是@Id注解标注的字段的类型，这里是Long。\r\n需要在启动类上面使用@EnableJpaRepositories注解\r\npackage edu.software.ergoutree.springandhibernate.repository;import edu.software.ergoutree.springandhibernate.model.Student;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 学生数据访问层 * 继承JpaRepository，自动获得基本的CRUD操作 */@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;    /**     * 方法名约定查询：根据名字模糊匹配学生     * 等效SQL：SELECT * FROM students WHERE name LIKE %?%     */    List&lt;Student&gt; findByNameContaining(String name);    /**     * 方法名约定查询：根据年龄范围查询学生     * 等效SQL：SELECT * FROM students WHERE age BETWEEN ? AND ?     */    List&lt;Student&gt; findByAgeBetween(Integer minAge, Integer maxAge);    /**     * JPQL查询：根据邮箱模式查询学生     * @Param 注解绑定命名参数到JPQL中的:email     */    @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)    List&lt;Student&gt; findStudentsByEmailPattern(@Param(&quot;email&quot;) String email);    /**     * 原生SQL查询：查询年龄大于指定值的学生，并按名字排序     * nativeQuery=true：启用原生SQL（直接操作数据库表）     */    @Query(value = &quot;SELECT * FROM students WHERE age &gt; :age ORDER BY name&quot;, nativeQuery = true)    List&lt;Student&gt; findStudentsOlderThanAge(@Param(&quot;age&quot;) Integer age);    /**     * 分页查询：根据名字模糊匹配学生，并支持分页和排序     * @param name 搜索关键词     * @param pageable 分页和排序参数     * @return 分页结果（包含总页数、总记录数等信息）     */    Page&lt;Student&gt; findByNameContaining(String name, Pageable pageable);    /**     * 自定义更新操作：修改学生年龄     * @Modifying 注解：标识该查询为修改操作     * @Transactional 需在调用层声明事务     */    @Modifying    @Query(&quot;UPDATE Student s SET s.age = :age WHERE s.id = :id&quot;)    int updateStudentAge(@Param(&quot;id&quot;) Long id, @Param(&quot;age&quot;) Integer age);&#125;\r\n在Repository上使用@Repository注解，表示这是一个Spring组件，并且用于访问数据库。PersonRepository继承自JpaRepository，这个接口提供了许多通用的数据库操作方法，如save、findById等。\r\n接口整体注解与继承\r\n@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;\r\n\r\n@Repository：\r\n\r\n声明该接口为 Spring 数据访问组件，自动注册为 Bean。\r\n作用：\r\n\r\n将数据访问层的异常（如 SQLException）转换为 Spring 的\r\nDataAccessException。\r\n支持组件扫描，无需在 XML 中手动配置 Bean。\r\n\r\n\r\nJpaRepository：\r\n\r\nSpring Data JPA 提供的核心接口，继承关系\r\nJpaRepository ← PagingAndSortingRepository ← CrudRepository\r\n内置方法\r\n// CrudRepository 提供的基础方法&lt;S extends T&gt; S save(S entity);Optional&lt;T&gt; findById(ID id);boolean existsById(ID id);Iterable&lt;T&gt; findAll();void deleteById(ID id);long count();// PagingAndSortingRepository 扩展的分页排序方法Page&lt;T&gt; findAll(Pageable pageable);Iterable&lt;T&gt; findAll(Sort sort);// JpaRepository 特有的方法void flush();&lt;S extends T&gt; S saveAndFlush(S entity);List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);\r\n\r\n\r\n方法名约定查询\r\n\r\n模糊查询（Containing）\r\n\r\nList&lt;Student&gt; findByNameContaining(String name);\r\n\r\n解析规则：\r\n\r\nfindBy：固定前缀，表示查询操作。\r\nNameContaining：字段名（Name） +\r\n匹配方式（Containing）。\r\n等效 SQL：WHERE name LIKE %?%。\r\n\r\n参数处理：\r\n\r\n传入 name=\"John\" 时，生成\r\nSQL：WHERE name LIKE '%John%'。\r\n\r\n其他常用匹配方式：\r\n\r\n\r\n\r\n关键字\r\nSQL 等效\r\n示例方法名\r\n\r\n\r\n\r\n\r\nContaining\r\nLIKE %?%\r\nfindByNameContaining\r\n\r\n\r\nStartingWith\r\nLIKE ?%\r\nfindByNameStartingWith\r\n\r\n\r\nEndingWith\r\nLIKE %?\r\nfindByNameEndingWith\r\n\r\n\r\nIsNotNull\r\nIS NOT NULL\r\nfindByNameIsNotNull\r\n\r\n\r\nGreaterThan\r\n&gt;\r\nfindByAgeGreaterThan\r\n\r\n\r\n\r\n\r\n\r\n范围查询（Between）\r\n\r\nList&lt;Student&gt; findByAgeBetween(Integer minAge, Integer maxAge);\r\n\r\n解析规则：\r\n\r\nfindBy：查询前缀。\r\nAgeBetween：字段名（Age） +\r\n范围操作（Between）。\r\n等效 SQL：WHERE age BETWEEN ? AND ?。\r\n\r\n参数顺序：\r\n\r\n第一个参数对应下限（minAge），第二个对应上限（maxAge）。\r\n\r\n\r\n\r\nJPQL 查询（@Query 注解）\r\n\r\n@Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)List&lt;Student&gt; findStudentsByEmailPattern(@Param(&quot;email&quot;) String email);\r\n\r\n@Query 注解：\r\n\r\n使用 JPA 查询语言（JPQL），语法类似\r\nSQL，但操作对象是实体类而非表。\r\n``` %:email%     - `:` 表示命名参数（对应 `@Param(&quot;email&quot;)`）。    - `%` 是 JPQL 的模糊匹配符（等效 SQL 的 `LIKE`）。- **命名参数绑定**：  - `@Param(&quot;email&quot;)`：将方法参数 `email` 绑定到 JPQL 中的 `:email`。- **替代方案：位置参数**：    ```java  @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %?1%&quot;)  List&lt;Student&gt; findStudentsByEmailPattern(String email);\r\n?1 表示第一个参数（从 1\r\n开始），但命名参数更易维护。\r\n\r\n\r\n\r\n原生 SQL\r\n查询（nativeQuery = true）\r\n\r\n@Query(value = &quot;SELECT * FROM students WHERE age &gt; :age ORDER BY name&quot;, nativeQuery = true)List&lt;Student&gt; findStudentsOlderThanAge(@Param(&quot;age&quot;) Integer age);\r\n\r\nnativeQuery = true：\r\n\r\n启用原生 SQL 查询，直接执行数据库 SQL 语句。\r\n表名 students\r\n和字段名需与数据库一致（而非实体类名和属性名）。\r\n\r\n适用场景：\r\n\r\nJPQL 无法表达复杂查询（如存储过程、函数调用）。\r\n需利用特定数据库特性（如 MySQL 的 GROUP_CONCAT）。\r\n\r\n风险提示：\r\n\r\n失去数据库无关性（如切换到 Oracle 可能需要修改 SQL）。\r\n字段名与实体属性映射需严格匹配（可通过\r\nSELECT s.id AS id, s.name AS name 显式映射）。\r\n\r\n\r\n\r\n分页与排序\r\n\r\n分页查询示例\r\n\r\n\r\n// 在接口中添加分页方法Page&lt;Student&gt; findByNameContaining(String name, Pageable pageable);// 调用示例Pageable pageable = PageRequest.of(0, 10, Sort.by(&quot;name&quot;).ascending());Page&lt;Student&gt; result = studentRepository.findByNameContaining(&quot;John&quot;, pageable);\r\n\r\nPageable 参数：\r\n\r\n``` PageRequest.of(page, size, sort)     - `page`：页码（从 0 开始）。    - `size`：每页数量。    - `sort`：排序规则（如 `Sort.by(&quot;name&quot;).ascending()`）。- **返回类型 `Page`**：  - 包含分页信息（总页数、总记录数、当前页数据）：    ```java    long totalElements = result.getTotalElements(); // 总记录数    int totalPages = result.getTotalPages();         // 总页数    List&lt;Student&gt; content = result.getContent();     // 当前页数据\r\n\r\n\r\n\r\n排序查询示例\r\n\r\n// 方法名中添加排序关键词List&lt;Student&gt; findByAgeGreaterThan(Integer age, Sort sort);// 调用示例Sort sort = Sort.by(&quot;name&quot;).descending().and(Sort.by(&quot;age&quot;).ascending());List&lt;Student&gt; result = studentRepository.findByAgeGreaterThan(18, sort);\r\n\r\nSort 参数\r\n\r\n支持多字段排序（如 name DESC, age ASC）。\r\n\r\n\r\n\r\n自定义方法实现\r\n\r\n若默认方法和查询注解无法满足需求，可通过以下方式扩展：\r\n\r\n自定义 Repository 实现\r\n\r\n// 1. 定义扩展接口interface StudentRepositoryCustom &#123;    List&lt;Student&gt; findStudentsByCustomCriteria(String criteria);&#125;// 2. 实现扩展接口class StudentRepositoryImpl implements StudentRepositoryCustom &#123;    @PersistenceContext    private EntityManager entityManager;        @Override    public List&lt;Student&gt; findStudentsByCustomCriteria(String criteria) &#123;        // 使用 EntityManager 实现自定义查询        String jpql = &quot;SELECT s FROM Student s WHERE ...&quot;;        return entityManager.createQuery(jpql, Student.class).getResultList();    &#125;&#125;// 3. 让主 Repository 继承扩展接口public interface StudentRepository extends JpaRepository&lt;Student, Long&gt;, StudentRepositoryCustom &#123;    // 现有方法保持不变&#125;\r\n\r\n使用 @Modifying 注解执行更新操作\r\n\r\n@Modifying@Query(&quot;UPDATE Student s SET s.age = :age WHERE s.id = :id&quot;)int updateStudentAge(@Param(&quot;id&quot;) Long id, @Param(&quot;age&quot;) Integer age);\r\n\r\n注意事项\r\n\r\n需配合 @Transactional 使用（在 Service 层声明）。\r\n返回值为受影响的行数。\r\n\r\n\r\nService层的编写\r\n先写接口\r\npackage edu.software.ergoutree.springandhibernate.service;import edu.software.ergoutree.springandhibernate.model.Student;import org.springframework.data.domain.Pageable;import java.util.List;import java.util.Optional;/** * 学生服务接口 * 定义学生相关的业务逻辑方法，通过 Spring Data JPA 间接使用 Hibernate 实现数据持久化 */public interface StudentService &#123;    /**     * 保存或更新学生（新增/修改）     * - 新增：学生 ID 为空时，Hibernate 生成 INSERT 语句     * - 更新：学生 ID 存在时，Hibernate 通过脏检查生成 UPDATE 语句     * @param student 学生实体（瞬时态或脱管态）     * @return 持久态学生对象（含数据库生成的 ID 或更新后的状态）     * @transactional 该方法需在事务内执行（由 Service 实现类注解控制）     */    Student saveStudent(Student student);    /**     * 根据 ID 查找学生（优先从一级缓存获取）     * @param id 学生 ID     * @return Optional 包装的持久态学生对象（若存在）     * @hibernate 操作：调用 StudentRepository.findById(id)，触发 Session.get() 查询     * @二级缓存扩展：可通过 @Cacheable 注解启用二级缓存     */    Optional&lt;Student&gt; findStudentById(Long id);    /**     * 查询所有学生（支持分页优化）     * @return 学生列表（持久态对象集合）     * @建议：实际开发中添加 Pageable 参数，避免全量加载：List&lt;Student&gt; findAllStudents(Pageable pageable)     * @hibernate 操作：生成 JPQL SELECT s FROM Student s，支持排序和分页     */    List&lt;Student&gt; findAllStudents();    /**     * 根据 ID 更新学生信息（需先查询原实体以确保处于持久态）     * @param student 包含更新字段的脱管态实体（需携带 ID）     * @return 更新后的持久态学生对象     * @hibernate 操作：     * 1. 通过 repository.findById(student.getId()) 将实体重新关联到 Session     * 2. 对比字段差异，生成 UPDATE 语句（仅更新变更字段）     */    Student updateStudent(Student student);    /**     * 根据 ID 删除学生（级联处理关联对象，如 @OneToMany(cascade = REMOVE)）     * @param id 学生 ID     * @throws EmptyResultDataAccessException 若 ID 不存在     * @hibernate 操作：调用 repository.deleteById(id)，生成 DELETE 语句     */    void deleteStudentById(Long id);    /**     * 根据名字模糊查询学生（方法名解析查询）     * @param name 姓名关键词（如 &quot;李&quot;）     * @return 匹配的持久态学生列表     * @hibernate 生成：JPQL SELECT s FROM Student s WHERE s.name LIKE %?%     */    List&lt;Student&gt; findStudentsByName(String name);    /**     * 根据年龄范围查询学生（方法名解析范围查询）     * @param minAge 最小年龄（包含）     * @param maxAge 最大年龄（包含）     * @return 符合条件的持久态学生列表     * @hibernate 生成：JPQL SELECT s FROM Student s WHERE s.age BETWEEN ? AND ?     */    List&lt;Student&gt; findStudentsByAgeRange(Integer minAge, Integer maxAge);    /**     * 根据邮箱模式查询学生（JPQL 自定义查询）     * @param email 邮箱关键词（支持 %，如 &quot;admin@&quot;）     * @return 匹配的持久态学生列表     * @hibernate 操作：执行 @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)     */    List&lt;Student&gt; findStudentsByEmailPattern(String email);    /**     * 根据年龄阈值查询学生（原生 SQL 示例）     * @param age 年龄阈值     * @return 符合条件的持久态学生列表     * @hibernate 操作：执行 @Query(value = &quot;SELECT * FROM students WHERE age &gt; :age&quot;, nativeQuery = true)     * @注意：表名 students 需与数据库一致（通过 @Table(name = &quot;students&quot;) 映射）     */    List&lt;Student&gt; findStudentsOlderThan(Integer age);&#125;\r\n再写实现类\r\npackage edu.software.ergoutree.springandhibernate.service.impl;import edu.software.ergoutree.springandhibernate.model.Student;import edu.software.ergoutree.springandhibernate.repository.StudentRepository;import edu.software.ergoutree.springandhibernate.service.StudentService;import jakarta.transaction.Transactional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;/** * 学生服务实现类 * 实现 StudentService 接口，基于 Spring Data JPA 和 Hibernate 完成数据操作 * Hibernate 核心： * 1. 通过 StudentRepository 间接调用 Hibernate 的 Session 方法 * 2. 事务管理由 Spring 整合 Hibernate 的 Transaction 机制实现 * 3. 实体对象状态自动管理（持久态、脱管态转换） */@Service // 标记为 Spring 服务组件，纳入依赖注入容器public class StudentServiceImpl implements StudentService &#123;    // 注入数据访问层接口（由 Spring 自动装配实现类）    private final StudentRepository studentRepository;    @Autowired // 构造函数注入，保证依赖不可变    public StudentServiceImpl(StudentRepository studentRepository) &#123;        this.studentRepository = studentRepository;    &#125;    /**     * 保存学生（新增或更新）     * - 新增：当 student.getId() 为 null 时，Hibernate 执行 INSERT     * - 更新：当 student.getId() 存在时，Hibernate 执行 UPDATE（基于脏检查）     * @param student 学生实体（瞬时态或脱管态）     * @return 持久态学生对象（数据库操作后状态）     * @Transactional 注解：     * - 开启事务，Hibernate 在事务提交时同步数据到数据库     * - 等效于 Hibernate 的 session.beginTransaction() 和 session.commit()     */    @Override    @Transactional // 声明式事务控制    public Student saveStudent(Student student) &#123;        return studentRepository.save(student); // 调用 JpaRepository.save()，触发 Hibernate 持久化    &#125;    /**     * 根据 ID 查询学生     * @param id 学生 ID     * @return Optional&lt;Student&gt; 包含持久态对象（若存在）     * @Hibernate 操作：     * 1. 调用 studentRepository.findById(id)     * 2. 内部通过 session.get(Student.class, id) 查询，使用一级缓存     */    @Override    public Optional&lt;Student&gt; findStudentById(Long id) &#123;        return studentRepository.findById(id); // 调用 JpaRepository.findById()    &#125;    /**     * 查询所有学生     * @return 持久态学生列表（由 Hibernate 维护对象状态）     * @Hibernate 生成 SQL：SELECT * FROM students（通过实体映射规则）     */    @Override    public List&lt;Student&gt; findAllStudents() &#123;        return studentRepository.findAll(); // 调用 JpaRepository.findAll()    &#125;    /**     * 更新学生信息（需验证学生存在）     * @param student 脱管态学生实体（必须包含 ID）     * @return 持久态学生对象（更新后状态）     * @Hibernate 步骤：     * 1. existsById() 检查实体是否存在（调用 session.contains()）     * 2. save() 执行 merge 操作，合并脱管态对象到持久化上下文     */    @Override    @Transactional    public Student updateStudent(Student student) &#123;        // 校验 ID 有效性（防止更新不存在的记录）        if (student.getId() != null &amp;&amp; studentRepository.existsById(student.getId())) &#123;            return studentRepository.save(student); // 执行更新操作        &#125;        throw new IllegalArgumentException(&quot;学生 ID 无效或记录不存在&quot;);    &#125;    /**     * 删除学生记录     * @param id 学生 ID     * @Hibernate 操作：     * 1. 调用 studentRepository.deleteById(id)     * 2. 生成 DELETE FROM students WHERE id = ? 语句     * @注意：若存在关联实体，需配置级联删除（如 @OneToMany(cascade = REMOVE)）     */    @Override    @Transactional    public void deleteStudentById(Long id) &#123;        studentRepository.deleteById(id); // 调用 JpaRepository.deleteById()    &#125;    /**     * 按姓名模糊查询（方法名解析查询）     * @param name 姓名关键词（如 &quot;王&quot;）     * @Hibernate 自动生成：SELECT s FROM Student s WHERE s.name LIKE %name%     */    @Override    public List&lt;Student&gt; findStudentsByName(String name) &#123;        return studentRepository.findByNameContaining(name); // 方法名映射为 LIKE 查询    &#125;    /**     * 按年龄范围查询（方法名解析范围查询）     * @param minAge 最小年龄（包含）     * @param maxAge 最大年龄（包含）     * @Hibernate 自动生成：SELECT s FROM Student s WHERE s.age BETWEEN minAge AND maxAge     */    @Override    public List&lt;Student&gt; findStudentsByAgeRange(Integer minAge, Integer maxAge) &#123;        return studentRepository.findByAgeBetween(minAge, maxAge); // BETWEEN 查询    &#125;    /**     * 按邮箱模式查询（JPQL 自定义查询）     * @param email 邮箱关键词（如 &quot;%@qq.com&quot;）     * @Hibernate 执行：@Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)     */    @Override    public List&lt;Student&gt; findStudentsByEmailPattern(String email) &#123;        return studentRepository.findStudentsByEmailPattern(email); // 调用自定义 JPQL 查询    &#125;    /**     * 按年龄阈值查询（原生 SQL 查询）     * @param age 年龄阈值     * @Hibernate 执行：@Query(value = &quot;SELECT * FROM students WHERE age &gt; :age&quot;, nativeQuery = true)     */    @Override    public List&lt;Student&gt; findStudentsOlderThan(Integer age) &#123;        return studentRepository.findStudentsOlderThanAge(age); // 调用原生 SQL 查询    &#125;&#125;\r\n依赖注入与构造函数\r\nprivate final StudentRepository studentRepository; // 注入数据访问层接口@Autowired // 自动装配 StudentRepository 的实现类（由 Spring 管理）public StudentServiceImpl(StudentRepository studentRepository) &#123;    this.studentRepository = studentRepository;&#125;\r\n\r\n与 Hibernate 的关联：\r\nStudentRepository 继承自\r\nJpaRepository，其底层实现由 Spring Data JPA 提供，内部通过\r\nHibernate 的 SessionFactory 创建 Session\r\n操作数据库。\r\n\r\n核心方法\r\n保存学生（新增 / 更新）\r\n\r\nHibernate 实现\r\nreturn studentRepository.save(student); // 调用 JpaRepository.save()\r\n会根据实体是否有 ID 判断操作类型：\r\n\r\n无 ID（瞬时态）：调用 Session.persist(student)，生成\r\nINSERT 语句。\r\n有 ID（脱管态）：调用 Session.merge(student)，生成\r\nUPDATE 语句（仅更新变更字段）。\r\n脏检查（Dirty Checking）：Hibernate\r\n自动对比实体属性与数据库记录，仅生成必要的 SQL。\r\n\r\n\r\n根据 ID 查询学生\r\n/** * 根据 ID 查询学生 * @param id 学生 ID * @return Optional&lt;Student&gt; 包含持久态对象（若存在） * * @Hibernate 操作： * 1. 调用 StudentRepository.findById(id) * 2. 内部通过 Session.get(Student.class, id) 查询，优先使用一级缓存 * @缓存机制： * - 一级缓存（Session 级）：同一事务内多次查询直接从缓存获取 * - 二级缓存（需配置 @Cacheable）：跨事务/请求缓存数据 */@Overridepublic Optional&lt;Student&gt; findStudentById(Long id) &#123;    return studentRepository.findById(id); // 调用 JpaRepository.findById()&#125;\r\n\r\nHibernate 实现\r\n\r\nfindById(id) 内部调用\r\nSession.get()，该方法会立即查询数据库（与\r\nSession.load() 的延迟加载不同）。\r\n若启用二级缓存（如 Ehcache），需在实体类添加\r\n@Cacheable(true)，并配置缓存提供者。\r\n\r\n\r\n查询所有学生\r\nreturn studentRepository.findAll(); // 调用 JpaRepository.findAll()\r\n\r\nHibernate 实现\r\n\r\nfindAll() 生成\r\nSELECT * FROM students（假设表名为\r\nstudents）。\r\n结果集中的对象自动转为持久态，纳入当前 Session\r\n管理。\r\n\r\n\r\n更新学生信息\r\nreturn studentRepository.save(student); // 执行更新\r\n\r\nHibernate 实现\r\n\r\nmerge(student)\r\n会创建新的持久态副本，原脱管态对象不会被修改。\r\n若实体已存在于当前\r\nSession（持久态），merge\r\n会将脱管态对象的属性复制到持久态对象，触发脏检查。\r\n\r\n\r\n删除学生\r\nstudentRepository.deleteById(id); // 调用 JpaRepository.deleteById()\r\n\r\nHibernate 实现\r\n\r\n直接执行 DELETE\r\n语句，若实体有关联对象且未配置级联删除，会抛出外键约束异常。\r\n实体类中通过 @OneToMany(cascade = CascadeType.ALL)\r\n自动处理关联删除。\r\n\r\n\r\n业务查询方法（以姓名模糊查询为例）\r\nreturn studentRepository.findByNameContaining(name); // 调用方法名解析查询\r\n\r\nHibernate 实现\r\n\r\n方法名中的 Containing 对应\r\nLIKE %name%，Hibernate 自动处理参数拼接，防止 SQL\r\n注入。\r\n生成的 JPQL 会通过 Session.createQuery()\r\n执行，结果集对象自动转为持久态。\r\n对 @OneToMany 关联，使用 FetchType.LAZY\r\n延迟加载，避免 SELECT N+1 问题\r\n@OneToMany(mappedBy = &quot;student&quot;, fetch = FetchType.LAZY)\r\n\r\n\r\n事务管理与 Hibernate 集成\r\n@Transactional // 类级别或方法级别声明事务\r\n\r\n作用范围\r\n\r\n类上声明 @Transactional，对所有 public 方法生效（可通过\r\n@Transactional(propagation = ...) 覆盖）。\r\n方法上声明 @Transactional，优先级高于类级别配置。\r\n\r\nHibernate 事务机制\r\n\r\n事务开始时，Hibernate 创建 Session\r\n并绑定到当前线程（ThreadLocal）。\r\n事务中所有 Repository 方法共享同一\r\nSession，确保数据一致性。\r\n事务提交时，Hibernate 执行\r\nSession.flush()，将缓存中的变更同步到数据库。\r\n事务回滚时，Session 清空，所有未提交变更被撤销。\r\n\r\n\r\nController层的编写\r\n创建REST控制器，用于处理HTTP请求：\r\npackage edu.software.ergoutree.springandhibernate.controller;import edu.software.ergoutree.springandhibernate.model.Student;import edu.software.ergoutree.springandhibernate.service.StudentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 学生控制器 * 提供 RESTful API 接口，处理 HTTP 请求与响应 * * - Spring MVC：处理路由、参数绑定、序列化 * - Hibernate：通过 Service 层间接实现数据持久化 * - REST 规范：使用 HTTP 方法和状态码表示资源操作 */@RestController // 声明为 REST 控制器，返回值自动序列化为 JSON@RequestMapping(&quot;/api/students&quot;) // 基础 URL 路径public class StudentController &#123;    private final StudentService studentService; // 注入服务层    @Autowired // 构造函数注入（推荐方式）    public StudentController(StudentService studentService) &#123;        this.studentService = studentService;    &#125;    /**     * 创建学生资源     * @param student 学生实体（JSON 请求体）     * @return 新创建的学生（含数据库生成的 ID）     * @HTTP 201 Created - 资源创建成功     * @Hibernate 操作：     * 1. Service 层调用 repository.save(student)     * 2. Hibernate 执行 INSERT 语句     * 3. 返回持久态对象（包含生成的 ID）     */    @PostMapping    public ResponseEntity&lt;Student&gt; createStudent(@RequestBody Student student) &#123;        Student savedStudent = studentService.saveStudent(student);        return new ResponseEntity&lt;&gt;(savedStudent, HttpStatus.CREATED);    &#125;    /**     * 获取所有学生列表     * @return 学生列表（JSON 数组）     * @HTTP 200 OK - 请求成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findAll()     * 2. Hibernate 生成 SQL：SELECT * FROM students     * @注意：未分页，可能导致大数据量性能问题     */    @GetMapping    public ResponseEntity&lt;List&lt;Student&gt;&gt; getAllStudents() &#123;        List&lt;Student&gt; students = studentService.findAllStudents();        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 根据 ID 获取单个学生     * @param id 学生 ID     * @return 学生对象（JSON）或 404 Not Found     * @HTTP 200 OK - 资源存在 | 404 Not Found - 资源不存在     * @Hibernate 操作：     * 1. Service 层调用 repository.findById(id)     * 2. Hibernate 通过一级缓存或数据库查询实体     */    @GetMapping(&quot;/&#123;id&#125;&quot;) // 修正：原代码缺少路径变量    public ResponseEntity&lt;Student&gt; getStudentById(@PathVariable Long id) &#123;        return studentService.findStudentById(id)                .map(student -&gt; new ResponseEntity&lt;&gt;(student, HttpStatus.OK))                .orElse(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));    &#125;    /**     * 更新学生信息     * @param id 学生 ID（路径参数）     * @param student 学生实体（JSON 请求体，需包含 ID）     * @return 更新后的学生或 404 Not Found     * @HTTP 200 OK - 更新成功 | 404 Not Found - 学生不存在     * @Hibernate 操作：     * 1. Service 层验证学生存在性     * 2. 调用 repository.save(student) 触发 Hibernate 的 merge()     * 3. 基于脏检查生成 UPDATE 语句     */    @PutMapping(&quot;/&#123;id&#125;&quot;) // 修正：原代码路径格式错误（//&#123;id&#125;）    public ResponseEntity&lt;Student&gt; updateStudent(@PathVariable(&quot;id&quot;) Long id, @RequestBody Student student) &#123;        try &#123;            student.setId(id); // 确保路径 ID 与请求体 ID 一致            Student updatedStudent = studentService.updateStudent(student);            return new ResponseEntity&lt;&gt;(updatedStudent, HttpStatus.OK);        &#125; catch (IllegalArgumentException e) &#123;            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;    &#125;    /**     * 删除学生资源     * @param id 学生 ID     * @return 204 No Content - 删除成功（无返回体）     * @HTTP 204 No Content - 删除成功 | 500 Internal Server Error - 删除失败     * @Hibernate 操作：     * 1. Service 层调用 repository.deleteById(id)     * 2. Hibernate 执行 DELETE 语句     * @注意：若 ID 不存在，Hibernate 抛出 EmptyResultDataAccessException（Spring 自动处理为 500）     */    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Void&gt; deleteStudent(@PathVariable(&quot;id&quot;) Long id) &#123;        studentService.deleteStudentById(id);        return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);    &#125;    /**     * 根据姓名模糊查询学生     * @param name 姓名关键词（如 &quot;张&quot;）     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findByNameContaining(name)     * 2. Hibernate 生成 JPQL：SELECT s FROM Student s WHERE s.name LIKE %:name%     */    @GetMapping(&quot;/search/name&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByName(@RequestParam String name) &#123;        List&lt;Student&gt; students = studentService.findStudentsByName(name);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 根据年龄范围查询学生     * @param minage 最小年龄（包含）     * @param maxage 最大年龄（包含）     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findByAgeBetween(minage, maxage)     * 2. Hibernate 生成 JPQL：SELECT s FROM Student s WHERE s.age BETWEEN :minage AND :maxage     */    @GetMapping(&quot;/search/age&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByAge(@RequestParam Integer minage, @RequestParam Integer maxage) &#123;        List&lt;Student&gt; students = studentService.findStudentsByAgeRange(minage, maxage);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 根据邮箱模式查询学生     * @param pattern 邮箱关键词（如 &quot;%@gmail.com&quot;）     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findStudentsByEmailPattern(pattern)     * 2. Hibernate 执行自定义 JPQL：SELECT s FROM Student s WHERE s.email LIKE %:email%     */    @GetMapping(&quot;/search/email&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByEmailPattern(@RequestParam String pattern) &#123;        List&lt;Student&gt; students = studentService.findStudentsByEmailPattern(pattern);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 查询年龄大于指定值的学生     * @param age 年龄阈值     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findStudentsOlderThanAge(age)     * 2. Hibernate 执行原生 SQL：SELECT * FROM students WHERE age &gt; :age     */    @GetMapping(&quot;/search/older-than&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsOlderThan(@RequestParam Integer age) &#123;        List&lt;Student&gt; students = studentService.findStudentsOlderThan(age);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;&#125;\r\n在控制器上使用@RestController注解，表示这是一个Spring组件，并且用于处理HTTP请求。\r\n控制器整体架构与 REST\r\n设计\r\n/** * 学生控制器 * 提供 RESTful API 接口，处理 HTTP 请求与响应 * 架构层次： * 1. 接收客户端请求（HTTP 协议） * 2. 调用 Service 层处理业务逻辑 * 3. 返回标准化 JSON 响应（含 HTTP 状态码） * Hibernate 集成点： * - 通过 Service 层间接使用 Hibernate 持久化能力 * - 处理 Hibernate 可能抛出的异常（如 EntityNotFoundException） */@RestController // 声明为 REST 控制器，自动将返回值序列化为 JSON@RequestMapping(&quot;/api/students&quot;) // 基础路径public class StudentController &#123;\r\n\r\nREST 规范：\r\n\r\n使用 HTTP\r\n方法映射操作：POST（创建）、GET（查询）、PUT（更新）、DELETE（删除）。\r\n路径设计遵循资源导向：/api/students/&#123;id&#125;\r\n表示学生资源。\r\n返回标准 HTTP 状态码（如\r\n201 Created、404 Not Found）\r\n\r\n\r\n依赖注入与服务层调用\r\nprivate final StudentService studentService;@Autowiredpublic StudentController(StudentService studentService) &#123;    this.studentService = studentService;&#125;\r\n\r\nHibernate 操作 ： StudentService\r\n内部通过 StudentRepository 调用 Hibernate 的\r\nSession 方法，实现数据库操作。\r\n设计模式：\r\n依赖注入（DI）遵循单一职责原则，控制器专注于请求处理，业务逻辑委托给\r\nService 层。\r\n\r\n核心方法注释与 Hibernate\r\n集成**\r\n创建学生（POST）\r\n/** * 创建学生资源 * @param student 学生实体（JSON 格式请求体） * @return 新创建的学生（含数据库生成的 ID） * @HTTP 201 Created - 资源创建成功 * @Hibernate 操作： * 1. Service 层调用 repository.save(student) * 2. Hibernate 执行 INSERT 语句，生成自增 ID * 3. 返回持久态对象（包含数据库生成的 ID） */@PostMappingpublic ResponseEntity&lt;Student&gt; createStudent(@RequestBody Student student) &#123;    Student savedStudent = studentService.saveStudent(student);    return new ResponseEntity&lt;&gt;(savedStudent, HttpStatus.CREATED);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n实体对象通过 @RequestBody 从 JSON\r\n反序列化，初始为瞬时态（Transient）。\r\nrepository.save(student)\r\n将其转换为持久态（Persistent），触发 Hibernate 的\r\nINSERT 操作。\r\n返回的 savedStudent 包含数据库生成的\r\nID（如自增主键）。\r\n\r\n\r\n查询所有学生（GET）\r\n/** * 获取所有学生列表 * @return 学生列表（JSON 数组） * @HTTP 200 OK - 请求成功 * @Hibernate 操作： * 1. Service 层调用 repository.findAll() * 2. Hibernate 生成 SQL：SELECT * FROM students * 3. 结果集映射为持久态对象列表 * @注意： * - 未分页，可能导致内存溢出（生产环境建议添加分页） */@GetMappingpublic ResponseEntity&lt;List&lt;Student&gt;&gt; getAllStudents() &#123;    List&lt;Student&gt; students = studentService.findAllStudents();    return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n返回的 students\r\n列表中每个对象均为持久态，处于 Hibernate 的\r\nSession 管理下。\r\n若实体存在懒加载关联（如 @OneToMany(fetch = LAZY)），在\r\nSession 关闭后访问会触发\r\nLazyInitializationException。\r\n\r\n\r\n更新学生（PUT）\r\n/** * 更新学生信息 * @param id 学生 ID（路径参数） * @param student 学生实体（JSON 请求体，需包含 ID） * @return 更新后的学生或 404 Not Found * @HTTP 200 OK - 更新成功 | 404 Not Found - 学生不存在 * @Hibernate 操作： * 1. Service 层验证学生存在性 * 2. 调用 repository.save(student) 触发 Hibernate 的 merge() * 3. Hibernate 执行 UPDATE 语句（基于脏检查） */@PutMapping(&quot;/&#123;id&#125;&quot;) // 修正：原代码路径格式错误（//&#123;id&#125;）public ResponseEntity&lt;Student&gt; updateStudent(@PathVariable(&quot;id&quot;) Long id, @RequestBody Student student) &#123;    try &#123;        student.setId(id); // 确保 ID 一致        Student updatedStudent = studentService.updateStudent(student);        return new ResponseEntity&lt;&gt;(updatedStudent, HttpStatus.OK);    &#125; catch (IllegalArgumentException e) &#123;        return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);    &#125;&#125;\r\n\r\nHibernate 集成体现：\r\n\r\n传入的 student\r\n是脱管态（Detached）对象（已存在但不在当前\r\nSession 中）。\r\nrepository.save(student) 调用 Hibernate 的\r\nSession.merge()，将脱管态对象合并到当前\r\nSession，生成 UPDATE 语句。\r\n脏检查机制：Hibernate 仅更新实际变更的字段（通过\r\n@DynamicUpdate 可进一步优化）。\r\n\r\n\r\n删除学生（Delete）\r\n/** * 删除学生资源 * @param id 学生 ID * @return 204 No Content - 删除成功（无返回体） * @HTTP 204 No Content - 删除成功 | 500 Internal Server Error - 删除失败 * @Hibernate 操作： * 1. Service 层调用 repository.deleteById(id) * 2. Hibernate 执行 DELETE FROM students WHERE id = ? * @注意： * - 若 ID 不存在，Hibernate 抛出 EmptyResultDataAccessException（Spring 自动处理为 500） * - 建议在 Service 层添加 existsById() 校验，返回 404 */@DeleteMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;Void&gt; deleteStudent(@PathVariable(&quot;id&quot;) Long id) &#123;    studentService.deleteStudentById(id);    return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n直接执行 DELETE 语句，无需先查询实体。\r\n若存在关联实体（如 Student 关联\r\nCourse），需确保配置了级联删除（如\r\n@OneToMany(cascade = CascadeType.REMOVE)），否则会触发外键约束异常。\r\n\r\n\r\n业务查询方法（以姓名模糊查询为例）\r\n/** * 根据姓名模糊查询学生 * @param name 姓名关键词（如 &quot;张&quot;） * @return 匹配的学生列表 * @HTTP 200 OK - 查询成功 * @Hibernate 操作： * 1. Service 层调用 repository.findByNameContaining(name) * 2. Hibernate 解析方法名生成 JPQL：SELECT s FROM Student s WHERE s.name LIKE %:name% */@GetMapping(&quot;/search/name&quot;)public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByName(@RequestParam String name) &#123;    List&lt;Student&gt; students = studentService.findStudentsByName(name);    return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);&#125;\r\n\r\nHibernate 集成体现：\r\n\r\n方法名中的 Containing 自动映射为\r\nLIKE %name% 查询，由 Hibernate 动态生成 SQL。\r\n返回的 students\r\n列表为持久态，若包含懒加载关联，需确保在事务内访问。\r\n\r\n\r\n异常处理\r\n显式异常处理（如更新不存在的学生）\r\ntry &#123;    student.setId(id);    Student updatedStudent = studentService.updateStudent(student);    return new ResponseEntity&lt;&gt;(updatedStudent, HttpStatus.OK);&#125; catch (IllegalArgumentException e) &#123;    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n当 studentService.updateStudent()\r\n发现学生不存在时，抛出\r\nIllegalArgumentException，控制器捕获后返回\r\n404 Not Found。\r\n避免将 Hibernate 底层异常（如\r\nEntityNotFoundException）直接暴露给客户端。\r\n\r\n\r\nSpring 自动异常处理\r\n\r\n默认行为\r\n\r\n若删除不存在的学生，Hibernate 抛出\r\nEmptyResultDataAccessException，Spring 自动返回\r\n500 Internal Server Error。\r\n\r\n优化： 在 Service\r\n层添加存在性检查，并抛出业务异常（如\r\nStudentNotFoundException），由全局异常处理器统一返回\r\n404：\r\n\r\n@ExceptionHandler(StudentNotFoundException.class)public ResponseEntity&lt;Void&gt; handleNotFoundException() &#123;    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#125;\r\n启动应用\r\n启动Spring Boot应用后，Spring Data\r\nJPA会自动配置Hibernate，并根据实体类的定义生成表结构（取决于spring.jpa.hibernate.ddl-auto的值）。\r\npackage edu.software.ergoutree.springandhibernate;import edu.software.ergoutree.springandhibernate.entity.Student;import edu.software.ergoutree.springandhibernate.repository.StudentRepository;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;/** * Spring Boot 应用程序入口类 *  * @SpringBootApplication 注解是一个组合注解，它包含了： * - @Configuration: 标记该类为配置类 * - @EnableAutoConfiguration: 启用Spring Boot的自动配置机制 * - @ComponentScan: 启用组件扫描，自动发现和注册Bean */@SpringBootApplicationpublic class SpringAndHibernateApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringAndHibernateApplication.class, args);    &#125;        /**     * 应用启动后初始化一些测试数据     * CommandLineRunner 是Spring Boot提供的一个接口，用于在应用启动后执行一些初始化操作     */    @Bean    public CommandLineRunner initData(StudentRepository studentRepository) &#123;        return args -&gt; &#123;            // 检查数据库中是否已有数据            if (studentRepository.count() == 0) &#123;                System.out.println(&quot;初始化学生数据...&quot;);                                // 创建并保存几个学生实体                studentRepository.save(new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20));                studentRepository.save(new Student(&quot;李四&quot;, &quot;lisi@example.com&quot;, 22));                studentRepository.save(new Student(&quot;王五&quot;, &quot;wangwu@example.com&quot;, 21));                studentRepository.save(new Student(&quot;赵六&quot;, &quot;zhaoliu@example.com&quot;, 23));                                System.out.println(&quot;数据初始化完成！&quot;);            &#125; else &#123;                System.out.println(&quot;数据库中已有数据，跳过初始化步骤。&quot;);            &#125;                        // 显示所有学生信息            System.out.println(&quot;学生列表：&quot;);            studentRepository.findAll().forEach(student -&gt;                 System.out.println(student.getId() + &quot;: &quot; + student.getName() + &quot;, &quot; +                                    student.getEmail() + &quot;, &quot; + student.getAge() + &quot;岁&quot;));        &#125;;    &#125;&#125;\r\n总结这个项目的集成\r\nHibernate 的要点\r\nSpring Boot 通过 Spring Data JPA 自动集成了\r\nHibernate，这种集成方式非常优雅且简化了大量配置工作。\r\n依赖关系\r\n在pom.xml中，我们添加了以下关键依赖：\r\n\r\n```xml spring-boot-starter-data-jpa   这个启动器包含了 Spring Data JPA 和 Hibernate 核心依赖- ```xml  mysql-connector-j\r\nMySQL 数据库驱动\r\n```xml spring-boot-starter-web   Web 应用支持**自动配置机制**Spring Boot 的核心优势在于其自动配置机制。通过 `@SpringBootApplication`注解，它会：- 自动配置 Hibernate 的 `SessionFactory`- 自动配置事务管理器- 自动配置数据源- 自动扫描实体类并映射到数据库表**配置文件**在 `application.properties`中，我们配置了：```propertiespropertiesCopyInsert# 数据库连接配置spring.datasource.url=jdbc:mysql://localhost:3306/hibernate_demo?createDatabaseIfNotExist=true&amp;useSSL=false&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root# Hibernate配置spring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.jpa.properties.hibernate.format_sql=truespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\r\n\r\n这些配置告诉 Spring Boot：\r\n\r\n使用 MySQL 数据库\r\n自动创建/更新表结构 ddl-auto=update\r\n显示 SQL 语句以便调试\r\n使用 MySQL 方言\r\n\r\n实体类映射\r\n我们使用 JPA 注解来定义实体类与数据库表的映射关系：\r\njavaCopyInsert@Entity@Table(name = &quot;students&quot;)public class Student &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;name&quot;, nullable = false, length = 100)    private String name;        // 其他字段...&#125;\r\n这些注解是 JPA 规范的一部分，Hibernate 作为 JPA\r\n的实现，会解析这些注解并将实体类映射到数据库表。\r\nRepository 层\r\nSpring Data JPA 提供了强大的 Repository\r\n接口，大大简化了数据访问层的开发：\r\njavaCopyInsert@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;    // 方法名约定查询    List&lt;Student&gt; findByNameContaining(String name);        // JPQL 查询    @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)    List&lt;Student&gt; findStudentsByEmailPattern(@Param(&quot;email&quot;) String email);        // 原生 SQL 查询    @Query(value = &quot;SELECT * FROM students WHERE age &gt; :age&quot;, nativeQuery = true)    List&lt;Student&gt; findStudentsOlderThanAge(@Param(&quot;age&quot;) Integer age);&#125;\r\n这里展示了三种查询方式：\r\n\r\n方法名约定查询：通过方法名自动生成查询语句\r\nJPQL 查询：使用面向对象的查询语言\r\n原生 SQL 查询：直接使用 SQL 语句\r\n\r\n事务管理\r\nSpring Boot 自动配置了事务管理器，我们只需使用\r\n@Transactional注解即可：\r\njavaCopyInsert@Servicepublic class StudentServiceImpl implements StudentService &#123;    @Override    @Transactional    public Student saveStudent(Student student) &#123;        return studentRepository.save(student);    &#125;        // 其他方法...&#125;\r\n数据初始化\r\n在启动类中，我们使用\r\nCommandLineRunner来初始化测试数据：\r\njavaCopyInsert@Beanpublic CommandLineRunner initData(StudentRepository studentRepository) &#123;    return args -&gt; &#123;        if (studentRepository.count() == 0) &#123;            // 创建并保存几个学生实体            studentRepository.save(new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20));            // 更多学生...        &#125;    &#125;;&#125;\r\nSpring Boot 与 Hibernate 的集成主要通过 Spring Data JPA\r\n实现，具有以下优势：\r\n\r\n简化配置：无需编写大量 XML 配置文件\r\n约定优于配置：遵循默认约定，减少配置量\r\n自动化：自动创建表结构、自动生成查询语句\r\n类型安全：编译时类型检查，减少运行时错误\r\n声明式事务：使用注解简化事务管理\r\n多种查询方式：支持方法名约定、JPQL 和原生 SQL\r\n\r\n这种集成方式大大提高了开发效率，让开发者可以专注于业务逻辑而非底层数据访问细节。\r\n要运行此应用程序，只需确保 MySQL 服务已启动，然后运行 Spring Boot\r\n应用程序即可。应用启动后，将自动创建数据库表并初始化测试数据。\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识","Spring Data JPA","JavaEE","Spring系列","Spring Boot","Java框架"]},{"title":"Spring Boot part7-HTTP缓存机制","url":"/posts/34701.html","content":"Spring Boot 的缓存机制\r\n随着应用用户量的不断增长和数据规模的持续扩大，数据库查询操作往往成为影响用户体验的关键瓶颈。缓存作为一种高效的解决方案，能够显著提升系统性能。Spring\r\nBoot\r\n提供了强大的缓存支持，通过基于注解的低侵入式方式，帮助开发者轻松地为应用添加缓存功能。\r\nSpring Boot 中的缓存机制原理\r\n缓存抽象层\r\nSpring Boot 的缓存机制基于 Spring\r\n框架的缓存抽象，它提供了一套统一的接口和注解，使得开发者可以在不关心具体缓存实现的情况下使用缓存功能。这种抽象层的设计，让开发者能够灵活地切换不同的缓存技术，如\r\nRedis、Ehcache 等。\r\nSpring\r\n从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；同时支持JCache（JSR-107）注解。\r\n工作原理\r\nSpring 缓存机制基于\r\nAOP（面向切面编程）实现，通过动态代理在方法执行前后添加缓存逻辑：\r\n\r\n方法调用前：检查缓存中是否存在对应的数据\r\n缓存命中：直接返回缓存数据，跳过方法执行\r\n缓存未命中：执行目标方法，将结果存储到缓存中\r\n方法调用后：根据配置更新或清除缓存\r\n\r\nSpring Boot 中的缓存支持\r\nSpring Boot\r\n提供了开箱即用的缓存抽象层，使得开发者能够轻松地集成各种缓存解决方案。Spring\r\nCache\r\n抽象主要基于注解配置，提供了统一的编程模型来操作不同类型的缓存后端。\r\n要启用 Spring Boot 的缓存支持，只需在主配置类或\r\napplication.properties 文件中添加以下配置：\r\n// 在主类上添加 @EnableCaching 注解@SpringBootApplication@EnableCachingpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\r\n或者在 application.properties 中设置：\r\nspring.cache.type=simple   # 简单内存缓存，可以用 Redis、Ehcache 等\r\nHTTP缓存\r\nHTTP\r\n缓存是浏览器缓存体系的重要组成部分，浏览器缓存也包含很多内容：HTTP缓存、indexDB、缓存、本地存储等等，主要通过两种核心机制实现资源缓存控制：\r\n浏览器主要分为Last-Modified/Etag和Cache-Control/Expires\r\n\r\n协商缓存（Conditional\r\nCache）：通过Last-Modified/Etag实现，需与服务器确认资源是否更新\r\n强缓存（Strict\r\nCache）：通过Cache-Control/Expires实现，直接根据本地缓存时间判断是否可用\r\n\r\n协商缓存机制：Last-Modified\r\n与 Etag\r\nLast-Modified\r\n工作原理\r\n基本概念：服务器响应请求时，在响应头中添加Last-Modified字段，标识资源最后修改时间。\r\n交互流程：\r\n\r\n首次请求：服务器返回资源及Last-Modified: Fri, 28 May 2025 12:00:00 GMT\r\n后续请求：浏览器自动在请求头中添加If-Modified-Since字段（值为上次的\r\nLast-Modified）\r\n服务器对比时间：\r\n\r\n若资源未修改：返回304 Not Modified，浏览器使用本地缓存\r\n若资源已修改：返回200 OK及最新资源\r\n\r\n\r\nEtag 工作原理\r\n基本概念：服务器为资源生成唯一标识（类似哈希值），存储在Etag响应头中。\r\n交互流程：\r\n\r\n首次请求：服务器返回Etag: \"abc123def456\"\r\n后续请求：浏览器在请求头中添加If-None-Match: \"abc123def456\"\r\n服务器验证：\r\n\r\n若 Etag 匹配：返回304 Not Modified\r\n若 Etag 不匹配：返回200 OK及新资源\r\n\r\n\r\n优先级：Etag &gt; Last-Modified（服务器同时存在时优先验证\r\nEtag）\r\n强缓存机制：Cache-Control 与\r\nExpires\r\nCache-Control 核心字段\r\n基本概念：通过响应头Cache-Control设置缓存策略，优先级高于Expires，支持更灵活的参数。\r\n常用参数：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数名\r\n说明\r\n示例\r\n\r\n\r\n\r\n\r\nmax-age=秒数\r\n资源在本地缓存的最大时间（秒），超过后失效\r\nCache-Control: max-age=3600\r\n\r\n\r\ns-maxage=秒数\r\n共享缓存（如 CDN）的最大缓存时间，优先级高于 max-age\r\nCache-Control: s-maxage=86400\r\n\r\n\r\npublic\r\n资源可被客户端和代理服务器缓存\r\nCache-Control: public\r\n\r\n\r\nprivate\r\n资源仅可被客户端缓存（默认值）\r\nCache-Control: private\r\n\r\n\r\nno-cache\r\n强制每次请求都向服务器验证资源（并非不缓存，而是需先验证）\r\nCache-Control: no-cache\r\n\r\n\r\nno-store\r\n禁止任何形式的缓存（最严格策略）\r\nCache-Control: no-store\r\n\r\n\r\nmust-revalidate\r\n缓存过期后必须向服务器验证，不能直接使用本地缓存\r\nCache-Control: must-revalidate\r\n\r\n\r\n\r\nExpires 工作原理\r\n基本概念：服务器返回资源时，在响应头中添加Expires字段，标识资源过期的绝对时间。\r\n交互流程：\r\n\r\n首次请求：服务器返回Expires: Fri, 29 May 2025 12:00:00 GMT\r\n浏览器对比本地时间：\r\n\r\n未超过时间：直接使用缓存，无需请求服务器\r\n超过时间：发送请求获取新资源\r\n\r\n\r\n核心组件\r\nCache 接口\r\nCache 接口是 Spring\r\n缓存抽象的核心，定义了缓存的基本操作：\r\npublic interface Cache &#123;    String getName();    Object getNativeCache();    ValueWrapper get(Object key);    &lt;T&gt; T get(Object key, Class&lt;T&gt; type);    &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader);    void put(Object key, @Nullable Object value);    void evict(Object key);    void clear();&#125;\r\nCacheManager 接口\r\nCacheManager 负责管理多个 Cache 实例：\r\npublic interface CacheManager &#123;    @Nullable    Cache getCache(String name);    Collection&lt;String&gt; getCacheNames();&#125;\r\nCache 注解详解\r\n@EnableCaching\r\n启用 Spring Boot 缓存功能的核心注解，需要在配置类上添加：\r\n@SpringBootApplication@EnableCachingpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\r\n@Cacheable\r\n用于声明一个方法的返回值可以被缓存，是最常用的缓存注解：\r\n@Servicepublic class UserService &#123;        @Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)    public User getUserById(Long id) &#123;        // 模拟数据库查询        return userRepository.findById(id);    &#125;        @Cacheable(value = &quot;users&quot;, key = &quot;#name&quot;, condition = &quot;#name.length() &gt; 2&quot;)    public User getUserByName(String name) &#123;        return userRepository.findByName(name);    &#125;&#125;\r\n主要属性：\r\n\r\nvalue/cacheNames：缓存名称，可以指定多个\r\nkey：缓存的键，支持 SpEL 表达式\r\ncondition：缓存条件，满足条件才缓存\r\nunless：排除条件，满足条件不缓存\r\nkeyGenerator：自定义键生成器\r\ncacheManager：指定缓存管理器\r\nsync：是否同步执行\r\n\r\n@CachePut\r\n无论方法是否被调用过，都会执行方法体，并将结果存入缓存：\r\n@CachePut(value = &quot;users&quot;, key = &quot;#user.id&quot;)public User updateUser(User user) &#123;    return userRepository.save(user);&#125;@CachePut(value = &quot;users&quot;, key = &quot;#result.id&quot;, condition = &quot;#result != null&quot;)public User createUser(User user) &#123;    return userRepository.save(user);&#125;\r\n\r\nupdateUser 方法\r\n\r\n当更新用户时，根据传入的 user.id\r\n找到缓存中的对应条目，并用新的 user 对象替换。\r\n适用于已知数据 ID 的更新场景。\r\n\r\ncreateUser 方法\r\n\r\n当创建用户后，根据返回的\r\nresult.id（通常是数据库生成的主键）作为键，将新用户存入缓存。\r\ncondition\r\n确保只有创建成功（返回非空）时才更新缓存。\r\n\r\n\r\n注解属性说明\r\n\r\nvalue：标识缓存的存储位置，缓存名称需在配置中提前定义，通过\r\n@CacheConfig 或 XML 配置\r\nkey：缓存的键，唯一标识缓存数据，支持 SpEL 表达式\r\ncondition：缓存条件，满足条件才缓存\r\n\r\n@CacheEvict\r\n用于清除缓存数据：\r\n// 清除指定键的缓存@CacheEvict(value = &quot;users&quot;, key = &quot;#id&quot;)public void deleteUser(Long id) &#123;    userRepository.deleteById(id);&#125;// 清除所有缓存@CacheEvict(value = &quot;users&quot;, allEntries = true)public void deleteAllUsers() &#123;    userRepository.deleteAll();&#125;// 方法执行前清除缓存@CacheEvict(value = &quot;users&quot;, key = &quot;#id&quot;, beforeInvocation = true)public void deleteUserWithException(Long id) &#123;    // 即使方法执行失败，缓存也会被清除    throw new RuntimeException(&quot;删除失败&quot;);&#125;\r\n主要属性：\r\n\r\nallEntries：是否清除所有缓存条目\r\nbeforeInvocation：是否在方法执行前清除缓存\r\n\r\n@CacheConfig\r\n类级别的缓存配置，用于设置该类中所有缓存操作的默认配置：\r\n@Service@CacheConfig(cacheNames = &quot;users&quot;, keyGenerator = &quot;customKeyGenerator&quot;)public class UserService &#123;        @Cacheable  // 使用默认的 cacheNames 和 keyGenerator    public User getUserById(Long id) &#123;        return userRepository.findById(id);    &#125;&#125;\r\nSpEL 表达式在缓存中的应用\r\nSpEL（Spring Expression Language）是Spring框架中用于表达式语言的一种方式。它类似于其他编程语言中的表达式语言，用于在运行时计算值或执行特定任务。\r\nSpEL表达式可以在字符串中进行定义，使用特殊的语法和符号来表示特定的操作。\r\nSpEL支持各种操作和函数，包括算术运算、逻辑运算、条件判断、正则表达式匹配、集合操作等。它还支持访问上下文中的变量和参数，以及调用对象的方法。\r\nSpring 缓存支持强大的 SpEL（Spring Expression Language）表达式：\r\n可用变量\r\npublic class CacheExample &#123;        // 使用方法参数    @Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)    public User getUser(Long id) &#123; ... &#125;        // 使用方法参数的属性    @Cacheable(value = &quot;users&quot;, key = &quot;#user.id&quot;)    public User saveUser(User user) &#123; ... &#125;        // 使用方法返回值    @CachePut(value = &quot;users&quot;, key = &quot;#result.id&quot;)    public User updateUser(User user) &#123; ... &#125;        // 使用根对象    @Cacheable(value = &quot;users&quot;, key = &quot;#root.methodName + &#x27;_&#x27; + #id&quot;)    public User findUser(Long id) &#123; ... &#125;        // 使用条件表达式    @Cacheable(value = &quot;users&quot;, condition = &quot;#id &gt; 0 and #id &lt; 1000&quot;)    public User getUserInRange(Long id) &#123; ... &#125;        // 复杂表达式    @Cacheable(value = &quot;users&quot;,                key = &quot;#user.id&quot;,                condition = &quot;#user.age &gt;= 18&quot;,               unless = &quot;#result == null or #result.status == &#x27;INACTIVE&#x27;&quot;)    public User getActiveAdultUser(User user) &#123; ... &#125;        // 安全导航操作符（?.）：当 user 为 null 时返回 null 而非抛出异常\t@Cacheable(value = &quot;user&quot;, key = &quot;#user?.id&quot;, unless = &quot;#result == null&quot;)\tpublic User getUser(User user) &#123; ... &#125;        // 调用方法参数的方法生成键\t@Cacheable(value = &quot;products&quot;, key = &quot;#product.generateCacheKey()&quot;)\tpublic Product getProduct(Product product) &#123; ... &#125;\t// 使用 SpEL 内置函数（如 T() 访问静态方法）\t@Cacheable(value = &quot;config&quot;, key = &quot;T(java.util.UUID).randomUUID().toString()&quot;)\tpublic Config getDynamicConfig() &#123; ... &#125;&#125;\r\n自定义键生成器\r\n@Componentpublic class CustomKeyGenerator implements KeyGenerator &#123;        @Override    public Object generate(Object target, Method method, Object... params) &#123;        StringBuilder key = new StringBuilder();        key.append(target.getClass().getSimpleName()).append(&quot;_&quot;);        key.append(method.getName()).append(&quot;_&quot;);                for (Object param : params) &#123;            if (param != null) &#123;                key.append(param.toString()).append(&quot;_&quot;);            &#125;        &#125;                return key.toString();    &#125;&#125;\r\nSpring Boot\r\n使用自带缓存机制的例子\r\n在 pom.xml 中添加如下依赖（Spring Boot Starter Cache）：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\r\n实体类\r\nimport lombok.Data;import java.io.Serializable;@Datapublic class Product implements Serializable &#123;    private String id;    private String name;    private double price;&#125;\r\n服务层\r\nimport org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.CacheEvict;import org.springframework.stereotype.Service;import java.util.HashMap;import java.util.Map;@Servicepublic class ProductService &#123;    // 模拟数据库    private Map&lt;String, Product&gt; productMap = new HashMap&lt;&gt;();    // 缓存查询方法    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)    public Product getProductById(String id) &#123;        // 模拟耗时查询        try &#123;            Thread.sleep(2000);        &#125; catch (InterruptedException e) &#123;            Thread.currentThread().interrupt();        &#125;                return productMap.get(id);    &#125;    // 添加商品    public void addProduct(Product product) &#123;        productMap.put(product.getId(), product);    &#125;    // 清除缓存    @CacheEvict(value = &quot;products&quot;, key = &quot;#id&quot;)    public void deleteProduct(String id) &#123;        productMap.remove(id);    &#125;&#125;\r\n控制器\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/products&quot;)public class ProductController &#123;    @Autowired    private ProductService productService;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Product getProduct(@PathVariable String id) &#123;        return productService.getProductById(id);    &#125;    @PostMapping    public void addProduct(@RequestBody Product product) &#123;        productService.addProduct(product);    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void deleteProduct(@PathVariable String id) &#123;        productService.deleteProduct(id);    &#125;&#125;\r\n启动类，需要加上 @EnableCaching 注解\r\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;@SpringBootApplication@EnableCachingpublic class CacheDemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(CacheDemoApplication.class, args);    &#125;&#125;\r\n可以进行一些常用的缓存配置\r\n# 缓存类型配置# 可选值：simple, none, generic, ehcache, hazelcast, infinispan, jcache, redisspring.cache.type=simple# 缓存名称，多个缓存名称用逗号分隔spring.cache.cache-names=products,users# 缓存过期时间配置（单位：毫秒）# 注意：simple类型缓存不支持过期时间spring.cache.redis.time-to-live=3600000# 是否允许缓存空值# 防止缓存穿透，但可能导致缓存中存储大量null值spring.cache.cache-null-values=true# JCache（JSR-107）提供者配置spring.cache.jcache.provider=com.example.MyCacheProvider# Redis缓存额外配置# 是否使用缓存前缀spring.cache.redis.use-key-prefix=true# Redis缓存键前缀spring.cache.redis.key-prefix=mycache:# 是否缓存空值spring.cache.redis.cache-null-values=true# Redis缓存过期时间（秒）spring.cache.redis.expires=3600# Ehcache配置文件位置spring.cache.ehcache.config=classpath:ehcache.xml# 是否允许覆盖已存在的缓存配置spring.cache.override-spring-cache-config=false# 自定义缓存管理器# 指定自定义的CacheManager实现类spring.cache.cache-manager=com.example.MyCacheManagerImpl# 分布式缓存配置（以Redis为例）# Redis服务器地址spring.redis.host=localhostspring.redis.port=6379# Redis缓存序列化方式spring.cache.redis.serialization-mode=json# 是否启用缓存统计spring.cache.cache-statistics-enabled=true\r\n或者就是写缓存的配置类了 需要标注 @Configuration\r\n和@EnableCaching 注解\r\n常用的 HTTP 请求状态码\r\n在这里提一下上一篇忘提到的状态码\r\n信息性状态码（100 - 199）\r\n表示服务器已接收请求，正在处理中。\r\n\r\n100 Continue\r\n客户端发送了部分请求，服务器指示可继续发送剩余内容。\r\n101 Switching Protocols\r\n服务器接受协议切换请求（如从 HTTP 切换到 WebSocket）。\r\n103 Early Hints\r\n服务器提前返回资源提示（如预加载响应头），优化用户体验。\r\n\r\n成功状态码（200 - 299）\r\n表示请求已成功处理。\r\n\r\n200 OK\r\n最常见的成功响应，请求已完成且资源正常返回。\r\n201 Created\r\n请求创建了新资源（如上传文件、创建用户），返回资源位置。\r\n202 Accepted\r\n请求已接受但尚未完成处理（如异步任务）。\r\n203 Non-Authoritative Information\r\n服务器返回的信息并非来自原始数据源（如缓存）。\r\n204 No Content\r\n请求成功但无返回内容（如删除操作后），浏览器不刷新页面。\r\n205 Reset Content\r\n请求成功，客户端需重置文档视图（如表单重置）。\r\n206 Partial Content\r\n服务器返回部分资源（如大文件分片下载），配合Range请求头使用。\r\n\r\n重定向状态码（300 - 399）\r\n表示需要客户端进一步操作以完成请求。\r\n\r\n301 Moved Permanently\r\n资源永久迁移，后续请求应使用新 URL（SEO 需注意更新链接）。\r\n302 Found 资源临时迁移，客户端应使用原 URL\r\n重新请求（如登录页重定向）。\r\n303 See Other 请求的响应需重定向到其他\r\nURL（通常用于 POST 请求后的跳转）。\r\n304 Not Modified\r\n资源未修改，客户端可使用缓存内容（减少带宽消耗）。\r\n307 Temporary Redirect\r\n临时重定向，保留原始请求方法（如 POST 请求重定向后仍为 POST）。\r\n308 Permanent Redirect\r\n永久重定向，保留原始请求方法（替代 301，更规范）。\r\n\r\n客户端错误状态码（400 - 499）\r\n表示客户端请求存在错误。\r\n\r\n400 Bad Request 请求语法错误（如参数格式错误、JSON\r\n解析失败）。\r\n401 Unauthorized 未授权，需提供认证信息（如\r\nToken、Cookie）。\r\n402 Payment Required\r\n预留状态码（理论上用于付费场景，实际很少使用）。\r\n403 Forbidden 服务器拒绝请求（如权限不足、IP\r\n被封禁）。\r\n404 Not Found 资源不存在（URL\r\n错误或资源已删除）。\r\n405 Method Not Allowed\r\n请求方法不被允许（如对静态资源使用 POST 请求）。\r\n406 Not Acceptable\r\n服务器无法提供符合Accept头要求的响应格式。\r\n407 Proxy Authentication Required\r\n需要代理服务器认证（与 401 类似，但针对代理）。\r\n408 Request Timeout\r\n请求超时，服务器未在规定时间内收到完整请求。\r\n409 Conflict\r\n请求与资源状态冲突（如版本冲突、重复提交）。\r\n410 Gone 资源永久删除（比 404\r\n更明确，提示不再存在）。\r\n411 Length Required\r\n请求缺少Content-Length头（需指定请求体长度）。\r\n412 Precondition Failed\r\n请求的条件（如If-Modified-Since）不满足。\r\n413 Payload Too Large\r\n请求体过大，超出服务器限制（如文件上传大小超限）。\r\n414 URI Too Long URL\r\n过长，服务器无法处理（常见于携带过多参数）。\r\n415 Unsupported Media Type 请求体格式不支持（如发送\r\nJSON 但未声明Content-Type: application/json）。\r\n416 Range Not Satisfiable\r\n请求的Range范围无效（如超出文件大小）。\r\n422 Unprocessable Entity\r\n请求格式正确但语义错误（如表单验证失败，REST API 常用）。\r\n425 Too Early\r\n请求过早，服务器拒绝处理（如防止重放攻击）。\r\n426 Upgrade Required 服务器要求升级协议（如从 HTTP\r\n升级到 HTTPS）。\r\n428 Precondition Required\r\n请求需包含条件头（如If-Match，用于乐观锁）。\r\n429 Too Many Requests\r\n客户端请求频率过高，触发限流（如 API 访问频次限制）。\r\n431 Request Header Fields Too Large\r\n请求头字段过大，服务器拒绝处理。\r\n\r\n服务器错误状态码（500 - 599）\r\n表示服务器处理请求时发生错误。\r\n\r\n500 Internal Server Error\r\n最常见的服务器错误（如代码异常、数据库连接失败）。\r\n501 Not Implemented 服务器不支持请求的功能（如未知\r\nAPI 接口）。\r\n502 Bad Gateway\r\n代理服务器从上游服务器获取响应失败（如 Nginx 后端服务异常）。\r\n503 Service Unavailable\r\n服务器暂时不可用（如过载、维护中，常伴随Retry-After头）。\r\n504 Gateway Timeout\r\n代理服务器等待上游服务器响应超时。\r\n505 HTTP Version Not Supported 服务器不支持请求的\r\nHTTP 版本（如使用 HTTP/3 但服务器未启用）。\r\n511 Network Authentication Required\r\n客户端需进行网络认证（如公共 WiFi 的登录页）。\r\n\r\n记忆技巧\r\n\r\n2xx：成功（200 OK 是核心）。\r\n3xx：重定向（301 永久、302 临时）。\r\n4xx：客户端错（404 找不到、403 没权限）。\r\n5xx：服务器错（500 内部错误、502 网关错误）。\r\n\r\nSpring Boot 下控制和配置缓存\r\nspring.web 下都有什么配置\r\n\r\n国际化相关配置\r\n\r\nlocale：用于设置应用程序的默认区域设置。例如，可以设置为Locale.US或Locale.CHINA等，以指定应用程序的默认语言和地区。\r\nlocaleResolver：指定用于解析用户请求中的区域设置的策略。可取值为FIXED（固定的区域设置）或ACCEPT_HEADER（根据请求头中的Accept-Language字段来解析区域设置）。\r\n\r\n静态资源的相关配置策略（开启，处理链，缓存）\r\n\r\nresources.staticLocations：指定静态资源的位置。默认值为classpath:/META - INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/，可以通过设置此属性来添加或修改静态资源的位置。\r\nresources.addMappings：是否自动添加静态资源的映射。默认为true，即\r\nSpring 会自动将静态资源路径映射到对应的\r\nURL，以便能够通过浏览器访问静态资源。\r\nresources.chain.enabled：资源处理链是否启用。可通过resources.chain.strategy.fixed.enabled和resources.chain.strategy.content.enabled以及此属性共同确定最终是否启用。\r\nresources.chain.cache：是否启用资源缓存，默认为true。\r\nresources.chain.compressed：是否对资源进行压缩，默认为false。\r\nresources.cache.period：静态资源缓存的时长。\r\nresources.cache.useLastModified：是否使用Last - Modified头来判断资源是否过期，默认为true。\r\nresources.cache.cachecontrol.maxAge：缓存的最大年龄，即资源在缓存中可以存在的最长时间。\r\nresources.cache.cachecontrol.noCache：是否设置Cache - Control头为no - cache，表示不使用缓存。\r\nresources.cache.cachecontrol.noStore：是否设置Cache - Control头为no - store，表示不存储缓存。\r\nresources.cache.cachecontrol.mustRevalidate：是否设置Cache - Control头的must - revalidate属性，指示缓存必须在使用之前重新验证。\r\nresources.cache.cachecontrol.noTransform：是否设置Cache - Control头的no - transform属性，防止中间缓存对资源进行转换。\r\nresources.cache.cachecontrol.cachePublic：是否设置Cache - Control头的public属性，指示缓存可以被公共缓存（如代理服务器）缓存。\r\nresources.cache.cachecontrol.cachePrivate：是否设置Cache - Control头的private属性，指示缓存只能被私有缓存（如浏览器）缓存。\r\nresources.cache.cachecontrol.proxyRevalidate：是否设置Cache - Control头的proxy - revalidate属性，指示代理服务器必须在使用缓存之前重新验证资源。\r\nresources.cache.cachecontrol.staleWhileRevalidate：设置Cache - Control头的stale - while - revalidate属性，指定在重新验证资源期间可以使用过期缓存的时长。\r\nresources.cache.cachecontrol.staleIfError：设置Cache - Control头的stale - if - error属性，指定在发生错误时可以使用过期缓存的时长。\r\nresources.cache.cachecontrol.sMaxAge：设置Cache - Control头的s - maxage属性，指定公共缓存中资源的最大缓存时间。\r\n\r\n\r\n涉及到spring.web的配置类WebProperties源码\r\n源码其实很长，与spring.web相关的配置类是WebProperties\r\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.springframework.boot.autoconfigure.web;import java.time.Duration;import java.time.temporal.ChronoUnit;import java.util.Locale;import java.util.Objects;import java.util.concurrent.TimeUnit;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.PropertyMapper;import org.springframework.boot.convert.DurationUnit;import org.springframework.http.CacheControl;@ConfigurationProperties(&quot;spring.web&quot;)public class WebProperties &#123;    private Locale locale;    private LocaleResolver localeResolver;    private final Resources resources;    public WebProperties() &#123;        this.localeResolver = WebProperties.LocaleResolver.ACCEPT_HEADER;        this.resources = new Resources();    &#125;    public Locale getLocale() &#123;        return this.locale;    &#125;    public void setLocale(Locale locale) &#123;        this.locale = locale;    &#125;    public LocaleResolver getLocaleResolver() &#123;        return this.localeResolver;    &#125;    public void setLocaleResolver(LocaleResolver localeResolver) &#123;        this.localeResolver = localeResolver;    &#125;    public Resources getResources() &#123;        return this.resources;    &#125;    public static enum LocaleResolver &#123;        FIXED,        ACCEPT_HEADER;        private LocaleResolver() &#123;        &#125;    &#125;    public static class Resources &#123;        private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;;        private String[] staticLocations;        private boolean addMappings;        private boolean customized;        private final Chain chain;        private final Cache cache;        public Resources() &#123;            this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;            this.addMappings = true;            this.customized = false;            this.chain = new Chain();            this.cache = new Cache();        &#125;        public String[] getStaticLocations() &#123;            return this.staticLocations;        &#125;        public void setStaticLocations(String[] staticLocations) &#123;            this.staticLocations = this.appendSlashIfNecessary(staticLocations);            this.customized = true;        &#125;        private String[] appendSlashIfNecessary(String[] staticLocations) &#123;            String[] normalized = new String[staticLocations.length];            for(int i = 0; i &lt; staticLocations.length; ++i) &#123;                String location = staticLocations[i];                normalized[i] = location.endsWith(&quot;/&quot;) ? location : location + &quot;/&quot;;            &#125;            return normalized;        &#125;        public boolean isAddMappings() &#123;            return this.addMappings;        &#125;        public void setAddMappings(boolean addMappings) &#123;            this.customized = true;            this.addMappings = addMappings;        &#125;        public Chain getChain() &#123;            return this.chain;        &#125;        public Cache getCache() &#123;            return this.cache;        &#125;        public boolean hasBeenCustomized() &#123;            return this.customized || this.getChain().hasBeenCustomized() || this.getCache().hasBeenCustomized();        &#125;        public static class Chain &#123;            boolean customized = false;            private Boolean enabled;            private boolean cache = true;            private boolean compressed = false;            private final Strategy strategy = new Strategy();            public Chain() &#123;            &#125;            public Boolean getEnabled() &#123;                return getEnabled(this.getStrategy().getFixed().isEnabled(), this.getStrategy().getContent().isEnabled(), this.enabled);            &#125;            private boolean hasBeenCustomized() &#123;                return this.customized || this.getStrategy().hasBeenCustomized();            &#125;            public void setEnabled(boolean enabled) &#123;                this.enabled = enabled;                this.customized = true;            &#125;            public boolean isCache() &#123;                return this.cache;            &#125;            public void setCache(boolean cache) &#123;                this.cache = cache;                this.customized = true;            &#125;            public Strategy getStrategy() &#123;                return this.strategy;            &#125;            public boolean isCompressed() &#123;                return this.compressed;            &#125;            public void setCompressed(boolean compressed) &#123;                this.compressed = compressed;                this.customized = true;            &#125;            static Boolean getEnabled(boolean fixedEnabled, boolean contentEnabled, Boolean chainEnabled) &#123;                return !fixedEnabled &amp;&amp; !contentEnabled ? chainEnabled : Boolean.TRUE;            &#125;            public static class Strategy &#123;                private final Fixed fixed = new Fixed();                private final Content content = new Content();                public Strategy() &#123;                &#125;                public Fixed getFixed() &#123;                    return this.fixed;                &#125;                public Content getContent() &#123;                    return this.content;                &#125;                private boolean hasBeenCustomized() &#123;                    return this.getFixed().hasBeenCustomized() || this.getContent().hasBeenCustomized();                &#125;                public static class Fixed &#123;                    private boolean customized = false;                    private boolean enabled;                    private String[] paths = new String[]&#123;&quot;/**&quot;&#125;;                    private String version;                    public Fixed() &#123;                    &#125;                    public boolean isEnabled() &#123;                        return this.enabled;                    &#125;                    public void setEnabled(boolean enabled) &#123;                        this.customized = true;                        this.enabled = enabled;                    &#125;                    public String[] getPaths() &#123;                        return this.paths;                    &#125;                    public void setPaths(String[] paths) &#123;                        this.customized = true;                        this.paths = paths;                    &#125;                    public String getVersion() &#123;                        return this.version;                    &#125;                    public void setVersion(String version) &#123;                        this.customized = true;                        this.version = version;                    &#125;                    private boolean hasBeenCustomized() &#123;                        return this.customized;                    &#125;                &#125;                public static class Content &#123;                    private boolean customized = false;                    private boolean enabled;                    private String[] paths = new String[]&#123;&quot;/**&quot;&#125;;                    public Content() &#123;                    &#125;                    public boolean isEnabled() &#123;                        return this.enabled;                    &#125;                    public void setEnabled(boolean enabled) &#123;                        this.customized = true;                        this.enabled = enabled;                    &#125;                    public String[] getPaths() &#123;                        return this.paths;                    &#125;                    public void setPaths(String[] paths) &#123;                        this.customized = true;                        this.paths = paths;                    &#125;                    private boolean hasBeenCustomized() &#123;                        return this.customized;                    &#125;                &#125;            &#125;        &#125;        public static class Cache &#123;            private boolean customized = false;            @DurationUnit(ChronoUnit.SECONDS)            private Duration period;            private final Cachecontrol cachecontrol = new Cachecontrol();            private boolean useLastModified = true;            public Cache() &#123;            &#125;            public Duration getPeriod() &#123;                return this.period;            &#125;            public void setPeriod(Duration period) &#123;                this.customized = true;                this.period = period;            &#125;            public Cachecontrol getCachecontrol() &#123;                return this.cachecontrol;            &#125;            public boolean isUseLastModified() &#123;                return this.useLastModified;            &#125;            public void setUseLastModified(boolean useLastModified) &#123;                this.useLastModified = useLastModified;            &#125;            private boolean hasBeenCustomized() &#123;                return this.customized || this.getCachecontrol().hasBeenCustomized();            &#125;            public static class Cachecontrol &#123;                private boolean customized = false;                @DurationUnit(ChronoUnit.SECONDS)                private Duration maxAge;                private Boolean noCache;                private Boolean noStore;                private Boolean mustRevalidate;                private Boolean noTransform;                private Boolean cachePublic;                private Boolean cachePrivate;                private Boolean proxyRevalidate;                @DurationUnit(ChronoUnit.SECONDS)                private Duration staleWhileRevalidate;                @DurationUnit(ChronoUnit.SECONDS)                private Duration staleIfError;                @DurationUnit(ChronoUnit.SECONDS)                private Duration sMaxAge;                public Cachecontrol() &#123;                &#125;                public Duration getMaxAge() &#123;                    return this.maxAge;                &#125;                public void setMaxAge(Duration maxAge) &#123;                    this.customized = true;                    this.maxAge = maxAge;                &#125;                public Boolean getNoCache() &#123;                    return this.noCache;                &#125;                public void setNoCache(Boolean noCache) &#123;                    this.customized = true;                    this.noCache = noCache;                &#125;                public Boolean getNoStore() &#123;                    return this.noStore;                &#125;                public void setNoStore(Boolean noStore) &#123;                    this.customized = true;                    this.noStore = noStore;                &#125;                public Boolean getMustRevalidate() &#123;                    return this.mustRevalidate;                &#125;                public void setMustRevalidate(Boolean mustRevalidate) &#123;                    this.customized = true;                    this.mustRevalidate = mustRevalidate;                &#125;                public Boolean getNoTransform() &#123;                    return this.noTransform;                &#125;                public void setNoTransform(Boolean noTransform) &#123;                    this.customized = true;                    this.noTransform = noTransform;                &#125;                public Boolean getCachePublic() &#123;                    return this.cachePublic;                &#125;                public void setCachePublic(Boolean cachePublic) &#123;                    this.customized = true;                    this.cachePublic = cachePublic;                &#125;                public Boolean getCachePrivate() &#123;                    return this.cachePrivate;                &#125;                public void setCachePrivate(Boolean cachePrivate) &#123;                    this.customized = true;                    this.cachePrivate = cachePrivate;                &#125;                public Boolean getProxyRevalidate() &#123;                    return this.proxyRevalidate;                &#125;                public void setProxyRevalidate(Boolean proxyRevalidate) &#123;                    this.customized = true;                    this.proxyRevalidate = proxyRevalidate;                &#125;                public Duration getStaleWhileRevalidate() &#123;                    return this.staleWhileRevalidate;                &#125;                public void setStaleWhileRevalidate(Duration staleWhileRevalidate) &#123;                    this.customized = true;                    this.staleWhileRevalidate = staleWhileRevalidate;                &#125;                public Duration getStaleIfError() &#123;                    return this.staleIfError;                &#125;                public void setStaleIfError(Duration staleIfError) &#123;                    this.customized = true;                    this.staleIfError = staleIfError;                &#125;                public Duration getSMaxAge() &#123;                    return this.sMaxAge;                &#125;                public void setSMaxAge(Duration sMaxAge) &#123;                    this.customized = true;                    this.sMaxAge = sMaxAge;                &#125;                public CacheControl toHttpCacheControl() &#123;                    PropertyMapper map = PropertyMapper.get();                    CacheControl control = this.createCacheControl();                    PropertyMapper.Source var10000 = map.from(this::getMustRevalidate).whenTrue();                    Objects.requireNonNull(control);                    var10000.toCall(control::mustRevalidate);                    var10000 = map.from(this::getNoTransform).whenTrue();                    Objects.requireNonNull(control);                    var10000.toCall(control::noTransform);                    var10000 = map.from(this::getCachePublic).whenTrue();                    Objects.requireNonNull(control);                    var10000.toCall(control::cachePublic);                    var10000 = map.from(this::getCachePrivate).whenTrue();                    Objects.requireNonNull(control);                    var10000.toCall(control::cachePrivate);                    var10000 = map.from(this::getProxyRevalidate).whenTrue();                    Objects.requireNonNull(control);                    var10000.toCall(control::proxyRevalidate);                    map.from(this::getStaleWhileRevalidate).whenNonNull().to((duration) -&gt; &#123;                        control.staleWhileRevalidate(duration.getSeconds(), TimeUnit.SECONDS);                    &#125;);                    map.from(this::getStaleIfError).whenNonNull().to((duration) -&gt; &#123;                        control.staleIfError(duration.getSeconds(), TimeUnit.SECONDS);                    &#125;);                    map.from(this::getSMaxAge).whenNonNull().to((duration) -&gt; &#123;                        control.sMaxAge(duration.getSeconds(), TimeUnit.SECONDS);                    &#125;);                    return control.getHeaderValue() == null ? null : control;                &#125;                private CacheControl createCacheControl() &#123;                    if (Boolean.TRUE.equals(this.noStore)) &#123;                        return CacheControl.noStore();                    &#125; else if (Boolean.TRUE.equals(this.noCache)) &#123;                        return CacheControl.noCache();                    &#125; else &#123;                        return this.maxAge != null ? CacheControl.maxAge(this.maxAge.getSeconds(), TimeUnit.SECONDS) : CacheControl.empty();                    &#125;                &#125;                private boolean hasBeenCustomized() &#123;                    return this.customized;                &#125;            &#125;        &#125;    &#125;&#125;\r\n有缓存有关的常用配置\r\n# 开启静态资源映射规则，默认 truespring.web.resources.add-map=true # 设置缓存存活时间，缓存详细合并项控制，覆盖 period 配置，浏览器第一次请求服务器，服务器告诉浏览器资源缓存3600秒，3600秒内所有此资源的访问不用发给服务器请求spring.web.resources.cache.cachecontrol.max-age=3600# 使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同，如果相同返回304spring.web.resources.cache.use-last-modified=true\r\n\r\n\r\nimage-20250529090140010\r\n\r\n缓存相关参数在响应头中有所体现，Spring Boot\r\n携带缓存等各种配置向浏览器发请求\r\nCache 相关的详细设置，在 Cachecontrol\r\n类里，可以参考这个类进行更详细的配置\r\npublic class CacheControl &#123;    @Nullable    private Duration maxAge;    private boolean noCache = false;    private boolean noStore = false;    private boolean mustRevalidate = false;    private boolean noTransform = false;    private boolean cachePublic = false;    private boolean cachePrivate = false;    private boolean proxyRevalidate = false;    @Nullable    private Duration staleWhileRevalidate;    @Nullable    private Duration staleIfError;    @Nullable    private Duration sMaxAge;    private boolean immutable = false;    protected CacheControl() &#123;    &#125;    。。。。。&#125;\r\n缓存实现与配置\r\n缓存实现方式之间的比较\r\n\r\nsimple：默认的内存缓存，使用 ConcurrentHashMap\r\n\r\n适合开发和测试环境\r\n不支持分布式\r\n性能较好，但不适合生产\r\n\r\nredis：分布式缓存\r\n\r\n支持集群\r\n持久化\r\n适合生产环境\r\n\r\nehcache：本地缓存\r\n\r\n支持磁盘持久化\r\n配置灵活\r\n适合单机应用\r\n\r\n\r\n内存缓存（默认）\r\nSpring Boot 默认使用简单的内存缓存：\r\nspring:  cache:    type: simple  # 默认值，可以省略\r\nRedis 缓存配置\r\nspring:  cache:    type: redis    redis:      time-to-live: 600000  # 10分钟      cache-null-values: false      key-prefix: &quot;myapp:&quot;      use-key-prefix: true  data:    redis:      host: localhost      port: 6379      database: 0      timeout: 2000ms      lettuce:        pool:          max-active: 8          max-idle: 8          min-idle: 0\r\n一般来说，如果需要自定义缓存配置，重写CacheConfig缓存配置类中的条目就可以\r\nHTTP 缓存配置\r\n静态资源缓存配置\r\nspring:  web:    resources:      # 开启静态资源映射      add-mappings: true      # 静态资源位置      static-locations: classpath:/static/,classpath:/public/      # 缓存配置      cache:        # 使用 Last-Modified 头        use-last-modified: true        # 缓存控制        cachecontrol:          max-age: 3600  # 1小时          cache-public: true          must-revalidate: true      # 资源处理链      chain:        enabled: true        cache: true        compressed: true        strategy:          content:            enabled: true            paths: /**\r\n使用Redis做集中式缓存\r\nRedisTemplate\r\n默认的缓存是在内存中定义HashMap，在实际的开发生产中，经常使用Redis作为缓存中间件，而不使用cache。\r\nRedis\r\n是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。也是以key-value的形式进行存储数据的一款非关系型数据库。\r\n通过Spring\r\nBoot与Redis的集成，可以实现高效的分布式缓存解决方案。Spring Cache\r\n抽象提供了简洁的注解方式，而 RedisTemplate\r\n则提供了更灵活的操作方式。\r\nRedis的Tempate 如下：\r\nRedis的常用五大数据类型\r\n\r\nString【字符串】、List【列表】、Set【集合】、Hash【散列】、ZSet【有序集合】\r\n\r\n分为两种\r\n\r\n一种是StringRedisTemplate\r\n\r\n字符串专属：仅支持 String\r\n类型的键值对操作，适合存储文本数据（如用户会话、配置信息）。专注于字符串操作，适合纯文本场景。\r\n序列化简单：使用 StringSerializer，将字符串直接存储到\r\nRedis，无需额外转换。\r\n可读性高：Redis 中存储的键值可直接查看（如通过\r\nredis-cli 命令）\r\n\r\n另一种是RedisTemplate\r\n\r\n通用型模板：支持 Redis\r\n所有数据类型（String、List、Set、Hash、ZSet），可存储任意 Java\r\n对象。\r\n灵活序列化：默认使用 Java 序列化（JDK\r\nSerialization），也可自定义序列化方式（如 JSON 序列化）。\r\n二进制存储：对象会被序列化为二进制数据，适合存储复杂结构（如用户对象、订单数据）。\r\n\r\n\r\n两者对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n对比维度\r\nStringRedisTemplate\r\nRedisTemplate\r\n\r\n\r\n\r\n\r\n默认序列化方式\r\nStringSerializer（字符串序列化）\r\nJdkSerializationRedisSerializer（Java 序列化）\r\n\r\n\r\n键（Key）类型\r\n只能是 String 类型\r\n可以是任意类型（需通过序列化转换）\r\n\r\n\r\n值（Value）类型\r\n只能是 String 类型\r\n可以是任意类型（需通过序列化转换）\r\n\r\n\r\n应用场景\r\n纯文本数据（如配置项、简单字符串）\r\n复杂对象、集合数据（如 Java 对象、List、Set）\r\n\r\n\r\n序列化结果\r\n直接存储字符串，可读性强\r\n存储二进制数据，可读性差但效率高\r\n\r\n\r\n\r\n并且Spring Boot会在侦测到存在 Redis 的依赖并且 Redis\r\n的配置是可用的情况下，还可以使用RedisCacheManager初始化CacheManager。\r\n实际例子\r\n下面写一个例子\r\n首先需要在pom.xml中添加Redis和Spring Cache的依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/version&gt;&lt;/dependency&gt;\r\n配置Redis\r\n在application.yml中配置Redis缓存信息：\r\nspring:  redis:    host: localhost    port: 6379    password:     database: 0  cache:    type: redis    redis:      time-to-live: 60000 # 缓存过期时间，单位毫秒(ms)      key-prefix: CACHE_      use-key-prefix: true      cache-null-values: false\r\n启用缓存\r\n在主应用类上添加@EnableCaching注解：\r\n@SpringBootApplication@EnableCachingpublic class MyApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MyApplication.class, args);    &#125;&#125;\r\n基本缓存操作\r\n在Service层使用缓存注解\r\n@Servicepublic class ProductService &#123;    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)    public Product getProductById(Long id) &#123;        // 模拟数据库查询        System.out.println(&quot;Fetching product from database...&quot;);        return new Product(id, &quot;Product &quot; + id, 99.99);    &#125;    @CachePut(value = &quot;products&quot;, key = &quot;#product.id&quot;)    public Product updateProduct(Product product) &#123;        // 模拟数据库更新        System.out.println(&quot;Updating product in database...&quot;);        return product;    &#125;    @CacheEvict(value = &quot;products&quot;, key = &quot;#id&quot;)    public void deleteProduct(Long id) &#123;        // 模拟数据库删除        System.out.println(&quot;Deleting product from database...&quot;);    &#125;    @Caching(evict = &#123;        @CacheEvict(value = &quot;products&quot;, allEntries = true)    &#125;)    public void clearAllCache() &#123;        System.out.println(&quot;Clearing all products cache...&quot;);    &#125;&#125;\r\n可以自定义Redis缓存配置以更好地控制缓存行为：\r\n@Configuration@EnableCachingpublic class RedisCacheConfig &#123;    @Bean    public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123;        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()            .entryTtl(Duration.ofMinutes(10)) // 默认过期时间10分钟            .disableCachingNullValues() // 不缓存null值            .prefixCacheNameWith(&quot;CACHE_&quot;) // 缓存key前缀           .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));        return RedisCacheManager.builder(redisConnectionFactory)            .cacheDefaults(config)            .withInitialCacheConfigurations(getCacheConfigurations())            .transactionAware()            .build();    &#125;    private Map&lt;String, RedisCacheConfiguration&gt; getCacheConfigurations() &#123;        Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;();                // 为products缓存设置不同的过期时间        cacheConfigurations.put(&quot;products&quot;,             RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofHours(1)));                // 为users缓存设置不同的序列化方式        cacheConfigurations.put(&quot;users&quot;,             RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofMinutes(30))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new JdkSerializationRedisSerializer())));                return cacheConfigurations;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","配置相关"]},{"title":"Spring Boot part1-Spring Boot框架的入门与介绍","url":"/posts/24829.html","content":"Spring Boot开发的两大流派\r\n\r\n\r\nimage-20250524204200477\r\n\r\nSpring Boot 从 2 开始，分为了两大流派：\r\n\r\n响应式栈（Reactive Stack ）和 Servlet 栈（Servlet Stack ）。\r\n\r\n响应式栈（Reactive Stack ）\r\n\r\n框架：Spring WebFlux ，是一个非阻塞的 Web\r\n框架，充分利用多核下一代处理器的优势，能处理大量并发连接。\r\n底层支持：依赖 Netty、Servlet 3.1 + 容器\r\n，并通过响应式流适配器（Reactive Streams Adapters）实现。\r\n相关组件\r\n\r\nSpring Security Reactive：响应式安全组件。\r\nSpring WebFlux：核心的响应式 Web 框架。\r\nSpring Data Reactive Repositories：支持\r\nMongo、Cassandra、Redis、Couchbase、R2DBC\r\n等数据库的响应式数据仓库。\r\n\r\n\r\n响应式栈主要好处和特点是很好的压榨了多核心 CPU\r\n的能力，基于缓冲区机制和调度器去调度 CPU\r\n，去处理大量的请求和实现高并发这种功能。这其实也就是我们常说的\r\n非阻塞 I/O，以 Spring WebFlux 为核心框架\r\n，基于异步非阻塞方式，不阻塞线程等待 I/O\r\n操作完成，充分利用多核处理器优势，能高效处理大量并发连接，提升系统吞吐量。支持多种异步框架，依赖\r\nNetty 等框架及 Servlet 3.1 + 容器，提供异步 I/O 能力。\r\n而且响应式栈基于响应式的编程模型，遵循响应式流规范，基于事件驱动的异步数据流处理模式，少量线程就能处理众多请求，资源利用高效。\r\nServlet 栈（Servlet Stack ）\r\n\r\n框架：Spring MVC ，基于 Servlet API 构建，采用同步阻塞 I/O\r\n架构，一个请求对应一个线程模型。\r\n底层支持：依赖 Servlet 容器和 Servlet API 。\r\n相关组件\r\n\r\nSpring Security：传统安全组件。\r\nSpring MVC：传统的 MVC 框架。\r\nSpring Data Repositories：支持 JDBC、JPA、NoSQL\r\n等数据库的数据仓库。\r\n\r\n\r\nSpring MVC 架构基于 Servlet API 构建，采用同步阻塞 I/O\r\n架构，每个请求占用一个线程，请求处理过程中线程会阻塞等待 I/O\r\n操作完成。这样就是使用了传统的分时\r\nCPU，适合小规模的普通应用，因为传统编程模型，是较为传统、开发者熟悉的编程模型，代码编写、阅读和调试相对容易，基于命令式编程。运行依赖\r\nServlet 容器，如 Tomcat、Jetty 等。\r\n响应式栈处理高并发时，用少量线程和资源；Servlet\r\n栈高并发下需较多线程，资源消耗大，线程池线程耗尽时性能受影响。响应式栈适合实时性要求高、高并发场景，如物联网、金融交易系统；Servlet\r\n栈适合传统 Web 应用开发，对并发要求不是极高的场景 。\r\nSpring Boot 概述\r\nSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化\r\nSpring 应用的创建、运行、调试、部署等。使用 Spring Boot 可以做到专注于\r\nSpring 应用的开发，而无需过多关注 XML 的配置。Spring Boot\r\n使用“习惯优于配置”的理念，简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题。使用\r\nSpring Boot 可以不用或者只需要很少的 Spring\r\n配置就可以让企业项目快速运行起来。\r\n\r\n提供预配置的依赖包\r\n按照使用习惯解决依赖问题\r\n极大减少XML配置\r\n开箱即用的应用程序架构\r\n\r\nSpringBoot是一个快速开发的框架，能过快速整合第三方框架，他是如何快速整合的呢？其实他是的基本原来是Maven依赖关系，Maven的集成，完全采用注解化，简化XML配置，内嵌HTTP服务器（Tomcate，jetty），默认嵌入Tomcate，最终以Java应用程序进行执行。\r\n所以说，Spring Boot 是开发者和 Spring Framework\r\n本身框架的中间层，帮助开发者统筹管理应用的配置，提供基于实际开发中常见配置的默认处理（即习惯优于配置），简化应用的开发，简化应用的运维；\r\n总的来说，其目的 Spring Boot 就是为了对 Java web\r\n的开发进行“简化”和加“快”速度，简化开发过程中引入或启动相关 Spring\r\n功能的配置。这样带来的好处就是降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。\r\n同时随着微服务概念的推广和实践，Spring Boot\r\n的精简理念又使其成为Java微服务开发的不二之选，也可以说，Spring Boot\r\n其实就是为了微服务而生的 Java web 框架。\r\nSpringBoot与SpringMVC 的区别是什么，说白了，就是 Spring Boot Web\r\n组件默认集成 SpringMVC 框架, SpringMVC3.0 以后支持注解方式使用 java\r\n代码启动 SpringMVC 。\r\n与 Spring\r\nFramework衔接并且起步\r\n我们已经在前面详细介绍了Spring框架，它的主要功能包括IoC容器、AOP支持、事务支持、MVC开发以及强大的第三方集成功能等。\r\n那么，Spring Boot又是什么？它和Spring是什么关系？\r\nSpring\r\nBoot是一个基于Spring的套件，它帮我们预组装了Spring的一系列组件，以便以尽可能少的代码和配置来开发基于Spring的Java应用程序。\r\n如果把应用开发比作组装汽车：\r\n\r\nSpring Framework =\r\n汽车零部件（发动机、传动、轮胎、底盘等）\r\nSpring Boot =\r\n预装好的整车（可以直接上路，需要时可以换配件）\r\n\r\n因此，Spring\r\nBoot和Spring的关系就是整车和零部件的关系，它们不是取代关系，试图跳过Spring直接学习Spring\r\nBoot是不可能的。\r\nSpring Boot的目标就是提供一个开箱即用的应用程序架构，我们基于Spring\r\nBoot的预置结构继续开发，省时省力。\r\n本章我们将详细介绍如何使用Spring Boot。\r\n本教程使用的Spring Boot版本是3.x版，如果使用Spring Boot\r\n2.x则需注意，两者有以下不同：\r\n\r\n\r\n\r\n\r\nSpring Boot 2.x\r\nSpring Boot 3.x\r\n\r\n\r\n\r\n\r\nSpring版本\r\nSpring 5.x\r\nSpring 6.x\r\n\r\n\r\nJDK版本\r\n&gt;= 1.8\r\n&gt;= 17\r\n\r\n\r\nTomcat版本\r\n9.x\r\n10.x\r\n\r\n\r\nAnnotation包\r\njavax.annotation\r\njakarta.annotation\r\n\r\n\r\nServlet包\r\njavax.servlet\r\njakarta.servlet\r\n\r\n\r\nJMS包\r\njavax.jms\r\njakarta.jms\r\n\r\n\r\nJavaMail包\r\njavax.mail\r\njakarta.mail\r\n\r\n\r\n\r\nSpring Boot 3.x的重要变化：\r\n// Spring Boot 2.ximport javax.servlet.http.HttpServletRequest;import javax.annotation.PostConstruct;// Spring Boot 3.x  import jakarta.servlet.http.HttpServletRequest;import jakarta.annotation.PostConstruct;\r\n注意：Spring Boot 3.x要求JDK\r\n17+，并且包名从javax.*迁移到jakarta.*\r\n如果使用Spring Boot的其他版本，则需要根据需要调整代码。\r\nSpring\r\nBoot的核心功能（核心特性）\r\n\r\n可独立运行的Spring项目：Spring Boot 可以以 jar\r\n包的形式独立运行。\r\n# 直接运行jar包java -jar myapp.jar\r\n内嵌的Servlet容器：Spring Boot可以选择内嵌 Tomcat、Jetty 或者\r\nUndertow，无须以 war 包形式部署项目。\r\n# application.yml配置示例server:  port: 8080  servlet:    context-path: /api  tomcat:    max-threads: 200\r\n简化的Maven配置：Spring 提供推荐的基础 pom.xml 文件来简化 Maven\r\n配置。\r\n&lt;!-- 父POM继承 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;relativePath/&gt;&lt;/parent&gt;&lt;!-- Starter依赖 --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n自动配置Spring以及第三方库：Spring Boot\r\n会根据项目依赖来自动配置Spring\r\n框架，极大地减少项目要使用的配置。也就是所谓的 约定大于配置\r\n@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;// @SpringBootApplication 等价于：// @Configuration + @EnableAutoConfiguration + @ComponentScan\r\n提供生产级特性 Actuator\r\n：提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查。\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\r\n常用监控端点：\r\n\r\n/actuator/health - 健康检查\r\n/actuator/metrics - 性能指标\r\n/actuator/info - 应用信息\r\n/actuator/env - 环境配置\r\n\r\n拥有可选的\r\nstarter：简化应用的整合，为生产的各种场景准备了对应的依赖坐标，导入一个就能全部导入\r\nStarter依赖生态\r\n\r\n\r\n\r\nStarter 名称\r\n功能描述\r\n\r\n\r\n\r\n\r\nspring-boot-starter-web\r\nWeb 开发（Spring MVC）\r\n\r\n\r\nspring-boot-starter-webflux\r\n响应式 Web 开发\r\n\r\n\r\nspring-boot-starter-data-jpa\r\nJPA 数据访问\r\n\r\n\r\nspring-boot-starter-security\r\nSpring Security 安全\r\n\r\n\r\nspring-boot-starter-test\r\n测试支持\r\n\r\n\r\nspring-boot-starter-redis\r\nRedis 缓存\r\n\r\n\r\n\r\n无代码生成和xml配置：Spring Boot 不生成代码。完全不需要任何 xml\r\n配置即可实现 Spring 的所有配置。\r\n传统Spring配置\r\n&lt;!-- web.xml --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;!-- spring-mvc.xml --&gt;&lt;context:component-scan base-package=&quot;com.example&quot;/&gt;&lt;mvc:annotation-driven/&gt;\r\nSpring Boot配置：\r\n@SpringBootApplication  // 一个注解搞定！public class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\r\n\r\n快速整合原理\r\n&lt;!-- Spring Boot的魔法：starter依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\r\nSpring Boot快速整合第三方框架的原理：\r\n\r\nMaven依赖管理：通过starter依赖自动引入相关组件\r\n注解驱动：完全采用注解化配置，简化XML\r\n内嵌服务器：默认嵌入Tomcat，支持Jetty、Undertow\r\n自动配置：根据classpath自动配置组件\r\n\r\nSpring Boot与微服务\r\nSpring\r\nBoot的精简理念使其成为Java微服务开发的首选框架：\r\n\r\n轻量级、快速启动\r\n独立运行，无需外部容器\r\n易于容器化部署\r\n完美支持Cloud Native应用\r\n\r\n建议学什么\r\n以尚硅谷的为例子\r\n\r\n\r\nimage-20250524204944287\r\n\r\nJava 基础\r\n\r\nJava 基础：熟练掌握 Java\r\n语法，包括面向对象编程（类、对象、继承、多态等\r\n）、异常处理、泛型、集合框架等。同时，Java 17\r\n及以上版本特性也需了解，因为 Spring Boot3 与 Java 17\r\n及更高版本兼容。\r\n函数式编程基础：理解 Lambda\r\n表达式、函数式接口，Stream API 等函数式编程相关概念 ，这有助于理解和使用\r\nSpring Boot3 中一些响应式编程和函数式风格的特性。\r\n\r\nSpring Boot3 核心概念\r\n\r\n自动配置：Spring Boot3\r\n能根据项目依赖和配置自动配置应用，像自动配置 Web\r\n服务器、数据库连接池、缓存等。需明白其自动配置原理和机制，以及如何自定义配置覆盖默认配置。\r\n起步依赖：通过添加起步依赖（如 spring - boot -\r\nstarter - web、spring - boot - starter - data - jpa 等），Spring Boot3\r\n自动引入所需的其他依赖，要掌握常见起步依赖用途和使用场景。\r\n嵌入式服务器：内置 Tomcat、Jetty、Undertow\r\n等嵌入式服务器，了解如何配置和使用它们，以及不同服务器的特点和适用场景。\r\nActuator：用于监控和管理 Spring Boot3\r\n应用，提供健康检查、性能指标、环境信息等功能。学会使用 Actuator\r\n暴露的端点监控应用运行状态。\r\n\r\n配置相关\r\n\r\n配置文件：掌握 application.properties 和\r\napplication.yml\r\n两种配置文件语法格式，以及如何配置常见项，如日志、数据源、Web\r\n服务器端口等。了解配置文件外部化、配置文件优先级等知识。\r\n自定义配置与属性：学会通过 @Value 注解注入属性值，使用 @ConfigurationProperties\r\n绑定配置属性到自定义类 。\r\n\r\nWeb 开发\r\n\r\nRESTful API 开发：利用 Spring MVC（Spring Boot3\r\n默认 Web 框架 ）创建 RESTful API，掌握 @RestController、@RequestMapping、@GetMapping\r\n等常用注解，以及请求参数处理、响应数据格式化等。\r\nThymeleaf 等模板引擎：若开发传统 Web 应用，了解\r\nThymeleaf 等模板引擎，用于渲染动态 HTML 页面。\r\n\r\n数据访问\r\n\r\nJPA（Java Persistence API）：使用 spring - boot -\r\nstarter - data - jpa 起步依赖集成 JPA，掌握 JPA\r\n基本操作，如实体类定义、Repository 接口编写、数据库 CRUD 操作。\r\n其他数据访问技术：除 JPA 外，了解 Spring Data\r\n对其他数据库（如 MySQL、PostgreSQL、Redis、MongoDB 等\r\n）的支持和操作方式。\r\n\r\n安全相关\r\n\r\nSpring Security：集成 Spring Security\r\n实现用户认证和授权，掌握基本认证方式（如表单认证、HTTP Basic 认证\r\n）、授权机制（如基于角色的访问控制 RBAC ）、密码加密等。\r\n\r\n响应式编程\r\n\r\nReactor：理解响应式编程模型，掌握 Reactor 框架中\r\nMono（表示 0 或 1 个元素的异步序列 ）和 Flux（表示 0\r\n到多个元素的异步序列 ）的使用，以及流操作符（如 map、filter、flatMap 等\r\n）、线程调度、错误处理等。\r\nSpring WebFlux：基于 Reactor 的响应式 Web\r\n框架，了解其与 Spring MVC 的区别，学会使用 Spring WebFlux\r\n开发异步、非阻塞的 Web 应用，处理高并发场景。\r\nSpring Data R2DBC：用于响应式访问关系型数据库，掌握\r\nR2dbc 驱动使用、DatabaseClient API 操作数据库，以及自定义\r\nRepository、处理关联查询等。\r\nSpring Security\r\nReactive：在响应式编程模型下实现安全控制，了解 RBAC\r\n权限模型配置、FilterChain 配置、ReactiveUserDetailsService 等。\r\n\r\n其他\r\n\r\n项目构建与部署：掌握 Maven 或 Gradle\r\n构建工具，学会打包项目（如生成可执行 JAR 或 WAR 包\r\n）。了解项目在生产环境的部署方式，如容器化（Docker、Kubernetes\r\n）、负载均衡等。\r\n性能优化与调优：掌握配置文件优化（如设置合理线程池、连接池\r\n）、使用缓存（@Cacheable 注解 ）、异步处理（@Async 注解\r\n）等性能优化技巧。\r\n日志管理：学会配置日志级别、输出格式等，使用日志记录应用运行信息，排查问题。\r\n\r\n这一套方案的比较全面且比较基础的，Spring Boot3 还要很多别的东西\r\nSpring Boot\r\n官方文档：https://docs.spring.io/spring-boot/index.html\r\n第一个 Spring Boot 程序\r\n要了解Spring Boot，我们先来编写第一个Spring\r\nBoot应用程序，看看与前面我们编写的Spring应用程序有何异同。\r\n目录结构\r\n我们新建一个springboot-ergou的工程，创建标准的 Maven工程\r\n目录结构如下：\r\nspringboot-demo/├── src/│   ├── main/│   │   ├── java/│   │   │   └── com/example/demo/│   │   │       ├── DemoApplication.java│   │   │       ├── controller/│   │   │       │   └── HelloController.java│   │   │       └── entity/│   │   │           └── User.java│   │   └── resources/│   │       ├── application.yml│   │       └── static/│   └── test/├── pom.xml└── README.md\r\n在存放源码的src/main/java目录中，Spring\r\nBoot对Java包的层级结构有一个要求。注意到我们的根package是edu.software.ergoutree.springbootpritical，下面还有其他子包。\r\n但是，Spring\r\nBoot要求main()方法所在的启动类必须放到根package下，命名不做要求\r\n依赖导入\r\n我们再观察pom.xml，它的内容如下\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- Maven项目对象模型(POM)文件，定义项目结构、依赖和构建配置 --&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;!-- 继承Spring Boot的基础配置，提供依赖管理和插件配置 --&gt;    &lt;!-- 这是第一步，所有Spring Boot项目都必须继承这个夫项目--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.5.0&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- 从Maven仓库查找父POM --&gt;    &lt;/parent&gt;        &lt;!-- 项目基本信息 --&gt;    &lt;groupId&gt;edu.software.ergoutree&lt;/groupId&gt; &lt;!-- 组织或项目的唯一标识符 --&gt;    &lt;artifactId&gt;SpringBootPritical&lt;/artifactId&gt; &lt;!-- 项目的唯一标识符 --&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 项目版本，SNAPSHOT表示开发版本 --&gt;    &lt;name&gt;SpringBootPritical&lt;/name&gt; &lt;!-- 项目名称(显示用) --&gt;    &lt;description&gt;SpringBootPritical&lt;/description&gt; &lt;!-- 项目描述 --&gt;    &lt;url/&gt; &lt;!-- 项目URL(可选) --&gt;        &lt;!-- 项目许可证信息(空标签表示未指定) --&gt;    &lt;licenses&gt;        &lt;license/&gt;    &lt;/licenses&gt;        &lt;!-- 项目开发者信息(空标签表示未指定) --&gt;    &lt;developers&gt;        &lt;developer/&gt;    &lt;/developers&gt;        &lt;!-- 版本控制系统信息(空标签表示未指定) --&gt;    &lt;scm&gt;        &lt;connection/&gt;        &lt;developerConnection/&gt;        &lt;tag/&gt;        &lt;url/&gt;    &lt;/scm&gt;        &lt;!-- 项目属性配置 --&gt;    &lt;properties&gt;        &lt;java.version&gt;21&lt;/java.version&gt; &lt;!-- 指定Java版本为21 --&gt;    &lt;/properties&gt;        &lt;!-- 项目依赖配置 --&gt;    &lt;dependencies&gt;        &lt;!--web开发的场景启动器，嵌入了 Tomcat--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-satrter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Spring Security测试依赖，仅用于测试环境 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--... 其他依赖 --&gt;    &lt;/dependencies&gt;        &lt;!-- Spring Boot应用打包插件，项目构建配置 --&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- Spring Boot Maven插件，用于打包和运行Spring Boot应用 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\r\n这其实 pom.xml 文件里面有几个 Spring Boot 开发的步骤\r\n创建项目，就是导入spring-boot-starter-parent继承\r\n使用Spring\r\nBoot时，强烈推荐从spring-boot-starter-parent继承，因为这样就可以引入Spring\r\nBoot的预置配置\r\n&lt;!-- pom.xml --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;3.5.0&lt;/version&gt;&lt;/parent&gt;\r\n\r\n统一依赖版本：内置了所有 Spring Boot\r\n依赖的版本号（称为 “BOM”，Bill of Materials），避免依赖冲突。\r\n简化配置：提供默认的插件配置（如编译版本、资源过滤等）。引入依赖时无需写version（除非需要覆盖默认版本）。\r\n\r\n紧接着，我们引入了其他依赖，可发现无需指定版本号，因为引入的\r\n&lt;parent&gt;\r\n内已经指定了，只有我们自己引入的某些第三方jar包需要指定版本号。\r\n导入场景\r\n就是导入各种场景启动器\r\n&lt;!--web开发的场景启动器，嵌入了 Tomcat--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-satrter-web&lt;/artifactId&gt;        &lt;/dependency&gt;\r\n打包\r\n&lt;!-- Spring Boot应用打包插件，项目构建配置 --&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- Spring Boot Maven插件，用于打包和运行Spring Boot应用 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;\r\n$ mvn clean package 把项目打成可执行的 jar 包\r\njava -jar 包名.jar 启动项目\r\n主程序启动类\r\npackage edu.software.ergoutree.springbootpritical;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;// Spring Boot 项目的主入口程序，@SpringBootApplication为其核心注解，标记为启动类@SpringBootApplicationpublic class SpringBootPriticalApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringBootPriticalApplication.class, args);    &#125;&#125;\r\n启动Spring\r\nBoot应用程序只需要一行代码加上一个注解@SpringBootApplication，该注解实际上又包含了：\r\n\r\n@SpringBootConfiguration\r\n\r\n@Configuration\r\n\r\n@EnableAutoConfiguration\r\n\r\n@AutoConfigurationPackage\r\n\r\n@ComponentScan\r\n\r\n这样一个注解就相当于启动了自动配置和自动扫描。\r\n配置文件的异同\r\nserver:  port: 8080  servlet:    context-path: /spring:  application:    name: springboot-demologging:  level:    com.example.demo: DEBUG  pattern:    console: &quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n&quot;\r\nspring.application.name=SpringBootPriticalserver.port=8080server.servlet.context-path=/logging.level.edu.software.ergoutree.springbootpritical: DEBUGlogging.pattern.console=&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n&quot;\r\n可见，YAML是一种层级格式，它和.properties很容易互相转换，它的优点是去掉了大量重复的前缀，并且更加易读。\r\n而在配置文件中，我们经常使用如下的格式对某个key进行配置：\r\nlogging:  level:    com.example.demo: DEBUG  pattern:    console: &quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; - %msg%n&quot;    # 控制台日志格式    spring:  datasource:    url: $&#123;DB_URL:jdbc:mysql://localhost:3306/app_db&#125;    username: $&#123;DB_USER:app_user&#125;    password: $&#123;DB_PASSWORD:app_pass&#125;\r\n$&#123;变量名:默认值&#125;语法的核心逻辑\r\n这种$&#123;DB_HOST:localhost&#125;意思是，首先从环境变量查找DB_HOST，如果环境变量定义了，那么使用环境变量的值，否则，使用默认值localhost。\r\n这种语法的执行逻辑如下：\r\n\r\n优先查找环境变量：Spring Boot\r\n会首先检查操作系统环境变量中是否存在DB_HOST\r\n其次查找系统属性：若环境变量不存在，会检查 Java\r\n系统属性（如通过-DDB_HOST=xxx设置）\r\n最后使用默认值：若前两者均不存在，则使用:,\r\n后的默认值localhost\r\n\r\n这使得我们在开发和部署时更加方便，因为开发时无需设定任何环境变量，直接使用默认值即本地数据库，而实际线上运行的时候，只需要传入环境变量即可，而且做到了配置与代码分离，避免敏感信息的直接显式暴露\r\nSpring Boot 对环境变量的解析机制\r\n\r\n变量解析顺序（优先级从高到低）：\r\n\r\n命令行参数（如--db.host=xxx）\r\n操作系统环境变量\r\napplication-&#123;profile&#125;.yml配置文件\r\napplication.yml配置文件\r\n代码中硬编码的默认值\r\n\r\n复杂变量场景\r\n\r\n多层级变量：$&#123;APP_CONFIG.db.host&#125;\r\n必选变量（无默认值）：$&#123;REQUIRED_VAR&#125;（若不存在则启动报错）\r\n组合变量：$&#123;DB_HOST&#125;:$&#123;DB_PORT&#125;\r\n\r\n\r\n业务部分，以Controller为例子\r\n实际上其他包也都是一回事，这里就拿 Controller 说了\r\n使用 REST API 的 Controller 如下\r\npackage edu.software.ergoutree.springbootpritical.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123;    // 处理请求，映射 HTTP GET 请求到根路径 /。例如：访问 http://localhost:8080/ 时触发此方法    @GetMapping(&quot;/&quot;)    public String home()&#123;        // 直接返回字符串 &quot;Hello Spring Boot!&quot;，自动作为响应体返回给客户端。        return &quot;Hello Spring Boot3!&quot;;    &#125;    // 映射动态路径，例如：/hello/John、/hello/World。    // &#123;name&#125; 是路径变量，通过 @PathVariable 绑定到方法参数。    // 问 http://localhost:8080/hello/Alice → 返回 Hello, Alice!。    @GetMapping(&quot;/hello/&#123;name&#125;&quot;)    public String hello(@PathVariable String name) &#123;        return &quot;Hello, &quot; + name + &quot;!&quot;;    &#125;&#125;\r\n测试\r\n在 test 文件夹下编写测试类就行，在这里会有一些特殊的注解\r\n启动\r\nSpring\r\nBoot自动启动了嵌入式Tomcat，当看到Started Application in xxx seconds时，Spring\r\nBoot应用启动成功。\r\n现在，我们在浏览器输入localhost:8080就可以直接访问页面。那么问题来了：\r\n前面我们定义的数据源、声明式事务、JdbcTemplate在哪创建的？怎么就可以直接注入到自己编写的UserService中呢？\r\n这些自动创建的Bean就是Spring Boot的特色：AutoConfiguration。\r\n当我们引入spring-boot-starter-jdbc时，启动时会自动扫描所有的XxxAutoConfiguration：\r\n\r\nDataSourceAutoConfiguration：自动创建一个DataSource，其中配置项从application.yml的spring.datasource读取；\r\nDataSourceTransactionManagerAutoConfiguration：自动创建了一个基于JDBC的事务管理器；\r\nJdbcTemplateAutoConfiguration：自动创建了一个JdbcTemplate。\r\n\r\n因此，我们自动得到了一个DataSource、一个DataSourceTransactionManager和一个JdbcTemplate。\r\n类似的，当我们引入spring-boot-starter-web时，自动创建了：\r\n\r\nServletWebServerFactoryAutoConfiguration：自动创建一个嵌入式Web服务器，默认是Tomcat；\r\nDispatcherServletAutoConfiguration：自动创建一个DispatcherServlet；\r\nHttpEncodingAutoConfiguration：自动创建一个CharacterEncodingFilter；\r\nWebMvcAutoConfiguration：自动创建若干与MVC相关的Bean。\r\n…\r\n\r\n引入第三方pebble-spring-boot-starter时，自动创建了：\r\n\r\nPebbleAutoConfiguration：自动创建了一个PebbleViewResolver。\r\n\r\nSpring\r\nBoot大量使用XxxAutoConfiguration来使得许多组件被自动化配置并创建，而这些创建过程又大量使用了Spring的Conditional功能。例如，我们观察JdbcTemplateAutoConfiguration，它的代码如下：\r\n@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)@ConditionalOnSingleCandidate(DataSource.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)@EnableConfigurationProperties(JdbcProperties.class)@Import(&#123; JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class &#125;)public class JdbcTemplateAutoConfiguration &#123;&#125;\r\n当满足条件：\r\n\r\n@ConditionalOnClass：在classpath中能找到DataSource和JdbcTemplate；\r\n@ConditionalOnSingleCandidate(DataSource.class)：在当前Bean的定义中能找到唯一的DataSource；\r\n\r\n该JdbcTemplateAutoConfiguration就会起作用。实际创建由导入的JdbcTemplateConfiguration完成：\r\n@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(JdbcOperations.class)class JdbcTemplateConfiguration &#123;    @Bean    @Primary    JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) &#123;        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        JdbcProperties.Template template = properties.getTemplate();        jdbcTemplate.setFetchSize(template.getFetchSize());        jdbcTemplate.setMaxRows(template.getMaxRows());        if (template.getQueryTimeout() != null) &#123;            jdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());        &#125;        return jdbcTemplate;    &#125;&#125;\r\n创建JdbcTemplate之前，要满足@ConditionalOnMissingBean(JdbcOperations.class)，即不存在JdbcOperations的Bean。\r\n可见，Spring\r\nBoot自动装配功能是通过自动扫描+条件装配实现的，这一套机制在默认情况下工作得很好，但是，如果我们要手动控制某个Bean的创建，就需要详细地了解Spring\r\nBoot自动创建的原理，很多时候还要跟踪XxxAutoConfiguration，以便设定条件使得某个Bean不会被自动创建。\r\n使用开发者工具\r\n在开发阶段，我们经常要修改代码，然后重启Spring\r\nBoot应用。经常手动停止再启动，比较麻烦。\r\nSpring\r\nBoot提供了一个开发者工具，可以监控classpath路径上的文件。只要源码或配置文件发生修改，Spring\r\nBoot应用可以自动重启。在开发阶段，这个功能比较有用。\r\n要使用这一开发者功能，我们只需添加如下依赖到pom.xml：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;\r\n然后，没有然后了。直接启动应用程序，然后试着修改源码，保存，观察日志输出，Spring\r\nBoot会自动重新加载。\r\n默认配置下，针对/static、/public和/templates目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。\r\n简单打包 Spring Boot\r\n普通的 Java 程序，使用\r\nmaven-shade-plugin就可以打包一个可执行的 jar 包\r\n在Spring Boot应用中，打包更加简单，当然如果你只是打 jar\r\n包，因为Spring\r\nBoot自带一个更简单的spring-boot-maven-plugin插件用来打包，我们只需要在pom.xml中加入以下配置\r\n&lt;project ...&gt;    ...    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\r\n无需任何配置，Spring\r\nBoot的这款插件会自动定位应用程序的入口Class，我们执行Maven的打包命令即可打包：\r\n$ mvn clean package\r\n打包后我们在target目录下可以看到两个jar文件：\r\n以springboot-exec-jar项目为例\r\n其中，springboot-exec-jar-1.0-SNAPSHOT.jar.original是Maven标准打包插件打的jar包，它只包含我们自己的Class，不包含依赖，而springboot-exec-jar-1.0-SNAPSHOT.jar是Spring\r\nBoot打包插件创建的包含依赖的jar，可以直接运行\r\n这样，部署一个Spring\r\nBoot应用就非常简单，无需预装任何服务器，只需要上传jar包即可。\r\n在打包的时候，因为打包后的Spring\r\nBoot应用不会被修改，因此，默认情况下，spring-boot-devtools这个依赖不会被打包进去。但是要注意，使用早期的Spring\r\nBoot版本时，需要配置一下才能排除spring-boot-devtools这个依赖\r\n特性小结\r\n\r\n简化整合\r\n导入相关的场景，就拥有了相关的功能，也就是场景启动器\r\nSpring Boot官方默认支持很多\r\nstarter，amqp，aop，jdbc，jpa什么的都有，都叫spring-boot-starter\r\n第三方还要各种场景启动器的提供，命名为\r\n*-spring-boot-starter\r\n简化开发\r\n简化配置\r\napplication.properties：集中式管理配置，只需要修改这个文件就行，而且配置基本都有默认值\r\n简化部署\r\n都嫩打包为可执行的 jar 包，linux 服务器上有 java\r\n环境就能运行\r\n简化运维\r\n修改配置（外部放一个\r\napplication.properties），监控应用，健康检查\r\n\r\nSpring Boot Initializer\r\nSpring Boot 创建项目的初始化向导，简化初始化项目\r\n\r\n\r\nimage-20250525141943983\r\n\r\n下面就是选场景，选依赖\r\n\r\n\r\nimage-20250525142008987\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架"]},{"title":"Spring Boot part3-Spring Boot的自动配置机制","url":"/posts/422.html","content":"自动配置\r\n学习SSM整合时，需要配置 Tomcat ，配置 Spring\r\nMVC，以及配置如何扫描包，配置字符过滤器，配置视图解析器，文件上传等。非常麻烦。而在\r\nSpring Boot 中，存在自动配置 机制，提高开发效率。\r\n现在，自动配置会自动配置好这些组件，容器中有什么组件，就具有什么功能\r\n验证\r\npublic static void main(String[] args) &#123;    //java10：局部变量类型的自动推断    var ioc = SpringApplication.run(MainApplication.class, args);    //1、获取容器中所有组件的名字    String[] names = ioc.getBeanDefinitionNames();    //2、挨个遍历：    // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartReso    // springboot把以前配置的核心组件现在都给我们自动配置好了。    for (String name : names) &#123;        System.out.println(name);    &#125;&#125;\r\n导入场景后，容器中就会自动配置好这个场景的核心组件\r\n自动配置的触发原理\r\n自动配置通过 @EnableAutoConfiguration\r\n注解触发，这个注解通常包含在 @SpringBootApplication\r\n注解中。当 Spring Boot 应用启动时，@EnableAutoConfiguration\r\n注解会执行以下操作：\r\n\r\n扫描类路径下的 META-INF/spring.factories 文件\r\nSpring Boot 在启动时会扫描类路径下所有的\r\nMETA-INF/spring.factories\r\n文件。这些文件中定义了一系列的自动配置类，它们以键值对的形式存在，其中键为\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration，值为多个自动配置类的全限定名。例如：\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\r\n加载配置类\r\nSpring Boot 会根据 spring.factories\r\n文件中定义的自动配置类，将这些类加载到 Spring\r\n容器中。这些自动配置类使用了 Spring 的 @Configuration\r\n注解，本质上就是普通的 Java 配置类。\r\n根据条件注解决定是否生效\r\n自动配置类中会使用大量的条件注解，如\r\n@ConditionalOnClass、@ConditionalOnMissingBean、@ConditionalOnProperty\r\n等，来决定该配置类是否生效。例如，@ConditionalOnClass\r\n注解会检查类路径中是否存在指定的类，如果存在则该配置类生效；@ConditionalOnMissingBean\r\n注解会检查 Spring 容器中是否已经存在指定类型的\r\nBean，如果不存在则该配置类生效。\r\n\r\n@SpringBootConfiguration\r\n查看该注解的定义，发现其上标有@Configuration，并且里面有一个唯一的属性即proxyBeanMethods。这说明被@SpringBootConfiguration修饰的类也是一个配置类。\r\n@ComponentScan\r\n指定扫描哪些Spring注解。\r\n@EnableAutoConfiguration\r\n这是SpringBoot自动配置的入口\r\n自动配置的工作流程\r\n\r\n\r\nimage-20250525182907852\r\n\r\n流程:\r\n\r\n导入 starter-web：导入了 web 开发场景\r\n\r\n场景启动器导入了相关场景的所有依赖：starter-json、starter-tomcat、springmvc\r\n每个场景启动器都引入了一个\r\nspring - boot - starter，核心场景启动器。\r\n核心场景启动器引入了 spring - boot - autoconfigure\r\n包。\r\nspring - boot - autoconfigure\r\n里面囊括了所有场景的所有配置。\r\n只要这个包下的所有类都能生效，那么相当于 Spring Boot\r\n官方写好的整合功能就能生效了。\r\nSpring Boot 默认扫描不到\r\nspring - boot - autoconfigure\r\n下写好的所有配置类。(这些配置类给我们做了整合操作\r\n\r\n主程序：@SpringBootApplication\r\n\r\n@SpringBootApplication 由三个注解构成\r\n@SpringBootConfiguration\r\n@EnableAutoConfiguration @ComponentScan\r\nSpring Boot\r\n默认只能扫描自己主程序及其所在的下面的子包，扫描不到spring-boot-autoconfigure包中官方写好的配置类\r\n@EnableAutoConfiguration:Spring Boot 开启自动配置的核心\r\n\r\n是由@Import(AutoConfigurationImportSelector.class)提供功能：批量给容器中导入组件\r\nSpring Boot启动会默认加载 142 个配置类\r\n这 142 个配置类来自于\r\nspring-boot-autoconfigure下META-INF/spring/org.springframework.boot.autoconfigurate.AutoConfiguration.imports文件指定的\r\n项目启动的时候利用 @Import 批量导入组件机制，把\r\nautoconfigure 包下的142个\r\nxxxAutoConfiguration类导入进来（自动配置类）\r\n虽然导入了 142 个配置类，但是并不是全部生效\r\n\r\n按需生效\r\n\r\n并不是这142个自动配置类都能生效\r\n每一个自动配置类，都有条件注解@ConditionalOnXxx，条件成立才能生效\r\n\r\n\r\nxxxAutoConfiguration类导入进来（自动配置类）\r\n\r\n给容器中使用@Bean放一堆组件\r\n每个自动配置类都可能有这个注解@EnableConfigurationProperties(xxxProperties.class)，用来把配置文件中配的指定前缀的属性值封装到\r\nxxxProperties 属性类中\r\n以 Tomcat 为例子，把服务器所有配置都是以 server\r\n开头的，配置都封装到了属性类中\r\n给容器中放的所有组件的一些核心参数，都来自于\r\nxxxProperties，\r\nxxxProperties都是和配置文件绑定\r\n只需要改配置文件的值，核心组件的底层参数都能修改，这样就实现了导入了\r\nstarter，所有的配置都能生效\r\n\r\n写业务，全程无需关心各种整合（底层这些整合写好了，而且也生效了）\r\n\r\n核心流程：\r\n\r\n导入 starter，就会导入 autoconfigure 包。\r\nautoconfigure 包里面有一个文件\r\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，里面指定的所有启动要加载的自动配置类。\r\n@EnableAutoConfiguration\r\n会自动的把上面文件里面写的所有自动配置类都导入进来。xxxAutoConfiguration\r\n是有条件注解进行按需加载\r\nxxxAutoConfiguration\r\n给容器中导入一堆组件，组件都是从xxxProperties中提取属性值\r\nxxxProperties 又是和配置文件进行了绑定\r\n\r\n效果：导入 starter、修改配置文件，就能修改底层行为\r\n容器功能\r\n在深入了解 Spring Boot 的自动配置功能之前，我们需要先了解 Spring Boot\r\n的容器管理功能。在学习 Spring Framework 时，我们知道 Spring Framework\r\n有两大核心机制：IOC（控制反转）和 AOP（面向切面编程）。\r\nIOC\r\n容器的主要作用是帮助我们存放对象，并管理对象的创建、装配和销毁过程。这样，原本由程序手动完成的对象管理工作就交给了\r\nSpring Framework 来处理。在 Spring Boot\r\n中，我们学习的核心在于如何将对象注册到 Spring 容器中，以及如何从 Spring\r\n容器中获取对象。\r\nSpring Boot 的默认包扫描路径\r\n在Spring Boot 的自动配置中，我们不需要像Spring MVC\r\n中一定要配置扫描包 。Spring Boot\r\n有默认的扫描包结构。这使得我们在没有指定任何包扫描路径的情况下，注册到容器中的对象也能被正常获取。这是因为\r\nSpring Boot 默认的包扫描路径下的目标对象，都会被注册进容器中。\r\n默认的扫描路径是 Main Application Class\r\n所在的目录以及子目录。\r\n@SpringBootApplication标注的类就是主程序类，Spring Boot\r\n只会扫描主程序所在的包及其下面的子包\r\n配置默认值\r\n\r\n配置文件所有配置项是和某个类的对象值是一一对应的\r\n绑定了配置文件中的每一项值的类：配置属性类\r\n比如 ServerProperties绑定了所有 Tomcat\r\n配置值相关的所有配置\r\n\r\n如果需要改变默认的扫描路径，可以通过在启动类上配置\r\nscanBasePackages 属性来实现：\r\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = &quot;com.example.demo.service,com.example.demo.repository&quot;)public class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\r\n该属性是一个字符串数组，可以指定多个包路径，用逗号隔开。\r\n实际上，scanBasePackages 属性和\r\n@ComponentScan 注解的 basePackages\r\n属性是绑定的，因此使用 @ComponentScan\r\n注解直接指定包扫描的路径也能达到同样的效果：\r\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@ComponentScan(basePackages = &quot;com.example.demo.service,com.example.demo.repository&quot;)@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\r\n自动配置遵循的原则\r\n自动配置遵守按需加载原则：也就是说，引入了哪个场景\r\nstarter启动器 就会加载该场景关联，的 jar 包，没有引入的\r\nstarter 则不会加载其关联 jar 。\r\nSpringBoot 所有的自动配置功能都在\r\nspring-boot-autoconfigure包里面；\r\n在Spring Boot 中的自动配置包，一般是 XXxAutoConfiguration.java 对应\r\nXXxProperties.java\r\n\r\n\r\nimg\r\n\r\n组件详解\r\n@SpringBoorConfiguration\r\n@SpringBootConfiguration 是 Spring Boot 中的一个类级注解\r\n，用于指示标注的类提供应用程序配置。被它标注的类，意味着其中可以包含\r\n@Bean 定义方法，Spring 容器会处理该配置类，进而实例化和配置\r\nbean。\r\n它本质上是 Spring 标准 @Configuration\r\n注解的替代方法，功能基本相同。二者唯一区别在于，@SpringBootConfiguration\r\n允许自动找到配置\r\n通常开发中更常用的 @SpringBootApplication\r\n注解，实际上自动继承了 @SpringBootConfiguration\r\n注解。@SpringBootApplication 是一个组合注解，整合了\r\n@SpringBootConfiguration、@EnableAutoConfiguration\r\n和 @ComponentScan 等功能。所以一般项目中使用\r\n@SpringBootApplication 标注主应用类，就无需再单独使用\r\n@SpringBootConfiguration 。并且建议一个应用程序中仅使用一个\r\n@SpringBootConfiguration 或\r\n@SpringBootApplication 批注。\r\n@Configuration和@Bean\r\n@Configuration注解表示这个类是个配置类，@Bean注解往容器中注册实例。\r\n@Configuration把 Spring Framework 中的 xml 改成了 java\r\nconfig\r\n配置类，配置类本身也是容器中的组件，组件默认都是单实例的，可以用@scope注解改，跟用&lt;scope&gt;标签一样。\r\n而 @Bean注解替代了以前的 bean\r\n标签，组件在容器中的名字默认就是方法名，可以修改\r\n@Bean注解的值\r\nimport com.codeliu.entity.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MyConfig &#123;    @Bean    public User user() &#123;        User user = new User(&quot;ErgouTree&quot;, 5555666);        return user;    &#125;&#125;\r\n然后在启动类中进行测试，可以发现容器中的实例都是单例的，即多次拿到的都是同一个对象。\r\n@SpringBootApplicationpublic class DockerTestApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext run = SpringApplication.run(DockerTestApplication.class, args);        User user1 = run.getBean(&quot;user&quot;, User.class);        User user2 = run.getBean(User.class);        // true        System.out.println(user1 == user2);    &#125;&#125;\r\n@Configuration注解中的proxyBeanMethods属性即代理bean的方法，决定是否是单例模式，默认为\r\ntrue 。Full模式（proxyBeanMethods = true）和\r\nLite（proxyBeanMethods =  false）模式，Full 模式保证每个\r\n@Bean\r\n方法被调用多少次返回的组件都是单实例的，而 Lite 模式每个 @Bean\r\n方法被调用多少次返回的组件都是新创建的。组件依赖必须使用 Full\r\n模式默认，其他默认 Lite 模式\r\n@Component、@Controller、@Service、@Repository\r\n不多说了，四大护法，使用在pojo、mapper、service、controller类上的注解。\r\n@Import\r\n第三方的任意类，都可以导入到你的配置类中作为组件，给容器中放指定类型的组件，名字默认全类名\r\n该注解定义如下，只有一个value属性，你可以传入一个Class数组，在启动过程中，会自动帮你把类注册进容器。\r\n@Configuration@Import(&#123;User.class, DBHelper.class&#125;)public class MyConfig &#123;&#125;\r\n@SpringBootApplicationpublic class DockerTestApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext run = SpringApplication.run(DockerTestApplication.class, args);        User user1 = run.getBean(User.class);        User user2 = run.getBean(User.class);        // true        System.out.println(user1 == user2);        User user = run.getBean(User.class);        // com.codeliu.entity.User@63411512        System.out.println(user);        DBHelper dbHelper = run.getBean(DBHelper.class);        // ch.qos.logback.core.db.DBHelper@35cd68d4        System.out.println(dbHelper);    &#125;&#125;\r\n可以看到，默认组件的名字是全类名。\r\n@Conditional条件装配\r\n意思就是满足@Conditional指定的条件，才进行组件注入。\r\n总之就是@ConditionalOnXxx，指定的条件成立，才触发指定行为\r\n条件注解详解\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解名称\r\n触发条件\r\n典型应用场景\r\n\r\n\r\n\r\n\r\n@ConditionalOnClass\r\n类路径存在指定类时生效\r\n自动配置数据源\r\n\r\n\r\n@ConditionalOnMissingBean\r\n容器中不存在指定Bean时生效\r\n覆盖默认配置\r\n\r\n\r\n@ConditionalOnProperty\r\n配置文件中存在指定属性时生效\r\n功能开关控制\r\n\r\n\r\n@ConditionalOnWebApplication\r\n当前是Web应用时生效\r\nWeb相关配置\r\n\r\n\r\n@ConditionalOnResource\r\n存在指定资源文件时生效\r\n特定配置文件存在时加载\r\n\r\n\r\n\r\n属性绑定类注解@ConfigurationProperties和@EnableConfigurationProperties\r\n@ConfigurationProperties\r\n声明组件的属性和配置文件中的哪些前缀开始进行绑定\r\n在 Spring Boot 里，@ConfigurationProperties\r\n能把外部配置（像application.properties 或\r\napplication.yml 里的属性 ）绑定到 Java\r\n对象上，让配置管理更简便，配置变更更灵活动态。\r\n这两个组件都是将容器中任意组件的属性值和配置文件的配置项进行绑定\r\n\r\n给容器中注册组件\r\n（@Component，@Bean）\r\n使用@ConfigurationProperties\r\n声明组件和配置文件中的哪些配置项进行绑定\r\n可以绑定到类上，可以绑定到方法上\r\n\r\n举例\r\n\r\n定义配置类：创建一个类，用\r\n@ConfigurationProperties 注解标注它，并指定\r\nprefix\r\n属性，该属性值是配置文件中相关属性的前缀。类中定义字段来对应配置属性，同时需提供这些字段对应的\r\ngetter 和 setter 方法 。比如：\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;myapp&quot;)public class MyAppProperties &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\r\n@ConfigurationProperties(prefix = \"myapp\")\r\n表示会找配置文件中以 myapp 开头的属性，像\r\nmyapp.name 会绑定到 name 字段\r\n，myapp.age 会绑定到 age 字段。同时通过\r\n@Component 注解将该类注册为 Spring\r\n容器中的组件，这样容器启动时就能处理这个配置类。\r\n配置文件配置：在\r\napplication.properties 或 application.yml\r\n里写对应属性，例如在 application.properties 中指定其中的\r\nname 和 age 字段\r\nmyapp.name=testmyapp.age=18\r\n使用配置：在其他组件中，可通过依赖注入使用这个配置类，获取配置属性值。\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class MyService &#123;    private final MyAppProperties myAppProperties;    @Autowired    public MyService(MyAppProperties myAppProperties) &#123;        this.myAppProperties = myAppProperties;    &#125;    public void doSomething() &#123;        System.out.println(&quot;Name: &quot; + myAppProperties.getName() + &quot;, Age: &quot; + myAppProperties.getAge());    &#125;&#125;\r\n\r\n所以说，@ConfigurationProperties就是将配置文件（如\r\napplication.properties）中的属性值，绑定到 Java\r\n类的字段上。在类上标注\r\n@ConfigurationProperties(prefix = \"xxx\")，指定配置文件中的属性前缀。但是注意，类需提供字段的\r\ngetter/setter 方法，并且需将该类注册为 Bean。\r\n@EnableConfigurationProperties\r\n这个一般是用于导入第三方写好的组件，进行属性绑定，即使第三方导入了并且标注了\r\n@Component 和\r\n@ConfigurationProperties注解，也不行，因为默认只扫描自己主程序所在的包。\r\n用于显式开启对 @ConfigurationProperties\r\n注解类的支持。告知 Spring Boot 框架，项目里有用\r\n@ConfigurationProperties\r\n注解的类，要自动加载配置文件属性并绑定到这些类的字段上\r\n，还能自动注册这些类为 Spring 容器中的 Bean。从 Spring Boot 2.2\r\n起，若配置属性类已用 @Component\r\n等注解注册为组件，可不显式用此注解，Spring Boot 会自动配置 。\r\n使用方式：在主类或者配置类上使用该注解，并在\r\nvalue 属性指定一个或多个\r\n@ConfigurationProperties 注解的类。示例如下：\r\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;@SpringBootApplication// 开启 MyAppProperties 组件中的属性绑定// 默认会把这个组件自己放到容器中@EnableConfigurationProperties(MyAppProperties.class)public class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\r\n这里\r\n@EnableConfigurationProperties(MyAppProperties.class) 让\r\nSpring Boot 把配置文件属性绑定到 MyAppProperties\r\n类实例上，并将其实例注册为 Spring 容器中的 Bean。\r\n所以，@EnableConfigurationProperties的功能就是启用\r\n@ConfigurationProperties 功能，在主类或配置类上标注\r\n@EnableConfigurationProperties(MyConfig.class)，将指定类注册为\r\nBean。若配置类已用 @Component\r\n标注，则无需显式使用此注解\r\nSpring Boot\r\n自动配置都配置了什么\r\n按需加载自动配置\r\n\r\n导入场景\r\n场景启动器除了会导入相关功能依赖，导入一个 spring-boot-starter\r\n，是所有 starter 的 starter\r\n这里面还导入了一个spring-boot-autoconfigure包，都是各种场景的自动配置AutoConfig类，虽然里面有全场景的，但是是导入哪个场景就启用哪个自动配置\r\n\r\n\r\nimage-20250525162137612\r\n\r\n\r\n当我们导入某个场景启动器，就会触发\r\nspring-boot-autoconfigure的自动配置生效，容器中就会具有相关场景的功能\r\n自动配置 Tomcat\r\nSpring Boot 默认会自动配置嵌入式的 Tomcat 服务器。当我们引入\r\nspring-boot-starter-web 依赖时，Spring Boot\r\n会自动检测到并为我们配置好 Tomcat 服务器。我们无需手动配置 Tomcat\r\n的启动参数、端口号等信息，Spring Boot 会使用默认的配置启动 Tomcat\r\n服务器。如果需要修改 Tomcat 的配置，例如修改端口号，可以在\r\napplication.properties 或 application.yml\r\n文件中进行配置：server.port=8081\r\n\r\n\r\nimg\r\n\r\n自动配置了 Spring MVC\r\nSpring Boot 会自动配置 Spring MVC 的核心组件，如\r\nDispatcherServlet、HandlerMapping、ViewResolver\r\n等。它会根据类路径中的依赖和配置文件中的信息，自动配置合适的视图解析器、消息转换器等。例如，当我们引入\r\nspring-boot-starter-thymeleaf 依赖时，Spring Boot\r\n会自动配置 Thymeleaf 视图解析器，让我们可以方便地使用 Thymeleaf\r\n模板引擎进行视图渲染。\r\n\r\n\r\nimg\r\n\r\n自动配置 Web 常用功能\r\nSpring Boot 还会自动配置 Web\r\n开发中常用的功能，如字符过滤器、静态资源映射等。\r\n例如，它会自动配置一个字符编码过滤器，确保请求和响应的字符编码一致。默认情况下，字符编码为\r\nUTF-8。我们可以通过配置文件修改字符编码：\r\nspring.http.encoding.charset=UTF-8spring.http.encoding.enabled=truespring.http.encoding.force=true\r\n我们可以通过 Debug 的方式，在 ioc 打上断点，从而查看 ioc 容器中有哪些\r\nBean 对象被创建了。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n自定义自动配置\r\n自定义自动配置过程\r\n虽然 Spring Boot\r\n的自动配置功能非常强大，但在某些情况下，我们可能需要自定义自动配置。自定义自动配置的步骤如下：\r\n\r\n创建自动配置类：创建一个带有\r\n@Configuration 注解的 Java 类，作为自动配置类。\r\n@Configuration@ConditionalOnClass(MyService.class)@EnableConfigurationProperties(MyServiceProperties.class)public class MyServiceAutoConfiguration &#123;    @Bean    @ConditionalOnMissingBean    public MyService myService(MyServiceProperties properties) &#123;        return new MyService(properties.getPrefix());    &#125;&#125;\r\n创建 META-INF/spring.factories\r\n文件：在 src/main/resources 目录下创建\r\nMETA-INF/spring.factories\r\n文件，并在文件中指定自动配置类的全限定名：\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.demo.MyAutoConfiguration\r\n定义配置：为了让自动配置更加灵活，可以在自动配置类中使用条件注解，根据不同的条件决定是否生效。\r\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnClass(MyService.class)public class MyAutoConfiguration &#123;    @Bean    public MyService myService() &#123;        return new MyService();    &#125;&#125;\r\n\r\n调试自动配置\r\n我们可以通过 Debug 的方式，在 IOC\r\n容器初始化的过程中打上断点，从而查看 IOC 容器中有哪些 Bean\r\n对象被创建了。此外，Spring Boot 还提供了 --debug\r\n启动参数，当我们在启动应用时添加该参数，Spring Boot\r\n会输出详细的自动配置报告，帮助我们了解自动配置的过程和结果。例如，在命令行中启动应用时添加\r\n--debug 参数：\r\njava -jar myapp.jar --debug\r\n查看生效配置\r\n# 启用自动配置报告debug=true\r\nSpring\r\nFramework原生配置文件引入\r\n@ImportResource注解可以导入 Spring\r\n的配置文件，让配置文件里的内容生效。因为有些项目 bean 定义在 xml\r\n文件里，但你必须知道 xml 文件的路径，这样在项目启动的时候 Spring\r\n才会加载配置文件。那对于 Spring Boot 项目来说，所有的 bean 都是通过 java\r\n配置实现，xml 没有用武之地了吗？\r\n@Configuration搭配@ImportResource可以实现xml配置的装载。\r\nimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(&quot;classpath:beans.xml&quot;)public class MyConfig &#123;&#125;\r\nSpring Boot 中的\r\napplication.properties\r\n自定义\r\napplication.properties 中的配置\r\nSpringBoot 项目最重要也是最核心的配置文件就是\r\napplication.properties，所有的框架配置都可以在这个配置文件中说明\r\n在Spring Boot中各种配置都有默认，当然可以自定义\r\n\r\n特别注意：该文件名必须是\r\napplication.properties，后缀也不可以修改。强烈建议将其放到\r\n类的根路径下(也就是resources 目录下 )\r\n其次是，注意：在.properties\r\n后缀的配置文件，当中编写，不要有空格，尽量不要有空格。\r\n\r\n在 Spring Boot 里，我们可以借助 .properties\r\n文件进行自定义配置，并且利用 @Value(\"$&#123;&#125;\")\r\n注解来获取这些配置的属性值。这样做能让我们更灵活地管理应用的配置信息，而不需要将这些信息硬编码在代码里。\r\n在需要使用这些配置信息的 Java 类里，我们可以通过 @Value\r\n注解来注入配置属性值。下面是一个示例\r\n# 自定义数据库连接信息custom.db.url=jdbc:mysql://localhost:3306/mydbcustom.db.username=rootcustom.db.password=123456# 自定义应用名称custom.app.name=MySpringBootApp\r\nimport org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class CustomConfig &#123;    // 使用 @Value 注解获取 custom.db.url 的值    @Value(&quot;$&#123;custom.db.url&#125;&quot;)    private String dbUrl;    // 使用 @Value 注解获取 custom.db.username 的值    @Value(&quot;$&#123;custom.db.username&#125;&quot;)    private String dbUsername;    // 使用 @Value 注解获取 custom.db.password 的值    @Value(&quot;$&#123;custom.db.password&#125;&quot;)    private String dbPassword;    // 使用 @Value 注解获取 custom.app.name 的值    @Value(&quot;$&#123;custom.app.name&#125;&quot;)    private String appName;    // Getter 方法，用于获取数据库连接 URL    public String getDbUrl() &#123;        return dbUrl;    &#125;    // Getter 方法，用于获取数据库用户名    public String getDbUsername() &#123;        return dbUsername;    &#125;    // Getter 方法，用于获取数据库密码    public String getDbPassword() &#123;        return dbPassword;    &#125;    // Getter 方法，用于获取应用名称    public String getAppName() &#123;        return appName;    &#125;&#125;\r\n我们可以在服务类或者控制器里注入 CustomConfig\r\n类的实例，然后使用其中的配置信息。示例如下：\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ConfigController &#123;    // 注入 CustomConfig 类的实例    @Autowired    private CustomConfig customConfig;    // 处理 GET 请求，返回应用名称    @GetMapping(&quot;/app-name&quot;)    public String getAppName() &#123;        return customConfig.getAppName();    &#125;    // 处理 GET 请求，返回数据库连接信息    @GetMapping(&quot;/db-info&quot;)    public String getDbInfo() &#123;        return &quot;DB URL: &quot; + customConfig.getDbUrl() +                &quot;, Username: &quot; + customConfig.getDbUsername() +                &quot;, Password: &quot; + customConfig.getDbPassword();    &#125;&#125;\r\n\r\n默认值设置：如果 .properties\r\n文件中没有定义某个属性，而我们又使用了 @Value\r\n注解去获取该属性值，应用启动时会抛出异常。为了避免这种情况，我们可以给\r\n@Value 注解设置默认值，示例如下：\r\n@Value(&quot;$&#123;custom.db.port:3306&#125;&quot;)private int dbPort;\r\n上述代码中，如果 custom.db.port 属性没有在\r\n.properties 文件中定义，dbPort 会被赋予默认值\r\n3306。\r\n\r\n配置文件的优先级\r\nSpring Boot 支持多种配置文件，如\r\napplication.properties、application.yml\r\n以及不同环境的配置文件（如\r\napplication-dev.properties、application-prod.properties）。这些配置文件有不同的优先级，需要注意它们之间的覆盖关系。\r\nSpring\r\nBoot 中在哪里配置读取 application.properties 配置文件\r\n打开 ConfigFileApplicationListener.java , 看一下源码\r\n\r\n\r\nimg\r\n\r\n// 指明: application.properties 可以存放的位置在哪里，Spring Boot 可以成功读取到 private static final String DEFAULT_SEARCH_LOCATIONS = &quot;classpath:/,classpath:/config/,file:./,file:./config/*/,file:./config/&quot;;// 指明: 配置类，要是为：application，  private static final String DEFAULT_NAMES = &quot;application&quot;;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","Maven"]},{"title":"Spring Boot part9-路径匹配与内容协商","url":"/posts/60585.html","content":"路径匹配\r\n路径匹配概述\r\n在 Spring 框架（这里聚焦于 Spring5.3\r\n及后续版本涉及的请求路径匹配相关内容\r\n）里，请求路径匹配是很关键的部分，是处理 Web 请求时确定 URL\r\n路径与控制器方法映射关系的核心机制。\r\n路径匹配是指框架如何将传入的 HTTP 请求 URL\r\n映射到对应的控制器方法上。例如，当用户访问 /users/123\r\n时，框架需要决定这个请求应该由哪个 @GetMapping 或\r\n@RequestMapping 注解的方法来处理。\r\n在 Spring Framework 5.3 及 Spring Boot 2.4\r\n之后，引入了一种新的路径匹配机制，这一变化在 Spring Boot 3\r\n中得到了保留和进一步的应用。这个新机制主要是通过 PathPattern\r\n代替了传统的 AntPathMatcher。\r\nAntPathMatcher 是基于 Ant 风格的路径匹配，而 PathPattern\r\n则是一个更高效、更精确的路径匹配方式，它是通过 PathPatternParser\r\n解析得到的。\r\n路径匹配两大策略\r\nSpring5.3 之后加入了更多的请求路径匹配的实现策略：\r\n以前只支持 AntPathMatcher 策略，现在提供了 PathPatternParser\r\n策略。并且可以让我们指定到底使用那种策略。\r\nSpring Boot 默认使用新版的路径匹配器，也就是 PathPatternParser\r\n，性能高，但是 ** 不能写在中间\r\n使用 spring.mvc.pathmath.macthing-strategy\r\n改变匹配策略\r\n具体策略说明\r\n\r\nAntPathMatcher：是 Spring\r\n中传统的路径匹配策略，基于 Ant 风格的路径模式语法，在之前的 Spring\r\n版本中广泛使用，很多开发者对其规则比较熟悉，用于处理各种 Web\r\n请求路径与配置的映射关系，像在 Spring MVC\r\n里配置请求映射（@RequestMapping\r\n等注解配合路径规则）时，常基于它工作 。\r\nPathPatternParser：Spring5.3\r\n之后新增的策略，它在一些场景下可能有更好的性能表现或者更灵活的特性，和\r\nAnt\r\n风格路径用法有一定关联但也有自身特点，也用于解析请求路径，确定是否匹配预设的路径模式，辅助完成请求的路由等操作\r\n。开发者可以根据项目实际需求，比如对路径匹配性能、规则灵活度等方面的要求，来指定使用哪种策略。\r\n\r\nAnt 风格路径\r\nAntPathMatcher 是 Spring 框架中一个基于 Ant\r\n风格模式的路径匹配器，它支持使用 ?、* 和\r\n** 等通配符进行匹配。\r\nAnt 风格的路径模式语法具有以下规则：\r\n\r\n*（星号）\r\n\r\n作用是匹配任意数量的字符，但不包含目录分隔符（/\r\n）。\r\n比如*.html\r\n，就是说不管前面的文件名是什么（像a.html、abc.html\r\n等），只要是以.html\r\n为后缀的文件路径，都能匹配上。常用于匹配同一层级下符合某种后缀特征的文件或路径片段。\r\n\r\n?（问号）\r\n\r\n代表匹配任意一个字符，同样不跨越目录分隔符。\r\n例如有路径a?b ，那么aab、acb\r\n等单字符差异的路径能匹配，而aabb （多了一个字符\r\n）就匹配不上。可以用于精确控制路径中某一位字符的不确定性场景。\r\n\r\n**（两个星号）\r\n\r\n强大之处在于能匹配任意数量的目录，包括多层嵌套的目录结构。\r\n像folder2/**/*.jsp ，不管folder2\r\n下面有多少级子目录，只要最终文件是.jsp\r\n后缀，就会被匹配到，比如folder2/a/b/c.jsp\r\n、folder2/d.jsp\r\n等情况都满足，在处理多层目录下的资源匹配时非常好用。\r\n\r\n&#123;&#125;（花括号）\r\n\r\n用于定义命名的模式占位符，路径变量，这在 RESTful\r\n风格的路径中很常用。\r\n比如/&#123;type&#125;/id&#125;.html ，这里的&#123;type&#125; 和\r\n&#123;id&#125;\r\n就是占位符，实际请求路径可能是/user/123.html\r\n，此时type 就对应user ，id\r\n对应123 ，在 Spring MVC\r\n中，这些占位符的值可以被提取出来，作为方法参数使用（通过@PathVariable\r\n注解 ），方便进行动态的路径参数处理。\r\n\r\n[]（方括号）\r\n\r\n用来表示字符集合，限定匹配的字符范围。\r\n如[a - z] 就表示只能匹配小写字母 a 到 z\r\n中的一个字符，若路径规则是[a - z]bc\r\n，那么abc、bbc\r\n等符合字符范围的能匹配，而1bc （数字不在集合内\r\n）、Abc （大写字母不在集合内\r\n）就匹配失败，可用于对路径中特定位置字符进行精确范围限制的场景，比如某些有特定字符规范的编号路径等\r\n。\r\n\r\n\r\n注意：Ant 风格的路径模式语法中的特殊字符需要转义\r\n转义说明\r\n在 Ant 风格路径模式语法里，特殊字符（像*、?\r\n等本身具有特殊匹配含义的字符\r\n）如果是作为普通字符出现在路径中（比如路径里真的有一个*\r\n作为文件名的一部分\r\n），就需要进行转义，一般是通过在特殊字符前加反斜杠（\\\r\n）等方式，让框架把它们当作普通字符对待，而不是执行匹配规则，否则框架会按照匹配规则去解析，导致路径匹配结果不符合预期\r\n。\r\n@GetMapping(&quot;/files/\\\\*.txt&quot;)  // 匹配字面量 /files/*.txtpublic String handleFile() &#123;    return &quot;file&quot;;&#125;\r\nPathPatternParser 风格路径\r\nPathPatternParser: 一个新的路径解析器，用于解析路径模式字符串，创建\r\nPathPattern\r\n对象。它引入了更严格的语法规则，并且设计了更高效的匹配算法。\r\nPathPattern: 由 PathPatternParser\r\n解析路径模式字符串得到的对象，代表了一种更加精确和高效的路径匹配方式。\r\n特点:\r\n\r\n性能: 相比 AntPathMatcher，PathPattern 提供了更高的性能。这是因为\r\nPathPattern 在匹配过程中采用了更加高效的算法，在 jmh 基准测试下，有 6~8\r\n倍吞吐量提升，降低 30%~40%空间分配率。\r\n精确性: PathPattern 的语法规则更严格，能够提供更精确的匹配结果。\r\n\r\n路径变量语法更严格，必须明确指定变量名：/&#123;name&#125;\r\n\r\n使用场景: 在 Spring Framework 5.3 及之后的版本中，默认使用\r\nPathPattern 进行路径匹配。如果你的应用是基于这些版本的 Spring Boot\r\n构建的，那么在处理路径匹配时，你将会默认使用 PathPattern。\r\n对 ** 通配符的使用有限制（不能出现在路径中间）\r\n\r\n有效：/resources/**\r\n无效：/resources/**/file\r\n\r\n\r\n路径匹配示例\r\n控制器方法映射\r\n@RestController@RequestMapping(&quot;/api&quot;)public class MyController &#123;        // 匹配 /api/users/123    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        // ...    &#125;        // 匹配 /api/files/2023/任何内容    @GetMapping(&quot;/files/2023/**&quot;)    public List&lt;File&gt; get2023Files() &#123;        // ...    &#125;        // 匹配 /api/products/abc123    @GetMapping(&quot;/products/&#123;code:[a-z]+\\\\d+&#125;&quot;)    public Product getProduct(@PathVariable String code) &#123;        // ...    &#125;&#125;\r\n解释一下/products/&#123;code:[a-z]+\\\\d+&#125;这段正则是如何匹配/api/products/abc123的\r\n\r\n&#123;code:[a-z]+\\\\d+&#125; 这种形式定义了一个名为\r\ncode 的路径变量，并且对它的值设定了正则表达式约束。\r\n其中，其中 [a-z]+\r\n表示这个部分必须由至少一个小写字母组成，\\\\d+\r\n表示这部分必须由至少一个数字组成\r\n所以说，整个正则表达式 [a-z]+\\\\d+\r\n的意思是，code\r\n的值要先有至少一个小写字母，接着有至少一个数字，而且字母和数字之间不能有其他字符，所以，/api/products/a1\r\n也能匹配，而 /api/products/123abc 就无法匹配\r\n\r\n静态资源匹配\r\n# 匹配所有静态html文件spring.mvc.static-path-pattern=/*.html\r\n拦截器路径配置\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;        @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new MyInterceptor())                .addPathPatterns(&quot;/admin/**&quot;)  // 拦截/admin下的所有路径                .excludePathPatterns(&quot;/admin/login&quot;);  // 排除登录页    &#125;&#125;\r\n内容协商\r\n注意这里多源码解读\r\n什么是内容协商\r\n在 Spring Boot 3 中，内容协商(Content\r\nNegotiation)是一个非常重要的概念，特别是在构建 RESTful API 时。\r\n内容协商机制允许客户端和服务器就如何交换资源的数据格式达成协议，允许同一资源URL根据客户端的偏好提供不同格式的表示。这一过程通常由服务器和客户端共同完成：客户端告知服务器它期望的内容类型，服务器根据自身能力选择最合适的表现形式返回。\r\n简单来说，它允许客户端通过请求头指定它们希望接收响应的格式（如\r\nJSON，XML 等），服务器基于这些信息来决定以什么格式返回数据。\r\n内容协商主要依靠媒体类型(Media\r\nType)，也称为MIME类型，如application/json、application/xml、text/html等。\r\n也就是，一套系统适配多端数据返回。\r\n\r\n\r\nimage-20250607143353192\r\n\r\nSpring Boot 中的内容协商架构\r\nSpringBoot基于Spring MVC的内容协商机制，通过以下组件实现：\r\n\r\nContentNegotiationManager:\r\n负责协调整个内容协商过程\r\nContentNegotiationStrategy:\r\n定义如何确定客户端请求的媒体类型\r\nHttpMessageConverter:\r\n负责在Java对象和HTTP请求/响应体之间进行转换\r\n\r\nSpringBoot默认支持多种内容协商策略，可以根据需求进行配置和组合。\r\n多端内容适配\r\n基于请求头实现内容协商\r\n基于请求头的内容协商是最符合HTTP规范的一种方式，它通过检查HTTP请求中的Accept头来确定客户端期望的响应格式。例如，当客户端发送Accept: application/json头时，服务器会优先返回JSON格式的数据。\r\n这种策略由HeaderContentNegotiationStrategy实现，是SpringBoot的默认内容协商策略。\r\n\r\n优先检查请求的Accept头\r\n其次检查URL路径扩展名(如.json)\r\n默认支持JSON格式(通过Jackson)，因为默认的 web 场景导入了 jackson\r\n的相关包\r\n\r\n这种行为有很多好处\r\n\r\n符合HTTP规范，是RESTful\r\nAPI的推荐实践，一般在面向程序化客户端的API接口，当多种客户端需要相同数据的不同表现形式时使用\r\n无需修改URL，保持URL的简洁性\r\n适用于所有HTTP客户端\r\n对缓存友好\r\n\r\n在SpringBoot中，默认已启用基于请求头的内容协商，无需额外配置。如果需要显式配置，可以在application.properties或application.yml中添加：\r\n# 启用/禁用基于后缀的内容协商spring.mvc.contentnegotiation.favor-path-extension=true# 启用/禁用请求参数内容协商spring.mvc.contentnegotiation.favor-parameter=true# 设置请求参数名称(默认为format)spring.mvc.contentnegotiation.parameter-name=format# 注册的媒体类型映射spring.mvc.contentnegotiation.media-types.json=application/jsonspring.mvc.contentnegotiation.media-types.xml=application/xml\r\n或者\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;        @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        configurer            .favorParameter(true)            .parameterName(&quot;mediaType&quot;)            .ignoreAcceptHeader(false)            .useRegisteredExtensionsOnly(true)            .defaultContentType(MediaType.APPLICATION_JSON)            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)            .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML);    &#125;&#125;\r\n基于请求参数的内容协商\r\n基于请求参数的内容协商通过URL查询参数来确定客户端期望的响应格式。例如，/api/products?format=json请求JSON格式，而/api/products?format=xml请求XML格式。\r\n\r\n发送请求 GET/projects/spring-boot?format=json\r\n匹配到 @GetMapping(\"/projects/spring-boot\")\r\n根据参数协商，优先返回 JSON 类型的数据，需要开启参数匹配设置\r\n\r\n这种策略由ParameterContentNegotiationStrategy实现，需要显式启用。\r\n配置方式如下\r\nspring:  mvc:    contentnegotiation:      # 启用基于请求参数的内容协商      favor-parameter: true      # 设置请求参数名称，默认为 &quot;format&quot;      parameter-name: format      # 注册扩展名和媒体类型的映射      media-types:        json: application/json        xml: application/xml        html: text/html\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;        @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        configurer            .favorParameter(true)            .parameterName(&quot;format&quot;)            .ignoreAcceptHeader(false)            .defaultContentType(MediaType.APPLICATION_JSON)            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)            .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML)            .mediaType(&quot;html&quot;, MediaType.TEXT_HTML);    &#125;&#125;\r\n注意相关实体类添加对应的注解\r\n基于URL路径扩展名实现内容协商\r\n基于URL路径扩展名的内容协商通过URL末尾的文件扩展名来确定客户端期望的响应格式。例如，/api/products.json请求JSON格式，而/api/products.xml请求XML格式。\r\n这种策略由PathExtensionContentNegotiationStrategy实现，需要特别注意的是，从Spring\r\n5.3开始，出于安全考虑，默认已禁用此策略。\r\n由于路径扩展策略可能导致路径遍历攻击，Spring\r\n5.3后默认禁用。如果必须使用，建议做好URL的安全配置\r\n配置方式如下\r\nspring:  mvc:    contentnegotiation:      # 启用基于 URL 路径扩展名的内容协商      favor-path-extension: true      # 明确指定路径扩展名与媒体类型的映射关系      media-types:        json: application/json        xml: application/xml        html: text/html\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;        @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        configurer            .favorPathExtension(true)            .ignoreAcceptHeader(false)            .defaultContentType(MediaType.APPLICATION_JSON)            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)            .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML)            .mediaType(&quot;html&quot;, MediaType.TEXT_HTML);    &#125;&#125;\r\n组合策略实现高级内容协商\r\n如何进行策略组合的配置\r\n在实际应用中，通常会组合多种策略实现提供最大的灵活性。可以通过\r\nContentNegotiationConfigurer 来配置组合策略。\r\n例如如下配置组合了基于请求参数、Accept 请求头和 URL\r\n路径扩展名的内容协商策略，提供了更灵活的内容协商方式。\r\n没错，这个配置类来实现更复杂的配置，是通过实现\r\nWebMvcConfigurer 接口方法实现的\r\nimport org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.servlet.config.annotation.ContentNegotiationConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        // 启用通过请求参数指定响应格式        configurer.favorParameter(true)                // 设置请求参数名称，默认为 &quot;format&quot;               .parameterName(&quot;format&quot;)                // 不忽略 Accept 请求头               .ignoreAcceptHeader(false)                // 启用基于 URL 路径扩展名的内容协商               .favorPathExtension(true)                // 设置默认的内容类型为 JSON               .defaultContentType(MediaType.APPLICATION_JSON)                // 注册扩展名和媒体类型的映射               .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)               .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML)               .mediaType(&quot;html&quot;, MediaType.TEXT_HTML);    &#125;&#125;\r\n自定义内容协商策略\r\n简介\r\n自定义内容协商格式主要涉及到两个方面：一是自定义支持的媒体类型（Media\r\nTypes），二是自定义对这些媒体类型的处理。\r\n在 Spring Boot 3 中，自定义内容协商格式通常需要以下几个步骤：\r\n\r\n注册自定义媒体类型：你可以通过配置类来注册自定义的媒体类型，让\r\nSpring MVC 知道你打算支持哪些额外的格式。\r\n实现 HttpMessageConverter\r\n接口：对于每种你想支持的媒体类型，你需要提供一个相应的HttpMessageConverter实现，用于序列化和反序列化数据。\r\n配置 Spring MVC 以使用你的自定义\r\nHttpMessageConverter：最后，你需要在 Spring MVC 配置中注册你的\r\nHttpMessageConverter 实现，以确保Spring MVC\r\n会使用它们进行请求和响应的处理。\r\n\r\nContentNegotiationConfigurer接口\r\nContentNegotiationConfigurer 是 Spring\r\n框架中的一个接口，用于自定义内容协商策略，主要通过以下几种方式来实现：\r\n\r\nURL参数: 通过 URL\r\n参数来指定响应格式，例如，?format=json。\r\nAccept头：通过 Accept\r\n请求头来指定希望接收的响应类型，这是HTTP规范推荐的方式。\r\n扩展名: 通过 URL\r\n的扩展名来指定响应的格式。例如，.json 表示希望响应为 JSON\r\n格式，.xml 表示希望响应为 XML 格式。\r\n\r\n实现自定义内容协商-以实现\r\nyaml 内容协商为例子\r\n首先是注册自定义媒体类型，假设你想添加对\r\napplication/yaml\r\n这种媒体类型的支持，首先需要在配置类中注册这种媒体类型，注意别忘了引入可能需要的依赖，然后接下来，需要创建一个\r\nWebMvcConfigurer\r\n实例，重写其中的configureContentNegotiation内容，把消息转换器和注册器注册进去，用于处理\r\nYAML 格式的数据。\r\n引入需要的依赖\r\n添加 Jackson 的 YAML 处理模块：\r\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;&lt;/dependency&gt;\r\n创建 YAML 消息转换器\r\n实现HttpMessageConverter接口，用于处理 YAML\r\n格式的数据：\r\nimport com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;import org.springframework.http.HttpInputMessage;import org.springframework.http.HttpOutputMessage;import org.springframework.http.MediaType;import org.springframework.http.converter.AbstractHttpMessageConverter;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.http.converter.HttpMessageNotWritableException;import java.io.IOException;/** * YAML格式消息转换器，用于处理application/x-yaml媒体类型 */public class YamlHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; &#123;    private final ObjectMapper objectMapper;    public YamlHttpMessageConverter() &#123;        // 支持的媒体类型        super(MediaType.valueOf(&quot;application/x-yaml&quot;),              MediaType.valueOf(&quot;text/yaml&quot;),              MediaType.valueOf(&quot;text/x-yaml&quot;));                // 创建YAML格式的ObjectMapper        this.objectMapper = new ObjectMapper(new YAMLFactory());    &#125;    @Override    protected boolean supports(Class&lt;?&gt; clazz) &#123;        // 支持所有类型，由ObjectMapper处理具体序列化/反序列化        return true;    &#125;    @Override    protected Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage)            throws IOException, HttpMessageNotReadableException &#123;        try &#123;            // 从输入流读取并反序列化为对象            return objectMapper.readValue(inputMessage.getBody(), clazz);        &#125; catch (Exception e) &#123;            throw new HttpMessageNotReadableException(&quot;Failed to read YAML: &quot; + e.getMessage(), e, inputMessage);        &#125;    &#125;    @Override    protected void writeInternal(Object obj, HttpOutputMessage outputMessage)            throws IOException, HttpMessageNotWritableException &#123;        try &#123;            // 将对象序列化为YAML并写入输出流            objectMapper.writeValue(outputMessage.getBody(), obj);        &#125; catch (Exception e) &#123;            throw new HttpMessageNotWritableException(&quot;Failed to write YAML: &quot; + e.getMessage(), e);        &#125;    &#125;&#125;\r\n配置内容协商策略\r\n注册自定义媒体类型并配置消息转换器：\r\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.accept.ContentNegotiationManager;import org.springframework.web.accept.HeaderContentNegotiationStrategy;import org.springframework.web.accept.ParameterContentNegotiationStrategy;import org.springframework.web.servlet.config.annotation.ContentNegotiationConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.HashMap;import java.util.Map;/** * Web MVC配置，用于自定义内容协商策略 */@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        // 配置支持的媒体类型映射        Map&lt;String, MediaType&gt; mediaTypes = new HashMap&lt;&gt;();        mediaTypes.put(&quot;json&quot;, MediaType.APPLICATION_JSON);        mediaTypes.put(&quot;yaml&quot;, MediaType.valueOf(&quot;application/x-yaml&quot;));                // 配置内容协商策略        configurer            .favorParameter(true)  // 支持通过URL参数指定格式            .parameterName(&quot;format&quot;)  // 参数名：format=yaml            .ignoreAcceptHeader(false)  // 不忽略Accept请求头            .useRegisteredExtensionsOnly(false)  // 允许未注册的扩展名            .defaultContentType(MediaType.APPLICATION_JSON)  // 默认返回JSON            .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON)  // JSON格式            .mediaType(&quot;yaml&quot;, MediaType.valueOf(&quot;application/x-yaml&quot;));  // YAML格式    &#125;    // 注册自定义消息转换器    @Override    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        // 将YAML转换器添加到列表开头，优先使用        converters.add(0, new YamlHttpMessageConverter());    &#125;&#125;\r\n创建示例实体类\r\nimport com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;// 用户实体类@Data@NoArgsConstructor@AllArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class User &#123;    private Long id;         // 用户ID    private String name;     // 用户名    private Integer age;     // 年龄    private String email;    // 邮箱&#125;\r\n创建 REST 控制器\r\nimport org.springframework.web.bind.annotation.*;import java.util.Arrays;import java.util.List;/** * 用户控制器，演示内容协商的使用 */@RestController@RequestMapping(&quot;/api/users&quot;)public class UserController &#123;    /**     * 获取所有用户     * 支持根据请求协商返回JSON或YAML格式     */    @GetMapping    public List&lt;User&gt; getAllUsers() &#123;        return Arrays.asList(            new User(1L, &quot;Alice&quot;, 30, &quot;alice@example.com&quot;),            new User(2L, &quot;Bob&quot;, 25, &quot;bob@example.com&quot;),            new User(3L, &quot;Charlie&quot;, 35, &quot;charlie@example.com&quot;)        );    &#125;    /**     * 根据ID获取用户     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    public User getUserById(@PathVariable Long id) &#123;        // 模拟根据ID查找用户        return new User(id, &quot;User&quot; + id, id.intValue() + 20, &quot;user&quot; + id + &quot;@example.com&quot;);    &#125;    /**     * 创建新用户     * 支持处理JSON或YAML格式的请求体     */    @PostMapping    public User createUser(@RequestBody User user) &#123;        // 模拟创建用户，实际应用中会保存到数据库        user.setId(4L);        return user;    &#125;&#125;\r\n测试\r\n下面通过几种方式测试 YAML 格式的内容协商：\r\n# 请求JSON格式curl -X GET http://localhost:8080/api/users# 请求YAML格式curl -X GET -H &quot;Accept: application/x-yaml&quot; http://localhost:8080/api/users\r\n发送 YAML 格式的请求体\r\ncurl -X POST -H &quot;Content-Type: application/x-yaml&quot; -d &#x27;id: 5name: Davidage: 40email: david@example.com&#x27; http://localhost:8080/api/users\r\n内容协商原理 -\r\nHttpMessageConverter\r\n基于上述我们的自定义内容协商的内容，我们可以知道，实现自定义内容协商的配置关键在于，编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverters\r\n这里就讲一下是如何实现的和其中的实现原理\r\n内容协商的完整流程\r\n当客户端发起请求时，内容协商的执行流程如下：\r\n\r\n请求到达 DispatcherServlet：Spring MVC\r\n的前端控制器接收请求\r\nHandlerMapping 确定处理器：找到处理该请求的\r\nController 方法\r\n内容协商启动：\r\n\r\n检查请求的 Accept 头（如\r\nAccept: application/json）\r\n检查 URL 参数（如 ?format=json）\r\n检查 URL 扩展名（如 .json）\r\n\r\n选择合适的 Converter：\r\n\r\n根据协商结果（如 JSON、XML），从 HttpMessageConverter\r\n列表中选择支持该媒体类型的转换器\r\n排序规则：优先使用用户自定义的 Converter（通过\r\nextendMessageConverters 添加），再使用默认的\r\n\r\n执行转换：\r\n\r\n请求处理：读取请求体并转换为 Controller\r\n方法的参数\r\n响应处理：将 Controller 返回值序列化为响应格式\r\n\r\n\r\n核心接口：HttpMessageConverter\r\n在 Spring MVC 中，内容协商是将 HTTP 请求和响应与特定格式（如\r\nJSON、XML、YAML 等）进行匹配的过程。这一过程的核心在于\r\nHttpMessageConverter 接口，它负责处理 HTTP\r\n请求和响应的序列化与反序列化。\r\nHttpMessageConverter 是一个策略接口，负责：\r\n\r\n读取 HTTP 请求体并将其转换为 Java\r\n对象（反序列化）\r\n写入 Java 对象到 HTTP 响应体（序列化）\r\n\r\n其核心方法包括：\r\n\r\ncanRead(Class clazz, MediaType mediaType)：判断是否能将请求转换为指定类型\r\ncanWrite(Class clazz, MediaType mediaType)：判断是否能将对象序列化为指定媒体类型\r\nread(Class clazz, HttpInputMessage inputMessage)：从请求中读取并转换为对象\r\nwrite(T t, MediaType contentType, HttpOutputMessage outputMessage)：将对象写入响应\r\n\r\n内容协商的具体实现\r\n内容协商是确定响应格式的过程，主要由\r\nContentNegotiationManager 负责：\r\n\r\n确定客户端期望的媒体类型\r\n\r\n检查 Accept 请求头\r\n检查 URL 参数（如 ?format=json）\r\n检查 URL 扩展名（如 .json）\r\n\r\n选择合适的 HttpMessageConverter\r\n\r\n遍历所有注册的 HttpMessageConverter\r\n调用 canWrite()\r\n方法判断转换器是否支持该类型和媒体类型\r\n选择第一个匹配的转换器\r\n\r\n\r\npublic List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException &#123;        Iterator var2 = this.strategies.iterator();\t\t// 遍历所有注册的协商策略        List mediaTypes;        do &#123;            if (!var2.hasNext()) &#123;                return MEDIA_TYPE_ALL_LIST;            &#125;            ContentNegotiationStrategy strategy = (ContentNegotiationStrategy)var2.next();            mediaTypes = strategy.resolveMediaTypes(request);        &#125; while(mediaTypes.equals(MEDIA_TYPE_ALL_LIST));        return mediaTypes;    &#125;\r\n@ResponseBody\r\n由 HttpMessgaeConverter处理\r\n@ResponseBody 注解的作用是：将 Controller\r\n方法的返回值直接写入 HTTP\r\n响应体，而不是转发到视图页面，当方法或类标注了\r\n@ResponseBody（@RestController 等价于类上标注\r\n@Controller + @ResponseBody）时，Spring MVC\r\n会启用特殊的返回值处理逻辑。\r\n@ResponseBody 注解是内容协商机制的关键触发点：\r\n\r\n当 Controller 方法被 @ResponseBody 注解时（或类被\r\n@RestController 注解），Spring MVC 会：\r\n\r\n步骤层次\r\n\r\n通过内容协商确定响应的媒体类型\r\n找到支持该媒体类型的 HttpMessageConverter\r\n使用该 Converter 将返回值序列化为响应体\r\n\r\n源码层次\r\n\r\n请求进来先来到DispatcherServlet类中的doDispatch()方法处理\r\n// DispatcherServlet.java// 这里是简化的源码流程protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;    // 1. 找到处理请求的 Handler    // 其实一上来这里是空的，一点点补充的    HandlerExecutionChain mappedHandler = getHandler(request);        // 2. 找到执行 Handler 的 Adapter    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());        // 3. 执行 Handler    ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());        // 4. 处理返回值    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);&#125;\r\n找到了一个HandlerAdapter适配器，利用适配器执行目标方法\r\n\r\n\r\nimage-20250607154029850\r\n\r\nRequestMappingHandlerAdapter来执行，最终会调用invokeHandlerMethod()来执行目标方法\r\n\r\n\r\nimage-20250607160624189\r\n\r\n目标方法执行之前，准备好两个东西\r\n\r\nHandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值\r\nHandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理\r\n\r\nRequestMappingHandlerAdapter里面的invokeAndHandle()真正执行目标方法\r\n目标方法执行完成，会返回返回值对象\r\n找到一个合适的返回值处理器HandlerMethodReturnValueHandler\r\n// HandlerMethodReturnValueHandlerComposite.java@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;        // 查找能处理该返回值的处理器    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);    if (handler == null) &#123;        throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());    &#125;        // 使用处理器处理返回值    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125;private HandlerMethodReturnValueHandler selectHandler(@Nullable Object returnValue, MethodParameter returnType) &#123;    // 是否是异步返回值    boolean isAsyncValue = isAsyncReturnValue(returnValue, returnType);    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123;        if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123;            continue;        &#125;        // 判断处理器是否支持该返回值类型        if (handler.supportsReturnType(returnType)) &#123;            return handler;        &#125;    &#125;    return null;&#125;\r\n最终找到RequestResponseBodyMethodProcessor能处理标注了@ResponseBody注解的方法\r\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;        mavContainer.setRequestHandled(true);        ServletServerHttpRequest inputMessage = this.createInputMessage(webRequest);        ServletServerHttpResponse outputMessage = this.createOutputMessage(webRequest);        if (returnValue instanceof ProblemDetail detail) &#123;            outputMessage.setStatusCode(HttpStatusCode.valueOf(detail.getStatus()));            if (detail.getInstance() == null) &#123;                URI path = URI.create(inputMessage.getServletRequest().getRequestURI());                detail.setInstance(path);            &#125;            this.invokeErrorResponseInterceptors(detail, (ErrorResponse)null);        &#125;        this.writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);    &#125;\r\nRequestResponseBodyMethodProcessor调用writeWithMessageConverters，利用MessageConverter把返回值进行序列化然后写出去\r\n\r\n上述的源码内容都在说一个事：@ResponseBody 由\r\nHttpMessgaeConverter处理的\r\n而HttpMessageConverter会进行内容协商\r\n\r\n遍历所有的MessageConverter，看谁支持这种内容类型的数据\r\n默认的MessageConverter有以下：\r\n最终因为要\r\njson，所以MappingJackson2HttpMessageConverter支持写出\r\nJSON\r\nJackson 用ObjectMapper把对象写出去\r\n\r\n\r\n@ResponseBody 与 HttpMessageConverter\r\n的协作流程可以概括为：\r\n\r\n请求处理：DispatcherServlet\r\n接收请求并找到处理方法\r\n方法执行：HandlerAdapter 执行目标方法\r\n返回值处理：通过 HandlerMethodReturnValueHandler\r\n找到 RequestResponseBodyMethodProcessor\r\n内容协商：确定响应的媒体类型\r\n转换器选择：遍历 HttpMessageConverter\r\n列表，找到第一个支持该类型和媒体类型的转换器\r\n序列化输出：使用选定的转换器将返回值序列化为响应体\r\n\r\n\r\n所以请求处理的整体流程就很清晰了，当客户端发送 HTTP 请求到 Spring MVC\r\n应用时，整个处理流程可以概括为：\r\n\r\n请求进入 DispatcherServlet：Spring MVC\r\n的前端控制器接收所有请求\r\nHandlerMapping 确定处理器：找到处理该请求的\r\nController 方法\r\nHandlerAdapter\r\n执行方法：通过适配器执行目标方法\r\n返回值处理：将方法返回值转换为 HTTP 响应\r\n响应输出：将处理结果返回给客户端\r\n\r\n例如\r\n@GetMapping(&quot;/users&quot;)@ResponseBody  // 可省略，@RestController 已隐含此注解public List&lt;User&gt; getUsers() &#123;    return Arrays.asList(new User(1L, &quot;Alice&quot;, 30));&#125;\r\nSpring MVC 会根据协商结果选择：\r\n\r\nMappingJackson2HttpMessageConverter 处理 JSON\r\nJaxb2RootElementHttpMessageConverter 处理 XML\r\n自定义的 YamlHttpMessageConverter 处理 YAML\r\n\r\nWebMvcAutoConfiguration提供几种默认的HttpMessageConverters\r\nSpring MVC 默认注册了多种\r\nHttpMessageConverter，按顺序排列如下：\r\n\r\nByteArrayHttpMessageConverter：处理二进制数据，支持\r\napplication/octet-stream\r\nStringHttpMessageConverter：处理字符串，支持\r\ntext/plain\r\nResourceHttpMessageConverter：处理资源文件，支持\r\napplication/octet-stream\r\nResourceRegionHttpMessageConverter：处理部分资源，支持媒体类型范围请求\r\nSourceHttpMessageConverter：处理\r\njavax.xml.transform.Source，支持 XML\r\nAllEncompassingFormHttpMessageConverter：处理表单数据，支持\r\napplication/x-www-form-urlencoded\r\nJaxb2RootElementHttpMessageConverter：处理 JAXB\r\n注解的对象，支持 XML\r\nMappingJackson2HttpMessageConverter：处理\r\nJSON，支持 application/json\r\nMappingJackson2XmlHttpMessageConverter：处理\r\nXML，支持 application/xml\r\nAtomFeedHttpMessageConverter：处理 Atom 格式，支持\r\napplication/atom+xml\r\nRssChannelHttpMessageConverter：处理 RSS 格式，支持\r\napplication/rss+xml\r\n\r\n注意这里需要添加可能需要的注解才可能在适配器遍历的时候被选中为有效的\r\n而其中，我们可以知道：\r\n\r\n系统提供的默认的 MessageConverter的功能很有限，仅适用于 json\r\n或者普通的数据返回\r\n需要增加额外的内容协商功能，必须添加新的HttpMessageConverters\r\n\r\n自定义\r\nHttpMessageConverter 的优先级\r\n当添加自定义 HttpMessageConverter\r\n时，注册顺序非常重要：\r\n\r\n替换默认转换器：\r\n@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    converters.clear(); // 移除所有默认转换器    converters.add(new YamlHttpMessageConverter()); // 添加自定义转换器    // 添加其他必要的转换器&#125;\r\n注意：这种方式会完全替换默认转换器，需谨慎使用\r\n扩展默认转换器（推荐方式）：\r\n@Overridepublic void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    converters.add(0, new YamlHttpMessageConverter()); // 添加到列表开头，优先使用&#125;\r\n原理：Spring MVC\r\n按顺序遍历转换器列表，选择第一个支持的转换器\r\n\r\n常见的内置\r\nHttpMessageConverter\r\nSpring MVC 默认提供了多种转换器：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n转换器\r\n支持的媒体类型\r\n用途\r\n\r\n\r\n\r\n\r\nMappingJackson2HttpMessageConverter\r\napplication/json, application/*+json\r\nJSON 处理\r\n\r\n\r\nMappingJackson2XmlHttpMessageConverter\r\napplication/xml, text/xml\r\nXML 处理\r\n\r\n\r\nStringHttpMessageConverter\r\ntext/plain\r\n字符串处理\r\n\r\n\r\nFormHttpMessageConverter\r\napplication/x-www-form-urlencoded\r\n表单数据处理\r\n\r\n\r\nByteArrayHttpMessageConverter\r\napplication/octet-stream\r\n二进制数据处理\r\n\r\n\r\n\r\n总结\r\n内容协商是 Spring MVC 处理不同格式数据的核心机制，其关键点在于：\r\n\r\nHttpMessageConverter 是实现格式转换的核心接口\r\n内容协商策略决定了如何选择合适的转换器\r\n注册顺序影响转换器的优先级\r\n@ResponseBody\r\n注解触发自动内容协商\r\n\r\n通过自定义 HttpMessageConverter\r\n和内容协商策略，可以轻松支持 JSON、XML、YAML 甚至自定义格式，实现灵活的\r\nAPI 设计。\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","源码分析","配置文件"]},{"title":"Spring Boot part5-日志配置","url":"/posts/37984.html","content":"日志配置\r\n规范：项目开发不要使用System.ut.println()，应该用日志记录信息\r\n\r\n\r\nimage-20250527110648134\r\n\r\n简介\r\n\r\nSpring\r\n使用commons - logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。\r\n\r\nspring5 及以后\r\ncommons - logging被spring直接自己写了\r\n\r\n支持 jul，log4j2，logback。SpringBoot\r\n提供了默认的控制台输出配置，也可以配置输出为文件。\r\nlogback 是默认使用的。Log4j 被弃用了，一般用 Log4j2\r\n虽然日志框架很多，但是我们不用担心，使用 SpringBoot\r\n的默认配置就能工作的很好。\r\n\r\n虽然默认是 Logback，但 Spring Boot 也支持对接其他日志框架，如 Java\r\nUtil Logging（JUL）、Log4j2\r\n等。不过在引入其他日志框架时，需要注意排除默认的 Logback\r\n相关依赖，避免冲突。例如若要使用 Log4j2，需在pom.xml中添加 Log4j2\r\n依赖，并排除 Spring Boot 默认的 Logback 依赖：\r\nSpring Boot\r\n是如何把日志默认配置好的\r\n\r\n每个 starter 场景，都会默认导入一个核心场景\r\nspring-boot-starter\r\n这个核心场景里面，本身就导入了日志场景，引入了日志的所有功能，这个是默认存在的\r\n默认了使用了 logback + slf4j 作为默认底层日志\r\n日志是系统一启动就用的，xxxAutoConfiguration\r\n是系统启动好了以后放好的组件，项目启动完成后来用的\r\n日志是利用监听器机制配置好的。ApplicationListener\r\n日志所有的配置都可以通过修改配置文件实现。以 logging\r\n开始的所有配置。\r\n\r\n假如maven依赖中添加了spring-boot-starter-logging：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt;\r\n但是呢，实际开发中我们不需要直接添加该依赖。\r\nspring-boot-starter其中包含了\r\nspring-boot-starter-logging，该依赖内容就是 Spring Boot\r\n默认的日志框架logback。\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\r\n日志格式\r\n以随便的几条为例子\r\n2025-05-27 14:22:51.330 [main] DEBUG e.s.e.s.SpringBootPriticalApplication - Running with Spring Boot v3.5.0, Spring v6.2.72025-05-27 14:22:51.331 [main] INFO  e.s.e.s.SpringBootPriticalApplication - No active profile set, falling back to 1 default profile: &quot;default&quot;2025-05-27 14:22:51.854 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode2025-05-27 14:22:51.854 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data JPA repositories in DEFAULT mode.\r\n默认输出格式：\r\n\r\n时间和日期：格式为\r\nyyyy-MM-dd HH:mm:ss.SSS，记录日志生成的精确时间。\r\n日志级别：ERROR WARN INFO\r\nDEBUG TRACE\r\n进程ID：\r\n- 或 --- ：消息分隔符\r\n线程名：使用 []\r\n包含，执行当前代码的线程名称（如main、http-nio-8080-exec-1）。\r\nLogger\r\n名：通常是产生日志的类名，是类的全限定名（如com.example.MyService），用于定位日志来源。\r\n消息：日志记录的内容\r\n\r\n注意：logback 没有 FATAL 级别，对应的是\r\nERROR\r\n修改日志格式：\r\n通过 logging.pattern.console\r\n属性可以自定义控制台日志格式。例如，将默认格式修改为\r\nlogging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;15&#125; ===&gt; %msg%n\r\n格式说明：\r\n\r\n%d&#123;...&#125;：时间戳格式。\r\n%-5level：左对齐的日志级别（宽度 5 个字符）。\r\n[%thread]：线程名。\r\n%logger&#123;15&#125;：Logger 名称（缩写为 15 个字符）。\r\n===&gt;：自定义分隔符。\r\n%msg：日志消息。\r\n%n：换行符。\r\n\r\n默认值：参照：spring - boot 包\r\nadditional - spring - configuration - metadata.json\r\n文件\r\n实际项目中使用日志记录信息\r\nimport org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class LoggingExampleApplication implements CommandLineRunner &#123;    // 创建Logger实例（通常放在类的顶部）    private static final Logger logger = LoggerFactory.getLogger(LoggingExampleApplication.class);    public static void main(String[] args) &#123;        // 启动时记录日志        logger.info(&quot;应用启动中...&quot;);        SpringApplication.run(LoggingExampleApplication.class, args);        logger.info(&quot;应用已成功启动！&quot;);    &#125;    @Override    public void run(String... args) throws Exception &#123;        // 初始化数据时记录日志        logger.info(&quot;正在初始化应用数据...&quot;);        // 模拟数据加载        Thread.sleep(1000);        logger.info(&quot;数据初始化完成！&quot;);    &#125;    @GetMapping(&quot;/hello&quot;)    public String sayHello() &#123;        // 处理请求时记录日志        logger.debug(&quot;收到/hello请求&quot;);                try &#123;            // 业务逻辑            String result = &quot;Hello, World!&quot;;            // 可以指定参数            logger.info(&quot;请求处理成功，返回结果: &#123;&#125;&quot;, result);            return result;        &#125; catch (Exception e) &#123;            // 异常处理            logger.error(&quot;请求处理失败&quot;, e);            return &quot;Error occurred&quot;;        &#125;    &#125;&#125;\r\n可以使用&#123;&#125;\r\n占位符来拼接字符串，而不需要使用+来连接字符串。\r\n日志级别\r\n\r\n由低到高：ALL, TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF；\r\n只会打印指定级别及以上级别的日志\r\n\r\nALL：打印所有日志\r\nTRACE：追踪框架详细流程日志，一般不使用\r\nDEBUG：开发调试细节日志\r\nINFO：关键、感兴趣信息日志\r\nWARN：警告但不是错误的信息日志，比如：版本过时\r\nERROR：业务错误日志，比如出现各种异常\r\nFATAL：致命错误日志，比如 jvm 系统崩溃\r\nOFF：关闭所有日志记录\r\n\r\n不指定级别的所有类，都使用 root 指定的级别作为默认级别\r\nSpring Boot 日志默认级别是 INFO\r\n\r\n\r\n在 application.properties/yaml\r\n中配置logging.level.=指定日志级别\r\nlevel 可取值范围：TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or\r\nOFF，定义在 LogLevel 类中\r\nroot 的 logger - name 叫\r\nroot，可以配置logging.level.root=warn，代表所有未指定日志级别都使用\r\nroot 的 warn 级别\r\n\r\nSpring Boot 支持通过 logging.level\r\n配置不同包的日志级别：\r\n# 全局级别logging.level.root=INFO# 可以精确到包，指定包级别logging.level.com.example=DEBUGlogging.level.org.springframework=WARN\r\n在运行命令后加入--debug标志，如：$ java -jar springTest.jar --debug\r\n也可以切换日志级别\r\n日志分组\r\n作用\r\n日志分组是一种将相关的日志记录器（Logger）归为一组进行统一配置的机制。它能更便捷地管理和控制日志输出，尤其是在项目规模较大、涉及众多模块和依赖时，通过分组可避免逐一配置每个\r\nLogger 的繁琐操作。\r\n\r\n简化配置：将多个相关的 Logger\r\n归为一组，只需针对组设置一次日志级别等配置，就能统一应用到组内所有\r\nLogger，避免了对每个 Logger 单独设置的重复操作。\r\n\r\nSpring Boot 默认创建了一些预定义的日志分组\r\n\r\nsql 组：通常用于与 SQL 相关的日志记录，与 SQL\r\n语句执行、参数绑定等相关的日志记录器可能会被纳入这个组。\r\nweb 组：主要涵盖与 Web 相关的日志。像 Spring MVC 或\r\nSpring WebFlux 处理 HTTP\r\n请求、响应的过程，包括请求的接收、处理、返回响应等环节的日志记录器可能会在这个组。\r\n\r\n自定义日志分组\r\n除了使用预定义分组，开发者还能根据项目需求自定义日志分组，步骤如下：\r\n\r\n在配置文件中定义分组：在application.properties或application.yaml配置文件中进行定义。以application.properties为例，假设要创建一个名为myGroup的日志分组，包含com.example.service包下的所有\r\nLogger 以及com.example.repository.UserRepository类对应的\r\nLogger，可以这样配置：\r\nlogging.group.myGroup=com.example.service,com.example.repository.UserRepository\r\n配置分组的日志级别：定义好分组后，可设置其日志级别。比如将myGroup分组的日志级别设为\r\nDEBUG，在application.properties中配置：\r\nlogging.level.myGroup=DEBUG\r\n日志分组与日志输出的关系：当设置好日志分组及级别后，组内 Logger\r\n会按照该组级别进行日志输出控制。日志分组的配置会覆盖单个 Logger\r\n的独立配置（如果之前有单独为某个 Logger\r\n设置过级别，分组配置后会以分组级别为准）\r\n\r\n结合日志滚动归档等功能\r\n日志分组常与日志的其他功能配合使用，比如在生产环境中，结合日志滚动归档和切割功能。\r\n\r\n假设已对某个业务模块的日志进行分组，可进一步配置该组日志按天归档、按文件大小切割。\r\n# 日志存档文件名格式logging.logback.rollingpolicy.file-name-pattern=logs/myGroupLog.%d&#123;yyyy-MM-dd&#125;.%i.gz# 应用启动时不清除以前存档logging.logback.rollingpolicy.clean-history-on-start=false# 存档前每个日志文件最大大小为10MBlogging.logback.rollingpolicy.max-file-size=10MB# 日志文件被删除之前容纳的最大大小（这里设为无限大）logging.logback.rollingpolicy.total-size-cap=0B# 日志文件保存的最大天数为7天logging.logback.rollingpolicy.max-history=7\r\n\r\n日志输出\r\n在 Spring Boot\r\n中，日志输出相关内容涵盖日志格式、输出位置、日志级别控制以及与不同日志框架的集成等方面\r\nSpring Boot 默认只把日志写在控制台，如果想额外记录到文件，可以在\r\napplication.properties中添加 logging.file.name\r\nor logging.file.path 配置项。\r\n输出位置\r\n\r\n控制台输出：Spring Boot\r\n默认将日志输出到控制台，在开发阶段方便快速查看应用运行状态和问题。开发者可通过配置日志级别来控制输出内容，比如设置为\r\nDEBUG 级别可获取更详细信息用于调试。\r\n文件输出：要将日志输出到文件，可在配置文件（application.properties或application.yaml）中进行配置。在application.properties中配置示例如下：\r\n属性设置\r\n\r\nlogging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log\r\nlogging.path，设置目录，会在该目录下创建spring.log`文件，并写入日志内容\r\n\r\n# 配置日志输出到文件，指定文件路径logging.file.name=logs/app.log# 也可分开指定日志文件路径和名称\r\n\r\nlogging.file.path=logs/\r\n# logging.file.name=app.log\r\n# 只写名字，就生成到当前项目同位置的 demo.log\r\n    配置后，日志除了在控制台输出（若未关闭控制台输出配置），还会写入指定文件，便于后续查看和分析，尤其适用于生产环境。    | logging.file.name | logging.file.path | 示例     | 效果                              |  | ----------------- | ----------------- | -------- | --------------------------------- |  | 未指定            | 未指定            |          | 仅控制台输出                      |  | 指定              | 未指定            | my.log   | 写入指定文件。可以加路径          |  | 未指定            | 指定              | /var/log | 写入指定目录，文件名为 spring.log |  | 指定              | 指定              |          | 以 logging.file.name 为准         |&gt; 注：二者不能同时使用，如若同时使用，则只有`logging.file`生效&gt; 默认情况下，日志文件的大小达到`10MB`时会切分一次，产生新的日志文件，默认级别为：`ERROR、WARN、INFO`#### 实际场景- **开发调试阶段**：将日志级别设为 DEBUG，通过控制台输出，能详细查看代码执行流程、变量值等信息，帮助快速定位问题。比如在开发一个业务方法时，在方法开始、关键逻辑分支、调用其他服务等位置添加 DEBUG 级别的日志，能清楚了解方法执行过程。- **生产运行阶段**：一般将日志级别设为 INFO 或 WARN，重点关注关键业务信息和警告信息。同时将日志输出到文件，便于定期查看和分析应用运行情况。例如记录订单创建、支付成功等 INFO 级别的日志；对于可能存在风险的操作，如用户登录失败次数过多，记录 WARN 级别的日志。还可结合日志分析工具，从大量日志文件中挖掘有价值的信息，用于性能优化、故障排查等。### 文件归档与滚动切割1. 每天的日志应该独立分割出来存档。如果使用 logback（SpringBoot 默认整合），可以通过 application.properties/yaml 文件指定日志滚动规则。2. 如果是其他日志系统，需要自行配置（添加 log4j2.xml 或 log4j2-spring.xml）3. 支持的滚动规则设置如下   ### 自定义日志系统在 Spring Boot 应用中，文件归档与滚动切割是日志管理的重要功能，用于有效管理不断增长的日志文件，避免单个日志文件过大，同时方便对历史日志进行存档和查阅归档：每天的日志都单独存到一个文档中切割：指定每个日志文件固定大小，超过大小就切割成另一个文件- **控制文件大小**：随着应用的持续运行，日志文件会不断增大。如果不加以控制，可能会占用大量磁盘空间，还会导致日志文件读取和分析困难。通过滚动切割，可将日志按照一定规则分割成多个较小的文件，比如按时间（每天、每周）或文件大小（达到一定字节数）进行切割。- **便于管理和存档**：将日志按规则归档，能让不同时间段或不同条件下的日志分开保存。例如按天归档，每天的日志都在独立文件中，方便查找特定日期的日志记录，也便于对历史日志进行备份、清理等管理操作。支持的滚动规则设置如下| 配置项                                               | 描述                                                         || ---------------------------------------------------- | ------------------------------------------------------------ || logging.logback.rollingpolicy.file-name-pattern      | 日志存档的文件名格式（默认值：$&#123;LOG_FILE&#125;.% d &#123;yyyy-MM-dd&#125;.% i.gz） || logging.logback.rollingpolicy.clean-history-on-start | 应用启动时是否清除以前存档（默认值：false）                  || logging.logback.rollingpolicy.max-file-size          | 存档前，每个日志文件的最大大小（默认值：10MB）               || logging.logback.rollingpolicy.total-size-cap         | 日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置 1GB 则磁盘存储超过 1GB 日志后就会删除旧日志文件 || logging.logback.rollingpolicy.max-history            | 日志文件保存的最大天数 (默认值：7)                           |#### 基于 Logback 的配置（Spring Boot 默认整合）- **按时间滚动切割**：在`application.properties`或`application.yaml`中进行配置。  在`application.properties`中配置按天滚动切割示例：  ```properties  # 日志文件名称  logging.file.name=logs/app.log  # 日志滚动策略：按时间滚动  logging.logback.rollingpolicy.time-based=true  # 日志存档文件名格式，%d&#123;yyyy-MM-dd&#125;表示按日期替换  logging.logback.rollingpolicy.file-name-pattern=logs/app.%d&#123;yyyy-MM-dd&#125;.log.gz  # 保留的历史日志文件最大数量，这里设为30天  logging.logback.rollingpolicy.max-history=30\r\n上述配置表示每天生成一个新的日志文件，旧的日志文件按app.日期.log.gz格式压缩存档，最多保留\r\n30 天的历史日志文件\r\n\r\n按文件大小滚动切割：同样在配置文件中设置。\r\n在application.properties中配置示例：\r\n# 日志文件名称logging.file.name=logs/app.log# 日志滚动策略：按文件大小滚动logging.logback.rollingpolicy.size-based=true# 每个日志文件的最大大小，这里设为10MBlogging.logback.rollingpolicy.max-file-size=10MB# 日志存档文件名格式logging.logback.rollingpolicy.file-name-pattern=logs/app.%i.log.gz# 日志文件被删除之前容纳的最大大小，这里设为100MBlogging.logback.rollingpolicy.total-size-cap=100MB\r\n此配置意味着当app.log文件大小达到 10MB\r\n时，会进行滚动切割，生成新的日志文件，按顺序编号（app.1.log.gz、app.2.log.gz等），所有存档日志文件总大小达到\r\n100MB 时，会删除最早的日志文件以控制占用空间。\r\n\r\n其他日志系统的配置\r\n如果使用 Log4j2 等其他日志系统，不能直接用上述针对 Logback\r\n的配置方式。一般需要在log4j2.xml或log4j2-spring.xml配置文件中进行设置。以下是\r\nLog4j2 按时间滚动切割的简单示例：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/app.log&quot;                     filePattern=&quot;logs/app.%d&#123;yyyy-MM-dd&#125;.log.gz&quot;&gt;            &lt;PatternLayout&gt;                &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&lt;/Pattern&gt;            &lt;/PatternLayout&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy /&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;&gt;                &lt;Delete basePath=&quot;logs&quot; maxDepth=&quot;1&quot;&gt;                    &lt;IfFileName glob=&quot;app.*.log.gz&quot;&gt;                        &lt;IfAccumulatedFileCount exceeds=&quot;30&quot; /&gt;                    &lt;/IfFileName&gt;                &lt;/Delete&gt;            &lt;/DefaultRolloverStrategy&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot; /&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n上述配置中，&lt;RollingFile&gt;元素定义了滚动日志文件的相关设置，&lt;Policies&gt;内的&lt;TimeBasedTriggeringPolicy&gt;指定按时间滚动策略，&lt;DefaultRolloverStrategy&gt;设置了保留的最大历史文件数及删除策略等。\r\n自定义日志系统\r\n根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：\r\n通常我们配置application.properties\r\n就够了。当然也可以自定义。比如：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n日志系统\r\n自定义\r\n\r\n\r\n\r\n\r\nLogback\r\nlogback-spring.xml,\r\nlogback-spring.groovy,logback.xml,\r\nlogback.groovy\r\n\r\n\r\nLog4j2\r\nlog4j2-spring.xml, log4j2.xml\r\n\r\n\r\nJDK(Java Util Logging)\r\nlogging.properties\r\n\r\n\r\n\r\n如果可能，我们建议您在日志配置中使用 -spring\r\n变量（例如，logback-spring.xml 而不是 logback.xml\r\n）。如果您使用标准配置文件，spring 无法完全控制日志初始化。\r\n如果要自己写配置，配置文件名加上xx-spring.xml\r\nSpring\r\nBoot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring\r\nboot 可以为它添加一些 spring boot 特有的配置项\r\n如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，application.yml可以通过logging.config属性指定自定义的名字：\r\nlogging.config=classpath:logging-config.xml\r\n虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日志配置，这个功能会很有用。\r\n一般不需要这个属性，而是直接在logback-spring.xml中使用springProfile配置，不需要logging.config指定不同环境使用不同配置文件。springProfile配置在下面介绍。\r\nLogback\r\n根节点&lt;configuration&gt;\r\n在 Logback 日志框架的配置中，&lt;configuration&gt;\r\n是根节点，它包含的一些属性可以控制 Logback\r\n的整体行为，同时它还有多个子节点用于进一步细化日志配置。以下是对这部分内容的详细讲解：\r\n根节点\r\n&lt;configuration&gt; 包含的属性\r\n\r\nscan 属性\r\n\r\n作用：决定当配置文件发生变化时，Logback\r\n是否重新加载配置。如果设置为 true ，一旦配置文件（比如\r\nlogback - spring.xml 等）的内容被修改，Logback\r\n会自动检测到并重新加载配置，新的配置会立即生效，无需重启应用程序。\r\n使用场景：在开发阶段非常实用，开发人员频繁调整日志配置（如修改日志级别、输出格式等）时，不用反复重启应用就能看到配置修改后的效果，提高开发效率。\r\n默认值：true 。\r\n\r\nscanPeriod 属性\r\n\r\n作用：指定 Logback\r\n检查配置文件是否有修改的时间间隔。只有当 scan 属性为\r\ntrue\r\n时，这个属性才会生效。如果不指定时间单位，默认以毫秒为单位。\r\n使用场景：如果希望更及时地检测到配置文件的变化，可以将时间间隔设置得短一些，比如设置为\r\n5000 （表示 5 秒），能让 Logback 每 5\r\n秒检查一次配置文件；若不想过于频繁地检查（频繁检查会消耗一定系统资源），可以设置较长时间间隔，如默认的\r\n1 分钟（即 60000 毫秒 ）。\r\n默认值：1 分钟（60000 毫秒 ）。\r\n\r\ndebug 属性\r\n\r\n作用：当设置为 true 时，Logback\r\n会打印内部日志信息，这些信息能帮助开发人员了解 Logback\r\n的运行状态，比如日志加载过程、各个组件的初始化情况、配置解析过程中是否存在问题等。\r\n使用场景：在排查 Logback 配置问题或调试 Logback\r\n相关功能时很有用。例如，发现日志输出不符合预期，开启 debug\r\n模式后，通过查看内部日志信息，能定位是配置文件解析错误，还是某些组件初始化失败等问题。\r\n默认值：false 。\r\n\r\n\r\n根节点\r\n&lt;configuration&gt; 的子节点\r\n&lt;configuration&gt;\r\n根节点有多个子节点，每个子节点都有特定的功能，后续会详细介绍，常见的子节点包括：\r\n\r\n&lt;appender&gt; 子节点\r\n\r\n作用：用来格式化日志输出节点，有俩个属性 name 和\r\nclass，class\r\n用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。可以用于定义日志输出的目的地，比如控制台（ConsoleAppender）、文件（FileAppender）、数据库等。可以配置不同的\r\nAppender\r\n来实现日志的多目的地输出，例如同时将日志输出到控制台和文件中。\r\n示例：定义一个将日志输出到控制台的\r\nAppender：\r\n&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;    &lt;encoder&gt;        &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;&lt;/appender&gt;\r\n上述配置中，name 属性给 Appender 命名为\r\nSTDOUT ，class 指定了 Appender\r\n的类型为控制台输出类型，&lt;encoder&gt;\r\n标签内定义了日志输出的格式，表示对日志进行编码\r\n\r\n%d&#123;HH: mm:ss.SSS&#125;——日志输出时间\r\n%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用\r\n%-5level——日志级别，并且使用5个字符靠左对齐\r\n%logger&#123;36&#125;——日志输出者的名字\r\n%msg——日志消息\r\n%n——平台的换行符\r\n\r\n\r\n&lt;logger&gt;子节点\r\n\r\n作用：用于设置特定包或类的日志级别，它可以覆盖根\r\nLogger 的级别设置。通过 &lt;appender&gt;\r\n节点，可以对项目中不同模块、包的日志级别进行精细控制。仅有一个name属性，一个可选的level和一个可选的addtivity属性。\r\n\r\nname：用来指定受此 logger\r\n约束的某一个包或者具体的某一个类。\r\nlevel：用来设置打印级别，大小写无关：TRACE, DEBUG,\r\nINFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值 INHERITED 或者同义词 NULL\r\n，代表强制执行上级的级别。如果未设置此属性，那么当前 logger\r\n将会继承上级的级别。\r\naddtivity：是否向上级loger传递打印信息。默认是true。\r\n\r\n示例：设置 com.example.service\r\n包下所有类的日志级别为 DEBUG：\r\n&lt;logger name=&quot;com.example.service&quot; level=&quot;DEBUG&quot; /&gt;\r\n这里 name 属性指定了包名，level\r\n属性设置了日志级别。\r\n\r\n&lt;root&gt; 子节点\r\n\r\n介绍：&lt;root&gt;节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性。level\r\n用来设置打印级别，大小写无关，标识这个 appender\r\n将会添加到这个loger。\r\n作用：定义根 Logger，它是所有其他 Logger 的父\r\nLogger，设置根 Logger 的级别会影响到未单独设置级别的 Logger。如果某个\r\nLogger 没有显式设置级别，就会继承根 Logger 的级别。\r\n示例：将根 Logger 的级别设置为 INFO\r\n&lt;root level=&quot;INFO&quot;&gt;    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;&lt;/root&gt;\r\n上述配置中，level 属性设置了根 Logger 级别为\r\nINFO，并通过 `标签引用了前面定义的名为STDOUT` 的\r\nAppender，意味着根 Logger 的日志会输出到控制台。\r\n\r\n&lt;turboFilter&gt; 子节点\r\n\r\n作用：用于实现更高级的日志过滤功能。TurboFilter\r\n可以在日志事件被处理之前进行过滤，根据自定义的规则决定是否允许该日志事件继续被处理和输出。\r\n示例：定义一个简单的\r\nTurboFilter（具体实现类需自定义）：\r\n&lt;turboFilter class=&quot;com.example.MyTurboFilter&quot;&gt;    &lt;option name=&quot;param1&quot; value=&quot;value1&quot; /&gt;&lt;/turboFilter&gt;\r\n这里 class 属性指定了 TurboFilter 的实现类，``\r\n标签可以传递一些参数给 TurboFilter。\r\n\r\n&lt;contextListener&gt; 子节点\r\n\r\n作用：用于在 Logback\r\n的上下文（Context）发生某些事件时执行特定的逻辑。比如在 Logback\r\n初始化完成、配置重新加载等事件发生时，可以通过 ContextListener\r\n来执行一些自定义操作。\r\n示例：定义一个\r\nContextListener（具体实现类需自定义）\r\n&lt;contextListener class=&quot;com.example.MyContextListener&quot; /&gt;\r\n这里 class 属性指定了 ContextListener\r\n的实现类。\r\n\r\n&lt;contextName&gt; 设置上下文名称\r\n\r\n作用：在 Logback\r\n中，&lt;contextName&gt; 用于设置日志上下文（Logger\r\nContext）的名称。每个 Logger\r\n都属于一个特定的上下文，默认情况下，这个上下文名称是\r\n“default”。通过自定义上下文名称，可以实现一些功能。一旦设置，不能修改，可以通过%contextName来打印日志上下文名称，一般来说我们不用这个属性，可有可无。\r\n关键特性：\r\n\r\n唯一性：每个 Logger\r\n上下文必须有唯一的名称。若多个应用使用相同名称，可能导致日志配置冲突。\r\n不可修改：上下文名称一旦在配置文件中设置，运行时无法修改。如需动态调整，需通过编程方式（如\r\nJava 代码）重新初始化 Logger 上下文。\r\n与 Spring Boot 集成：Spring Boot 默认使用\r\nspring.application.name 作为上下文名称（通过\r\nLogbackLoggingSystem 自动配置），无需手动设置。例如：\r\n\r\n示例：\r\n在 logback.xml 中设置上下文名称\r\n&lt;configuration&gt;    &lt;!-- 设置上下文名称为 myApp --&gt;    &lt;contextName&gt;myApp&lt;/contextName&gt;        &lt;!-- 配置 Appender，在日志格式中包含 %contextName --&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%contextName] [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;        &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;\r\n输出示例：\r\n2025-05-28 10:30:00 [myApp] [main] INFO  com.example.MyService - 服务启动成功\r\n\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","日志与调试","Spring Boot","Java框架","配置相关"]},{"title":"SpringFrameworkPart9-Bean的管理方式总结","url":"/posts/47294.html","content":"Bean配置概述\r\n配置文件\r\nSpring 的配置文件是用于指导 Spring 工厂进行 Bean\r\n的生产、依赖关系注入及 Bean\r\n实例分发的“图纸”，是Spring的基础。如果我们没有配置文件的话，则Spring的容器将无从谈起。\r\n它是一个或多个标准的XML文档，其ApplicationContext.xml是Spring的默认配置文件，当容器启动时找不到其他的配置文件时，则会尝试加载这个默认的配置文件。\r\nSpring容器成功启动需要以下三方面的条件同时具备：\r\n\r\nSpring的类包必须已经放在Spring的类容器下面\r\n应用程序应当为Spring提供完备的Bean的配置信息\r\nBean的类都已经放在Spring的类容器下面\r\n\r\nSpring启动时读取应用程序提供的Bean的配置信息，并在Spring容器中生成一份相应的Bean的配置注册表，然后根据这张注册表来实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。\r\n而bean的配置信息就是Bean的元数据信息，他由以下五个方面来组成：\r\n\r\nBean的实现类\r\nBean的属性信息 比如：数据源的连接数，用户名和密码等等。\r\nBean的依赖关系 Spring根据依赖关系配置完成Bean之间的装配\r\nBean的行为配置\r\n比如：生命周期范围以及生命周期各个过程的回调函数等\r\nBean的创建方式定义 主要说明是通过构造器还是工厂方法来构造Bean\r\n\r\n基础的Bean操作示例\r\n最基础的bean配置如下：\r\n&lt;bean id=&quot;bean_test&quot; class=&quot;cn.qtone.test.HelloWorld&quot;&gt;&lt;/bean&gt;\r\n这是最基础的 Bean\r\n配置，使用了默认的构造方法来实例化HelloWorld类。相当于在\r\nJava 代码中使用new HelloWorld()来创建对象。\r\n获取 Bean 实例\r\n// 1.创建Spring IOC容器对象，ApplicationContext表示容器，是一个接口，ClassPathXmlApplicationContext是ApplicationContext的一个实现类// 传入配置文件名ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 2.利用id定位到IOC容器中的bean，获取bean实例HelloWorld hw = (HelloWorld)ctx.getBean(&quot;helloWorld&quot;);//传入id\r\n这里首先创建了一个ClassPathXmlApplicationContext对象，它会加载指定的配置文件applicationContext.xml。然后通过getBean方法，根据\r\nBean 的 id 获取对应的实例\r\n默认情况下，Spring 中的 Bean\r\n是单例的，在spring配置中的整个应用期间只有一个实例，当然这个单例是指对一个IOC容器（spring）来说的，当然，spring也可以这样配置不是单态的实例，比如可以通过scope属性来修改\r\nBean 的作用域\r\n&lt;bean id=&quot;bean_test&quot; class=&quot;cn.qtone.test.HelloWorld&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\r\n将scope设置为prototype后，每次从 Spring\r\n容器中获取HelloWorld的实例时，都会创建一个新的对象，即我们所说的原型。spring\r\n中 scope 默认的是单态（singleton），除了prototype，Spring\r\n还支持其他作用域，如request、session等，具体使用哪种作用域取决于应用程序的需求\r\n如果HelloWorld类没有空的构造方法，而是有带参数的构造方法，如下所示\r\npublic HelloWorld(String str)&#123;    ……&#125;public HelloWorld(Date date, int i)&#123;    ……&#125;\r\n那么在配置 Bean\r\n时需要指定构造参数，使用&lt;constructor-arg&gt;标签来指定构造函数的参数值，可以按照参数的顺序依次配置：\r\n&lt;bean id=&quot;bean_date&quot; class=&quot;java.util.Date&quot; /&gt;&lt;!-- 使用二个参数的构造 --&gt;&lt;bean id=&quot;bean_test&quot; class=&quot;cn.qtone.test.HelloWorld&quot; scope=&quot;prototype&quot;&gt;    &lt;constructor-arg ref=&quot;bean_date&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg&gt;&lt;value&gt;345&lt;/value&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\r\n在这个例子中，第一个参数是通过ref引用了另一个配置好的\r\nBean（bean_date），第二个参数是直接指定了一个整数值。\r\n当然，这样对简单的构造来说不会有什么问题，如果情况比较复杂的话，那么一般建议使用序号来标定，如下：\r\n&lt;!-- 使用二个参数的构造 --&gt;&lt;bean id=&quot;bean_test&quot; class=&quot;cn.qtone.test.HelloWorld&quot; scope=&quot;prototype&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; ref=&quot;bean_date&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg index=&quot;1&quot;&gt;&lt;value&gt;345&lt;/value&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\r\nBean的配置框架\r\n\r\n配置形式\r\n\r\n基于 xml 文件\r\n基于注解\r\n基于特定的 Java 类提供 Bean 定义信息\r\n\r\n配置方式\r\n\r\n通过全类名(反射)\r\n通过工厂方法(静态工厂方法、实例工厂方法)\r\nFactoryBean\r\n\r\n依赖注入方式\r\n\r\n属性注入\r\n构造器注入\r\n\r\n\r\nBean的基础配置\r\n在Spring中，Bean的基础配置主要通过XML文件定义，核心元素包括：\r\n\r\n&lt;bean&gt;标签：定义Bean的基本信息。\r\n\r\nid属性：Bean的唯一标识符，用于在容器中查找Bean。\r\nclass属性：Bean的全限定类名（包名+类名），Spring通过反射实例化该类。\r\nscope属性：定义Bean的作用域（如singleton、prototype等），默认是单例模式。\r\n\r\n\r\nBean基础配置\r\n在 Spring 框架中，Bean 是由 Spring IOC\r\n容器管理的对象。通过 XML 配置文件或注解，可以定义 Bean\r\n的创建方式、依赖关系和生命周期。\r\n&lt;bean id=&quot;beanName&quot; class=&quot;com.example.MyClass&quot;&gt;&lt;/bean&gt;\r\n\r\nid：Bean 的唯一标识符，用于从容器中获取实例。\r\nclass：Bean 的全限定类名，指定要实例化的 Java\r\n类。\r\n\r\n\r\n\r\nimage-20250521143614049\r\n\r\n在Spring容器的配置文件中定义一个简要Bean的配置片段如下所示：\r\n\r\n\r\nimg\r\n\r\n一般情况下，Spring\r\nIOC容器中的一个Bean即对应配置文件中的一个&lt;bean&gt;，这种镜像对应关系应该容易理解。其中id为这个Bean的名称，通过容器的getBean(\"foo\")即可获取对应的Bean，在容器中起到定位查找的作用，是外部程序和Spring\r\nIOC容器进行交互的桥梁。class属性指定了Bean对应的实现类。\r\nBean别名配置\r\n在实际开发中，一个 Bean\r\n可能需要多个名称（别名），方便在不同场景下引用。Spring\r\n提供了两种方式配置别名：\r\n\r\n使用&lt;alias&gt;标签\r\n&lt;bean id=&quot;userService&quot; class=&quot;com.example.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;&lt;alias name=&quot;userService&quot; alias=&quot;service1&quot; /&gt;&lt;alias name=&quot;userService&quot; alias=&quot;service2&quot; /&gt;\r\n\r\nname：原 Bean 的 id 或名称。\r\nalias：新的别名。\r\n\r\n在&lt;bean&gt;标签内使用name属性\r\n&lt;bean id=&quot;userService&quot;       name=&quot;service1, service2, service3&quot;       class=&quot;com.example.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;\r\n\r\nname：可以指定多个别名，用逗号、空格或分号分隔。\r\n\r\n\r\n\r\nimage-20250521150035174\r\n\r\n\r\nBean作用范围配置\r\nBean 的作用域决定了 Spring 如何创建和管理 Bean\r\n实例。通过scope属性可以指定 Bean 的作用域类型：\r\npackage com.example;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.example.dao.BookDao;public class AppForScope &#123;    public static void main(String[] args) &#123;        // 创建Spring的IOC容器，加载配置文件applicationContext.xml        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        // 从容器中获取id为&quot;bookDao&quot;的BookDao实例        BookDao bookDao1 = (BookDao) ctx.getBean(&quot;bookDao&quot;);        // 再次从容器中获取id为&quot;bookDao&quot;的BookDao实例        BookDao bookDao2 = (BookDao) ctx.getBean(&quot;bookDao&quot;);        // 打印两个实例，用于对比是否为同一个实例        System.out.println(bookDao1);        System.out.println(bookDao2);        // 比较两个实例是否相等，验证单例特性        System.out.println(&quot;两个实例是否相等：&quot; + (bookDao1 == bookDao2));    &#125;&#125;\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置BookDao的Bean，未指定scope，默认是单例模式 --&gt;    &lt;bean id=&quot;bookDao&quot; class=&quot;com.example.dao.BookDaoImpl&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n运行AppForScope类的main方法后，在控制台会看到类似如下输出：\r\ncom.example.dao.BookDaoImpl@12345678com.example.dao.BookDaoImpl@12345678两个实例是否相等：true\r\n这表明两次从 Spring\r\n容器中获取的bookDao实例是同一个对象,这就验证了在 Spring\r\n中，当不指定scope属性时，Bean\r\n的默认作用域是单例，即整个应用中只有一个该 Bean\r\n的实例，多次获取得到的都是同一个实例。\r\n为什么 Bean 默认为单例？\r\n\r\n其实很简单，如果对象不复用，就是 Spring 的 Bean\r\n容器压力就很容易很大\r\n\r\n单例模式：默认\r\n&lt;bean id=&quot;userService&quot; class=&quot;com.example.service.UserServiceImpl&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;\r\n\r\n特性：每个 Spring\r\n容器中只创建一个实例，所有请求共享该实例。\r\n适用场景：无状态的服务类、工具类等（如\r\nDAO、Service）。\r\n\r\n单例 Bean\r\n如果包含可变状态（如成员变量），可能存在线程安全问题。推荐单例 Bean\r\n设计为无状态对象（如 Service\r\n层，DAO层），有状态对象使用prototype作用域。\r\n\r\n\r\n原型模式（Prototype）\r\n&lt;bean id=&quot;user&quot; class=&quot;com.example.entity.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\r\n\r\n特性：每次请求都创建新的实例（类似new User()）。\r\n适用场景：有状态的对象（如实体类、需要保存会话数据的类）。\r\n\r\nWeb\r\n环境下的作用域（需 WebApplicationContext 支持）\r\n&lt;!-- 每个HTTP请求创建一个实例 --&gt;&lt;bean id=&quot;requestBean&quot; class=&quot;com.example.RequestBean&quot; scope=&quot;request&quot;&gt;&lt;/bean&gt;&lt;!-- 每个HTTP会话创建一个实例 --&gt;&lt;bean id=&quot;sessionBean&quot; class=&quot;com.example.SessionBean&quot; scope=&quot;session&quot;&gt;&lt;/bean&gt;&lt;!-- 全局Web应用上下文共享一个实例 --&gt;&lt;bean id=&quot;applicationBean&quot; class=&quot;com.example.ApplicationBean&quot; scope=&quot;application&quot;&gt;&lt;/bean&gt;\r\n\r\nrequest：每个 HTTP 请求独享一个实例。\r\nsession：每个用户会话（Session）独享一个实例。\r\napplication：整个 Web 应用共享一个实例（类似\r\nServletContext）。\r\n\r\n使用自定义作用域（如线程作用域）\r\n&lt;bean id=&quot;threadScopeBean&quot; class=&quot;com.example.ThreadScopeBean&quot; scope=&quot;thread&quot;&gt;    &lt;aop:scoped-proxy /&gt; &lt;!-- 必须添加代理，否则会报错 --&gt;&lt;/bean&gt;\r\n\r\nthread：每个线程独享一个实例。\r\n需额外配置：注册自定义作用域处理器（如SimpleThreadScope）。\r\n\r\nBean基于注解的配置\r\n我们知道，Spring容器成功启动的三大要件分别是：Bean定义信息、Bean实现类以及Spring本身。如果采用基于XML的配置，Bean定义信息和Bean实现类本身是分离的，而采用基于注解的配置方式时，Bean定义信息即通过在Bean实现类上标注注解实现。\r\n下面是使用注解定义一个DAO的Bean\r\npackage com.baobaotao.anno; import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;//通过@Component定义一个Bean @Component(&quot;userDao&quot;)public class UserDao &#123; &#125;\r\n我们使用@Component注解在UserDao类声明处对类进行标注，它可以被Spring容器识别，Spring容器自动将POJO转换为容器管理的Bean。它和以下的XML配置是等效的：\r\n&lt;bean id=&quot;userDao&quot; class=&quot;com.baobaotao.anno.UserDao&quot;/&gt;\r\n组件扫描与自动装配\r\nSpring 通过组件扫描（Component\r\nScanning）自动发现应用中定义的\r\nBean，并通过自动装配（Auto-wiring）注入依赖关系。\r\n首先，在 XML 配置文件的根元素``中声明了 context 命名空间：\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd                            http://www.springframework.org/schema/context                            http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;\r\n这里通过xmlns:context声明了 context 命名空间\r\n使用组件扫描可以不必在Spring的配置文件中配置各个&lt;bean/&gt;节点\r\n使用&lt;context:component-scan&gt;标签来指定需要扫描的基类包：\r\n&lt;context:component-scan base-package=&quot;com.stonegeek&quot; /&gt;\r\nbase-package表示需要扫描的“根包”,当配置后，Spring容器会自动扫描根包下所有类，及各及子包类。\r\n如果只想扫描特定的类而不是基包下的所有类，可以使用resource-pattern属性：\r\n&lt;context:component-scan base-package=&quot;com.baobaotao&quot; resource-pattern=&quot;anno/*.class&quot;/&gt;\r\n这里将基类包设置为com.baobaotao，并将resource-pattern属性的值设置为anno/*.class，表示\r\nSpring\r\n仅会扫描com.baobaotao包下的anno子包中的类。默认情况下，resource-pattern属性的值为**/*.class，即扫描基类包及其所有子包中的所有类。\r\n以上 xml\r\n配置的目的是：让Spring知道有哪些类，事实上，只是配置组件扫描，Spring并不会创建这些类的对象。如需要Spring创建某些类的对象，还需要为这些类添加注解！\r\n关键注解\r\n\r\n@Component\r\n\r\n作用：标记一个类为 Spring\r\n组件，使其被自动扫描并注册为 Bean。\r\n场景：通用的组件标记，适用于任何 Spring\r\n管理的类。\r\n\r\n@ComponentScan\r\n\r\n作用：指定 Spring 扫描组件的包路径。\r\n位置：通常在配置类上使用。\r\n@Configuration@ComponentScan(basePackages = &quot;com.example&quot;)public class AppConfig &#123;    // 配置类&#125;\r\n\r\n@Autowired\r\n\r\n作用：自动注入依赖，支持构造器、字段、方法注入。\r\n原理：默认按类型（byType）匹配，若存在多个候选\r\nBean，需结合@Qualifier指定名称。\r\n@Componentpublic class UserController &#123;    @Autowired    private UserService userService; // 字段注入&#125;\r\n\r\n@Repository\r\n\r\n作用：标记数据访问层（DAO）组件，提供持久化异常转换。\r\n\r\n\r\n\r\n场景：通常用于数据库操作类。\r\n\r\n\r\n@Service\r\n\r\n作用：标记服务层组件，处理业务逻辑。\r\n场景：Service 层类。\r\n\r\n@Controller\r\n\r\n作用：标记 Web 控制器，处理 HTTP 请求。\r\n场景：Spring MVC 的控制器类。\r\n\r\n@RestController\r\n\r\n作用：@Controller +\r\n@ResponseBody的组合，直接返回 JSON/XML 数据。\r\n场景：RESTful API 开发。\r\n\r\n@Qualifier\r\n\r\n作用：当存在多个同类型的 Bean\r\n时，通过名称指定具体注入的 Bean。\r\n@Servicepublic class OrderService &#123;    @Autowired    @Qualifier(&quot;paypalPaymentProcessor&quot;) // 指定使用名称为paypalPaymentProcessor的Bean    private PaymentProcessor paymentProcessor;&#125;\r\n\r\n@Conditional\r\n\r\n作用：根据自定义条件决定是否创建 Bean。\r\n@Configurationpublic class AppConfig &#123;    @Bean    @Conditional(OnProductionEnvironment.class) // 自定义条件    public DataSource productionDataSource() &#123;        // 生产环境数据源    &#125;&#125;\r\n\r\n\r\nBean基于 Java Config\r\n类的配置\r\n除了组件扫描，还可以通过配置类手动定义 Bean：\r\n@Configuration\r\n\r\n作用：表明该类是一个用于定义 Bean 的配置类。，替代\r\nXML 配置文件。\r\n场景：定义 JavaConfig 类。\r\n\r\n@Bean\r\n\r\n作用：在配置类中定义 Bean，相当于 XML\r\n中的&lt;bean&gt;标签。\r\n场景：创建第三方库的 Bean 或复杂初始化的\r\nBean。\r\n@Configurationpublic class AppConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new DriverManagerDataSource(&quot;jdbc:mysql://localhost:3306/mydb&quot;, &quot;user&quot;, &quot;pass&quot;);    &#125;&#125;\r\nBean\r\n的类型由方法返回值类型决定，名称默认和方法名相同，也可以通过name属性显式指定。例如：\r\n@Bean(name=&quot;userDao&quot;)public UserDao userDao()&#123;   return new UserDao();    &#125;\r\n\r\n在普通的POJO类中只要标注@Configuration注解，就可以为spring容器提供Bean定义的信息了，每个标注了@Bean的类方法都相当于提供了一个Bean的定义信息。\r\n举例：\r\npackage com.example.config;import com.example.dao.UserDao;import com.example.dao.UserDaoImpl;import com.example.service.UserService;import com.example.service.UserServiceImpl;import org.springframework.context.annotation.Bean; // Bean 定义注解import org.springframework.context.annotation.Configuration; // 配置类注解@Configuration // 标记为 Spring 配置类（替代 XML 配置文件）public class AppConfig &#123;    // ====================== Bean 定义 ======================    /**     * 定义 UserDao Bean（单例，默认作用域）     * - @Bean 声明该方法返回一个 Bean     * - 方法名 userDao() 作为 Bean 的默认名称（等价于 XML 中的 &lt;bean id=&quot;userDao&quot; ...&gt;）     */    @Bean    public UserDao userDao() &#123;        System.out.println(&quot;创建 UserDao Bean&quot;);        return new UserDaoImpl(); // 实例化逻辑    &#125;    /**     * 定义 UserService Bean，并注入 UserDao 依赖     * - 通过方法调用 userDao() 获取已定义的 Bean（自动装配）     * - 等价于 XML 中的 &lt;bean id=&quot;userService&quot; class=&quot;...&quot;&gt; 并通过 &lt;property&gt; 注入     */    @Bean    public UserService userService() &#123;        System.out.println(&quot;创建 UserService Bean&quot;);        // 直接调用 userDao() 方法获取依赖的 Bean（无需 @Autowired）        UserService userService = new UserServiceImpl(userDao());         return userService;    &#125;    // ====================== 进阶：带参数的 Bean 定义 ======================    // 示例：定义带参数的 Bean（模拟构造器参数注入）    @Bean    public UserDao customUserDao(String username) &#123;        UserDaoImpl dao = new UserDaoImpl();        // 假设 UserDaoImpl 有业务方法设置参数（非必须，仅演示）        dao.setUsername(username); // 模拟设置参数        return dao;    &#125;    // 调用方式：context.getBean(&quot;customUserDao&quot;, &quot;Alice&quot;);&#125;\r\npackage com.example;import com.example.config.AppConfig;import com.example.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class MainApp &#123;    public static void main(String[] args) &#123;        // ====================== 启动 Spring 容器 ======================        // 使用 AnnotationConfigApplicationContext 加载 Java 配置类        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);        System.out.println(&quot;Spring 容器启动完成\\n&quot;);        // ====================== 获取 Bean 并验证 ======================        // 获取 UserService Bean（自动装配了 UserDao）        UserService userService = ctx.getBean(UserService.class);        String result = userService.getFormattedUsername();        System.out.println(&quot;调用 UserService 结果：&quot; + result); // 输出: Hello, John Doe        // 验证 Bean 作用域（单例）：两次获取同一 Bean，实例相同        UserService userService1 = ctx.getBean(UserService.class);        UserService userService2 = ctx.getBean(UserService.class);        System.out.println(&quot;Bean 是否为单例：&quot; + (userService1 == userService2)); // 输出: true    &#125;&#125;\r\nBean的实例化\r\n首先讲一下什么是 Bean的实例化 什么是 Bean的依赖注入\r\nBean 的实例化\r\n\r\n定义：Bean 的实例化是指创建一个 Bean\r\n对象的过程，即将一个类的定义转化为在内存中实际存在的对象。\r\n过程：在 Spring 中，Bean\r\n的实例化可以通过多种方式实现，例如使用构造函数、静态工厂方法或实例工厂方法。Spring\r\n容器负责管理 Bean 的生命周期，包括实例化、初始化和销毁。\r\n\r\nBean 的依赖注入 DI\r\n\r\n定义：依赖注入（Dependency Injection，简称\r\nDI）是一种设计模式，它允许将一个对象的依赖关系（即该对象所依赖的其他对象）通过外部方式（如配置文件或注解）注入到对象中，而不是在对象内部自行创建依赖对象。\r\n目的：通过依赖注入，可以实现对象之间的解耦，提高代码的可维护性和可测试性。\r\n方式：Spring\r\n支持多种依赖注入方式，主要包括构造函数注入、Setter\r\n方法注入和字段注入。\r\n\r\n其中这俩的区别就很明显了：\r\n\r\n关注点不同\r\n\r\n实例化：主要关注如何创建一个对象。\r\n依赖注入：关注如何将对象所依赖的其他对象传递给该对象。\r\n\r\n作用不同\r\n\r\n实例化：是创建对象的基础步骤，为对象的使用做好准备。\r\n依赖注入：实现了对象之间的解耦，使对象的依赖关系更加清晰和灵活。\r\n\r\n\r\nBean的实例化之构造方法\r\nBean的实例化就是Bean是如何创建出来的，Bean本质上就是对象，创建Bean也可以使用构造方法来完成\r\n这个方法是最开始接触Spring时使用的创建对象的方式，只需要在Spring.xml文件配置\r\nBean 标签中配置，然后在\r\ntest方法中直接通过ApplicationContext调用getbean()方法；这是在底层调用了反射技术创建对象；\r\nSpring 默认通过反射调用类的无参构造方法实例化\r\nBean。若类没有无参构造方法，需显式指定构造参数。\r\n配置方式：在 XML 中使用\r\n&lt;constructor-arg&gt; 标签定义构造参数。\r\n\r\n无参构造方法（默认）没有任何变化\r\n&lt;bean id=&quot;helloWorld&quot; class=&quot;cn.qtone.test.HelloWorld&quot; /&gt;\r\n等价于 Java 代码\r\nHelloWorld helloWorld = new HelloWorld(); // 反射调用无参构造\r\n带参构造方法\r\n假设 HelloWorld 类有以下构造方法：\r\npublic HelloWorld(String message, int priority) &#123;    this.message = message;    this.priority = priority;&#125;\r\n&lt;bean id=&quot;helloWorld&quot; class=&quot;cn.qtone.test.HelloWorld&quot;&gt;    &lt;constructor-arg value=&quot;Hello Spring!&quot; /&gt;       &lt;!-- 按顺序注入字符串 --&gt;    &lt;constructor-arg value=&quot;1&quot; /&gt;                   &lt;!-- 按顺序注入整数 --&gt;&lt;/bean&gt;&lt;!--或通过索引明确参数位置--&gt;&lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot; /&gt;&lt;constructor-arg index=&quot;1&quot; value=&quot;1&quot; /&gt;\r\n\r\nBean的实例化之静态工厂\r\n当 Bean\r\n的创建逻辑复杂（如需要条件判断、缓存等），可将实例化逻辑封装在静态工厂方法中\r\n通过 factory-method 指定静态工厂方法名。\r\n在使用静态工厂实例化Bean时要求开发者在工厂类中创建一个静态方法来创建\r\nBean 的实例。在配置 Bean 时，class属性指定静态工厂类，同时还需要使用\r\nfactory-method 属性指定工厂类中的静态方法\r\n定义静态工厂\r\npublic class HelloWorldFactory &#123;    // 静态工厂方法    public static HelloWorld createHelloWorld(String message) &#123;        HelloWorld helloWorld = new HelloWorld();        helloWorld.setMessage(message);        return helloWorld;    &#125;&#125;\r\nxml 配置\r\n&lt;bean id=&quot;helloWorld&quot;       class=&quot;spring6.ergoutree.test.HelloWorldFactory&quot;  &lt;!-- 工厂类全限定名 --&gt;      factory-method=&quot;createHelloWorld&quot;&gt;       &lt;!-- 静态方法名 --&gt;    &lt;constructor-arg value=&quot;From Static Factory&quot; /&gt;  &lt;!-- 工厂方法参数 --&gt;&lt;/bean&gt;\r\n获取 Bean\r\nApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);HelloWorld hw = (HelloWorld) ctx.getBean(&quot;helloWorld&quot;);System.out.println(hw + hw.message);\r\nBean 的实例化之实例工厂\r\n实例工厂是指通过一个已存在的实例对象的方法来创建 Bean 实例。\r\n与静态工厂实例方法类似，但是方法是实例方法，在bean的参数额外多了一个\r\nfactory-bean属性标签，用以区分是实例的。\r\n从 spring 容器中获取配置了 factory-method的 bean\r\n对象时， spring 会自动执行实例工厂的创建对象的方法来返回另一个 bean\r\n对象。\r\n实例工厂方法创建的bean，spring可以管理其生命周期。因为实例工厂bean本身是spring容器管理的bean。\r\n效果：用 getBean 获取配置了 factory-method 的 bean\r\n对象时，返回的是另一个 bean 对象\r\n\r\n与静态工厂的区别： 静态工厂通过类静态方法创建\r\nBean，而实例工厂需要先创建工厂类的实例，再通过该实例的普通方法创建目标\r\nBean。\r\n适用场景： 当工厂类本身需要依赖注入或需要 Spring\r\n管理其生命周期时使用。\r\n\r\n工厂类定义\r\npublic class UserFactory &#123;    // 实例工厂方法（非静态）    public User createUser(String name, int age) &#123;        User user = new User();        user.setName(name);        user.setAge(age);        return user;    &#125;&#125;\r\nXML 配置\r\n&lt;!-- 1. 先声明工厂类的Bean --&gt;&lt;bean id=&quot;userFactory&quot; class=&quot;com.example.UserFactory&quot; /&gt;&lt;!-- 2. 通过工厂实例的方法创建目标Bean --&gt;&lt;bean id=&quot;user&quot;       factory-bean=&quot;userFactory&quot;   &lt;!-- 引用工厂Bean --&gt;      factory-method=&quot;createUser&quot;&gt; &lt;!-- 工厂方法名 --&gt;    &lt;constructor-arg value=&quot;Alice&quot; /&gt;  &lt;!-- 方法参数 --&gt;    &lt;constructor-arg value=&quot;25&quot; /&gt;&lt;/bean&gt;\r\n\r\nid为userFactory的 Bean\r\n定义了实例工厂对象。\r\nid为user的 Bean\r\n通过factory-bean属性指定了使用userFactory这个实例工厂，通过factory-method属性指定了调用createProduct方法来创建user对象。\r\n\r\n获取 Bean\r\nApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);User user = (User) ctx.getBean(&quot;user&quot;);\r\nBean的实例化之FactoryBean\r\nFactoryBean是一个接口，实现了该接口的类可以作为一个工厂来创建\r\nBean 实例。用于定制化复杂 Bean 的创建过程。当 Bean\r\n的实例化逻辑非常复杂（如需要多步骤初始化）时，可通过实现\r\nFactoryBean 接口封装逻辑。\r\nSpring 容器在创建使用FactoryBean的 Bean\r\n时，会调用FactoryBean的getObject方法来获取实际的\r\nBean 实例。\r\n通过 getBean(\"factoryBeanName\") 获取的是\r\nFactoryBean 创建的目标对象，而非\r\nFactoryBean 本身。若需获取 FactoryBean 实例，需在 Bean 名前加\r\n&amp;（如\r\ngetBean(\"&amp;factoryBeanName\")）。\r\n实现 FactoryBean 接口：重写\r\ngetObject(), getObjectType(),\r\nisSingleton() 方法。\r\nimport org.springframework.beans.factory.FactoryBean;public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123;    private String name;    private int age;    // 依赖注入（可选）    public void setName(String name) &#123; this.name = name; &#125;    public void setAge(int age) &#123; this.age = age; &#125;    @Override    public User getObject() throws Exception &#123;        // 复杂创建逻辑（如连接数据库、解析配置文件等）        User user = new User();        user.setName(name);        user.setAge(age);        user.setRole(&quot;ADMIN&quot;);  // 假设需要额外处理        return user;    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return User.class;    &#125;    @Override    public boolean isSingleton() &#123;        return true;  // 单例模式    &#125;&#125;\r\nXML 配置\r\n&lt;!-- 注册 FactoryBean --&gt;&lt;bean id=&quot;userFactoryBean&quot; class=&quot;com.example.UserFactoryBean&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;Bob&quot; /&gt;    &lt;property name=&quot;age&quot; value=&quot;30&quot; /&gt;&lt;/bean&gt;\r\n获取 Bean\r\n// 获取 FactoryBean 创建的目标对象（User）User user = (User) ctx.getBean(&quot;userFactoryBean&quot;);// 获取 FactoryBean 实例本身UserFactoryBean factoryBean = (UserFactoryBean) ctx.getBean(&quot;&amp;userFactoryBean&quot;);\r\nFactoryBean只需要在配置文件中定义其本身即可，Spring\r\n会自动识别并调用其getObject方法来创建 Bean。\r\nBean的依赖注入\r\n依赖注入，英文叫做 Dependency Injection，简称 DI。\r\nDI 和 IoC （《Spring IoC\r\n容器详解》）含义相同，它们是从两个角度描述的同一个概念、做同一件事情。\r\n当某个 Java 实例需要另一个 Java 实例时，使用 Spring\r\n之前都是由调用者创建（使用 new\r\n关键字获得被调用者实例）被调用者的实例，而使用 Spring\r\n框架后，被调用者的实例不再由调用者创建，而是由 Spring IoC\r\n容器创建，这称为控制反转，也即 IoC。\r\nSpring IoC\r\n容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过\r\nSpring IoC 容器获得被调用者实例，这称为依赖注入，也即 DI。\r\nBean 的依赖注入方式，或叫 Bean\r\n的装配方式，有多种形式，比如接下来要介绍的基于 XML\r\n的依赖注入（有两种实现方式：Setter Injection 属性注入和 Constructor\r\nInjection 构造器注入）、基于 Annotation\r\n的依赖注入、基于自动装配、基于静态工厂的方式的依赖注入和基于实例工厂的方式的依赖注入等。\r\nSetter注入(属性注入)\r\n属性注入即通过setXxx()方法注入Bean的属性值或依赖对象，由于属性注入方式具有可选择性和灵活性高的优点，因此属性注入是实际应用中最常采用的注入方式。\r\n指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参\r\nstatic 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于\r\nsetter 的 DI。\r\n属性注入要求Bean提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法。Spring先调用Bean的默认构造函数实例化Bean对象，然后通过反射的方式调用Setter方法注入属性值。\r\n\r\n必须提供无参构造器：Spring 通过无参构造器实例化\r\nBean。\r\n必须为属性提供 Setter\r\n方法：格式为setXxx()，其中Xxx是属性名的驼峰写法。\r\n\r\npublic class UserService &#123;    // 声明需要注入的依赖对象。    private UserDao userDao; // 依赖对象    // 无参构造器（必须）    // Spring 通过无参构造器实例化 Bean：    public UserService() &#123;&#125;    // Setter方法（必须）\t// 格式必须为setXxx()，其中Xxx是属性名的驼峰写法        public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\r\nxml 配置\r\n&lt;bean id=&quot;userDao&quot; class=&quot;com.example.dao.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.example.service.UserService&quot;&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 通过setUserDao注入 --&gt;&lt;/bean&gt;\r\n这相当于 Spring 会执行\r\nservice.setUserDao(applicationContext.getBean(&quot;userDao&quot;)); // 后注入\r\n注解配置示例\r\n@Componentpublic class UserService &#123;    private UserDao userDao;    @Autowired // 可省略，Setter注入非必须    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\r\n作为 Spring\r\n核心机制的依赖注入，改变了传统的编程习惯，对组件的实例化不再由应用程序完成，转而交由\r\nSpring\r\n容器完成，在需要时注入应用程序中，从而对组件之间依赖关系进行了解耦。这一切都离不开\r\nSpring 配置文件中使用的 &lt;bean&gt;元素。\r\nSpring 容器可以被看作一个大工厂，而 Spring 容器中的 Bean\r\n就相当于该工厂的产品。如果希望这个大工厂能够生产和管理\r\nBean，这时则需要告诉容器需要哪些 Bean，以及需要以何种方式将这些 Bean\r\n装配到一起。\r\nSpring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties\r\n文件格式。通常情况下，Spring 会以 XML 文件格式作为 Spring\r\n的配置文件，这种配置方式通过 XML 文件注册并管理 Bean\r\n之间的依赖关系。\r\n构造器注入\r\n使用构造函数注入的前提是Bean必须提供带参数的构造函数。例如\r\n\r\n通过构造器参数注入依赖对象。\r\n容器在实例化 Bean 时，直接通过带参构造器完成依赖注入，无需额外调用\r\nSetter 方法。\r\n\r\n注意条件\r\n\r\n必须提供带参构造器：参数类型与依赖对象匹配。\r\n依赖对象不可变：构造器注入的依赖通常被声明为final。\r\n\r\npublic class UserService &#123;    private final UserDao userDao; // 推荐使用final    // 带参构造器（必须）    public UserService(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\r\nxml 配置\r\n&lt;bean id=&quot;userDao&quot; class=&quot;com.example.dao.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.example.service.UserService&quot;&gt;    &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;!-- 通过构造器注入 --&gt;&lt;/bean&gt;\r\n等价于 Java 代码\r\nnew UserService(userDao); // 一步完成实例化和注入\r\n注解配置示例\r\n@Componentpublic class UserService &#123;    private final UserDao userDao;    // @Autowired 可省略（Spring 4.3+后，单参构造器默认注入）    public UserService(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\r\n工厂方法注入\r\n工厂方法注入是 Spring 依赖注入的一种方式，通过调用工厂类的方法创建\r\nBean 实例，分为两种类型：\r\n\r\n静态工厂方法注入：通过类的静态方法创建 Bean。\r\n实例工厂方法注入：通过工厂类的实例方法创建\r\nBean（需先创建工厂实例）。\r\n\r\n静态工厂注入\r\n\r\n特点：工厂方法为静态方法，无需创建工厂实例。\r\n适用场景：工厂类无需维护状态，仅提供创建逻辑。\r\n\r\n静态工厂注入就是我们编写一个静态的工厂方法，这个工厂方法会返回一个我们需要的值，然后在配置文件中，我们指定使用这个工厂方法创建bean。首先我们需要一个静态工厂，如下所示：\r\npublic class CarFactory &#123;    // 静态工厂方法：根据类型创建 Car 实例    public static Car createCar(String type) &#123;        if (&quot;electric&quot;.equals(type)) &#123;            return new ElectricCar();        &#125; else if (&quot;gasoline&quot;.equals(type)) &#123;            return new GasolineCar();        &#125;        throw new IllegalArgumentException(&quot;Unknown car type: &quot; + type);    &#125;&#125;\r\n\r\n静态方法：createCar是静态方法，无需创建CarFactory实例即可调用。\r\n\r\n普通工厂需要先创建工厂实例（如new CarFactory().createCar()），而静态工厂直接通过类名调用（如CarFactory.createCar()），更轻量。\r\n\r\n多态返回：根据传入参数（electric或gasoline）返回不同子类对象。\r\n\r\n下面我们需要在xml中配置car这个bean，并指定它由工厂方法进行创建。配置如下：\r\n通过 &lt;constructor-arg&gt; 向工厂方法传递参数。\r\n&lt;!-- 静态工厂方法配置 --&gt;&lt;bean id=&quot;electricCar&quot;       class=&quot;com.example.CarFactory&quot;        &lt;!-- 工厂类全限定名 --&gt;      factory-method=&quot;createCar&quot;&gt;           &lt;!-- 静态方法名 --&gt;    &lt;constructor-arg value=&quot;electric&quot; /&gt;    &lt;!-- 方法参数 --&gt;&lt;/bean&gt;&lt;bean id=&quot;gasolineCar&quot;       class=&quot;com.example.CarFactory&quot;       factory-method=&quot;createCar&quot;&gt;    &lt;constructor-arg value=&quot;gasoline&quot; /&gt;&lt;/bean&gt;\r\n\r\n&lt;constructor-arg&gt;标签：向静态方法传递参数（如\"electric\"）。\r\n\r\n获取 Bean\r\nApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);// 无需工厂实例：直接通过类名调用静态方法。Car electricCar = ctx.getBean(&quot;electricCar&quot;, Car.class); // ElectricCar 实例Car gasolineCar = ctx.getBean(&quot;gasolineCar&quot;, Car.class); // GasolineCar 实例\r\nSpring\r\n容器启动时，会直接调用CarFactory.createCar(\"electric\")，并将返回的ElectricCar实例注册为electricCar\r\nBean。通过Car.class指定返回类型，确保返回的对象符合预期\r\n非静态工厂注入：\r\n\r\n特点：需先创建工厂类的实例，再调用实例方法创建\r\nBean。\r\n适用场景：工厂类需要依赖其他 Bean 或维护状态。\r\n\r\n有些工厂方法是非静态的，即必须实例化工厂类后才能调用工厂方法。\r\npublic class UserFactory &#123;    private String defaultRole;    // 依赖注入：工厂类可被注入其他 Bean    public void setDefaultRole(String role) &#123;        this.defaultRole = role;    &#125;    // 实例工厂方法：创建 User 对象    public User createUser(String name) &#123;        User user = new User();        user.setName(name);        user.setRole(defaultRole); // 使用工厂类自身的属性        return user;    &#125;&#125;\r\n工厂类负责创建一个或多个目标类实例，工厂类方法一般以接口或抽象类变量的形式返回目标类实例，工厂类对外屏蔽了目标类的实例化步骤，调用者甚至不用知道具体的目标类是什么。\r\n&lt;!-- 1. 先创建工厂实例 --&gt;&lt;bean id=&quot;userFactory&quot; class=&quot;com.example.UserFactory&quot;&gt;    &lt;property name=&quot;defaultRole&quot; value=&quot;GUEST&quot; /&gt;  &lt;!-- 注入工厂属性 --&gt;&lt;/bean&gt;&lt;!-- 2. 通过工厂实例的方法创建目标 Bean --&gt;&lt;bean id=&quot;user1&quot;       factory-bean=&quot;userFactory&quot;  &lt;!-- 引用工厂实例 --&gt;      factory-method=&quot;createUser&quot;&gt; &lt;!-- 实例方法名 --&gt;    &lt;constructor-arg value=&quot;Alice&quot; /&gt;  &lt;!-- 方法参数 --&gt;&lt;/bean&gt;&lt;bean id=&quot;user2&quot;       factory-bean=&quot;userFactory&quot;       factory-method=&quot;createUser&quot;&gt;    &lt;constructor-arg value=&quot;Bob&quot; /&gt;&lt;/bean&gt;\r\n获取 Bean\r\nApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);User user1 = ctx.getBean(&quot;user1&quot;, User.class); // name=Alice, role=GUESTUser user2 = ctx.getBean(&quot;user2&quot;, User.class); // name=Bob, role=GUEST\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n静态工厂方法注入\r\n实例工厂方法注入\r\n\r\n\r\n\r\n\r\n工厂实例\r\n不需要（直接调用静态方法）\r\n需要（需先创建工厂 Bean）\r\n\r\n\r\n配置方式\r\nclass + factory-method\r\nfactory-bean + factory-method\r\n\r\n\r\n状态管理\r\n无法维护状态（无实例）\r\n可以维护状态（通过工厂 Bean 属性）\r\n\r\n\r\n依赖注入能力\r\n无法注入其他 Bean 到工厂类\r\n工厂类可以注入其他 Bean 或属性\r\n\r\n\r\n适用场景\r\n简单、无状态的创建逻辑\r\n复杂、需要依赖或状态管理的创建逻辑\r\n\r\n\r\n\r\n使用@Autowired进行自动注入\r\npring通过@Autowired注解实现Bean的依赖注入，下面是一个例子\r\npackage com.baobaotao.anno; import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;//① 定义一个Service的Bean（不需要在XML中定义Bean）@Servicepublic class LogonService implements BeanNameAware&#123;        //② 分别注入LogDao及UserDao的Bean（不需要在XML中定义property属性注入）    @Autowired(required=false)    private LogDao logDao;    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;        public LogDao getLogDao() &#123;        return logDao;    &#125;    public UserDao getUserDao() &#123;        return userDao;    &#125;        public void setBeanName(String beanName) &#123;        System.out.println(&quot;beanName:&quot;+beanName);            &#125;        public void initMethod1()&#123;        System.out.println(&quot;initMethod1&quot;);    &#125;    public void initMethod2()&#123;        System.out.println(&quot;initMethod2&quot;);    &#125;    &#125;\r\n在①处，我们使用@Service将LogonService标注为一个Bean，在②处，通过@Autowired注入LogDao及UserDao的Bean。@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入到@Autowired标注的变量中。\r\n使用@Autowired的required属性\r\n如果容器中没有一个和标注变量类型匹配的 Bean，Spring 容器启动时将报\r\nNoSuchBeanDefinitionException的异常。如果希望 Spring\r\n即使找不到匹配的 Bean\r\n完成注入也不用抛出异常，那么可以使用@Autowired(required=false)进行标注：\r\n@Servicepublic class LogonService implements BeanNameAware&#123;    @Autowired(required=false)    private LogDao logDao;        ...&#125;\r\n默认情况下，@Autowired的required属性的值为true，即要求一定要找到匹配的Bean，否则将报异常。\r\n使用@Qualifier指定注入Bean的名称\r\n如果容器中有一个以上匹配的Bean时，则可以通过@Qualifier注解限定Bean的名称，如下所示：\r\n@Servicepublic class LogonService implements BeanNameAware&#123;    @Autowired(required=false)    private LogDao logDao;    //①注入名为UserDao，类型为UserDao的Bean    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao;&#125;\r\n这里假设容器有两个类型为UserDao的Bean，一个名为userDao，另一个名为otherUserDao，则①处会注入名为userDao的Bean。\r\n对类方法进行标注\r\n@Autowired可以对类成员变量及方法的入参进行标注，下面我们在类的方法上使用@Autowired注解：\r\npackage com.baobaotao.anno; import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service; @Servicepublic class LogonService implements BeanNameAware&#123;        private LogDao logDao;    private UserDao userDao;            @Autowired    public void setLogDao(LogDao logDao) &#123;        this.logDao = logDao;    &#125;        @Autowired    @Qualifier(&quot;userDao&quot;)    public void setUserDao(UserDao userDao) &#123;        System.out.println(&quot;auto inject&quot;);        this.userDao = userDao;    &#125;    &#125;\r\n如果一个方法拥有多个入参，在默认情况下，Spring自动选择匹配入参类型的Bean进行注入。Spring允许对方法入参标注@Qualifier以指定注入Bean的名称，如下所示：\r\n@Autowired   public void init(@Qualifier(&quot;userDao&quot;)UserDao userDao,LogDao logDao)&#123;       System.out.println(&quot;multi param inject&quot;);       this.userDao = userDao;       this.logDao =logDao;   &#125;\r\n在以上例子中，UserDao的入参注入名为userDao的Bean，而LogDao的入参注入LogDao类型的Bean。\r\n一般情况下，在 Spring 容器中大部分的 Bean\r\n都是单实例的，所以我们一般都无须通过@Repository、@Service等注解的value属性为\r\nBean 指定名称，也无须使用@Qualifier按名称进行注入。\r\n集合注入\r\n数组注入\r\n&lt;property name=&quot;languages&quot;&gt;    &lt;array&gt;        &lt;value&gt;Java&lt;/value&gt;        &lt;value&gt;Python&lt;/value&gt;    &lt;/array&gt;&lt;/property&gt;\r\nList 注入\r\nXML 配置\r\n&lt;bean id=&quot;collectionBean&quot; class=&quot;com.example.CollectionBean&quot;&gt;    &lt;!-- 直接值注入 --&gt;    &lt;property name=&quot;stringList&quot;&gt;        &lt;list&gt;            &lt;value&gt;Java&lt;/value&gt;            &lt;value&gt;Spring&lt;/value&gt;            &lt;value&gt;Hibernate&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;        &lt;!-- Bean 引用注入 --&gt;    &lt;property name=&quot;beanList&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;serviceA&quot;/&gt;            &lt;ref bean=&quot;serviceB&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;\r\nJavaConfig 配置\r\n@Configurationpublic class AppConfig &#123;    @Bean    public CollectionBean collectionBean() &#123;        CollectionBean bean = new CollectionBean();        bean.setStringList(Arrays.asList(&quot;Java&quot;, &quot;Spring&quot;, &quot;Hibernate&quot;));        bean.setBeanList(Arrays.asList(serviceA(), serviceB()));        return bean;    &#125;        @Bean public ServiceA serviceA() &#123; return new ServiceA(); &#125;    @Bean public ServiceB serviceB() &#123; return new ServiceB(); &#125;&#125;\r\n注解自动装配\r\n@Componentpublic class CollectionBean &#123;    @Autowired    @Qualifier(&quot;techKeywords&quot;) // 指定特定 Bean    private List&lt;String&gt; stringList;        // 自动收集所有实现 Processor 接口的 Bean    @Autowired    private List&lt;Processor&gt; processors;&#125;\r\nSet 注入\r\nXML 配置\r\n&lt;property name=&quot;uniqueTags&quot;&gt;    &lt;set&gt;        &lt;value&gt;Backend&lt;/value&gt;        &lt;value&gt;Framework&lt;/value&gt;        &lt;value&gt;Backend&lt;/value&gt; &lt;!-- 重复值会被自动过滤 --&gt;    &lt;/set&gt;&lt;/property&gt;\r\nJavaConfig 配置\r\nbean.setUniqueTags(new LinkedHashSet&lt;&gt;(Arrays.asList(&quot;Backend&quot;, &quot;Framework&quot;)));\r\nMap 注入\r\nxml 配置\r\n&lt;property name=&quot;configMap&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;timeout&quot; value=&quot;5000&quot;/&gt;        &lt;entry key=&quot;maxConnections&quot; value=&quot;100&quot;/&gt;        &lt;entry key=&quot;cacheService&quot; value-ref=&quot;cacheService&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;\r\nJavaConfig 配置\r\nMap&lt;String, Object&gt; configMap = new HashMap&lt;&gt;();configMap.put(&quot;timeout&quot;, 5000);configMap.put(&quot;cacheService&quot;, cacheService());bean.setConfigMap(configMap);\r\nProperties 注入\r\nXML 配置\r\n&lt;property name=&quot;dbProperties&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;jdbc.url&quot;&gt;jdbc:mysql://localhost:3306/mydb&lt;/prop&gt;        &lt;prop key=&quot;jdbc.user&quot;&gt;root&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\r\nJavaConfig 配置\r\nProperties props = new Properties();props.setProperty(&quot;jdbc.url&quot;, &quot;jdbc:mysql://localhost:3306/mydb&quot;);bean.setDbProperties(props);\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架","知识总结"]},{"title":"Spring Boot part2-Spring Boot的依赖管理机制","url":"/posts/6704.html","content":"依赖管理\r\n依赖管理机制概述\r\n从 Spring 转到 Spring Boot 的最重大的改变应该就是，以前整合 Spring +\r\nMyBatis + SpringMVC\r\n我们需要写一大堆的配置文件，堪称配置文件地狱，我们还要在 pom.xml\r\n文件里引入各种类型的 jar 包，Mybatis 的、SpringMVC 的、Spring-aop\r\n的，Spring-context 等等。\r\n使用 SpringBoot\r\n后，新建一个项目几乎不需要做任何改动，我们就可以运行起来。pom\r\n文件里，我们只需要引入一个spring-boot-starter-web就可以，之前我们所做的一切，SpringBoot\r\n都在底层帮我们做了。\r\nSpring Boot 的依赖管理机制主要通过以下几个核心组件实现：\r\n\r\nParent POM（父 POM）：提供依赖版本管理\r\nStarter\r\nDependencies（启动器依赖）：预配置的依赖集合\r\nAuto-Configuration（自动配置）：基于类路径自动配置\r\nBean\r\nDependency Management Plugin：Gradle/Maven\r\n插件支持\r\n\r\n理解约定优于配置\r\n约定优于配置（Convention over Configuration /\r\nCoC）,又称约定编程，是一种软件设计规范，本质上是对系统，类库或框架中一些东西。\r\n总体来说，核心内容就是我们需要一个大众化合理的默认值（缺省值）\r\n简单来说就是假如你所期待的配置 与\r\n约定的配置\r\n一致，那么就可以不做任何配置，约定不符合期待时，才需要对约定进行替换配置。约定其实就是一个规范，遵循了规范，那么就存在通用性。存在了通用性，那么事情就会变得相对简单\r\n，程序员之间的沟通成本就会降低，工作效率会提升，合作也会变得更加简单。\r\n例如在模型中存在一个名为User的类，那么对应到数据库会存在一个名为 user\r\n的表，只有偏离这个约定时才需要做相关的配置（例如你想将表名命名为：t_user等非user时才需要写关于这个名字的配置）\r\n父项目所做的依赖管理\r\n开发什么场景，导入什么场景启动器，maven\r\n会根据依赖传递原则，自动把这个场景的所有核心依赖全部导入进来\r\nspring-boot-starter-parent\r\n如何进行依赖指定\r\n每个 Spring Boot 项目，pom.xml文件都会给我们定义一个 parent\r\n节点，它管理了大量常用依赖的版本。\r\n&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;\r\n该节点指定了version版本号，所以在 pom.xml\r\n文件里我们很多引入的依赖都没有定义版本号，但这样也不会出错，因为SpringBoot\r\n帮我们为一些常用的依赖默认指定了版本号。\r\n作用机制：\r\n\r\n预定义了数百个依赖的版本号\r\n提供了合理的资源过滤配置\r\n设置了插件配置\r\n提供了依赖管理（dependency management）\r\n\r\n进入spring-boot-starter-parent这个jar包，会发现它的父项目是spring-boot-dependencies\r\nSpring Boot 使用一个中央的 Maven pom 文件，通常称为 “Spring Boot\r\nDependencies POM”。这个 pom 文件定义了所有支持的库的版本，它充当所有\r\nSpring Boot 应用的父 pom 或者在 Gradle\r\n项目中通过插件方式引用。这样做的好处是：\r\n\r\n统一版本控制：通过在这个中心 POM\r\n中定义库版本，所有引入的库将默认使用这些版本，保证了依赖的一致性和兼容性。\r\n简化依赖声明：开发者在自己的项目 POM\r\n中引入依赖时，可以不必指定版本号。Maven 会自动根据父 POM\r\n文件解析正确的版本。\r\n\r\n自动版本仲裁与依赖版本覆盖\r\nspring-boot-dependencies还会进行自动版本仲裁，即如果程序员没有指定某个\r\n依赖的 jar 的版本，则以父项目指定的版本为准。\r\n&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; \r\n而在这个依赖里，就声明了很多开发中常用依赖的版本号\r\n所以在你 pom.xml 文件中引入 jar\r\n的时候，如果该依赖在spring-boot-dependencies中定义了版本号，那么你可以不写。如果你想使用其他的版本号，那么也可以在\r\npom.xml 中导入依赖时候定义 version，遵循就近原则。\r\n覆盖依赖版本\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt;\r\n使用 properties 指定版本号\r\n在某些情况下，为了方便管理多个依赖项的版本，你也可以在项目的\r\nproperties 部分中定义版本号，然后在依赖中引用这些属性：\r\n&lt;!-- 使用 properties 中定义的版本 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;    &lt;/dependency&gt;\r\n这种写法就是将依赖jar\r\n包的配置信息，和配置版本分开来编写\r\n\r\n在 &lt;properties&gt; 标签中，配置 jar\r\n的版本信息 ，可以配置多个不同的 jar 包的版本信息\r\n在 &lt;dependencies&gt; 标签中，配置 jar 的\r\n配置坐标信息 ，可以配置多个 jar\r\n\r\n\r\n\r\nimg\r\n\r\n依赖冲突的解决\r\n当不同的依赖项或 starters 引入了同一个库的不同版本时，Spring Boot\r\n依赖管理机制和构建工具的版本冲突解决策略会起作用：\r\n\r\nMaven：默认使用 “最近优先”\r\n策略，即项目依赖树中距离根最近的版本将被使用。\r\nGradle：默认也是使用 “最近优先”\r\n策略，但提供了更多配置选项来调整这一行为，例如强制使用某些版本。\r\n\r\nstarter场景启动器\r\nStarter 是 Spring Boot\r\n的核心概念，它将相关的依赖打包在一起，遵循”约定优于配置”的原则。\r\n一句话，开发什么场景，导入什么场景启动器，maven\r\n会根据依赖传递原则，自动把这个场景的所有核心依赖全部导入进来\r\n命名规范：\r\n\r\n官方 Starter：spring-boot-starter-*\r\n第三方 Starter：*-spring-boot-starter\r\n\r\nSpring Boot Starters 是预设的依赖描述符，当你在项目中引入任何一个\r\nstarter 时，实际上是在引入一组库和模块，这些都是为了支持特定的功能集（如\r\nWeb 开发、数据库访问等）。Starters 依赖于 Spring Boot\r\n的依赖管理系统来确保所有引入的库都是兼容的版本。\r\n例如，我们之前学习到的 web 开发引入了，该 starter 将导入与 web\r\n开发相关的所有包。\r\n当你使用 Spring Initializr 或其他工具创建一个 Spring Boot\r\n项目时，生成的 pom.xml 文件通常会包含 Spring Boot 的父 POM\r\n和至少一个 starter。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.5.0&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;edu.software.ergoutree&lt;/groupId&gt;    &lt;artifactId&gt;SpringBootPritical&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;SpringBootPritical&lt;/name&gt;    &lt;description&gt;SpringBootPritical&lt;/description&gt;    &lt;url/&gt;    &lt;licenses&gt;        &lt;license/&gt;    &lt;/licenses&gt;    &lt;developers&gt;        &lt;developer/&gt;    &lt;/developers&gt;    &lt;scm&gt;        &lt;connection/&gt;        &lt;developerConnection/&gt;        &lt;tag/&gt;        &lt;url/&gt;    &lt;/scm&gt;    &lt;properties&gt;        &lt;java.version&gt;21&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- 引入 Spring Boot Web Starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\r\nspring-boot-starter-parent 是作为父 POM\r\n使用的，它已经定义了许多库的兼容版本，而我们添加的\r\nspring-boot-starter-web 包含了开发 web\r\n应用所需的所有依赖，如 Tomcat 和 Spring MVC。\r\n所以在 Spring Boot\r\n项目中，我们只需要引入spring-boot-starter-web包就可以写接口并且进行访问，因为在这个\r\nstarter 中整合了我们之前写 Spring\r\n项目时引入的spring-aop、spring-context、spring-webmvc等\r\njar 包，包括 tomcat，所以SpringBoot 项目不需要外部的 tomcat，只需要启动\r\napplication 类使用内置的 tomcat 服务器即可。\r\n依赖树\r\n\r\n\r\nimg\r\n\r\n例如我们常用的 Web 应用 Starter 包含的依赖如下：\r\n\r\nspring-boot-starter（核心启动器）\r\nspring-boot-starter-tomcat（嵌入式 Tomcat）\r\nspring-webmvc（Spring MVC）\r\nspring-web（Spring Web）\r\njackson（JSON 处理）\r\n\r\n数据库 starter ：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;\r\n包含的依赖：\r\n\r\nspring-boot-starter-jdbc\r\nhibernate-core\r\nspring-data-jpa\r\nspring-aspects\r\n\r\n测试 starter ：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\r\n包含的依赖\r\n\r\nJUnit 5\r\nMockito\r\nAssertJ\r\nHamcrest\r\nSpring Test\r\n\r\n所有场景启动器最底层的依赖就是spring-boot-starter，该\r\njar 包是核心启动包，这个依赖也是 SpringBoot\r\n自动配置的核心依赖，包含了自动配置的支持，日志以及YAML。Core starter, including auto-configuration support, logging and YAML，这是官方对它的描述。\r\n而这个spring-boot-autoconfigure就关系到我们接下来要说的SpringBoot自动配置功能。\r\n依赖传递\r\n\r\nMaven：当一个依赖项被引入到项目中时，这个依赖的所有传递依赖也会被自动引入。Maven\r\n会根据依赖树来解析哪些依赖是必要的，同时检查和解决版本冲突。\r\nGradle：Gradle\r\n也处理传递依赖，并且提供了灵活的依赖解析策略，使得开发者可以更细致地控制版本和依赖。\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","Maven"]},{"title":"Spring Boot part10-Thymeleaf模板引擎","url":"/posts/62445.html","content":"Thymeleaf引擎\r\nThymeleaf 简介\r\n什么是\r\nThymeleaf：Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎\r\n由于 Spring Boot 使用了嵌入式 Servlet 容器，所以 JSP\r\n默认是不能使用的\r\n如果依旧需要服务端进行页面渲染，优先考虑使用模板引擎\r\n\r\n\r\nimage-20250607192416710\r\n\r\n模板引擎页面默认放在 src/main/resources/templates\r\nSpringBoot 包含以下模板引擎的自动配置\r\n\r\nFreeMarker\r\nGroovy\r\nThymeleaf Thymeleaf官⽹：https://www.thymeleaf.org/\r\nMustache\r\n\r\nThymeleaf 是一个现代化的服务器端 Java 模板引擎，专为 Web\r\n和独立环境而设计。与传统模板引擎相比，它具有以下核心优势：\r\n\r\n开箱即用的 HTML 兼容性：Thymeleaf\r\n模板可以直接在浏览器中预览，因为它会忽略未解析的标签和属性，这大大提升了前端开发的效率。\r\n天然的模板设计：模板本身就是有效的\r\nHTML，开发时无需区分 “模板” 和\r\n“最终渲染结果”。Thymeleaf使用html通过一些特定标签语法代表其含义，但并未破坏html结构，即使无网络、不通过后端渲染也能在浏览器成功打开，大大方便界面的测试和修改。\r\n与 Spring 生态深度集成：在 Spring Boot\r\n中实现了自动化配置和无缝整合。Thymeleaf拥有适用于Spring\r\nFramework的模块\r\n支持多种数据格式：不仅支持 HTML，还能处理\r\nXML、JavaScript、CSS 等格式。\r\n强大的表达式语言：提供简洁灵活的表达式语法，方便数据绑定和逻辑处理。\r\n\r\n什么是模板引擎\r\n模板引擎？你可能第一次听说模板引擎，估计你会禁不住想问：什么是模板引擎？\r\n\r\n模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。从字面上理解模板引擎，最重要的就是模板二字，这个意思就是做好一个模板后套入对应位置的数据，最终以html的格式展示出来，这就是模板引擎的作用。\r\n对于模板引擎的理解，可以这样形象的做一个类比：开会！\r\n相信你在上学初高中时候每次开会都要提前布置场地、拿小板凳、收拾场地。而你上了大学之后每次开会再也不去大操场了,每次开会都去学校的大会议室，桌子板凳音响主席台齐全，来个人即可，还可复用……。模板引擎的功能就类似我们的会议室开会一样开箱即用，将模板设计好之后直接填充数据即可而不需要重新设计整个页面。提高页面、代码的复用性。\r\n\r\n不仅如此，在 Java\r\n中模板引擎还有很多，模板引擎是动态网页发展进步的产物，在最初并且流传度最广的jsp它就是一个模板引擎。jsp\r\n是官方标准的模板，但是由于 jsp 的缺点比较多也挺严重的，所以很多人弃用\r\njsp\r\n选用第三方的模板引擎，市面上开源的第三方的模板引擎也比较多，有Thymeleaf、FreeMaker、Velocity等模板引擎受众较广。\r\n听完了模板引擎的介绍，相信你也很容易明白了模板引擎在web领域的主要作用：让网站实现界面和数据分离，这样大大提高了开发效率，让代码重用更加容易。\r\nMVC设计模式介绍\r\n我们使用的Thymeleaf模板引擎在整个web项目中起到的作用为视图展示(view)，谈到视图就不得不提起模型(model)以及控制器(view),其三者在web项目中分工和职责不同，但又相互有联系。三者组成当今web项目较为流行的MVC架构。\r\nMVC全名是Model View\r\nController，是模型(model)－视图(view)－控制器(controller)的缩写，其中：\r\n\r\nModel（模型）表示应用程序核心（用来存储数据供视图层渲染）。\r\nView（视图）显示数据，而本篇使用的就是Thymeleaf作为视图。\r\nController（控制器）处理输入请求，将模型和视图分离。\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n使用MVC设计模式程序有很多优点，比如降低程序耦合、增加代码的复用性、降低开发程序和接口的成本，并且通过这样分层结构在部署维护能够提供更大的便捷性。\r\n在Java\r\nweb体系最流行的MVC框架无疑就是SpringMvc框架了，在项目中经常配合模板引擎使用或者提供Restful接口。\r\n探讨动静分离\r\n\r\n部分内容借自 https://developer.aliyun.com/article/769977\r\n\r\n主要是由于Thymeleaf模板基于html，后缀也是.html。\r\n对于传统jsp或者其他模板来说，没有一个模板引擎的后缀为.html，就拿jsp来说jsp的后缀为.jsp,它的本质就是将一个html文件修改后缀为.jsp，然后在这个文件中增加自己的语法、标签然后执行时候通过后台处理这个文件最终返回一个html页面。\r\n浏览器无法直接识别.jsp文件，需要借助网络(服务端)才能进行访问；而\r\nThymeleaf 用 html 做模板可以直接在浏览器中打开。开发者充分考虑 html\r\n页面特性，将 Thymeleaf 的语法通过 html\r\n的标签属性来定义完成，这些标签属性不会影响 html\r\n页面的完整性和显示。如果通过后台服务端访问页面服务端会寻找这些标签将服务端对应的数据替换到相应位置实现动态页面！大体区别可以参照下图：\r\n\r\n\r\n在这里插入图片描述\r\n\r\n上图的意思就是如果直接打开这个 html\r\n那么浏览器会对th等标签忽视而显示原始的内容。如果通过服务端访问那么服务端将先寻找th标签将服务端储存的数据替换到对应位置。具体效果可以参照下图,下图即为一个动静结合的实例。\r\n\r\n右上角为动态页面通过服务端访问，数据显示为服务端提供的数据，样式依然为html的样式\r\n右下角为静态页面可通过浏览器直接打开，数据为初始的数据\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n所以说，Thymeleaf\r\n实现的动静分离并非简单的技术特性，而是一种融合前端开发与后端逻辑的工程化思想。其核心在于：让\r\nHTML\r\n回归为纯粹的前端设计载体，同时通过非侵入式的属性扩展实现服务端数据注入。这种设计打破了传统模板引擎对页面结构的强耦合，具体体现在：\r\n\r\n语法层面的解耦 Thymeleaf 通过 HTML 属性（如\r\nth:text、th:href）而非标签体或特殊语法块来定义动态逻辑，例如\r\n&lt;!-- 动态数据绑定完全通过属性实现，不破坏HTML结构 --&gt;&lt;h1 th:text=&quot;$&#123;title&#125;&quot;&gt;默认标题&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/users/&#123;id&#125;(id=$&#123;user.id&#125;)&#125;&quot;&gt;用户详情&lt;/a&gt;\r\n这种设计使得 HTML\r\n模板在脱离服务端时仍为标准可渲染文档，而服务端仅需解析属性即可完成数据注入，形成\r\n“一份模板，两种渲染模式” 的能力。\r\n渲染流程的分层处理\r\n\r\n静态渲染：浏览器直接打开时，Thymeleaf\r\n属性会被忽略，页面显示静态占位内容（如 th:text\r\n的默认值）。\r\n动态渲染：服务端处理时，通过解析 Thymeleaf\r\n属性将模型数据注入，生成完整动态页面。\r\n这种机制使得前端设计师可在无服务端环境下直接预览页面布局，而后端开发仅需关注属性绑定逻辑，实现真正的前后端并行开发\r\n\r\n\r\n以 JSP、FreeMarker 为例，Thymeleaf 在动静分离能力上的突破体现在：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n维度\r\nThymeleaf\r\nJSP\r\nFreeMarker\r\n\r\n\r\n\r\n\r\n语法载体\r\nHTML 属性（th:*）\r\n标签体（&lt;%= %&gt;）或自定义标签\r\n模板指令（$&#123;...&#125; 或 &lt;#if&gt;）\r\n\r\n\r\n静态可预览性\r\n完全支持（属性被浏览器忽略）\r\n不支持（需服务端编译执行）\r\n部分支持（需特殊语法隐藏指令）\r\n\r\n\r\n前端工具兼容性\r\n可直接使用 HTML 编辑器、浏览器调试\r\n依赖 IDE 插件或服务端环境\r\n需专用模板预览工具\r\n\r\n\r\n前后端耦合度\r\n低（属性扩展非侵入）\r\n高（标签体混合逻辑）\r\n中（模板指令需后端配合）\r\n\r\n\r\n部署模式\r\n支持前后端同构部署或分离部署\r\n强依赖服务端容器\r\n需与后端\r\n\r\n\r\n\r\n动静分离的工程化实践\r\n\r\n静态资源优化策略 Thymeleaf 模板中的静态资源（如\r\nCSS/JS）可通过标准 HTML 标签引入，并利用 Spring Boot\r\n的静态资源缓存机制：\r\n&lt;!-- 静态资源直接引用，浏览器可独立缓存 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/style.css&quot;&gt;&lt;script src=&quot;/static/js/app.js&quot;&gt;&lt;/script&gt;&lt;!-- 动态资源路径（如带版本号的URL）可通过Thymeleaf属性生成 --&gt;&lt;script th:src=&quot;@&#123;/js/app.js?v=$&#123;appVersion&#125;&#125;&quot;&gt;&lt;/script&gt;\r\n当页面包含大量动态交互（如实时数据更新、复杂表单验证）时，Thymeleaf\r\n的服务端渲染可能存在性能瓶颈。此时可采用 “动静混合” 架构：\r\n\r\n服务端渲染：处理首屏加载、SEO 相关的静态内容\r\n客户端渲染：通过 AJAX 或前端框架（如\r\nVue、React）处理交互逻辑\r\n\r\n\r\nThymeleaf 整合\r\n依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\r\nSpring Boot 对 Thymeleaf 的自动配置主要通过以下类实现：\r\n\r\nThymeleafAutoConfiguration：核心自动配置类，负责初始化\r\nThymeleaf 的基本环境。\r\nThymeleafProperties：提供 Thymeleaf\r\n的配置属性，可通过 application.properties 或\r\napplication.yml 自定义。\r\nThymeleafViewResolver：视图解析器，负责将逻辑视图名解析为\r\nThymeleaf 模板。\r\n\r\n默认配置下，Thymeleaf 的工作机制如下：\r\n\r\n模板文件默认存放路径：src/main/resources/templates/\r\n模板文件后缀默认：.html\r\n静态资源默认路径：src/main/resources/static/、public/、resources/、META-INF/resources/\r\n\r\n自动配置原理\r\n\r\n开启了org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration自动配置\r\n属性绑定在 ThymeleafProperties 中，对应配置文件\r\nspring.thymeleaf 内容\r\n所有的模板页面默认在 classpath:/templates 文件夹下\r\n默认效果\r\n\r\n所有的模板页面在 classpath:/templates/ 下\r\n找后缀名为 .html 的页面\r\n\r\n\r\n第一个 Thymeleaf 程序\r\n\r\n添加依赖：在 pom.xml 中添加\r\nThymeleaf 依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\r\n创建模板文件：在\r\nsrc/main/resources/templates/ 下创建\r\nhello.html\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Thymeleaf 示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 th:text=&quot;$&#123;message&#125;&quot;&gt;默认文本&lt;/h1&gt;    &lt;p&gt;当前时间: &lt;span th:text=&quot;$&#123;#temporals.format(#temporals.createNow(), &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;h2&gt;        &lt;span th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/span&gt;    &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;\r\n创建控制器\r\nimport org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;// 前后端不分离的模式，使用 Controller 返回渲染后的页面@Controllerpublic class HelloController &#123;        // 模板的逻辑视图名    // 物理视图 = 前缀 + 逻辑视图名 + 后缀     // 真实地址 = classpath:/templates/welcome.html    @GetMapping(&quot;/hello&quot;)    public String hello(@RequestParam(&quot;name&quot;) String name, Model model) &#123;        model.addAttribute(&quot;message2&quot;, &quot;name&quot;);        model.addAttribute(&quot;message&quot;, &quot;Hello Thymeleaf!&quot;);        return &quot;hello&quot;; // 返回视图名，对应 templates/hello.html    &#125;&#125;\r\n访问测试：启动应用后访问\r\nhttp://localhost:8080/hello，将看到渲染后的页面。\r\n\r\nThymeleaf 核心语法\r\nth:xxx\r\n：动态渲染指定的 html 标签属性值、或者th指令（遍历、判断等）\r\n核心用法\r\n\r\nth:text\r\n：替换标签体内的内容，使用标签体内文本值渲染，会转义\r\n\r\nth:utext\r\n：不会转义，显示为html原本的样⼦，真正显示成html该有的样式\r\n\r\n&lt;!-- 后端控制器 --&gt;@Controllerpublic class DemoController &#123;    @GetMapping(&quot;/demo&quot;)    public String demo(Model model) &#123;        model.addAttribute(&quot;message&quot;, &quot;&lt;strong&gt;Hello Thymeleaf!&lt;/strong&gt;&quot;);        return &quot;demo&quot;;    &#125;&#125;\r\n&lt;!-- 模板 --&gt;&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;默认文本&lt;/p&gt;&lt;!-- 渲染结果 --&gt;&lt;p&gt;&amp;lt;strong&amp;gt;Hello Thymeleaf!&amp;lt;/strong&amp;gt;&lt;/p&gt;&lt;p th:utext=&quot;$&#123;message&#125;&quot;&gt;默认文本&lt;/p&gt;&lt;!-- 渲染结果 --&gt;&lt;p&gt;&lt;strong&gt;Hello Thymeleaf!&lt;/strong&gt;&lt;/p&gt;\r\nth: 任意html属性 ：标签指定属性渲染\r\nth:attr ：标签任意属性渲染，动态设置多个属性\r\n&lt;button th:attr=&quot;id=&#x27;btn-&#x27; + $&#123;user.id&#125;, disabled=$&#123;user.status != &#x27;active&#x27;&#125;&quot;&gt;    [[$&#123;user.name&#125;]]&lt;/button&gt;\r\nth:*：动态设置 HTML 标签的任意属性。\r\n&lt;!-- 设置 href 属性 --&gt;&lt;a href=&quot;#&quot; th:href=&quot;@&#123;/users/&#123;id&#125;(id=$&#123;user.id&#125;)&#125;&quot;&gt;查看用户&lt;/a&gt;&lt;!-- 设置 src 属性 --&gt;&lt;img src=&quot;default.jpg&quot; th:src=&quot;@&#123;/images/$&#123;user.avatar&#125;&#125;&quot;&gt;&lt;!-- 设置 class 属性 --&gt;&lt;div class=&quot;card&quot; th:classappend=&quot;$&#123;user.active&#125;? &#x27;active&#x27; : &#x27;inactive&#x27;&quot;&gt;内容&lt;/div&gt;\r\nth:if  th:each …\r\n：th:其他指令，其他th指令\r\n\r\nth:if：条件渲染，根据表达式的值决定是否渲染标签。\r\n&lt;div th:if=&quot;$&#123;user.age &gt;= 18&#125;&quot;&gt;    成年用户&lt;/div&gt;&lt;div th:unless=&quot;$&#123;user.age &gt;= 18&#125;&quot;&gt; &lt;!-- 等同于 th:if=&quot;!$&#123;...&#125;&quot; --&gt;    未成年用户&lt;/div&gt;\r\nth:each：循环渲染，遍历集合或数组，为每个元素生成一个标签。\r\n&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;ID&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;    &lt;/tr&gt;    &lt;tr th:each=&quot;user, stat : $&#123;userList&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;1&lt;/td&gt;        &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;张三&lt;/td&gt;        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;20&lt;/td&gt;        &lt;td th:text=&quot;$&#123;stat.index&#125;&quot;&gt;索引&lt;/td&gt; &lt;!-- 当前迭代索引 (0-based) --&gt;        &lt;td th:text=&quot;$&#123;stat.count&#125;&quot;&gt;计数&lt;/td&gt; &lt;!-- 当前迭代计数 (1-based) --&gt;        &lt;td th:text=&quot;$&#123;stat.size&#125;&quot;&gt;总数&lt;/td&gt; &lt;!-- 集合大小 --&gt;    &lt;/tr&gt;&lt;/table&gt;\r\n\r\n\r\nThymeleaf支持的各种字面量与运算符\r\nThymeleaf\r\n提供了丰富的字面量和运算符支持，这些表达式可以嵌套组合，实现复杂的逻辑处理。\r\n常⻅：\r\n\r\n⽂本：使用单引号 ' 包裹，支持转义字符。\r\n数字： 支持整数、小数和科学计数法。\r\n布尔：true、false\r\nnull: null\r\n变量名： 直接引用上下文变量，无需引号。\r\n\r\n&lt;p th:text=&quot;&#x27;Hello, World!&#x27;&quot;&gt;默认文本&lt;/p&gt;&lt;p th:text=&quot;&#x27;It\\&#x27;s a beautiful day!&#x27;&quot;&gt;带引号的文本&lt;/p&gt;&lt;p th:text=&quot;123&quot;&gt;整数&lt;/p&gt;&lt;p th:text=&quot;3.14&quot;&gt;小数&lt;/p&gt;&lt;p th:text=&quot;1.23e5&quot;&gt;科学计数法 (123000)&lt;/p&gt;    &lt;!-- 假设 model 中存在 user 变量 --&gt;&lt;p th:text=&quot;$&#123;user.name&#125;&quot;&gt;用户名&lt;/p&gt;\r\n文本操作：\r\n\r\n拼串：+\r\n&lt;p th:text=&quot;&#x27;Hello, &#x27; + $&#123;user.name&#125; + &#x27;!&#x27;&quot;&gt;Hello, 访客!&lt;/p&gt;&lt;p th:text=&quot;&#x27;欢迎来到 &#x27; + $&#123;app.name&#125; + &#x27; 系统&#x27;&quot;&gt;欢迎来到系统&lt;/p&gt;\r\n文本替换：| The name is $&#123;name&#125;\r\n&lt;p th:text=&quot;|欢迎, $&#123;user.name&#125;! 今天是 $&#123;#dates.format(today, &#x27;yyyy-MM-dd&#x27;)&#125;|&quot;&gt;    欢迎, 访客! 今天是 2023-01-01&lt;/p&gt;\r\n\r\n布尔操作：\r\n\r\n二进制运算： and，or\r\n取反：!，not\r\n\r\n比较运算：\r\n\r\n基本比较符\r\n\r\n&gt;：大于\r\n&lt;：小于\r\n&gt;=：大于等于\r\n&lt;=：小于等于\r\n==：等于\r\n!=：不等于\r\n\r\n安全比较（避免空指针） 使用 eq 和\r\nne 进行安全比较。\r\n&lt;p th:if=&quot;$&#123;user.role eq &#x27;ADMIN&#x27;&#125;&quot;&gt;管理员用户&lt;/p&gt;&lt;p th:if=&quot;$&#123;user.email ne null&#125;&quot;&gt;已设置邮箱&lt;/p&gt;\r\n\r\n条件运算：\r\n\r\n三元运算符：条件 ? 值1 : 值2\r\n&lt;p th:text=&quot;$&#123;user.vip ? &#x27;VIP用户&#x27; : &#x27;普通用户&#x27;&#125;&quot;&gt;用户类型&lt;/p&gt;\r\nElvis 运算符（空值默认）\r\n&lt;p th:text=&quot;$&#123;user.nickname ?: user.name&#125;&quot;&gt;昵称或用户名&lt;/p&gt;&lt;p th:text=&quot;$&#123;product.discountPrice ?: product.price&#125;&quot;&gt;折扣价或原价&lt;/p&gt;\r\nif-then\r\nif-then-else\r\ndefault：\r\n(value)?:(defaultValue）\r\n\r\n特殊语法：\r\n\r\n选择表达式（\\*&#123;...&#125;）\r\n安全导航操作符（?.）：避免空指针\r\n&lt;p th:text=&quot;$&#123;user?.address?.city ?: &#x27;未知城市&#x27;&#125;&quot;&gt;城市&lt;/p&gt;\r\n方法调用（()）\r\n&lt;p th:text=&quot;$&#123;user.getFullName()&#125;&quot;&gt;全名&lt;/p&gt;&lt;p th:text=&quot;$&#123;#strings.toUpperCase(user.name)&#125;&quot;&gt;大写姓名&lt;/p&gt;\r\n列表 / 数组索引（[]）\r\n访问集合或数组元素。\r\n集合选择（?&#123;...&#125;）\r\n过滤集合元素。\r\n&lt;!-- 假设 products 是商品列表 --&gt;&lt;div th:each=&quot;product : $&#123;products.?&#123;#strings.contains(name, &#x27;手机&#x27;)&#125;&#125;&quot;&gt;    &lt;p th:text=&quot;$&#123;product.name&#125;&quot;&gt;手机产品&lt;/p&gt;&lt;/div&gt;\r\n集合投影（!&#123;...&#125;）\r\n提取集合元素的属性。\r\n&lt;!-- 获取所有用户的姓名列表 --&gt;&lt;p th:text=&quot;$&#123;#strings.join(users.!&#123;name&#125;, &#x27;, &#x27;)&#125;&quot;&gt;用户列表&lt;/p&gt;\r\n\r\n核心表达式：用来动态取值\r\nThymeleaf\r\n通过特定命名空间（xmlns:th=\"http://www.thymeleaf.org\"）来定义模板表达式，主要表达式类型包括：\r\n\r\n变量表达式$&#123;...&#125;：用于访问模型中的变量，使用model共享给页面的值都用这个\r\n其中支持各种字面量与运算符\r\n&lt;!-- 基础对象属性访问 --&gt;&lt;p th:text=&quot;$&#123;user.name&#125;&quot;&gt;默认姓名&lt;/p&gt;&lt;!-- 嵌套对象访问 --&gt;&lt;p th:text=&quot;$&#123;user.address.city&#125;&quot;&gt;默认城市&lt;/p&gt;&lt;!-- 安全导航操作符（避免空指针） --&gt;&lt;p th:text=&quot;$&#123;user?.address?.city ?: &#x27;未知城市&#x27;&#125;&quot;&gt;默认城市&lt;/p&gt;&lt;!-- 调用对象方法 --&gt;&lt;p th:text=&quot;$&#123;user.getFullName()&#125;&quot;&gt;全名&lt;/p&gt;&lt;!-- 访问集合元素 --&gt;&lt;p th:text=&quot;$&#123;userList[0].name&#125;&quot;&gt;第一个用户&lt;/p&gt;\r\n选择表达式*&#123;&#125;：在\r\nth:object\r\n上下文中使用，需要配合th:object绑定对象\r\n&lt;div th:object=&quot;$&#123;user&#125;&quot;&gt;    &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;姓名&lt;/p&gt;    &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;年龄&lt;/p&gt;    &lt;p th:text=&quot;*&#123;address.street&#125;&quot;&gt;街道&lt;/p&gt;&lt;/div&gt;\r\n链接表达式@&#123;...&#125;：生成 URL\r\n链接，自动处理上下文路径和参数编码，专门用来取各种路径\r\n&lt;!-- 绝对路径 --&gt;&lt;a th:href=&quot;@&#123;/home&#125;&quot;&gt;首页&lt;/a&gt;&lt;!-- 带路径变量 --&gt;&lt;a th:href=&quot;@&#123;/users/&#123;id&#125;(id=$&#123;user.id&#125;)&#125;&quot;&gt;用户详情&lt;/a&gt;&lt;!-- 查询参数 --&gt;&lt;a th:href=&quot;@&#123;/search(keyword=$&#123;query&#125;, page=$&#123;page&#125;)&#125;&quot;&gt;搜索&lt;/a&gt;&lt;!-- 相对路径 --&gt;&lt;a th:href=&quot;@&#123;../edit(id=$&#123;user.id&#125;)&#125;&quot;&gt;编辑&lt;/a&gt;&lt;!-- 锚点和查询参数混合 --&gt;&lt;a th:href=&quot;@&#123;/articles/&#123;id&#125;#comments(id=$&#123;article.id&#125;, sort=&#x27;newest&#x27;)&#125;&quot;&gt;查看评论&lt;/a&gt;\r\n国际化表达式#&#123;&#125;\r\n：国际化消息处理，从资源文件读取文本。\r\n&lt;!-- messages.properties --&gt;welcome=欢迎光临user.greeting=欢迎, &#123;0&#125;!&lt;!-- 模板 --&gt;&lt;p th:text=&quot;#&#123;welcome&#125;&quot;&gt;默认欢迎语&lt;/p&gt;&lt;p th:text=&quot;#&#123;user.greeting($&#123;user.name&#125;)&#125;&quot;&gt;欢迎, 访客!&lt;/p&gt;\r\n片段表达式~&#123;...&#125;：引用模板片段，实现代码复用\r\n&lt;!-- 定义片段 --&gt;&lt;footer th:fragment=&quot;footer&quot;&gt;    &lt;p&gt;版权所有 &amp;copy; 2025&lt;/p&gt;&lt;/footer&gt;&lt;!-- 引入片段 --&gt;&lt;div th:insert=&quot;~&#123;layout/footer :: footer&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 带参数的片段 --&gt;&lt;header th:fragment=&quot;header(title, user)&quot;&gt;    &lt;h1 th:text=&quot;$&#123;title&#125;&quot;&gt;默认标题&lt;/h1&gt;    &lt;p&gt;欢迎, &lt;span th:text=&quot;$&#123;user.name&#125;&quot;&gt;访客&lt;/span&gt;&lt;/p&gt;&lt;/header&gt;&lt;!-- 传递参数 --&gt;&lt;div th:replace=&quot;~&#123;layout/header :: header(title=&#x27;用户中心&#x27;, user=$&#123;currentUser&#125;)&#125;&quot;&gt;&lt;/div&gt;\r\n\r\n系统⼯具&amp;内置对象\r\nThymeleaf 通过内置工具对象（以 #\r\n开头进行引用）提供了强大的功能扩展，这些工具可以在表达式中直接使用，处理各种常见任务\r\n详细文档Tutorial:\r\nUsing Thymeleaf\r\n基础环境对象\r\n\r\nparam - 请求参数对象 访问 HTTP\r\n请求参数，返回字符串数组。\r\n&lt;!-- URL: /page?name=John&amp;age=30 --&gt;&lt;p th:text=&quot;$&#123;param.name[0]&#125;&quot;&gt;默认姓名&lt;/p&gt;  &lt;!-- 输出: John --&gt;&lt;p th:text=&quot;$&#123;param.age[0]&#125;&quot;&gt;默认年龄&lt;/p&gt;  &lt;!-- 输出: 30 --&gt;&lt;!-- 安全获取参数（避免数组越界） --&gt;&lt;p th:text=&quot;$&#123;param.name&#125;?.[0] ?: &#x27;未知&#x27;&quot;&gt;默认姓名&lt;/p&gt;\r\nsession - Session 对象\r\n访问 HTTP Session 属性。\r\n&lt;!-- 假设 session 中存储了 user 对象 --&gt;&lt;p th:text=&quot;$&#123;session.user.name&#125;&quot;&gt;默认用户名&lt;/p&gt;&lt;!-- 判断 session 属性是否存在 --&gt;&lt;div th:if=&quot;$&#123;session.user != null&#125;&quot;&gt;用户已登录&lt;/div&gt;\r\napplication - ServletContext 对象\r\n访问应用范围内的属性。\r\n&lt;!-- 假设 application 中存储了 appName --&gt;&lt;p th:text=&quot;$&#123;application.appName&#125;&quot;&gt;默认应用名&lt;/p&gt;\r\n\r\n表达式工具对象\r\n\r\n#execInfo - 模板执行信息\r\n获取模板执行的上下文信息。\r\n&lt;p th:text=&quot;$&#123;#execInfo.templateName&#125;&quot;&gt;模板名称&lt;/p&gt;  &lt;!-- 输出当前模板名 --&gt;&lt;p th:text=&quot;$&#123;#execInfo.lineNumber&#125;&quot;&gt;行号&lt;/p&gt;      &lt;!-- 输出当前表达式所在行号 --&gt;\r\n#messages - 国际化消息\r\n获取国际化资源文件中的消息。\r\n&lt;!-- messages.properties --&gt;welcome=欢迎光临user.greeting=欢迎, &#123;0&#125;!&lt;!-- 模板 --&gt;&lt;p th:text=&quot;#&#123;welcome&#125;&quot;&gt;默认欢迎语&lt;/p&gt;&lt;p th:text=&quot;#&#123;user.greeting($&#123;user.name&#125;)&#125;&quot;&gt;欢迎, 访客!&lt;/p&gt;\r\n#uris - URI/URL 工具\r\n处理 URI 和 URL 编码。\r\n&lt;!-- 编码参数 --&gt;&lt;a th:href=&quot;@&#123;/search(query=$&#123;#uris.encodePath(param.query[0], &#x27;UTF-8&#x27;)&#125;)&#125;&quot;&gt;搜索&lt;/a&gt;&lt;!-- 解码参数 --&gt;&lt;p th:text=&quot;$&#123;#uris.decode(param.encodedValue[0], &#x27;UTF-8&#x27;)&#125;&quot;&gt;解码值&lt;/p&gt;\r\n#ctx - 上下文对象\r\n访问当前模板上下文。\r\n&lt;p th:text=&quot;$&#123;#ctx.locale&#125;&quot;&gt;当前语言环境&lt;/p&gt;&lt;p th:text=&quot;$&#123;#ctx.variables.get(&#x27;user&#x27;)&#125;&quot;&gt;用户对象&lt;/p&gt;\r\n#locale - 本地化工具\r\n获取本地化信息。\r\n&lt;p th:text=&quot;$&#123;#locale.language&#125;&quot;&gt;当前语言&lt;/p&gt;&lt;p th:text=&quot;$&#123;#locale.country&#125;&quot;&gt;当前国家&lt;/p&gt;\r\n\r\n数据类型工具\r\n\r\n#conversions - 类型转换工具 执行\r\nSpring 定义的类型转换。\r\n&lt;!-- 将字符串转换为日期 --&gt;&lt;p th:text=&quot;$&#123;#conversions.convert(&#x27;2023-01-01&#x27;, &#x27;java.util.Date&#x27;)&#125;&quot;&gt;日期&lt;/p&gt;&lt;!-- 将数字格式化 --&gt;&lt;p th:text=&quot;$&#123;#conversions.convert(1234.56, &#x27;java.lang.String&#x27;, &#x27;#,##0.00&#x27;)&#125;&quot;&gt;1,234.56&lt;/p&gt;\r\n#dates -\r\n日期工具（java.util.Date） 处理\r\njava.util.Date 类型的日期。\r\n&lt;!-- 假设 user.birthday 是 java.util.Date 类型 --&gt;&lt;p th:text=&quot;$&#123;#dates.format(user.birthday, &#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;生日&lt;/p&gt;&lt;p th:text=&quot;$&#123;#dates.year(user.birthday)&#125;&quot;&gt;出生年份&lt;/p&gt;&lt;p th:text=&quot;$&#123;#dates.dayOfWeek(user.birthday)&#125;&quot;&gt;星期几&lt;/p&gt;\r\n#calendars -\r\n日历工具（java.util.Calendar） 处理\r\njava.util.Calendar 类型的日期。\r\n&lt;!-- 假设 user.registerDate 是 Calendar 类型 --&gt;&lt;p th:text=&quot;$&#123;#calendars.format(user.registerDate, &#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;注册日期&lt;/p&gt;&lt;p th:text=&quot;$&#123;#calendars.month(user.registerDate)&#125; + 1&quot;&gt;月份&lt;/p&gt; &lt;!-- 注意: 月份从0开始 --&gt;\r\n#temporals - JDK8+\r\n日期时间工具（java.time） 处理 JDK8 引入的\r\njava.time API（如 LocalDate,\r\nLocalDateTime）\r\n&lt;!-- 假设 now 是 LocalDateTime 类型 --&gt;&lt;p th:text=&quot;$&#123;#temporals.format(now, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;当前时间&lt;/p&gt;&lt;p th:text=&quot;$&#123;#temporals.plusDays(now, 7)&#125;&quot;&gt;一周后&lt;/p&gt;&lt;p th:text=&quot;$&#123;#temporals.between(now, futureDate).days&#125;&quot;&gt;相差天数&lt;/p&gt;\r\n#numbers - 数字工具\r\n处理数字格式化和操作。\r\n&lt;!-- 格式化货币 --&gt;&lt;p th:text=&quot;$&#123;#numbers.formatCurrency(1234.56)&#125;&quot;&gt;¥1,234.56&lt;/p&gt;&lt;!-- 格式化百分比 --&gt;&lt;p th:text=&quot;$&#123;#numbers.formatPercent(0.75, 2, 2)&#125;&quot;&gt;75.00%&lt;/p&gt; &lt;!-- 保留两位小数 --&gt;&lt;!-- 四舍五入 --&gt;&lt;p th:text=&quot;$&#123;#numbers.round(3.14159, 2)&#125;&quot;&gt;3.14&lt;/p&gt;\r\n#strings - 字符串工具\r\n处理字符串操作。\r\n&lt;!-- 字符串拼接 --&gt;&lt;p th:text=&quot;$&#123;#strings.concat(&#x27;Hello&#x27;, &#x27; &#x27;, user.name)&#125;&quot;&gt;Hello 访客&lt;/p&gt;&lt;!-- 截取子串 --&gt;&lt;p th:text=&quot;$&#123;#strings.substring(user.email, 0, user.email.indexOf(&#x27;@&#x27;))&#125;&quot;&gt;邮箱前缀&lt;/p&gt;&lt;!-- 判断空值 --&gt;&lt;p th:text=&quot;$&#123;#strings.isEmpty(user.nickname)&#125;? &#x27;无昵称&#x27; : user.nickname&quot;&gt;昵称&lt;/p&gt;&lt;!-- 大小写转换 --&gt;&lt;p th:text=&quot;$&#123;#strings.toUpperCase(user.name)&#125;&quot;&gt;大写姓名&lt;/p&gt;\r\n#objects - 对象工具\r\n处理对象操作和空值安全。\r\n&lt;!-- 空值安全获取 --&gt;&lt;p th:text=&quot;$&#123;#objects.nullSafe(user.name, &#x27;匿名用户&#x27;)&#125;&quot;&gt;用户名&lt;/p&gt;&lt;!-- 判断相等 --&gt;&lt;p th:text=&quot;$&#123;#objects.equals(user.role, &#x27;ADMIN&#x27;)&#125;? &#x27;管理员&#x27; : &#x27;普通用户&#x27;&quot;&gt;用户角色&lt;/p&gt;\r\n#bools - 布尔工具\r\n处理布尔逻辑。\r\n&lt;!-- 逻辑判断 --&gt;&lt;div th:if=&quot;$&#123;#bools.isTrue(user.active)&#125;&quot;&gt;用户活跃&lt;/div&gt;&lt;!-- 条件组合 --&gt;&lt;div th:if=&quot;$&#123;#bools.and(user.active, user.verified)&#125;&quot;&gt;用户已激活并验证&lt;/div&gt;\r\n\r\n集合与数组工具\r\n\r\n#arrays - 数组工具\r\n处理数组操作。\r\n&lt;!-- 假设 userIds 是 Long[] 类型 --&gt;&lt;p th:text=&quot;$&#123;#arrays.length(userIds)&#125;&quot;&gt;数组长度&lt;/p&gt;&lt;!-- 数组是否包含元素 --&gt;&lt;p th:text=&quot;$&#123;#arrays.contains(userIds, 1L)&#125;? &#x27;包含&#x27; : &#x27;不包含&#x27;&quot;&gt;是否包含ID=1&lt;/p&gt;&lt;!-- 数组连接 --&gt;&lt;p th:text=&quot;$&#123;#arrays.join(userIds, &#x27;, &#x27;)&#125;&quot;&gt;1, 2, 3&lt;/p&gt;\r\n#lists - 列表工具 处理\r\njava.util.List 操作。\r\n&lt;!-- 假设 userList 是 List&lt;User&gt; 类型 --&gt;&lt;p th:text=&quot;$&#123;#lists.size(userList)&#125;&quot;&gt;用户数量&lt;/p&gt;&lt;!-- 列表排序 --&gt;&lt;th:block th:each=&quot;user : $&#123;#lists.sort(userList, &#x27;age&#x27;)&#125;&quot;&gt;    &lt;p th:text=&quot;$&#123;user.name&#125;&quot;&gt;用户名&lt;/p&gt;&lt;/th:block&gt;&lt;!-- 判断列表是否为空 --&gt;&lt;p th:if=&quot;$&#123;#lists.isEmpty(userList)&#125;&quot;&gt;暂无用户&lt;/p&gt;\r\n#sets - 集合工具 处理\r\njava.util.Set 操作。\r\n&lt;!-- 假设 roles 是 Set&lt;Role&gt; 类型 --&gt;&lt;p th:text=&quot;$&#123;#sets.contains(roles, &#x27;ADMIN&#x27;)&#125;? &#x27;是管理员&#x27; : &#x27;不是管理员&#x27;&quot;&gt;用户权限&lt;/p&gt;\r\n#maps - 映射工具 处理\r\njava.util.Map 操作。\r\n&lt;!-- 假设 userMap 是 Map&lt;Long, User&gt; 类型 --&gt;&lt;p th:text=&quot;$&#123;userMap.get(1L).name&#125;&quot;&gt;ID为1的用户名&lt;/p&gt;&lt;!-- 遍历Map --&gt;&lt;th:block th:each=&quot;entry : $&#123;userMap&#125;&quot;&gt;    &lt;p&gt;ID: &lt;span th:text=&quot;$&#123;entry.key&#125;&quot;&gt;1&lt;/span&gt;, 姓名: &lt;span th:text=&quot;$&#123;entry.value.name&#125;&quot;&gt;张三&lt;/span&gt;&lt;/p&gt;&lt;/th:block&gt;\r\n#aggregates - 集合聚合工具\r\n计算集合的聚合值（如总和、平均值）。\r\n&lt;!-- 假设 scores 是 List&lt;Integer&gt; 类型 --&gt;&lt;p th:text=&quot;$&#123;#aggregates.sum(scores)&#125;&quot;&gt;总分&lt;/p&gt;&lt;p th:text=&quot;$&#123;#aggregates.avg(scores)&#125;&quot;&gt;平均分&lt;/p&gt;&lt;p th:text=&quot;$&#123;#aggregates.max(scores)&#125;&quot;&gt;最高分&lt;/p&gt;\r\n#ids - ID 生成工具 生成唯一\r\nID。\r\n&lt;!-- 生成唯一ID --&gt;&lt;div th:id=&quot;$&#123;#ids.next(&#x27;form&#x27;)&#125;&quot;&gt;表单&lt;/div&gt; &lt;!-- 生成类似 form1, form2 的ID --&gt;\r\n\r\n其他工具\r\n\r\n#links - 链接工具 生成链接，功能与\r\n@&#123;...&#125; 类似。\r\n&lt;a th:href=&quot;$&#123;#links.url(&#x27;/users&#x27;, &#123;&#x27;page&#x27;: pageNum&#125;)&#125;&quot;&gt;第 [[$&#123;pageNum&#125;]] 页&lt;/a&gt;\r\n#dates/#temporals\r\n的更多功能 处理复杂日期计算。\r\n&lt;!-- 判断日期是否在今天之后 --&gt;&lt;p th:text=&quot;$&#123;#temporals.isAfter(user.expireDate, #temporals.createNow())&#125;? &#x27;未过期&#x27; : &#x27;已过期&#x27;&quot;&gt;会员状态&lt;/p&gt;&lt;!-- 计算日期差 --&gt;&lt;p th:text=&quot;$&#123;#temporals.between(user.registerDate, #temporals.createNow()).days&#125;&quot;&gt;注册天数&lt;/p&gt;\r\n\r\n一个比较全面的例子\r\npackage edu.software.ergoutree.springbootwebpart1.controller;import edu.software.ergoutree.springbootwebpart1.Entity.User;import edu.software.ergoutree.springbootwebpart1.Entity.Role;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import java.time.LocalDate;import java.util.Arrays;import java.util.List;@Controller@RequestMapping(&quot;/users&quot;)public class ThyleafDemoController &#123;    // 模拟用户数据    private List&lt;User&gt; userList = Arrays.asList(            new User(1L, &quot;张三&quot;, 25, &quot;zhangsan@example.com&quot;, true, LocalDate.of(2023, 1, 15)),            new User(2L, &quot;李四&quot;, 30, &quot;lisi@example.com&quot;, false, LocalDate.of(2023, 3, 20)),            new User(3L, &quot;王五&quot;, 22, &quot;wangwu@example.com&quot;, true, LocalDate.of(2023, 5, 10))    );    // 角色列表    private List&lt;Role&gt; roleList = Arrays.asList(            new Role(1L, &quot;管理员&quot;),            new Role(2L, &quot;普通用户&quot;),            new Role(3L, &quot;访客&quot;)    );    // 显示用户列表    @GetMapping    public String listUsers(Model model) &#123;        model.addAttribute(&quot;userList&quot;, userList);        return &quot;users/list&quot;;    &#125;    // 显示创建用户表单    @GetMapping(&quot;/create&quot;)    public String showCreateForm(Model model) &#123;        model.addAttribute(&quot;user&quot;, new User(1L, &quot;张三&quot;, 25, &quot;zhangsan@example.com&quot;, true, LocalDate.of(2023, 1, 15)));        model.addAttribute(&quot;roles&quot;, roleList);        return &quot;users/form&quot;;    &#125;    // 处理用户提交    @PostMapping(&quot;/save&quot;)    public String saveUser(@ModelAttribute User user) &#123;        // 模拟保存用户        System.out.println(&quot;保存用户: &quot; + user);        return &quot;redirect:/users&quot;;    &#125;&#125;\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;用户列表&lt;/title&gt;    &lt;style&gt;        table &#123; border-collapse: collapse; width: 100%; &#125;        th, td &#123; border: 1px solid #ddd; padding: 8px; &#125;        th &#123; background-color: #f2f2f2; &#125;        .active &#123; color: green; &#125;        .inactive &#123; color: red; &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户列表&lt;/h1&gt;&lt;!-- 条件渲染：判断用户列表是否为空 --&gt;&lt;div th:if=&quot;$&#123;#lists.isEmpty(userList)&#125;&quot;&gt;    &lt;p&gt;暂无用户数据&lt;/p&gt;&lt;/div&gt;&lt;!-- 循环渲染用户列表 --&gt;&lt;table th:if=&quot;$&#123;not #lists.isEmpty(userList)&#125;&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;ID&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;        &lt;th&gt;邮箱&lt;/th&gt;        &lt;th&gt;状态&lt;/th&gt;        &lt;th&gt;创建日期&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;!-- 循环遍历用户列表，使用状态变量stat获取索引信息 --&gt;    &lt;tr th:each=&quot;user, stat : $&#123;userList&#125;&quot; th:class=&quot;$&#123;stat.even&#125;? &#x27;even&#x27; : &#x27;odd&#x27;&quot;&gt;        &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;1&lt;/td&gt;        &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;张三&lt;/td&gt;        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;25&lt;/td&gt;        &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;zhangsan@example.com&lt;/td&gt;        &lt;td&gt;            &lt;!-- 三元表达式：根据用户状态显示不同样式 --&gt;            &lt;span th:text=&quot;$&#123;user.active&#125;? &#x27;活跃&#x27; : &#x27;非活跃&#x27;&quot;                  th:class=&quot;$&#123;user.active&#125;? &#x27;active&#x27; : &#x27;inactive&#x27;&quot;&gt;活跃&lt;/span&gt;        &lt;/td&gt;        &lt;td&gt;            &lt;!-- 使用日期工具格式化日期 --&gt;            &lt;span th:text=&quot;$&#123;#dates.format(user.createDate, &#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;2023-01-01&lt;/span&gt;        &lt;/td&gt;        &lt;td&gt;            &lt;!-- URL表达式：带参数的链接 --&gt;            &lt;a th:href=&quot;@&#123;/users/edit(id=$&#123;user.id&#125;)&#125;&quot;&gt;编辑&lt;/a&gt; |            &lt;a th:href=&quot;@&#123;/users/delete(id=$&#123;user.id&#125;)&#125;&quot;&gt;删除&lt;/a&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;!-- 显示统计信息 --&gt;&lt;p&gt;共有 &lt;span th:text=&quot;$&#123;#lists.size(userList)&#125;&quot;&gt;0&lt;/span&gt; 个用户&lt;/p&gt;&lt;!-- 链接到创建用户页面 --&gt;&lt;a th:href=&quot;@&#123;/users/create&#125;&quot;&gt;创建新用户&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;body&gt;    &lt;!-- 访问请求参数 --&gt;    &lt;p&gt;搜索关键词: [[$&#123;param.keyword[0]&#125; ?: &#x27;未搜索&#x27;]]&lt;/p&gt;        &lt;!-- 日期格式化 --&gt;    &lt;p&gt;今天: [[$&#123;#dates.format(#dates.createNow(), &#x27;yyyy-MM-dd&#x27;)&#125;]]&lt;/p&gt;        &lt;!-- 字符串处理 --&gt;    &lt;p&gt;用户名长度: [[$&#123;#strings.length(user.name)&#125;]]&lt;/p&gt;        &lt;!-- 集合操作 --&gt;    &lt;p&gt;用户数量: [[$&#123;#lists.size(userList)&#125;]]&lt;/p&gt;        &lt;!-- 条件判断 --&gt;    &lt;p th:if=&quot;$&#123;#bools.isTrue(user.vip)&#125;&quot; class=&quot;vip&quot;&gt;VIP用户&lt;/p&gt;        &lt;!-- 数字格式化 --&gt;    &lt;p&gt;账户余额: [[$&#123;#numbers.formatCurrency(user.balance)&#125;]]&lt;/p&gt;        &lt;!-- 生成唯一ID --&gt;    &lt;div th:id=&quot;$&#123;#ids.next(&#x27;section&#x27;)&#125;&quot;&gt;内容区域&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\nThymeleaf属性\r\n属性设置\r\nThymeleaf 通过 th:* 系列属性实现 HTML 标签的动态渲染\r\n\r\nURL\r\n属性设置（th:href、th:src）：\r\n\r\n动态设置 href 属性，生成相对应用上下文的\r\nURL\r\n特性\r\n\r\n@&#123;...&#125; 表达式会自动添加应用上下文路径（如\r\n/app）\r\n避免硬编码 URL，提高代码可维护性\r\n\r\n示例\r\n&lt;a th:href=&quot;@&#123;/product/list&#125;&quot;&gt;产品列表&lt;/a&gt;&lt;!-- 若应用上下文为 /app --&gt;&lt;a href=&quot;/app/product/list&quot;&gt;产品列表&lt;/a&gt;\r\n\r\n通用属性设置（th:attr）\r\n\r\n作用：动态设置任意 HTML 属性\r\n特性\r\n\r\n支持单个或多个属性同时设置\r\n属性值可以是表达式\r\n\r\n示例：\r\n&lt;div th:attr=&quot;class=$&#123;active&#125;&quot;&gt;内容&lt;/div&gt;&lt;!-- 若 $&#123;active&#125; 为 &quot;highlight&quot; --&gt;&lt;div class=&quot;highlight&quot;&gt;内容&lt;/div&gt;&lt;!--同时设置多个属性--&gt;&lt;img src=&quot;../../images/gtvglogo.png&quot;      th:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;\r\n\r\n布尔属性设置（th:checked、th:disabled\r\n等）\r\n\r\n作用：动态控制布尔属性（如\r\nchecked、disabled、selected\r\n等）\r\n特性\r\n\r\n当表达式为 true 时添加属性\r\n当表达式为 false 时移除属性\r\n\r\n示例\r\n&lt;input type=&quot;checkbox&quot; th:checked=&quot;$&#123;user.active&#125;&quot; /&gt;&lt;!-- 若 $&#123;user.active&#125; 为 true --&gt;&lt;input type=&quot;checkbox&quot; checked /&gt;&lt;!-- 若 $&#123;user.active&#125; 为 false --&gt;&lt;input type=&quot;checkbox&quot; /&gt;\r\n\r\n内容替换（th:text、th:utext）\r\n\r\n作用：替换标签内的文本内容\r\n特性\r\n\r\n自动转义 HTML 字符（如 &lt; 转为\r\n&lt;）\r\n若表达式为 null，则显示空字符串\r\n\r\n示例：\r\n&lt;p th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;&lt;!-- 若 $&#123;content&#125; 为 &quot;&lt;b&gt;Hello&lt;/b&gt;&quot; --&gt;&lt;p&gt;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&lt;/p&gt;&lt;p th:utext=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;&lt;!-- 渲染结果 --&gt;&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;\r\n\r\n\r\n注意：\r\n\r\n属性名大小写：\r\n\r\nHTML 属性名是大小写不敏感的（如 class 和\r\nCLASS 等价）\r\nThymeleaf 属性名是大小写敏感的（如 th:href\r\n必须小写）\r\n\r\n特殊属性：\r\n\r\nth:class：完全覆盖原 class 属性\r\nth:classappend：追加到原 class 属性\r\nth:styleappend：追加到原 style 属性\r\n\r\n注意空值处理\r\n\r\n属性优先级与覆盖规则\r\n常见的属性优先级：片段 &gt; 遍历 &gt; 判断\r\n\r\n\r\nimage-20250608150606155\r\n\r\n\r\nThymeleaf 属性优先：\r\n&lt;a href=&quot;/static-link&quot; th:href=&quot;@&#123;/dynamic-link&#125;&quot;&gt;链接&lt;/a&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;/app/dynamic-link&quot;&gt;链接&lt;/a&gt;\r\n多属性合并：\r\n&lt;div class=&quot;base&quot; th:classappend=&quot;$&#123;active&#125;? &#x27;active&#x27; : &#x27;inactive&#x27;&quot;&gt;内容&lt;/div&gt;&lt;!-- 渲染结果 --&gt;&lt;!-- 若 $&#123;active&#125; 为 true --&gt;&lt;div class=&quot;base active&quot;&gt;内容&lt;/div&gt;&lt;!-- 若 $&#123;active&#125; 为 false --&gt;&lt;div class=&quot;base inactive&quot;&gt;内容&lt;/div&gt;\r\n\r\nThymeleaf 遍历与判断\r\n遍历\r\n语法：th:each=\" 元素名 , 迭代状态 : $&#123; 集合 &#125;\"\r\n基础遍历\r\n&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt; \t&lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;\t&lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; \t&lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;&gt;\t&lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; \t&lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; \t&lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt; &lt;/tr&gt;\r\n\r\n说明\r\n\r\n遍历 prods 集合，每次迭代创建一个 标签\r\n$&#123;prod&#125; 表示当前迭代的产品对象\r\n直接使用对象属性（如 prod.name）访问数据\r\n\r\n\r\n带状态变量的遍历\r\n&lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;&gt;    &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;产品名称&lt;/td&gt;    &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;价格&lt;/td&gt;    &lt;td th:text=&quot;$&#123;prod.inStock&#125;? &#x27;有货&#x27; : &#x27;无货&#x27;&quot;&gt;库存状态&lt;/td&gt;&lt;/tr&gt;\r\n\r\n迭代状态变量（iterStat）的属性\r\n\r\nindex：当前索引（从 0 开始）\r\ncount：当前计数（从 1 开始）\r\nsize：集合总大小\r\ncurrent：当前元素对象\r\neven/odd：是否为偶数 / 奇数行\r\nfirst/last：是否为第一个 / 最后一个元素\r\n\r\n\r\n遍历 Map\r\n&lt;table&gt;    &lt;tr th:each=&quot;entry : $&#123;userMap&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;entry.key&#125;&quot;&gt;键&lt;/td&gt;        &lt;td th:text=&quot;$&#123;entry.value&#125;&quot;&gt;值&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\r\n\r\n说明\r\n\r\nentry 是 Map.Entry 对象\r\n通过 entry.key 和 entry.value\r\n访问键值对\r\n\r\n\r\n判断\r\n基础语法：（th:if、th:unless、th:switch）\r\n1. th:if 和 th:unless\r\n&lt;!-- 显示评论链接（仅当产品有评论时） --&gt;&lt;a href=&quot;#&quot;    th:href=&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;    th:if=&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;    查看评论&lt;/a&gt;&lt;!-- 仅当用户不是管理员时显示 --&gt;&lt;div th:unless=&quot;$&#123;user.role == &#x27;ADMIN&#x27;&#125;&quot;&gt;普通用户界面&lt;/div&gt;\r\n\r\n说明\r\n\r\nth:if：条件为 true 时渲染标签\r\nth:unless：条件为 false 时渲染标签（与\r\nth:if 相反）\r\n\r\n\r\n2. th:switch 和\r\nth:case\r\n&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;    &lt;p th:case=&quot;&#x27;ADMIN&#x27;&quot;&gt;管理员用户&lt;/p&gt;    &lt;p th:case=&quot;&#x27;MODERATOR&#x27;&quot;&gt;版主用户&lt;/p&gt;    &lt;p th:case=&quot;*&quot;&gt;普通用户&lt;/p&gt; &lt;!-- 默认情况 --&gt;&lt;/div&gt;\r\n\r\n说明\r\n\r\nth:switch：设置表达式\r\nth:case：匹配值\r\n*：默认情况（相当于 default）\r\n\r\n\r\nThymeleaf 模板引用\r\nThymeleaf\r\n通过强大的模板引用、变量选择和布局功能，实现了代码复用和高效开发。\r\n变量选择\r\n变量选择（th:object 和\r\n*&#123;...&#125;）\r\n\r\n使用th:object=\"$&#123;user&#125;\"绑定一个属性，在接下来使用*&#123;...&#125;能直接取出其th:object绑定的对象的属性\r\n\r\n&lt;!-- 传统方式 --&gt;&lt;p th:text=&quot;$&#123;user.name&#125;&quot;&gt;姓名&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.age&#125;&quot;&gt;年龄&lt;/p&gt;&lt;!-- 使用 th:object --&gt;&lt;div th:object=&quot;$&#123;user&#125;&quot;&gt;    &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;姓名&lt;/p&gt;    &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;年龄&lt;/p&gt;&lt;/div&gt;\r\n优势：\r\n\r\n简化嵌套对象的访问\r\n提高代码可读性\r\n与表单绑定结合更方便\r\n\r\n模板布局\r\n模板布局（th:fragment、th:insert、th:replace）\r\n\r\n定义模板片段（th:fragment）\r\n在布局文件中定义可复用的片段：\r\n&lt;!-- layout/footer.html --&gt;&lt;footer th:fragment=&quot;footer&quot;&gt;    &lt;p&gt;&amp;copy; 2025 版权所有&lt;/p&gt;&lt;/footer&gt;&lt;!-- 带参数的片段 --&gt;&lt;header th:fragment=&quot;header(title, user)&quot;&gt;    &lt;h1 th:text=&quot;$&#123;title&#125;&quot;&gt;默认标题&lt;/h1&gt;    &lt;p&gt;欢迎, &lt;span th:text=&quot;$&#123;user.name&#125;&quot;&gt;访客&lt;/span&gt;&lt;/p&gt;&lt;/header&gt;\r\n引用模板片段 使用 ~&#123;模板名::片段名&#125;\r\n语法引用片段：\r\n&lt;!-- 引入页脚 --&gt;&lt;div th:insert=&quot;~&#123;layout/footer::footer&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 引入带参数的头部 --&gt;&lt;div th:replace=&quot;~&#123;layout/header::header(title=&#x27;用户中心&#x27;, user=$&#123;currentUser&#125;)&#125;&quot;&gt;&lt;/div&gt;\r\n插入方式对比\r\n\r\nth:insert：保留当前标签，将片段插入内部\r\nth:replace：替换当前标签为片段内容\r\n&lt;!-- 使用 th:insert --&gt;&lt;div th:insert=&quot;~&#123;footer::copy&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 渲染结果 --&gt;&lt;div&gt;    &lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;/div&gt;&lt;!-- 使用 th:replace --&gt;&lt;div th:replace=&quot;~&#123;footer::copy&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 渲染结果 --&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;\r\n\r\n\r\n内容传递\r\n1. 变量传递\r\n在引用布局时传递参数：\r\n&lt;!-- home.html --&gt;&lt;html th:replace=&quot;~&#123;layout/main :: layout(title=&#x27;首页&#x27;, user=$&#123;session.user&#125;)&#125;&quot;&gt;\r\n在布局中使用这些参数：\r\n&lt;!-- layout/main.html --&gt;&lt;title th:text=&quot;$&#123;title&#125;&quot;&gt;默认标题&lt;/title&gt;&lt;p&gt;欢迎, &lt;span th:text=&quot;$&#123;user.name&#125;&quot;&gt;访客&lt;/span&gt;!&lt;/p&gt;\r\n2. 多层内容传递\r\n布局模板可以定义多个可替换区域：\r\n布局模板：\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;title th:text=&quot;$&#123;title&#125;&quot;&gt;默认标题&lt;/title&gt;    &lt;meta name=&quot;description&quot; th:content=&quot;$&#123;description&#125;&quot;&gt;默认描述&lt;/meta&gt;    &lt;th:block th:insert=&quot;~&#123;::head&#125;&quot;&gt;&lt;/th:block&gt; &lt;!-- 头部自定义内容 --&gt;&lt;/head&gt;&lt;body&gt;    &lt;header th:replace=&quot;~&#123;layout/header::header&#125;&quot;&gt;&lt;/header&gt;        &lt;main th:insert=&quot;~&#123;::content&#125;&quot;&gt;        &lt;p&gt;默认内容&lt;/p&gt;    &lt;/main&gt;        &lt;footer th:replace=&quot;~&#123;layout/footer::footer&#125;&quot;&gt;&lt;/footer&gt;        &lt;th:block th:insert=&quot;~&#123;::scripts&#125;&quot;&gt;&lt;/th:block&gt; &lt;!-- 自定义脚本 --&gt;&lt;/body&gt;&lt;/html&gt;\r\n内容模板：\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;       th:replace=&quot;~&#123;layout/main :: layout(title=&#x27;产品详情&#x27;)&#125;&quot;&gt;&lt;head&gt;    &lt;meta th:fragment=&quot;head&quot; name=&quot;keywords&quot; content=&quot;产品,详情&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;section th:fragment=&quot;content&quot;&gt;        &lt;h1&gt;产品详情&lt;/h1&gt;        &lt;p&gt;产品信息...&lt;/p&gt;    &lt;/section&gt;        &lt;th:block th:fragment=&quot;scripts&quot;&gt;        &lt;script src=&quot;/js/product-detail.js&quot;&gt;&lt;/script&gt;    &lt;/th:block&gt;&lt;/body&gt;&lt;/html&gt;\r\n片段引用语法\r\n\r\n标准引用：\r\nth:replace=&quot;~&#123;layout/main::content&#125;&quot;\r\n简化引用：\r\nth:replace=&quot;layout/main::content&quot;  &lt;!-- 省略 ~&#123;&#125; --&gt;\r\n带参数的引用：\r\nth:replace=&quot;~&#123;layout/header::header(title=&#x27;首页&#x27;, user=$&#123;user&#125;)&#125;&quot;\r\n\r\n模板继承\r\nThymeleaf\r\n的模板继承机制允许创建一个基础模板定义页面结构，然后子模板可以继承这个基础模板并替换特定部分。这种模式类似于\r\nJava 中的类继承，是实现页面布局复用的核心功能。\r\n1. 定义布局模板\r\n定义页面的整体结构，包含通用元素（如头部、导航、页脚），并使用\r\nth:fragment 定义可替换的区域。\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;       th:replace=&quot;~&#123;layout/main :: layout(title=&#x27;首页&#x27;)&#125;&quot;&gt;&lt;body&gt;    &lt;!-- 定义将插入到布局中main区域的内容 --&gt;    &lt;section th:fragment=&quot;content&quot;&gt;        &lt;h1&gt;欢迎来到首页&lt;/h1&gt;        &lt;p&gt;这是首页的主要内容&lt;/p&gt;    &lt;/section&gt;&lt;/body&gt;&lt;/html&gt;\r\n2. 子模板继承 继承布局模板，通过\r\nth:replace 或 th:insert\r\n指令替换布局中的特定片段。\r\nth:replace = “&#123;模板名 :: 片段名&#125;”\r\n布局模板\r\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;title th:text=&quot;$&#123;title&#125; ?: &#x27;默认标题&#x27;&quot;&gt;标题&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 头部导航 --&gt;    &lt;header th:replace=&quot;~&#123;layout/header::header&#125;&quot;&gt;&lt;/header&gt;        &lt;!-- 侧边栏 --&gt;    &lt;aside th:replace=&quot;~&#123;layout/sidebar::sidebar&#125;&quot;&gt;&lt;/aside&gt;        &lt;!-- 主要内容区域 --&gt;    &lt;main th:insert=&quot;~&#123;::content&#125;&quot;&gt;        &lt;p&gt;默认内容&lt;/p&gt;    &lt;/main&gt;        &lt;!-- 页脚 --&gt;    &lt;footer th:replace=&quot;~&#123;layout/footer::footer&#125;&quot;&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;\r\ndevtools\r\n1. 添加依赖 在 pom.xml 中添加\r\nDevTools：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\r\n2. 主要功能\r\n\r\n自动重启：修改模板或 Java 代码后自动重启应用\r\n热部署：模板文件修改后无需重启，直接刷新页面\r\n禁用缓存：自动禁用模板缓存，确保修改实时生效\r\n\r\n3. 注意事项\r\n\r\nJava 代码修改可能导致热启动异常（如静态变量状态丢失）\r\n复杂 Bean 初始化可能失败，需手动重启\r\n使用 ctrl + F9 强制刷新模板更改\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","前端技术","学习","Spring系列","Spring Boot","Java框架","源码分析","Spring MVC"]},{"title":"Spring Boot part13-全面接管Spring MVC","url":"/posts/8200.html","content":"全面接管 SpringMVC 的思路\r\nSpringBoot 默认配置好了 SpringMVC 的所有常⽤特性。\r\n在 SpringBoot 中，全面接管 SpringMVC\r\n配置的思路是通过禁用默认配置并完全自定义所有 MVC\r\n行为。这是一个高级用法，适用于需要对 SpringMVC 进行深度定制的场景。\r\n全面接管 SpringMVC 的核心步骤如下：\r\n\r\n创建一个配置类，实现WebMvcConfigurer接口\r\n使用@EnableWebMvc注解禁用 SpringBoot 的默认 MVC\r\n配置\r\n重写WebMvcConfigurer接口中的方法来定义所有需要的 MVC\r\n行为，WebMvcConfigurer组件定义MVC的底层行为\r\n\r\n回忆一下配置类的三种自定义方式\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n全自动\r\n直接编写控制器逻辑\r\n\r\n全部使用自动配置默认效果\r\n\r\n\r\n\r\n\r\n手自一体\r\n@Configuration + 配置 WebMvcConfigurer +\r\n配置 WebMvcRegistrations\r\n不要标注@EnableWebMvc\r\n自动配置效果 手动设置部分功能 定义 MVC 底层组件\r\n\r\n\r\n全手动\r\n@Configuration + 配置\r\nWebMvcConfigurer\r\n标注@EnableWebMvc\r\n禁用自动配置效果 全手动设置\r\n\r\n\r\n\r\n例如，如下就是一个全面接管 SpringMVC 配置的示例代码：\r\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.format.FormatterRegistry;import org.springframework.http.CacheControl;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.validation.MessageCodesResolver;import org.springframework.validation.Validator;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.HandlerMethodReturnValueHandler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.config.annotation.*;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import java.util.List;import java.util.concurrent.TimeUnit;@Configuration@EnableWebMvc // 禁用SpringBoot默认的MVC配置public class WebMvcConfig implements WebMvcConfigurer &#123;    // 配置静态资源处理    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/static/**&quot;)                .addResourceLocations(&quot;classpath:/static/&quot;)                .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));    &#125;    // 配置视图控制器    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;/home&quot;).setViewName(&quot;home&quot;);        registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;);        registry.addViewController(&quot;/hello&quot;).setViewName(&quot;hello&quot;);        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);    &#125;    // 配置拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);    &#125;    // 配置跨域支持    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/api/**&quot;)                .allowedOrigins(&quot;http://domain2.com&quot;)                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;)                .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)                .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)                .allowCredentials(true).maxAge(3600);    &#125;    // 配置路径匹配    @Override    public void configurePathMatch(PathMatchConfigurer configurer) &#123;        configurer.setUseSuffixPatternMatch(false)                .setUseTrailingSlashMatch(true);    &#125;    // 配置内容协商    @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        configurer.defaultContentType(org.springframework.http.MediaType.APPLICATION_JSON);    &#125;    // 配置消息转换器    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        // 自定义消息转换器配置        // 注意：这里需要完全自定义，SpringBoot不会添加默认的转换器    &#125;    // 配置异常处理器    @Override    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;        // 自定义异常处理器    &#125;    // 配置参数解析器    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;        // 添加自定义参数解析器    &#125;    // 配置返回值处理器    @Override    public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;        // 添加自定义返回值处理器    &#125;    // 配置数据格式化    @Override    public void addFormatters(FormatterRegistry registry) &#123;        // 添加自定义格式化器    &#125;    // 配置Validator    @Override    public Validator getValidator() &#123;        // 返回自定义Validator        return null;    &#125;    // 配置消息代码解析器    @Override    public MessageCodesResolver getMessageCodesResolver() &#123;        // 返回自定义消息代码解析器        return null;    &#125;    // 配置RequestMappingHandlerMapping    @Bean    public RequestMappingHandlerMapping requestMappingHandlerMapping() &#123;        RequestMappingHandlerMapping mapping = new RequestMappingHandlerMapping();        mapping.setOrder(0);        mapping.setInterceptors(getInterceptors());        // 自定义配置        return mapping;    &#125;&#125;\r\n\r\n@EnableWebMvc\r\n注解：这个注解是全面接管的关键，它会禁用 SpringBoot 的自动 MVC\r\n配置，让你完全控制所有 MVC 行为。\r\nWebMvcConfigurer\r\n接口：实现这个接口并重写其方法，可以自定义各种 MVC 行为：\r\n\r\n静态资源处理\r\n视图控制器配置\r\n拦截器注册\r\n跨域支持\r\n路径匹配策略\r\n内容协商\r\n消息转换器\r\n异常处理器\r\n参数解析器\r\n返回值处理器\r\n数据格式化\r\n\r\n自定义 Bean：除了实现接口方法外，还可以通过\r\n@Bean注解提供自定义的组件，如\r\nRequestMappingHandlerMapping、Validator等。\r\n\r\nWebMvcConfigurer\r\n接口分析及方法详解\r\n源码分析\r\norg.springframework.web.servlet.config.annotation.WebMvcConfigurer\r\n是 Spring MVC 提供的一个接口，用于自定义 Web MVC 的配置。它是一个\r\n标记接口（marker\r\ninterface），它本身没有任何抽象方法，但提供了一组默认为空实现的方法（Java\r\n8+ 的 default 方法），开发者可以选择性地覆盖这些方法来定制 Spring MVC\r\n的行为。\r\n来看看WebMvcConfigurer接口的源代码，对应方法我编写了注释\r\npackage org.springframework.web.servlet.config.annotation;import java.util.List;import org.springframework.format.FormatterRegistry;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.lang.Nullable;import org.springframework.validation.MessageCodesResolver;import org.springframework.validation.Validator;import org.springframework.web.ErrorResponse;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.HandlerMethodReturnValueHandler;import org.springframework.web.servlet.HandlerExceptionResolver;/** * 用于自定义Spring MVC配置的接口。 * 实现此接口的类可以选择性地重写其方法来自定义Spring MVC的行为， * 而无需使用XML配置或完全替换默认配置。 *  * 注意：如果使用@EnableWebMvc注解，Spring Boot的自动配置将被禁用， * 所有MVC配置都必须通过实现此接口来显式定义。 */public interface WebMvcConfigurer &#123;        /**     * 配置路径匹配选项，如后缀模式匹配、尾部斜杠匹配等。     */    default void configurePathMatch(PathMatchConfigurer configurer) &#123;    &#125;    /**     * 配置内容协商策略，用于确定请求和响应的媒体类型。     */    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;    &#125;    /**     * 配置异步请求处理选项，如异步请求超时时间、任务执行器等。     */    default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;    &#125;    /**     * 配置默认Servlet处理，用于处理静态资源请求。     */    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;    &#125;    /**     * 注册自定义的格式化器和转换器，用于类型转换和格式化。     */    default void addFormatters(FormatterRegistry registry) &#123;    &#125;    /**     * 注册自定义的拦截器，用于处理请求的预处理和后处理。     */    default void addInterceptors(InterceptorRegistry registry) &#123;    &#125;    /**     * 注册自定义的资源处理器，用于处理静态资源请求。     */    default void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    &#125;    /**     * 配置跨域资源共享(CORS)映射，允许跨域请求。     */    default void addCorsMappings(CorsRegistry registry) &#123;    &#125;    /**     * 注册视图控制器，用于直接映射URL到视图而不需要控制器方法。     */    default void addViewControllers(ViewControllerRegistry registry) &#123;    &#125;    /**     * 配置视图解析器，用于将逻辑视图名称解析为实际的视图实现。     */    default void configureViewResolvers(ViewResolverRegistry registry) &#123;    &#125;    /**     * 注册自定义的处理器方法参数解析器，用于处理控制器方法的参数。     */    default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;    &#125;    /**     * 注册自定义的处理器方法返回值处理器，用于处理控制器方法的返回值。     */    default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;    &#125;    /**     * 配置HTTP消息转换器列表。此方法用于完全自定义消息转换器，     * 会替换默认的转换器列表。     */    default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    &#125;    /**     * 扩展默认的HTTP消息转换器列表。此方法用于在默认转换器的基础上添加自定义转换器，     * 而不是替换它们。     */    default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    &#125;    /**     * 配置处理器异常解析器列表。此方法用于完全自定义异常解析器，     * 会替换默认的解析器列表。     */    default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    &#125;    /**     * 扩展默认的处理器异常解析器列表。此方法用于在默认解析器的基础上添加自定义解析器，     * 而不是替换它们。     */    default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    &#125;    /**     * 添加错误响应拦截器，用于自定义错误响应的处理。     */    default void addErrorResponseInterceptors(List&lt;ErrorResponse.Interceptor&gt; interceptors) &#123;    &#125;    /**     * 提供自定义的Validator实现，用于数据验证。     */    @Nullable    default Validator getValidator() &#123;        return null;    &#125;    /**     * 提供自定义的MessageCodesResolver实现，用于解析验证错误代码。     */    @Nullable    default MessageCodesResolver getMessageCodesResolver() &#123;        return null;    &#125;&#125;\r\n总结下来就是：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法名\r\n描述\r\n常用场景\r\n\r\n\r\n\r\n\r\nconfigurePathMatch\r\n配置路径匹配选项，如后缀模式匹配、尾部斜杠匹配等\r\n自定义 URL 匹配规则，如禁用.html后缀匹配\r\n\r\n\r\nconfigureContentNegotiation\r\n配置内容协商策略，用于确定请求和响应的媒体类型\r\n设置默认响应格式为 JSON，配置基于 URL 扩展名的内容协商\r\n\r\n\r\nconfigureAsyncSupport\r\n配置异步请求处理选项，如异步请求超时时间、任务执行器等\r\n设置异步请求超时时间，配置 DeferredResult 处理\r\n\r\n\r\nconfigureDefaultServletHandling\r\n配置默认 Servlet 处理，用于处理静态资源请求\r\n启用默认 Servlet 处理静态资源\r\n\r\n\r\naddFormatters\r\n注册自定义的格式化器和转换器，用于类型转换和格式化\r\n添加日期格式化器，注册自定义类型转换器\r\n\r\n\r\naddInterceptors\r\n注册自定义的拦截器，用于处理请求的预处理和后处理\r\n添加身份验证拦截器，实现请求日志记录\r\n\r\n\r\naddResourceHandlers\r\n注册自定义的资源处理器，用于处理静态资源请求\r\n配置静态资源路径，设置缓存控制头\r\n\r\n\r\naddCorsMappings\r\n配置跨域资源共享 (CORS) 映射，允许跨域请求\r\n允许特定域名访问 API，配置跨域请求头\r\n\r\n\r\naddViewControllers\r\n注册视图控制器，用于直接映射 URL 到视图而不需要控制器方法\r\n简化登录页面、主页等简单视图的映射\r\n\r\n\r\nconfigureViewResolvers\r\n配置视图解析器，用于将逻辑视图名称解析为实际的视图实现\r\n配置 JSP、Thymeleaf 等视图解析器\r\n\r\n\r\naddArgumentResolvers\r\n注册自定义的处理器方法参数解析器，用于处理控制器方法的参数\r\n添加自定义参数解析器，如用户会话参数\r\n\r\n\r\naddReturnValueHandlers\r\n注册自定义的处理器方法返回值处理器，用于处理控制器方法的返回值\r\n添加自定义返回值处理器，如统一 API 响应格式\r\n\r\n\r\nconfigureMessageConverters\r\n配置 HTTP 消息转换器列表，会替换默认转换器\r\n完全自定义消息转换器，如使用自定义 JSON 序列化器\r\n\r\n\r\nextendMessageConverters\r\n扩展默认的 HTTP 消息转换器列表\r\n在默认转换器基础上添加自定义转换器\r\n\r\n\r\nconfigureHandlerExceptionResolvers\r\n配置处理器异常解析器列表，会替换默认解析器\r\n完全自定义异常处理机制\r\n\r\n\r\nextendHandlerExceptionResolvers\r\n扩展默认的处理器异常解析器列表\r\n添加自定义异常处理器\r\n\r\n\r\naddErrorResponseInterceptors\r\n添加错误响应拦截器，用于自定义错误响应的处理\r\n自定义错误响应格式，添加额外错误信息\r\n\r\n\r\ngetValidator\r\n提供自定义的 Validator 实现，用于数据验证\r\n提供自定义验证器，如使用 Hibernate Validator\r\n\r\n\r\ngetMessageCodesResolver\r\n提供自定义的 MessageCodesResolver 实现，用于解析验证错误代码\r\n自定义错误代码解析逻辑\r\n\r\n\r\n\r\n接下来我会挑出其中重要的进行分析和讲解\r\nconfigureMessageConverters\r\nvs extendMessageConverters\r\nSpring MVC 默认提供了一系列消息转换器，如\r\nMappingJackson2HttpMessageConverter（JSON）、StringHttpMessageConverter\r\n等\r\n这两个方法都用于配置 HTTP 消息转换器，但作用不同\r\n\r\nconfigureMessageConverters:\r\n完全自定义消息转换器列表，会替换默认的转换器\r\nextendMessageConverters:\r\n在默认转换器的基础上添加自定义转换器\r\n\r\n@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    // 完全自定义消息转换器，不使用默认转换器    converters.add(new MappingJackson2HttpMessageConverter());    converters.add(new StringHttpMessageConverter());&#125;@Overridepublic void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    // 在默认转换器的基础上添加自定义转换器    converters.add(new MyCustomHttpMessageConverter());&#125;\r\n建议使用 extendMessageConverters 和\r\nextendHandlerExceptionResolvers 而不是完全替换默认配置\r\n底层实现差异：\r\n// 在RequestMappingHandlerAdapter初始化时调用if (configurers.configureMessageConverters) &#123;    // 完全替换默认转换器    adapter.setMessageConverters(converters); &#125; else &#123;    // 追加自定义转换器    adapter.addMessageConverters(converters);&#125;\r\naddInterceptors(InterceptorRegistry registry)\r\n用于注册自定义拦截器，可以在请求处理前后执行特定逻辑，如身份验证、日志记录等。\r\n拦截器很像 Servlet\r\n中的过滤器（Filter），但拦截器提供了更精细的控制和更丰富的功能，允许你在请求处理的不同阶段执行特定逻辑\r\n拦截器是实现横切关注点的好方法，如认证、日志、性能监控等，在这里写一些登录常用的逻辑很不错\r\n@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(new AuthenticationInterceptor())            .addPathPatterns(&quot;/api/**&quot;)  // 拦截路径            .excludePathPatterns(&quot;/api/public/**&quot;);  // 排除路径&#125;\r\n拦截器链的执行原理\r\nsequenceDiagram\n    participant DispatcherServlet\n    participant Interceptor1\n    participant Interceptor2\n    participant Handler\n    \n    DispatcherServlet-&gt;&gt;Interceptor1: preHandle()\n    Interceptor1-&gt;&gt;Interceptor2: preHandle()\n    Interceptor2-&gt;&gt;Handler: 执行控制器方法\n    Handler--&gt;&gt;Interceptor2: postHandle()\n    Interceptor2--&gt;&gt;Interceptor1: postHandle()\n    Interceptor1--&gt;&gt;DispatcherServlet: afterCompletion()\r\n拦截器与过滤器对比：\r\n\r\n\r\n\r\n特性\r\n拦截器(Interceptor)\r\n过滤器(Filter)\r\n\r\n\r\n\r\n\r\n作用域\r\nSpring MVC上下文\r\nServlet容器层面\r\n\r\n\r\n依赖\r\n依赖Spring框架\r\n仅需Servlet API\r\n\r\n\r\n执行时机\r\n控制器方法前后\r\n请求进入Servlet之前\r\n\r\n\r\n异常处理\r\n可接入ControllerAdvice\r\n只能跳转错误页面\r\n\r\n\r\n\r\naddResourceHandlers\r\n用于配置静态资源处理器，如\r\nCSS、JavaScript、图片等文件的访问路径。\r\n@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    // 自定义静态资源路径    registry.addResourceHandler(&quot;/static/**&quot;)            .addResourceLocations(&quot;classpath:/static/&quot;)            .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));        // 配置WebJars支持    registry.addResourceHandler(&quot;/webjars/**&quot;)            .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);        // 配置自定义欢迎页    registry.addResourceHandler(&quot;/&quot;)            .addResourceLocations(&quot;classpath:/public/index.html&quot;)            .setCacheControl(CacheControl.noCache());&#125;\r\naddCorsMappings\r\n用于配置跨域资源共享 (CORS)，允许浏览器从不同域名访问 API。\r\nCORS 原理：\r\n\r\n浏览器实施同源策略，跨域请求需服务器明确允许\r\n简单请求直接发送，预检请求（复杂请求）先发送 OPTIONS 请求\r\nSpring MVC\r\n通过设置响应头（如Access-Control-Allow-Origin）实现 CORS\r\n支持\r\n\r\n@Overridepublic void addCorsMappings(CorsRegistry registry) &#123;    registry.addMapping(&quot;/api/**&quot;)            .allowedOrigins(&quot;http://example.com&quot;, &quot;https://example.com&quot;)            .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)            .allowedHeaders(&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;)            .exposedHeaders(&quot;Location&quot;, &quot;X-Total-Count&quot;)            .allowCredentials(true)            .maxAge(3600); // 预检请求缓存1小时        // 针对特定API的细粒度配置    registry.addMapping(&quot;/api/auth/**&quot;)            .allowedOrigins(&quot;*&quot;)            .allowedMethods(&quot;POST&quot;, &quot;OPTIONS&quot;)            .maxAge(3600);&#125;\r\nconfigureHandlerExceptionResolvers\r\nvs extendHandlerExceptionResolvers\r\n默认异常解析器：\r\n\r\nExceptionHandlerExceptionResolver -\r\n处理带@ExceptionHandler注解的方法\r\nResponseStatusExceptionResolver -\r\n处理带@ResponseStatus注解的异常\r\nDefaultHandlerExceptionResolver - 处理 Spring MVC\r\n标准异常\r\n\r\n这两个方法用于配置异常处理器：\r\n\r\nconfigureHandlerExceptionResolvers:\r\n完全自定义异常处理器列表\r\nextendHandlerExceptionResolvers:\r\n在默认处理器的基础上添加自定义处理器\r\n\r\n@Overridepublic void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    // 添加自定义异常解析器    resolvers.add(new MyCustomExceptionResolver());        // 找到并修改默认的ExceptionHandlerExceptionResolver    resolvers.stream()            .filter(resolver -&gt; resolver instanceof ExceptionHandlerExceptionResolver)            .findFirst()            .ifPresent(resolver -&gt; &#123;                ExceptionHandlerExceptionResolver exResolver = (ExceptionHandlerExceptionResolver) resolver;                // 自定义配置            &#125;);&#125;\r\nconfigureContentNegotiation(ContentNegotiationConfigurer configurer)\r\n配置内容协商策略，根据请求头或 URL 参数决定返回的数据格式（如\r\nJSON、XML）。\r\n@Overridepublic void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;    configurer        .favorParameter(true) // 优先使用请求参数        .parameterName(&quot;format&quot;) // 参数名        .ignoreAcceptHeader(false) // 不忽略Accept头        .useRegisteredExtensionsOnly(false) // 允许未注册的扩展名        .defaultContentType(MediaType.APPLICATION_JSON) // 默认内容类型        .mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON) // 注册媒体类型映射        .mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML);&#125;\r\nconfigureAsyncSupport(AsyncSupportConfigurer configurer)\r\n异步请求类型：\r\n\r\nCallable -\r\n控制器返回Callable，在单独线程中执行\r\nDeferredResult -\r\n控制器返回DeferredResult，在另一个线程中设置结果\r\nResponseBodyEmitter - 流式响应\r\nSseEmitter - 服务器发送事件\r\nStreamingResponseBody - 流式响应体\r\n\r\n配置异步请求支持，例如设置任务执行超时时间、线程池等。\r\n@Overridepublic void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;    // 设置超时时间    configurer.setDefaultTimeout(30000); // 30秒        // 配置异步任务执行器    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();    executor.setCorePoolSize(10);    executor.setMaxPoolSize(100);    executor.setQueueCapacity(100);    executor.setThreadNamePrefix(&quot;AsyncTask-&quot;);    executor.initialize();    configurer.setTaskExecutor(executor);        // 注册异步请求拦截器    configurer.registerCallableInterceptors(new TimeoutCallableProcessingInterceptor());    configurer.registerDeferredResultInterceptors(new TimeoutDeferredResultProcessingInterceptor());&#125;\r\nconfigurePathMatch(PathMatchConfigurer configurer)\r\n关键配置项：\r\n\r\nsetUseSuffixPatternMatch -\r\n是否启用后缀模式匹配（如/users.html匹配/users）\r\nsetUseTrailingSlashMatch -\r\n是否启用尾部斜杠匹配（如/users/匹配/users）\r\nsetUseRegisteredSuffixPatternMatch -\r\n仅匹配已注册的后缀\r\nsetPathMatcher - 设置自定义路径匹配器\r\nsetUrlPathHelper - 设置自定义 URL 路径帮助器\r\n\r\n@Overridepublic void configurePathMatch(PathMatchConfigurer configurer) &#123;    // 禁用后缀模式匹配（防止/resource.json绕过安全检查）    configurer.setUseSuffixPatternMatch(false);        // 启用尾部斜杠匹配    configurer.setUseTrailingSlashMatch(true);        // 配置路径匹配器    AntPathMatcher pathMatcher = new AntPathMatcher();    pathMatcher.setCaseSensitive(true); // 区分大小写    pathMatcher.setTrimTokens(true); // 去除路径中的空白字符    configurer.setPathMatcher(pathMatcher);&#125;\r\nWebMvcAutoConfiguration\r\n到底自动配置了哪些规则\r\nSpringMVC\r\n自动配置场景给我们配置了如下所有默认行为，其中的过程和涉及到的细节内容我也一起讲解，因为东西太多，只是过一遍会很混乱\r\n\r\nWebMvcAutoConfiguration web 场景的自动配置类\r\n\r\n支持 RESTful 的 filter：HiddenHttpMethodFilter\r\n\r\n作用：在浏览器表单仅支持 GET、POST\r\n原生请求方法的限制下，通过请求参数（默认参数名为 _method\r\n），将 POST 请求转换为\r\nPUT、DELETE、PATCH 等符合 RESTful\r\n规范的请求方法，让普通表单也能适配 RESTful 风格接口。\r\n例如：前端页面要发送一个删除资源的 DELETE\r\n请求，但浏览器无法直接发起，就可以用 POST 表单携带\r\n_method=DELETE 参数，经此 Filter 转换后，后端控制器就能用\r\n@DeleteMapping 接收处理。\r\n\r\n支持非 POST\r\n请求，请求体携带数据：FormContentFilter\r\n\r\n作用：对于 PUT、PATCH 等非\r\nPOST 请求，解决浏览器默认不会像 POST\r\n请求那样自动携带表单数据（请求体内容\r\n）的问题。它会解析请求体中的表单参数，并将这些参数填充到请求对象中，使后端控制器方法能像处理\r\nPOST 请求参数一样，正常获取\r\nPUT、PATCH 等请求携带的表单数据。比如前端用\r\nPUT\r\n请求更新用户信息，携带表单形式的用户姓名、年龄等参数，后端通过\r\n@RequestParam 等注解就能顺利拿到这些参数进行业务处理。\r\n生效逻辑：自动注册到 Filter 链，针对\r\nPUT、PATCH\r\n等方法的请求，在请求处理前期解析请求体表单数据，为后续控制器方法执行做准备。\r\n\r\n导入 EnableWebMvcConfiguration：\r\nEnableWebMvcConfiguration 是\r\nWebMvcAutoConfiguration 内部类，继承自\r\nDelegatingWebMvcConfiguration ，它借助 Spring\r\n框架的配置机制，进一步初始化和配置一系列 Spring MVC\r\n核心组件，具体如下：\r\n\r\nRequestMappingHandlerAdapter:\r\n\r\n作为 Spring MVC 中处理请求的重要适配器，负责调用被\r\n@RequestMapping（及衍生的\r\n@GetMapping、@PostMapping 等\r\n）标注的控制器方法。在调用过程中，它会处理请求参数的绑定（比如将 HTTP\r\n请求参数转换为控制器方法的入参类型\r\n）、返回值的处理（把控制器方法返回结果转换为合适的响应数据格式，如\r\nJSON、视图名等 ），是连接请求、控制器方法、响应的关键桥梁。\r\n初始化：由 EnableWebMvcConfiguration 依据 Spring 容器的\r\nBean 管理机制，结合默认配置和用户可能的自定义配置（若有实现\r\nWebMvcConfigurer 相关参数处理定制\r\n），完成创建和初始化，确保能适配各种常见的参数、返回值处理场景。\r\n\r\nWelcomePageHandlerMapping：欢迎页功能支持（模板引擎目录、静态资源目录放\r\nindex.html）\r\n\r\n当访问应用根路径（/\r\n）时，它会按照一定优先级顺序去查找欢迎页资源。优先在模板引擎可解析的目录（如使用\r\nThymeleaf 时的 classpath:/templates/ ）下查找\r\nindex.html\r\n，若未找到，会到静态资源目录（classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/\r\n等 ）中寻找 index.html\r\n文件，找到后就会将该页面作为欢迎页展示，让访问根路径的请求能直接呈现友好的首页内容。\r\n\r\nRequestMappingHandlerMapping：找每个请求由谁处理的映射关系\r\n\r\n负责扫描 Spring 容器中所有被\r\n@Controller、@RestController\r\n标注的控制器类，以及这些类中被 @RequestMapping\r\n及其衍生注解（@GetMapping、@PostMapping 等\r\n）标注的方法，然后建立并维护 “请求路径 ↔︎ 控制器方法”\r\n的映射关系。后续当有 HTTP\r\n请求到达时，能依据请求路径快速找到对应的控制器方法进行处理，是 Spring\r\nMVC 实现请求路由的核心基础。\r\n扫描与构建：在应用启动时，它会遍历符合条件的 Bean\r\n，解析注解信息，构建起庞大的请求路径映射注册表，并且在应用运行过程中，若有\r\nBean 动态加载（如通过 Bean 定义注册器新增控制器 Bean\r\n），也能适时更新映射关系。\r\n\r\nExceptionHandlerExceptionResolver：默认的异常解析器\r\n\r\n作为 Spring MVC\r\n默认的异常解析器，用于处理控制器方法执行过程中抛出的异常。它会查找被\r\n@ExceptionHandler\r\n标注的异常处理方法（可以是当前控制器类中的方法，也能是通过\r\n@ControllerAdvice 全局配置的方法\r\n），将异常交由对应的处理方法进行逻辑处理（比如返回自定义错误提示、错误码等\r\n），最终生成合适的响应（可以是 JSON 数据、错误页面等\r\n）返回给客户端，保证应用遇到异常时能有统一、友好的错误处理表现。\r\n异常处理流程：当控制器方法抛出异常后，DispatcherServlet\r\n会将异常交给 ExceptionHandlerExceptionResolver\r\n，它依据异常类型去匹配对应的 @ExceptionHandler\r\n方法，执行方法得到处理结果后，再转换为响应发送给客户端，若未找到匹配的处理方法，会按默认的异常处理逻辑（如返回\r\n500 错误等 ）处理。\r\n\r\nLocaleResolver：国际化解析器\r\n\r\n用于处理 Web 应用的国际化（多语言\r\n）需求，解析请求中的语言区域信息。默认情况下，它会根据 HTTP 请求头中的\r\nAccept-Language 字段来判断客户端期望的语言类型（如\r\nzh-CN 表示中文 - 中国，en-US 表示英文 - 美国\r\n），然后结合应用中配置的国际化资源文件（如\r\nmessages_zh_CN.properties、messages_en_US.properties\r\n等\r\n），为后续的视图渲染、消息提示等提供对应的语言环境支持，让应用能根据不同地区用户展示合适的语言内容。\r\n若默认的基于 Accept-Language\r\n的解析方式不能满足需求（比如想通过请求参数 ?lang=zh\r\n来切换语言 ），可通过实现 LocaleResolver\r\n接口自定义解析逻辑，再配置到 Spring MVC 环境中替换默认实现。\r\n\r\nThemeResolver：主题解析器\r\n\r\n主要用于处理 Web\r\n应用的主题切换需求，比如不同的页面风格、样式主题等。它会依据一定的规则（默认可通过请求参数、Session\r\n等方式\r\n）确定当前请求对应的主题，后续视图解析、资源加载等环节就能根据主题信息，使用对应的主题资源（如不同主题的\r\nCSS 样式文件、页面模板等 ），实现应用界面主题的灵活切换和展示。\r\n应用场景：在一些需要让用户自定义界面风格（如浅色主题、深色主题\r\n）的系统中，通过 ThemeResolver\r\n配合主题相关的视图解析、资源管理，能很好地实现不同主题的切换和呈现。\r\n\r\nFlashMapManager：临时数据共享\r\n\r\n实现重定向时临时数据的共享功能。当控制器方法处理完请求，需要重定向到另一个\r\nURL ，并且希望在重定向后能获取到一些 “一次性” 的数据（如提示信息\r\n“操作成功，请查看详情” ）时，可通过 FlashMap\r\n存储这些数据，FlashMapManager 负责管理\r\nFlashMap 的创建、存储（通常存储在 Session 中\r\n）和获取。重定向前将数据存入 FlashMap\r\n，重定向后的请求处理时，FlashMapManager\r\n会取出数据供后续使用，使用完后这些数据会被清除，保证是 “一次性” 的。\r\n@PostMapping(&quot;/save&quot;)public String saveData(RedirectAttributes redirectAttributes) &#123;    // 业务处理...    redirectAttributes.addFlashAttribute(&quot;msg&quot;, &quot;数据保存成功&quot;);    return &quot;redirect:/list&quot;;    // 在重定向后的 /list 对应的控制器方法或视图中，就能获取到 msg 这个一次性提示数据。&#125;\r\n\r\nFormattingConversionService：数据格式化、类型转化\r\n\r\n职责：承担着数据格式化和类型转换的重要职责。在请求参数绑定阶段，它会将\r\nHTTP\r\n请求中的字符串参数，按照一定规则转换为控制器方法入参的对应类型（比如把请求参数中的字符串\r\n“2024-10-01” 转换为 java.util.Date 类型\r\n）；在响应数据处理时，也能将一些复杂类型（如自定义的枚举类型\r\n）格式化为合适的字符串或其他可传输的格式。同时，它默认集成了对 JSR303\r\n校验相关的支持，在数据转换、绑定过程中，能配合校验注解（如\r\n@DateTimeFormat 结合 @Valid\r\n）进行数据格式的校验和转换。\r\n扩展能力：用户可通过实现\r\nFormatter、Converter\r\n接口，自定义数据格式化和类型转换规则，然后注册到\r\nFormattingConversionService\r\n中，实现对特殊类型数据（如自定义的日期格式、自定义业务枚举\r\n）的个性化转换和格式化。\r\n\r\nValidator：数据校验 JSR303 提供的数据校验功能\r\n\r\n职责：提供数据校验功能，基于 JSR303（Java Bean Validation 规范\r\n）及后续的 JSR349、JSR380 等规范，支持使用\r\n@Valid、@NotBlank、@Size\r\n等校验注解，对控制器方法的入参（如 @RequestBody\r\n接收的对象、@RequestParam 绑定的参数等\r\n）、实体类的属性进行校验。当校验不通过时，会抛出对应的校验异常，可结合\r\nExceptionHandlerExceptionResolver\r\n进行统一的异常处理和错误提示返回，保证输入数据的合法性和规范性。\r\n\r\nWebBindingInitializer：请求参数的封装与绑定\r\n\r\n在 Spring MVC\r\n请求参数绑定的过程中，负责初始化数据绑定的相关设置。它会参与到请求参数转换为控制器方法入参的整个流程，比如设置默认的类型转换器（关联到\r\nFormattingConversionService\r\n）、初始化数据绑定的一些基础规则（如是否允许空值、日期格式的默认处理等\r\n），确保请求参数能准确、合理地绑定到控制器方法的参数上，为控制器方法正确执行提供数据基础。\r\n关联关系：与 FormattingConversionService\r\n紧密协作，FormattingConversionService\r\n提供具体的类型转换和格式化能力，WebBindingInitializer\r\n则在绑定流程中运用这些能力，同时进行一些初始化、规则设置的工作。\r\n\r\nContentNegotiationManager：内容协商管理器\r\n\r\n职责：实现内容协商功能，决定客户端请求期望的响应数据格式，以及服务端实际返回的响应数据格式。它会综合考虑多个因素来确定响应格式，包括请求头中的\r\nAccept 字段（客户端期望接收的媒体类型，如\r\napplication/json、text/html 等\r\n）、请求参数（可通过设置参数如 ?format=json 来指定响应格式\r\n）等。根据协商结果，Spring MVC 会选择合适的消息转换器（如\r\nMappingJackson2HttpMessageConverter 用于转换 JSON 格式\r\n）来处理响应数据，保证返回给客户端的数据格式是其期望或可接受的。\r\n应用场景：在一个同时提供 JSON 数据接口和 HTML 页面展示的 Web\r\n应用中，通过 ContentNegotiationManager\r\n，就能根据客户端不同的请求（如浏览器直接访问返回 HTML\r\n页面，手机端接口调用返回 JSON 数据\r\n），灵活返回对应的响应格式，提升应用的兼容性和适用性。\r\n\r\n\r\nWebMvcAutoConfigurationAdapter配置生效，它是一个WebMvcConfigurer，定义\r\nmvc 底层组件\r\nWebMvcAutoConfigurationAdapter 是\r\nWebMvcAutoConfiguration 内部的静态类，它实现了\r\nWebMvcConfigurer 接口，作为 Spring Boot\r\n自动配置的具体实现，用来定义 Spring MVC\r\n底层组件的默认配置，以下是其关键配置点：\r\n\r\n定义好WebMvcConfigurer\r\n底层组件默认功能；所有功能详见下面或者上面的列表\r\n视图解析器：InternalResourceViewResolver\r\n\r\n主要用于解析 JSP 等 “内部资源视图”。当控制器方法返回一个视图名（如\r\nreturn \"userInfo\" ）时，它会按照配置的前缀（如\r\nprefix = \"/WEB-INF/views/\" ）和后缀（如\r\nsuffix = \".jsp\" ）规则，拼接出完整的视图资源路径（即\r\n/WEB-INF/views/userInfo.jsp ），然后找到对应的 JSP\r\n文件进行渲染，将动态数据填充到 JSP 页面中，最终返回给客户端呈现。在\r\nWebMvcAutoConfigurationAdapter 中，会依据 Spring Boot\r\n的默认配置策略，设置合适的前缀和后缀（也可通过\r\napplication.properties 等配置文件进行自定义调整\r\n），适配常见的 JSP 视图存储目录结构，让基于 JSP 的 Web\r\n应用能便捷地进行视图解析和渲染。\r\n\r\n视图解析器： BeanNameViewResolver ,\r\n视图名（controller 方法的返回值字符串）就是组件名\r\n\r\n将控制器方法返回的视图名，直接作为 Spring 容器中 View\r\n类型 Bean 的名称去查找对应的视图组件。也就是说，若控制器方法返回视图名\r\n“customView” ，那么 Spring 容器中需要存在一个名为 “customView” 且类型为\r\nView 的 Bean（可以是自定义的 View 实现类\r\n），BeanNameViewResolver 会找到该 Bean\r\n并使用它来渲染视图，实现灵活的视图定制。\r\n\r\n内容协商解析器： ContentNegotiatingViewResolver\r\n\r\n它本身并不直接解析视图，而是结合\r\nContentNegotiationManager\r\n的内容协商结果，从多个视图解析器（如\r\nInternalResourceViewResolver、BeanNameViewResolver\r\n等 ）中选择合适的视图解析器来解析视图。例如，内容协商确定需要返回 HTML\r\n格式的视图，它就会在能解析 HTML 视图的解析器中挑选（如\r\nInternalResourceViewResolver 若配置了解析 JSP 生成 HTML\r\n），然后使用该解析器进行视图解析和渲染，是一个 “协调者”\r\n角色，整合多种视图解析器和内容协商功能。\r\n工作流程：先通过 ContentNegotiationManager\r\n确定响应数据格式需求，再遍历其管理的视图解析器列表，找到第一个能满足该格式需求且能解析对应视图名的解析器，交由其进行视图解析和渲染，保证在内容协商的基础上，能正确找到并使用合适的视图资源。\r\n\r\n请求上下文过滤器：\r\nRequestContextFilter：任意位置直接获取当前请求\r\n\r\n为应用中任意位置（包括非 Web 层的 Service、Component 等\r\n）提供获取当前 HTTP\r\n请求上下文（HttpServletRequest、HttpServletResponse\r\n）的能力。它会在请求处理过程中，将当前的请求和响应对象绑定到线程局部变量（ThreadLocal\r\n）中，后续在同一线程的任意位置，都可以通过\r\nRequestContextHolder.currentRequestAttributes()\r\n等方式获取到当前请求的上下文信息，方便一些非 Web\r\n层组件在需要时使用请求相关的数据（如获取请求头信息、Session 数据等\r\n）。\r\n注意事项：因为是基于 ThreadLocal\r\n实现，所以要注意线程安全和资源释放问题，在异步处理场景中，若不正确处理，可能会导致获取到错误的请求上下文或资源泄漏，不过\r\nSpring Boot 对常见的异步场景也有相应的处理机制来保障其正确性。\r\n\r\npublic class aService &#123;    public void getRequest()&#123;        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        // 任意位置通过  RequestContextHolder 获取到当前请求和响应的信息        HttpServletRequest request = attributes.getRequest();        HttpServletResponse response = attributes.getResponse();                String url = request.getRequestURI();     &#125;&#125;\r\n静态资源链规则\r\nProblemDetailsExceptionHandler：错误详情\r\n\r\n统一处理 Spring MVC\r\n内部抛出的异常，生成标准化的错误详情响应。当控制器方法抛出异常（如参数校验失败的\r\nMethodArgumentNotValidException 、资源未找到的\r\nNoSuchRequestHandlingMethodException 等\r\n）时，它会将异常信息封装成包含 type（错误类型标识\r\n）、title（错误标题 ）、status（HTTP 状态码\r\n）、detail（错误详情 ）等字段的 JSON\r\n响应，让客户端能更清晰、规范地识别错误。\r\n\r\n定义了 MVC 默认的底层行为：WebMvcConfigurer\r\n\r\nWebMvcAutoConfigurationAdapter 本身就是\r\nWebMvcConfigurer 的实现类，它为 Spring MVC\r\n的所有底层行为提供了 “开箱即用” 的默认配置\r\n\r\n\r\n\r\n\r\n核心总结\r\nWebMvcAutoConfiguration 作为 Spring Boot\r\n自动配置的核心，通过以下方式为 Web 应用搭建 MVC 基石：\r\n\r\nFilter 层：通过\r\nHiddenHttpMethodFilter、FormContentFilter\r\n补全浏览器请求能力，适配 RESTful 风格和非 POST 请求的表单处理。\r\n核心组件层：借助\r\nEnableWebMvcConfiguration 初始化\r\nRequestMappingHandlerMapping、ExceptionHandlerExceptionResolver\r\n等 MVC 核心组件，构建 “请求路由 → 处理 → 异常处理” 的完整流程。\r\n默认配置层：通过\r\nWebMvcAutoConfigurationAdapter 实现\r\nWebMvcConfigurer\r\n，为视图解析、资源处理、错误详情等提供开箱即用的默认规则，同时预留\r\nWebMvcConfigurer 扩展点，支持用户按需覆盖。\r\n\r\n理解这些后，再看 Spring Boot 中的 Web 应用：大部分 MVC\r\n需求（如静态资源、视图解析、异常处理 ）都能 “零配置”\r\n运行，这背后正是 WebMvcAutoConfiguration\r\n的功劳；而当需要定制（如修改 JSON 序列化规则、添加自定义拦截器\r\n）时，只需实现 WebMvcConfigurer ，就能在默认配置基础上\r\n“微创” 调整，既享受自动配置的便捷，又保留定制化的灵活性 。\r\n使用表格总结如下\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法名\r\n默认规则\r\n核心参数\r\n常用场景\r\n\r\n\r\n\r\n\r\nconfigurePathMatch\r\n默认启用后缀模式匹配（如/users.html匹配/users）和尾部斜杠匹配（如/users/匹配/users）\r\n- setUseSuffixPatternMatch: 是否启用后缀模式匹配 -\r\nsetUseTrailingSlashMatch: 是否启用尾部斜杠匹配 -\r\nsetPathMatcher: 设置自定义路径匹配器\r\n自定义 URL 匹配规则，如禁用.html后缀匹配\r\n\r\n\r\nconfigureContentNegotiation\r\n默认基于请求的 Accept 头确定响应内容类型，支持 JSON、XML 等\r\n- defaultContentType: 设置默认内容类型 -\r\nfavorPathExtension: 是否优先使用 URL 扩展名进行内容协商 -\r\nmediaTypes: 注册媒体类型映射\r\n设置默认响应格式为 JSON，配置基于 URL 扩展名的内容协商\r\n\r\n\r\nconfigureAsyncSupport\r\n默认异步请求超时时间为 30 秒，使用 SimpleAsyncTaskExecutor\r\n执行异步任务\r\n- setDefaultTimeout: 设置异步请求超时时间 -\r\nsetTaskExecutor: 设置异步任务执行器 -\r\nregisterCallableInterceptors: 注册 Callable 拦截器\r\n设置异步请求超时时间，配置 DeferredResult 处理\r\n\r\n\r\nconfigureDefaultServletHandling\r\n默认不启用默认 Servlet 处理，静态资源由 Spring MVC 处理\r\n- enable: 启用默认 Servlet 处理 -\r\nenableDispatcherTypes: 指定 DispatcherType\r\n启用默认 Servlet 处理静态资源\r\n\r\n\r\naddFormatters\r\n默认注册 JSR-310 日期时间格式化器、数字格式化器等\r\n- FormatterRegistry:\r\n用于注册格式化器和转换器的注册表\r\n添加日期格式化器，注册自定义类型转换器\r\n\r\n\r\naddInterceptors\r\n默认不注册任何拦截器\r\n- InterceptorRegistry: 用于注册拦截器的注册表 -\r\naddPathPatterns: 指定拦截路径 -\r\nexcludePathPatterns: 指定排除路径 - order:\r\n设置拦截器顺序\r\n添加身份验证拦截器，实现请求日志记录\r\n\r\n\r\naddResourceHandlers\r\n默认从classpath:/META-INF/resources/,\r\nclasspath:/resources/, classpath:/static/,\r\nclasspath:/public/加载静态资源，缓存控制头为 365 天\r\n- addResourceHandler: 指定 URL 路径 -\r\naddResourceLocations: 指定资源位置 -\r\nsetCacheControl: 设置缓存控制头 -\r\nsetCachePeriod: 设置缓存时间（秒）\r\n配置静态资源路径，设置缓存控制头\r\n\r\n\r\naddCorsMappings\r\n默认不配置任何 CORS 映射\r\n- addMapping: 指定 CORS 映射路径 -\r\nallowedOrigins: 允许的源 - allowedMethods:\r\n允许的 HTTP 方法 - allowedHeaders: 允许的请求头 -\r\nallowCredentials: 是否允许发送 Cookie -\r\nmaxAge: 预检请求的有效期（秒）\r\n允许特定域名访问 API，配置跨域请求头\r\n\r\n\r\naddViewControllers\r\n默认不注册任何视图控制器\r\n- ViewControllerRegistry: 用于注册视图控制器的注册表 -\r\naddViewController: 添加视图控制器 -\r\nsetViewName: 设置视图名称\r\n简化登录页面、主页等简单视图的映射\r\n\r\n\r\nconfigureViewResolvers\r\n默认根据依赖自动配置视图解析器，如 Thymeleaf、FreeMarker 等\r\n- ViewResolverRegistry: 用于配置视图解析器的注册表 -\r\njsp: 配置 JSP 视图解析器 - thymeleaf: 配置\r\nThymeleaf 视图解析器 - freemarker: 配置 FreeMarker\r\n视图解析器\r\n配置 JSP、Thymeleaf 等视图解析器\r\n\r\n\r\naddArgumentResolvers\r\n默认注册\r\nRequestParamMethodArgumentResolver、PathVariableMethodArgumentResolver\r\n等\r\n- HandlerMethodArgumentResolver:\r\n自定义参数解析器列表\r\n添加自定义参数解析器，如用户会话参数\r\n\r\n\r\naddReturnValueHandlers\r\n默认注册\r\nRequestResponseBodyMethodProcessor、ViewNameMethodReturnValueHandler\r\n等\r\n- HandlerMethodReturnValueHandler:\r\n自定义返回值处理器列表\r\n添加自定义返回值处理器，如统一 API 响应格式\r\n\r\n\r\nconfigureMessageConverters\r\n默认注册\r\nMappingJackson2HttpMessageConverter、StringHttpMessageConverter 等\r\n- HttpMessageConverter:\r\n自定义消息转换器列表（将替换默认转换器）\r\n完全自定义消息转换器，如使用自定义 JSON 序列化器\r\n\r\n\r\nextendMessageConverters\r\n默认注册\r\nMappingJackson2HttpMessageConverter、StringHttpMessageConverter 等\r\n- HttpMessageConverter:\r\n自定义消息转换器列表（添加到默认转换器之后）\r\n在默认转换器基础上添加自定义转换器\r\n\r\n\r\nconfigureHandlerExceptionResolvers\r\n默认注册\r\nExceptionHandlerExceptionResolver、ResponseStatusExceptionResolver\r\n等\r\n- HandlerExceptionResolver:\r\n自定义异常解析器列表（将替换默认解析器）\r\n完全自定义异常处理机制\r\n\r\n\r\nextendHandlerExceptionResolvers\r\n默认注册\r\nExceptionHandlerExceptionResolver、ResponseStatusExceptionResolver\r\n等\r\n- HandlerExceptionResolver:\r\n自定义异常解析器列表（添加到默认解析器之后）\r\n添加自定义异常处理器\r\n\r\n\r\naddErrorResponseInterceptors\r\n默认不注册任何错误响应拦截器\r\n- ErrorResponse.Interceptor: 错误响应拦截器列表\r\n自定义错误响应格式，添加额外错误信息\r\n\r\n\r\ngetValidator\r\n默认使用 Spring 的 LocalValidatorFactoryBean，支持 JSR-303/349\r\n验证\r\n- 返回实现 Validator 接口的自定义验证器\r\n提供自定义验证器，如使用 Hibernate Validator\r\n\r\n\r\ngetMessageCodesResolver\r\n默认使用 DefaultMessageCodesResolver\r\n- 返回实现 MessageCodesResolver 接口的自定义解析器\r\n自定义错误代码解析逻辑\r\n\r\n\r\n\r\n@EnableWebMvc 禁用默行为的原理\r\n@EnableWebMvc 的作用\r\n\r\n核心逻辑：\r\n@EnableWebMvc 会向 Spring 容器中导入\r\nDelegatingWebMvcConfiguration组件。\r\n\r\n而 DelegatingWebMvcConfiguration 是\r\nWebMvcConfigurationSupport 的子类 ，这意味着一旦使用\r\n@EnableWebMvc，本质上就是让\r\nWebMvcConfigurationSupport 相关逻辑进入容器。\r\n\r\n\r\nSpring Boot 中 Spring\r\nMVC 自动配置的条件\r\n\r\n关键注解：WebMvcAutoConfiguration（Spring\r\nBoot 对 Spring MVC 的自动配置类）上有一个条件注解：\r\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\r\n含义是：当 Spring 容器中没有\r\nWebMvcConfigurationSupport 类型的 Bean\r\n时，WebMvcAutoConfiguration 才会生效，进而启用\r\nSpring Boot 对 Spring MVC 的默认自动配置。\r\n\r\n@EnableWebMvc\r\n禁用默认自动配置的原因\r\n\r\n因为 @EnableWebMvc 导入了\r\nWebMvcConfigurationSupport（通过\r\nDelegatingWebMvcConfiguration 间接引入 ），此时容器中存在\r\nWebMvcConfigurationSupport 类型的 Bean。\r\n这就触发了 WebMvcAutoConfiguration 的条件注解\r\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\r\n不满足条件，导致 WebMvcAutoConfiguration\r\n失效，最终禁用了 Spring Boot 对 Spring MVC 的默认自动配置行为。\r\n\r\n所以，@EnableWebMvc\r\n的影响体现在，一旦在配置类上标注\r\n@EnableWebMvc，会让 Spring Boot 中 Spring MVC\r\n的自动配置失效，需要你自己通过 WebMvcConfigurer（或直接继承\r\nWebMvcConfigurationSupport）手动配置 Spring MVC\r\n的底层组件（如拦截器、消息转换器、视图解析器等 。\r\n而WebMvcConfigurer 的角色就充当是一个定义 Spring MVC\r\n底层组件功能的接口，你可以实现它来定制 Spring MVC 行为。即使不用\r\n@EnableWebMvc（即保留 Spring Boot 自动配置），也能通过\r\nWebMvcConfigurer 做定制化扩展；但用了\r\n@EnableWebMvc 后，自动配置失效，更需要实现\r\nWebMvcConfigurer 接口或更底层的\r\nWebMvcConfigurationSupport 接口来手动搭建 MVC\r\n功能，实现自己的 WebMvcConfigurer配置类。\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","JavaEE","Web","Spring系列","Servlet","Spring Boot","Java框架","配置相关","源码分析"]},{"title":"Spring Boot part11-错误处理","url":"/posts/35587.html","content":"前言\r\n在项目开发的过程中， 不管是对底层数据库的操作过程，\r\n还是业务层的处理过程， 还是控制层的处理过程，\r\n都不可避免会遇到各种可预知的、 不可预知的异常需要处理。\r\n如果对每个过程都单独作异常处理，\r\n代码耦合度会比较高，开发工作量也会加大而且不好统一，\r\n这也增加了代码的维护成本。\r\n针对这种实际情况，\r\n我们需要将所有类型的异常处理从各处理过程中解耦出来，\r\n这样既保证了相关处理过程的功能单一，\r\n也实现了异常信息的统一处理和维护。\r\n同时， 我们也不希望直接把异常抛给用户， 应该对异常进行处理，\r\n对错误信息进行封装， 然后返回一个友好的信息给用户。\r\n自定义异常类相关知识回顾\r\n\r\n\r\nimg\r\n\r\n异常的分类\r\n\r\nThrowable 类是 Java 异常类型的顶层父类，一个对象只有是\r\nThrowable类的实例，才是一个异常对象，才能被异常处理机制识别。\r\n按照错误严重性，从 Throwale 类中衍生出 Error 和 Exception 两大派系\r\n\r\nError（错误）：程序在执行过程中所遇到的硬件或系统的错误。错误对程序而言是致命的，将导致程序无法运行。不允许捕获。当发生\r\nError 时，只能依靠外界干预。比如：内存溢出。\r\nException（异常）：是程序运行过程中，可以预料的意外情况。比如空指针，数组下标越界。异常出现可以被捕获处理掉，使程序继续运行。\r\n\r\nException：又分为编译时异常和运行时异常。\r\n\r\n运行时异常都是 RuntimeException 类及其子类, 这些异常是不检查的异常,\r\n是在程序运行的时候可能会发生的, 所以程序可以捕捉,\r\n也可以不捕捉。程序应该从逻辑角度去尽量避免。如：空指针、数组下标越界等。\r\n编译时异常也叫检查异常，是运行时异常以外的异常, 也是 Exception\r\n及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的,\r\n否则不能通过编译. 如 IOException、SQLException 等。\r\n\r\n\r\n\r\n\r\nimg\r\n\r\n上面的异常体系结构图都是系统自带的，系统自己处理，但是很多时候项目会出现特有问题，而这些问题并未被\r\nJava\r\n所描述并封装成对象，所以对于这些特有的问题可以按照封装的思想，将特有的问题进行自定义异常封装。要想创建自定义异常，需要继承\r\nThrowable 或者他的子类 Exception。\r\n使用自定义异常类的步骤\r\n\r\n\r\nimg\r\n\r\n错误处理机制的默认机制\r\n默认机制流程\r\nSpring Boot 对异常的处理有一套默认的机制\r\n\r\n当程序产生异常时，根据请求头中的 Content-Type\r\n包含的内容来返回不同的响应信息。如果 Content-Type 是”text/html”,则以\r\nHTML 格式返回，如果 Content-Type 是”application/json”,则以 JSON\r\n格式返回。\r\n\r\n错误处理的⾃动配置都在 ErrorMvcAutoConfiguration\r\n中，两⼤核⼼机制：\r\n\r\nSpringBoot 会自适应处理错误，响应页面或JSON数据\r\nSpringMVC的错误处理机制依然保留，MVC处理不了，才会交给boot进行处理\r\n\r\n如下，这张图将是整个默认处理机制的核心步骤总结\r\n\r\n\r\nimage-20250608153602955\r\n\r\n如果你使用了以前 Spring MVC\r\n错误处理的方式，那么就按照你的来，没有就按照默认的来\r\n\r\n这里就是使用的@ExceptionHandler，用于标记一个方法，该方法将处理特定类型的异常。默认情况下，它只处理\r\n当前控制器类 中发生的异常\r\n@RestController@RequestMapping(&quot;/api&quot;)public class UserController &#123;    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        // 可能抛出 UserNotFoundException        return userService.getUserById(id);    &#125;    // 处理当前控制器中的 UserNotFoundException    @ExceptionHandler(UserNotFoundException.class)    public ResponseEntity&lt;String&gt; handleUserNotFound(UserNotFoundException ex) &#123;        return ResponseEntity.status(HttpStatus.NOT_FOUND)                .body(&quot;User not found: &quot; + ex.getMessage());    &#125;&#125;\r\n而@ControllerAdvice统一处理所有错误，通常用在全局错误处理器，一般是集中处理所有\r\nController 发生的错误\r\n@ControllerAdvicepublic class GlobalExceptionHandler &#123;    // 处理所有控制器中的 NullPointerException    @ExceptionHandler(NullPointerException.class)    public ResponseEntity&lt;String&gt; handleNullPointerException(NullPointerException ex) &#123;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)                .body(&quot;Internal server error: &quot; + ex.getMessage());    &#125;    // 处理所有控制器中的 MethodArgumentNotValidException（验证失败）    @ExceptionHandler(MethodArgumentNotValidException.class)    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationErrors(MethodArgumentNotValidException ex) &#123;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();        ex.getBindingResult().getFieldErrors()                .forEach(error -&gt; errors.put(error.getField(), error.getDefaultMessage()));        return ResponseEntity.badRequest().body(errors);    &#125;&#125;\r\n\r\n而在这里，可以实现可以通过自定义异常类和 @ResponseStatus\r\n注解来简化异常处理\r\n如果你使用自定义 Spring MVC 的错误，注意，Spring MVC 的异常处理遵循\r\n就近原则\r\n\r\n局部处理：优先使用控制器内部的\r\n@ExceptionHandler。\r\n全局处理：如果控制器内部没有匹配的处理方法，则使用\r\n@ControllerAdvice 中的全局处理方法。\r\n\r\n这部分就是在这里提一下，下面在说Spring Boot\r\n中的异常处理方案时候还是会继续说的。\r\n所以Spring boot 在什么都不写的时候，会默认就有一个\r\n/error目录。因为 Spring MVC\r\n如果没有错误请求处理，就处理不了，就得转发到 Spring boot\r\n处理错误的请求路径。\r\n\r\n\r\nimg\r\n\r\n如果用 Postman 访问，则以 JSON 的格式返回异常信息\r\n\r\n\r\nimage-20250608154906069\r\n\r\n发⽣错误以后，转发给/error路径，SpringBoot在底层写好⼀个\r\nBasicErrorController的组件，专⻔ 处理这个请求\r\n这个路径是可以设置的，配置文件中通过server.error.path=/error，表示错误发生后，错误请求将转发到这个路径进行处理\r\n默认错误处理机制的实现：关键点在 BasicErrorController 这个类中\r\nBasicErrorController 类\r\n\r\n这是 Spring Boot\r\n默认的错误处理控制器，负责处理所有未被应用程序其他控制器处理的异常请求（默认映射到\r\n/error 路径）\r\n它提供了两种错误响应方式：HTML 格式（errorHtml 方法）和\r\nJSON 格式（error 方法）\r\n在处理 HTML 错误视图时，它依赖于 ErrorViewResolver\r\n接口的实现来确定具体使用哪个视图模板\r\n\r\n/** * 处理HTML格式的错误请求，返回错误页面视图 *  * @param request  HTTP请求对象 * @param response HTTP响应对象 * @return 错误视图模型，如果未找到特定视图则返回默认&quot;error&quot;视图 */@RequestMapping(        produces = &#123;&quot;text/html&quot;&#125;    )    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;        // 获取请求对应的HTTP状态码        HttpStatus status = this.getStatus(request);        // 获取错误属性并封装到不可修改的Map中        Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));        // 设置响应状态码        response.setStatus(status.value());        // 尝试解析错误视图        ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);        // 如果未找到特定视图则返回默认&quot;error&quot;视图        return modelAndView != null ? modelAndView : new ModelAndView(&quot;error&quot;, model);    &#125;\r\n/** * 处理非HTML格式的错误请求，返回JSON格式错误响应 *  * @param request HTTP请求对象 * @return 包含错误信息的响应实体 */@RequestMapping      // 返回ResponseEntity, JSON    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;        // 获取请求对应的HTTP状态码        HttpStatus status = this.getStatus(request);        // 处理无内容状态码的特殊情况        if (status == HttpStatus.NO_CONTENT) &#123;            return new ResponseEntity(status);        &#125; else &#123;            // 获取错误属性并封装到响应体中            Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL));            return new ResponseEntity(body, status);        &#125;    &#125;\r\n所以说，错误页面和错误信息是这么解析到的\r\nModelAndView modelAndView = this.resolveErrorView(request, response, status, model);       // 如果未找到特定视图则返回默认&quot;error&quot;视图       return modelAndView != null ? modelAndView : new ModelAndView(&quot;error&quot;, model);\r\n容器中专门的有⼀个错误视图解析器，在public class ErrorMvcAutoConfiguration，就是去哪个错误页面是这个方法解析器来决定的，其中涉及到的关键类\r\nDefaultErrorViewResolver，会在下面说\r\n@Bean@ConditionalOnBean(&#123;DispatcherServlet.class&#125;)@ConditionalOnMissingBean(&#123;ErrorViewResolver.class&#125;)DefaultErrorViewResolver conventionErrorViewResolver() &#123;    return new DefaultErrorViewResolver(this.applicationContext, this.resources);&#125;\r\n看一下\r\nBasicErrorController类的关系，BasicErrorController类本身就是一个控制器，这个类是默认处理/error\r\n请求的。那么响应页面的时候是怎么找到页面的呢？这里有一个关键类\r\nDefaultErrorViewResolver。\r\n\r\n\r\nimage-20250608155228098\r\n\r\nDefaultErrorViewResolver 类：\r\n\r\n这是 ErrorViewResolver 接口的默认实现类，负责根据 HTTP\r\n状态码解析对应的错误视图\r\n它尝试从模板引擎（如\r\nThymeleaf、FreeMarker）或静态资源目录中查找匹配的错误页面\r\n如果找不到精确匹配的错误页面（如\r\nerror/404.html），则尝试使用系列错误页面（如\r\nerror/4xx.html 或 error/5xx.html）\r\n\r\n响应页面时如何找到默认处理 /error\r\n请求的呢，可以发现，页面当应用程序抛出异常时，Spring Boot\r\n的错误处理流程大致如下：\r\n\r\n异常捕获：DispatcherServlet\r\n捕获到未处理的异常，将请求转发到 /error 路径\r\n请求处理：BasicErrorController\r\n接收到 /error 请求，并根据请求的 Accept 头决定返回 HTML\r\n还是 JSON 格式的响应\r\n视图解析：在处理 HTML\r\n响应时，BasicErrorController 调用\r\nDefaultErrorViewResolver 的 resolveErrorView\r\n方法来确定使用哪个视图模板\r\npublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123;    // 尝试解析精确匹配的状态码视图（如 error/404）    ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model);    // 如果找不到精确匹配的视图，则尝试解析系列视图（如 error/4xx）    if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;        modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model);    &#125;    return modelAndView;&#125;\r\n\r\n视图解析的流程大概如下：\r\nresolveErrorView中，调用了reslove去解析精确匹配的状态码，然后尝试构建视图，然后resolve方法中会调用resolveResource获取静态资源\r\nprivate ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123;    // 构建错误视图名称，格式为 &quot;error/&#123;statusCode&#125;&quot; 或 &quot;error/&#123;series&#125;&quot;    String errorViewName = &quot;error/&quot; + viewName;        // 检查是否存在可用的模板引擎来处理该视图    TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext);        // 如果存在模板引擎支持，则使用模板引擎渲染视图    // 否则尝试从静态资源中查找对应的 HTML 文件    return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);&#125;\r\nprivate ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123;    // 遍历所有静态资源位置    String[] locations = this.resources.getStaticLocations();    for (String location : locations) &#123;        try &#123;            // 尝试加载资源            Resource resource = this.applicationContext.getResource(location);            resource = resource.createRelative(viewName + &quot;.html&quot;);            if (resource.exists()) &#123;                return new ModelAndView(new HtmlResourceView(resource), model);            &#125;        &#125; catch (Exception e) &#123;            // 忽略异常，继续检查下一个位置        &#125;    &#125;    return null;&#125;\r\n所以，我们可以得到详细的规则，如下：\r\n\r\n解析⼀个错误⻚\r\n\r\n如果发⽣了500、404、503、403 这些错误\r\n\r\n如果有模板引擎，默认在\r\nclasspath:/templates/error/ 精确码 .html\r\n如果没有模板引擎，在静态资源⽂件夹下找\r\n精确码 .html\r\n\r\n如果匹配不到 精确码 .html 这些精确的错误⻚，就去找\r\n5xx.html ， 4xx.html模糊匹配\r\n\r\n如果有模板引擎，默认在\r\nclasspath:/templates/error/5xx.html\r\n如果没有模板引擎，在静态资源⽂件夹下找\r\n5xx.html\r\n\r\n如果模板引擎路径 templates 下有 error.html\r\n⻚⾯，就直接渲染\r\n\r\n如果你需要定制错误页面，这个类的步骤很重要\r\n因为，这种机制使得开发者可以通过在 templates/error/\r\n或 static/error/ 目录下放置相应的 HTML\r\n文件来自定义错误页面，同时保持了 Spring Boot\r\n错误处理的默认行为。\r\n\r\n而容器中有⼀个默认的名为 error 的 view； 提供了默认⽩⻚功能\r\n@Bean(        name = &#123;&quot;error&quot;&#125;    )    @ConditionalOnMissingBean(        name = &#123;&quot;error&quot;&#125;    )    public View defaultErrorView() &#123;        return this.defaultErrorView;    &#125;\r\n封装了JSON格式的错误信息\r\n@Bean@ConditionalOnMissingBean(    value = &#123;ErrorAttributes.class&#125;,    search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() &#123;    return new DefaultErrorAttributes();&#125;\r\n所以如何自定义一个异常的界面，这很有说法了\r\nSpring Boot 中的异常处理方案\r\nSpring Boot中自定义异常\r\n全局异常处理：通过实现HandlerExceptionResolver接口或扩展ResponseEntityExceptionHandler类，实现全局的异常处理。\r\n实现HandlerExceptionResolver\r\nSpring提供了HandlerExceptionResolver接口，用于定义全局的异常处理逻辑。可以通过实现该接口，来自定义异常处理策略。\r\nimport org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;public class CustomExceptionResolver implements HandlerExceptionResolver &#123;    @Override    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;        ModelAndView modelAndView = new ModelAndView();        modelAndView.addObject(&quot;message&quot;, ex.getMessage());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    &#125;&#125;\r\n扩展ResponseEntityExceptionHandler\r\nResponseEntityExceptionHandler是Spring提供的一个基类，包含了一些常见异常的处理逻辑。可以通过扩展该类，来实现自定义的异常处理逻辑。\r\nimport org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;@ControllerAdvicepublic class CustomResponseEntityExceptionHandler extends ResponseEntityExceptionHandler &#123;    @Override    protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex,                                                                  HttpHeaders headers,                                                                  HttpStatus status,                                                                  WebRequest request) &#123;        ErrorDetails errorDetails = new ErrorDetails(new Date(), &quot;Validation Failed&quot;, ex.getBindingResult().toString());        return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.BAD_REQUEST);    &#125;&#125;\r\n常见异常的处理方法\r\n处理资源未找到异常\r\n资源未找到异常（ResourceNotFoundException）是指请求的资源不存在，通常在RESTful\r\nAPI中较为常见。可以通过自定义异常类和异常处理方法来处理这种异常。\r\npublic class ResourceNotFoundException extends RuntimeException &#123;    public ResourceNotFoundException(String message) &#123;        super(message);    &#125;&#125;\r\n在全局异常处理类中处理该异常：\r\n@ExceptionHandler(ResourceNotFoundException.class)public ResponseEntity&lt;?&gt; handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) &#123;    ErrorDetails errorDetails = new ErrorDetails(new Date(), ex.getMessage(), request.getDescription(false));    return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.NOT_FOUND);&#125;\r\n处理数据验证异常\r\n数据验证异常（ValidationException）通常在对输入数据进行验证时出现。可以通过在Controller中使用@Valid注解，对输入数据进行验证，并在全局异常处理类中处理验证异常。\r\nimport javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class User &#123;    @NotNull    private Long id;    @Size(min = 2, message = &quot;Name should have at least 2 characters&quot;)    private String name;    // Getters and Setters&#125;\r\n在Controller中使用@Valid注解：\r\nimport org.springframework.web.bind.annotation.*;import javax.validation.Valid;@RestController@RequestMapping(&quot;/api/users&quot;)public class UserController &#123;    @PostMapping    public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody User user) &#123;        // Save user to database        return new ResponseEntity&lt;&gt;(user, HttpStatus.CREATED);    &#125;&#125;\r\n在全局异常处理类中处理验证异常\r\nimport org.springframework.validation.FieldError;import org.springframework.web.bind.MethodArgumentNotValidException;@ExceptionHandler(MethodArgumentNotValidException.class)public ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, WebRequest request) &#123;    Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();    ex.getBindingResult().getAllErrors().forEach((error) -&gt; &#123;        String fieldName = ((FieldError) error).getField();        String errorMessage = error.getDefaultMessage();        errors.put(fieldName, errorMessage);    &#125;);    return new ResponseEntity&lt;&gt;(errors, HttpStatus.BAD_REQUEST);&#125;\r\n处理数据库异常\r\n数据库异常（DatabaseException）通常在与数据库交互时出现。例如，违反唯一性约束、外键约束等。可以通过自定义异常类和异常处理方法来处理这种异常。\r\npublic class DatabaseException extends RuntimeException &#123;    public DatabaseException(String message) &#123;        super(message);    &#125;&#125;\r\n在全局异常处理类中处理数据库异常：\r\n@ExceptionHandler(DatabaseException.class)public ResponseEntity&lt;?&gt; handleDatabaseException(DatabaseException ex, WebRequest request) &#123;    ErrorDetails errorDetails = new ErrorDetails(new Date(), ex.getMessage(), request.getDescription(false));    return new ResponseEntity&lt;&gt;(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);&#125;\r\n自定义json响应\r\n简介\r\n在现代前后端分离的架构中，RESTful API 通常需要返回结构化的 JSON\r\n错误响应，而不是 HTML 页面。Spring Boot 提供了多种方式来实现自定义 JSON\r\n错误响应，使前端能够以统一的方式处理错误。\r\nSpring 提供了一个非常方便的异常处理方案：控制器通知\r\n(@ControllerAdvice\r\n或@RestControllerAdvice)，它将所有控制器作为一个\r\n切面，利用切面技术来实现异常的通知。处理Controller层的异常处理就是通过@ControllerAdvice和@ExceptionHandler注解，集中处理Controller层的异常。这两个注解的使用我在上面已经说过了，在这里就是扩展讲一下了\r\n相关注解\r\n@ExceptionHandler\r\n@ExceptionHandler，用于标记一个方法，该方法将处理特定类型的异常。默认情况下，它只处理\r\n当前控制器类 中发生的异常\r\n\r\n作用范围：仅处理当前控制器类中抛出的异常。\r\n异常类型匹配：通过 value\r\n属性指定要处理的异常类型。\r\n返回值：可以返回视图名称（如\r\nString）、ModelAndView 或直接返回响应体（如\r\n@ResponseBody）。\r\n\r\n@ControllerAdvice\r\n@ControllerAdvice 是一个特殊的\r\n@Component，用于定义\r\n@ExceptionHandler、@InitBinder 和\r\n@ModelAttribute 方法，这些方法将应用于\r\n所有控制器。\r\n核心特性\r\n\r\n全局作用域：处理所有控制器中抛出的异常。\r\n选择性应用：可通过\r\nannotations、basePackages\r\n等属性指定要应用的控制器范围。\r\n与 @ExceptionHandler 结合：在\r\n@ControllerAdvice 类中定义 @ExceptionHandler\r\n方法，实现全局异常处理。\r\n如果组合使用 @ExceptionHandler 和\r\n@ControllerAdvice，注意Spring MVC 的异常处理遵循\r\n就近原则：\r\n\r\n局部处理：优先使用控制器内部的\r\n@ExceptionHandler。\r\n全局处理：如果控制器内部没有匹配的处理方法，则使用\r\n@ControllerAdvice 中的全局处理方法。\r\n\r\n例如，处理流程示例\r\n\r\n控制器抛出UserNotFoundException\r\n\r\n首先查找当前控制器中是否有\r\n@ExceptionHandler(UserNotFoundException.class)。\r\n如果没有，则查找 @ControllerAdvice\r\n类中是否有匹配的处理方法。\r\n如果仍没有，则由 Spring MVC 的默认异常处理器处理。\r\n\r\n// 全局异常处理器@ControllerAdvicepublic class GlobalExceptionHandler &#123;    // 全局处理 RuntimeException    @ExceptionHandler(RuntimeException.class)    public ResponseEntity&lt;String&gt; handleRuntimeException(RuntimeException ex) &#123;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)                .body(&quot;Runtime error: &quot; + ex.getMessage());    &#125;&#125;// 特定控制器@RestController@RequestMapping(&quot;/api&quot;)public class OrderController &#123;    @PostMapping(&quot;/orders&quot;)    public Order createOrder(@RequestBody Order order) &#123;        // 可能抛出 BusinessException        return orderService.createOrder(order);    &#125;    // 仅处理当前控制器中的 BusinessException    @ExceptionHandler(BusinessException.class)    public ResponseEntity&lt;String&gt; handleBusinessException(BusinessException ex) &#123;        return ResponseEntity.status(HttpStatus.BAD_REQUEST)                .body(&quot;Business error: &quot; + ex.getMessage());    &#125;&#125;\r\n\r\n\r\n@RestControllerAdvice\r\n@RestControllerAdvice 是 @ControllerAdvice\r\n的特殊版本，是专门为 RESTful\r\n控制器设计的全局异常处理器，它的方法返回值将自动转换为JSON响应体。它是\r\n@ControllerAdvice 和 @ResponseBody\r\n的结合体。\r\n当 Spring Boot 应用启动时，Spring 容器会自动扫描并加载带有\r\n@RestControllerAdvice\r\n注解的类，将其实例化并纳入管理。一旦控制器层在处理请求时抛出异常，Spring\r\nMVC 的异常处理机制就会被触发。\r\n在标注了 @RestControllerAdvice\r\n的类中，我们可以定义若干个 @ExceptionHandler\r\n方法，这些方法会根据其参数类型与抛出的异常类型进行匹配\r\n@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(YourSelfException.class)    public ResponseEntity&lt;ErrorResponse&gt; handleAllExceptions(Exception ex) &#123;        ErrorResponse errorResponse = new ErrorResponse(            HttpStatus.INTERNAL_SERVER_ERROR.value(),            &quot;Internal Server Error&quot;,            ex.getMessage()        );        return new ResponseEntity&lt;&gt;(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);    &#125;        @ExceptionHandler(value = NullPointerException.class)    public ResponseEntity&lt;ErrorResponse&gt; handleNullPointerException(NullPointerException ex) &#123;        // 对空指针异常的处理逻辑    &#125;    @ExceptionHandler(value = MyCustomException.class)    public ResponseEntity&lt;ErrorResponse&gt; handleMyCustomException(MyCustomException ex) &#123;        // 对自定义异常 MyCustomException 的处理逻辑    &#125;    @ExceptionHandler(value = Exception.class)    public ResponseEntity&lt;ErrorResponse&gt; handleAllExceptions(Exception ex) &#123;        // 对所有未特别处理的异常的通用处理逻辑    &#125;&#125;\r\n由于 @RestControllerAdvice\r\n类型的处理器返回值带有 @ResponseBody 效果，因此，这些 @ExceptionHandler\r\n方法的返回值会被自动转换为 HTTP\r\n响应体的内容。常见的做法是返回一个自定义的错误响应实体，如\r\nErrorResponse，包含错误代码、消息等信息，方便客户端理解和处理，自定义的错误响应实体示例如下\r\n@Data@AllArgsConstructor@NoArgsConstructorpublic class ErrorResponse &#123;    private int status;    private String error;    private String message;    private String path;    private long timestamp;        public ErrorResponse(int status, String error, String message) &#123;        this.status = status;        this.error = error;        this.message = message;        this.timestamp = System.currentTimeMillis();    &#125;&#125;\r\n@ResponseStatus\r\n@ResponseStatus注解是spring-web包中提供的一个注解，其主要作用就是为了改变HTTP响应的状态码\r\n有两种用法\r\n\r\n一种是加载自定义异常类上\r\n一种是加在目标方法中，当修饰一个类的时候，通常修饰的是一个异常类。\r\n@RequestMapping(path = &quot;/401&quot;)@ResponseStatus(value = HttpStatus.CREATED)public Response unauthorized() &#123;    return new Response(401, &quot;Unauthorized&quot;, null);&#125;\r\nHttpStatus.CREATED 状态码为201，将原来请求状态码200改为201。\r\n\r\n\r\nimg\r\n\r\n\r\n@ResponseStatus注释可指定下表所示属性：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n属性\r\n类型\r\n是否必要\r\n说明\r\n\r\n\r\n\r\n\r\ncode\r\nHttpStatus\r\n否\r\nhttp状态码，如HttpStatus.CREATED,HttpStatus.OK\r\n\r\n\r\nvalue\r\nString\r\n否\r\n同code属性\r\n\r\n\r\nreason\r\nHttpStatus\r\n否\r\n错误信息\r\n\r\n\r\n\r\n如果@ResponseStatus有reason属性，@RequestMapping方法返回值都不处理了，直接返回服务器自带的\r\nERROR页面，交互体验比较差，建议不要使用。而且当@ResponseStatus用在方法上，如果添加了reason属性，且reason不为”“，且code\r\n&gt; 0(哪怕状态码是200)，也会对当前请求走错误处理。\r\n响应状态的覆盖顺序\r\n\r\n方法级@ResponseStatus\r\n异常类级@ResponseStatus\r\nResponseEntity设置的状态码\r\nSpring默认状态码\r\n\r\n可以通过自定义异常类和 @ResponseStatus\r\n注解来简化异常处理：\r\n使用时，先声明一个自定义异常类，在自定义异常类上面加上@ResponseStatus注释表示系统运行期间，当抛出自定义异常的时候，使用@ResponseStatus注解中声明的属性和reason属性将异常信息返回给客户端，提高可读性。\r\nimport org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(reason=&quot;The system is exception！&quot;)public class BusinessException extends RuntimeException&#123;&#125;\r\n@RequestMapping(value = &quot;/helloResponseStatus2&quot;)public void helloResponseStatus2(@RequestParam(value = &quot;name&quot;) String name) &#123;    if (StringUtils.isBlank(name)) &#123;        throw new BusinessException();    &#125;&#125;\r\n响应结果可以看到：\r\n\r\n\r\nimg\r\n\r\n而@ResponseStatus注解配合@ExceptionHandler注解使用会更好\r\n@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(ValidationException.class)    @ResponseStatus(HttpStatus.BAD_REQUEST)    public ErrorResponse handleValidationException(ValidationException ex) &#123;        return new ErrorResponse(            &quot;VALIDATION_FAILED&quot;,            ex.getFieldErrors()        );    &#125;&#125;\r\n\r\n@ExceptionHandler(ValidationException.class)指定该方法处理\r\nValidationException 类型的异常。当任何控制器抛出\r\nValidationException\r\n时，此方法会被调用，@ResponseStatus(HttpStatus.BAD_REQUEST)将\r\nHTTP 状态码设置为 400（Bad Request）\r\n这种组合无需在每个异常处理方法中手动设置\r\nHttpServletResponse 的状态码，代码更简洁，符合 RESTful API\r\n设计原则。\r\n\r\n而且还可以实现组合状态码与自定义响应\r\n@ExceptionHandler(PaymentRequiredException.class)@ResponseStatus(HttpStatus.PAYMENT_REQUIRED)public ApiResponse&lt;Void&gt; handlePaymentRequired(PaymentRequiredException ex) &#123;    return ApiResponse.fail(        &quot;PAYMENT_REQUIRED&quot;,        ex.getOrderId(),        &quot;Please complete payment for order &quot; + ex.getOrderId()    );&#125;\r\n但是会覆盖异常类的注解\r\n@ExceptionHandler(ResourceNotFoundException.class)@ResponseStatus(HttpStatus.GONE) // 覆盖原NOT_FOUND定义public ErrorResponse handleResourceNotFound(ResourceNotFoundException ex) &#123;    return new ErrorResponse(        &quot;RESOURCE_EXPIRED&quot;,        &quot;Resource was permanently removed&quot;    );&#125;\r\n自定义页面响应\r\n在Web应用中，除了常见的JSON格式错误响应外，很多时候我们还需要返回自定义的错误页面，特别是在传统的服务端渲染(SSR)应用中。Spring\r\nBoot提供了多种方式来实现自定义错误页面，让用户获得更友好的错误提示体验。\r\n实现自定义异常页面主要通过以下两种方式：基于静态资源的简单实现和基于模板引擎的动态实现。\r\n但是我们需要先知道定制错误处理逻辑异常页面的资源加载过程\r\n假设我们拥有自定义的异常页面，如下图结构\r\n\r\n\r\nimg\r\n\r\n如上图定义一个 404 的异常界面。查找顺序如下\r\n\r\n有模板引擎的情况下：templates/error/状态码，将错误页面命名为\r\n错误状态码.html放在模板引擎文件夹里面的 error\r\n文件夹下， 发生此状态码的错误就会来到对应的页面。\r\n没有模板引擎或者模板引擎找不到错误页面，静态资源\r\nstatic文件 夹下找：static/error/状态\r\n以上都没有，默认来到 Spring Boot 默认的错误提示页面\r\n\r\n也就是说，根据默认错误页面机制，Spring Boot\r\n默认会在以下路径查找错误页面：\r\n\r\n/error/404.html (针对404错误)\r\n/error/5xx.html (针对5xx系列错误)\r\n/error/error.html (通用错误页面)\r\n\r\n如果需要修改默认的错误页面路径，可以在application.properties中配置：\r\nserver.error.path=/my-errorspring.mvc.static-path-pattern=/static/**\r\n对于更复杂的场景，我们可以使用模板引擎动态渲染错误页面。\r\n以使用Thymeleaf模板引擎为例子\r\n实现步骤：\r\n\r\n在resources/templates/error/目录下创建模板文件\r\n模板中可以访问错误信息变量\r\n\r\n而 Spring Boot 会自动向错误页面提供以下属性：\r\n\r\ntimestamp：错误发生的时间戳\r\nstatus：HTTP状态码\r\nerror：错误原因\r\nexception：异常类名\r\nmessage：异常消息\r\npath：请求路径\r\n\r\n&lt;!-- resources/templates/error/error.html --&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;title th:text=&quot;$&#123;status&#125; + &#x27; &#x27; + $&#123;error&#125;&quot;&gt;Error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 th:text=&quot;$&#123;status&#125; + &#x27; &#x27; + $&#123;error&#125;&quot;&gt;Error&lt;/h1&gt;    &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;Error message&lt;/p&gt;    &lt;p th:text=&quot;$&#123;timestamp&#125;&quot;&gt;Timestamp&lt;/p&gt;    &lt;p th:text=&quot;$&#123;path&#125;&quot;&gt;Path&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\r\n如果需要更灵活的错误页面解析逻辑，可以自定义\r\nErrorViewResolver。\r\n\r\n创建自定义 ErrorViewResolver 实现\r\nErrorViewResolver 接口，并重写\r\nresolveErrorView 方法。\r\n\r\nimport org.springframework.boot.web.servlet.error.ErrorViewResolver;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import java.util.Map;@Componentpublic class CustomErrorViewResolver implements ErrorViewResolver &#123;    @Override    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123;        // 根据不同的状态码返回不同的视图        if (status == HttpStatus.NOT_FOUND) &#123;            return new ModelAndView(&quot;custom/404&quot;, model); // 指向 templates/custom/404.html        &#125; else if (status == HttpStatus.INTERNAL_SERVER_ERROR) &#123;            return new ModelAndView(&quot;custom/500&quot;, model); // 指向 templates/custom/500.html        &#125;        return null; // 返回 null 让默认解析器处理其他情况    &#125;&#125;\r\n如果需要完全控制错误处理逻辑，可以自定义\r\nErrorController。\r\n\r\n创建自定义 ErrorController 实现\r\nErrorController 接口，处理 /error 路径。\r\n@Controllerpublic class EnhancedErrorController implements ErrorController &#123;    @RequestMapping(&quot;/error&quot;)    public String handleError(HttpServletRequest request, Model model) &#123;        // 收集错误信息        Object status = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);        Object exception = request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);                // 设置模型数据        model.addAttribute(&quot;timestamp&quot;, new Date());        model.addAttribute(&quot;status&quot;, status);        model.addAttribute(&quot;error&quot;, HttpStatus.valueOf(Integer.valueOf(status.toString())).getReasonPhrase());                if (exception != null) &#123;            Throwable ex = (Throwable) exception;            model.addAttribute(&quot;message&quot;, ex.getMessage());            model.addAttribute(&quot;exception&quot;, ex.getClass().getName());        &#125;                Object path = request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI);        if (path != null) &#123;            model.addAttribute(&quot;path&quot;, path);        &#125;                return &quot;error/custom-error&quot;;    &#125;&#125;\r\n\r\n虽然@ControllerAdvice通常用于返回JSON响应，但也可以用来返回错误页面。算是冷知识了。\r\n需要针对特定异常特殊处理时，可以使用@ControllerAdvice\r\n@ControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(ResourceNotFoundException.class)    public ModelAndView handleResourceNotFound(ResourceNotFoundException ex) &#123;        ModelAndView mav = new ModelAndView();        mav.addObject(&quot;message&quot;, ex.getMessage());        mav.addObject(&quot;status&quot;, HttpStatus.NOT_FOUND.value());        mav.setViewName(&quot;error/resource-not-found&quot;);        return mav;    &#125;    @ExceptionHandler(Exception.class)    public ModelAndView handleAllExceptions(Exception ex) &#123;        ModelAndView mav = new ModelAndView();        mav.addObject(&quot;message&quot;, &quot;An unexpected error occurred&quot;);        mav.addObject(&quot;status&quot;, HttpStatus.INTERNAL_SERVER_ERROR.value());        mav.setViewName(&quot;error/generic-error&quot;);        return mav;    &#125;&#125;\r\nSpring Boot 异常处理实战\r\n前后分离场景\r\n\r\n核心手段：利用\r\n@ControllerAdvice + @ExceptionHandler\r\n组合，对后台产生的所有错误，执行统一异常处理流程，将异常信息以合适格式（如\r\nJSON）返回给前端，便于前端做错误提示等处理。\r\n\r\n服务端页面渲染场景\r\n不可预知的 HTTP\r\n码错误（服务器或客户端错误 ）\r\n\r\n精确匹配：在\r\nclasspath:/templates/error/ 路径下，放置像\r\n500.html（处理 500 错误 ）、404.html（处理 404\r\n错误 ）这类，与具体 HTTP\r\n错误码精准对应的错误页面。\r\n模糊匹配：同样在\r\nclasspath:/templates/error/ 路径下，放\r\n5xx.html（匹配所有 5 开头的服务器错误\r\n）、4xx.html（匹配所有 4 开头的客户端错误\r\n）这类通用错误页面，作为精确匹配未命中时的兜底。\r\n\r\n业务错误\r\n\r\n核心业务错误：针对核心业务里的各类错误，通过代码主动控制跳转，导向专门定制的专属错误页，保证核心业务错误提示精准、贴合业务逻辑。\r\n通用业务错误：借助\r\nclasspath:/templates/error.html\r\n页面，在通用业务出错时，展示错误信息，作为通用业务错误的统一展示入口\r\n。\r\n\r\n所以就是整体是在 Spring Boot\r\n框架下，依据不同的开发场景（前后端交互形式、错误类型），规划对应的错误处理与页面\r\n/ 信息返回策略，让错误处理更规范、体验更优 。\r\nHttpStatus\r\n文章末尾，贴一下org.springframework包内的\r\nHttpStatus状态码的枚举类\r\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.springframework.http;import org.springframework.lang.Nullable;public enum HttpStatus implements HttpStatusCode &#123;    CONTINUE(100, HttpStatus.Series.INFORMATIONAL, &quot;Continue&quot;),    SWITCHING_PROTOCOLS(101, HttpStatus.Series.INFORMATIONAL, &quot;Switching Protocols&quot;),    PROCESSING(102, HttpStatus.Series.INFORMATIONAL, &quot;Processing&quot;),    EARLY_HINTS(103, HttpStatus.Series.INFORMATIONAL, &quot;Early Hints&quot;),    /** @deprecated */    @Deprecated(        since = &quot;6.0.5&quot;    )    CHECKPOINT(103, HttpStatus.Series.INFORMATIONAL, &quot;Checkpoint&quot;),    OK(200, HttpStatus.Series.SUCCESSFUL, &quot;OK&quot;),    CREATED(201, HttpStatus.Series.SUCCESSFUL, &quot;Created&quot;),    ACCEPTED(202, HttpStatus.Series.SUCCESSFUL, &quot;Accepted&quot;),    NON_AUTHORITATIVE_INFORMATION(203, HttpStatus.Series.SUCCESSFUL, &quot;Non-Authoritative Information&quot;),    NO_CONTENT(204, HttpStatus.Series.SUCCESSFUL, &quot;No Content&quot;),    RESET_CONTENT(205, HttpStatus.Series.SUCCESSFUL, &quot;Reset Content&quot;),    PARTIAL_CONTENT(206, HttpStatus.Series.SUCCESSFUL, &quot;Partial Content&quot;),    MULTI_STATUS(207, HttpStatus.Series.SUCCESSFUL, &quot;Multi-Status&quot;),    ALREADY_REPORTED(208, HttpStatus.Series.SUCCESSFUL, &quot;Already Reported&quot;),    IM_USED(226, HttpStatus.Series.SUCCESSFUL, &quot;IM Used&quot;),    MULTIPLE_CHOICES(300, HttpStatus.Series.REDIRECTION, &quot;Multiple Choices&quot;),    MOVED_PERMANENTLY(301, HttpStatus.Series.REDIRECTION, &quot;Moved Permanently&quot;),    FOUND(302, HttpStatus.Series.REDIRECTION, &quot;Found&quot;),    /** @deprecated */    @Deprecated    MOVED_TEMPORARILY(302, HttpStatus.Series.REDIRECTION, &quot;Moved Temporarily&quot;),    SEE_OTHER(303, HttpStatus.Series.REDIRECTION, &quot;See Other&quot;),    NOT_MODIFIED(304, HttpStatus.Series.REDIRECTION, &quot;Not Modified&quot;),    /** @deprecated */    @Deprecated    USE_PROXY(305, HttpStatus.Series.REDIRECTION, &quot;Use Proxy&quot;),    TEMPORARY_REDIRECT(307, HttpStatus.Series.REDIRECTION, &quot;Temporary Redirect&quot;),    PERMANENT_REDIRECT(308, HttpStatus.Series.REDIRECTION, &quot;Permanent Redirect&quot;),    BAD_REQUEST(400, HttpStatus.Series.CLIENT_ERROR, &quot;Bad Request&quot;),    UNAUTHORIZED(401, HttpStatus.Series.CLIENT_ERROR, &quot;Unauthorized&quot;),    PAYMENT_REQUIRED(402, HttpStatus.Series.CLIENT_ERROR, &quot;Payment Required&quot;),    FORBIDDEN(403, HttpStatus.Series.CLIENT_ERROR, &quot;Forbidden&quot;),    NOT_FOUND(404, HttpStatus.Series.CLIENT_ERROR, &quot;Not Found&quot;),    METHOD_NOT_ALLOWED(405, HttpStatus.Series.CLIENT_ERROR, &quot;Method Not Allowed&quot;),    NOT_ACCEPTABLE(406, HttpStatus.Series.CLIENT_ERROR, &quot;Not Acceptable&quot;),    PROXY_AUTHENTICATION_REQUIRED(407, HttpStatus.Series.CLIENT_ERROR, &quot;Proxy Authentication Required&quot;),    REQUEST_TIMEOUT(408, HttpStatus.Series.CLIENT_ERROR, &quot;Request Timeout&quot;),    CONFLICT(409, HttpStatus.Series.CLIENT_ERROR, &quot;Conflict&quot;),    GONE(410, HttpStatus.Series.CLIENT_ERROR, &quot;Gone&quot;),    LENGTH_REQUIRED(411, HttpStatus.Series.CLIENT_ERROR, &quot;Length Required&quot;),    PRECONDITION_FAILED(412, HttpStatus.Series.CLIENT_ERROR, &quot;Precondition Failed&quot;),    PAYLOAD_TOO_LARGE(413, HttpStatus.Series.CLIENT_ERROR, &quot;Payload Too Large&quot;),    /** @deprecated */    @Deprecated    REQUEST_ENTITY_TOO_LARGE(413, HttpStatus.Series.CLIENT_ERROR, &quot;Request Entity Too Large&quot;),    URI_TOO_LONG(414, HttpStatus.Series.CLIENT_ERROR, &quot;URI Too Long&quot;),    /** @deprecated */    @Deprecated    REQUEST_URI_TOO_LONG(414, HttpStatus.Series.CLIENT_ERROR, &quot;Request-URI Too Long&quot;),    UNSUPPORTED_MEDIA_TYPE(415, HttpStatus.Series.CLIENT_ERROR, &quot;Unsupported Media Type&quot;),    REQUESTED_RANGE_NOT_SATISFIABLE(416, HttpStatus.Series.CLIENT_ERROR, &quot;Requested range not satisfiable&quot;),    EXPECTATION_FAILED(417, HttpStatus.Series.CLIENT_ERROR, &quot;Expectation Failed&quot;),    I_AM_A_TEAPOT(418, HttpStatus.Series.CLIENT_ERROR, &quot;I&#x27;m a teapot&quot;),    /** @deprecated */    @Deprecated    INSUFFICIENT_SPACE_ON_RESOURCE(419, HttpStatus.Series.CLIENT_ERROR, &quot;Insufficient Space On Resource&quot;),    /** @deprecated */    @Deprecated    METHOD_FAILURE(420, HttpStatus.Series.CLIENT_ERROR, &quot;Method Failure&quot;),    /** @deprecated */    @Deprecated    DESTINATION_LOCKED(421, HttpStatus.Series.CLIENT_ERROR, &quot;Destination Locked&quot;),    UNPROCESSABLE_ENTITY(422, HttpStatus.Series.CLIENT_ERROR, &quot;Unprocessable Entity&quot;),    LOCKED(423, HttpStatus.Series.CLIENT_ERROR, &quot;Locked&quot;),    FAILED_DEPENDENCY(424, HttpStatus.Series.CLIENT_ERROR, &quot;Failed Dependency&quot;),    TOO_EARLY(425, HttpStatus.Series.CLIENT_ERROR, &quot;Too Early&quot;),    UPGRADE_REQUIRED(426, HttpStatus.Series.CLIENT_ERROR, &quot;Upgrade Required&quot;),    PRECONDITION_REQUIRED(428, HttpStatus.Series.CLIENT_ERROR, &quot;Precondition Required&quot;),    TOO_MANY_REQUESTS(429, HttpStatus.Series.CLIENT_ERROR, &quot;Too Many Requests&quot;),    REQUEST_HEADER_FIELDS_TOO_LARGE(431, HttpStatus.Series.CLIENT_ERROR, &quot;Request Header Fields Too Large&quot;),    UNAVAILABLE_FOR_LEGAL_REASONS(451, HttpStatus.Series.CLIENT_ERROR, &quot;Unavailable For Legal Reasons&quot;),    INTERNAL_SERVER_ERROR(500, HttpStatus.Series.SERVER_ERROR, &quot;Internal Server Error&quot;),    NOT_IMPLEMENTED(501, HttpStatus.Series.SERVER_ERROR, &quot;Not Implemented&quot;),    BAD_GATEWAY(502, HttpStatus.Series.SERVER_ERROR, &quot;Bad Gateway&quot;),    SERVICE_UNAVAILABLE(503, HttpStatus.Series.SERVER_ERROR, &quot;Service Unavailable&quot;),    GATEWAY_TIMEOUT(504, HttpStatus.Series.SERVER_ERROR, &quot;Gateway Timeout&quot;),    HTTP_VERSION_NOT_SUPPORTED(505, HttpStatus.Series.SERVER_ERROR, &quot;HTTP Version not supported&quot;),    VARIANT_ALSO_NEGOTIATES(506, HttpStatus.Series.SERVER_ERROR, &quot;Variant Also Negotiates&quot;),    INSUFFICIENT_STORAGE(507, HttpStatus.Series.SERVER_ERROR, &quot;Insufficient Storage&quot;),    LOOP_DETECTED(508, HttpStatus.Series.SERVER_ERROR, &quot;Loop Detected&quot;),    BANDWIDTH_LIMIT_EXCEEDED(509, HttpStatus.Series.SERVER_ERROR, &quot;Bandwidth Limit Exceeded&quot;),    NOT_EXTENDED(510, HttpStatus.Series.SERVER_ERROR, &quot;Not Extended&quot;),    NETWORK_AUTHENTICATION_REQUIRED(511, HttpStatus.Series.SERVER_ERROR, &quot;Network Authentication Required&quot;);    private static final HttpStatus[] VALUES = values();    private final int value;    private final Series series;    private final String reasonPhrase;    private HttpStatus(int value, Series series, String reasonPhrase) &#123;        this.value = value;        this.series = series;        this.reasonPhrase = reasonPhrase;    &#125;    public int value() &#123;        return this.value;    &#125;    public Series series() &#123;        return this.series;    &#125;    public String getReasonPhrase() &#123;        return this.reasonPhrase;    &#125;    public boolean is1xxInformational() &#123;        return this.series() == HttpStatus.Series.INFORMATIONAL;    &#125;    public boolean is2xxSuccessful() &#123;        return this.series() == HttpStatus.Series.SUCCESSFUL;    &#125;    public boolean is3xxRedirection() &#123;        return this.series() == HttpStatus.Series.REDIRECTION;    &#125;    public boolean is4xxClientError() &#123;        return this.series() == HttpStatus.Series.CLIENT_ERROR;    &#125;    public boolean is5xxServerError() &#123;        return this.series() == HttpStatus.Series.SERVER_ERROR;    &#125;    public boolean isError() &#123;        return this.is4xxClientError() || this.is5xxServerError();    &#125;    public String toString() &#123;        int var10000 = this.value;        return &quot;&quot; + var10000 + &quot; &quot; + this.name();    &#125;    public static HttpStatus valueOf(int statusCode) &#123;        HttpStatus status = resolve(statusCode);        if (status == null) &#123;            throw new IllegalArgumentException(&quot;No matching constant for [&quot; + statusCode + &quot;]&quot;);        &#125; else &#123;            return status;        &#125;    &#125;    @Nullable    public static HttpStatus resolve(int statusCode) &#123;        HttpStatus[] var1 = VALUES;        int var2 = var1.length;        for(int var3 = 0; var3 &lt; var2; ++var3) &#123;            HttpStatus status = var1[var3];            if (status.value == statusCode) &#123;                return status;            &#125;        &#125;        return null;    &#125;    public static enum Series &#123;        INFORMATIONAL(1),        SUCCESSFUL(2),        REDIRECTION(3),        CLIENT_ERROR(4),        SERVER_ERROR(5);        private final int value;        private Series(int value) &#123;            this.value = value;        &#125;        public int value() &#123;            return this.value;        &#125;        /** @deprecated */        @Deprecated        public static Series valueOf(HttpStatus status) &#123;            return status.series;        &#125;        public static Series valueOf(int statusCode) &#123;            Series series = resolve(statusCode);            if (series == null) &#123;                throw new IllegalArgumentException(&quot;No matching constant for [&quot; + statusCode + &quot;]&quot;);            &#125; else &#123;                return series;            &#125;        &#125;        @Nullable        public static Series resolve(int statusCode) &#123;            int seriesCode = statusCode / 100;            Series[] var2 = values();            int var3 = var2.length;            for(int var4 = 0; var4 &lt; var3; ++var4) &#123;                Series series = var2[var4];                if (series.value == seriesCode) &#123;                    return series;                &#125;            &#125;            return null;        &#125;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","源码分析"]},{"title":"Spring Boot part12-嵌入式容器","url":"/posts/6874.html","content":"前言\r\nSpring Boot\r\n的目标是构建“非常容易创建、独立、产品级别的基于Spring的应用”。这些应用是“立即可运行的”。在这个过程中，完全没有代码生成，不需要配置任何特殊的XML配置，为了这个目标，Spring\r\nBoot 在 Spring 4.0\r\n框架之上提供了很多特性，帮助应用以“约定优于配置”“开箱即用”的方式来启动应用并运行上下文。\r\nSpring Boot 同样改变了一个传统的 Web\r\n应用服务的启动流程和部署方式。通过自动配置机制，Spring Boot\r\n提供了一个嵌入式的运行时容器环境，并使用代码注解的方式在代码中将 URL\r\n服务地址映射到 Controller 的方法完成服务映射。\r\n所以，开发者不再需要关心传统容器（如\r\nTomcat）中web.xml的配置，同时实现容器的具体技术都是可替换及可更改的，这些技术以插件化的Starter组件方式在运行时加载到\r\nSpring 容器中。\r\n\r\n\r\nimg\r\n\r\n什么是嵌入式容器\r\n嵌入式容器是指将Servlet容器（如Tomcat、Jetty、Undertow）直接集成到应用程序中，而不是作为独立的外部服务器运行。这种设计使得应用程序可以作为一个独立的单元运行，无需额外安装和配置Web服务器。\r\n优势：\r\n\r\n简化部署：应用程序打包为可执行的JAR文件，包含所有依赖和运行时环境，部署时只需运行JAR文件即可。\r\n开发便捷：无需配置外部服务器，开发者可以专注于业务逻辑，快速启动和测试应用。\r\n灵活性：支持多种容器（Tomcat、Jetty、Undertow），开发者可以根据需求自由切换。\r\n适合云原生：嵌入式容器轻量且易于扩展，非常适合微服务和云原生应用场景。\r\n\r\nServlet 容器：管理、运⾏ Servlet\r\n组件（Servlet、Filter、Listener）的环境，⼀般指服务器。\r\nSpring\r\nBoot默认使用Tomcat作为嵌入式Servlet容器，但也支持Jetty和Undertow。开发者可以通过简单的依赖配置切换容器。\r\n其对应的 Java Web 容器发展至今也分为 Servlet Web 容器和\r\nReactive Web\r\n容器，前者的使用率大概占比是百分之九十左右，其具体的实现有\r\nTomcat、Jetty 和\r\nUndertow；而后者它的默认实现为\r\nNetty Web Server\r\nServlet 规范是 Java Web 开发的核心标准，由 Java Community\r\nProcess（JCP）制定，用于定义 Web 容器与 Servlet\r\n组件之间的交互规则。以下是 Tomcat、Jetty、Undertow 对 Servlet\r\n规范的兼容情况对比：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n容器名称\r\n最新稳定版本\r\n支持的最高 Servlet 规范\r\n关键特性\r\n\r\n\r\n\r\n\r\nTomcat\r\n10.1.x（2023 年）\r\nServlet 5.0（JSP 3.0）\r\n- 最广泛使用的 Java Web 容器 - 轻量级、高稳定性 - 完整支持 JSP 与 EL\r\n表达式 - 适用于中小型企业应用\r\n\r\n\r\nJetty\r\n12.0.x（2023 年）\r\nServlet 5.0（WebSocket 2.0）\r\n- 高性能异步处理能力 - 支持嵌入式部署（如 Spring Boot） -\r\n轻量级架构，启动速度快 - 对 WebSocket 支持尤为出色\r\n\r\n\r\nUndertow\r\n2.3.x（2023 年）\r\nServlet 4.0（WebSockets 1.1）\r\n- Red Hat 开发的高性能容器 - 基于 NIO 的非阻塞模型 -\r\n内存占用低，适合微服务场景 - 与 Spring Boot 默认集成度高\r\n\r\n\r\n\r\n其中的容器如何选择：\r\n\r\nTomcat：兼容性优先\r\n\r\n若应用依赖 JSP 或需要兼容旧版框架（如 Struts 2），Tomcat\r\n是首选。\r\nSpring Boot 默认使用 Tomcat，适合快速搭建传统 Web 应用。\r\n\r\nJetty：异步与 WebSocket 场景\r\n\r\n实时通信系统（如在线聊天、股票行情）推荐 Jetty，其 WebSocket\r\n性能优于 Tomcat。\r\n嵌入式服务（如工具类应用）因轻量级特性更适合 Jetty。\r\n\r\nUndertow：高性能与微服务\r\n\r\n高并发、低延迟场景（如 API 网关、实时数据处理）优先选择\r\nUndertow。\r\n与 Spring Boot 集成时，可通过配置\r\napplication.properties 切换：\r\n\r\n\r\n自动配置嵌入式容器的原理\r\n核心机制\r\nSpring Boot 自动配置嵌入式容器的核心是通过 条件注解\r\n和 工厂模式 实现的。这一机制遵循 “约定优于配置”\r\n的原则，使开发者无需手动配置服务器。\r\n关键组件：\r\n\r\nServletWebServerFactoryAutoConfiguration：主配置类，负责检测环境并加载合适的容器配置\r\nServletWebServerFactory：工厂接口，负责创建具体的 Web\r\n服务器实例\r\nWebServer：抽象接口，代表实际运行的 Web 服务器（如\r\nTomcat、Jetty）\r\nServerProperties：配置属性类，绑定\r\napplication.properties 中的 server.* 配置\r\nEmbeddedWebServerFactoryCustomizerAutoConfiguration\r\n：\r\n\r\n条件注解的作用：\r\n\r\n@ConditionalOnClass：确保类路径中存在指定类时才生效\r\n@ConditionalOnWebApplication：确保应用是 Web\r\n应用时才生效\r\n@ConditionalOnMissingBean：确保容器中不存在指定 Bean\r\n时才创建\r\n\r\n工作流程\r\n其中 Spring Boot 自动配置嵌入式 Servlet 容器的核心类是\r\nServletWebServerFactoryAutoConfiguration，从其源码我们能得知\r\nServletWebServerFactoryAutoConfiguration 分析\r\n// 是一个配置类，定义Spring Bean。@Configuration(    // 该配置类中的@Bean方法不会被CGLIB代理调用，而是直接返回新的实例。适用于配置类内部没有Bean依赖的情况    proxyBeanMethods = false)// 指定该自动配置类的加载顺序@AutoConfigureOrder(Integer.MIN_VALUE)// 仅在类路径中存在ServletRequest类时生效，即项目中引入了Servlet相关的依赖@ConditionalOnClass(&#123;ServletRequest.class&#125;)// 仅在当前应用是Servlet Web应用（而非Reactive Web应用）时生效。@ConditionalOnWebApplication(    type = Type.SERVLET)// 启用ServerProperties配置绑定@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)// 导入其他配置类或组件和其他嵌入式容器的自动配置类，Spring Boot会根据类路径中的依赖动态选择其中一个@Import(&#123;BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class&#125;)public class ServletWebServerFactoryAutoConfiguration &#123;&#125;\r\n这个配置类的主要功能：\r\n\r\n通过 @Import\r\n导入三种容器的配置类，但只会根据类路径中存在的依赖激活其中一个\r\n@EnableConfigurationProperties 绑定\r\nServerProperties，使 application.properties\r\n中的配置生效，这些属性会在自动配置阶段被注入到嵌入式容器的工厂类（如TomcatServletWebServerFactory）中。\r\n@AutoConfigureOrder 确保该配置类优先加载\r\n\r\n源码分析：\r\n\r\nServletWebServerFactoryAutoConfiguration\r\n⾃动配置了嵌⼊式容器场景,ServerProperties 类通过\r\n@ConfigurationProperties\r\n注解绑定配置文件中的属性，这些属性会被注入到工厂类中，影响服务器的行为\r\n绑定了ServerProperties\r\n配置类，所有和（嵌入式容器）服务器有关的配置都在以\r\nserver开头的配置\r\n\r\n\r\nimage-20250611104002322\r\n\r\n\r\ntomcat 调优就在 server-tomcat所有配置\r\n\r\nServletWebServerFactoryAutoConfiguration\r\n导入了嵌入式的三大服务器 Tomcat 、 Jetty 、\r\nUndertow\r\n\r\n导⼊ Tomcat 、 Jetty 、\r\nUndertow\r\n都有条件注解。系统中有这个类才行（也就是导了包）\r\n默认 Tomcat 配置⽣效。给容器中放\r\nTomcatServletWebServerFactory\r\n都给容器中 ServletWebServerFactory 放了⼀个\r\nweb服务器工厂（造web服务器的）\r\nweb服务器工厂 都有⼀个功能，getWebServer\r\n获取web服务器\r\npublic WebServer getWebServer(ServletContextInitializer... initializers) &#123;        if (this.disableMBeanRegistry) &#123;            Registry.disableRegistry();        &#125;        Tomcat tomcat = new Tomcat();        File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir(&quot;tomcat&quot;);\r\nTomcatServletWebServerFactory 创建了\r\ntomcat。\r\n\r\nServletWebServerFactory 什么时候会创建 webServer\r\n出来，ServletWebServerApplicationContext，ioc容器，启动的时候会调⽤创建\r\nweb 服务器\r\nSpring\r\n容器刷新的时候，会预留一个时机，刷新子容器，onRefresh()，而所谓容器刷新，就是容器启动\r\nrefresh()\r\n容器刷新十二大步的刷新⼦容器会调用，onRefresh()，而在\r\nonRefresh()\r\n方法中，ServletWebServerApplicationContext 会调用\r\ncreateWebServer() 方法\r\n\r\nprivate void createWebServer() &#123;    WebServer webServer = this.webServer;    ServletContext servletContext = this.getServletContext();        if (webServer == null &amp;&amp; servletContext == null) &#123;        // 获取容器中的工厂类        ServletWebServerFactory factory = this.getWebServerFactory();        // 创建Web服务器实例        this.webServer = factory.getWebServer(this.getSelfInitializer());    &#125;    // ...&#125;\r\n这个过程中：\r\n\r\nSpring 容器从自身获取 ServletWebServerFactory\r\nBean（例如 TomcatServletWebServerFactory）\r\n调用工厂的 getWebServer() 方法创建实际的 Web\r\n服务器\r\n服务器启动并绑定到配置的端口（默认 8080）\r\n\r\n其中的 refresh() 容器刷新十二大步如下\r\npublic void refresh() throws BeansException, IllegalStateException &#123;        synchronized(this.startupShutdownMonitor) &#123;            StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;);            this.prepareRefresh();            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();            this.prepareBeanFactory(beanFactory);            try &#123;                this.postProcessBeanFactory(beanFactory);                StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);                this.invokeBeanFactoryPostProcessors(beanFactory);                this.registerBeanPostProcessors(beanFactory);                beanPostProcess.end();                this.initMessageSource();                this.initApplicationEventMulticaster();                this.onRefresh();    // 第10步：刷新子容器                this.registerListeners();                this.finishBeanFactoryInitialization(beanFactory);                this.finishRefresh();            &#125; catch (BeansException var10) &#123;                BeansException ex = var10;                if (this.logger.isWarnEnabled()) &#123;                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + ex);                &#125;                this.destroyBeans();                this.cancelRefresh(ex);                throw ex;            &#125; finally &#123;                this.resetCommonCaches();                contextRefresh.end();            &#125;        &#125;    &#125;\r\n\r\n总结出来就是一句话，Web 场景的 Spring 容器启动，在 onRefresh\r\n的时候，会调用创建 Web 服务器的方法\r\n而 Web 服务器的创建是通过 WebServerFactory\r\n搞定的。容器中又会根据导了什么包条件注解，启动相关的服务器配置，默认EmbeddedTomcat会给容器中放⼀个TomcatServletWebServerFactory\r\n，导致项目启动，⾃动创建出Tomcat。\r\n\r\nsequenceDiagram\n    participant App as 应用启动\n    participant AutoConfig as 自动配置\n    participant Container as Spring容器\n    participant Factory as 服务器工厂\n    participant Server as Web服务器\n    \n    App-&gt;&gt;AutoConfig: 加载ServletWebServerFactoryAutoConfiguration\n    AutoConfig-&gt;&gt;AutoConfig: 检查条件注解\n    AutoConfig-&gt;&gt;AutoConfig: 导入对应容器配置\n    AutoConfig-&gt;&gt;Container: 注册ServletWebServerFactory\n    \n    App-&gt;&gt;Container: 调用refresh()\n    Container-&gt;&gt;Container: 执行onRefresh()\n    Container-&gt;&gt;Factory: 获取WebServerFactory\n    Factory-&gt;&gt;Server: 创建WebServer实例\n    Server-&gt;&gt;Server: 启动并监听端口\n    Server--&gt;&gt;Container: 返回WebServer\n    Container--&gt;&gt;App: 启动完成\r\n自定义嵌入式 Servlet 容器\r\n为什么 Tomcat 是默认的容器\r\n这就涉及到 Spring Boot 的默认绑定机制\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\r\n\r\n自动包含spring-boot-starter-tomcat传递依赖\r\n依赖关系可通过mvn dependency:tree查看：\r\n[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.7.0[INFO] |  \\- org.springframework.boot:spring-boot-starter-tomcat:jar:2.7.0\r\n\r\n而Reactive Web 应用\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;\r\n\r\n其中自动包含reactor-netty核心依赖\r\n\r\n\r\n\r\nimg\r\n\r\n&lt;!--引入springboot父依赖--&gt;   &lt;parent&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;       &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;   &lt;/parent&gt;   &lt;dependencies&gt;       &lt;!--引入启动器依赖 里面就有默认的tomcat --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;\r\n如何切换嵌入式 Servlet 容器\r\nSpring Boot 支持四种嵌入式容器实现，分别对应不同的技术场景：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n容器类型\r\n技术类型\r\n默认绑定启动器\r\n特点\r\n\r\n\r\n\r\n\r\nTomcat\r\nServlet Web\r\nspring-boot-starter-web\r\n默认实现，稳定性高\r\n\r\n\r\nJetty\r\nServlet Web\r\nspring-boot-starter-jetty\r\n高性能，适合长连接场景\r\n\r\n\r\nUndertow\r\nServlet Web\r\nspring-boot-starter-undertow\r\n低内存消耗，非阻塞IO模型\r\n\r\n\r\nNetty\r\nReactive Web\r\nspring-boot-starter-webflux\r\n异步非阻塞，高并发处理\r\n\r\n\r\n\r\n以上 Web 容器均被 Spring Boot\r\n嵌入至其中作为其核心特性，来简化\r\nSpring Boot应用启动流程。Spring Boot 通过\r\nMaven 依赖来切换应用的嵌入式容器类型，其对应的 Maven jar\r\n分别是：\r\n&lt;!-- Tomcat --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- undertow --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jetty --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- netty Web Server --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-reactor-netty&lt;/artifactId&gt;&lt;/dependency&gt;\r\n前三者是 Servlet Web 实现，最后则是\r\nReactive Web 的实现。值得注意的是，当我们引用的是\r\nServlet Web 功能模块时，它会自动集成 Tomcat\r\n，里面包含了 Tomcat 的 Maven\r\n依赖包，也是印证了上面说的 Tomcat 是默认的\r\nServlet Web 容器。Servlet Web 模块的\r\nMaven 依赖就是 web 启动场景：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\r\n而如果引用的是 Reactive Web 功能模块时，则会默认集成\r\nnetty Web Server 。Reactive Web\r\n模块的依赖如下：\r\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;\r\n不过，上面的三种 Servlet Web 容器也能作为\r\nReactive Web 容器 ，并允许替换默认实现\r\nNetty Web Server，因为 Servlet\r\n3.1+容器同样满足 Reactive 异步非阻塞特性。\r\n我们需要切换不同的容器，就需要在启动器依赖里把 Tomcat\r\n给排除，然后换成自己需要的容器类型\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!-- 关键步骤：排除Tomcat --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入Jetty --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;\r\n如果需要切换到 Netty 也是一样\r\n因为web里引入的是tomcat容器，所以这里首先排除tomcat容器，然后引入Netty容器\r\n&lt;!--引入springboot父依赖--&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;!--引入启动器依赖 里面就有默认的tomcat --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;!--排除tomcat--&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;!--引入Netty--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n而其中装配什么就生效什么，也是依赖于上述的条件装配机制，每个容器配置类都有@ConditionalOnClass注解，并且通过spring-autoconfigure-metadata.json定义加载顺序\r\ngraph TD\n  A[启动应用] --&gt; B[检测类路径]\n  B --&gt; C&#123;存在Tomcat类?&#125;\n  C --&gt;|是| D[加载Tomcat工厂]\n  C --&gt;|否| E&#123;存在Jetty类?&#125;\n  E --&gt;|是| F[加载Jetty工厂]\n  E --&gt;|否| G[加载Undertow工厂]\r\n我们可以通过使用如下代码确认当前容器\r\n@SpringBootApplicationpublic class MyApp &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MyApp.class, args)            .getBean(ServletWebServerFactory.class)            .getClass()            .getName(); // 输出工厂类全限定名    &#125;&#125;\r\n但是更常用的从启动日志分析就可以看出\r\no.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\r\n关键日志标识：\r\n\r\nTomcat: o.s.b.w.embedded.tomcat\r\nJetty: o.s.b.w.embedded.jetty\r\nUndertow: o.s.b.w.embedded.undertow\r\n\r\n如果同时存在多个容器依赖\r\n\r\nSpring Boot会按以下优先级选择：\r\n\r\nTomcat\r\nJetty\r\nUndertow\r\n\r\n也可以通过@Order注解控制：\r\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)public class MyCustomContainerAutoConfiguration &#123;&#125;\r\n\r\n不同Spring Boot版本对容器的支持存在差异：\r\n\r\n\r\n\r\nSpring Boot\r\nTomcat\r\nJetty\r\nUndertow\r\nNetty\r\n\r\n\r\n\r\n\r\n2.7.x\r\n9.0\r\n9.4\r\n2.2\r\n1.0\r\n\r\n\r\n3.0.x\r\n10.0\r\n11.0\r\n2.3\r\n1.1\r\n\r\n\r\n\r\n建议通过spring-boot-dependencies管理版本，避免冲突。\r\n三种机制\r\nSpring Boot 提供了灵活的机制来定制嵌入式 Tomcat\r\n容器，开发者可通过配置文件、工厂类定制或完全自定义配置三种方式实现。\r\n容器选择机制\r\nSpring Boot 根据类路径中的依赖自动选择容器：\r\n\r\n默认使用 Tomcat（spring-boot-starter-web 包含 Tomcat\r\n依赖）\r\n若排除 Tomcat 并添加 Jetty/Undertow 依赖，则自动切换\r\n\r\n工厂类的作用：\r\n当容器选择完成后，对应的工厂类会被注册到 Spring 容器中：\r\n\r\nTomcat：TomcatServletWebServerFactory\r\nJetty：JettyServletWebServerFactory\r\nUndertow：UndertowServletWebServerFactory\r\n\r\n这些工厂类实现了 ServletWebServerFactory\r\n接口，负责创建和配置具体的 Web 服务器实例。\r\n以Tomcat为例子，展示如何配置\r\n通过配置文件定制 Tomcat 参数\r\n在 application.properties 或\r\napplication.yml 中通过 server.tomcat 前缀配置\r\nTomcat 特性，以下是常用配置项：\r\n# 基础服务器配置server.port=8080                      # 服务端口server.servlet.context-path=/app      # 上下文路径# Tomcat 连接池配置server.tomcat.max-threads=200         # 最大工作线程数（默认200）server.tomcat.min-spare-threads=10    # 最小空闲线程数（默认10）server.tomcat.max-connections=10000   # 最大连接数（默认10000）server.tomcat.uri-encoding=UTF-8      # URL编码格式# 超时配置server.tomcat.connection-timeout=20000 # 连接超时时间（毫秒，默认20000）server.tomcat.accesslog.enabled=true   # 启用访问日志server.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %Dms # 日志格式# SSL 配置（HTTPS）server.ssl.enabled=trueserver.ssl.key-store=classpath:keystore.p12server.ssl.key-store-password=passwordserver.ssl.key-store-type=PKCS12server.ssl.key-alias=tomcat\r\n通过工厂类定制 Tomcat 组件\r\n通过自定义 TomcatServletWebServerFactory Bean\r\n实现更深度的定制\r\nimport org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.apache.catalina.connector.Connector;import org.apache.catalina.core.StandardContext;import org.apache.catalina.valves.RemoteIpValve;@Configurationpublic class TomcatCustomizationConfig &#123;    // 方式1：直接创建TomcatServletWebServerFactory Bean    @Bean    public TomcatServletWebServerFactory tomcatFactory() &#123;        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();                // 配置端口        factory.setPort(8081);                // 配置上下文路径        factory.setContextPath(&quot;/custom&quot;);                // 自定义连接器（添加HTTP/2支持）        factory.addAdditionalTomcatConnectors(createHttp2Connector());                // 添加Valve（如远程IP转换）        factory.addContextValves(new RemoteIpValve());                // 配置JSP支持（需添加tomcat-embed-jsp依赖）        factory.configureContext((context) -&gt; &#123;            context.addLifecycleListener((event) -&gt; &#123;                if (event.getType().equals(&quot;start&quot;)) &#123;                    // 上下文启动时的自定义逻辑                &#125;            &#125;);        &#125;);                return factory;    &#125;        // 方式2：通过WebServerFactoryCustomizer接口定制    @Bean    public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; tomcatCustomizer() &#123;        return factory -&gt; &#123;            // 配置最大线程数            factory.setMaxThreads(250);            // 配置URI编码            factory.setUriEncoding(&quot;UTF-8&quot;);            // 配置访问日志            factory.getTomcatConnectorCustomizers().add(connector -&gt; &#123;                connector.setProperty(&quot;maxKeepAliveRequests&quot;, &quot;1000&quot;);            &#125;);        &#125;;    &#125;        // 辅助方法：创建HTTP/2连接器    private Connector createHttp2Connector() &#123;        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;);        connector.setPort(8443);        connector.setSecure(true);        connector.setScheme(&quot;https&quot;);                // 配置SSL        connector.setProperty(&quot;sslProtocol&quot;, &quot;TLS&quot;);        connector.setProperty(&quot;keystoreFile&quot;, &quot;classpath:keystore.p12&quot;);        connector.setProperty(&quot;keystorePass&quot;, &quot;password&quot;);        connector.setProperty(&quot;keystoreType&quot;, &quot;PKCS12&quot;);                // 启用HTTP/2        connector.setProperty(&quot;maxHttpHeaderSize&quot;, &quot;8192&quot;);        connector.setProperty(&quot;http2&quot;, &quot;true&quot;);        return connector;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","JavaEE","Web","Spring系列","Servlet","Spring Boot","Java框架","配置相关","源码分析"]},{"title":"Spring Boot part14-数据访问之整合SSM场景及其自动配置原理","url":"/posts/35124.html","content":"Spring Boot 3 整合 SSM\r\n场景进行数据访问\r\n熟悉 SSM 框架\r\nSSM 框架简介\r\nSSM 框架是 Spring、Spring MVC 和 MyBatis 三个框架的整合，是 Java\r\n企业级开发中经典的技术栈组合。其中：\r\n\r\nSpring\r\n提供了依赖注入（DI）和面向切面编程（AOP）等核心功能，用于管理对象生命周期和业务逻辑分层\r\nSpring MVC 是基于 MVC 设计模式的 Web\r\n框架，负责处理 Web 请求和响应\r\nMyBatis 是持久层框架，用于实现数据库操作的 ORM\r\n映射\r\n\r\n\r\nSpring Boot 3 整合 SSM 的优势很明显\r\nSpring Boot 3 对 SSM 框架的整合带来了以下核心优势：\r\n\r\n自动化配置：通过 Starter 依赖自动配置\r\nSpring、Spring MVC 和 MyBatis 的基础环境\r\n简化部署：内置 Tomcat 等容器，可直接打包为可执行\r\nJAR\r\n性能优化：基于 Spring 6 的响应式编程模型，支持\r\nReactive Stream\r\n微服务支持：天然适配 Spring Cloud\r\n生态，便于构建微服务架构\r\n\r\n\r\nSSM 各组件在场景中的角色\r\n\r\nSpringBoot 整合 Spring 、SpringMVC 、MyBatis 进行数据访问场景开发\r\n\r\nSpring\r\n作为整个架构的基石，负责管理应用中的所有组件。它提供了两大核心功能：\r\n\r\n依赖注入 (DI)：通过控制反转 (IoC)\r\n实现组件间的松耦合\r\n面向切面编程\r\n(AOP)：用于处理事务、日志、安全等横切关注点\r\n\r\n在 Spring Boot 3 中，不会再使用 Spring Framework 6\r\n中复杂的配置，配置更加简化，通常使用 Java 注解声明为配置类代替 XML\r\n配置：\r\n@Configuration@EnableTransactionManagementpublic class AppConfig &#123;    //  Bean 定义和配置    @Bean    public UserService userService() &#123;        return new UserServiceImpl();    &#125;&#125;\r\n\r\nSpring MVC 控制器层负责处理 Web 请求，遵循 MVC 设计模式：\r\n\r\nModel：业务数据和逻辑\r\nView：用户界面\r\nController：处理请求并协调 Model 和 View\r\n\r\n负责接收前端请求并返回响应，通常与 RESTful 接口设计结合：\r\n在 Spring Boot 3 中，RESTful API 开发更加便捷：\r\n@RestController@RequestMapping(&quot;/api/users&quot;)public class UserController &#123;        @Autowired    private UserService userService;        @GetMapping    public List&lt;User&gt; getAllUsers() &#123;        return userService.findAll();    &#125;        @PostMapping    @ResponseStatus(HttpStatus.CREATED)    public User createUser(@RequestBody User user) &#123;        return userService.save(user);    &#125;&#125;\r\n\r\nMyBatis 作为 ORM 框架，负责处理数据库操作：\r\n\r\nSQL 映射：通过 XML 或注解定义 SQL 语句\r\n结果映射：将查询结果映射到 Java 对象\r\n参数映射：将 Java 对象转换为 SQL 参数\r\n\r\n在 Spring Boot 3 中，通常使用 Mapper 接口和注解：\r\n@Mapperpublic interface UserMapper &#123;        @Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)    User findById(Long id);        @Insert(&quot;INSERT INTO users(name, email) VALUES(#&#123;name&#125;, #&#123;email&#125;)&quot;)    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)    void save(User user);        @Update(&quot;UPDATE users SET name = #&#123;name&#125; WHERE id = #&#123;id&#125;&quot;)    void update(User user);        @Delete(&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;)    void delete(Long id);&#125;\r\n\r\n组件间协作流程\r\nsequenceDiagram\nClient-&gt;&gt;Controller: HTTP 请求\nController-&gt;&gt;Service: 调用业务方法\nService-&gt;&gt;Mapper: 调用数据访问方法\nMapper-&gt;&gt;Database: 执行 SQL 操作\nDatabase--&gt;&gt;Mapper: 返回结果\nMapper--&gt;&gt;Service: 返回数据对象\nService--&gt;&gt;Controller: 返回业务结果\nController--&gt;&gt;Client: HTTP 响应\r\n数据访问流程\r\n\n        \n          2023\r\n\n        \n      \r\n整合 SSM 场景的 Spring Boot\r\n程序\r\n创建SSM整合项目\r\nSpring Initializier部分\r\n\r\n\r\nimage-20250611172727771\r\n\r\n\r\n\r\nimage-20250611172833188\r\n\r\n所以，需要导入的关键依赖如下\r\n核心依赖\r\nSpring 核心依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\r\n\r\n作用：提供 Spring MVC 框架支持，包括\r\nDispatcherServlet、控制器、视图解析等功能\r\n包含组件：Spring MVC、Spring Web、Tomcat\r\n嵌入式服务器\r\n\r\nMyBatis 集成依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.4&lt;/version&gt;&lt;/dependency&gt;\r\n\r\n作用：MyBatis 与 Spring Boot 的集成包，自动配置\r\nMyBatis 环境\r\n包含组件：MyBatis 核心库、MyBatis-Spring 集成、SQL\r\n会话工厂等\r\n\r\n如果你不使用 MyBatis，Spring 的 JPA 依赖的实现会与 MyBatis\r\n的基本功能重叠，在标准 SSM 架构中，通常使用 MyBatis 而非\r\nJPA。若同时存在两者，需注意配置冲突\r\n数据库连接依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\r\n\r\nspring-boot-starter-jdbc：提供 JDBC 抽象层，包含\r\nHikariCP 连接池\r\nmysql-connector-j：MySQL 数据库驱动，用于连接 MySQL\r\n数据库\r\n\r\n相关配置项\r\n基本配置略过了\r\n数据源相关配置\r\n\r\n采用 MySQL 数据库，使用 HikariCP 连接池 (默认)\r\n连接参数包含时区设置、字符编码等关键配置\r\n连接池参数根据应用并发量可调整\r\n\r\n# 数据库连接信息# 数据库连接URLspring.datasource.url=jdbc:mysql://localhost:3306/ssm_db?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8# 用户名和密码spring.datasource.username=rootspring.datasource.password=root# MySQL 8.x驱动类名spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 连接池配置 (HikariCP)spring.datasource.hikari.minimum-idle=5# 连接池保持的最小空闲连接数，确保有足够连接处理突发请求spring.datasource.hikari.maximum-pool-size=15# 连接池允许的最大连接数，根据服务器资源和应用并发量调整# 计算公式参考：CPU核心数 * 2 + 磁盘数spring.datasource.hikari.auto-commit=true# 是否自动提交事务，默认true，适合大多数场景# 若需要手动控制事务，可设置为falsespring.datasource.hikari.idle-timeout=30000# 空闲连接的超时时间（毫秒），超过此时间的空闲连接将被释放spring.datasource.hikari.pool-name=HikariCP# 连接池名称，用于日志和JMX监控，方便识别spring.datasource.hikari.max-lifetime=1800000# 连接的最大生命周期（毫秒），超过此时间的连接将被强制关闭spring.datasource.hikari.connection-timeout=30000# 获取连接的超时时间（毫秒），超过此时间将抛出异常spring.datasource.hikari.connection-test-query=SELECT 1# 连接测试SQL，用于验证连接是否有效\r\n\r\n连接池大小调优：\r\n\r\n过小会导致连接争用，影响性能\r\n过大会占用过多资源，增加 GC 压力\r\n计算公式：(核心数 * 2) + 磁盘数 作为参考值\r\n\r\n安全性考虑：\r\n\r\n生产环境应使用更安全的密码管理方式（如配置中心、Vault 等）\r\n考虑启用 SSL 连接（移除useSSL=false参数）\r\n\r\n性能优化：\r\n\r\n根据业务特性调整minimum-idle和maximum-pool-size\r\n对于读写比例高的应用，可考虑读写分离配置\r\n\r\n监控与调优：\r\n\r\n结合 Actuator 监控连接池指标（活跃连接数、等待队列等）\r\n根据监控数据动态调整连接池参数\r\n\r\n\r\nMyBatis 配置\r\n# ===========================================# MyBatis配置# ===========================================# Mapper XML文件位置，指定 mapper 映射文件的位置mybatis.mapper-locations=classpath:mapper/*.xml# 实体类包路径，简化XML中类型引用mybatis.type-aliases-package=com.example.entity# MyBatis核心配置mybatis.configuration.map-underscore-to-camel-case=true  # 开启驼峰命名自动映射mybatis.configuration.cache-enabled=true  # 开启二级缓存mybatis.configuration.lazy-loading-enabled=true  # 开启懒加载mybatis.configuration.aggressive-lazy-loading=false  # 关闭激进懒加载mybatis.configuration.default-fetch-size=100  # 默认获取记录数mybatis.configuration.default-statement-timeout=30  # 默认SQL超时时间\r\n安装 MyBatisX 插件，帮我们⽣成 Mapper 接⼝的 xml 文件即可\r\n实体类相关编写\r\n实体类就使用简单的 User 类\r\npackage edu.software.ergoutree.springbootssmdataassess.entity;import lombok.Data;import java.io.Serializable;import java.util.Date;/** * 用户实体类 * 使用@Data注解自动生成getter、setter、equals、hashCode和toString方法 * 实现Serializable接口使对象可序列化，便于网络传输和对象持久化 */@Datapublic class User implements Serializable &#123;        /**     * 用户ID，主键     * 在数据库中通常设置为自增长     */    private Long id;        /**     * 用户名     * 用户登录系统的唯一标识     */    private String username;        /**     * 密码     * 存储时应当加密处理，不应明文存储     */    private String password;        /**     * 用户真实姓名     */    private String realName;        /**     * 用户邮箱     */    private String email;        /**     * 用户手机号     */    private String phone;        /**     * 用户状态     * 0: 禁用     * 1: 启用     */    private Integer status;        /**     * 创建时间     * 记录用户创建的时间戳     */    private Date createTime;        /**     * 更新时间     * 记录用户信息最后一次更新的时间戳     */    private Date updateTime;        /**     * 序列化版本ID     * 用于序列化和反序列化过程中的版本控制     */    private static final long serialVersionUID = 1L;&#125; \r\nMyBatis 相关 mapper\r\n首先，来复习一下 MyBatis，MyBatis 是一个半自动化的\r\nORM（对象关系映射）框架，核心功能是将 SQL 语句与 Java 对象进行映射。在\r\nSSM 项目中，MyBatis 主要负责数据持久层的操作，其核心组件包括：\r\n\r\nSqlSessionFactory：创建 SqlSession\r\n的工厂，通过配置文件或代码构建\r\nSqlSession：提供数据库操作的接口，如查询、更新、事务管理等\r\nMapper 接口：定义数据库操作方法的接口\r\nMapper XML 文件：实现 Mapper 接口方法的 SQL\r\n映射配置\r\nTypeHandler：处理 Java 类型与数据库类型的转换\r\nResultMap：定义复杂的结果集映射规则\r\n\r\n所以，我们包含 CURD 操作的 UserMapper 就如下\r\n那么，如何进行 CURD 的开发呢，主要开发流程如下\r\n\r\n编写 Bean\r\n编写 Mapper\r\n使用插件或手写 MapperXML\r\n编写 CURD 语句\r\n\r\npackage edu.software.ergoutree.springbootssmdataassess.mapper;import edu.software.ergoutree.springbootssmdataassess.entity.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import java.util.List;/** * 用户数据访问层接口 * 使用@Mapper注解标识该接口为MyBatis的Mapper接口 * MyBatis会自动为该接口创建代理对象，实现与数据库的交互 */@Mapperpublic interface UserMapper &#123;        /**     * 插入新用户     *      * @param user 用户对象     * @return 影响的行数     */    int insert(User user);        /**     * 根据主键删除用户     *      * @param id 用户ID     * @return 影响的行数     */    int deleteById(Long id);        /**     * 更新用户信息     *      * @param user 用户对象     * @return 影响的行数     */    int update(User user);        /**     * 根据主键查询用户     *      * @param id 用户ID     * @return 用户对象     */    User selectById(Long id);        /**     * 查询所有用户     *      * @return 用户列表     */    List&lt;User&gt; selectAll();        /**     * 根据用户名查询用户     *      * @param username 用户名     * @return 用户对象     */    User selectByUsername(String username);        /**     * 根据条件查询用户列表     *      * @param user 查询条件     * @return 用户列表     */    List&lt;User&gt; selectByCondition(User user);        /**     * 批量删除用户     *      * @param ids 用户ID数组     * @return 影响的行数     */    int batchDelete(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);        /**     * 统计用户总数     *      * @return 用户总数     */    int count();&#125; \r\n然后，我们就需要为 Mapper 编写对应的 xml 文件，在这里可以使用对应的\r\nMyBatisX 插件自动生成\r\n在这里复习以下 MyBatis 提供的 SQL 标签：\r\n\r\n&lt;where&gt;：自动处理 SQL 语句中的\r\nWHERE 关键字和多余的 AND/OR\r\n&lt;if&gt;：根据条件判断是否包含某段\r\nSQL\r\n&lt;&gt;set：自动处理 UPDATE 语句中的\r\nSET 关键字和多余的逗号\r\n&lt;foreach&gt;：遍历集合参数，生成 IN\r\n条件或批量操作\r\n&lt;choose&gt;/&lt;when&gt;/&lt;otherwise&gt;：类似\r\nJava 的 switch-case 结构\r\n\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;edu.software.ergoutree.springbootssmdataassess.mapper.UserMapper&quot;&gt;        &lt;!-- 结果映射，将数据库字段映射到实体类属性 --&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;edu.software.ergoutree.springbootssmdataassess.entity.User&quot;&gt;        &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;        &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;        &lt;result column=&quot;real_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;realName&quot; /&gt;        &lt;result column=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;email&quot; /&gt;        &lt;result column=&quot;phone&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;phone&quot; /&gt;        &lt;result column=&quot;status&quot; jdbcType=&quot;INTEGER&quot; property=&quot;status&quot; /&gt;        &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;        &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;    &lt;/resultMap&gt;        &lt;!-- 所有字段 --&gt;    &lt;sql id=&quot;Base_Column_List&quot;&gt;        id, username, password, real_name, email, phone, status, create_time, update_time    &lt;/sql&gt;        &lt;!-- 插入用户记录 --&gt;    &lt;insert id=&quot;insert&quot; parameterType=&quot;edu.software.ergoutree.springbootssmdataassess.entity.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        insert into user (            username, password, real_name, email, phone, status, create_time, update_time        ) values (            #&#123;username,jdbcType=VARCHAR&#125;,             #&#123;password,jdbcType=VARCHAR&#125;,             #&#123;realName,jdbcType=VARCHAR&#125;,             #&#123;email,jdbcType=VARCHAR&#125;,             #&#123;phone,jdbcType=VARCHAR&#125;,             #&#123;status,jdbcType=INTEGER&#125;,             now(),             now()        )    &lt;/insert&gt;        &lt;!-- 根据主键删除用户 --&gt;    &lt;delete id=&quot;deleteById&quot; parameterType=&quot;java.lang.Long&quot;&gt;        delete from user where id = #&#123;id,jdbcType=BIGINT&#125;    &lt;/delete&gt;        &lt;!-- 批量删除用户 --&gt;    &lt;delete id=&quot;batchDelete&quot; parameterType=&quot;java.util.List&quot;&gt;        delete from user where id in        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/delete&gt;        &lt;!-- 更新用户信息 --&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;edu.software.ergoutree.springbootssmdataassess.entity.User&quot;&gt;        update user        &lt;set&gt;            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username,jdbcType=VARCHAR&#125;,&lt;/if&gt;            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password,jdbcType=VARCHAR&#125;,&lt;/if&gt;            &lt;if test=&quot;realName != null&quot;&gt;real_name = #&#123;realName,jdbcType=VARCHAR&#125;,&lt;/if&gt;            &lt;if test=&quot;email != null&quot;&gt;email = #&#123;email,jdbcType=VARCHAR&#125;,&lt;/if&gt;            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone,jdbcType=VARCHAR&#125;,&lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status,jdbcType=INTEGER&#125;,&lt;/if&gt;            update_time = now()        &lt;/set&gt;        where id = #&#123;id,jdbcType=BIGINT&#125;    &lt;/update&gt;        &lt;!-- 根据主键查询用户 --&gt;    &lt;select id=&quot;selectById&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select         &lt;include refid=&quot;Base_Column_List&quot; /&gt;        from user        where id = #&#123;id,jdbcType=BIGINT&#125;    &lt;/select&gt;        &lt;!-- 查询所有用户 --&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select         &lt;include refid=&quot;Base_Column_List&quot; /&gt;        from user        order by id desc    &lt;/select&gt;        &lt;!-- 根据用户名查询用户 --&gt;    &lt;select id=&quot;selectByUsername&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select         &lt;include refid=&quot;Base_Column_List&quot; /&gt;        from user        where username = #&#123;username,jdbcType=VARCHAR&#125;    &lt;/select&gt;        &lt;!-- 根据条件查询用户列表 --&gt;    &lt;select id=&quot;selectByCondition&quot; parameterType=&quot;edu.software.ergoutree.springbootssmdataassess.entity.User&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select         &lt;include refid=&quot;Base_Column_List&quot; /&gt;        from user        &lt;where&gt;            &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;                and username like concat(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;)            &lt;/if&gt;            &lt;if test=&quot;realName != null and realName != &#x27;&#x27;&quot;&gt;                and real_name like concat(&#x27;%&#x27;, #&#123;realName&#125;, &#x27;%&#x27;)            &lt;/if&gt;            &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;                and email = #&#123;email&#125;            &lt;/if&gt;            &lt;if test=&quot;phone != null and phone != &#x27;&#x27;&quot;&gt;                and phone = #&#123;phone&#125;            &lt;/if&gt;            &lt;if test=&quot;status != null&quot;&gt;                and status = #&#123;status&#125;            &lt;/if&gt;        &lt;/where&gt;        order by id desc    &lt;/select&gt;        &lt;!-- 统计用户总数 --&gt;    &lt;select id=&quot;count&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select count(*) from user    &lt;/select&gt;    &lt;/mapper&gt; \r\n之后就是对应的\r\nService 层 和 Controller 层\r\nService 接口\r\npackage edu.software.ergoutree.springbootssmdataassess.service;import edu.software.ergoutree.springbootssmdataassess.entity.User;import java.util.List;/** * 用户服务接口 * 定义用户相关的业务逻辑操作 */public interface UserService &#123;        /**     * 添加用户     *      * @param user 用户信息     * @return 添加成功返回true，否则返回false     */    boolean addUser(User user);        /**     * 删除用户     *      * @param id 用户ID     * @return 删除成功返回true，否则返回false     */    boolean deleteUser(Long id);        /**     * 更新用户信息     *      * @param user 用户信息     * @return 更新成功返回true，否则返回false     */    boolean updateUser(User user);        /**     * 根据ID查询用户     *      * @param id 用户ID     * @return 用户对象，如果不存在返回null     */    User getUserById(Long id);        /**     * 查询所有用户     *      * @return 用户列表     */    List&lt;User&gt; getAllUsers();        /**     * 根据用户名查询用户     *      * @param username 用户名     * @return 用户对象，如果不存在返回null     */    User getUserByUsername(String username);        /**     * 根据条件查询用户     *      * @param user 查询条件     * @return 符合条件的用户列表     */    List&lt;User&gt; getUsersByCondition(User user);        /**     * 批量删除用户     *      * @param ids 用户ID列表     * @return 删除成功返回true，否则返回false     */    boolean batchDeleteUsers(List&lt;Long&gt; ids);        /**     * 获取用户总数     *      * @return 用户总数     */    int countUsers();&#125; \r\n实现类\r\npackage edu.software.ergoutree.springbootssmdataassess.service.impl;import edu.software.ergoutree.springbootssmdataassess.entity.User;import edu.software.ergoutree.springbootssmdataassess.mapper.UserMapper;import edu.software.ergoutree.springbootssmdataassess.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 用户服务实现类 * 使用@Service注解标识该类为Spring的服务层组件 */@Servicepublic class UserServiceImpl implements UserService &#123;    /**     * 用户数据访问对象     * 使用@Autowired注解自动注入UserMapper依赖     */    @Autowired    private UserMapper userMapper;        /**     * 添加用户     * 使用@Transactional注解声明事务，确保数据一致性     *      * @param user 用户信息     * @return 添加成功返回true，否则返回false     */    @Override    @Transactional    public boolean addUser(User user) &#123;        // 设置默认状态为启用        if (user.getStatus() == null) &#123;            user.setStatus(1);        &#125;        return userMapper.insert(user) &gt; 0;    &#125;        /**     * 删除用户     *      * @param id 用户ID     * @return 删除成功返回true，否则返回false     */    @Override    @Transactional    public boolean deleteUser(Long id) &#123;        return userMapper.deleteById(id) &gt; 0;    &#125;        /**     * 更新用户信息     *      * @param user 用户信息     * @return 更新成功返回true，否则返回false     */    @Override    @Transactional    public boolean updateUser(User user) &#123;        return userMapper.update(user) &gt; 0;    &#125;        /**     * 根据ID查询用户     *      * @param id 用户ID     * @return 用户对象，如果不存在返回null     */    @Override    public User getUserById(Long id) &#123;        return userMapper.selectById(id);    &#125;        /**     * 查询所有用户     *      * @return 用户列表     */    @Override    public List&lt;User&gt; getAllUsers() &#123;        return userMapper.selectAll();    &#125;        /**     * 根据用户名查询用户     *      * @param username 用户名     * @return 用户对象，如果不存在返回null     */    @Override    public User getUserByUsername(String username) &#123;        return userMapper.selectByUsername(username);    &#125;        /**     * 根据条件查询用户     *      * @param user 查询条件     * @return 符合条件的用户列表     */    @Override    public List&lt;User&gt; getUsersByCondition(User user) &#123;        return userMapper.selectByCondition(user);    &#125;        /**     * 批量删除用户     *      * @param ids 用户ID列表     * @return 删除成功返回true，否则返回false     */    @Override    @Transactional    public boolean batchDeleteUsers(List&lt;Long&gt; ids) &#123;        return userMapper.batchDelete(ids) &gt; 0;    &#125;        /**     * 获取用户总数     *      * @return 用户总数     */    @Override    public int countUsers() &#123;        return userMapper.count();    &#125;&#125; \r\nController 层的编写和之前没有什么差别\r\npackage edu.software.ergoutree.springbootssmdataassess.controller;import edu.software.ergoutree.springbootssmdataassess.entity.User;import edu.software.ergoutree.springbootssmdataassess.service.UserService;import edu.software.ergoutree.springbootssmdataassess.common.Result;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 用户控制器 * 处理用户相关的HTTP请求 * 使用@RestController注解标识该类为控制器，并且方法的返回值会自动转换为JSON格式 * 使用@RequestMapping注解指定该控制器的基础URL路径 */@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123;    /**     * 用户服务     * 使用@Autowired注解自动注入UserService依赖     */    @Autowired    private UserService userService;        /**     * 创建用户     * 使用@PostMapping注解处理POST请求     *      * @param user 用户信息，从请求体中获取     * @return 创建结果     */    @PostMapping    public Result&lt;User&gt; createUser(@RequestBody User user) &#123;        boolean result = userService.addUser(user);        if (result) &#123;            return Result.success(&quot;用户创建成功&quot;, user);        &#125; else &#123;            return Result.error(&quot;用户创建失败&quot;);        &#125;    &#125;        /**     * 根据ID获取用户     * 使用@GetMapping注解处理GET请求     * 使用@PathVariable注解获取URL路径中的参数     *      * @param id 用户ID     * @return 用户信息     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Result&lt;User&gt; getUserById(@PathVariable Long id) &#123;        User user = userService.getUserById(id);        if (user != null) &#123;            return Result.success(user);        &#125; else &#123;            return Result.error(404, &quot;用户不存在&quot;);        &#125;    &#125;        /**     * 获取所有用户     *      * @return 用户列表     */    @GetMapping    public Result&lt;List&lt;User&gt;&gt; getAllUsers() &#123;        List&lt;User&gt; users = userService.getAllUsers();        return Result.success(users);    &#125;        /**     * 更新用户     * 使用@PutMapping注解处理PUT请求     *      * @param id 用户ID     * @param user 更新的用户信息     * @return 更新结果     */    @PutMapping(&quot;/&#123;id&#125;&quot;)    public Result&lt;Void&gt; updateUser(@PathVariable Long id, @RequestBody User user) &#123;        // 使用lombok生成的setter方法设置ID        user.setId(id);        boolean result = userService.updateUser(user);        if (result) &#123;            return Result.success(&quot;用户更新成功&quot;, null);        &#125; else &#123;            return Result.error(&quot;用户更新失败&quot;);        &#125;    &#125;        /**     * 删除用户     * 使用@DeleteMapping注解处理DELETE请求     *      * @param id 用户ID     * @return 删除结果     */    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public Result&lt;Void&gt; deleteUser(@PathVariable Long id) &#123;        boolean result = userService.deleteUser(id);        if (result) &#123;            return Result.success(&quot;用户删除成功&quot;, null);        &#125; else &#123;            return Result.error(&quot;用户删除失败&quot;);        &#125;    &#125;        /**     * 根据用户名查询用户     * 使用@GetMapping注解处理GET请求     * 使用@RequestParam注解获取查询参数     *      * @param username 用户名     * @return 用户信息     */    @GetMapping(&quot;/by-username&quot;)    public Result&lt;User&gt; getUserByUsername(@RequestParam String username) &#123;        User user = userService.getUserByUsername(username);        if (user != null) &#123;            return Result.success(user);        &#125; else &#123;            return Result.error(404, &quot;用户不存在&quot;);        &#125;    &#125;        /**     * 条件查询用户     *      * @param user 查询条件     * @return 符合条件的用户列表     */    @PostMapping(&quot;/search&quot;)    public Result&lt;List&lt;User&gt;&gt; searchUsers(@RequestBody User user) &#123;        List&lt;User&gt; users = userService.getUsersByCondition(user);        return Result.success(users);    &#125;        /**     * 批量删除用户     *      * @param ids 用户ID列表     * @return 删除结果     */    @DeleteMapping(&quot;/batch&quot;)    public Result&lt;Void&gt; batchDeleteUsers(@RequestBody List&lt;Long&gt; ids) &#123;        boolean result = userService.batchDeleteUsers(ids);        if (result) &#123;            return Result.success(&quot;批量删除成功&quot;, null);        &#125; else &#123;            return Result.error(&quot;批量删除失败&quot;);        &#125;    &#125;        /**     * 获取用户总数     *      * @return 用户总数     */    @GetMapping(&quot;/count&quot;)    public Result&lt;Integer&gt; countUsers() &#123;        int count = userService.countUsers();        return Result.success(count);    &#125;&#125; \r\n启动类\r\n启动类也要有相应改变\r\n\r\n@MapperScan(basePackages = ““) mapper\r\n文件的包位置，批量扫描注解，供扫描哪个包下的所有接口\r\n\r\npackage edu.software.ergoutree.springbootssmdataassess;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(basePackages = &quot;edu.software.ergoutree.springbootssmdataassess.mapper&quot;)@SpringBootApplicationpublic class SpringBootSsmDataAssessApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringBootSsmDataAssessApplication.class, args);    &#125;&#125;\r\n配置类中也要配置每个接口的xml 的位置\r\nmybatis.mapper-locations=classpath:mapper/*.xml\r\n这样就会自动进行绑定\r\n所以说，接口的全类名和namespace的值是一一对应的\r\n测试发现接口都能正常使用获得信息\r\n\r\n\r\nimage-20250613105849633\r\n\r\nSSM 整合总结\r\nSSM 的核心整合的目标\r\n就是基于 Spring Boot 3.5，通过 自动配置 简化传统 SSM\r\n繁琐的 XML 配置，快速搭建 “控制层（SpringMVC）+\r\n业务层（Spring）+ 持久层（MyBatis）” 三层架构，实现：\r\n\r\n浏览器 / 前端 → SpringMVC（Controller）\r\n接收请求\r\n业务逻辑 → Spring（Service）\r\n处理（含事务管理）\r\n数据库操作 → MyBatis（Mapper） 执行 SQL\r\n\r\n整合步骤如下：\r\n依赖导入：用 Starter 简化配置\r\n\r\nspring-boot-starter-web：包含 SpringMVC\r\n核心功能，自动配置\r\nDispatcherServlet、HandlerMapping\r\n等。\r\nmybatis-spring-boot-starter：自动配置\r\nSqlSessionFactory、MapperScannerConfigurer，无需手动写\r\nMyBatis 的 XML 配置。\r\n\r\n数据源配置：连接数据库\r\n\r\nSpring Boot 会读取\r\napplication.yml/application.properties\r\n中的配置，自动创建数据源（默认用 HikariCP 连接池）。\r\n\r\n持久层（MyBatis Mapper）：数据库操作\r\n\r\nMyBatis 负责执行 SQL，通过 Mapper 接口 + XML\r\n映射文件 或 注解 实现。\r\n首先先定义 Mapper 接口，创建 Mapper\r\n接口，声明数据库操作方法（类似 DAO 层）\r\n编写 XML 映射文件，在\r\nresources/mapper/ 下创建\r\nUserMapper.xml，编写复杂 SQL（与 Mapper\r\n接口方法对应）：\r\n\r\n业务层（Spring Service）：事务与逻辑\r\n\r\nService 层通过 @Service 被 Spring 管理，依赖 Mapper\r\n操作数据库，并用 @Transactional 管理事务。\r\n\r\n控制层（SpringMVC Controller）：接收请求\r\n\r\nController 负责接收前端请求，调用 Service 处理业务，返回响应（视图或\r\nJSON）。\r\n\r\n启动类：开启自动扫描\r\n\r\nSpring Boot 3.5 中，启动类需标注\r\n@SpringBootApplication，自动扫描同包及子包的 Bean。\r\n需要开启@MapperScan：批量扫描 Mapper\r\n接口包，无需每个接口加 @Mapper，更简洁\r\n\r\nSSM 自动配置原理和分析\r\nSpring Boot 能简化 SSM 整合，核心依赖\r\n“自动配置（Auto-Configuration）” 机制。其底层通过以下 3\r\n个核心组件实现：\r\njdbc\r\n场景的自动配置——DataSourceAutoConfiguration\r\n这个部分配置了数据源等基本信息\r\nmybatis-spring-boot-starter会导入数据库的场景\r\nspring-boot-starter-jdbc，jdbc是操作数据库的场景\r\nJDBC场景的几个自动配置如下，他们的自动配置使得Spring数据访问具有的底层能力：数据源、\r\nJdbcTemplate 、事务\r\nDataSourceAutoConfiguration\r\n全类名：org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\r\n\r\n核心作用：自动创建数据库连接池（DataSource），是所有数据库操作的基础。实现了数据源的自动配置\r\n\r\n所有和数据源有关的配置都绑定在DataSourceProperties\r\n@ConditionalOnClass(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)@ConditionalOnMissingBean(    type = &#123;&quot;io.r2dbc.spi.ConnectionFactory&quot;&#125;)@EnableConfigurationProperties(&#123;DataSourceProperties.class&#125;)@Import(&#123;DataSourcePoolMetadataProvidersConfiguration.class, DataSourceCheckpointRestoreConfiguration.class&#125;)\r\n\r\n绑定配置：将 application.yml 中\r\nspring.datasource 前缀的配置（如\r\nurl、username、password），绑定到\r\nDataSourceProperties 类。\r\n默认实现：默认使用\r\nHikariDataSource（高性能连接池，Spring Boot 2.x+\r\n起默认），替代传统的 Tomcat JDBC 或 DBCP。\r\nstatic class PooledDataSourceCondition extends AnyNestedCondition &#123;        PooledDataSourceCondition() &#123;            super(ConfigurationPhase.PARSE_CONFIGURATION);        &#125;        @Conditional(&#123;PooledDataSourceAvailableCondition.class&#125;)        static class PooledDataSourceAvailable &#123;            PooledDataSourceAvailable() &#123;            &#125;        &#125;        @ConditionalOnProperty(            prefix = &quot;spring.datasource&quot;,            name = &#123;&quot;type&quot;&#125;        )        static class ExplicitType &#123;            ExplicitType() &#123;            &#125;        &#125;\r\n\r\n连接池优先级：HikariCP &gt; Tomcat JDBC &gt; DBCP2\r\n&gt; Oracle UCP。\r\n默认选择\r\nHikariCP：若类路径中同时存在多个连接池，Spring Boot 会优先使用\r\nHikariCP（性能最优）。\r\n\r\n\r\nJdbcTemplateAutoConfiguration\r\n全类名：org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration，这个是负责JdbcTemplate自动配置相关的\r\n// 确保数据源已创建@AutoConfiguration(    after = &#123;DataSourceAutoConfiguration.class&#125;)// 仅当类路径中存在 DataSource 和 JdbcTemplate 时才生效，确保用户已引入 JDBC 相关依赖。@ConditionalOnClass(&#123;DataSource.class, JdbcTemplate.class&#125;)// 仅当容器中存在 唯一的 DataSource Bean 时才生效@ConditionalOnSingleCandidate(DataSource.class)// 启用 JdbcProperties 配置类，绑定 spring.jdbc 前缀的配置@EnableConfigurationProperties(&#123;JdbcProperties.class&#125;)@Import(&#123;DatabaseInitializationDependencyConfigurer.class, JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class&#125;)public class JdbcTemplateAutoConfiguration &#123;    public JdbcTemplateAutoConfiguration() &#123;    &#125;&#125;\r\n\r\n核心作用：自动创建 JdbcTemplate\r\nBean，简化原生 JDBC 的繁琐操作（如手动获取连接、关闭资源）。\r\n\r\n它给容器中放入了JdbcTemplate组件，通过JdbcTemplateConfiguration.class引入，用于操作数据库\r\n@Configuration(    proxyBeanMethods = false)@ConditionalOnMissingBean(&#123;JdbcOperations.class&#125;)class JdbcTemplateConfiguration &#123;    JdbcTemplateConfiguration() &#123;    &#125;    @Bean    @Primary    JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) &#123;        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);        JdbcProperties.Template template = properties.getTemplate();        jdbcTemplate.setFetchSize(template.getFetchSize());        jdbcTemplate.setMaxRows(template.getMaxRows());        if (template.getQueryTimeout() != null) &#123;            jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds());        &#125;        return jdbcTemplate;    &#125;&#125;\r\n\r\n使用方式：直接 @Autowired 注入\r\nJdbcTemplate，即可执行 SQL\r\n\r\nDataSourceTransactionManagerAutoConfiguration\r\n全类名：org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration，这个是负责数据源事务管理器自动配置相关的\r\n\r\n核心作用：自动创建\r\nDataSourceTransactionManager（事务管理器），作为 Spring\r\n声明式事务的基础支撑，与 @Transactional\r\n注解协同，实现方法执行失败时的自动回滚等事务管理功能 ，为基于 JDBC\r\n操作的数据库事务提供统一的管理机制。\r\n使用场景：在 Service 层方法上添加\r\n@Transactional，即可让方法执行失败时自动回滚：\r\n自动配置条件：\r\n@AutoConfiguration(    before = &#123;TransactionAutoConfiguration.class&#125;,    after = &#123;DataSourceAutoConfiguration.class, TransactionManagerCustomizationAutoConfiguration.class&#125;)// 当类路径中存在 DataSource（数据源）、JdbcTemplate（JDBC 操作模板）、TransactionManager（事务管理器接口）时，该自动配置才会生效，确保相关基础类已引入 。@ConditionalOnClass(&#123;DataSource.class, JdbcTemplate.class, TransactionManager.class&#125;)@AutoConfigureOrder(Integer.MAX_VALUE)@EnableConfigurationProperties(&#123;DataSourceProperties.class&#125;)public class DataSourceTransactionManagerAutoConfiguration &#123;\r\n内部配置类\r\nJdbcTransactionManagerConfiguration：\r\n\r\n条件控制：当容器中存在单一的\r\nDataSource Bean 时才会生效\r\n创建事务管理器逻辑：\r\ntransactionManager 方法：创建\r\nDataSourceTransactionManager Bean，先调用\r\ncreateTransactionManager 方法构建基础事务管理器，再利用\r\nObjectProvider 对事务管理器进行自定义（若有自定义逻辑的话\r\n）。\r\ncreateTransactionManager 方法就是进行统一异常转换\r\nDataSourceTransactionManager（基础的数据源事务管理器实现\r\n），最终都是构建出适配数据源的事务管理对象，用于管理数据库操作的事务。\r\nstatic class JdbcTransactionManagerConfiguration &#123;        JdbcTransactionManagerConfiguration() &#123;        &#125;        @Bean        @ConditionalOnMissingBean(&#123;TransactionManager.class&#125;)        DataSourceTransactionManager transactionManager(Environment environment, DataSource dataSource, ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers) &#123;            DataSourceTransactionManager transactionManager = this.createTransactionManager(environment, dataSource);            transactionManagerCustomizers.ifAvailable((customizers) -&gt; &#123;                customizers.customize(transactionManager);            &#125;);            return transactionManager;        &#125;        private DataSourceTransactionManager createTransactionManager(Environment environment, DataSource dataSource) &#123;            return (DataSourceTransactionManager)((Boolean)environment.getProperty(&quot;spring.dao.exceptiontranslation.enabled&quot;, Boolean.class, Boolean.TRUE) ? new JdbcTransactionManager(dataSource) : new DataSourceTransactionManager(dataSource));        &#125;    &#125;\r\n\r\n\r\nXADataSourceAutoConfiguration（XA\r\n数据源自动配置）\r\n全类名：org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration，基于XA⼆阶提交协议的分布式事务数据源\r\n\r\n核心作用：支持\r\n分布式事务（跨多个数据库 / 数据源的事务），基于 XA\r\n协议（两阶段提交）保证多个数据源操作的原子性。\r\n典型场景：微服务中，一个业务操作需要同时更新\r\n订单库 和 库存库，用 XA\r\n事务保证两者要么都成功，要么都回滚。\r\n\r\nJndiDataSourceAutoConfiguration（JNDI\r\n数据源自动配置）\r\n全类名：org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration\r\n\r\n核心作用：从 JNDI（Java Naming and Directory\r\nInterface）获取数据源，适用于传统 Java EE 应用服务器（如\r\nTomcat、WebLogic）的场景。\r\n\r\n配置了MyBatis的整合流程——MyBatisAutoConfiguration\r\nmybatis-spring-boot-starter 会导入 mybatis\r\n的自动配置包mybatis-spring-boot-autoconfigure\r\n之后就会默认加载两个自动配置类\r\n\r\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration\r\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\r\n\r\n核心类：MyBatisAutoConfiguration\r\n解析\r\n全类名\r\norg.mybatis.spring.boot.autoconfigure.MyBatisAutoConfiguration\r\n核心作用\r\n\r\n自动整合 MyBatis 到 Spring Boot 体系，替代传统 XML\r\n配置（如\r\nmybatis-config.xml、SqlSessionFactoryBean\r\n配置）。\r\n自动创建\r\nSqlSessionFactory、SqlSessionTemplate\r\n等核心组件，让开发者直接注入 Mapper 接口即可使用。\r\n\r\n自动配置的触发条件\r\n\r\n首先会进行依赖的导入\r\n\r\n当项目引入mybatis-spring-boot-starter时，会间接引入：\r\n\r\nmybatis-spring-boot-autoconfigure：包含 MyBatis\r\n自动配置类（如 MyBatisAutoConfiguration）。\r\nmybatis-spring：实现 MyBatis 与 Spring 的整合（如\r\nSqlSessionFactoryBean）。\r\n\r\n\r\n自动配置通过如下条件注解决定是否生效\r\n@Configuration(    proxyBeanMethods = false)// 存在 MyBatis 核心类时生效@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)// 存在 DataSource Bean 时生效（依赖数据源）,所以存在数据源才生效@ConditionalOnSingleCandidate(DataSource.class)// 绑定 application.yml 配置@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)// 在数据源配置后执行@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)public class MybatisAutoConfiguration implements InitializingBean &#123;\r\n\r\n其中@ConditionalOnBean(DataSource.class)：依赖\r\nDataSourceAutoConfiguration\r\n已创建的数据源。所以必须先创建数据源，并且数据源配置好之后才会生效，这和\r\nHibertnate 会自动创建数据表有一定的差别\r\n@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)会放入\r\nMyBatis 和核心组件，session工厂相关的两个组件，分别是\r\n\r\n给容器中放 SqlSessionFactory\r\n组件。创建和数据库的⼀次会话\r\n给容器中 SqlSessionTemplate 组件。操作数据库\r\n\r\n\r\n\r\nMyBatis的所有配置绑定在\r\nMybatisProperties\r\n可以发现public class MybatisAutoConfiguration implements InitializingBean中存在\r\n@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)\r\n所以，MybatisAutoConfiguration自动配置需要启用MybatisProperties.class，也就是说MyBatis的所有配置绑定在\r\nMybatisProperties，我们来看看其中有什么内容\r\nMybatisProperties 是 Spring Boot 整合 MyBatis\r\n时的核心配置类，通过\r\n@ConfigurationProperties(prefix = \"mybatis\") 绑定\r\napplication.yml 中 mybatis 前缀的配置。\r\n@ConfigurationProperties(    prefix = &quot;mybatis&quot;)\r\n其中的一些基础配置项如表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应 application.yml 配置\r\n作用描述\r\n\r\n\r\n\r\n\r\nconfigLocation\r\nString\r\nmybatis.config-location\r\n指定 MyBatis 全局配置文件路径（如\r\nmybatis-config.xml），优先级高于\r\napplication.yml 配置\r\n\r\n\r\nmapperLocations\r\nString[]\r\nmybatis.mapper-locations\r\n扫描 Mapper XML 文件路径（如\r\nclasspath:mapper/*.xml），支持 Ant 风格路径\r\n\r\n\r\ntypeAliasesPackage\r\nString\r\nmybatis.type-aliases-package\r\n扫描实体类包，自动注册类名作为别名（如 User 替代\r\ncom.example.User）\r\n\r\n\r\ntypeAliasesSuperType\r\nClass&lt;?&gt;\r\nmybatis.type-aliases-super-type\r\n仅注册指定父类的子类作为类型别名，缩小扫描范围\r\n\r\n\r\ncheckConfigLocation\r\nboolean\r\nmybatis.check-config-location\r\n启动时检查配置文件是否存在，默认 false\r\n\r\n\r\n\r\n对应的代码如下\r\npublic String getConfigLocation() &#123;        return this.configLocation;    &#125;    public void setConfigLocation(String configLocation) &#123;        this.configLocation = configLocation;    &#125;    public String[] getMapperLocations() &#123;        return this.mapperLocations;    &#125;    public void setMapperLocations(String[] mapperLocations) &#123;        this.mapperLocations = mapperLocations;    &#125;    public String getTypeHandlersPackage() &#123;        return this.typeHandlersPackage;    &#125;    public void setTypeHandlersPackage(String typeHandlersPackage) &#123;        this.typeHandlersPackage = typeHandlersPackage;    &#125;    public String getTypeAliasesPackage() &#123;        return this.typeAliasesPackage;    &#125;    public void setTypeAliasesPackage(String typeAliasesPackage) &#123;        this.typeAliasesPackage = typeAliasesPackage;    &#125;    public Class&lt;?&gt; getTypeAliasesSuperType() &#123;        return this.typeAliasesSuperType;    &#125;    public void setTypeAliasesSuperType(Class&lt;?&gt; typeAliasesSuperType) &#123;        this.typeAliasesSuperType = typeAliasesSuperType;    &#125;\tpublic boolean isCheckConfigLocation() &#123;        return this.checkConfigLocation;    &#125;    public void setCheckConfigLocation(boolean checkConfigLocation) &#123;        this.checkConfigLocation = checkConfigLocation;    &#125;\t\r\n类型处理器与语言驱动配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应配置\r\n作用描述\r\n\r\n\r\n\r\n\r\ntypeHandlersPackage\r\nString\r\nmybatis.type-handlers-package\r\n扫描类型处理器（TypeHandler）包，自动注册自定义类型转换逻辑\r\n\r\n\r\ndefaultScriptingLanguageDriver\r\nClass&lt;? extends LanguageDriver&gt;\r\nmybatis.default-scripting-language-driver\r\n指定默认脚本语言驱动（如\r\norg.mybatis.scripting.xmltags.XMLLanguageDriver）\r\n\r\n\r\n\r\n源码如下\r\npublic String getTypeHandlersPackage() &#123;       return this.typeHandlersPackage;   &#125;   public void setTypeHandlersPackage(String typeHandlersPackage) &#123;       this.typeHandlersPackage = typeHandlersPackage;   &#125;public Class&lt;? extends LanguageDriver&gt; getDefaultScriptingLanguageDriver() &#123;       return this.defaultScriptingLanguageDriver;   &#125;   public void setDefaultScriptingLanguageDriver(Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver) &#123;       this.defaultScriptingLanguageDriver = defaultScriptingLanguageDriver;   &#125;\r\n执行器与事务配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应配置\r\n作用描述\r\n\r\n\r\n\r\n\r\nexecutorType\r\nExecutorType\r\nmybatis.executor-type\r\n设置执行器类型：SIMPLE（默认）、REUSE（重用连接）、BATCH（批量执行）\r\n\r\n\r\n\r\n而其中，核心配置项便是CoreConfiguration\r\n内部类CoreConfiguration 封装了 MyBatis\r\nConfiguration 类的核心配置，对应\r\nmybatis.configuration 前缀的配置，是 MyBatis\r\n行为的核心控制项。这个类其中有很多内容，只挑出重要的进行讲解\r\n映射与驼峰命名配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应配置\r\n作用描述\r\n\r\n\r\n\r\n\r\nmapUnderscoreToCamelCase\r\nBoolean\r\nmybatis.configuration.map-underscore-to-camel-case\r\n开启下划线转驼峰映射（如 user_name →\r\nuserName）\r\n\r\n\r\nautoMappingBehavior\r\nAutoMappingBehavior\r\nmybatis.configuration.auto-mapping-behavior\r\n自动映射行为：NONE/PARTIAL（默认）/FULL\r\n\r\n\r\nautoMappingUnknownColumnBehavior\r\nAutoMappingUnknownColumnBehavior\r\nmybatis.configuration.auto-mapping-unknown-column-behavior\r\n未知列映射策略：NONE（忽略）/WARNING（警告）/FAILING（报错）\r\n\r\n\r\n\r\n示例：\r\nmybatis:  configuration:    map-underscore-to-camel-case: true  # 开启驼峰映射    auto-mapping-behavior: FULL         # 全量自动映射\r\n2. 延迟加载与缓存配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应配置\r\n作用描述\r\n\r\n\r\n\r\n\r\nlazyLoadingEnabled\r\nBoolean\r\nmybatis.configuration.lazy-loading-enabled\r\n启用延迟加载（按需加载关联对象）\r\n\r\n\r\naggressiveLazyLoading\r\nBoolean\r\nmybatis.configuration.aggressive-lazy-loading\r\n激进延迟加载（加载一个属性时加载所有关联属性）\r\n\r\n\r\ncacheEnabled\r\nBoolean\r\nmybatis.configuration.cache-enabled\r\n启用二级缓存（基于命名空间的缓存）\r\n\r\n\r\nlocalCacheScope\r\nLocalCacheScope\r\nmybatis.configuration.local-cache-scope\r\n本地缓存作用域：SESSION（默认）/STATEMENT\r\n\r\n\r\n\r\n3. 执行与超时配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应配置\r\n作用描述\r\n\r\n\r\n\r\n\r\ndefaultStatementTimeout\r\nInteger\r\nmybatis.configuration.default-statement-timeout\r\nSQL 执行超时时间（秒）\r\n\r\n\r\ndefaultFetchSize\r\nInteger\r\nmybatis.configuration.default-fetch-size\r\n结果集批量获取行数（优化大数据查询）\r\n\r\n\r\nuseGeneratedKeys\r\nBoolean\r\nmybatis.configuration.use-generated-keys\r\n启用自增主键获取（如 MySQL 的 AUTO_INCREMENT）\r\n\r\n\r\n\r\n4. 日志与 VFS 配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n类型\r\n对应配置\r\n作用描述\r\n\r\n\r\n\r\n\r\nlogImpl\r\nClass&lt;? extends Log&gt;\r\nmybatis.configuration.log-impl\r\n指定日志实现（如\r\norg.apache.ibatis.logging.stdout.StdOutImpl）\r\n\r\n\r\nvfsImpl\r\nClass&lt;? extends VFS&gt;\r\nmybatis.configuration.vfs-impl\r\n\r\n\r\n\r\n\r\n其中，MybatisProperties 提供\r\nresolveMapperLocations() 方法解析\r\nmapperLocations 配置，支持 Ant 风格路径（如\r\nclasspath*:mapper/**/*.xml），内部通过\r\nPathMatchingResourcePatternResolver 实现资源扫描。\r\npublic Resource[] resolveMapperLocations() &#123;    return Stream.of(Optional.ofNullable(mapperLocations).orElse(new String[0]))                 .flatMap(location -&gt; Stream.of(getResources(location)))                 .toArray(Resource[]::new);&#125;\r\nconfigLocation 指定的 XML 配置 &gt;\r\napplication.yml 中 mybatis.configuration 配置\r\n&gt; MyBatis 默认值。\r\n自动配置流程：\r\n\r\nSpring Boot 启动时，MyBatisAutoConfiguration 读取\r\nMybatisProperties 配置。\r\n通过 CoreConfiguration.applyTo(Configuration)\r\n方法将配置应用到 MyBatis 的 Configuration 对象。\r\n\r\n通过 MybatisProperties，Spring Boot 实现了 MyBatis\r\n配置的全量绑定，开发者无需编写 XML 配置文件，仅通过\r\napplication.yml 即可完成 MyBatis 的所有核心配置，真正实现\r\n“约定优于配置” 的开发体验。\r\n每个Mapper接⼝的代理对象是怎么创建放到容器中——@MapperScan原理\r\nMyBatis 中 Mapper\r\n是接口，本身无法直接创建对象。@MapperScan\r\n的作用是： 通过 动态代理 + Spring Bean 注册，让每个\r\nMapper 接口生成代理对象（能执行 SQL），并注入到 Spring\r\n容器，最终实现 @Autowired UserMapper userMapper\r\n直接用。\r\nsequenceDiagram\n    participant 启动类 as Spring Boot 启动类（@MapperScan）\n    participant ImportRegistrar as MapperScannerRegistrar（@Import 引入）\n    participant ScannerConfigurer as MapperScannerConfigurer（注册 BeanDefinition）\n    participant ClassPathMapperScanner as ClassPathMapperScanner（扫描 Mapper）\n    participant MapperFactoryBean as MapperFactoryBean（创建代理对象）\n    \n    启动类-&gt;&gt;ImportRegistrar: 加载 @MapperScan，触发 Import\n    ImportRegistrar-&gt;&gt;ScannerConfigurer: 注册 MapperScannerConfigurer 的 BeanDefinition\n    ScannerConfigurer-&gt;&gt;ClassPathMapperScanner: 扫描指定包（如 com.example.mapper）\n    ClassPathMapperScanner-&gt;&gt;MapperFactoryBean: 为每个 Mapper 接口创建 BeanDefinition\n    MapperFactoryBean-&gt;&gt;Spring容器: 生成 Mapper 代理对象，注册到容器\r\nMapperScan 接口的源码就是这样\r\n@MapperScan\r\n注解的触发入口如下，其中@Import(MapperScannerRegistrar.class)\r\n引入逻辑处理类，替代手动配置\r\nMapperScannerConfigurer是核心。\r\n@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;MapperScannerRegistrar.class&#125;)@Repeatable(MapperScans.class)public @interface MapperScan &#123;    @AliasFor(&quot;basePackages&quot;)    String[] value() default &#123;&#125;;   // 要扫描的 Mapper 包路径    @AliasFor(&quot;value&quot;)    String[] basePackages() default &#123;&#125;;\r\n而解析 @MapperScan\r\n配置的类就是MapperScannerRegistrar，它的作用就是实现\r\nImportBeanDefinitionRegistrar 接口，动态注册\r\nMapperScannerConfigurer 到 Spring 容器。\r\n也就是将 @MapperScan 的配置（如扫描包路径）传递给\r\nMapperScannerConfigurer，将 @MapperScan\r\n注解的配置转换为 Spring 容器中的 Mapper Bean。\r\nMapperScannerRegistrar源码如下\r\n// ImportBeanDefinitionRegistrar：允许在 Spring 启动时动态注册 BeanDefinition（如 Mapper 接口的代理对象）public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123;    // 注入 Spring 的 ResourceLoader，用于加载类路径资源    private ResourceLoader resourceLoader;    public MapperScannerRegistrar() &#123;    &#125;    public void setResourceLoader(ResourceLoader resourceLoader) &#123;        this.resourceLoader = resourceLoader;    &#125;   public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;    // 1. 从启动类上获取 @MapperScan 注解的属性    AnnotationAttributes mapperScanAttrs = AnnotationAttributes.fromMap(        importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));        if (mapperScanAttrs != null) &#123;        // 2. 注册 MapperScannerConfigurer 的 BeanDefinition        this.registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,                                     generateBaseBeanName(importingClassMetadata, 0));    &#125;&#125;\r\n其中，上述registerBeanDefinitions方法，做到了解析\r\n@MapperScan 注解（如\r\n@MapperScan(basePackages = \"com.example.mapper\")），并将配置传递给\r\nMapperScannerConfigurer。\r\n配置 MapperScannerConfigurer 的\r\nBeanDefinition的源码如下\r\nvoid registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs,                             BeanDefinitionRegistry registry, String beanName) &#123;    // 1. 创建 MapperScannerConfigurer 的 BeanDefinition    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);        // 2. 设置属性：处理占位符    builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, annoAttrs.getBoolean(&quot;processPropertyPlaceHolders&quot;));        // 3. 设置注解过滤：仅扫描带特定注解的接口    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);    if (!Annotation.class.equals(annotationClass)) &#123;        builder.addPropertyValue(&quot;annotationClass&quot;, annotationClass);    &#125;        // 4. 设置标记接口：仅扫描实现特定接口的 Mapper    Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);    if (!Class.class.equals(markerInterface)) &#123;        builder.addPropertyValue(&quot;markerInterface&quot;, markerInterface);    &#125;        // 5. 设置 Bean 命名生成器    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;        builder.addPropertyValue(&quot;nameGenerator&quot;, BeanUtils.instantiateClass(generatorClass));    &#125;        // 6. 设置 Mapper 工厂类（默认为 MapperFactoryBean）    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;        builder.addPropertyValue(&quot;mapperFactoryBeanClass&quot;, mapperFactoryBeanClass);    &#125;        // 7. 设置 SqlSessionTemplate 或 SqlSessionFactory 的引用    String sqlSessionTemplateRef = annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;);    if (StringUtils.hasText(sqlSessionTemplateRef)) &#123;        builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, sqlSessionTemplateRef);    &#125;        String sqlSessionFactoryRef = annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;);    if (StringUtils.hasText(sqlSessionFactoryRef)) &#123;        builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, sqlSessionFactoryRef);    &#125;        // 8. 计算扫描包路径（basePackages 或 basePackageClasses）    List&lt;String&gt; basePackages = new ArrayList&lt;&gt;();    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;))                             .filter(StringUtils::hasText)                             .collect(Collectors.toList()));        basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;))                             .map(ClassUtils::getPackageName)                             .collect(Collectors.toList()));        // 如果未指定包路径，默认使用启动类所在的包    if (basePackages.isEmpty()) &#123;        basePackages.add(getDefaultBasePackage(annoMeta));    &#125;        // 9. 设置排除过滤器（excludeFilters）    AnnotationAttributes[] excludeFilterArray = annoAttrs.getAnnotationArray(&quot;excludeFilters&quot;);    if (excludeFilterArray.length &gt; 0) &#123;        // 处理正则、AspectJ 等特殊过滤器        List&lt;TypeFilter&gt; typeFilters = new ArrayList&lt;&gt;();        List&lt;Map&lt;String, String&gt;&gt; rawTypeFilters = new ArrayList&lt;&gt;();                // 解析过滤器配置...        builder.addPropertyValue(&quot;excludeFilters&quot;, typeFilters);        builder.addPropertyValue(&quot;rawExcludeFilters&quot;, rawTypeFilters);    &#125;        // 10. 设置懒加载和作用域    String lazyInitialization = annoAttrs.getString(&quot;lazyInitialization&quot;);    if (StringUtils.hasText(lazyInitialization)) &#123;        builder.addPropertyValue(&quot;lazyInitialization&quot;, lazyInitialization);    &#125;        String defaultScope = annoAttrs.getString(&quot;defaultScope&quot;);    if (!&quot;&quot;.equals(defaultScope)) &#123;        builder.addPropertyValue(&quot;defaultScope&quot;, defaultScope);    &#125;        // 11. 最终设置扫描包路径并注册 BeanDefinition    builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));    builder.setRole(2);  // ROLE_SUPPORT：辅助角色的 Bean    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());&#125;\r\n上述源码的核心功能就是将 @MapperScan 的各种配置（如\r\nbasePackages、annotationClass、excludeFilters）转换为\r\nMapperScannerConfigurer 的属性，最终实现注册到\r\nSpring 容器。\r\n下面的就是一些过滤器和重复注解处理，就不看了\r\n总之，MapperScannerRegistrar 的核心流程就是\r\n\r\n解析注解：从 @MapperScan\r\n获取配置（如扫描包路径、过滤器）。\r\n创建配置器：创建\r\nMapperScannerConfigurer 的\r\nBeanDefinition，并设置属性。\r\n注册配置器：将 MapperScannerConfigurer\r\n注册到 Spring 容器。\r\n延迟扫描：MapperScannerConfigurer 在\r\nSpring 容器启动后，才会真正扫描 Mapper 接口并生成代理对象。\r\n\r\n也即是说，MapperScan接口使用了@Import(&#123;MapperScannerRegistrar.class&#125;)导入了Mapper注册成了bean对象，其中，也做到了批量给容器中注册组件。解析指定的包路径里面的每⼀个类，为每⼀个Mapper接口类，创建Bean定义信息，注册到容器中。\r\n还有一个类能扫描 Mapper\r\n接口MapperScannerConfigurer，实现\r\nBeanDefinitionRegistryPostProcessor 接口，在 Spring\r\n启动早期扫描 Mapper 接口\r\n其中比较核心的代码如下\r\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;        if (this.processPropertyPlaceHolders) &#123;            this.processPropertyPlaceHolders();        &#125;\t\t// 1. 创建 ClassPathMapperScanner，设置扫描规则        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry, this.getEnvironment());    \t// 扫描上述`MybatisProperties`中的各种核心配置        scanner.setAddToConfig(this.addToConfig);        scanner.setAnnotationClass(this.annotationClass);        scanner.setMarkerInterface(this.markerInterface);        scanner.setExcludeFilters(this.excludeFilters = this.mergeExcludeFilters());        scanner.setSqlSessionFactory(this.sqlSessionFactory);        scanner.setSqlSessionTemplate(this.sqlSessionTemplate);        scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);        scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);        scanner.setResourceLoader(this.applicationContext);        scanner.setBeanNameGenerator(this.nameGenerator);        scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);        if (StringUtils.hasText(this.lazyInitialization)) &#123;            scanner.setLazyInitialization(Boolean.parseBoolean(this.lazyInitialization));        &#125;        if (StringUtils.hasText(this.defaultScope)) &#123;            scanner.setDefaultScope(this.defaultScope);        &#125;        scanner.registerFilters();    \t // 2. 扫描指定包下的 @Mapper 接口        scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, &quot;,; \\t\\n&quot;));    &#125;\r\n其中，ClassPathMapperScanner 是 MyBatis\r\n扩展的扫描器，专门处理 Mapper 接口。\r\n而ClassPathMapperScanner就是生成 Mapper 的\r\nBeanDefinition，它继承\r\nClassPathBeanDefinitionScanner，重写\r\ndoScan 方法，为每个 Mapper 接口创建\r\nBeanDefinition：\r\npublic class ClassPathMapperScanner extends ClassPathBeanDefinitionScanner &#123;    public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;        // 1. 扫描 basePackages 下的所有接口（@Mapper 或指定标记接口）        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);        if (beanDefinitions.isEmpty()) &#123;            if (this.printWarnLogIfNotFoundMappers) &#123;                LOGGER.warn(() -&gt; &#123;                    return &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;;                &#125;);            &#125;        &#125; else &#123;            this.processBeanDefinitions(beanDefinitions);        &#125;        return beanDefinitions;    &#125;&#125;\r\n之后MapperFactoryBean的作用就是创建 Mapper\r\n代理对象，继承 FactoryBean，动态生成 Mapper\r\n接口的代理对象：\r\npublic class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123;    private Class&lt;T&gt; mapperInterface;    \tpublic T getObject() throws Exception &#123;        // 从 SqlSession 获取 Mapper 代理对象（MyBatis 核心逻辑）        return this.getSqlSession().getMapper(this.mapperInterface);    &#125;    public Class&lt;T&gt; getObjectType() &#123;        return this.mapperInterface;    &#125;\r\nsqlSession.getMapper(mapperInterface) 会通过 JDK\r\n动态代理，为 Mapper 接口生成代理对象，代理对象内部通过\r\nSqlSession 执行 SQL。\r\n所以说从 @MapperScan 到 Mapper\r\n可用的完整流程总结如下：\r\n\r\n启动触发：@MapperScan 通过\r\n@Import 引入 MapperScannerRegistrar。\r\n注册配置类：MapperScannerRegistrar 向\r\nSpring 容器注册 MapperScannerConfigurer。\r\n扫描 Mapper：MapperScannerConfigurer\r\n启动扫描，找到所有 Mapper 接口。\r\n替换 BeanClass：将 Mapper 接口的\r\nBeanClass 替换为 MapperFactoryBean。\r\n生成代理对象：MapperFactoryBean 利用\r\nMyBatis 的 SqlSession，为 Mapper\r\n接口生成动态代理对象，并注册到 Spring 容器。\r\n\r\n最终，你可以通过 @Autowired UserMapper userMapper\r\n直接注入 Mapper 代理对象，执行 SQL 时由代理对象转发给 MyBatis 执行。\r\n如何找自动配置类\r\n如何分析哪个场景导⼊以后，开启了哪些自动配置类。\r\n找：\r\nclasspath:/META-INF/spring/org.springframework.boot.autoconfigure. AutoConfiguration.imports\r\n文件中配置的所有值，就是要开启的⾃动配置类，但是每个\r\n类可能有条件注解，基于条件注解判断哪个⾃动配置类⽣效了\r\n快速定位⽣效的配置可以开启如下\r\n#开启调试模式，详细打印开启了哪些⾃动配置debug=true # Positive（⽣效的⾃动配置）  Negative（不⽣效的⾃动配置）\r\n整合其他数据源\r\nDruid 数据源\r\n\r\n暂不⽀持 SpringBoot3\r\n\r\n导入 druid-starter\r\n写配置\r\n分析自动配置了哪些东⻄，怎么用\r\n\r\n\r\n#数据源基本配置 spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demo spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.username=root spring.datasource.password=123456 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource # 配置StatFilter监控 spring.datasource.druid.filter.stat.enabled=true spring.datasource.druid.filter.stat.db-type=mysql spring.datasource.druid.filter.stat.log-slow-sql=true spring.datasource.druid.filter.stat.slow-sql-millis=2000 # 配置WallFilter防⽕墙 spring.datasource.druid.filter.wall.enabled=true spring.datasource.druid.filter.wall.db-type=mysql spring.datasource.druid.filter.wall.config.delete-allow=false spring.datasource.druid.filter.wall.config.drop-table-allow=false # 配置监控⻚，内置监控⻚⾯的⾸⻚是/druid/index.html spring.datasource.druid.stat-view-servlet.enabled=true spring.datasource.druid.stat-view-servlet.login-username=admin spring.datasource.druid.stat-view-servlet.login-password=admin spring.datasource.druid.stat-view-servlet.allow=* # 其他Filter 配置不再演示 # ⽬前为以下Filter 提供了配置⽀持，请参考⽂档或者根据IDE提示（spring.datasource.druid.filter.*）进⾏配置。# StatFilter # WallFilter # ConfigFilter # EncodingConvertFilter # Slf4jLogFilter # Log4jFilter # Log4j2Filter # CommonsLogFilter\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","配置相关"]},{"title":"Spring Boot part16-Profile环境隔离","url":"/posts/28584.html","content":"什么是Profiles\r\n介绍\r\n随着软件开发变得越来越复杂，应用程序往往需要在不同的环境中运行，比如开发、测试、生产等。每个环境可能对配置有不同的需求。手动管理这些差异化的配置不仅容易出错，而且效率低下。为了解决这个问题，Spring框架引入了Profiles的概念，它允许开发者根据不同的环境来激活特定的配置设置。\r\nSpring Profiles\r\n是Spring框架提供的一种机制，用来解决多环境配置问题。通过定义不同的profiles，可以在同一套代码库中针对不同的运行时环境（如开发、测试、生产）指定不同的配置属性，这样就提供了一种方式允许我们指定在特定环境下只加载对应的程序配置，每一种环境配置对应一个\r\nProfile，只有当前 Profile 处于激活状态时，才会将该 Profile\r\n所对应的配置和 Bean 加载到 Spring\r\n程序中。这样做的好处是能够保持代码的一致性，同时又能灵活地适应各种环境的变化。\r\n\r\nSpring Profiles\r\n就是针对应用程序，不同环境需要不同配置加载的一种解决方案。\r\n\r\nProfile 的概念其实很早在 Spring Framework 就有了，在 Spring Framework\r\n3.1 版本引入了注解 @Profile 和 Environment\r\n环境配置的抽象，只是在 Spring Boot 框架里再进一步将 Profiles\r\n功能进行扩展，使它也成为了 Spring Boot 特性之一，为此单独在 官方文档\r\n25. Profiles 一节里介绍，文档里把 Spring Boot Profiles 也叫做 Spring\r\nProfiles。\r\n当然 Spring 允许多个 Profile\r\n处于激活状态，在需要激活环境对应配置时，指定多个 Profile。\r\n在实际开发中，Profile 可以用来实现以下几种功能：\r\n\r\n区分不同的环境，例如开发环境、测试环境和生产环境。\r\n配置不同的数据库连接信息\r\n配置不同的日志级别\r\n\r\n使用 Profiles\r\n如何使用\r\n在 Spring Boot 中，Profile\r\n是通过配置文件来实现的。在不同的环境下，可以加载不同的配置文件，从而实现不同的配置逻辑。具体来说，Spring\r\nBoot 支持以下几种配置文件：\r\napplication.properties\r\napplication.yml\r\napplication-&#123;profile&#125;.properties\r\napplication-&#123;profile&#125;.yml\r\n其中，application.properties 和\r\napplication.yml\r\n是通用的配置文件，它们在所有的环境下都会被加载。而\r\napplication-&#123;profile&#125;.properties 和\r\napplication-&#123;profile&#125;.yml 则是根据不同的 Profile\r\n来加载的配置文件。当应用程序启动时，Spring Boot\r\n会根据当前的环境变量来决定加载哪个配置文件。例如，如果当前环境变量为\r\ndev，则会加载 application-dev.properties 或\r\napplication-dev.yml 文件。\r\n我们使用 Profiles 的步骤一般如下：\r\n\r\n标识环境：指定哪些组件、配置在哪个环境⽣效\r\n切换环境：这个环境对应的所有组件和配置就应该⽣效\r\n\r\n在 Spring 中，Profiles 用于实现\r\n“环境隔离”（比如区分开发、测试、生产环境的配置），核心有两种使用方式：XML\r\n配置 和 @Profile 注解。\r\n\r\nXML 就不细说了，在 XML 配置文件中，通过\r\n&lt;beans profile=\"环境标识\"&gt; 来隔离不同环境的 Bean\r\n定义，注意必须使用 Spring XML Beans Schema 4.0+（对应\r\nSpring 3.1+ 版本），否则 &lt;beans profile&gt; 会报错。\r\n&lt;!-- 开发环境 Bean --&gt;&lt;beans profile=&quot;dev&quot;&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://dev.db:3306/test&quot; /&gt;        &lt;!-- 其他开发环境配置 --&gt;    &lt;/bean&gt;&lt;/beans&gt;&lt;!-- 生产环境 Bean --&gt;&lt;beans profile=&quot;prod&quot;&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://prod.db:3306/test&quot; /&gt;        &lt;!-- 其他生产环境配置 --&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n此时激活有两种方式\r\n\r\n通过 spring.profiles.active 指定环境\r\n// 代码方式激活new AnnotationConfigApplicationContext()    .getEnvironment()    .setActiveProfiles(&quot;dev&quot;);\r\n或通过 JVM 参数：\r\n-Dspring.profiles.active=prod\r\n\r\n@Profile 是更灵活的 注解式\r\n环境隔离方案，支持标注在 类 或 方法\r\n上，任何@Component，@Configuration或者@ConfigurationProperties，决定\r\nBean 是否在特定环境下生效。容器中的组件都可以被 @Profile\r\n标记\r\n\r\n标注在 @Configuration 类上\r\n示例，区分开发和生产环境的配置类\r\n// 开发环境配置类（可以写多个，当 dev 和 test 环境激活时生效）@Configuration@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)public class DevConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new DruidDataSource() &#123;&#123;            setUrl(&quot;jdbc:mysql://dev.db:3306/test&quot;);        &#125;&#125;;    &#125;&#125;// 生产环境配置类（仅当 prod 环境激活时生效）@Configuration@Profile(&quot;prod&quot;)public class ProdConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new DruidDataSource() &#123;&#123;            setUrl(&quot;jdbc:mysql://prod.db:3306/test&quot;);        &#125;&#125;;    &#125;&#125;\r\n如果标注@Profile(\"default\")，是默认\r\nprofile，指定在默认环境下生效\r\n如果组件没有标注@Profile注解，代表任意时刻都生效\r\n标注在 @Bean 方法上\r\n示例：同一个配置类中，不同环境返回不同 Bean\r\n@Configurationpublic class DataSourceConfig &#123;    // 开发环境 DataSource    @Bean    @Profile(&quot;dev&quot;)    public DataSource devDataSource() &#123;        return new DruidDataSource() &#123;&#123;            setUrl(&quot;jdbc:mysql://dev.db:3306/test&quot;);        &#125;&#125;;    &#125;    // 生产环境 DataSource    @Bean    @Profile(&quot;prod&quot;)    public DataSource prodDataSource() &#123;        return new DruidDataSource() &#123;&#123;            setUrl(&quot;jdbc:mysql://prod.db:3306/test&quot;);        &#125;&#125;;    &#125;&#125;\r\n组合条件：@Profile(\"!prod\")（非生产环境生效）\r\n示例：测试、开发环境共用一套配置\r\n@Bean@Profile(&quot;!prod&quot;) // 非 prod 环境（如 dev、test）生效public DataSource nonProdDataSource() &#123;    return new DruidDataSource() &#123;&#123;        setUrl(&quot;jdbc:mysql://test.db:3306/test&quot;);    &#125;&#125;;&#125;\r\n与application配置文件配合使用\r\n在 Spring Boot 中，通常会结合 application.yml 配置\r\nProfiles\r\napplication-&#123;profile&#125;.properties\r\n可以作为指定环境的配置⽂件，示例：\r\n# 通用配置spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver# 开发环境配置（application-dev.yml）spring:  profiles: dev  datasource:    url: jdbc:mysql://dev.db:3306/test    username: dev_user    password: dev_pass# 生产环境配置（application-prod.yml）spring:  profiles: prod  datasource:    url: jdbc:mysql://prod.db:3306/test    username: prod_user    password: prod_pass\r\n激活这个环境，配置就会⽣效。最终⽣效的所有配置是\r\n\r\napplication.properties\r\n：主配置⽂件，任意时候都⽣效\r\napplication-&#123;profile&#125;.properties\r\n：指定环境配置⽂件，激活指定环境⽣效，带profile的配置文件的优先级\r\n大于 不带的application\r\n\r\n\r\n\r\n激活对应的 Profiles\r\nSpring Profiles\r\n的激活是实现环境隔离的关键环节，以下是各种激活方式的原理与实践\r\n在配置文件中指定（推荐方式）\r\n在 application.yml 中指定：\r\nspring:  profiles:    active: prod  # 激活生产环境配置\r\nspring.profiles.active=prod\r\n场景：\r\n\r\n项目默认环境（如测试环境）可直接写入\r\napplication.yml。\r\n配合 application-&#123;profile&#125;.yml 实现环境隔离：\r\n\r\n其中，可以实现指定多个环境\r\nspring.profiles.active=dev,test\r\n配置默认环境\r\nspring.profiles.default=test\r\n注意：\r\n\r\n未标注 @Profile 的组件始终生效，不受默认环境影响。\r\n若同时存在 spring.profiles.active 和\r\ndefault，active 优先级更高。\r\n\r\n命令行参数激活（动态覆盖）\r\n语法：\r\n# 单环境激活java -jar app.jar --spring.profiles.active=prod# 多环境激活（用逗号分隔）java -jar app.jar --spring.profiles.active=dev,test\r\n场景：\r\n\r\n生产部署时临时切换环境（如从测试环境切到预发环境）。\r\n容器化部署时通过环境变量传递：\r\n\r\n编程式动态激活（API 方式）\r\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.env.EnvironmentPostProcessor;import org.springframework.core.env.ConfigurableEnvironment;public class DynamicProfileApplication &#123;    public static void main(String[] args) &#123;        SpringApplication app = new SpringApplication(MainConfig.class);                // 方式1：直接设置激活的Profiles（覆盖其他配置）        app.setAdditionalProfiles(&quot;dev&quot;, &quot;local&quot;);                // 方式2：通过EnvironmentPostProcessor扩展（更灵活）        app.addEnvironmentPostProcessor(new EnvironmentPostProcessor() &#123;            @Override            public void postProcessEnvironment(ConfigurableEnvironment env, SpringApplication app) &#123;                // 根据系统属性动态决定激活的环境                String envType = System.getProperty(&quot;app.env&quot;, &quot;dev&quot;);                env.addActiveProfile(envType);            &#125;        &#125;);                app.run(args);    &#125;&#125;\r\n或者在启动类中也可以指定\r\npublic static void main(String[] args) &#123;    SpringApplication app = new SpringApplication(MyApp.class);    // 动态设置激活的环境    app.setAdditionalProfiles(&quot;dev&quot;, &quot;test&quot;);     app.run(args);&#125;\r\n场景：\r\n\r\n框架 / 中间件需要根据运行时条件动态选择环境（如根据服务器 IP\r\n判断生产 / 测试环境）。\r\n单元测试中临时切换\r\nProfile（配合@ActiveProfiles注解）。\r\n\r\n激活方式的优先级（从高到低）\r\n\r\n命令行参数：--spring.profiles.active=prod（最高优先级，可覆盖一切）\r\n编程式激活：app.setAdditionalProfiles(...)（次高优先级）\r\n系统属性：-Dspring.profiles.active=prod\r\n环境变量：SPRING_PROFILES_ACTIVE=prod\r\napplication.yml 中的\r\nspring.profiles.active（默认配置）\r\nspring.profiles.default（最低优先级，仅当无\r\nactive 时生效）\r\n\r\n配置文件加载顺序\r\nSpring Boot 按以下顺序加载配置，后加载的会覆盖先加载的：\r\n\r\n当前目录下的 application.yml\r\n类路径下的 application.yml\r\n当前目录下的\r\napplication-&#123;profile&#125;.yml\r\n类路径下的\r\napplication-&#123;profile&#125;.yml\r\n\r\n环境包含问题：\r\n\r\nspring.profiles.active 和\r\nspring.profiles.default 这两条配置项目只能⽤到 ⽆ profile\r\n的⽂件中，如果在 application-&#123;profiles&#125;.yaml这种带 profiles\r\n的配置文件中编写就是⽆效的\r\n也可以额外添加⽣效⽂件，⽽不是激活替换。⽐如：\r\nspring.profiles.include[0]=commonspring.profiles.include[1]=local\r\nspring:  profiles:    active: prod    include:      - common  # 叠加common配置      - logging  # 叠加logging配置\r\n效果：\r\n\r\n除了 prod 环境的配置，还会加载\r\napplication-common.yml 和\r\napplication-logging.yml。\r\n适用于公共配置与环境配置分离的场景（如公共日志配置、公共服务配置）。\r\n\r\n\r\nProfile 分组问题：\r\n在实际开发中，一个应用可能涉及多个维度的配置切换（如环境、功能模块），此时\r\nProfile 分组 能更高效地管理复杂配置。Profile\r\n分组允许将多个 Profile 归为一组，通过激活组名来批量启用相关配置\r\nProfile 分组本质是将多个 Profile 逻辑聚合，实现\r\n“一键激活多个关联配置”。\r\n# 开发环境分组配置spring:  profiles: dev  profiles:    include:      - base  # 继承基础配置      - redis # 启用 Redis 配置      - dev-logging # 开发环境专属日志配置\r\n# 激活开发环境分组配置java -jar app.jar --spring.profiles.active=dev\r\n激活 dev 时，自动启用\r\nbase、redis、dev-logging 三个\r\nProfile 的配置。\r\nProfile 分组支持嵌套，即一个分组可包含另一个分组\r\n优先级规则\r\n\r\n同层级 Profile：后加载的覆盖先加载的（如 dev 覆盖\r\nbase 中的重复配置）。\r\n嵌套\r\nProfile：子分组的配置会合并到父分组中，若冲突，以最内层为准。\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","配置文件"]},{"title":"Spring Boot part17-外部化配置","url":"/posts/20474.html","content":"外部化配置\r\n什么是外部化配置\r\n在软件开发中，外部化配置指的是将应用程序的配置信息（如环境参数、连接地址、业务开关等）与代码逻辑分离，存储在外部资源中（如配置文件、环境变量、数据库等）。Spring\r\nBoot\r\n的外部化配置机制并非凭空产生，而是源于软件开发中一系列实际需求的驱动\r\nSpring Boot 外部化配置 (Externalized Configuration)\r\n提供了一套强大的机制，允许我们将应用的配置\r\n从代码中解耦出来，并通过多种外部来源进行灵活管理，从而打造出\r\n可移植、可扩展、易于维护 的 Spring Boot 应用。\r\nSpringBoot支持多种外部化配置，以便于开发者能够在不同的环境下，使用同一套应用程序代码。外部化配置的方式有多种：properties文件，yaml文件，Environment变量已经命令行参数等等。\r\n为什么需要外部化配置\r\n\r\n硬编码的痛点：若将配置直接写入代码（如数据库连接字符串、端口号），当环境变更时（如从测试环境部署到生产环境），必须修改代码并重新编译，这不仅增加了部署风险，还违背了\r\n“开闭原则”。\r\n外部化配置的优势：将配置移至外部文件（如application.yml），代码只需通过变量引用配置，环境变更时仅需修改配置文件，无需修改代码。而且外部化配置使得应用的配置管理更加清晰、结构化，易于扩展和维护，适应应用规模的增长。\r\n环境多样性需求：开发、测试、预发、生产环境的基础设施（如服务器地址、缓存配置）往往不同，外部化配置可通过\r\nProfile\r\n机制（如application-dev.yml、application-prod.yml）为不同环境定制专属配置，通过命令行参数--spring.profiles.active=prod即可指定启动环境，无需修改代码或打包不同版本。\r\n安全性提升 (Security Enhancement):\r\n可以将敏感信息存储在更安全的地方\r\n(例如环境变量、外部配置中心)，避免硬编码在代码中。\r\n\r\n多种配置同时出现的生效顺序\r\nSpring Boot\r\n按以下顺序加载配置源，后加载的会覆盖先加载的配置：\r\n配置源优先级列表（由高到低）\r\n\r\nDevTools\r\n全局属性:devtool处于active状态时，$HOME/.config/spring-boot目录中的Devtool全局配置。\r\n@TestPropertySource\r\n注解：测试类中指定的属性源。\r\n@TestPropertySource(&quot;classpath:test.properties&quot;)class MyServiceTest &#123; ... &#125;\r\n测试属性：@SpringBootTest\r\n测试时通过 properties 参数指定。\r\n@SpringBootTest(properties = &#123;&quot;server.port=9090&quot;&#125;)class MyAppTest &#123; ... &#125;\r\n命令行参数：通过 --key=value\r\n传递，如 --server.port=8080。\r\nSPRING_APPLICATION_JSON：内置在环境变量或系统属性中的\r\nJSON 配置。\r\nexport SPRING_APPLICATION_JSON=&#x27;&#123;&quot;server.port&quot;: 8081, &quot;app.name&quot;: &quot;json-app&quot;&#125;&#x27;\r\nServletConfig 初始化参数：Servlet 的\r\n&lt;init-param&gt;配置。\r\nServletContext 初始化参数：在\r\nweb.xml 中配置的\r\n&lt;context-param&gt;。\r\nJNDI 属性：来自 java:comp/env\r\n上下文，传统 Java EE 环境使用。\r\nJava 系统属性：通过\r\nSystem.getProperty() 获取，如\r\n-Dapp.env=prod。\r\njava -jar app.jar -Dapp.env=prod\r\nOS 环境变量：通过 System.getenv()\r\n获取，如 DATABASE_URL。\r\nexport DATABASE_URL=jdbc:mysql://prod.db:3306/app\r\n随机值配置：random.* 配置（如\r\nrandom.int、random.uuid）。\r\napp.secret=$&#123;random.uuid&#125;app.port=$&#123;random.int[10000,20000]&#125;\r\n配置文件：application.properties/.yml\r\n及其 Profile 变体（如 application-dev.properties）。\r\n\r\n配置文件内的加载顺序如下\r\n\r\n首先，同路径下 .properties 优先于 .yml（如\r\napplication.properties 覆盖\r\napplication.yml）。\r\n环境专属配置application-&#123;profile&#125;.properties高于默认配置application.properties\r\n应用程序以外的application-&#123;profile&#125;.properties或者application.properties文件高于打包在应用程序内的application-&#123;profile&#125;.properties或者application.properties，也就是\r\njar 包外的高于 jar包内的，这就是外部化配置生效的重要原因\r\n类路径(内部)中的配置文件， 类下/config包 高于\r\n类根路径\r\n当前路径（项⽬所在的位置），/config⽬录的直接⼦⽬录\r\n高于 当前下 /config⼦⽬录 高于 当前路径\r\n\r\n\r\n@PropertySource 注解：标注在\r\n@Configuration 类上，加载指定配置文件。\r\n@Configuration@PropertySource(&quot;classpath:custom.properties&quot;)public class AppConfig &#123; ... &#125;\r\n默认属性：通过\r\nSpringApplication.setDefaultProperties(Map)\r\n定义的默认值。\r\nSpringApplication app = new SpringApplication(MyApp.class);app.setDefaultProperties(Collections.singletonMap(&quot;app.name&quot;, &quot;default-app&quot;));\r\n\r\n这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性。\r\n所有参数均可由命令⾏传⼊，使⽤ --参数项 = 参数值\r\n，将会被添加到环境变量中，并优先于配置⽂件 。\r\n\r\n结论：配置可以写到很多位置，常⻅的优先级顺序：\r\n\r\n命令⾏ &gt; 配置⽂件 &gt; spring application 配置\r\n\r\n建议：⽤⼀种格式的配置⽂件。 .properties 和 结 .yml 同时存在 , 则\r\n.properties 优先\r\n\r\n包外 &gt; 包内 ； 同级情况： profile 配置 &gt; application 配置\r\nproperties配置 &gt; yaml配置\r\n命令⾏ &gt; 包外config直接⼦⽬录 &gt; 包外config⽬录 &gt; 包外根⽬录\r\n&gt; 包内⽬录\r\n\r\n\r\n配置文件的加载位置按优先级从高到低排列：\r\n\r\n命令行参数（最高优先级，可覆盖一切）。\r\n当前目录的 /config 子目录（如\r\n./config/application.yml）。\r\n当前目录（如\r\n./application.yml）。\r\n类路径的 /config 包（如\r\nclasspath:/config/application.yml）。\r\n类路径根目录（如\r\nclasspath:/application.yml）。\r\n\r\n\r\n\r\nimage-20250620203750693\r\n\r\n规律：最外层的最优先。\r\n\r\n命令⾏ &gt; 所有\r\n包外 &gt; 包内\r\nconfig⽬录 &gt; 根⽬录\r\nprofile &gt; application\r\n\r\n配置不同就都⽣效（互补），配置相同⾼优先级覆盖低优先级\r\n各种外部化配置\r\n导入配置\r\n使⽤spring.config.import可以导⼊额外配置\r\n让你能在 Spring Boot 主配置文件（比如\r\napplication.properties 或\r\napplication.yml）里，引入外部的配置文件或配置片段\r\n，灵活扩展配置来源。\r\n# 1. 导入外部配置文件spring.config.import=my.properties  # 2. 主配置文件里的属性my.property=value  \r\nspring.config.import=my.properties：\r\n告诉 Spring Boot，加载当前配置文件时，额外导入\r\nmy.properties 文件的配置\r\n（my.properties 需和主配置文件在类路径或可识别路径下 ）\r\n优先级说明： 无论 spring.config.import\r\n和 my.property=value\r\n谁写在前，my.properties 里的\r\nmy.property 值，会覆盖主配置文件里的同名属性 。\r\n这是因为导入的配置，在加载顺序和优先级上更\r\n“高”，用于覆盖主配置里的默认或基础配置\r\n这样一来，就实现了配置拆分，把大而全的配置拆成多个小文件（比如\r\ndb.properties 放数据库配置、redis.properties\r\n放 Redis 配置 ），用 spring.config.import\r\n聚合，方便维护，而且不同环境（开发 / 测试 /\r\n生产）的差异化配置，可单独写文件，通过 spring.config.import\r\n按环境引入\r\n属性占位符\r\n配置⽂件中可以使⽤\r\n$&#123;name:default&#125;形式取出之前配置过的值。在配置文件里，动态引用已定义的属性值\r\n，还能设置默认值，让配置更灵活、可复用。\r\n在使用application.properties中的值的时候，他们会从\r\nEnvironment\r\n中获取值，那就意味着，可以引用之前定义过的值，比如引用系统属性。具体做法如下：\r\n# 1. 定义基础属性app.name=MyApp  # 2. 引用属性 + 默认值app.description=$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;  \r\n\r\n$&#123;app.name&#125;： 引用已定义的\r\napp.name 属性值（即 MyApp ），最终\r\napp.description 里的 &#123;app.name&#125; 会被替换成\r\nMyApp 。\r\n$&#123;username:Unknown&#125;： 尝试引用\r\nusername 属性，如果 username\r\n没定义，就用默认值 Unknown\r\n兜底，避免配置缺失报错。\r\n\r\n这个在如下情况下很有用\r\n\r\n配置拼接：比如拼接服务地址\r\nservice.url=$&#123;host&#125;:$&#123;port&#125; ，只需维护 host 和\r\nport，动态组合成完整地址。让配置可拆分、可聚合，适配复杂项目的多环境、多模块配置管理，降低单个配置文件的复杂度。\r\n默认值兜底：对于一些非必填、或环境差异大的配置（比如开发者本地的用户名\r\n），用 :默认值 避免配置遗漏导致启动失败。实现配置的\r\n“动态引用” 和 “默认兜底”，减少硬编码，提升配置的灵活性和可维护性\r\n\r\n随机值配置\r\n在配置文件里，生成随机的字符串、数字等\r\n，常用于测试环境的动态值（比如随机端口、随机密钥\r\n），避免固定值引发的冲突或安全问题。\r\n配置文件中$&#123;random&#125;\r\n可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦\r\nSpring Boot 内置了\r\nRandomValuePropertySource，RandomValuePropertySource类重写了getProperty方法，判断以random.为前缀之后，进行了适当的处理，支持以下语法：\r\n# 1. 随机整数（范围可选，如 1000-9999）server.port=$&#123;random.int:1000-9999&#125;  # 2. 随机长整数my.random.long=$&#123;random.long&#125;  # 3. 随机 UUID（唯一识别码）my.random.uuid=$&#123;random.uuid&#125;  # 4. 随机字符串（自定义长度或直接生成）my.random.str=$&#123;random.value&#125; \r\n这样配置的效果：\r\n\r\n启动应用时，server.port 会随机生成 1000-9999\r\n之间的整数，避免多个服务本地启动时端口冲突。\r\nmy.random.uuid 每次启动都会生成一个唯一的\r\nUUID，可用于动态生成临时 Token、测试用的唯一标识等。\r\n\r\n一般在生成随机的加密密钥（如 jwt.secret=$&#123;random.value&#125;\r\n），测试环境不用写死密钥，减少泄露风险。\r\n命令行参数配置\r\n默认情况下，SpringApplication将所有的命令行选项参数【以--开头的参数，如--server.port=9000】转换为属性，并将它们加入SpringEnvironment中，命令行属性的配置始终优先于其他的属性配置。\r\n所以我们可以运行时通过命令行传入配置参数\r\n，覆盖配置文件里的默认值，灵活适配不同环境（尤其适合生产环境快速调整配置\r\n）。\r\n使用方式也比较简单，启动 Spring Boot 应用时，通过\r\n--参数=值 的形式传参，示例：\r\n# 方式 1：jar 包启动（经典方式）java -jar myapp.jar --server.port=8081 --app.env=prod  # 方式 2：IDE 里启动（添加 VM Options 或 Program arguments）--server.port=8082 --db.username=test \r\n命令行参数的优先级非常高\r\n，会覆盖配置文件（application.properties/application.yml\r\n）、环境变量里的同名配置。\r\n如果你不希望将命令行属性添加到Environment中，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。\r\n加密属性\r\n配置文件里常包含 敏感信息（如数据库密码、API 密钥\r\n），直接明文存储有泄露风险。\r\nSpring\r\nBoot不提供对加密属性值的任何内置支持，但是，它提供了修改Spring环境中的值所必需的挂钩点。所以Spring\r\nBoot 可通过扩展实现\r\n配置加密，让敏感配置以密文存储，运行时解密使用。\r\n以jasypt-spring-boot扩展为例子，先导入如下依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.5&lt;/version&gt; &lt;!-- 版本按需选 --&gt;&lt;/dependency&gt;\r\n在配置文件（或环境变量）里设置\r\n加密密钥（生产环境建议用环境变量 / 启动参数，避免硬编码\r\n）：\r\n# application.propertiesjasypt.encryptor.password=MySuperSecretKey!2025  \r\n加密配置值，用 Jasypt 工具生成密文。比如命令行加密（或写代码加密\r\n）：\r\n# 用 jasypt 命令行工具加密（假设密钥是上面的 MySuperSecretKey!2025 ）java -cp jasypt-1.9.3.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI \\  input=&quot;db.password=MyDBP@ssw0rd&quot; \\  password=MySuperSecretKey!2025 \\  algorithm=PBEWithMD5AndDES  \r\n配置文件用密文，把加密后的字符串放到配置里，用 ENC(...)\r\n包裹：\r\nspring.datasource.password=ENC(abcdef123456...)  \r\nSpring Boot 启动时，jasypt-spring-boot 会自动识别\r\nENC(...) 格式的配置，用密钥解密，注入到对应的 Bean 中。\r\n其中\r\n\r\n编译期 / 运行期解密：通过自定义\r\nPropertySource 或\r\nBeanPostProcessor，拦截配置加载，对密文做解密处理。\r\n密钥安全：生产环境密钥绝不能硬编码到配置文件！建议通过\r\n环境变量（export JASYPT_ENCRYPTOR_PASSWORD=xxx\r\n）、启动参数（java -jar app.jar --jasypt.encryptor.password=xxx\r\n）传入。\r\n\r\n类型安全的属性配置\r\n配置文件里的 key=value 是\r\n松散的字符串配置，直接用 @Value(\"$&#123;key&#125;\")\r\n注入时：\r\n\r\n零散的 @Value\r\n注入在配置多的时候，代码冗余且易出错。\r\n无法做 类型校验（比如配置是 int\r\n类型，但填了字符串 ）。\r\n\r\n例如：\r\nredis.host=localhostredis.port=6379redis.password=123456redis.timeout=3000redis.pool.max-active=100redis.pool.max-idle=20redis.pool.min-idle=5\r\n如果你使用 @Value注入\r\nimport org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class RedisService &#123;    @Value(&quot;$&#123;redis.host&#125;&quot;)    private String host;    @Value(&quot;$&#123;redis.port&#125;&quot;)    private int port;    @Value(&quot;$&#123;redis.password&#125;&quot;)    private String password;    @Value(&quot;$&#123;redis.timeout&#125;&quot;)    private int timeout;    @Value(&quot;$&#123;redis.pool.max-active&#125;&quot;)    private int maxActive;    @Value(&quot;$&#123;redis.pool.max-idle&#125;&quot;)    private int maxIdle;    @Value(&quot;$&#123;redis.pool.min-idle&#125;&quot;)    private int minIdle;    // 使用这些配置的方法...    public void connect() &#123;        System.out.println(&quot;Connecting to Redis: &quot; + host + &quot;:&quot; + port);        // ...    &#125;&#125;\r\n\r\n每个配置项都要写一个 @Value 注解，重复模板代码多。\r\n如果有多个类需要这些配置，每个类都要重复写一遍\r\n@Value。\r\n\r\n@ConfigurationProperties 让配置\r\n结构化、类型安全，把配置映射到 Java\r\n实体类，支持校验、嵌套。\r\n使用步骤如下：\r\n\r\n定义配置实体类，用 @ConfigurationProperties\r\n绑定配置前缀\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;@Component@ConfigurationProperties(prefix = &quot;app&quot;) public class AppConfig &#123;    private String name;          // 对应 app.name    private int port;            // 对应 app.port    private List&lt;String&gt; features; // 对应 app.features[0], app.features[1]...        // Getter + Setter 必须有（Lombok 可简化）    public String getName() &#123; return name; &#125;    public void setName(String name) &#123; this.name = name; &#125;    // ...其他 Getter/Setter&#125;\r\n配置文件编写，在 application.properties\r\n里按前缀写配置：\r\napp.name=MyAppapp.port=8080app.features[0]=securityapp.features[1]=logging\r\n注入并且使用，在任意 Bean 中注入\r\nAppConfig，直接用结构化属性：\r\nimport org.springframework.stereotype.Service;@Servicepublic class MyService &#123;    private final AppConfig appConfig;    public MyService(AppConfig appConfig) &#123;        this.appConfig = appConfig;    &#125;    public void printConfig() &#123;        System.out.println(&quot;Name: &quot; + appConfig.getName());  // 直接用实体类属性        System.out.println(&quot;Port: &quot; + appConfig.getPort());    &#125;&#125;\r\n而且可以加 @Validated 和 JSR303\r\n注解，实现配置校验：\r\nimport jakarta.validation.constraints.Min;import jakarta.validation.constraints.NotEmpty;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;import java.util.List;@Component@ConfigurationProperties(prefix = &quot;app&quot;)@Validated // 开启校验public class AppConfig &#123;    @NotEmpty(message = &quot;app.name 不能为空&quot;)    private String name;             @Min(value = 1024, message = &quot;app.port 不能小于 1024&quot;)    private int port;               private List&lt;String&gt; features;         // Getter + Setter&#125;\r\n如果配置不符合规则（如 app.port=80\r\n），启动时会直接报错，提前拦截配置错误。\r\n\r\n通过@ContructorBinding注解使用构造器绑定的方式：\r\n简单说，它是 让 @ConfigurationProperties 类通过 构造器\r\n完成属性绑定 的注解，核心解决 “配置类字段不可变（final）”\r\n场景的绑定问题，也能让对象初始化更可控。\r\n如果使用默认 @ConfigurationProperties ，它是用 Setter\r\n方法来绑定属性，这会带来一些问题\r\n\r\n字段必须可变：类里的字段得有 Setter（即\r\nprivate String name; public void setName(String name) &#123;...&#125;\r\n），无法用 final 修饰。\r\n初始化时机模糊：属性通过 Setter\r\n零散赋值，若依赖多字段初始化，容易出现 “部分字段已赋值、部分未赋值”\r\n的中间状态。\r\n\r\n在 @ConfigurationProperties 类上，加上\r\n@ConstructorBinding，明确告诉 Spring\r\nBoot：用构造器来绑定配置属性。\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.ConstructorBinding;@ConstructorBinding // 关键：启用构造器绑定@ConfigurationProperties(prefix = &quot;app&quot;) public class AppConfig &#123;    private final String name;     private final int port;      // 构造器注入所有配置属性    public AppConfig(String name, int port) &#123;        this.name = name;        this.port = port;    &#125;    // Getter（无需 Setter）    public String getName() &#123; return name; &#125;    public int getPort() &#123; return port; &#125;&#125;\r\n和常规 @ConfigurationProperties 一样，按前缀写配置：\r\napp.name=MyAppapp.port=8080\r\n在需要的地方，通过 构造器注入 或\r\n@Autowired 注入 AppConfig\r\n即可：\r\nimport org.springframework.stereotype.Service;@Servicepublic class MyService &#123;    private final AppConfig appConfig;    // 构造器注入（推荐）    public MyService(AppConfig appConfig) &#123;        this.appConfig = appConfig;    &#125;    public void printConfig() &#123;        System.out.println(&quot;Name: &quot; + appConfig.getName());        System.out.println(&quot;Port: &quot; + appConfig.getPort());    &#125;&#125;\r\n注意：\r\n\r\n必须配合 @ConfigurationProperties：\r\n@ConstructorBinding 不能单独用，必须和\r\n@ConfigurationProperties 一起标注在类上。\r\n依赖注入方式：\r\n若用构造器绑定，配置类必须能被 Spring 扫描到（或通过\r\n@EnableConfigurationProperties 显式启用 ）。 比如非\r\n@Component 标注的配置类，需要在启动类加：\r\n@SpringBootApplication@EnableConfigurationProperties(AppConfig.class) // 显式启用public class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","JavaEE","Spring系列","Servlet","Spring Boot","Java框架","配置相关"]},{"title":"Spring Boot part15-SpringApplication的基础特性及其原理","url":"/posts/16164.html","content":"SpringApplication的基础特性\r\n在 Spring Boot 生态中，SpringApplication\r\n是启动应用的核心类，它封装了繁杂的启动流程，让开发者能以简洁方式启动应用，同时还提供了丰富可扩展点，助力定制化需求实现。\r\n在这里我会先讲基础特性，然后会再将一些 SpringApplication\r\n的基础原理\r\n自定义 banner\r\n什么是 banner\r\nbanner 是 Spring Boot\r\n应用启动时，在控制台打印的一段字符图案或文字信息，默认是 Spring Boot\r\n标志性图案。它虽不影响应用功能，却能成为应用独特\r\n“名片”，用于展示团队文化、应用名称等个性化内容。\r\n\r\n\r\nimage-20250613165542529\r\n\r\n这个就是 banner\r\n这个东西是可以自定义的\r\n如何自定义 banner\r\n在类路径（一般是 src/main/resources 目录）下添加\r\nbanner.txt 文件，Spring Boot 启动时会自动加载该文件内容作为\r\nbanner 显示。可借助在线工具（如文中提到的 Spring Boot banner\r\n在线生成工具，访问 banner-bootschool.net\r\n），生成个性文字图案（支持英文等），下载后替换 banner.txt\r\n文字，轻松定制专属启动画面。\r\n自定义banner的网站\r\n若不想用默认 banner.txt 文件名或存放路径，可通过配置\r\nspring.banner.location 实现。例如在\r\napplication.yml 中配置：\r\nspring:  banner:    location: classpath:custom/banner-custom.txt\r\n这样 Spring Boot 启动时，就会加载 classpath:custom/\r\n路径下的 banner-custom.txt 文件作为 banner 。\r\n除了文本格式的 banner.txt，Spring Boot\r\n还支持其他格式：\r\n\r\nbanner.gif/banner.jpg/banner.png\r\n：若在类路径放置这些图片格式文件，Spring Boot\r\n会将图片转换为字符画形式展示（效果取决于图片复杂度和终端支持度）。\r\n配置控制显示：通过\r\nspring.banner.image.* 系列配置，如\r\nspring.banner.image.width\r\n、spring.banner.image.height\r\n等，可调整图片转字符画的显示参数，精细控制 banner 呈现效果 。\r\n\r\nspring.main.banner-mode=off# 这样就关闭了banner，默认是 console\r\n自定义\r\nSpringApplication：灵活把控启动配置\r\n直接创建与配置\r\nSpringApplication 对象\r\n在 Spring Boot 应用中，常规启动方式是借助\r\n@SpringBootApplication 注解和\r\nSpringApplication.run(MyApplication.class, args)\r\n简洁启动\r\n@SpringBootApplicationpublic class SpringBootWebPart1Application &#123;    public static void main(String[] args) &#123;        // SpringApplication调用run方法，传入你的主程序启动类和不定参数args        SpringApplication.run(SpringBootWebPart1Application.class, args);    &#125;&#125;\r\n我们来看看SpringApplication中涉及到run的源代码\r\npublic class SpringApplication &#123; \tpublic static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;        return run(new Class[]&#123;primarySource&#125;, args);    &#125;    public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;        // 先会 new 一个主程序应用，然后把我们的主程序传入进来，再调用run        // 所以这个过程我们可以拆解，就是自定义启动行为        return (new SpringApplication(primarySources)).run(args);    &#125;&#125;\r\n这两个静态方法本质上是快速创建 SpringApplication\r\n对象并执行启动流程的\r\n“语法糖”。但在实际开发中，若想对应用启动进行更细粒度的配置，就需要手动创建\r\nSpringApplication 对象，深入参与启动过程。\r\n常规的静态 run\r\n方法虽然简洁，但封装了很多默认的启动逻辑。当我们需要自定义一些启动行为时，手动创建\r\nSpringApplication 对象就显得尤为必要。示例代码如下：\r\nimport org.springframework.boot.Banner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MyApplication &#123;    public static void main(String[] args) &#123;        // 手动创建 SpringApplication 对象，指定主配置类        // 拆成两步写，这样就可以在run方法前自定义 SpringApplication的底层设置        SpringApplication application = new SpringApplication(MyApplication.class);        // 设置 banner 显示模式为关闭，即启动时不显示 banner        application.setBannerMode(Banner.Mode.OFF);         // 等等各种行为都可以自定义        // 执行启动        application.run(args);     &#125;&#125;\r\n在这个过程中：\r\n\r\n创建对象：new SpringApplication(MyApplication.class)\r\n明确指定了应用的主配置类，SpringApplication\r\n会基于此去扫描和加载相关的 Bean 定义、自动配置等内容。\r\n配置行为：通过 setBannerMode\r\n方法，能灵活控制 banner 显示状态。除了 OFF（关闭），还有\r\nCONSOLE（控制台显示，默认）、LOG（记录到日志文件）模式。比如在生产环境，为避免控制台冗余输出，可设置为\r\nOFF；开发环境下，为了直观看到 Spring Boot\r\n标志性启动画面或者自定义的 banner ，则可使用 CONSOLE 模式\r\n。\r\n执行启动：调用 run(args)\r\n方法，才真正触发 Spring Boot\r\n应用的启动流程，包括环境准备、上下文创建、Bean\r\n加载和初始化等一系列操作。\r\n\r\n注意，在程序化调整 SpringApplication\r\n的启动参数的时候，它的优先级是低于配置文件的优先级的，这个可以看配置注入的源码，你会发现是为什么是这个顺序。\r\nBuilder\r\n方式构建 SpringApplication——FluentBuilder API\r\n在 Spring Boot 中，除了直接通过 SpringApplication\r\n的构造方法、静态 run 方法来创建和启动应用，还提供了\r\nFluentBuilder API（流畅构建器 API） ，也就是基于\r\nSpringApplicationBuilder\r\n的构建方式。它通过链式调用的语法，让开发者更灵活、更直观地配置\r\nSpringApplication 的各项参数\r\n定制化 Banner + 激活配置文件示例\r\nnew SpringApplicationBuilder(MyApp.class)    // 自定义 Banner（可以是自己写的 ASCII 字符串，或者读取文件）    .banner(new ResourceBanner(new ClassPathResource(&quot;my-banner.txt&quot;)))     .bannerMode(Banner.Mode.CONSOLE) // 在控制台显示 Banner    .profiles(&quot;dev&quot;, &quot;local&quot;)        // 激活 dev、local 配置文件    .run(args);\r\nSpringApplicationBuilder\r\n支持链式调用，一步一步配置应用的各种属性，最后调用 run(...)\r\n启动应用。\r\nnew SpringApplicationBuilder(MyApp.class)    .bannerMode(Banner.Mode.CONSOLE) // 配置 Banner 显示模式    .logStartupInfo(true)            // 开启启动日志    .web(WebApplicationType.SERVLET) // 指定 Web 应用类型    .run(args);                      // 启动应用\r\n如果不用 Builder，等价逻辑需要这样写：\r\nSpringApplication app = new SpringApplication(MyApp.class);app.setBannerMode(Banner.Mode.CONSOLE);app.setLogStartupInfo(true);app.setWebApplicationType(WebApplicationType.SERVLET);app.run(args);\r\n可以看到，Builder 方式通过链式调用，把零散的 set\r\n操作串起来\r\nSpringApplicationBuilder 内部其实是对\r\nSpringApplication 和 ApplicationContext\r\n构建过程的封装，核心思路是：\r\n\r\n封装配置参数： 把 SpringApplication\r\n的各种配置项（如\r\nwebApplicationType、bannerMode、initializers\r\n等），以及 ApplicationContext 的相关配置，通过 Builder\r\n的方法暴露出来，让开发者用链式调用设置。\r\n延迟构建 SpringApplication： 调用\r\nrun(...) 之前，Builder 只是在收集配置；真正调用\r\nrun(...) 时，才会根据收集的配置，创建\r\nSpringApplication 实例，并执行启动流程。\r\n支持父子上下文： 这是 Builder\r\n方式的一个重要特性！它可以方便地构建 父子 Spring\r\n上下文（比如父上下文放公共配置，子上下文放 Web\r\n相关配置），典型代码：\r\npublic static void main(String[] args) &#123;    new SpringApplicationBuilder()        // 父上下文：加载公共配置        .parent(CommonConfig.class)          .web(WebApplicationType.NONE) // 父上下文是非 Web 类型        // 子上下文：加载 Web 相关配置        .child(WebConfig.class)               .web(WebApplicationType.SERVLET) // 子上下文是 Servlet Web 类型        .run(args);&#125;\r\n\r\n父上下文 CommonConfig 里的 Bean（如\r\nDataSource），子上下文 WebConfig\r\n可以直接引用。\r\n子上下文的 Bean（如\r\nUserController）不会污染父上下文，实现了一定程度的\r\n“模块隔离”。\r\n\r\n\r\nSpringApplicationBuilder\r\n提供了丰富的链式方法，常用的有这些：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法名\r\n作用\r\n\r\n\r\n\r\n\r\nsources(...)\r\n指定主配置类（等价于 SpringApplication 构造方法里的\r\nprimarySources）\r\n\r\n\r\nweb(WebApplicationType)\r\n设置 Web 应用类型（SERVLET/REACTIVE/NONE）\r\n\r\n\r\nbanner(Banner)\r\n自定义启动 Banner（比如替换成自己的 ASCII 艺术字）\r\n\r\n\r\nbannerMode(Banner.Mode)\r\n控制 Banner 显示方式（CONSOLE/LOG/OFF）\r\n\r\n\r\nlogStartupInfo(boolean)\r\n是否打印启动日志（默认 true）\r\n\r\n\r\ninitializers(...)\r\n添加 ApplicationContextInitializer 初始化器\r\n\r\n\r\nlisteners(...)\r\n添加 ApplicationListener 监听器\r\n\r\n\r\nparent(...) / child(...)\r\n构建父子上下文（父上下文通常放公共 Bean，子上下文放业务 Bean）\r\n\r\n\r\nprofiles(...)\r\n指定激活的配置文件（等价于\r\nspring.profiles.active）\r\n\r\n\r\nenvironment(...)\r\n自定义 Environment（比如添加额外的属性源）\r\n\r\n\r\n\r\nSpringApplication的基础原理\r\n@SpringBootApplication\r\n可以发现，Spring Boot\r\n项目中的启动类，总会加一个@SpringBootApplication，这个就是Spring\r\nBoot启动类的核心部分，它的存在使得项目启动类非常简单，仅仅存在一个注解`@SpringBootApplication以及一个运行参数为被该注解标注类run函数，基本全部\r\nSpring Boot 的启动准备工作就会被自动完成。\r\n对于该启动类的分析，就从这个Spring\r\nBoot的核心注解@SpringBootApplication开始入手。\r\n字面分析，这个注解是标注一个Spring Boot应用。\r\n我们进去这个注解的详细信息，去看看它的源码\r\npackage org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.beans.factory.support.BeanNameGenerator;import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.context.TypeExcludeFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.core.annotation.AliasFor;/** * 这是一个组合注解，整合了 Spring Boot 应用所需的常用注解配置。 * 一般会把该注解添加到主应用类上，这样就能启用以下功能： * - 自动配置：依据类路径和 Bean 定义自动配置 Spring 应用上下文 * - 组件扫描：自动扫描并注册带有特定注解的组件 * - 声明配置类：表明该类是一个配置类 */@Target(&#123;ElementType.TYPE&#125;) // 此注解可用于类、接口或枚举@Retention(RetentionPolicy.RUNTIME) // 在运行时可以通过反射获取该注解@Documented // 该注解会被包含在 JavaDoc 中@Inherited // 该注解可被继承@SpringBootConfiguration // 表明这是一个 Spring Boot 配置类@EnableAutoConfiguration // 开启自动配置功能// 在自动扫描组件时排除特定类型的类@ComponentScan(    excludeFilters = &#123;@Filter(    type = FilterType.CUSTOM,    classes = &#123;TypeExcludeFilter.class&#125;  // 排除测试相关的组件), @Filter(    type = FilterType.CUSTOM,    classes = &#123;AutoConfigurationExcludeFilter.class&#125;  // 专注于处理自动配置类的排除,排除自动配置类)&#125;) // 自动扫描并注册组件，同时排除特定类型public @interface SpringBootApplication &#123;    /**     * 明确指定要排除的自动配置类。     * 这些类不会被 Spring Boot 自动配置。     */    @AliasFor(        annotation = EnableAutoConfiguration.class    )    Class&lt;?&gt;[] exclude() default &#123;&#125;;    /**     * 明确指定要排除的自动配置类的全限定名。     * 这些类不会被 Spring Boot 自动配置。     */    @AliasFor(        annotation = EnableAutoConfiguration.class    )    String[] excludeName() default &#123;&#125;;    /**     * 指定要扫描组件的基础包。     * 如果没有指定，就会从被该注解标注的类所在的包开始扫描。     */    @AliasFor(        annotation = ComponentScan.class,        attribute = &quot;basePackages&quot;    )    String[] scanBasePackages() default &#123;&#125;;    /**     * 指定要扫描组件的基础包的参考类。     * 每个类所在的包都会被作为扫描的基础包。     */    @AliasFor(        annotation = ComponentScan.class,        attribute = &quot;basePackageClasses&quot;    )    Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;    /**     * 为组件扫描时发现的 Bean 指定命名生成器类。     */    @AliasFor(        annotation = ComponentScan.class,        attribute = &quot;nameGenerator&quot;    )    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;    /**     * 指示是否要代理配置类的 Bean 方法，从而实现 Bean 的生命周期管理。     * - true：使用 CGLIB 代理 Bean 方法     * - false：直接调用 Bean 方法（适用于函数式风格的配置）     */    @AliasFor(        annotation = Configuration.class    )    boolean proxyBeanMethods() default true;&#125;\r\n进入到这个注解后，可以发现该注解由四个元注解，以及其他三个注解组成分别是\r\n@SpringBootConfiguration // 表明这是一个 Spring Boot 配置类@EnableAutoConfiguration // 开启自动配置功能// 在自动扫描组件时排除特定类型的类@ComponentScan(    excludeFilters = &#123;@Filter(    type = FilterType.CUSTOM,    classes = &#123;TypeExcludeFilter.class&#125;  // 排除测试相关的组件), @Filter(    type = FilterType.CUSTOM,    classes = &#123;AutoConfigurationExcludeFilter.class&#125;  // 专注于处理自动配置类的排除,排除自动配置类)&#125;\r\n我们首先从@SpringBootConfiguration 注解看起\r\n@SpringBootConfiguration\r\npackage org.springframework.boot;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.AliasFor;import org.springframework.stereotype.Indexed;/** * 该注解是 Spring Boot 应用的配置类标识，是 @Configuration 的特殊形式。 * 通常会将此注解添加到主应用类上，用于： * 1. 声明该类为 Bean 定义的来源 * 2. 启用对 @Bean 方法的增强处理 * 3. 支持组件扫描和自动配置的元数据处理 * * 建议与 @EnableAutoConfiguration 和 @ComponentScan 组合使用， * 不过 @SpringBootApplication 已经整合了这三个注解。 */@Target(&#123;ElementType.TYPE&#125;) // 此注解可用于类、接口或枚举@Retention(RetentionPolicy.RUNTIME) // 在运行时可以通过反射获取该注解@Documented // 该注解会被包含在 JavaDoc 中@Configuration // 表明这是一个配置类，可以定义 Bean@Indexed // 支持组件索引，提高组件扫描性能，在 META-INF/spring.components 中生成索引文件，避免全类路径扫描public @interface SpringBootConfiguration &#123;    /**     * 指示是否要代理配置类的 Bean 方法，从而实现 Bean 的生命周期管理。     * - true：使用 CGLIB 代理 Bean 方法，确保对同一 Bean 的多次调用返回相同实例（单例）     * - false：直接调用 Bean 方法，每次调用都可能创建新实例（适用于函数式风格配置）     *     * 此属性与 @Configuration 中的 proxyBeanMethods 属性保持一致。     */    @AliasFor(        annotation = Configuration.class    )    boolean proxyBeanMethods() default true;&#125;\r\n可以发现，这个注解中除了元注解之外，存在@Configuration这个Spring\r\nFramework 提供的原生注解，@SpringBootConfiguration\r\n对其进行了扩展，增加了对 Spring Boot 特性的支持。\r\n那么可以理解@SpringBootConfiguration为他仅仅就是一个配置类。我们知道，@Configuration注解为Spring中的配置类注解，其中被@Component标注为Spring组件，意味着他被注册到IOC容器。\r\n因此，套用官方文档的答案：@SpringBootConfiguration表示一个类提供\r\nSpring Boot 应用程序@Configuration。可以用作 Spring\r\n标准@Configuration注释的替代方法，以便可以自动找到配置（例如在测试中）。\r\n而且，我们可以明确看出 @SpringBootApplication 是整合了\r\n@SpringBootConfiguration、@EnableAutoConfiguration\r\n和 @ComponentScan\r\n的组合注解，而其中SpringBootApplication 中的属性通过\r\n@AliasFor\r\n映射到底层注解，这种设计让开发者可以在不破坏注解组合的前提下，灵活定制配置\r\n@AliasFor(annotation = EnableAutoConfiguration.class)Class&lt;?&gt;[] exclude() default &#123;&#125;;@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)String[] scanBasePackages() default &#123;&#125;;@AliasFor(annotation = Configuration.class)  // SpringBootConfiguration 继承自 Configurationboolean proxyBeanMethods() default true;\r\n\r\nexclude → 映射到 @EnableAutoConfiguration\r\n的 exclude\r\nscanBasePackages → 映射到 @ComponentScan\r\n的 basePackages\r\nproxyBeanMethods → 映射到 @Configuration\r\n的 proxyBeanMethods\r\n\r\n@EnableAutoConfiguration\r\n接下来就是咱们比较熟悉的注解，@EnableAutoConfiguration，它是自动配置原理的核心注解，它的作用就是开启自动配置，进入源码\r\npackage org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Import;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;    Class&lt;?&gt;[] exclude() default &#123;&#125;;    String[] excludeName() default &#123;&#125;;&#125;\r\n可以发现，除了四个元注解，这个注解被两个注解所标注@AutoConfigurationPackage、@Import(AutoConfigurationImportSelector.class)\r\n我们之前的文章中分析过，@AutoConfigurationPackage中使用注解@Import，导入了AutoConfigurationPackages.Registrar.class到你的Spring容器中，来处理包注册，@SpringBootApplication这个组合注解包含了\r\n@AutoConfigurationPackage，所以当你使用\r\n@SpringBootApplication 时，会自动启用包注册功能。在 Spring\r\nBoot 应用启动时，这个注解会和 @EnableAutoConfiguration\r\n一起工作，共同构建自动配置的基础环境。\r\n@EnableAutoConfiguration还通过@Import(AutoConfigurationImportSelector.class)引入了关键的导入选择器，其核心逻辑在于AutoConfigurationImportSelector的selectImports()方法。该方法会调用SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, classLoader)，从类路径的META-INF/spring.factories中获取自动配置类列表。当项目引入某个依赖（如spring-boot-starter-web）时，其\r\nJAR\r\n包内的spring.factories会包含对应的自动配置类，从而被SpringFactoriesLoader扫描到。\r\n所以说，Spring Boot\r\n启动时，通过SpringFactoriesLoader工具类从类路径下的META-INF/spring.factories文件中，读取与EnableAutoConfiguration.class关联的配置类列表，并将这些类导入\r\nSpring 容器，实现自动配置功能。\r\n与`@ComponentScan相比，二者的区别在于，@AutoConfigurationPackage\r\n主要是为自动配置提供包路径信息，而 @ComponentScan\r\n侧重于组件扫描。\r\npackage org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Import;/** * 该注解用于标记自动配置包的注册。 * 通常会被 @SpringBootApplication 间接引入，不过也能单独使用。 * 其核心功能是： * 1. 记录主应用类所在的包路径 * 2. 让自动配置组件能够定位到这些包 * 3. 支持使用 basePackages 或 basePackageClasses 自定义扫描包 */@Target(&#123;ElementType.TYPE&#125;) // 此注解可用于类、接口或枚举@Retention(RetentionPolicy.RUNTIME) // 在运行时可以通过反射获取该注解@Documented // 该注解会被包含在 JavaDoc 中@Inherited // 该注解可被继承@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;) // 导入 Registrar 类来处理包注册public @interface AutoConfigurationPackage &#123;    /**     * 手动指定要注册的基础包。     * 如果没有指定，将使用被 @AutoConfigurationPackage 标注的类所在的包。     */    String[] basePackages() default &#123;&#125;;    /**     * 手动指定要注册的基础包的参考类。     * 每个类所在的包都会被作为基础包进行注册。     */    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125;\r\n\r\n借助 AutoConfigurationPackages.Registrar\r\n类，把主应用类所在的包路径注册到 Spring 容器中。这些包路径会被存储在\r\nBeanDefinitionRegistry 里。\r\n其他自动配置类可以通过\r\nAutoConfigurationPackages.get(BeanFactory)\r\n方法获取这些包路径。像 JPA\r\n实体扫描、组件扫描等功能都会依赖这些包路径\r\n可以通过 basePackages 参数直接指定包名。这就是为什么\r\nSpring Boot 可以配置自定义扫描路径，也能通过\r\nbasePackageClasses\r\n参数指定参考类，以类所在的包作为扫描范围。这样就实现了支持灵活的包路径自定义，以满足不同的项目结构需求。\r\n@AutoConfigurationPackage就是添加该注解的类所在的包作为自动配置包进行管理。他的实现就是依赖于工具类AutoConfigurationPackages中的内部类Registrar对所标注的包进行注册。\r\n\r\n进入到AutoConfigurationPackages这个类中，就会发现，其中有一些重要的方法来负责管理和存储自动配置的基础包路径，用于扫描组件（如\r\n@Entity、@Repository\r\n等）以及定位需要自动配置的类时候使用\r\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.springframework.boot.autoconfigure;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Set;import java.util.stream.Stream;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.NoSuchBeanDefinitionException;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.ConstructorArgumentValues;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.boot.context.annotation.DeterminableImports;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.annotation.AnnotationAttributes;import org.springframework.core.type.AnnotationMetadata;import org.springframework.util.ClassUtils;import org.springframework.util.StringUtils;public abstract class AutoConfigurationPackages &#123;    private static final Log logger = LogFactory.getLog(AutoConfigurationPackages.class);    private static final String BEAN = AutoConfigurationPackages.class.getName();    public static boolean has(BeanFactory beanFactory) &#123;        return beanFactory.containsBean(BEAN) &amp;&amp; !get(beanFactory).isEmpty();    &#125;    public static List&lt;String&gt; get(BeanFactory beanFactory) &#123;        try &#123;            return ((BasePackages)beanFactory.getBean(BEAN, BasePackages.class)).get();        &#125; catch (NoSuchBeanDefinitionException var2) &#123;            throw new IllegalStateException(&quot;Unable to retrieve @EnableAutoConfiguration base packages&quot;);        &#125;    &#125;    public static void register(BeanDefinitionRegistry registry, String... packageNames) &#123;        if (registry.containsBeanDefinition(BEAN)) &#123;            addBasePackages(registry.getBeanDefinition(BEAN), packageNames);        &#125; else &#123;            RootBeanDefinition beanDefinition = new RootBeanDefinition(BasePackages.class);            beanDefinition.setRole(2);            addBasePackages(beanDefinition, packageNames);            registry.registerBeanDefinition(BEAN, beanDefinition);        &#125;    &#125;    private static void addBasePackages(BeanDefinition beanDefinition, String[] additionalBasePackages) &#123;        ConstructorArgumentValues constructorArgumentValues = beanDefinition.getConstructorArgumentValues();        if (constructorArgumentValues.hasIndexedArgumentValue(0)) &#123;            String[] existingPackages = (String[])constructorArgumentValues.getIndexedArgumentValue(0, String[].class).getValue();            constructorArgumentValues.addIndexedArgumentValue(0, Stream.concat(Stream.of(existingPackages), Stream.of(additionalBasePackages)).distinct().toArray((x$0) -&gt; new String[x$0]));        &#125; else &#123;            constructorArgumentValues.addIndexedArgumentValue(0, additionalBasePackages);        &#125;    &#125;    static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;            AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));        &#125;        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;            return Collections.singleton(new PackageImports(metadata));        &#125;    &#125;    private static final class PackageImports &#123;        private final List&lt;String&gt; packageNames;        PackageImports(AnnotationMetadata metadata) &#123;            AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));            List&lt;String&gt; packageNames = new ArrayList(Arrays.asList(attributes.getStringArray(&quot;basePackages&quot;)));            for(Class&lt;?&gt; basePackageClass : attributes.getClassArray(&quot;basePackageClasses&quot;)) &#123;                packageNames.add(basePackageClass.getPackage().getName());            &#125;            if (packageNames.isEmpty()) &#123;                packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));            &#125;            this.packageNames = Collections.unmodifiableList(packageNames);        &#125;        List&lt;String&gt; getPackageNames() &#123;            return this.packageNames;        &#125;        public boolean equals(Object obj) &#123;            return obj != null &amp;&amp; this.getClass() == obj.getClass() ? this.packageNames.equals(((PackageImports)obj).packageNames) : false;        &#125;        public int hashCode() &#123;            return this.packageNames.hashCode();        &#125;        public String toString() &#123;            return &quot;Package Imports &quot; + String.valueOf(this.packageNames);        &#125;    &#125;    static final class BasePackages &#123;        private final List&lt;String&gt; packages;        private boolean loggedBasePackageInfo;        BasePackages(String... names) &#123;            List&lt;String&gt; packages = new ArrayList();            for(String name : names) &#123;                if (StringUtils.hasText(name)) &#123;                    packages.add(name);                &#125;            &#125;            this.packages = packages;        &#125;        List&lt;String&gt; get() &#123;            if (!this.loggedBasePackageInfo) &#123;                if (this.packages.isEmpty()) &#123;                    if (AutoConfigurationPackages.logger.isWarnEnabled()) &#123;                        AutoConfigurationPackages.logger.warn(&quot;@EnableAutoConfiguration was declared on a class in the default package. Automatic @Repository and @Entity scanning is not enabled.&quot;);                    &#125;                &#125; else if (AutoConfigurationPackages.logger.isDebugEnabled()) &#123;                    String packageNames = StringUtils.collectionToCommaDelimitedString(this.packages);                    AutoConfigurationPackages.logger.debug(&quot;@EnableAutoConfiguration was declared on a class in the package &#x27;&quot; + packageNames + &quot;&#x27;. Automatic @Repository and @Entity scanning is enabled.&quot;);                &#125;                this.loggedBasePackageInfo = true;            &#125;            return this.packages;        &#125;    &#125;&#125;\r\n其中的静态工具方法\r\npublic static boolean has(BeanFactory beanFactory)public static List&lt;String&gt; get(BeanFactory beanFactory)public static void register(BeanDefinitionRegistry registry, String... packageNames)\r\n\r\nhas()：检查 BeanFactory\r\n中是否存在自动配置包的注册信息。\r\nget()：获取已注册的基础包路径列表。\r\nregister()：向 BeanDefinitionRegistry\r\n注册基础包路径。\r\n\r\n进入到内部类结构，可以得到如下\r\n\r\nRegistrar：实现\r\nImportBeanDefinitionRegistrar，负责注册\r\nBasePackages Bean。\r\nPackageImports：解析\r\n@AutoConfigurationPackage 注解的属性，提取基础包路径。\r\nBasePackages：封装基础包路径列表，支持日志记录和路径获取。\r\n\r\n简单讲解一下其工作流程\r\n\r\n首先当 @AutoConfigurationPackage\r\n注解被处理时，Registrar\r\n方法会被调用，来注册包路径，从注解元数据中提取包路径（通过\r\nPackageImports）。调用\r\nAutoConfigurationPackages.register() 注册路径。\r\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;            AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));        &#125;        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;            return Collections.singleton(new PackageImports(metadata));        &#125;    &#125;\r\n然后 PackageImports\r\n解析注解属性，从中可以发现优先级，basePackages &gt;\r\nbasePackageClasses &gt;\r\n注解所在类的包，按照这个顺序获得packageNames属性也就是启动类所在的包。，如果用户没有显式指定包，Spring\r\nBoot 会使用主应用类所在的包，这就是默认行为的来源\r\nprivate static final class PackageImports &#123;    PackageImports(AnnotationMetadata metadata) &#123;        // 1. 获取 @AutoConfigurationPackage 注解的 basePackages 属性        List&lt;String&gt; packageNames = new ArrayList(Arrays.asList(attributes.getStringArray(&quot;basePackages&quot;)));                // 2. 获取 basePackageClasses 属性并提取其所在包        for(Class&lt;?&gt; basePackageClass : attributes.getClassArray(&quot;basePackageClasses&quot;)) &#123;            packageNames.add(basePackageClass.getPackage().getName());        &#125;                // 3. 如果都没指定，则使用注解所在类的包        if (packageNames.isEmpty()) &#123;            packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));        &#125;    &#125;&#125;\r\nBasePackages\r\n管理包路径，这个没啥好讲，就是存储一下基础包路径列表，然后给点日志，这个方法中有这样一条List&lt;String&gt; packages = new ArrayList();，这个列表将所有自动配置的基础包路径集中存储在一个\r\nBean 中，便于其他自动配置类统一获取。\r\n最后注册BeanDefinition，保证基础设施\r\nBean不对外暴露，通过构造函数参数形式存储包路径数组\r\n\r\nSpring Boot 应用程序的启动\r\n继续剖析 run 方法\r\n讲完了注解相关的原理和源代码梳理后，让我们聚焦于应用程序的启动过程，我们来看看Spring\r\nBoot项目的启动原理\r\n我们可以看到 SpringBootWebPart1Application 的\r\nmain 方法中，直接调用了 SpringApplication\r\n的静态方法 run，用于启动整个 Spring Boot 项目。Spring Boot\r\n应用的启动通常始于以下代码：\r\n@SpringBootApplicationpublic class SpringBootWebPart1Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringBootWebPart1Application.class, args);    &#125;&#125;\r\nrun方法的源代码我们上面已经讲过了，实际上就是\r\nnew 了一个SpringApplication 对象，其构造参数\r\nprimarySources 为加载的主要资源类，通常就是\r\nSpringBoot 的入口类，并调用其 run\r\n方法，通过其参数 args\r\n为传递给应用程序的参数信息，然后进行启动后返回一个应用上下文对象\r\nConfigurableApplicationContext 。\r\n简单来说，这个静态方法实际上执行了两个关键步骤：\r\n\r\n创建SpringApplication实例：封装应用上下文的创建逻辑。\r\n调用run()方法：启动应用并返回ConfigurableApplicationContext。\r\n\r\n创建SpringApplication实例的细节原理\r\n在启动的过程中，SpringApplication会进行实例化，SpringApplication的初始化过程涉及到其构造函数，它承担了应用启动前的准备工作，如下源码所示\r\npublic SpringApplication(Class&lt;?&gt;... primarySources) &#123;        this((ResourceLoader)null, primarySources);    &#125;    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;        this.addCommandLineProperties = true;        this.addConversionService = true;        this.headless = true;        this.additionalProfiles = Collections.emptySet();        this.applicationContextFactory = ApplicationContextFactory.DEFAULT;        this.applicationStartup = ApplicationStartup.DEFAULT;        this.properties = new ApplicationProperties();        this.resourceLoader = resourceLoader;        Assert.notNull(primarySources, &quot;&#x27;primarySources&#x27; must not be null&quot;);        this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));        this.properties.setWebApplicationType(WebApplicationType.deduceFromClasspath());        this.bootstrapRegistryInitializers = new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));        this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));        this.mainApplicationClass = this.deduceMainApplicationClass();    &#125;\r\n由上可知，SpringApplication\r\n提供了两个构造方法，而其核心的逻辑都在第二个构造方法中实现。\r\n我们从上述源码可知，SpringApplication\r\n的第二个构造方法有两个参数，分别是：\r\nResourceLoader resourceLoader\r\n：ResourceLoader 为资源加载的接口，它用于在Spring Boot\r\n启动时打印对应的 banner\r\n信息，默认采用的就是DefaultResourceLoader，实操过程中，如果未按照\r\nSpring Boot 的 “约定” 将 banner 的内容放置于 classpath\r\n下，或者文件名不是 banner.*\r\n格式，默认资源加载器是无法加载到对应的 banner 信息的，此时则可通过\r\nResourceLoader 来指定需要加载的文件路径\r\nClass&lt;?&gt;... primarySources ：主要的 bean\r\n来源，该参数为可变参数，默认我们会传入 Spring Boot 的入口类【即\r\nmain 方法所在的类】，如上面我们的\r\nDemoApplication\r\n。如果作为项目的引导类，该类需要满足一个条件，就是被注解\r\n@EnableAutoConfiguration\r\n或其组合注解标注。在前面的的部分我们已经知道\r\n@SpringBootApplication 注解中包含了\r\n@EnableAutoConfiguration 注解，因此被\r\n@SpringBootApplication\r\n注解标注的类也可作为参数传入。当然，primarySources\r\n也可传入其他普通类，但只有传入被@EnableAutoConfiguration\r\n标注的类才能够开启 Spring Boot 的自动配置。\r\n而其中 primarySources\r\n这个可变参数的描述有点疑惑，其实primarySources参数接收的是被@EnableAutoConfiguration（或@SpringBootApplication）标注的类，其核心作用是：\r\n\r\n作为自动配置的触发点：告知 Spring Boot\r\n从该类的注解中获取组件扫描范围、自动配置规则等信息。\r\n确定基础包路径：该类所在的包会被@AutoConfigurationPackage注册为自动配置的基础扫描路径（参考前文AutoConfigurationPackages的解析）。\r\n\r\n我们来做一个实验，在启动类目录的同级下，再建一个如下SpringBootWebSecondApplication类\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootWebSecondApplication &#123;&#125;\r\n标记上@SpringBootApplication注解，然后，改写SpringBootWebPart1Application原来的启动类\r\npublic class SpringBootWebPart1Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringBootWebSecondApplication.class, args);    &#125;&#125;\r\n项目跑起来是没有任何问题的，并完成自动配置，因此，决定 Spring Boot\r\n启动的入口类并不是一定是 main 方法所在类，而是直接或间接被\r\n@EnableAutoConfiguration\r\n标注的类。即使main方法所在类未被@SpringBootApplication标注，只要SpringApplication.run()传入的primarySources是被@EnableAutoConfiguration标注的类，应用仍可正常启动。\r\n\r\n\r\nimage-20250620171538976\r\n\r\n这是因为，Spring Boot\r\n的启动逻辑仅依赖primarySources中的类是否携带@EnableAutoConfiguration，而main方法仅作为\r\nJava 程序的入口，二者无直接关联。\r\nprimarySources类所在的包会成为组件扫描的默认基础包，等价于@ComponentScan未指定basePackages时的行为。Spring\r\nBoot\r\n启动时候会自动扫描com.example.myapp及其子包下的@Component、@Service等组件。然后primarySources类上的@EnableAutoConfiguration会触发AutoConfigurationImportSelector加载spring.factories中的自动配置类。若传入的类未标注该注解，自动配置机制将失效。\r\n其实发现源码中，还有一个方法addPrimarySources，发现可以调用\r\naddPrimarySources 方法来追加额外的\r\nprimarySources，所以，primarySources支持传入多个类（通过可变参数），多个类的包路径会被合并为组件扫描范围，多个类上的@EnableAutoConfiguration配置会被合并（如exclude参数）\r\npublic void addPrimarySources(Collection&lt;Class&lt;?&gt;&gt; additionalPrimarySources) &#123;        this.primarySources.addAll(additionalPrimarySources);    &#125;\r\n构造参数中，这里将 primarySources 参数转换为\r\nLinkedHashSet 集合，并赋值给SpringApplication\r\n的私有成员变量\r\nSet&lt;Class&lt;?&gt;&gt; primarySources。\r\nthis.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\r\nSpring\r\nBoot项目启动的初始化部分\r\n这次再来看初始化的部分，只挑重要的初始化部分步骤就是如下部分\r\npublic SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;    // 设置默认属性    this.addCommandLineProperties = true;    this.headless = true;    this.applicationContextFactory = ApplicationContextFactory.DEFAULT;        // 保存主源类（通常是@SpringBootApplication标注的类）    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));        // 推断应用类型（SERVLET、REACTIVE或NONE）    this.webApplicationType = WebApplicationType.deduceFromClasspath();        // 从spring.factories加载初始化器和监听器    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));        // 推断main方法所在的类    this.mainApplicationClass = deduceMainApplicationClass();&#125;\r\n确定 Web 应用类型：\r\nthis.webApplicationType = WebApplicationType.deduceFromClasspath();\r\n这里调用了 WebApplicationType\r\n的deduceFromClasspath 方法来进行 Web 应用类型的推断\r\n通过检查类路径中的关键类（如javax.servlet.Servlet或org.springframework.web.reactive.DispatcherHandler），自动判断应用类型：\r\n\r\nSERVLET：传统 Servlet Web 应用（默认）\r\nREACTIVE：响应式 Web 应用\r\nNONE：非 Web 应用\r\n\r\n继续翻看其 WebApplicationType 的源码：\r\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.springframework.boot;import org.springframework.aot.hint.MemberCategory;import org.springframework.aot.hint.RuntimeHints;import org.springframework.aot.hint.RuntimeHintsRegistrar;import org.springframework.aot.hint.TypeReference;import org.springframework.util.ClassUtils;public enum WebApplicationType &#123;    NONE,    SERVLET,    REACTIVE;    private static final String[] SERVLET_INDICATOR_CLASSES = new String[]&#123;&quot;jakarta.servlet.Servlet&quot;, &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;&#125;;    private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.web.servlet.DispatcherServlet&quot;;    private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.springframework.web.reactive.DispatcherHandler&quot;;    private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;;    static WebApplicationType deduceFromClasspath() &#123;        if (ClassUtils.isPresent(&quot;org.springframework.web.reactive.DispatcherHandler&quot;, (ClassLoader)null) &amp;&amp; !ClassUtils.isPresent(&quot;org.springframework.web.servlet.DispatcherServlet&quot;, (ClassLoader)null) &amp;&amp; !ClassUtils.isPresent(&quot;org.glassfish.jersey.servlet.ServletContainer&quot;, (ClassLoader)null)) &#123;            return REACTIVE;        &#125; else &#123;            for(String className : SERVLET_INDICATOR_CLASSES) &#123;                if (!ClassUtils.isPresent(className, (ClassLoader)null)) &#123;                    return NONE;                &#125;            &#125;            return SERVLET;        &#125;    &#125;    static class WebApplicationTypeRuntimeHints implements RuntimeHintsRegistrar &#123;        public void registerHints(RuntimeHints hints, ClassLoader classLoader) &#123;            for(String servletIndicatorClass : WebApplicationType.SERVLET_INDICATOR_CLASSES) &#123;                this.registerTypeIfPresent(servletIndicatorClass, classLoader, hints);            &#125;            this.registerTypeIfPresent(&quot;org.glassfish.jersey.servlet.ServletContainer&quot;, classLoader, hints);            this.registerTypeIfPresent(&quot;org.springframework.web.reactive.DispatcherHandler&quot;, classLoader, hints);            this.registerTypeIfPresent(&quot;org.springframework.web.servlet.DispatcherServlet&quot;, classLoader, hints);        &#125;        private void registerTypeIfPresent(String typeName, ClassLoader classLoader, RuntimeHints hints) &#123;            if (ClassUtils.isPresent(typeName, classLoader)) &#123;                hints.reflection().registerType(TypeReference.of(typeName), new MemberCategory[0]);            &#125;        &#125;    &#125;&#125;\r\n我们发现，WebApplicationType\r\n是一个定义了可能的Web应用类型的枚举类，这一判断将直接影响\r\n\r\n应用上下文类型：决定创建\r\nServletWebServerApplicationContext（Servlet）、ReactiveWebServerApplicationContext（响应式）或普通\r\nApplicationContext（非 Web）。\r\n自动配置规则：不同类型的应用会加载不同的自动配置类（如\r\nWebMvcAutoConfiguration 或 WebFluxAutoConfiguration）。\r\n服务启动方式：确定是否启动嵌入式 Web 服务器（如\r\nTomcat、Netty）。\r\n\r\n上来就是一堆常量，这些常量其实就是判断Web应用类型的指示器功能，起到存在则是的作用\r\nprivate static final String[] SERVLET_INDICATOR_CLASSES = &#123;    &quot;jakarta.servlet.Servlet&quot;,     &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;&#125;;private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.web.servlet.DispatcherServlet&quot;;private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.springframework.web.reactive.DispatcherHandler&quot;;\r\n\r\nSERVLET_INDICATOR_CLASSES：\r\n\r\nServlet：所有 Servlet 容器（如\r\nTomcat）的基础接口，存在即表示可能为 Servlet 应用。\r\nConfigurableWebApplicationContext：Spring Web\r\n上下文的标准接口，标志着 Web 相关配置的存在。\r\n\r\nWEBMVC_INDICATOR_CLASS：\r\n\r\nDispatcherServlet 是 Spring MVC\r\n的核心控制器，存在即表示传统 Web MVC 应用。\r\n\r\nWEBFLUX_INDICATOR_CLASS：\r\n\r\nDispatcherHandler 是 Spring WebFlux\r\n的核心处理器，存在即表示响应式 Web 应用。\r\n\r\n\r\ndeduceFromClasspath ()实现了推断web应用类型的逻辑，分布推断的流程如下：\r\n\r\n响应式应用优先原则：\r\n\r\n检查是否存在\r\norg.springframework.web.reactive.DispatcherHandler（响应式核心处理器）。\r\n同时确保不存在 DispatcherServlet（Servlet Web MVC\r\n核心）和 ServletContainer（Jersey 容器）。\r\n场景：当项目依赖\r\nspring-boot-starter-webflux 时，此条件成立。\r\n\r\nServlet 应用的必要条件：\r\n\r\n验证SERVLET_INDICATOR_CLASSES中的所有类是否存在：\r\n\r\njakarta.servlet.Servlet：Servlet 规范核心接口。\r\norg.springframework.web.context.ConfigurableWebApplicationContext：Web\r\n上下文接口。\r\n\r\n场景：引入 spring-boot-starter-web\r\n后，这两个类必然存在\r\n\r\n非 Web 应用的判定：\r\n\r\n若上述条件均不满足（如仅包含业务依赖，无 Web 相关库），则判定为\r\nNONE\r\n\r\n\r\n而deduceFromClasspath()方法中调用了ClassUtils.isPresent ()方法实现了类存在性检查，该工具类方法就是通过反射创建指定的类，根据在创建过程中是否抛出异常来判断该类是否存在。\r\npublic static boolean isPresent(String className, @Nullable ClassLoader classLoader) &#123;        try &#123;            forName(className, classLoader);            return true;        &#125; catch (IllegalAccessError err) &#123;            throw new IllegalStateException(&quot;Readability mismatch in inheritance hierarchy of class [&quot; + className + &quot;]: &quot; + err.getMessage(), err);        &#125; catch (Throwable var4) &#123;            return false;        &#125;    &#125;\r\n\r\n通过 Class.forName() 尝试加载类，若抛出\r\nClassNotFoundException 或\r\nNoClassDefFoundError，则认为类不存在。\r\nfalse\r\n参数表示不初始化类，仅验证类是否存在，避免触发静态代码块或构造函数。\r\n\r\n判断完Web 应用类型之后，就决定了\r\ncreateApplicationContext()\r\n方法创建的上下文类型，实现了类型推断\r\n加载应用初始化器（ApplicationContextInitializer）：\r\nthis.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\r\n这个就涉及到上面自动配置哪里讲的了，从META-INF/spring.factories加载所有实现ApplicationContextInitializer的类，用于在上下文刷新前进行自定义配置。\r\n加载流程如下\r\n\r\n首先，从 spring.factories\r\n读取，getSpringFactoriesInstances() 方法扫描类路径下所有\r\nMETA-INF/spring.factories，提取\r\nApplicationContextInitializer\r\n的实现类。加载内置的初始化器，Spring的内置初始化器有很多，分别负责不同的作用\r\n然后通过反射创建实例，按 @Order 注解或\r\nOrdered 接口排序。\r\n之后在 prepareContext() 阶段调用：\r\nprivate void prepareContext(ConfigurableApplicationContext context, ...) &#123;    // ...（其他准备上下文的逻辑，比如加载环境、配置日志等）        // 关键调用：应用所有的 ApplicationContextInitializer 初始化器    applyInitializers(context);        // ...（后续继续准备上下文的逻辑，比如加载 bean 定义等）&#125;\r\n在这一步中，prepareContext 是\r\nSpringApplication\r\n中负责「准备应用上下文」的核心方法之一，在 Spring Boot\r\n启动流程里，会在创建好 ConfigurableApplicationContext（如\r\nAnnotationConfigServletWebServerApplicationContext\r\n等）后，执行一系列准备动作，applyInitializers(context)\r\n就是其中一步，目的是让所有注册好的\r\nApplicationContextInitializer\r\n有机会在上下文正式刷新（refresh）前，对其做自定义初始化配置。\r\n可以简单理解为：Spring Boot 先把上下文的 “壳”\r\n建好，然后在真正往里面加载 Bean、刷新容器之前，让各种初始化器先 “装饰”\r\n一下这个上下文，给后续流程提前设置好一些参数、环境等。\r\n之后\r\nprotected void applyInitializers(ConfigurableApplicationContext context) &#123;    // 遍历所有获取到的 ApplicationContextInitializer 初始化器    for (ApplicationContextInitializer initializer : getInitializers()) &#123;        // 解析 initializer 所要求的上下文类型（泛型解析）        // 比如有的 Initializer 可能限定只能处理 ServletWebServerApplicationContext，这里就会解析出对应的类型        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(            initializer.getClass(), ApplicationContextInitializer.class);                // 断言当前上下文 context 是符合 initializer 要求的类型        // 如果类型不匹配，会抛出异常，阻止启动，避免初始化器执行时报错        Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer&quot;);                // 真正执行初始化逻辑，把当前上下文交给 initializer 去“初始化”        initializer.initialize(context);    &#125;&#125;\r\n\r\n从 SpringApplication 中获取所有已经注册好的\r\nApplicationContextInitializer\r\n列表。这些初始化器可能来自：\r\n\r\nspring.factories 中配置的默认实现（Spring Boot\r\n自身或第三方框架注册的）；\r\n开发者通过 SpringApplication.addInitializers(...)\r\n手动添加的自定义实现。\r\n\r\n利用 Spring 的 GenericTypeResolver 工具，解析\r\nApplicationContextInitializer 实现类上的泛型参数。\r\n用 Spring 的 Assert 断言工具，检查当前要初始化的\r\ncontext（实际的应用上下文对象，如\r\nServletWebServerApplicationContext）是否是\r\nrequiredType 及其子类 / 实现类。\r\n如果类型不匹配，直接抛出异常，让开发者能快速发现\r\n“某个初始化器期望的上下文类型和实际创建的上下文不兼容” 问题\r\n回调初始化器的 initialize\r\n方法，把当前准备好的应用上下文对象传递进去，让初始化器执行自定义逻辑。\r\n比如有的初始化器可能会往上下文里添加自定义的\r\nPropertySource（属性源）、提前注册一些特殊的 Bean\r\n定义，或者设置上下文的一些环境变量等，为后续 Spring\r\n容器正式刷新（refresh）做准备。\r\n\r\n\r\nApplicationContextInitializer 是 Spring\r\n框架中的一个接口，是 Spring\r\n框架提供的一个强大扩展点，它的主要作用是在Spring容器刷新之前初始化\r\nConfigurableApplicationContext，允许开发者在 Spring\r\n容器刷新（refresh()）之前\r\n对应用上下文进行自定义配置。这个刷新时机往细致了说就是，在\r\nSpringApplication.run(...) 流程中，创建完\r\nConfigurableApplicationContext 后，执行\r\nrefresh 之前。也就是说，此时 Bean\r\n还没开始加载、创建，但是上下文的 “基础环境”（如\r\nEnvironment、BeanFactory\r\n等）已经准备好，初始化器可以在这个阶段对上下文做一些 “前期定制”。\r\n@FunctionalInterfacepublic interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; &#123;    void initialize(C applicationContext);&#125;\r\n\r\nSpringApplication.run()\r\n方法中，prepareContext() 阶段调用初始化器（早于 Bean\r\n定义加载和自动配置）。\r\n接收\r\nConfigurableApplicationContext，可修改上下文配置（如添加属性源、注册\r\nBean 等）。\r\n\r\n这样整套流程下来，你就能明白：ApplicationContextInitializer\r\n是 Spring Boot\r\n留给开发者（以及框架自身）在容器启动最早期介入、定制上下文的 “钩子”，而\r\nprepareContext + applyInitializers\r\n就是触发这些钩子的关键逻辑\r\n，通过泛型解析、类型校验、遍历执行，确保各种初始化器能安全、有序地对应用上下文做初始化配置。\r\n注册应用监听器（ApplicationListener）：\r\nthis.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\r\n加载所有实现ApplicationListener的类，监听应用生命周期事件（如启动、失败、停止等）。\r\nApplicationListener 是 Spring\r\n框架提供的一个事件监听机制，它是Spring\r\n应用内部的事件驱动机制，通常被用于监控应用内部的运行状况。其实现的原理是\r\n观察者设计模式，该设计模式的初衷是为了实现系统业务逻辑之间的解耦，从而提升系统的可扩展性和可维护性\r\n我不熟监听器，不说了\r\n确定主应用类：\r\nthis.mainApplicationClass = deduceMainApplicationClass();\r\n通过分析调用栈，找出包含main方法的类，用于后续日志和上下文信息。\r\n这是Spring Boot启动的最后一步，调用 SpringApplication 的\r\ndeduceMainApplicationClass 方法来进行入口类的推断：\r\nprivate Class&lt;?&gt; deduceMainApplicationClass() &#123;        return (Class)((Optional)StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE).walk(this::findMainClass)).orElse((Object)null);    &#125;\r\nSpring Boot 启动后，会在日志里输出类似这样的内容：\r\nStarted DemoApplication in 2.345 seconds (JVM running for 3.456)\r\n这里的 DemoApplication 就是\r\n主应用类（即 main\r\n方法所在类）。它的作用包括：\r\n\r\n日志标识：启动日志里明确标注\r\n“哪个类触发了启动”，方便排查问题。\r\n上下文关联：某些自动配置（比如\r\nSpringApplicationAdminJmxAutoConfiguration）会基于主类生成\r\nMBean 名称，用于 JMX 监控。\r\n框架扩展：第三方库（如 APM\r\n工具、自定义启动器）可能需要获取主类，做链路追踪、启动增强等。\r\n\r\n那么问题来了，deduceMainApplicationClass\r\n方法是如何找到其主类的呢？\r\n核心逻辑分两步：\r\n\r\n用 StackWalker 遍历调用栈\r\n\r\nStackWalker 是 Java 9+ 引入的\r\nAPI，能高效遍历当前线程的调用栈，且支持保留类引用（RETAIN_CLASS_REFERENCE\r\n选项）。StackWalker 是专门为 高效遍历栈帧\r\n设计的 API，通过 StackFrame.getDeclaringClass() 直接获取\r\nClass，无需反射。这让 Spring Boot\r\n的启动流程更高效、更简洁。\r\nwalk(this::findMainClass)：把调用栈交给\r\nfindMainClass 方法处理，找到符合条件的类。\r\n\r\nfindMainClass 筛选主类\r\n\r\nfindMainClass\r\n是一个方法引用，实际逻辑是遍历调用栈，找 包含 main\r\n方法的类：\r\nprivate Optional&lt;Class&lt;?&gt;&gt; findMainClass(Stream&lt;StackWalker.StackFrame&gt; stackFrames) &#123;    return stackFrames        // 过滤出包含 &quot;main&quot; 方法的栈帧        .filter(frame -&gt; frame.getMethodName().equals(&quot;main&quot;))        // 提取对应的类        .map(StackWalker.StackFrame::getDeclaringClass)        // 只保留第一个匹配的（因为 main 方法唯一）        .findFirst();&#125;\r\n调用栈里，main 方法所在类的栈帧会包含\r\nmethodName = \"main\"，通过过滤、提取、去重，就能定位到主应用类。\r\n\r\n\r\n所以说，虽然 Spring Boot\r\n能自动推断主类，但某些场景（比如框架封装、多主类启动）可能需要手动指定。可以通过以下方式实现：\r\nSpringApplication app = new SpringApplication(MyMainClass.class);app.setMainApplicationClass(MyMainClass.class); // 手动设置主类app.run(args);\r\n这种方式会跳过 deduceMainApplicationClass\r\n的自动推断，强制使用指定的类作为主应用类\r\n所以说，deduceMainApplicationClass 是 Spring Boot\r\n启动流程的 “收尾环节”，通过 StackWalker\r\n遍历调用栈，精准定位到 main\r\n方法所在类。它的设计既保证了\r\n高效性（避免全栈遍历），又能\r\n直接关联类引用（无需反射），让主类识别逻辑简洁又可靠\r\nSpring Boot\r\n应用程序的启动与生命周期加载机制\r\n这一部分，如果你没有看 Spring Boot part18-生命周期监听与9大事件\r\n，那就别往下看了\r\n在上面，我们提到了如下内容\r\n@SpringBootApplication\r\n\r\n就是：@Configuration ，容器中的组件，配置类。spring ioc\r\n启动就会加载创建这个类对象\r\n\r\n@EnableAutoConfiguration: 开启自动配置\r\n@AutoConfigurationPackage :\r\n扫描主程序包：加载自己的组件\r\n\r\n利用 @Import(AutoConfigurationPackages.Registrar.class)\r\n想要给容器中导入组件。\r\n把主程序所在的包的所有组件导入进来。\r\n为什么 SpringBoot 默认只扫描主程序所在的包及其子包\r\n\r\n@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载\r\nstarter 导入的组件\r\nList&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())        .getCandidates();\r\n扫描 SPI 文件:\r\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\r\n@ComponentScan\r\n组件扫描：排除一些组件（哪些不要）\r\n排除前面已经扫描进来的 配置类、和 自动配置类 。\r\n@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)\r\n当调用 SpringApplication.run(MyApp.class, args)\r\n时，核心流程如下：\r\npublic ConfigurableApplicationContext run(String... args) &#123;        Startup startup = SpringApplication.Startup.create();        if (this.properties.isRegisterShutdownHook()) &#123;            shutdownHook.enableShutdownHookAddition();        &#125;        // 2. 创建并配置引导上下文（BootstrapContext）        DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();        ConfigurableApplicationContext context = null;        this.configureHeadlessProperty();        // 5. 获取并启动所有SpringApplicationRunListener        // 这一步会触发starting()事件        SpringApplicationRunListeners listeners = this.getRunListeners(args);        listeners.starting(bootstrapContext, this.mainApplicationClass);        try &#123;            // 6. 封装命令行参数            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);            // 7. 准备环境（包括配置文件加载、属性源处理）            // 触发environmentPrepared()事件            ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);            Banner printedBanner = this.printBanner(environment);            // 10. 创建应用上下文（根据应用类型选择不同的容器实现）            context = this.createApplicationContext();            context.setApplicationStartup(this.applicationStartup);             // 12. 准备上下文（加载主配置类、应用初始化器）            // 触发contextPrepared()和contextLoaded()事件            prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);            // 13. 刷新上下文（核心IoC容器初始化：Bean定义加载、实例化、依赖注入）            refreshContext(context);            this.afterRefresh(context, applicationArguments);            startup.started();            if (this.properties.isLogStartupInfo()) &#123;                (new StartupInfoLogger(this.mainApplicationClass, environment)).logStarted(this.getApplicationLog(), startup);            &#125;            listeners.started(context, startup.timeTakenToStarted());            this.callRunners(context, applicationArguments);        &#125; catch (Throwable ex) &#123;            throw this.handleRunFailure(context, ex, listeners);        &#125;\r\n我们在这之后，就在 part18 详细展开讲了 Spring Boot 生命周期过程，其中\r\nioc\r\n容器刷新部分也分为12小步，前些步都是工厂的内容，后面步骤都是其中处理组件的内容\r\n@Overridepublic void refresh() throws BeansException, IllegalStateException &#123;    // 1. 加锁，确保刷新过程互斥执行    this.startupShutdownLock.lock();    try &#123;        // 记录当前刷新线程        this.startupShutdownThread = Thread.currentThread();        // 2. 启动上下文刷新的性能监控        StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;);        // 3. 环境准备：设置启动时间、清除缓存、验证必要属性        prepareRefresh();        // 4. 获取工厂        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // 5. 配置 BeanFactory 的基本属性（类加载器、表达式解析器等），准备工厂        prepareBeanFactory(beanFactory);        try &#123;            // 6. 子类扩展点：允许子类对 BeanFactory 进行额外配置            postProcessBeanFactory(beanFactory);            // 7. 执行 BeanFactoryPostProcessor（处理 Bean 定义）            invokeBeanFactoryPostProcessors(beanFactory);                        // 8. 注册 BeanPostProcessor（处理 Bean 实例）            registerBeanPostProcessors(beanFactory);            // 9. 初始化国际化消息源            initMessageSource();            // 10. 初始化事件广播器（用于发布事件）            initApplicationEventMulticaster();            // 11. 子类扩展点：初始化特殊 Bean（如 Web 容器）            onRefresh();            // 12. 注册事件监听器            registerListeners();            // 13. 实例化所有非懒加载的单例 Bean（核心步骤），也就是在这一步，造组件的            finishBeanFactoryInitialization(beanFactory);            // 14. 完成刷新：清除资源缓存、发布 ContextRefreshedEvent 事件            finishRefresh();        &#125;\r\n进去到invokeBeanFactoryPostProcessors(beanFactory);中，在这里会提前的自动配置的功能导入进来，这里也是加载spi的时机，相当于导入了自动配置，所有的自动配置类都是在这一步自动扫描进去的，这里只是扫描，创建还在下面finishBeanFactoryInitialization(beanFactory)\r\n\r\n\r\nimage-20250621174108662\r\n\r\n在finishBeanFactoryInitialization(beanFactory)中，完成了组件的最终创建和初始化，相关代码如下\r\nString[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);for (String weaverAwareName : weaverAwareNames) &#123;    beanFactory.getBean(weaverAwareName, LoadTimeWeaverAware.class);&#125;\r\n\r\n提前初始化实现了LoadTimeWeaverAware接口的 Bean，这些\r\nBean 需要在类加载阶段进行 AOP 织入（例如 AspectJ 的\r\nLTW）。通过getBean()强制实例化这些\r\nBean，确保它们的LoadTimeWeaver在类加载前准备就绪。\r\n\r\nbeanFactory.preInstantiateSingletons();\r\n\r\n遍历所有非懒加载的单例 Bean 定义，并按以下顺序创建它们：\r\n\r\n优先创建实现了PriorityOrdered接口的 Bean。\r\n再创建实现了Ordered接口的 Bean。\r\n最后创建剩余的普通 Bean。\r\n\r\n\r\n这样，我们的Spring Boot\r\n生命周期过程就和自动配置，启动过程全部连接起来了\r\n\r\n\r\nimage-20250621171858227\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","源码分析"]},{"title":"Spring Boot part18-整合JUnit5进行测试","url":"/posts/22150.html","content":"Spring Boot 整合 JUnit5\r\n进行单元测试\r\nSpringBoot 提供⼀系列测试⼯具集及注解⽅便我们进⾏测试。\r\nSpring Test 与\r\nJUnit等其他测试框架结合起来，提供了便捷高效的测试手段。而 Spring Boot\r\nTest 是在 Spring Test 之上的再次封装，增加了切片测试，增强了 mock\r\n能力。\r\nspring-boot-test提供核⼼测试能⼒，spring-boot-test-autoconfigure提供测试的⼀些⾃动配置\r\n我们只需要导⼊ spring-boot-starter-test 即可整合测试\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\r\nSpring Boot Test 基于 spring-boot-starter-test\r\n提供了丰富的测试工具，支持从单元测试到端到端测试的全流程覆盖。其测试体系可分为三大类：\r\n\r\n单元测试：一般面向方法，编写一般业务代码时，聚焦代码逻辑进行的测试，测试单个组件（如方法、类）的行为，隔离外部依赖。\r\n\r\n通过 Mockito\r\n模拟外部依赖（如数据库、服务调用）。\r\n依赖 JUnit 5 的 @Test 注解。\r\n\r\n切片测试：一般面向难于测试的边界功能，介于单元测试和功能测试之间。测试特定组件或层，部分启动\r\nSpring 容器，减少测试依赖。\r\n\r\n比单元测试更接近真实场景，但只加载必要的组件。\r\n通过 Spring Test 提供的切片注解（如\r\n@WebMvcTest、@DataJpaTest）实现。\r\n\r\n功能测试：测试完整业务流程，验证系统各组件的协同工作，同时也可以使用切面测试中的\r\nmock 能力，推荐使用。\r\n\r\n加载完整 Spring 容器，可能使用真实数据库或测试替身（Test\r\nDouble）。\r\n通过 @SpringBootTest\r\n注解启动应用上下文。\r\n\r\n\r\nspring-boot-starter-test默认提供了以下库供我们测试使⽤：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n库\r\n主要用途\r\n典型场景\r\n\r\n\r\n\r\n\r\nJUnit 5\r\n基础测试框架\r\n单元测试、参数化测试、生命周期管理\r\n\r\n\r\nMockito\r\nMock 对象与行为验证\r\n隔离外部依赖（如数据库、第三方服务）\r\n\r\n\r\nAssertJ\r\n流式断言（更易读的断言语法）\r\n替代 JUnit 原生 assertEquals\r\n\r\n\r\nHamcrest\r\n提供匹配器（Matcher）\r\n复杂条件断言（如 allOf、hasItem）\r\n\r\n\r\nJSONassert\r\nJSON 内容断言\r\nREST API 返回的 JSON 数据验证\r\n\r\n\r\nJsonPath\r\nJSON 路径表达式查询\r\n提取和验证 JSON 中的特定字段（如 $.users[0].name）\r\n\r\n\r\n\r\n核心注解详解\r\n测试运行与 Spring 容器相关\r\n@SpringBootTest\r\n@SpringBootTest 是 Spring Boot\r\n提供的核心注解，适用于大多数集成测试。它的核心功能是启动完整的 Spring\r\n上下文，模拟一个真实的应用程序环境，使得开发者可以在接近生产的环境下对应用进行测试。\r\n当在测试类中标注 @SpringBootTest\r\n注解时，在运行测试阶段，Spring Boot\r\n会自动完整启动整个主程序。这意味着测试过程将包含 Spring Boot\r\n应用的全部配置。例如，在一个包含数据库操作的 Spring Boot\r\n应用中，使用@SpringBootTest注解后，测试过程会自动加载数据源配置，建立数据库连接，从而可以测试数据库相关的业务逻辑。\r\n首先，测试类也必须在主程序所在的包及其子包，标注了@SpringBootTest注解意味着，该测试可以具备测试\r\nSpring Boot 应用容器中的所有组件的功能\r\n@SpringBootTest注解提供如下属性，用于灵活控制测试环境的启动方式。\r\n\r\nclasses：指定启动 Spring\r\n应用上下文的主配置类，通常是 Spring Boot\r\n应用的主类。若项目只有一个主类，该属性可省略，Spring Boot\r\n会自动扫描；若存在多个候选主类，则必须显式指定，例如@SpringBootTest(classes = MyApplication.class)。\r\nwebEnvironment：定义 Web\r\n测试环境，有四个可选值。\r\n\r\nMOCK（默认值）：使用 Spring MockMVC 进行 Web 测试，不启动真实的\r\nServlet 容器，适合测试 Web 层逻辑，如控制器方法。\r\nRANDOM_PORT：启动一个真实的 Servlet\r\n容器，并分配一个随机的端口，可以通过@LocalServerPort注解获取该端口，用于测试需要真实网络交互的场景。\r\nDEFINED_PORT：启动真实的 Servlet\r\n容器，并使用server.port配置中定义的端口，若配置中未指定端口，启动会失败。\r\nNONE：不加载 Web 应用上下文，适用于非 Web\r\n应用的测试，如仅测试数据访问层代码。\r\n\r\n\r\n@SpringBootTestpublic class MyApplicationTests &#123;    @Autowired    private SomeService someService;   // 自动注入任意组件即可测试    @Test    public void testServiceMethod() &#123;        assertNotNull(someService);    &#125;&#125;\r\n@WebMvcTest\r\n@WebMvcTest 是 Spring Boot\r\n提供的一个强大注解，专门用于对 Spring MVC 控制器进行切片测试（Slice\r\nTest）。它能够精准加载 Web 层（通常是 Controller\r\n层）组件相关的配置，而不需要启动完整的应用上下文，适合测试请求到\r\nController 的映射和验证等。\r\n当你在测试类上标注 @WebMvcTest 注解时，Spring Boot\r\n会自动执行以下操作：\r\n\r\n仅加载 Web\r\n层组件：只加载与控制器（Controller）、控制器通知（ControllerAdvice）、过滤器（Filter）、WebMvcConfigurer、HandlerMethodArgumentResolver\r\n相关的 Bean，其他组件（如 Service、Repository）不会被加载。\r\n自动配置 Mock 环境：\r\n\r\n自动配置 MockMvc Bean，用于模拟 HTTP\r\n请求和验证响应。\r\n自动应用 @ControllerAdvice\r\n类，处理异常和返回统一格式。\r\n自动配置 JSON 序列化和反序列化支持。\r\n\r\n支持依赖注入：可以通过 @Autowired 注入\r\nMockMvc 或其他 Web 层相关 Bean。\r\n注意：@WebMvcTest使用\r\nMockMvc，不会启动 Servlet 容器\r\n\r\n@WebMvcTest 注解主要有以下两个常用属性：\r\n\r\nvalue/ controllers：指定要测试的控制器类\r\n@WebMvcTest(UserController.class)public class UserControllerTest &#123; ... &#125;\r\n如果省略该属性，Spring Boot 会尝试查找并加载所有的控制器\r\nBean。\r\nincludeFilters/ excludeFilters：通过\r\n@ComponentScan.Filter 自定义包含或排除的 Bean\r\n@WebMvcTest(    controllers = UserController.class,    includeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = CustomValidator.class))public class UserControllerTest &#123; ... &#125;\r\n\r\n测试示例：以测试一个处理用户请求的控制器为例子\r\n@WebMvcTest(UserController.class)public class UserControllerTest &#123;    // 当使用@WebMvcTest注解时，Spring会自动配置并注入MockMvc实例    @Autowired    private MockMvc mockMvc;    // 创建UserService的Mock对象，替换Spring上下文中的真实UserService Bean    @MockBean    private UserService userService;    @Test    public void testGetUserById() throws Exception &#123;        // 准备测试数据        UserDTO user = new UserDTO(1L, &quot;John Doe&quot;, &quot;john@example.com&quot;);                // Mock 服务方法        Mockito.when(userService.getUserById(1L)).thenReturn(user);                // 执行请求并验证结果        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/api/users/1&quot;))               .andExpect(status().isOk())               .andExpect(jsonPath(&quot;$.id&quot;).value(1L))               .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;John Doe&quot;));                // 验证服务方法被调用        Mockito.verify(userService, Mockito.times(1)).getUserById(1L);    &#125;&#125;\r\n@DataJpaTest\r\n和@JdbcTest\r\n@DataJpaTest 是专门为 JPA 相关测试提供的注解，它自动配置\r\nJPA 测试环境，专注于测试 JPA\r\n仓库（Repository）层。它会配置一个内存数据库（如 H2），并只加载与 JPA\r\n相关的 Bean。会自动配置\r\nEntityManager、DataSource 等JPA\r\n基础设施，而且支持通过 data.sql 或 schema.sql\r\n初始化测试数据\r\n假设我们有一个 UserRepository 接口\r\n@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;    Optional&lt;User&gt; findByEmail(String email);&#125;\r\n使用 @DataJpaTest 进行测试\r\n@DataJpaTestpublic class UserRepositoryTest &#123;    @Autowired    private UserRepository userRepository;    @Test    public void testFindByEmail() &#123;        // 准备测试数据        User user = new User();        user.setEmail(&quot;test@example.com&quot;);        userRepository.save(user);        // 执行查询        Optional&lt;User&gt; result = userRepository.findByEmail(&quot;test@example.com&quot;);        // 验证结果        assertTrue(result.isPresent());        assertEquals(&quot;test@example.com&quot;, result.get().getEmail());    &#125;&#125;\r\n而@JdbcTest专注于测试基于 JDBC\r\n的数据访问层，提供更底层的数据库操作测试能力，一般用于测试传统 JDBC\r\n模板（JdbcTemplate）操作，验证 SQL\r\n查询语句的正确性，测试存储过程和自定义数据访问逻辑等，它也是默认使用 H2\r\n内存数据库，会自动配置\r\nDataSource、JdbcTemplate 等 JDBC\r\n基础设施，但是不会加载 JPA 相关的 Bean\r\n假设我们有一个使用 JdbcTemplate 的数据访问类\r\n@Repositorypublic class UserJdbcRepository &#123;    private final JdbcTemplate jdbcTemplate;    @Autowired    public UserJdbcRepository(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public int count() &#123;        return jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM users&quot;, Integer.class);    &#125;&#125;\r\n使用 @JdbcTest 进行测试\r\n@JdbcTestpublic class UserJdbcRepositoryTest &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Autowired    private UserJdbcRepository userJdbcRepository;    @Test    public void testCount() &#123;        // 初始化测试数据        jdbcTemplate.execute(&quot;CREATE TABLE users (id SERIAL, name VARCHAR(100))&quot;);        jdbcTemplate.update(&quot;INSERT INTO users (name) VALUES (&#x27;John&#x27;)&quot;);        // 执行测试        int count = userJdbcRepository.count();        // 验证结果        assertEquals(1, count);    &#125;&#125;\r\n@RestClientTest\r\n客户端与 REST API 的交互测试至关重要。@RestClientTest 是\r\nSpring Boot 提供的一个专用注解，用于测试 REST 客户端组件（如\r\nRestTemplate、WebClient 或\r\n@RestClient），它能够创建一个轻量级测试环境，专注于验证客户端与外部服务的交互逻辑。\r\n它不会加载完整的 Spring 应用上下文，并且通过\r\n@AutoConfigureWebClient(registerRestTemplate = true)\r\n自动配置 RestTemplate 或\r\nWebClient，而且其中内部集成\r\nMockRestServiceServer 或 WebTestClient\r\n用于模拟 HTTP 响应\r\n例如，定义 WebClient 客户端，然后编写测试用例\r\n@Servicepublic class MyWebClient &#123;    private final WebClient webClient;    @Autowired    public MyWebClient(WebClient.Builder builder) &#123;        this.webClient = builder.baseUrl(&quot;https://api.example.com&quot;).build();    &#125;    public Mono&lt;User&gt; getUserById(Long id) &#123;        return webClient.get()                .uri(&quot;/users/&#123;id&#125;&quot;, id)                .retrieve()                .bodyToMono(User.class);    &#125;&#125;\r\n@RestClientTest(MyWebClient.class)public class MyWebClientTest &#123;    @Autowired    private MyWebClient client;    @Autowired    private WebTestClient webTestClient; // 用于模拟 WebClient 请求    @Test    public void testGetUserById() &#123;        // 准备模拟响应        User expectedUser = new User(1L, &quot;John Doe&quot;);                // 使用 WebTestClient 模拟服务器响应        webTestClient.mutate()                .responseTimeout(Duration.ofSeconds(10))                .build()                .get().uri(&quot;/users/1&quot;)                .exchange()                .expectStatus().isOk()                .expectBody(User.class).isEqualTo(expectedUser);        // 执行测试（使用真实 WebClient 调用）        StepVerifier.create(client.getUserById(1L))                .expectNextMatches(user -&gt;                     user.getId().equals(1L) &amp;&amp; user.getName().equals(&quot;John Doe&quot;))                .verifyComplete();    &#125;&#125;\r\n@JsonTest\r\n@JsonTest 用于测试 JSON 序列化和反序列化过程。它会加载\r\nJSON 相关的 Bean，如 ObjectMapper，并且根据项目依赖自动配置\r\nJSON 处理库\r\n测试对象序列化\r\n@JsonTestpublic class UserSerializationTest &#123;    @Autowired    private JacksonTester&lt;User&gt; json;    @Test    public void testSerializeUser() throws Exception &#123;        // 创建测试对象        User user = new User(1L, &quot;John Doe&quot;, LocalDate.of(1990, 1, 1));        // 执行序列化测试        JsonContent&lt;User&gt; result = json.write(user);        // 验证 JSON 内容        assertThat(result).extractingJsonPathNumberValue(&quot;$.id&quot;).isEqualTo(1);        assertThat(result).extractingJsonPathStringValue(&quot;$.name&quot;).isEqualTo(&quot;John Doe&quot;);        assertThat(result).extractingJsonPathStringValue(&quot;$.birthDate&quot;).isEqualTo(&quot;1990-01-01&quot;);    &#125;&#125;\r\n测试 JSON 反序列化\r\n@JsonTestpublic class UserDeserializationTest &#123;    @Autowired    private JacksonTester&lt;User&gt; json;    @Test    public void testDeserializeUser() throws Exception &#123;        // 创建测试 JSON        String jsonContent = &quot;&quot;&quot;            &#123;                &quot;id&quot;: 1,                &quot;name&quot;: &quot;John Doe&quot;,                &quot;birthDate&quot;: &quot;1990-01-01&quot;            &#125;            &quot;&quot;&quot;;        // 执行反序列化测试        User user = json.parse(jsonContent).getObject();        // 验证对象属性        assertEquals(1L, user.getId());        assertEquals(&quot;John Doe&quot;, user.getName());        assertEquals(LocalDate.of(1990, 1, 1), user.getBirthDate());    &#125;&#125;\r\n总结：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n所属库\r\n作用\r\n\r\n\r\n\r\n\r\n@SpringBootTest\r\nSpring Boot Test\r\n启动完整 Spring 应用上下文，用于集成测试或端到端测试。可指定\r\nwebEnvironment（如 RANDOM_PORT）。\r\n\r\n\r\n@WebMvcTest\r\nSpring Boot Test\r\n仅加载 Spring MVC 组件（如 Controller），用于切片测试 Web 层。\r\n\r\n\r\n@DataJpaTest\r\nSpring Boot Test\r\n测试 JPA 数据访问层，自动配置内嵌数据库（如 H2）和 JPA 组件。\r\n\r\n\r\n@JdbcTest\r\nSpring Boot Test\r\n测试 JDBC 数据访问层，自动配置数据源和 JdbcTemplate。\r\n\r\n\r\n@RestClientTest\r\nSpring Boot Test\r\n测试 REST 客户端（如 RestTemplate），自动配置 HTTP 客户端。\r\n\r\n\r\n@JsonTest\r\nSpring Boot Test\r\n测试 JSON 序列化 / 反序列化，自动配置 Jackson 或 Gson。\r\n\r\n\r\n\r\nMock 与依赖注入相关\r\n@MockBean 和\r\n@SpyBean\r\n首先我们要知道 Spring Boot Test 中提到的 mock 是什么\r\nMock（模拟）是软件开发测试中的一种技术手段，指通过创建虚拟的对象来替代真实对象，以隔离测试目标、控制依赖行为。\r\n在 Spring Boot 测试中，Mockito 作为主流 Mock 框架。它将 Mockito\r\n创建的 Mock 对象注入 Spring 容器，替代原 Bean，而且测试结束后自动清理\r\nMock 对象，可以直接通过注解声明 Mock 需求\r\n当测试某个 Service 或 Controller 时，若其依赖其他 Bean（如\r\nDAO、外部服务），直接注入真实 Bean\r\n会导致各种一连串的配置，而且无法控制。Mockito 可创建 Mock\r\n对象替代真实 Bean，使测试聚焦于目标逻辑。\r\n这次再来讲 @MockBean\r\n估计我不用说大家都知道是什么意思了\r\n也就是说，@MockBean注解完全替换 Spring\r\n容器中的真实 Bean 为 Mock 对象，实现隔离外部依赖\r\n示例\r\n// 示例：测试UserController，模拟UserService依赖@WebMvcTest(UserController.class)class UserControllerTest &#123;        @MockBean  // 注入Mock对象替代真实UserService    private UserService userService;        @Autowired    private MockMvc mockMvc;  // Spring提供的HTTP请求模拟工具        @Test    void testGetUser() throws Exception &#123;        // 配置Mock行为：当调用userService.getUser(1)时返回指定用户        when(userService.getUser(1L)).thenReturn(            new User(1L, &quot;张三&quot;, &quot;admin&quot;)        );                // 发送HTTP请求并断言响应        mockMvc.perform(get(&quot;/users/1&quot;))            .andExpect(status().isOk())            .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;张三&quot;));                // 验证userService.getUser被调用一次        verify(userService, times(1)).getUser(1L);    &#125;&#125;\r\n而@SpyBean的作用正相反，它包装真实\r\nBean，保留原有行为\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n工具 / 注解\r\n作用范围\r\n实现方式\r\n典型场景\r\n\r\n\r\n\r\n\r\n@MockBean\r\nSpring 容器中的 Bean\r\n替换 Bean\r\n隔离 Service、Repository 等\r\n\r\n\r\n@SpyBean\r\nSpring 容器中的 Bean\r\n包装 Bean\r\n部分方法 Stub，保留其他真实逻辑\r\n\r\n\r\nMockito.mock()\r\n纯 Java 对象\r\n手动创建 Mock\r\n单元测试中隔离非 Spring 对象\r\n\r\n\r\nMockito.spy()\r\n纯 Java 对象\r\n手动创建 Spy\r\n单元测试中包装真实对象\r\n\r\n\r\n@Mock + @InjectMocks\r\nJUnit 单元测试\r\n结合 @ExtendWith(MockitoExtension.class)\r\n纯单元测试，不启动 Spring 容器\r\n\r\n\r\n\r\n@InjectMocks\r\n一句话，自动注入 Mock 对象到测试目标中\r\n当@InjectMocks标注在某个类上时，Mockito\r\n会创建该类的实例作为\r\n“被测试对象”，然后自动扫描目标类的字段，若字段被@Mock/@MockBean/@Spy/@SpyBean标注，则将对应的\r\nMock 对象注入；\r\n@SpringBootTestclass OrderControllerTest &#123;        @InjectMocks  // 注入被测试的Controller    private OrderController orderController;        @MockBean  // 模拟依赖的Service    private OrderService orderService;        @Test    void testCreateOrder() &#123;        // 配置Mock行为        when(orderService.createOrder(any(OrderDTO.class)))            .thenReturn(new Order(1L, &quot;20250621&quot;, OrderStatus.SUCCESS));                // 调用Controller方法（通过MockMvc发送请求）        // ... 省略请求模拟与断言逻辑    &#125;&#125;\r\n\r\norderController 实例由 Mockito\r\n创建，其内部依赖的orderService会被自动注入 Mock 对象；\r\n若目标类有多个构造器，Mockito 会优先注入参数最多的构造器（类似\r\nSpring 的构造器注入策略）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n作用对象\r\n核心功能\r\n\r\n\r\n\r\n\r\n@InjectMocks\r\n被测试的目标类\r\n自动将 Mock 对象注入到目标类中，创建目标类的实例\r\n\r\n\r\n@MockBean（Spring）\r\nSpring 容器中的 Bean\r\n在 Spring 容器中创建 Mock 对象，替代原 Bean\r\n\r\n\r\n@SpyBean（Spring）\r\nSpring 容器中的 Bean\r\n在 Spring 容器中创建 Spy 对象（部分 Mock，保留原 Bean\r\n的真实方法调用）\r\n\r\n\r\n\r\n@AutoConfigureMockMvc\r\n和@ImportAutoConfiguration\r\n首先，@AutoConfigureMockMvc 会自动配置 Spring MVC\r\n的MockMvc实例，用于测试 Controller 层的 HTTP\r\n请求处理逻辑，无需启动完整 Web 容器。当Web\r\n层切片测试（如@WebMvcTest）或功能测试中，需模拟 HTTP\r\n请求并验证响应结果需要使用。\r\n@WebMvcTest(HomeController.class)  // 仅测试指定Controller@AutoConfigureMockMvc  // 自动配置MockMvcclass HomeControllerTest &#123;        @Autowired    private MockMvc mockMvc;  // 自动注入配置好的MockMvc        @Test    void testHomePage() throws Exception &#123;        mockMvc.perform(get(&quot;/&quot;))  // 模拟GET请求               .andExpect(status().isOk())  // 断言响应状态码               .andExpect(content().string(containsString(&quot;欢迎&quot;)));  // 断言响应内容    &#125;&#125;\r\n若 Controller 依赖的 Service\r\n被@MockBean标注，@AutoConfigureMockMvc会自动将\r\nMock 对象注入到 Controller 中\r\n而@ImportAutoConfiguration就是手动导入 Spring Boot\r\n的自动配置类（AutoConfiguration），用于测试中按需加载特定配置，避免完整容器启动的开销。\r\n总结\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n所属库\r\n作用\r\n\r\n\r\n\r\n\r\n@MockBean\r\nSpring Boot Test\r\n替换 Spring 容器中的 Bean 为 Mock\r\n对象（Mockito），用于隔离外部依赖。\r\n\r\n\r\n@SpyBean\r\nSpring Boot Test\r\n创建真实 Bean 的 Spy 对象，监视其方法调用（Mockito）。\r\n\r\n\r\n@AutoConfigureMockMvc\r\nSpring Boot Test\r\n自动配置 MockMvc（Spring MVC 测试工具），用于模拟 HTTP 请求。\r\n\r\n\r\n@ImportAutoConfiguration\r\nSpring Boot Test\r\n手动导入特定的自动配置类，用于自定义测试环境。\r\n\r\n\r\n\r\n测试配置与环境相关\r\n@TestPropertySource\r\n为测试类指定额外的属性配置，覆盖默认配置文件（如application.properties）。\r\n@SpringBootTest@TestPropertySource(properties = &#123;    &quot;spring.datasource.url=jdbc:h2:mem:testdb&quot;,  // 内存数据库    &quot;app.feature.enabled=false&quot;                 // 禁用某个功能&#125;)class MyServiceTest &#123;    // 测试代码&#125;\r\n\r\nproperties：直接指定键值对（优先级最高）；\r\nlocations：指定额外的属性文件路径（如classpath:test.properties）。\r\n\r\n测试时属性加载顺序（从高到低）：\r\n\r\n@TestPropertySource 注解中指定的属性；\r\n命令行参数（如--spring.profiles.active=test）；\r\n系统环境变量；\r\napplication-test.properties（若激活test\r\nprofile）；\r\napplication.properties\r\n\r\n@ActiveProfiles\r\n指定测试时使用的 Spring\r\nProfile，加载对应配置文件（如application-test.properties），用于区分不同环境的配置（开发\r\n/ 测试 / 生产）\r\n@SpringBootTest@ActiveProfiles(&quot;test&quot;)  // 激活test profile,测试时覆盖默认配置class MyRepositoryTest &#123;    // 测试代码&#125;\r\n两者可同时使用，@ActiveProfiles加载基础配置，@TestPropertySource进一步覆盖特定属性：\r\n@SpringBootTest@ActiveProfiles(&quot;test&quot;)@TestPropertySource(properties = &quot;app.special.value=test-only&quot;)class MyTest &#123;    // 测试代码&#125;\r\n@AutoConfigureTestDatabase\r\n替换应用的数据源为测试专用数据库，避免测试影响生产数据。一般是使用内嵌数据库（如\r\nH2、HSQL）替代真实数据库时候使用该注解\r\n@DataJpaTest  // 专注于JPA测试@AutoConfigureTestDatabase(replace = Replace.ANY)  // 替换任何已配置的数据源class UserRepositoryTest &#123;    // 测试代码，自动使用H2数据库，无需额外配置&#125;\r\n\r\nreplace替换策略，可选值：\r\n\r\nReplace.ANY（默认）：替换任何已配置的数据源（包括显式配置的）；\r\nReplace.NONE：不替换，使用现有配置（用于测试真实数据库）；\r\nReplace.AUTO_CONFIGURED：仅替换自动配置的数据源。\r\n\r\n\r\n@TestConfiguration\r\n定义仅在测试环境生效的配置类，不影响主应用配置。一般是注册测试工具、Mock\r\n服务\r\n@SpringBootTestclass MyServiceTest &#123;    @TestConfiguration    static class TestConfig &#123;        @Bean        public MyDependency mockDependency() &#123;            return Mockito.mock(MyDependency.class);  // 注册Mock Bean        &#125;    &#125;    @Autowired    private MyService myService;  // 注入使用mockDependency的MyService    @Test    void testService() &#123;        // 测试代码    &#125;&#125;\r\n总结\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n所属库\r\n作用\r\n\r\n\r\n\r\n\r\n@TestPropertySource\r\nSpring Test\r\n为测试指定额外的属性源（如\r\n@TestPropertySource(properties = \"app.port=8081\")）。\r\n\r\n\r\n@ActiveProfiles\r\nSpring Test\r\n指定测试时激活的 Spring Profile（如\r\n@ActiveProfiles(\"test\")）。\r\n\r\n\r\n@AutoConfigureTestDatabase\r\nSpring Boot Test\r\n自动配置测试数据库，可替换为内嵌数据库（如\r\n@AutoConfigureTestDatabase(replace = Replace.ANY)）。\r\n\r\n\r\n@TestConfiguration\r\nSpring Test\r\n定义测试专用的配置类，不会被主应用扫描。\r\n\r\n\r\n\r\nJUnit 5 原生注解\r\n在这里不再细讲\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n作用\r\n\r\n\r\n\r\n\r\n@Test\r\n标记测试方法。\r\n\r\n\r\n@BeforeEach\r\n每个测试方法前执行（替代 JUnit 4 的 @Before）。\r\n\r\n\r\n@AfterEach\r\n每个测试方法后执行（替代 JUnit 4 的 @After）。\r\n\r\n\r\n@BeforeAll\r\n所有测试方法前执行一次（需静态方法，替代 JUnit 4 的\r\n@BeforeClass）。\r\n\r\n\r\n@AfterAll\r\n所有测试方法后执行一次（需静态方法，替代 JUnit 4 的\r\n@AfterClass）。\r\n\r\n\r\n@Disabled\r\n禁用测试方法 / 类（替代 JUnit 4 的 @Ignore）。\r\n\r\n\r\n@DisplayName\r\n为测试类或方法指定显示名称。\r\n\r\n\r\n@Tag\r\n表示单元测试类别，类似于JUnit4中的@Categories\r\n\r\n\r\n@Timeout\r\n表示测试⽅法运⾏如果超过了指定时间将会返回错误\r\n\r\n\r\n@MethodSource\r\n通过方法提供参数\r\n\r\n\r\n@ParameterizedTest\r\n参数化测试，支持多种参数源（如\r\n@ValueSource、@CsvSource）。\r\n\r\n\r\n\r\n举一个相对完善的例子帮着大家回忆一下\r\nimport org.junit.jupiter.api.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.mock.mockito.MockBean;import java.util.Arrays;import java.util.List;import java.util.Optional;import static org.assertj.core.api.Assertions.*;import static org.mockito.Mockito.*;@SpringBootTest  // 启动完整 Spring 应用上下文@DisplayName(&quot;用户服务测试套件&quot;)  // 测试类显示名称class UserServiceTest &#123;    @Autowired    private UserService userService;  // 被测试的服务    @MockBean    private UserRepository userRepository;  // 模拟依赖的仓储    private static List&lt;User&gt; testUsers;  // 测试数据    // 所有测试开始前执行一次（初始化共享资源）    @BeforeAll    static void setUpAll() &#123;        testUsers = Arrays.asList(            new User(1L, &quot;Alice&quot;),            new User(2L, &quot;Bob&quot;),            new User(3L, &quot;Charlie&quot;)        );        System.out.println(&quot;=== 初始化测试数据 ===&quot;);    &#125;    // 每个测试方法执行前重置 Mock 状态    @BeforeEach    void setUpEach() &#123;        reset(userRepository);  // 清除 Mock 的调用记录和 stub        System.out.println(&quot;--- 开始测试 ---&quot;);    &#125;    // 每个测试方法执行后执行（释放资源）    @AfterEach    void tearDownEach() &#123;        System.out.println(&quot;--- 测试结束 ---&quot;);    &#125;    // 所有测试结束后执行一次（清理资源）    @AfterAll    static void tearDownAll() &#123;        testUsers = null;        System.out.println(&quot;=== 清理测试数据 ===&quot;);    &#125;    // 基本测试方法    @Test    @DisplayName(&quot;应通过 ID 查找用户&quot;)    void shouldFindUserById() &#123;        // 准备 Mock 数据        when(userRepository.findById(1L))            .thenReturn(Optional.of(testUsers.get(0)));        // 执行测试        User result = userService.getUserById(1L);        // 断言结果        assertThat(result.getName()).isEqualTo(&quot;Alice&quot;);        verify(userRepository, times(1)).findById(1L);  // 验证方法调用    &#125;    // 禁用的测试（临时跳过）    @Disabled(&quot;待实现用户删除逻辑&quot;)    @Test    void shouldDeleteUser() &#123;        // 测试逻辑    &#125;    // 参数化测试（使用不同参数多次执行同一测试逻辑）    @ParameterizedTest(name = &quot;用户 ID &#123;0&#125; 应存在&quot;)    @ValueSource(longs = &#123;1L, 2L, 3L&#125;)  // 测试参数源    void shouldValidateUserId(Long userId) &#123;        when(userRepository.existsById(userId)).thenReturn(true);        boolean exists = userService.exists(userId);        assertThat(exists).isTrue();    &#125;    // 动态参数化测试（通过方法生成测试参数）    @ParameterizedTest    @MethodSource(&quot;provideUserNames&quot;)  // 指定参数生成方法    void shouldCreateUser(String name) &#123;        User newUser = new User(null, name);        when(userRepository.save(any(User.class)))            .thenAnswer(invocation -&gt; &#123;                User saved = invocation.getArgument(0);                saved.setId(99L);  // 模拟生成 ID                return saved;            &#125;);        User result = userService.createUser(newUser);        assertThat(result.getId()).isNotNull();        assertThat(result.getName()).isEqualTo(name);    &#125;    // 提供参数的静态方法    static Stream&lt;String&gt; provideUserNames() &#123;        return Stream.of(&quot;David&quot;, &quot;Emma&quot;, &quot;Frank&quot;);    &#125;    // 异常测试    @Test    void shouldThrowExceptionWhenUserNotFound() &#123;        when(userRepository.findById(99L)).thenReturn(Optional.empty());                // 断言抛出特定异常        assertThatThrownBy(() -&gt; userService.getUserById(99L))            .isInstanceOf(EntityNotFoundException.class)            .hasMessage(&quot;User not found with ID: 99&quot;);    &#125;&#125;// 示例实体类class User &#123;    private Long id;    private String name;    // 构造方法、Getter/Setter 省略&#125;// 示例仓储接口interface UserRepository &#123;    Optional&lt;User&gt; findById(Long id);    boolean existsById(Long id);    User save(User user);&#125;// 示例服务类class UserService &#123;    private final UserRepository userRepository;    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;    public User getUserById(Long id) &#123;        return userRepository.findById(id)            .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found with ID: &quot; + id));    &#125;    public boolean exists(Long id) &#123;        return userRepository.existsById(id);    &#125;    public User createUser(User user) &#123;        return userRepository.save(user);    &#125;&#125;// 自定义异常class EntityNotFoundException extends RuntimeException &#123;    public EntityNotFoundException(String message) &#123;        super(message);    &#125;&#125;\r\n数据相关\r\n@Sql\r\n在写单元测试时，往往需要在数据库中准备对应的测试数据。\r\n我们可以在测试用例中，通过代码的方式往数据库中插入数据。但这么做会使测试代码比较臃肿。\r\n通过sql脚本去导入数据，再结合@Transational注解在每次测试结束后对数据进行回滚，是一种更好的方案。为此，spring为我们准备了很有用的注解@Sql。\r\n@Sql注解可以执行SQL脚本，也可以执行SQL语句。它既可以加上类上面，也可以加在方法上面。默认情况下，方法上的@Sql注解会覆盖类上的@Sql注解，但可以通过@SqlMergeMode注解来修改此默认行为。\r\n@Sql有下面的属性：\r\n\r\nconfig：与注解@SqlConfig作用一样，用来配置“注释前缀”，“分隔符”等。\r\nexecutionPhase：决定SQL脚本或语句什么时候会执行，默认是BEFORE_TEST_METHOD。\r\nstatements：配置要一起执行的SQL语句。\r\nscripts：配置SQL脚本路径。\r\nvalue：scripts的别名，它不能和scripts同时配置，但statements可以。\r\n\r\n示例如下：\r\nimport org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.annotation.Rollback;import org.springframework.test.jdbc.SQLAssert;import org.springframework.test.sql.annotation.Sql;import org.springframework.transaction.annotation.Transactional;import javax.sql.DataSource;import java.sql.Connection;import java.sql.Statement;@SpringBootTest@Transactional  // 测试后自动回滚数据@Sql(scripts = &quot;classpath:sql/init-db.sql&quot;)  // 类级别：所有测试前执行初始化脚本class UserRepositoryTest &#123;    @Autowired    private DataSource dataSource;    @Autowired    private UserRepository userRepository;    // 测试方法：使用方法级别的 @Sql 覆盖类级别配置    @Test    @Sql(statements = &#123;        &quot;INSERT INTO users(id, name, age) VALUES(4, &#x27;David&#x27;, 35)&quot;,        &quot;INSERT INTO users(id, name, age) VALUES(5, &#x27;Emma&#x27;, 28)&quot;    &#125;)    void testFindAllUsers() throws Exception &#123;        // 执行查询        List&lt;User&gt; users = userRepository.findAll();                // 断言数据数量        assertThat(users).hasSize(5);  // 包括 init-db.sql 中的3条和本方法插入的2条                // 直接查询数据库验证数据        try (Connection conn = dataSource.getConnection();             Statement stmt = conn.createStatement()) &#123;            SQLAssert.assertSelectCount(stmt, &quot;SELECT * FROM users&quot;, 5);        &#125;    &#125;    // 测试方法：使用自定义 SQL 配置    @Test    @Sql(        config = @SqlConfig(commentPrefix = &quot;--&quot;),  // 自定义注释前缀        scripts = &quot;classpath:sql/insert-test-user.sql&quot;,        executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD  // 测试后执行    )    void testUserCount() &#123;        // 测试前数据库有3条数据（来自类级别 @Sql）        long count = userRepository.count();        assertThat(count).isEqualTo(3);                // 注意：此方法的 SQL 脚本在测试后执行，不影响本次测试    &#125;&#125;// 示例实体类class User &#123;    private Long id;    private String name;    private int age;    // 构造方法、Getter/Setter 省略&#125;// 示例仓储接口interface UserRepository &#123;    List&lt;User&gt; findAll();    long count();&#125;\r\ninit-db.sql（类级别执行的初始化脚本）\r\n-- 初始化测试数据CREATE TABLE IF NOT EXISTS users (    id BIGINT PRIMARY KEY,    name VARCHAR(50),    age INT);INSERT INTO users(id, name, age) VALUES(1, &#x27;Alice&#x27;, 25);INSERT INTO users(id, name, age) VALUES(2, &#x27;Bob&#x27;, 30);INSERT INTO users(id, name, age) VALUES(3, &#x27;Charlie&#x27;, 35);\r\ninsert-test-user.sql（方法级别执行的脚本）：\r\n-- 测试后插入的数据（不影响当前测试）INSERT INTO users(id, name, age) VALUES(6, &#x27;Frank&#x27;, 40);\r\n@SqlConfig\r\n@SqlConfig 用于自定义 SQL\r\n脚本的执行配置，解决不同 SQL\r\n方言、注释格式、分隔符等差异问题。\r\n@Sql注解也有一个config属性，作用与@SqlConfig相同，不同的是作用域只在对应的@Sql注解范围。它的优先级也大于类注解的@SqlConfig。\r\n核心属性\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n属性\r\n说明\r\n示例\r\n\r\n\r\n\r\n\r\ncommentPrefix\r\nSQL 注释前缀（默认 --）\r\n@SqlConfig(commentPrefix = \"REM \")（适配 Oracle）\r\n\r\n\r\nseparator\r\nSQL 语句分隔符（默认 ;）\r\n@SqlConfig(separator = \"/\")（适配 Oracle\r\n存储过程）\r\n\r\n\r\nencoding\r\n脚本编码（默认 UTF-8）\r\n@SqlConfig(encoding = \"ISO-8859-1\")\r\n\r\n\r\nerrorMode\r\n错误处理模式（默认 STOP，遇到错误停止执行）\r\n@SqlConfig(errorMode = SqlConfig.ErrorMode.CONTINUE)（忽略错误继续执行）\r\n\r\n\r\ntransactionMode\r\n事务模式（默认 DEFAULT，使用测试的事务配置）\r\n@SqlConfig(transactionMode = SqlConfig.TransactionMode.ISOLATED)\r\n\r\n\r\n\r\n与@sql结合使用的示例\r\n@SpringBootTest@Transactionalclass AdvancedSqlTest &#123;    @Autowired    private DataSource dataSource;    // 使用 @SqlConfig 自定义 SQL 执行行为    @Test    @Sql(        config = @SqlConfig(            commentPrefix = &quot;#&quot;,        // 使用 # 作为注释前缀（类似 H2 数据库）            separator = &quot;;&quot;,            // 语句分隔符            encoding = &quot;UTF-8&quot;,         // 编码格式            errorMode = SqlConfig.ErrorMode.STOP,  // 遇到错误停止            transactionMode = SqlConfig.TransactionMode.ISOLATED  // 独立事务        ),        scripts = &quot;classpath:sql/complex-script.sql&quot;    )    void testCustomSqlConfig() throws Exception &#123;        // 验证 SQL 执行结果        try (Connection conn = dataSource.getConnection()) &#123;            // 断言数据已正确插入            SQLAssert.assertSelectCount(conn.createStatement(),                 &quot;SELECT * FROM special_users&quot;, 5);        &#125;    &#125;&#125;\r\n\r\n方法级别优先：方法上的 @Sql\r\n会覆盖类上的 @Sql；\r\n@SqlConfig 继承：方法上的\r\n@SqlConfig 会覆盖类上的\r\n@SqlConfig，若无则继承类配置；\r\n合并模式：通过 @SqlMergeMode\r\n可修改默认的覆盖行为（如\r\n@SqlMergeMode(SqlMergeMode.MergeMode.MERGE) 合并配置）\r\n\r\n进行测试\r\n单元测试\r\n我们之前会使用@RunWith注解，去测试指定的类，不过在 JUnit\r\n5 中，我们可以使用更加简洁和强大的注解来完成单元测试。\r\n一般来说，每个测试方法只测试一个功能点，避免测试用例过于复杂。而且单元测试拥有Given-When-Then\r\n模式\r\n通常情况下，我们会在单元测试中，结合 Mock\r\n，去做一些dao，service，controller层或者util层的测试，因为单元测试应独立于外部依赖（如数据库、服务调用），通常通过\r\nMock\r\n对象实现。而且测试目标应聚焦于代码的业务逻辑，而非框架或基础设施。\r\n例如\r\n目标：测试 UserService\r\n的业务逻辑，隔离对 UserRepository 的依赖。\r\n@ExtendWith(MockitoExtension.class) // JUnit 5 集成 Mockitoclass UserServiceTest &#123;    @Mock  // 创建 UserRepository 的 Mock 对象    private UserRepository userRepository;    @InjectMocks  // 自动注入 Mock 对象到 UserService    private UserService userService;    @Test    void shouldGetUserById() &#123;        // 准备 Mock 数据        when(userRepository.findById(1L))            .thenReturn(Optional.of(new User(1L, &quot;Alice&quot;, &quot;alice@example.com&quot;)));        // 执行测试        User result = userService.getUserById(1L);        // 验证结果        assertEquals(&quot;Alice&quot;, result.getName());        verify(userRepository, times(1)).findById(1L); // 验证方法调用    &#125;    @Test    void shouldThrowExceptionWhenUserNotFound() &#123;        // 配置 Mock 行为：返回空结果        when(userRepository.findById(99L)).thenReturn(Optional.empty());        // 断言异常        Exception exception = assertThrows(EntityNotFoundException.class,             () -&gt; userService.getUserById(99L));                    assertEquals(&quot;User not found with ID: 99&quot;, exception.getMessage());    &#125;&#125;// 示例实体类和接口class User &#123;    private Long id;    private String name;    private String email;    // 构造方法、Getter/Setter 省略&#125;interface UserRepository &#123;    Optional&lt;User&gt; findById(Long id);&#125;class UserService &#123;    private final UserRepository userRepository;    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;    public User getUserById(Long id) &#123;        return userRepository.findById(id)            .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found with ID: &quot; + id));    &#125;&#125;class EntityNotFoundException extends RuntimeException &#123;    public EntityNotFoundException(String message) &#123;        super(message);    &#125;&#125;\r\n目标：测试 UserController\r\n的请求处理逻辑，隔离对 UserService 的依赖。\r\n@WebMvcTest(UserController.class) // 仅加载 Controller，不启动完整 Web 容器class UserControllerTest &#123;    @Autowired    private MockMvc mockMvc;  // 模拟 HTTP 请求的工具    @MockBean  // 替换 Controller 依赖的 Service 为 Mock 对象    private UserService userService;    @Test    void shouldReturnUserById() throws Exception &#123;        // 准备 Mock 数据        User user = new User(1L, &quot;Bob&quot;, &quot;bob@example.com&quot;);        when(userService.getUserById(1L)).thenReturn(user);        // 模拟 GET 请求并验证响应        mockMvc.perform(get(&quot;/api/users/1&quot;))               .andExpect(status().isOk())               .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;Bob&quot;));    &#125;    @Test    void shouldCreateUser() throws Exception &#123;        // 准备请求 JSON        String requestJson = &quot;&quot;&quot;            &#123;                &quot;name&quot;: &quot;Charlie&quot;,                &quot;email&quot;: &quot;charlie@example.com&quot;            &#125;            &quot;&quot;&quot;;        // 配置 Mock 行为        User savedUser = new User(2L, &quot;Charlie&quot;, &quot;charlie@example.com&quot;);        when(userService.createUser(any(User.class))).thenReturn(savedUser);        // 模拟 POST 请求并验证响应        mockMvc.perform(post(&quot;/api/users&quot;)                .contentType(MediaType.APPLICATION_JSON)                .content(requestJson))               .andExpect(status().isCreated())               .andExpect(jsonPath(&quot;$.id&quot;).value(2));    &#125;&#125;// 示例 Controller@RestController@RequestMapping(&quot;/api/users&quot;)class UserController &#123;    private final UserService userService;    public UserController(UserService userService) &#123;        this.userService = userService;    &#125;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        return userService.getUserById(id);    &#125;    @PostMapping    @ResponseStatus(HttpStatus.CREATED)    public User createUser(@RequestBody User user) &#123;        return userService.createUser(user);    &#125;&#125;\r\n这个其实和用 postman 等接口测试工具的效果是一样的\r\n嵌套测试\r\nJUnit 5\r\n引入了嵌套测试的概念，允许将测试类分层组织，以更好地表达测试场景的层次结构。嵌套测试通过\r\n@Nested 注解实现，适合测试复杂类或多个相关场景。\r\nimport org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import org.junit.jupiter.api.extension.ExtendWith;import static org.mockito.Mockito.*;import static org.junit.jupiter.api.Assertions.*;@ExtendWith(MockitoExtension.class)@DisplayName(&quot;用户服务单元测试&quot;)class UserServiceTest &#123;    @Mock    private UserRepository userRepository;    @InjectMocks    private UserService userService;    @Nested    @DisplayName(&quot;查找用户&quot;)    class FindUserTests &#123;        @Test        @DisplayName(&quot;通过ID查找用户 - 用户存在&quot;)        void shouldFindUserByIdWhenUserExists() &#123;            // 准备 Mock 数据            User expectedUser = new User(1L, &quot;Alice&quot;);            when(userRepository.findById(1L)).thenReturn(Optional.of(expectedUser));            // 执行测试            User result = userService.getUserById(1L);            // 断言结果            assertEquals(&quot;Alice&quot;, result.getName());            verify(userRepository, times(1)).findById(1L);        &#125;        @Test        @DisplayName(&quot;通过ID查找用户 - 用户不存在&quot;)        void shouldThrowExceptionWhenUserNotFound() &#123;            // 配置 Mock 行为            when(userRepository.findById(99L)).thenReturn(Optional.empty());            // 断言异常            assertThrows(EntityNotFoundException.class, () -&gt; userService.getUserById(99L));        &#125;    &#125;    @Nested    @DisplayName(&quot;创建用户&quot;)    class CreateUserTests &#123;        @Test        @DisplayName(&quot;创建用户成功&quot;)        void shouldCreateUserSuccessfully() &#123;            User newUser = new User(null, &quot;Bob&quot;);            User savedUser = new User(2L, &quot;Bob&quot;);            // 配置 Mock 行为            when(userRepository.save(newUser)).thenReturn(savedUser);            // 执行测试            User result = userService.createUser(newUser);            // 断言结果            assertEquals(2L, result.getId());            assertEquals(&quot;Bob&quot;, result.getName());            verify(userRepository, times(1)).save(newUser);        &#125;    &#125;&#125;\r\n常见断言表如下\r\n\r\n\r\nimage-20250621133416241\r\n\r\n功能测试\r\n而功能测试其实跟大家口中常说的集成测试没啥区别，是介于单元测试和端到端测试之间的一种测试方式，它验证多个组件协同工作的正确性，比如\r\nService 层与 Repository 层的交互，或者 Controller 层与 Service\r\n层的协作。\r\n在这里，我们就涉及到加载部分 Spring\r\n容器，只初始化测试所需的组件，结合 Mock 部分依赖。\r\n示例，测试Service层\r\n@SpringBootTest@Transactionalclass UserServiceIntegrationTest &#123;    @Autowired    private UserService userService;  // 测试目标    @Autowired    private UserRepository userRepository;  // 真实依赖    @Test    void shouldCreateUserAndSaveToDatabase() &#123;        // 准备测试数据        UserDTO userDTO = new UserDTO(&quot;Alice&quot;, &quot;alice@example.com&quot;);        // 执行业务逻辑        User savedUser = userService.createUser(userDTO);        // 验证数据库结果        assertNotNull(savedUser.getId());        Optional&lt;User&gt; dbUser = userRepository.findById(savedUser.getId());        assertTrue(dbUser.isPresent());        assertEquals(&quot;Alice&quot;, dbUser.get().getName());    &#125;&#125;\r\n示例：Controller 层功能测试（模拟 HTTP）\r\n@SpringBootTest@AutoConfigureMockMvcclass UserControllerIntegrationTest &#123;    @Autowired    private MockMvc mockMvc;    @MockBean  // 模拟外部服务    private EmailService emailService;    @Test    void shouldReturnUserWhenIdExists() throws Exception &#123;        // 模拟依赖行为        when(emailService.isValid(anyString())).thenReturn(true);        // 发送 HTTP 请求并验证响应        mockMvc.perform(post(&quot;/api/users&quot;)               .contentType(MediaType.APPLICATION_JSON)               .content(&quot;&#123;\\&quot;name\\&quot;:\\&quot;Bob\\&quot;,\\&quot;email\\&quot;:\\&quot;bob@example.com\\&quot;&#125;&quot;))               .andExpect(status().isCreated())               .andExpect(jsonPath(&quot;$.name&quot;).value(&quot;Bob&quot;));    &#125;&#125;\r\n切片测试\r\n切片测试是 Spring Boot\r\n的特色功能，它允许开发者针对应用的某一“切片”（如 Web\r\n层、数据层）进行精准测试，避免加载整个应用上下文，从而提升测试速度。\r\n因为这里只是某一层，所以只初始化特定层的组件（如\r\nController、Repository），然后非目标层的依赖会自动替换为 Mock 对象。\r\n基本就用到了上面我讲的以下注解\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n测试目标\r\n自动配置项\r\n典型场景\r\n\r\n\r\n\r\n\r\n@WebMvcTest\r\nController 层\r\nMockMvc、Web 相关组件\r\n测试 HTTP 接口映射和响应格式\r\n\r\n\r\n@DataJpaTest\r\nJPA Repository 层\r\n内存数据库、EntityManager、DataSource\r\n测试数据库查询和持久化逻辑\r\n\r\n\r\n@JdbcTest\r\nJDBC 操作层\r\nDataSource、JdbcTemplate\r\n测试原生 SQL 或存储过程\r\n\r\n\r\n@JsonTest\r\nJSON 序列化\r\nJackson/Gson 配置\r\n验证对象与 JSON 的转换逻辑\r\n\r\n\r\n@RestClientTest\r\nREST 客户端\r\nMockRestServiceServer\r\n测试 RestTemplate 或 WebClient\r\n\r\n\r\n\r\n示例 1：Web 层切片测试 (@WebMvcTest)\r\n@WebMvcTest(UserController.class)  // 只加载 UserController 相关配置class UserControllerSliceTest &#123;    @Autowired    private MockMvc mockMvc;    @MockBean  // 自动替换真实 Bean    private UserService userService;    @Test    void shouldReturn404WhenUserNotFound() throws Exception &#123;        when(userService.getUserById(99L)).thenThrow(new UserNotFoundException());        mockMvc.perform(get(&quot;/api/users/99&quot;))               .andExpect(status().isNotFound());    &#125;&#125;\r\n示例 2：JPA 层切片测试 (@DataJpaTest)\r\n@DataJpaTest  // 只加载 JPA 相关配置，使用 H2 内存数据库class UserRepositorySliceTest &#123;    @Autowired    private UserRepository userRepository;    @Test    void shouldFindByEmailIgnoreCase() &#123;        // 初始化数据（自动事务回滚）        userRepository.save(new User(&quot;alice@example.com&quot;, &quot;Alice&quot;));        // 查询验证        Optional&lt;User&gt; user = userRepository.findByEmailIgnoreCase(&quot;ALICE@EXAMPLE.COM&quot;);        assertTrue(user.isPresent());    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","JavaEE","Spring系列","Spring Boot","Java框架","配置相关","JUnit","测试"]},{"title":"Spring Boot part19-生命周期监听与9大事件","url":"/posts/54298.html","content":"观察者模式\r\n观察者模式是一种行为设计模式，它定义了对象之间的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。在这个模式中，改变状态的对象被称为主题，依赖的对象被称为观察者。\r\n举个实际的例子：\r\n\r\n事件源（Event\r\nSource）：可以视为“主题（Subject）”，当其状态发生变化时（比如播放新的内容），会通知所有的观察者。想象我们正在听广播，广播电台就是一个事件源，它提供了大量的新闻、音乐和其他内容。\r\n事件（Event）：这是主题状态改变的具体表示，对应到广播例子中，就是新闻、音乐和其他内容。每当电台播放新的内容时，就相当于一个新的事件被发布了。\r\n广播器（Event Publisher /\r\nMulticaster）：广播器起到的是中介的作用，它将事件从事件源传递到监听器。在这个例子中，广播塔就充当了这个角色，它将电台的节目的无线电信号发送到空气中，以便无线电接收器（监听器）可以接收。\r\n监听器（Listener）：监听器就是“观察者”，它们监听并响应特定的事件。在例子中，无线电接收器就是监听器，它接收广播塔发出的信号，然后播放电台的内容。\r\n\r\n在Spring中，事件模型的工作方式也是类似的：\r\n\r\n当Spring应用程序中发生某个行为时（比如一个用户完成了注册），那么产生这个行为的组件（比如用户服务）就会创建一个事件，并将它发布出去。\r\n事件一旦被发布，Spring的ApplicationContext就会作为广播器，把这个事件发送给所有注册的监听器。\r\n各个监听器接收到事件后，就会根据事件的类型和内容，进行相应的处理（比如发送欢迎邮件，赠送新用户优惠券等）。\r\n\r\n这就是Spring事件模型的工作原理，它实现了事件源、广播器和监听器之间的解耦，使得事件的生产者和消费者可以独立地进行开发和修改，增强了程序的灵活性和可维护性。\r\n生命周期监听\r\n监听 Spring Boot\r\n的生命周期的事件，让开发者能在应用启动不同阶段（如环境准备、容器初始化、Bean\r\n加载等）插入自定义逻辑，实现对启动流程的精细控制。\r\n自定义SpringApplicationRunListener来监听事件\r\nSpringApplicationRunListener是Spring Boot\r\n定义的应用启动生命周期监听器接口，作用是\r\n“感知应用启动的关键阶段，触发自定义逻辑”\r\n，比如在环境准备好时打印启动参数、在 Bean 加载完成后做初始化校验等\r\n实现与配置自定义监听器的流程如下\r\n\r\n编写实现类：\r\n自定义一个类，实现 SpringApplicationRunListener\r\n接口，重写接口中定义的生命周期方法（如\r\nstarting、environmentPrepared 等\r\n），在方法里写你想执行的逻辑（比如日志打印、参数校验 ）。\r\n配置 spring.factories： 在项目\r\nMETA-INF 目录下创建（或已有）spring.factories\r\n文件，添加配置，还可以指定⼀个有参构造器，接\r\n受两个参数(SpringApplication application, String[] args)\r\norg.springframework.boot.SpringApplicationRunListener=\\你的包名.MyRunListener\r\n\r\n\r\nimage-20250621142029901\r\n\r\n这样，Spring Boot 启动时会通过 SPI\r\n机制（spring.factories 是 SPI 配置方式\r\n），找到并加载你的监听器。\r\n\r\n而 Spring Boot 在 spring-boot.jar 中配置了默认的\r\nListener，如下\r\n\r\n\r\nimage-20250621141047197\r\n\r\nSpring Boot 自身在 spring-boot.jar 的\r\nMETA-INF/spring.factories 中，默认配置了\r\nEventPublishingRunListener ，它的核心作用是\r\n“事件转发”，在上述生命周期阶段，它会把\r\nSpringApplicationRunListener 的事件，转换为 Spring 标准的\r\nApplicationEvent（如\r\nApplicationStartingEvent、ApplicationEnvironmentPreparedEvent\r\n等 ），然后发布到 Spring 事件机制中。这样，其他通过\r\n@EventListener\r\n注解监听这些事件的组件，就能感知启动流程。\r\n我们来写一个实例，来看看实现SpringApplicationRunListener手写监听器都需要实现什么方法\r\npublic class MyAppListener implements SpringApplicationRunListener &#123;    // 传递的是启动上下文    @Override    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;        System.out.println(&quot;====staring 正在启动===&quot;);    &#125;    @Override    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;        System.out.println(&quot;====failed 应用启动失败===&quot;);    &#125;    @Override    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;        System.out.println(&quot;====environmentPrepared 环境准备完成===&quot;);    &#125;    @Override    public void contextPrepared(ConfigurableApplicationContext context) &#123;        System.out.println(&quot;====contextPrepared IOC容器准备完成===&quot;);    &#125;    @Override    public void contextLoaded(ConfigurableApplicationContext context) &#123;        System.out.println(&quot;====contextPrepared IOC容器加载完成===&quot;);    &#125;    // 传递的是启动上下文    @Override    public void started(ConfigurableApplicationContext context, Duration timeTaken) &#123;        System.out.println(&quot;====started 启动完成===&quot;);    &#125;    @Override    public void ready(ConfigurableApplicationContext context, Duration timeTaken) &#123;        System.out.println(&quot;====ready 准备就绪===&quot;);    &#125;&#125;\r\n可以发现，一个空的SpringApplicationRunListener的实现类有如上这些方法需要被实现，这也对应着其\r\nSpring Boot 应用的生命周期\r\nSpring Boot 启动过程会触发 SpringApplicationRunListener\r\n的多个方法，对应不同阶段，可理解为\r\n“应用启动的时间轴”：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n阶段方法\r\n触发时机 &amp; 作用\r\n关键说明\r\n\r\n\r\n\r\n\r\nstarting\r\nSpringApplication.run()\r\n调用后立即执行，此时应用刚启动，BootstrapContext 可用\r\n可做最早期初始化（如标记启动开始时间 ）\r\n\r\n\r\nenvironmentPrepared\r\n环境准备完成（启动参数、系统变量等绑定到 Environment\r\n），但 IoC 容器 还未创建\r\n可修改环境变量（如动态设置配置参数 ）\r\n\r\n\r\ncontextPrepared\r\nIoC 容器 创建并准备好，但主配置类（sources\r\n）未加载、组件未创建\r\n可对容器做预配置（如注册自定义 Bean 后处理器 ）\r\n\r\n\r\ncontextLoaded\r\nIoC 容器 加载主配置类，但容器未刷新（Bean\r\n未实例化、依赖未注入 ）\r\n可在此阶段加载额外配置类\r\n\r\n\r\nstarted\r\nIoC 容器 刷新完成（所有 Bean 已创建、依赖注入完成\r\n），但 ApplicationRunner/CommandLineRunner\r\n未执行\r\n可做 Bean 初始化后的校验、日志统计\r\n\r\n\r\nready\r\nApplicationRunner/CommandLineRunner\r\n执行完毕，应用完全就绪\r\n可标记启动完成，对外暴露服务就绪状态\r\n\r\n\r\nfailed\r\n启动过程中发生异常时触发\r\n可做异常兜底（如记录详细错误、发送告警 ）\r\n\r\n\r\n\r\n在META-INF中配好了我们自己实现的SpringApplicationRunListener监听器后，来看看启动后的关键流程变化\r\n\r\n\r\nimage-20250621142323120\r\n\r\n\r\n\r\nimage-20250621142200266\r\n\r\n项目启动的生命周期流程分析\r\n所以整个启动流程就分为如下三步\r\n引导\r\n\r\n关键动作围绕 BootstrapContext\r\n展开，利用它引导上下文启动，它是一个轻量级上下文，存放启动初期必要的基础配置、监听器等，支撑应用启动流程\r\n“开个头”。\r\n首先就是这个 staring\r\n方法，SpringApplicationRunListener接口中的源码如下\r\ndefault void starting(ConfigurableBootstrapContext bootstrapContext) &#123;    &#125;\r\n之后，我们返回到我们的启动类中，可以发现\r\npublic ConfigurableApplicationContext run(String... args) &#123;    Startup startup = SpringApplication.Startup.create();     if (this.properties.isRegisterShutdownHook()) &#123;        shutdownHook.enableShutdownHookAddition(); // 注册关闭钩子，用于优雅停机    &#125;    // 关键：创建引导上下文 BootstrapContext     DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();     // ... 后续流程&#125;\r\n从 SpringApplication.run()\r\n调用开始，引导阶段的核心步骤可拆解为：\r\n\r\n当你在启动类调用\r\nSpringApplication.run(xxx.class, args) run方法时候，Spring\r\nBoot 会进入启动流程，先初始化一些基础对象（如 Startup\r\n记录启动指标、shutdownHook 注册关闭钩子\r\n），然后创建 BootstrapContext\r\n然后触发 starting\r\n方法，SpringApplicationRunListener 介入，创建完\r\nBootstrapContext 后，Spring Boot 会主动调用所有\r\nSpringApplicationRunListener 的 starting\r\n方法 。\r\nSpringApplicationRunListeners listeners = this.getRunListeners(args);\r\n以你自定义的监听器为例，Linstener先要从\r\nMETA-INF / spring.factories\r\n中读到实现类，用构造器（SpringApplication application, String[] args\r\n）实例化后，执行 starting 逻辑\r\nlisteners.starting(bootstrapContext, this.mainApplicationClass);\r\n此时，只要有了BootstrapContext，starting\r\n方法里的逻辑就会执行（比如打印 “应用开始启动” 日志、记录启动时间戳\r\n），这是应用启动生命周期的第一个可扩展点，能在最早期插入自定义逻辑。\r\n之后就是进行环境准备，把环境准备好，启动参数什么的进行绑定，但是此时，ioc容器还没有被创建\r\nApplicationArguments applicationArguments = new DefaultApplicationArguments(args);ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);Banner printedBanner = this.printBanner(environment);\r\n\r\nBootstrapContext 虽然\r\n“生命周期短”（主要在引导阶段活跃 ），但承担两个关键职责：\r\n\r\n存放基础配置：启动过程中需要的一些基础\r\nBean、配置参数，会临时存在这里，供后续流程快速获取。\r\n支撑监听器交互：starting\r\n等方法的参数是 BootstrapContext ，监听器可通过它读取 /\r\n修改启动初期的基础配置（比如动态设置环境变量 ），影响后续启动流程。\r\n引导阶段结束后，BootstrapContext\r\n并不会直接销毁，而是会传递给后续流程（比如\r\nenvironmentPrepared 阶段，监听器仍能拿到它 ），直到\r\nIoC 容器 （如\r\nAnnotationConfigApplicationContext\r\n）创建并准备好，引导上下文的使命才会逐步收尾，应用进入\r\n“启动阶段”（如\r\ncontextPrepared、contextLoaded 等流程\r\n）。\r\n\r\n\r\n启动\r\n\r\n启动阶段” 是 Spring Boot 真正构建\r\nIoC 容器、加载配置、初始化 Bean 的过程，对应\r\nSpringApplicationRunListener 的\r\nenvironmentPrepared、contextPrepared、contextLicooaded、started\r\n等方法。可以理解为：引导阶段搭好 “启动框架”，启动阶段负责\r\n“填充内容、构建ioc容器”。\r\n引导创建启动上下文之后，Spring Boot\r\n会进入环境准备完成阶段，触发\r\nSpringApplicationRunListener 的\r\nenvironmentPrepared 方法。\r\ndefault void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;&#125;\r\n此时，从引导阶段传递下来的BootstrapContext对象就会帮助其完成Environment\r\n的准备，在这里，我们可以修改 /\r\n校验环境配置，比如动态设置配置参数、检查必要配置是否存在。\r\n// - 创建并配置 Environment（包含系统属性、配置文件、命令行参数等）// - 触发 listeners.environmentPrepared() 事件ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);\r\n这一步，本质上是引导的延续，也可以算是引导的一环\r\n接下来，就来到contextPrepared这一步，此时，IoC 容器（如\r\nAnnotationConfigApplicationContext ）已创建并\r\n“准备好”，但主配置类（sources，即\r\n@SpringBootApplication 标注的类\r\n）还未加载，容器内也没有任何 Bean。\r\n在这里，框架会创建 IoC 容器\r\n并触发此阶段，此时可以发现，容器是空的，但你可以通过\r\ncontext 做预配置\r\n// 4. 创建应用上下文（IoC 容器）// 根据应用类型（Web/非 Web）创建对应的 ApplicationContextcontext = this.createApplicationContext();// 这里只是准备好了 IOC 容器\r\n之后，就来到contextLoaded这步了，加载主配置类，但\r\nBean 未实例化，此时IoC 容器\r\n已加载主配置类（@SpringBootApplication 类\r\n），解析其 @Bean、@ComponentScan\r\n等注解，但容器未刷新（Bean 未实例化、依赖未注入\r\n）里面没有组件，bean此时还没有创建。在这里，就是允许你加载额外的\r\n@Configuration 类的时候了\r\n继续追随 run\r\n方法，可以看到在createApplicationContext()之后，有\r\n// 这一步，就是准备应用上下文，配置上下文环境、加载主配置类，触发 listeners.contextPrepared() 和 listeners.contextLoaded() 事件this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\r\n追随prepareContext方法，继续阅读\r\n// 设置之前准备好的 Environment 到应用上下文context.setEnvironment(environment);// 应用上下文后置处理（模板方法，子类可重写）// 例如：ServletWebServerApplicationContext 会在此设置 Servlet 相关配置this.postProcessApplicationContext(context);// 添加 AOT（提前编译）生成的初始化器（如果适用）this.addAotGeneratedInitializerIfNecessary(this.initializers);// 应用所有 ApplicationContextInitializer// 允许第三方组件在容器刷新前自定义上下文（如注册属性源、添加 Bean 定义）this.applyInitializers(context);// 触发 contextPrepared 事件// 此时容器已创建但尚未加载任何配置listeners.contextPrepared(context);// 关闭 BootstrapContext（引导上下文）// 标志引导阶段结束，后续使用正式的应用上下文bootstrapContext.close(context);\r\n这也就是为什么，contextLoaded 事件是 Spring Boot\r\n启动流程中的配置扩展点\r\n接下来，就是对应started这步，此时IoC 容器\r\n已刷新完成（所有 Bean\r\n已实例化、依赖注入完成、@PostConstruct 等初始化方法已执行\r\n），但\r\nApplicationRunner/CommandLineRunner\r\n还未执行。\r\n继续追随 run\r\n方法，可以发现ioc容器刷新了，bean都造好了，这里涉及到容器刷新12大步，我之前也讲过\r\n// 6. 刷新应用上下文（核心启动逻辑）// - 初始化 BeanFactory、加载所有 Bean 定义// - 实例化单例 Bean、处理依赖注入// - 触发各种 Bean 生命周期回调（@PostConstruct、InitializingBean 等）this.refreshContext(context);// 7. 刷新后的处理（模板方法）// 子类可重写此方法，在容器刷新后执行自定义逻辑this.afterRefresh(context, applicationArguments);// 8. 记录启动完成时间startup.started();// 打印启动信息（如果启用）if (this.properties.isLogStartupInfo()) &#123;    (new StartupInfoLogger(this.mainApplicationClass, environment)).logStarted(this.getApplicationLog(), startup);&#125;// 9. 触发容器启动完成事件// 调用 listeners.started()，通知所有监听器容器已启动listeners.started(context, startup.timeTakenToStarted());\r\n最后就是启动的终点，触发\r\nSpringApplicationRunListener 的 ready\r\n方法，执行 ApplicationRunner/CommandLineRunner\r\n逻辑。这一步标志着：应用已完全就绪，可对外提供服务。\r\n来到我们run 方法主要流程try块中的最后一行，我们会发现\r\n// 10. 执行应用运行器和命令行运行器// 调用所有实现 ApplicationRunner 或 CommandLineRunner 的 Bean// 这是应用完全启动前的最后一步，常用于执行初始化任务this.callRunners(context, applicationArguments);\r\n这里面会调用callRunners方法，执行\r\nApplicationRunner/CommandLineRunner\r\n逻辑，源码如下\r\n在 callRunners 执行完毕后，Spring Boot 会触发\r\nSpringApplicationRunListener 的 ready\r\n方法，这标志着\r\n\r\n所有 Bean 已初始化\r\n所有 ApplicationRunner/CommandLineRunner\r\n已执行\r\n应用可以正式对外提供服务\r\n\r\nprivate void callRunners(ConfigurableApplicationContext context, ApplicationArguments args) &#123;        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();        String[] beanNames = beanFactory.getBeanNamesForType(Runner.class);        Map&lt;Runner, String&gt; instancesToBeanNames = new IdentityHashMap();        for(String beanName : beanNames) &#123;            instancesToBeanNames.put((Runner)beanFactory.getBean(beanName, Runner.class), beanName);        &#125;        Comparator&lt;Object&gt; comparator = this.getOrderComparator(beanFactory).withSourceProvider(new FactoryAwareOrderSourceProvider(beanFactory, instancesToBeanNames));        instancesToBeanNames.keySet().stream().sorted(comparator).forEach((runner) -&gt; this.callRunner(runner, args));    &#125;\r\n下面的catch块，就是在 ready 返回的 context\r\n中判断出现了什么样的异常，进行进一步的处理\r\n\r\n运行\r\n\r\n之后，我们发现，就剩下一个方法没有被处理过，那就是在运行过程中发生异常（如\r\nBean 初始化失败、Runner 执行异常），Spring Boot 会触发\r\nfailed 事件\r\n这里就是用到了 run 方法中那一大堆的 catch 块\r\ntry &#123;   if (context.isRunning()) &#123;      listeners.ready(context, startup.ready());    &#125;        return context;  &#125; catch (Throwable ex) &#123;      throw this.handleRunFailure(context, ex, (SpringApplicationRunListeners)null);  &#125;\r\n而其中会有一个handleRunFailure专门处理\r\nfailed 事件异常\r\nprivate RuntimeException handleRunFailure(ConfigurableApplicationContext context, Throwable exception, SpringApplicationRunListeners listeners) &#123;        if (exception instanceof AbandonedRunException abandonedRunException) &#123;            return abandonedRunException;        &#125; else &#123;            try &#123;                try &#123;                    this.handleExitCode(context, exception);                     // 触发 failed 事件                    if (listeners != null) &#123;                        listeners.failed(context, exception);                    &#125;                &#125; finally &#123;                    this.reportFailure(this.getExceptionReporters(context), exception);                    if (context != null) &#123;                        context.close();                        shutdownHook.deregisterFailedApplicationContext(context);                    &#125;                &#125;            &#125; catch (Exception ex) &#123;                logger.warn(&quot;Unable to close ApplicationContext&quot;, ex);            &#125;            Object var10000;            if (exception instanceof RuntimeException runtimeException) &#123;                var10000 = runtimeException;            &#125; else &#123;                var10000 = new IllegalStateException(exception);            &#125;            return (RuntimeException)var10000;        &#125;    &#125;\r\n\r\n总结下来，整个流程就行如下图\r\n\r\n\r\nimage-20250621151006134\r\n\r\n事件触发的时机\r\n各种回调监听器\r\nSpring Boot 监听器（Listeners）基于 Spring Framework\r\n的事件机制（ApplicationEvent和ApplicationListener），用于在应用生命周期或自定义事件触发时执行特定逻辑。它们提供了一种松耦合的方式响应应用状态变化，常用于初始化资源、监控应用状态、执行异步任务等。\r\n而 Spring Boot 中存在很多事件回调监听器，这些监听器都是 Spring Boot\r\n为了让开发者 “感知应用启动流程、插入自定义逻辑”\r\n设计的扩展点，覆盖从 “最早期引导上下文” 到 “应用完全就绪”\r\n的全生命周期，可按需选择对应监听器实现精细化控制。\r\n简单说，这些监听器就像 Spring Boot 启动流程里的\r\n“钩子”，从最早期的引导上下文，到容器初始化、事件驱动，再到应用就绪，不同阶段都有对应的扩展点。根据需求选对应的\r\n“钩子”，就能精准在 Spring Boot\r\n启动的各个环节插入自定义逻辑，实现如安全校验、配置修改、初始化加载等功能\r\nBootstrapRegistryInitializer\r\n\r\n感知阶段：引导上下文（BootstrapContext）初始化阶段\r\n触发时机：创建 BootstrapContext\r\n时触发（启动最早期，比 IoC 容器创建还早 ），在进入 run\r\n方法的时候就被创建\r\n在run方法中有\r\nDefaultBootstrapContext bootstrapContext = this.createBootstrapContext();\r\n\r\n\r\nimage-20250621154930427\r\n\r\n\r\n\r\nimage-20250621152216366\r\n\r\n可以发现，run方法进入以后，首先就调用了BootstrapRegistryInitializer中的initialize方法\r\n使用方式\r\n\r\n配置：在 META-INF/spring.factories 里加\r\norg.springframework.boot.BootstrapRegistryInitializer=你的实现类\r\norg.springframework.boot.SpringApplicationRunListener=com.your.listener.MyApplicationListener org.springframework.boot.BootstrapRegistryInitializer=com.your.listener.MyBootstrapRegistryInitializer\r\n代码：application.addBootstrapRegistryInitializer(...)\r\n在启动主类中动态添加\r\n\r\n典型场景：最早期的\r\n“底层初始化”，比如密钥校验、授权初始化（需要在容器启动前完成的安全逻辑\r\n）\r\n\r\nApplicationContextInitializer\r\n\r\n感知阶段：IoC\r\n容器（ApplicationContext）初始化阶段（容器创建后，刷新前\r\n）\r\n触发时机：IoC\r\n容器准备好，但还没加载 Bean 定义、实例化 Bean\r\n时触发，经过上文的分析，我们知道，ApplicationContextInitializer执行是在contextPrepared(ioc容器准备完成)之前，environmentPrepared(环境准备完成)之后\r\nrun 方法中，之后不断进入，就能知道其中什么时候调用了这个方法\r\nthis.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\r\n\r\n\r\nimage-20250621152629580\r\n\r\n\r\n\r\nimage-20250621152641493\r\n\r\n使用方式\r\n\r\n配置：META-INF/spring.factories 里加\r\norg.springframework.context.ApplicationContextInitializer=你的实现类\r\n代码：application.addInitializers(...) 动态添加\r\n\r\n典型场景：对 IoC\r\n容器做预配置，比如修改环境变量、注册自定义 Bean\r\n后处理器（影响容器后续加载流程 ）\r\n\r\nApplicationListener\r\n\r\n感知阶段：基于 Spring\r\n事件机制，感知全流程事件（从应用启动到关闭的各种事件\r\n）这也是为什么，我们要是重写监听器，一般都会实现这个接口，它是基于事件机制感知全阶段的，是感知事件用的，不能够去进行对应操作。类似于那种\r\nAOP\r\n的普通通知，而下面的SpringApplicationRunListener类似于环绕通知\r\n触发时机：对应事件发生时触发（如\r\nApplicationStartingEvent、ContextRefreshedEvent\r\n等 ）\r\n使用方式\r\n\r\n注解：@Bean 定义监听器 Bean，或用\r\n@EventListener\r\n标注方法（更简洁）这里涉及到后面的事件驱动开发，我这里就简单说一下\r\nimport org.springframework.boot.context.event.ApplicationReadyEvent;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component;// 实现 ApplicationListener，指定监听的事件类型public class MyAppReadyListener implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123;    @Override    public void onApplicationEvent(ApplicationReadyEvent event) &#123;        // event.getTimestamp() 是事件触发时间（接近应用启动完成时间）        // 可以结合启动开始时间，计算耗时（实际可通过上下文存启动开始时间）        System.out.println(&quot;应用已完全就绪！启动耗时可在此计算...&quot;);        // 也能获取容器、环境等信息        System.out.println(&quot;当前环境：&quot; + event.getApplicationContext().getEnvironment().getActiveProfiles()[0]);    &#125;&#125;\r\n在配置类（或启动类 ）里，通过 @Bean 把监听器加入 Spring\r\n容器：\r\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ListenerConfig &#123;    @Bean    public MyAppReadyListener myAppReadyListener() &#123;        return new MyAppReadyListener();    &#125;&#125;\r\n或者\r\n无需显式实现 ApplicationListener 接口，直接在 Spring\r\n管理的 Bean（如 @Component 类 ）里，用\r\n@EventListener 标注方法，指定要监听的事件类型\r\nimport org.springframework.boot.context.event.ApplicationReadyEvent;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;@Component // 必须是 Spring 管理的 Beanpublic class MyEventListenerBean &#123;    // 标注 @EventListener，指定监听 ApplicationReadyEvent    @EventListener(ApplicationReadyEvent.class)    public void onAppReady(ApplicationReadyEvent event) &#123;        System.out.println(&quot;通过 @EventListener 监听到应用就绪事件！&quot;);        // 同样可操作容器、环境等        System.out.println(&quot;当前激活配置：&quot; + event.getApplicationContext().getEnvironment().getProperty(&quot;spring.profiles.active&quot;));    &#125;&#125;\r\n配置：启动类中添加SpringApplication.addListeners(...)\r\n或 spring.factories 配置\r\n\r\n典型场景：事件驱动的零散逻辑，比如监听应用启动完成发通知、监听\r\nBean 加载完成做缓存预热（灵活，可针对不同事件写逻辑 ）\r\n举个例子\r\npublic class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;    @Override    public void onApplicationEvent(ApplicationEvent event) &#123;        System.out.println(&quot;----事件&quot; + event + &quot;到达-------&quot;);    &#125;&#125;\r\n然后，写到 META-INF 中\r\norg.springframework.context.ApplicationListener=\\  edu.software.ergoutree.springbootwebpart2.listener.MyApplicationListener\r\n\r\n​ 启动后发现，事件就被标注出来了\r\n\r\n\r\nimage-20250621160339952\r\n\r\nSpringApplicationRunListener\r\n\r\n感知阶段：不仅能够感知应用启动全生命周期（从\r\nstarting 到 ready/failed 所有阶段\r\n），而且还能进行各阶段的自定义操作\r\n触发时机：启动流程的每个关键节点（如环境准备、容器刷新、应用就绪等\r\n）都会触发对应方法，这个在上面已经说的比较多了\r\n使用方式：META-INF/spring.factories\r\n配置\r\norg.springframework.boot.SpringApplicationRunListener=你的实现类\r\n典型场景：深度干预启动流程，比如在每个阶段记录日志、统计启动耗时、自定义启动失败处理（功能最全面，覆盖所有阶段\r\n）\r\n\r\nApplicationRunner\r\n&amp; CommandLineRunner\r\n\r\n感知阶段：感知应用就绪，是应用就绪前最后一步（所有\r\nBean 加载完成，准备对外提供服务时\r\n），也就是感知应用就绪ready这步，这些 Runner\r\n的作用就是，在runner执行的前后都会发送探针事件\r\n触发时机：IoC\r\n容器刷新完成，ApplicationRunner 先执行（参数是\r\nApplicationArguments ），CommandLineRunner\r\n后执行（参数是原始命令行参数数组 ）\r\n从 run 方法中的try块最后一行进入到started 方法来\r\n\r\n\r\nimage-20250621162954409\r\n\r\n进入 callRunner 方法，不断进入\r\n\r\n\r\nimage-20250621163231548\r\n\r\n使用方式：定义实现类，用 @Bean 注入\r\nSpring 容器\r\n典型场景：应用就绪前的初始化逻辑，比如加载基础数据、注册服务到注册中心；如果逻辑里抛异常，会阻断应用就绪（让应用启动失败，适合做\r\n“启动前最后校验” ）\r\n\r\n9大事件\r\n经过上述示例，我们实现了ApplicationListene接口，标注出了其中的事件，这些事件的内容如下\r\n----事件org.springframework.boot.context.event.ApplicationStartingEvent[source=org.springframework.boot.SpringApplication@5204062d]到达-------====staring 正在启动===----事件org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent[source=org.springframework.boot.SpringApplication@5204062d]到达-------====environmentPrepared 环境准备完成===----事件org.springframework.boot.context.event.ApplicationContextInitializedEvent[source=org.springframework.boot.SpringApplication@5204062d]到达-------====contextPrepared IOC容器准备完成===----事件org.springframework.boot.context.event.ApplicationPreparedEvent[source=org.springframework.boot.SpringApplication@5204062d]到达-------====contextPrepared IOC容器加载完成===----事件org.springframework.boot.web.servlet.context.ServletWebServerInitializedEvent[source=org.springframework.boot.web.embedded.tomcat.TomcatWebServer@56da8847]到达-----------事件org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@747f281, started on Sat Jun 21 16:02:16 GMT+08:00 2025]到达-----------事件org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@5204062d]到达-----------事件org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@747f281, started on Sat Jun 21 16:02:16 GMT+08:00 2025]到达-------====started 启动完成===----事件org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@5204062d]到达-----------事件org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@747f281, started on Sat Jun 21 16:02:16 GMT+08:00 2025]到达-------====ready 准备就绪===\r\nApplicationStartingEvent\r\n\r\n触发时机：应用启动最开始，仅完成\r\nlisteners（监听器 ）和 initializers（初始化器\r\n）的注册，还未加载环境、创建容器。在进行任何处理之前发送（除了监听器和初始化器注册之外）。\r\n核心作用：标记\r\n“应用启动的起点”，可在此做最早期初始化（如设置全局日志标识、初始化基础工具类\r\n）。\r\n\r\nApplicationEnvironmentPreparedEvent\r\n\r\n触发时机：Environment（环境配置，包含配置文件、系统变量、命令行参数等\r\n）准备完成，但 IoC 容器（ApplicationContext\r\n）还未创建。\r\n核心作用：允许修改 /\r\n校验环境配置，是干预应用配置的关键节点。\r\n实践场景：动态设置配置参数（如根据环境变量切换数据源地址\r\n）；校验必要配置是否存在（如 database.url 未配置则抛异常\r\n）。\r\n\r\nApplicationContextInitializedEvent\r\n\r\n触发时机：IoC\r\n(ApplicationContext)容器创建完成，且\r\nApplicationContextInitializers（容器初始化器\r\n）已调用，但没有加载任何 Bean\r\n定义（主配置类、@Bean 等还未解析\r\n）。此时，容器是空的\r\n核心作用：对空容器做预配置，影响后续\r\nBean 加载流程。\r\n实践场景：注册自定义\r\nBeanFactoryPostProcessor（修改 Bean 定义的处理器\r\n）；提前设置容器级别的属性（如资源加载器 ）。\r\n\r\nApplicationPreparedEvent\r\n\r\n触发时机：容器刷新（refresh）之前，Bean\r\n定义信息已加载（主配置类、@ComponentScan 扫描的\r\nBean、@Bean 等已解析为 Bean 定义 ），但 Bean\r\n未实例化。此时，容器里面没有组件，bean此时还没有创建。\r\n核心作用：最后一次修改 Bean 定义的机会，可调整 Bean\r\n的配置。\r\n实践场景：根据环境动态替换 Bean\r\n定义（如开发环境用模拟 Bean，生产环境用真实 Bean ）；校验 Bean\r\n定义的合法性（如某个 Bean 必须设置特定属性 ）。\r\n\r\nContextRefreshedEvent\r\n\r\n触发时机：Spring\r\n应用上下文（ApplicationContext）完成刷新时触发。具体发生在：\r\n\r\n容器初始化完成：所有 Bean\r\n定义已加载、实例化、依赖注入完成，且执行了所有初始化回调（如\r\n@PostConstruct、InitializingBean）。\r\n容器刷新操作结束：调用 refresh()\r\n方法（包括应用启动时自动调用，或手动刷新）的最后阶段。\r\n可多次触发：对于支持热刷新的容器（如\r\nGenericApplicationContext），每次刷新都会触发；但 Spring\r\nBoot 默认容器通常只在启动时刷新一次。\r\n\r\n核心作用：\r\n\r\n标记容器完全就绪：此时所有 Bean\r\n已处于可用状态，可执行依赖于完整容器环境的操作。\r\n扩展容器功能：注册动态组件（如事件监听器、MBean）、启动后台任务、执行最终配置校验。\r\n\r\n\r\nApplicationStartedEvent\r\n\r\n触发时机：容器刷新完成（所有 Bean\r\n已实例化、依赖注入完成、@PostConstruct 等初始化方法执行完毕\r\n），但\r\nApplicationRunner/CommandLineRunner\r\n未执行。\r\n核心作用：标记\r\n“容器已就绪，但应用还未完全对外服务”，可做 Bean 初始化后的校验。\r\n实践场景：检查关键 Bean 的状态（如数据库连接 Bean\r\n是否正常 ）；初始化业务资源（如缓存预热、定时任务注册 ）。\r\n\r\nAvailabilityChangeEvent（LivenessState.CORRECT）\r\n\r\n触发时机：应用存活状态变更为\r\n“健康”（LivenessState.CORRECT\r\n），一般在容器正常刷新后触发，属于存活探针。\r\n核心作用：告知监控系统\r\n“应用进程还活着，基础功能正常”。\r\n实践场景：配合 Kubernetes\r\n等平台的存活检测；自定义监控逻辑，标记应用存活状态。\r\n\r\nApplicationReadyEvent\r\n\r\n触发时机：所有\r\nApplicationRunner/CommandLineRunner\r\n执行完毕，应用完全就绪，可对外提供服务。\r\n核心作用：标记\r\n“应用已准备好处理外部请求”，是启动流程的关键终点。\r\n实践场景：发送应用就绪通知（如给运维平台、监控系统\r\n）；记录完整启动耗时（从 ApplicationStartingEvent 到此时\r\n）。\r\n\r\nAvailabilityChangeEvent（ReadinessState.ACCEPTING_TRAFFIC）\r\n\r\n触发时机：应用就绪状态变更为\r\n“可接收流量”（ReadinessState.ACCEPTING_TRAFFIC ），在\r\nApplicationReadyEvent\r\n后触发，属于就绪探针。\r\n核心作用：告知外部系统\r\n“应用不仅活着，还能处理请求”。\r\n实践场景：Kubernetes\r\n等平台据此判断是否将流量转发到该实例；网关、负载均衡器感知应用状态。\r\n\r\nApplicationFailedEvent\r\n九大事件有十个怎么了\r\n\r\n触发时机：启动过程中发生异常（如 Bean\r\n初始化失败、Runner 执行报错 ），导致应用启动终止。\r\n核心作用：捕获启动异常，做兜底处理。\r\n实践场景：记录详细错误日志（便于排查问题\r\n）；发送启动失败告警（邮件、短信通知运维 ）。\r\n\r\n总结下来就是这张图\r\n\r\n\r\nimage-20250621155431009\r\n\r\nflowchart TB\n    %% 定义节点样式\n    classDef eventStyle fill:#f9f,stroke:#333,stroke-width:1px,rx:5px,ry:5px;\n    classDef listenerStyle fill:#b8e994,stroke:#333,stroke-width:1px,rx:5px,ry:5px;\n    \n    %% 应用事件流程\n    A[&quot;ApplicationStartingEvent\\n应用开始启动&quot;]:::eventStyle --&gt; B[&quot;prepareEnvironment\\n准备环境&quot;]\n    B --&gt; C[&quot;ApplicationEnvironmentPreparedEvent\\n环境准备完成&quot;]:::eventStyle\n    C --&gt; D[&quot;prepareContext\\n初始化容器&quot;]\n    D --&gt; E[&quot;ApplicationContextInitializedEvent\\nInitializer 调用&quot;]:::eventStyle\n    D --&gt; F[&quot;ApplicationPreparedEvent\\n应用准备完成&quot;]:::eventStyle\n    F --&gt; G[&quot;refreshContext 之后\\n容器刷新完成&quot;]\n    G --&gt; H[&quot;ApplicationStartedEvent\\nstarted 阶段&quot;]:::eventStyle\n    G --&gt; I[&quot;AvailabilityChangeEvent\\n(LivenessState.CORRECT)\\n可用探针&quot;]:::eventStyle\n    H --&gt; J[&quot;callRunners\\n调用所有 runner&quot;]\n    J --&gt; K[&quot;ApplicationReadyEvent\\n应用运行完成&quot;]:::eventStyle\n    J --&gt; L[&quot;AvailabilityChangeEvent\\n(ReadinessState.ACCEPTING_TRAFFIC)\\n就绪探针&quot;]:::eventStyle\n    \n    %% 异常分支\n    B --&gt; M[&quot;所有异常、进行捕获&quot;]\n    D --&gt; M\n    F --&gt; M\n    G --&gt; M\n    H --&gt; M\n    J --&gt; M\n    M --&gt; N[&quot;ApplicationFailedEvent\\n应用失败&quot;]:::eventStyle\n    \n    %% 监听器运行流程\n    O[&quot;listeners.starting&quot;]:::listenerStyle --&gt; P[&quot;listeners.environmentPrepared&quot;]:::listenerStyle\n    P --&gt; Q[&quot;listeners.contextPrepared&quot;]:::listenerStyle\n    Q --&gt; R[&quot;listeners.contextLoaded&quot;]:::listenerStyle\n    R --&gt; S[&quot;listeners.started&quot;]:::listenerStyle\n    S --&gt; T[&quot;callRunners\\n调用所有 runner&quot;]\n    T --&gt; U[&quot;listeners.ready&quot;]:::listenerStyle\n    \n    %% 异常时监听器执行\n    M --&gt; V[&quot;listeners.failed&quot;]:::listenerStyle\r\n\r\n\r\nimage-20250621162125240\r\n\r\n\r\n\r\nimage-20250621162216083\r\n\r\nsequenceDiagram\n    title Spring Boot 启动事件时序\n    participant 应用 as 应用启动入口\n    participant 事件1 as ApplicationStartingEvent\n    participant 事件2 as ApplicationEnvironmentPreparedEvent\n    participant 事件3 as ApplicationContextInitializedEvent\n    participant 事件4 as ApplicationPreparedEvent\n    participant 事件5 as ApplicationStartedEvent\n    participant 事件6 as AvailabilityChangeEvent(Liveness)\n    participant 事件7 as ApplicationReadyEvent\n    participant 事件8 as AvailabilityChangeEvent(Readiness)\n    participant 事件9 as ApplicationFailedEvent\n    \n    应用-&gt;&gt;事件1: 启动开始，仅注册监听器/初始化器\n    事件1-&gt;&gt;事件2: 环境准备完成（配置加载）\n    事件2-&gt;&gt;事件3: IoC容器创建，未加载Bean\n    事件3-&gt;&gt;事件4: Bean定义加载完成，未实例化\n    事件4-&gt;&gt;事件5: 容器刷新完成，Bean初始化完成\n    事件5-&gt;&gt;事件6: 标记应用存活\n    事件6-&gt;&gt;事件7: Runner执行完毕，应用就绪\n    事件7-&gt;&gt;事件8: 标记应用可接收流量\n    应用-&gt;&gt;事件9: 启动异常时触发\r\n哪个看得懂看哪个\r\n实践总结\r\n\r\n项目启动前做事 →\r\nBootstrapRegistryInitializer +\r\nApplicationContextInitializer\r\n\r\n核心需求：在应用启动最早期（容器创建前、Bean\r\n加载前 ）执行逻辑。\r\nBootstrapRegistryInitializer：\r\n\r\n触发时机：引导上下文（BootstrapContext）创建时（比\r\nIoC 容器还早 ）。\r\n典型场景：最底层的初始化（如密钥校验、授权认证，需要在容器启动前完成\r\n）。\r\n代码示例\r\npublic class MyBootstrapInitializer implements BootstrapRegistryInitializer &#123;    @Override    public void initialize(BootstrapRegistry registry) &#123;        // 启动前校验：比如检查 License 文件是否有效        if (!checkLicense()) &#123;            throw new IllegalStateException(&quot;License 无效&quot;);        &#125;    &#125;&#125;// 在 META-INF/spring.factories 配置：// org.springframework.boot.BootstrapRegistryInitializer=com.example.MyBootstrapInitializer\r\n\r\nApplicationContextInitializer：\r\n\r\n触发时机：IoC 容器创建后，但 Bean\r\n未加载时（可修改容器环境、预配置 ）。\r\n典型场景：动态修改配置（如根据环境变量切换数据源 ）、注册 Bean\r\n后处理器。\r\n代码示例\r\npublic class MyContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123;    @Override    public void initialize(ConfigurableApplicationContext context) &#123;        // 修改环境变量：生产环境启用调试模式        if (context.getEnvironment().getActiveProfiles()[0].equals(&quot;prod&quot;)) &#123;            context.getEnvironment().setActiveProfiles(&quot;prod&quot;, &quot;debug&quot;);        &#125;    &#125;&#125;// 在 META-INF/spring.factories 配置：// org.springframework.context.ApplicationContextInitializer=com.example.MyContextInitializer\r\n\r\n\r\n项目启动完成后做事 →\r\nApplicationRunner + CommandLineRunner\r\n\r\n核心需求：应用完全就绪（所有 Bean\r\n加载完成、容器刷新完成 ）后，执行初始化逻辑。\r\nApplicationRunner：\r\n\r\n触发时机：应用就绪后，接收\r\nApplicationArguments（封装命令行参数 ）。\r\n典型场景：需要解析命令行参数的初始化（如根据\r\n--import-data 参数加载数据 ）。\r\n\r\nCommandLineRunner：\r\n\r\n触发时机：应用就绪后，接收原始命令行参数数组（更简单直接\r\n）。\r\n典型场景：无需复杂参数解析的初始化（如打印启动完成日志、注册服务\r\n）。\r\n\r\n\r\n干涉生命周期做事 →\r\nSpringApplicationRunListener\r\n\r\n核心需求：深度控制启动流程，在每个生命周期阶段（如环境准备、容器刷新、应用就绪\r\n）插入逻辑。\r\n\r\n用事件机制做事 →\r\nApplicationListener\r\n\r\n核心需求：通过事件驱动，灵活响应特定阶段（如应用启动、Bean\r\n加载完成 ）。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n需求场景\r\n推荐工具\r\n核心优势\r\n\r\n\r\n\r\n\r\n启动前最早期初始化（容器创建前 ）\r\nBootstrapRegistryInitializer\r\n干预引导上下文，做底层校验（如 License ）\r\n\r\n\r\n启动前容器级初始化（容器创建后，Bean 加载前 ）\r\nApplicationContextInitializer\r\n修改环境、预配置容器（如动态切换数据源 ）\r\n\r\n\r\n启动后业务初始化（需解析命令行参数 ）\r\nApplicationRunner\r\n支持复杂参数解析（如 --import-data ）\r\n\r\n\r\n启动后简单初始化（无需参数解析 ）\r\nCommandLineRunner\r\n代码简洁，直接执行逻辑（如注册服务 ）\r\n\r\n\r\n深度干预生命周期（每个阶段精细控制 ）\r\nSpringApplicationRunListener\r\n覆盖全生命周期，统计耗时、自定义失败处理\r\n\r\n\r\n事件驱动响应（灵活监听任意阶段 ）\r\nApplicationListener\r\n解耦逻辑，通过事件触发（如应用就绪、Bean 加载完成 ）\r\n\r\n\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","JavaEE","Spring系列","Spring Boot","Java框架","配置相关","源码分析","JUnit"]},{"title":"Spring Boot part20-事件驱动开发","url":"/posts/10821.html","content":"事件驱动开发\r\n简介\r\n在现代应用程序开发中，事件驱动架构（EDA）越来越受欢迎。它不仅可以提高系统的解耦性，还能提升系统的可扩展性和响应速度。Spring\r\nBoot\r\n中的事件驱动开发是一种解耦业务逻辑的设计模式，核心思想是：通过\r\n“事件发布 - 监听”\r\n机制，让不同组件在不直接依赖的情况下协作。\r\n事件驱动开发是一种软件架构模式，系统通过事件来进行通信和协调。事件可以是系统中发生的任何有意义的事情，如用户点击按钮、数据更新等。事件驱动架构的核心思想是将事件的发布者和事件的处理者解耦，通过事件总线来传递事件。这样可以使得系统更加灵活，易于扩展和维护。\r\nSpring Boot中的事件模型基于 Spring Framework 的 ApplicationEvent 和\r\nApplicationListener。ApplicationEvent\r\n是所有事件的基类，ApplicationListener\r\n是所有事件监听器的接口。我们可以自定义事件并发布，自定义监听器来处理这些事件。\r\n简单说，事件驱动开发是用 “事件” 作为业务流程的\r\n“粘合剂”，让不同组件在 “松耦合”\r\n的情况下协作。当业务逻辑复杂、需求多变时，它能让代码更清晰、更易扩展\r\n核心概念\r\n如果我们按照原来的模式，把事件解耦，会有如下思路\r\n\r\n\r\nimage-20250621164940785\r\n\r\n\r\n应用启动过程生命周期事件感知（9大事件）、应用运行中事件感知（无数种）\r\n\r\n\r\n\r\nimage-20250621164843835\r\n\r\n\r\n事件（Event）：\r\n\r\n描述 “发生了什么事” 的对象（如 LoginSuccessEvent\r\n登录成功、OrderCreatedEvent 订单创建 ）。\r\n可以是 Spring 内置事件（如启动阶段的\r\nApplicationReadyEvent\r\n），也可以是自定义事件（业务场景需要的事件 ）。\r\n\r\n事件发布者（Publisher）：\r\n\r\n触发事件的组件（如图中的\r\nLoginController、OrderController ）。\r\n职责：在业务逻辑中 “发布事件”（比如用户登录成功后，发布\r\nLoginSuccessEvent ）。、\r\n\r\n事件订阅者（Subscriber）：\r\n\r\n监听事件并执行逻辑的组件（如图中的\r\nAccountService、CouponService ）。\r\n职责：“订阅事件”，当事件发生时执行对应的业务（比如登录成功后，给用户发优惠券、记录系统日志\r\n）。\r\n\r\n\r\n\r\n事件发布：ApplicationEventPublisherAware或注入：ApplicationEventMulticaster\r\n事件监听：组件 + @EventListener\r\n\r\n代码落地举例思路\r\n开启Spring Boot 的事件监听\r\n为了更直观的看到 Spring Boot 执行的生命周期的事件监听，我们首先打开\r\nSpring Boot 的事件监听\r\n首先要实现ApplicationListener&lt;ApplicationEvent&gt;这个类中的onApplicationEvent方法，我们在这里打印了事件的出现信息\r\npublic class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;        @Override    public void onApplicationEvent(ApplicationEvent event) &#123;        System.out.println(&quot;----事件&quot; + event + &quot;到达-------&quot;);    &#125;&#125;\r\n在resources下面创建一个META-INF/spring.factories文件\r\norg.springframework.context.ApplicationListener=\\  edu.software.ergoutree.springbootwebpart2.listener.MyApplicationListener\r\n事件驱动开发的完整流程\r\n普通开发流程\r\n在普通的情况下，我们的代码流程如下：\r\n\r\n设计数据模型：设计用户实体、数据库表结构。\r\n编写Repository：实现数据访问层（如UserRepository）。\r\n编写Service：实现业务逻辑（如UserServiceImpl），所有业务逻辑都直接写在Service里。\r\n编写Controller：实现接口，调用Service完成注册、登录等功能。\r\n\r\n一个实体三大层的情况下大约就是这样\r\n如果用普通开发，代码会耦合在\r\nUserController 里；用事件驱动，则通过\r\n“事件”\r\n解耦这些逻辑。更利于在需要添加需求的时候的操作，避免扩展新功能（如登录后发邮件）需要修改原有Service代码。\r\n事件驱动代码开发流程\r\n设计数据实体和编写Repository\r\n当然这个和普通的开发也没什么不同\r\n自定义事件\r\n之前提到的 “应用启动过程生命周期事件（9 大事件）”，这些是 Spring Boot\r\n内置的框架级事件（如 ApplicationReadyEvent\r\n应用就绪 ）。而上面的\r\nLoginSuccessEvent是业务级事件。\r\n\r\n框架级事件：由 Spring Boot\r\n自动发布，用于感知启动流程（如 ApplicationListener 监听\r\n）。\r\n业务级事件：由开发者自定义发布，用于解耦业务逻辑（如登录、订单场景\r\n）。\r\n需要实现ApplicationEventPublisher，Spring\r\nBoot会通过ApplicationEventPublisherAware接口自动注入给我们，实现setApplicationEventPublisher方法，并且自定义一个方法来调用底层API发送事件，事件是广播出去的。所有监听这个事件的监听器都可以收到\r\n\r\n创建事件发布者\r\n@Servicepublic class EventPublisher implements ApplicationEventPublisherAware &#123;    /**     * 底层发送事件用的组件，springboot会通过ApplicationEventPublisherAware接口自动注入给我们     * 事件是广播出去的。所有监听这个事件的监听器都可以收到     * */    ApplicationEventPublisher applicationEventPublisher;    /**     * 所有事件都可以发送     * */    public void sendEvent(ApplicationEvent event)&#123;        //调用底层API发送事件        applicationEventPublisher.publishEvent(event);    &#125;    @Override    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123;        this.applicationEventPublisher = applicationEventPublisher;    &#125;&#125;\r\n写一个用户登录和注册的事件\r\n/** * 用户登录事件 */public class UserLoginEvent extends ApplicationEvent &#123;        private final User user;    private final String ip;    private final boolean success;    private final String message;        public UserLoginEvent(Object source, User user, String ip, boolean success, String message) &#123;        super(source);        this.user = user;        this.ip = ip;        this.success = success;        this.message = message;    &#125;        public User getUser() &#123;        return user;    &#125;        public String getIp() &#123;        return ip;    &#125;        public boolean isSuccess() &#123;        return success;    &#125;        public String getMessage() &#123;        return message;    &#125;&#125; \r\n/** * 用户注册事件 */public class UserRegistrationEvent extends ApplicationEvent &#123;        private final User user;        public UserRegistrationEvent(Object source, User user) &#123;        super(source);        this.user = user;    &#125;        public User getUser() &#123;        return user;    &#125;&#125; \r\n编写事件监听器\r\n这个需要实现ApplicationListener，专门处理某类事件（如登录日志、注册欢迎邮件、安全告警等）。\r\n/** * 用户注册事件监听器 */@Componentpublic class UserRegistrationEventListener implements ApplicationListener&lt;UserRegistrationEvent&gt; &#123;        private static final Logger logger = LoggerFactory.getLogger(UserRegistrationEventListener.class);        @Override    public void onApplicationEvent(UserRegistrationEvent event) &#123;        // 获取注册的用户信息        String username = event.getUser().getUsername();        String email = event.getUser().getEmail();                // 记录注册日志        logger.info(&quot;新用户注册 - 用户名: &#123;&#125;, 邮箱: &#123;&#125;&quot;, username, email);                // 这里可以添加更多的业务逻辑，例如：        // 1. 发送欢迎邮件        // 2. 创建用户默认设置        // 3. 分配初始角色        // 4. 记录用户来源                System.out.println(&quot;====用户注册事件处理完成====&quot;);    &#125;&#125; \r\nService新增代码\r\n就以其中的登录为例子吧\r\n@Override    public User register(String username, String password, String email) &#123;        // 检查用户名是否已存在        Optional&lt;User&gt; existingUser = userRepository.findByUsername(username);        if (existingUser.isPresent()) &#123;            // 发布事件 - 注册失败（用户名已存在）            eventPublisher.publishEvent(new SecurityEvent(                    this,                    username,                    &quot;REGISTER_ATTEMPT&quot;,                    &quot;N/A&quot;,                    &quot;注册失败：用户名已存在&quot;            ));            return null; // 用户名已存在        &#125;                // 创建新用户        User newUser = new User(username, password, email);        User savedUser = userRepository.save(newUser);                // 发布用户注册事件        eventPublisher.publishEvent(new UserRegistrationEvent(this, savedUser));                return savedUser;    &#125;\r\n最后在 Controller 中发送事件\r\n/**     * 用户登录     */    @PostMapping(&quot;/login&quot;)    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; login(            @RequestBody Map&lt;String, String&gt; request,            HttpServletRequest httpRequest) &#123;                String username = request.get(&quot;username&quot;);        String password = request.get(&quot;password&quot;);        String ip = httpRequest.getRemoteAddr();                Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();                if (username == null || password == null) &#123;            response.put(&quot;success&quot;, false);            response.put(&quot;message&quot;, &quot;用户名和密码不能为空&quot;);            return ResponseEntity.badRequest().body(response);        &#125;                User loggedInUser = userService.login(username, password, ip);                if (loggedInUser == null) &#123;            response.put(&quot;success&quot;, false);            response.put(&quot;message&quot;, &quot;用户名或密码错误&quot;);            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);        &#125;                response.put(&quot;success&quot;, true);        response.put(&quot;message&quot;, &quot;登录成功&quot;);        response.put(&quot;user&quot;, Map.of(                &quot;id&quot;, loggedInUser.getId(),                &quot;username&quot;, loggedInUser.getUsername(),                &quot;email&quot;, loggedInUser.getEmail()        ));                return ResponseEntity.ok(response);    &#125;\r\n启动后发现监听器正常运转，且事件解耦\r\n\r\n\r\nimage-20250621181112888\r\n\r\n在url中输入请求时，界面会出现如下\r\n\r\n\r\nimage-20250621181313567\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["实用知识","Java技术","JavaWeb","框架知识","学习","JavaEE","Spring系列","Spring Boot","Java框架","JUnit","设计模式"]},{"title":"Spring Boot part21-自定义starter","url":"/posts/59030.html","content":"自定义 starter\r\nSpringBoot Starter 场景机制\r\nSpring Boot Starter 是一种简化 Spring Boot\r\n应用开发的机制，它可以通过引入一些预定义的依赖和配置，让我们快速地集成某些功能模块，而无需繁琐地编写代码和配置文件。应用者只需要在maven中引入\r\nstarter 依赖，Spring Boot\r\n就能自动扫描到要加载的信息并启动相应的默认配置。\r\nstarter 让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。Spring\r\nBoot 会自动通过 classpath 路径下的类发现需要的\r\nBean，并注册进IOC容器。Spring Boot 提供了针对日常企业应用研发各种场景的\r\nspring-boot-starter\r\n依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。\r\nSpring Boot 官方提供了很多常用的\r\nStarter，例如spring-boot-starter-web、spring-boot-starter-data-jpa等，但有时候我们也需要根据自己的业务需求，创建一些自定义的Starter，以便在不同的项目中复用一些通用的功能或组件。\r\n自定义starter的命名规则\r\nSpring Boot 提供的 starter\r\n以spring-boot-starter-xxx的方式命名的。官方建议自定义的starter使用xxx-spring-boot-starter命名规则。以区分Spring\r\nBoot生态提供的 starter。\r\n自定义 Starter 通常包含以下内容：\r\n\r\n自动配置类（@Configuration）：定义好依赖的自动配置逻辑。\r\n配置属性类（@ConfigurationProperties）：支持使用外部化配置参数来简化使用。\r\n必要的依赖管理：将常用的第三方库一并引入，避免手动添加依赖。\r\n\r\nStarter项目的结构\r\n创建一个自定义的Starter项目和创建一个普通的Spring\r\nBoot项目没有太大区别，我们可以使用IDE或者 Spring Initializer\r\n来快速生成一个基本的项目结构。一个典型的 Starter 项目结构如下：\r\nergou-spring-boot-starter├── src│   ├── main│   │   ├── java│   │   │   └── com.woniu.util│   │   │       ├── autoconfigure // 自动配置类所在的包│   │   │       │   ├── ErgouAutoConfiguration.java // 自动配置类│   │   │       │   └── ErgouProperties.java // 属性类│   │   │       └── util // 业务功能类所在的包│   │   │           └── ErgouUtil.java // 业务功能类│   │   └── resources│   │       └── META-INF│   │           └── spring.factories // Spring Boot自动装配文件│   └── test│       └── java├── pom.xml // Maven依赖管理文件└── README.md // 项目说明文档\r\n在创建一个自定义的 Starter 项目时，我们需要在 pom.xml\r\n文件中添加一些必要的依赖。首先，我们需要添加spring-boot-starter作为基础依赖，它提供了\r\nSpring Boot 核心功能和默认配置。其次，我们需要添加\r\nspring-boot-configuration-processor\r\n作为编译时依赖，它可以帮助我们生成属性类和配置元数据，并且设置为可选依赖，避免传递给其他项目。最后，我们需要添加我们要集成的功能模块相关的依赖。\r\n示例演示：自定义一个简单的短信发送Starter\r\nstarter的依赖导入\r\n   &lt;groupId&gt;com.example&lt;/groupId&gt;   &lt;artifactId&gt;sms-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.0.0&lt;/version&gt;   &lt;packaging&gt;jar&lt;/packaging&gt;   &lt;name&gt;SMS Spring Boot Starter&lt;/name&gt;   &lt;description&gt;自定义短信发送Starter&lt;/description&gt;   &lt;properties&gt;       &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;       &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;       &lt;spring.boot.version&gt;2.7.0&lt;/spring.boot.version&gt;   &lt;/properties&gt;&lt;dependencies&gt;\t&lt;!-- 基础依赖：Spring Boot自动配置 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;           &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;       &lt;/dependency&gt;              &lt;!-- 编译时依赖： Spring Boot配置处理器，用于生成配置元数据 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;           &lt;version&gt;$&#123;spring.boot.version&#125;&lt;/version&gt;           &lt;optional&gt;true&lt;/optional&gt;       &lt;/dependency&gt;              &lt;!-- 构建和管理应用程序的运行环境 Spring Context --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework&lt;/groupId&gt;           &lt;artifactId&gt;spring-context&lt;/artifactId&gt;           &lt;version&gt;5.3.21&lt;/version&gt;       &lt;/dependency&gt;              &lt;dependency&gt;   \t\t&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;   \t\t&lt;artifactId&gt;lombok&lt;/artifactId&gt;       \t&lt;optional&gt;true&lt;/optional&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;\r\nStarter项目的属性类\r\n在创建一个自定义的Starter项目时，我们需要编写一个属性类，用来定义我们要集成的功能模块所需的配置项，并且使用@ConfigurationProperties注解来指定配置文件中的前缀。\r\n例如，在本例中，我们要使用短信发送服务，需要在属性类中做好如下配置\r\npackage com.example.sms.properties;import org.springframework.boot.context.properties.ConfigurationProperties;/** * 短信服务配置属性类 * 用于映射application.yml中的配置项 * 支持阿里云、腾讯云、华为云等短信服务商 */@Getter@Setter@ConfigurationProperties(prefix = &quot;sms&quot;)public class SmsProperties &#123;        /**     * 是否启用短信服务，默认为true     */    private boolean enabled = true;        /**     * 短信服务提供商类型：aliyun, tencent, huawei     */    private String provider = &quot;aliyun&quot;;        /**     * API访问密钥ID     */    private String accessKeyId;        /**     * API访问密钥Secret     */    private String accessKeySecret;        /**     * 短信签名     */    private String signName;        /**     * 默认短信模板ID     */    private String defaultTemplateId;        /**     * 连接超时时间（毫秒），默认5000ms     */    private int connectTimeout = 5000;        /**     * 读取超时时间（毫秒），默认10000ms     */    private int readTimeout = 10000;    @Override    public String toString() &#123;        return &quot;SmsProperties&#123;&quot; +                &quot;enabled=&quot; + enabled +                &quot;, provider=&#x27;&quot; + provider + &#x27;\\&#x27;&#x27; +                &quot;, accessKeyId=&#x27;&quot; + accessKeyId + &#x27;\\&#x27;&#x27; +                &quot;, signName=&#x27;&quot; + signName + &#x27;\\&#x27;&#x27; +                &quot;, defaultTemplateId=&#x27;&quot; + defaultTemplateId + &#x27;\\&#x27;&#x27; +                &quot;, connectTimeout=&quot; + connectTimeout +                &quot;, readTimeout=&quot; + readTimeout +                &#x27;&#125;&#x27;;    &#125;&#125;\r\n/** * 短信发送结果 */@Dataclass SmsResult &#123;    private boolean success;    private String message;    private String requestId;&#125;\r\nStarter 项目的业务功能类\r\n在创建一个自定义的Starter项目时，我们需要编写一个或多个业务功能类，用来实现我们要集成的功能模块的具体逻辑。例如，在本例中，我们要集成短信发送功能，所以我们需要定义一个短信发送的服务接口及其实现类，用来实现短信发送的业务流程。\r\npackage com.example.sms.service;import com.example.sms.properties.SmsProperties;import org.springframework.util.StringUtils;import java.util.Map;/** * 短信服务接口 */public interface SmsService &#123;        /**     * 发送短信     * @param phone 手机号     * @param templateId 模板ID     * @param params 模板参数     * @return 发送结果     */    SmsResult sendSms(String phone, String templateId, Map&lt;String, Object&gt; params);        /**     * 发送短信（使用默认模板）     * @param phone 手机号     * @param params 模板参数     * @return 发送结果     */    SmsResult sendSms(String phone, Map&lt;String, Object&gt; params);&#125;\r\n/** * 短信服务实现类 */class SmsServiceImpl implements SmsService &#123;        private final SmsProperties smsProperties;        public SmsServiceImpl(SmsProperties smsProperties) &#123;        this.smsProperties = smsProperties;    &#125;        @Override    public SmsResult sendSms(String phone, String templateId, Map&lt;String, Object&gt; params) &#123;        // 参数校验        if (!StringUtils.hasText(phone)) &#123;            return new SmsResult(false, &quot;手机号不能为空&quot;);        &#125;                if (!StringUtils.hasText(templateId)) &#123;            return new SmsResult(false, &quot;模板ID不能为空&quot;);        &#125;                // 模拟发送短信的过程        try &#123;            System.out.println(&quot;=== 短信发送详情 ===&quot;);            System.out.println(&quot;服务提供商: &quot; + smsProperties.getProvider());            System.out.println(&quot;手机号: &quot; + phone);            System.out.println(&quot;签名: &quot; + smsProperties.getSignName());            System.out.println(&quot;模板ID: &quot; + templateId);            System.out.println(&quot;模板参数: &quot; + params);            System.out.println(&quot;连接超时: &quot; + smsProperties.getConnectTimeout() + &quot;ms&quot;);            System.out.println(&quot;读取超时: &quot; + smsProperties.getReadTimeout() + &quot;ms&quot;);                        // 模拟网络请求延迟            Thread.sleep(100);                        // 模拟成功响应            String requestId = &quot;SMS_&quot; + System.currentTimeMillis();            System.out.println(&quot;发送成功，请求ID: &quot; + requestId);            System.out.println(&quot;==================&quot;);                        return new SmsResult(true, &quot;短信发送成功&quot;, requestId);                    &#125; catch (Exception e) &#123;            System.err.println(&quot;短信发送失败: &quot; + e.getMessage());            return new SmsResult(false, &quot;短信发送失败: &quot; + e.getMessage());        &#125;    &#125;        @Override    public SmsResult sendSms(String phone, Map&lt;String, Object&gt; params) &#123;        String defaultTemplateId = smsProperties.getDefaultTemplateId();        if (!StringUtils.hasText(defaultTemplateId)) &#123;            return new SmsResult(false, &quot;未配置默认模板ID&quot;);        &#125;        return sendSms(phone, defaultTemplateId, params);    &#125;&#125;\r\nStarter项目的自动配置类\r\n在创建一个自定义的Starter项目时，我们需要编写一个自动配置类，用来根据属性类和业务功能类，创建相应的Bean对象，并且使用@EnableConfigurationProperties注解来启用属性类，使用@ConditionalOnClass注解来判断业务功能类是否存在，使用@ConditionalOnProperty注解来判断配置文件中是否有相应的配置项。\r\npackage com.example.sms.autoconfigure;import com.example.sms.properties.SmsProperties;import com.example.sms.service.SmsService;import com.example.sms.service.SmsServiceImpl;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * SMS自动配置类 * 这是Starter的核心类，负责自动创建和配置Bean */@Configuration  // 标识这是一个配置类@ConditionalOnWebApplication   // 表示在web应用中才配置@EnableConfigurationProperties(SmsProperties.class)  // 启用并且绑定配置属性类@ConditionalOnProperty(prefix = &quot;sms&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)   // 基于配置属性值生效// 条件注解：只有当sms.enabled=true时才生效，默认为truepublic class SmsAutoConfiguration &#123;        /**     * 创建SmsService Bean     * @param smsProperties 注入的配置属性     * @return SmsService实例     */    @Bean    @ConditionalOnMissingBean(SmsService.class)  // 只有当容器中没有SmsService Bean时才创建    public SmsService smsService(SmsProperties smsProperties) &#123;        System.out.println(&quot;初始化SmsService，配置信息: &quot; + smsProperties);        return new SmsServiceImpl(smsProperties);    &#125;&#125;\r\nStarter项目的自动装配文件\r\n在创建一个自定义的Starter项目时，我们需要在resources/META-INF目录下创建一个名为spring.factories的文件，用来指定我们的自动配置类，让Spring\r\nBoot能够在启动时自动扫描并加载它。以下是一个示例\r\n# 这个文件必须放在src/main/resources/META-INF/目录下# Spring Boot通过这个文件来发现和加载自动配置类# 自动配置类注册org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.sms.autoconfigure.SmsAutoConfiguration\r\n在其他项目中使用这个starter\r\n在完成了一个自定义的Starter项目后，我们可以将它打包成jar文件，并且发布到Maven仓库或者本地仓库，这样就可以在其他项目中引用它了。我们默认打包发布是发布在我们本地的maven仓库的，所以只能本地使用。如果想要将自己的服务公开出去，可以查找发布到maven中心仓库的方法。\r\n大约流程如下\r\n\r\n在需要使用你自定义starter的项目的pom.xml中添加依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;sms-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;\r\n然后，在其他项目的配置文件中添加如下配置项，这部分配置就是对应的是你编写的配置属性类部分\r\nsms:  enabled: true  provider: aliyun  access-key-id: your-access-key-id  access-key-secret: your-access-key-secret  sign-name: 你的签名  default-template-id: SMS_123456789  connect-timeout: 5000  read-timeout: 10000\r\n最后，在其他项目的代码中，我们可以通过注入 smsService\r\n类来调用其功能\r\npackage com.example.demo;import com.example.sms.service.SmsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;@SpringBootApplication@RestControllerpublic class DemoApplication &#123;    // 自动注入SmsService，这个Bean是由我们的Starter自动创建的    @Autowired    private SmsService smsService;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;    /**     * 发送验证码短信     */    @GetMapping(&quot;/send-code&quot;)    public String sendVerificationCode(@RequestParam String phone) &#123;        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();        params.put(&quot;code&quot;, &quot;123456&quot;);        params.put(&quot;minutes&quot;, &quot;5&quot;);                // 使用默认模板发送        var result = smsService.sendSms(phone, params);                return result.isSuccess() ? &quot;发送成功: &quot; + result.getRequestId() : &quot;发送失败: &quot; + result.getMessage();    &#125;    /**     * 发送自定义模板短信     */    @GetMapping(&quot;/send-custom&quot;)    public String sendCustomMessage(@RequestParam String phone, @RequestParam String templateId) &#123;        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();        params.put(&quot;name&quot;, &quot;张三&quot;);        params.put(&quot;product&quot;, &quot;云服务器&quot;);                var result = smsService.sendSms(phone, templateId, params);                return result.isSuccess() ? &quot;发送成功: &quot; + result.getRequestId() : &quot;发送失败: &quot; + result.getMessage();    &#125;&#125;\r\n如果你想使用自己的SmsService实现，可以创建一个Bean：\r\n@Componentpublic class CustomSmsService implements SmsService &#123;        @Override    public SmsResult sendSms(String phone, String templateId, Map&lt;String, Object&gt; params) &#123;        // 你的自定义实现        return new SmsResult(true, &quot;使用自定义实现发送成功&quot;);    &#125;        @Override    public SmsResult sendSms(String phone, Map&lt;String, Object&gt; params) &#123;        // 你的自定义实现        return new SmsResult(true, &quot;使用自定义实现发送成功&quot;);    &#125;&#125;\r\n由于@ConditionalOnMissingBean注解的存在，Starter\r\n会检测到你已经有了SmsService的实现，就不会创建默认的SmsServiceImpl了。\r\n\r\nStarter项目的原理\r\n首先，Starter 项目也是一个 Spring Boot （Maven/Gradle 项目）\r\n项目，其核心还是Spring Boot组件自动配置与集成的那些机制：\r\n\r\n依赖聚合 将特定功能所需的所有依赖（如\r\nRedis、MyBatis、RabbitMQ\r\n等）整合到一个模块中，简化使用者的依赖管理。Starter 的依赖管理是通过\r\nMaven 的依赖传递机制来实现的。每个 Starter 都是一个 Maven 项目，它在\r\npom.xml\r\n文件中定义了一系列的依赖项。当开发者在自己的项目中引入一个 Starter\r\n时，Maven 会自动解析该 Starter\r\n的依赖关系，并将这些依赖项添加到项目的依赖列表中。\r\nSpring Boot 提供了一个依赖管理模块\r\nspring-boot-dependencies，它定义了所有 Spring Boot\r\n相关依赖的版本号。这样，开发者在使用 Starter\r\n时，无需手动指定依赖的版本号，而是直接使用\r\nspring-boot-dependencies\r\n中定义的版本。这保证了依赖版本的一致性，避免了版本冲突的问题。\r\n自动配置 Spring Boot 的自动配置机制是 Starter\r\n能够发挥作用的关键。当 Spring Boot\r\n应用程序启动时，它会通过一系列的条件注解（如\r\n@Conditional）来判断是否需要加载某个自动配置类。这些条件注解会检查类路径中是否存在某些类、配置文件中是否存在某些属性等条件，从而决定是否启用某个功能。\r\n自动配置类通常位于 spring-boot-autoconfigure\r\n模块中，每个 Starter 都会通过 @EnableAutoConfiguration\r\n注解来启用这些自动配置。开发者可以通过在\r\napplication.properties 或 application.yml\r\n文件中配置相关的属性来覆盖默认的自动配置。\r\n条件注解\r\n条件注解是 Spring Boot 自动配置的核心。Spring Boot\r\n提供了一系列的条件注解，这些注解可以用来控制自动配置类的加载条件。以下是一些常用的条件注解：\r\n\r\n@ConditionalOnClass：当类路径中存在指定的类时，才加载自动配置类。\r\n@ConditionalOnMissingBean：当容器中不存在指定的 Bean\r\n时，才加载自动配置类。\r\n@ConditionalOnProperty：当配置文件中存在指定的属性时，才加载自动配置类。\r\n@ConditionalOnWebApplication：当项目是一个 Web\r\n应用程序时，才加载自动配置类。\r\n\r\n通过这些条件注解，Spring Boot\r\n可以根据项目的实际情况动态地加载相关的自动配置类，从而实现“按需配置”的效果。\r\nSPI 机制 通过 Java 的 SPI（Service Provider\r\nInterface）机制，在 META-INF/spring.factories\r\n中声明自动配置类，使 Spring Boot 能够发现并加载它们。\r\n\r\nStarter 的加载流程如下\r\n\r\nSpringApplication 启动 Spring Boot\r\n应用启动时，SpringApplication 类会自动扫描类路径下的\r\nspring.factories 文件。\r\n自动配置类加载 从 spring.factories\r\n中获取 EnableAutoConfiguration\r\n对应的配置类列表，并加载到容器中。\r\n条件评估 对每个自动配置类中的\r\n@Conditional 注解进行评估，决定是否生效。\r\nBean 注册 生效的配置类会注册相应的 Bean 到 Spring\r\n容器中。\r\n属性绑定 通过 @ConfigurationProperties\r\n将配置文件中的值绑定到属性类。\r\n\r\nJava 的 SPI 机制\r\n在这里只是简单说一下，之后打算单开一篇文章说，因为放在前面的话会使得启动流程那篇太长了\r\nJava 的 SPI（Service Provider\r\nInterface）是JDK内置的一种服务提供发现机制，允许第三方组件通过接口实现来扩展系统功能。它通过将接口定义与具体实现分离，实现了框架的可插拔性，是\r\nJava 生态中众多组件（如 JDBC、SLF4J、Spring Boot\r\n等）的核心扩展机制。\r\nJava中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是解耦。\r\n\r\n\r\nimage-20250621205637825\r\n\r\n在Java中，当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\r\n在 Spring Boot\r\n中，META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，在\r\nMETA-INF/spring.factories 中声明自动配置类，使 Spring Boot\r\n能够发现并加载它们。\r\n在这里主要以 Spring Boot 为背景说了，上面那个 Java\r\n原生的我哪天再单开\r\n角色划分\r\n\r\n服务接口（Service\r\nInterface）：定义系统提供的功能契约，由框架开发者定义。\r\n服务提供者（Service\r\nProvider）：实现服务接口的具体类，由第三方开发者提供。\r\n服务注册表（Service\r\nRegistry）：ServiceLoader\r\n类，负责加载和管理服务提供者。\r\n\r\n约定大于配置\r\nSPI 机制遵循以下约定：\r\n\r\n在 META-INF/services\r\n目录下创建以接口全限定名命名的文件\r\n文件内容为实现类的全限定名\r\n多个实现类可按行分隔\r\n\r\nSPI 的工作流程\r\n\r\n定义服务接口 框架开发者定义公共接口：\r\npublic interface PaymentService &#123;    void pay(double amount);&#125;\r\n实现服务提供者 第三方实现该接口：\r\npublic class AlipayService implements PaymentService &#123;    @Override    public void pay(double amount) &#123;        System.out.println(&quot;使用支付宝支付: &quot; + amount + &quot;元&quot;);    &#125;&#125;public class WechatPayService implements PaymentService &#123;    @Override    public void pay(double amount) &#123;        System.out.println(&quot;使用微信支付: &quot; + amount + &quot;元&quot;);    &#125;&#125;\r\n注册服务提供者 在\r\nMETA-INF/services/com.example.PaymentService\r\n文件中写入实现类：\r\ncom.example.impl.AlipayServicecom.example.impl.WechatPayService\r\n加载服务提供者 使用 ServiceLoader\r\n动态加载实现类：\r\nServiceLoader&lt;PaymentService&gt; loader = ServiceLoader.load(PaymentService.class);for (PaymentService service : loader) &#123;    service.pay(100.0);&#125;\r\n其中，加载服务提供者的方式如下\r\n// 方式一：使用线程上下文类加载器ServiceLoader&lt;PaymentService&gt; loader = ServiceLoader.load(PaymentService.class);// 方式二：指定类加载器ServiceLoader&lt;PaymentService&gt; loader = ServiceLoader.load(    PaymentService.class,     Thread.currentThread().getContextClassLoader());// 方式三：Java 9+ 模块系统使用ServiceLoader&lt;PaymentService&gt; loader = ServiceLoader.load(PaymentService.class, ModuleLayer.boot());// 迭代器方式（Java 8 之前）Iterator&lt;PaymentService&gt; iterator = loader.iterator();while (iterator.hasNext()) &#123;    PaymentService service = iterator.next();    service.pay(100.0);&#125;// Stream 方式（Java 8+）loader.stream()    .map(ServiceLoader.Provider::get)    .forEach(service -&gt; service.pay(100.0));\r\n\r\nSPI与传统依赖注入的区别\r\n在 Spring 环境中使用 SPI 并注入依赖：\r\npublic class SpringServiceProvider implements PaymentService &#123;    private final OrderService orderService;        @Autowired    public SpringServiceProvider(OrderService orderService) &#123;        this.orderService = orderService;    &#125;        @Override    public void pay(double amount) &#123;        // 使用注入的服务        orderService.createOrder(amount);        System.out.println(&quot;支付完成&quot;);    &#125;&#125;\r\nServiceLoader采用懒加载策略，只有在真正迭代时才会实例化服务提供者：\r\npublic class SpiLazyLoadingDemo &#123;    public static void main(String[] args) &#123;        // 这里不会实例化任何服务提供者        ServiceLoader&lt;PaymentService&gt; loader = ServiceLoader.load(PaymentService.class);                System.out.println(&quot;ServiceLoader已创建，但服务未实例化&quot;);                // 只有在迭代时才会实例化        for (PaymentService service : loader) &#123;            System.out.println(&quot;实例化服务: &quot; + service.getClass().getName());            service.pay(100.0);        &#125;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["实用知识","Java技术","JavaWeb","框架知识","学习","JavaSE","JavaEE","Spring系列","Spring Boot","Java框架","配置相关"]},{"title":"Spring Boot part4-yaml语法及其配置文件的管理和比较","url":"/posts/24419.html","content":"Yaml 语法\r\n\r\n该部分基于菜鸟教程 https://www.runoob.com/w3cnote/yaml-intro.html\r\n\r\nyaml 概述\r\nYAML 是 “YAML Ain’t a Markup Language”（YAML\r\n不是一种标记语言）的递归缩写。在开发的这种语言时，YAML\r\n的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。\r\nYAML\r\n是一种人类可读的数据序列化标准，常用于配置文件、数据交换、API规范等场景。它的设计目标是既能被人类轻松阅读和编写，又能被机器有效解析。\r\nYAML\r\n的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\r\nYAML 的配置文件后缀为 .yml，如：application.yml\r\n。\r\nYAML 的主要特点:\r\n\r\n人类可读性强，语法简洁直观\r\n使用缩进表示层级结构，避免了XML的标签冗余\r\n支持丰富的数据类型\r\n跨语言支持，几乎所有编程语言都有对应的解析库\r\n配置文件后缀为 .yml 或 .yaml\r\n\r\n基本语法\r\n\r\n大小写敏感 - Name 和 name\r\n是不同的键\r\n使用缩进表示层级关系 - 类似Python的语法风格\r\n缩进只允许使用空格，不允许使用Tab -\r\n这是YAML的强制要求\r\n缩进的空格数量不限 - 但同一层级必须左对齐\r\n冒号后必须跟空格 -\r\nkey: value，不能写成key:value\r\n井号表示注释 - # 这是注释\r\n\r\n数据类型\r\nYAML 支持以下几种数据类型：\r\n\r\n对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） /\r\n字典（dictionary）\r\n数组：一组按次序排列的值，又称为序列（sequence） /\r\n列表（list）\r\n纯量 (标量)（scalars）：基本数据类型\r\n\r\nYAML 对象\r\n对象键值对使用冒号结构表示 key:\r\nvalue，冒号后面要加一个空格。\r\n也可以使用 key:{key1: value1, key2: value2, …}。\r\n还可以使用缩进表示层级关系；\r\n# 简单的键值对user:  name: Alice  age: 30  email: alice@example.com\r\n# 嵌套映射company:  name: Tech Corp  address:    street: 123 Main St    city: San Francisco    country: USA  employees:    - name: Alice      position: Developer    - name: Bob        position: Designer\r\n较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的\r\nkey，配合一个冒号加一个空格代表一个 value：\r\n# 使用引号包围复杂键名&quot;user name&quot;: John&quot;api-key&quot;: abc123&quot;@context&quot;: &quot;https://schema.org&quot;# 使用问号语法定义复杂键? [key1, key2]: value_for_complex_key?   name: complex_object_key  type: identifier:  result: success  data: processed\r\n意思即对象的属性是一个数组\r\n[complexkey1,complexkey2]，对应的值也是一个数组\r\n[complexvalue1,complexvalue2]\r\n而且还支持一种行内映射的形式\r\n# 行内格式（类似JSON）user: &#123;name: Alice, age: 30, city: &quot;New York&quot;&#125;coordinates: &#123;x: 10, y: 20, z: 5&#125;\r\nYAML 数组\r\n以 - 开头的行表示构成一个数组：\r\n# 使用短横线表示数组元素languages:  - Python  - JavaScript  - Go  - Rust# 嵌套序列projects:  - name: Project A    languages:      - Python      - Django    status: active  - name: Project B    languages:      - JavaScript      - React    status: completed\r\nYAML 支持多维数组，可以使用行内表示：\r\n# 行内数组格式numbers: [1, 2, 3, 4, 5]colors: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]mixed: [1, &quot;hello&quot;, true, null]xxxxxxxxxx4 1# 行内数组格式2numbers: [1, 2, 3, 4, 5]3colors: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]4mixed: [1, &quot;hello&quot;, true, null]key: [value1, value2, ...]yanl\r\n多维序列\r\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\r\n# 矩阵/二维数组matrix:  - [1, 2, 3]  - [4, 5, 6]  - [7, 8, 9]# 或者使用嵌套格式matrix_nested:  -    - 1    - 2    - 3  -    - 4    - 5    - 6\r\n一个相对复杂的例子：\r\ncompanies:    -        id: 1        name: company1        price: 200W    -        id: 2        name: company2        price: 500W\r\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price\r\n三个属性构成。\r\n数组也可以使用流式(flow)的方式表示：\r\ncompanies: [&#123;id: 1,name: company1,price: 200W&#125;,&#123;id: 2,name: company2,price: 500W&#125;]\r\n复合结构\r\n数组和对象可以构成复合结构，例：\r\nlanguages:  - Ruby  - Perl  - Python websites:  YAML: yaml.org   Ruby: ruby-lang.org   Python: python.org   Perl: use.perl.org\r\n转换为 json 为：\r\n&#123;   languages: [ &#x27;Ruby&#x27;, &#x27;Perl&#x27;, &#x27;Python&#x27;],  websites: &#123;    YAML: &#x27;yaml.org&#x27;,    Ruby: &#x27;ruby-lang.org&#x27;,    Python: &#x27;python.org&#x27;,    Perl: &#x27;use.perl.org&#x27;   &#125; &#125;\r\n纯量\r\n纯量是最基本的，不可再分的值，包括：\r\n\r\n字符串\r\n布尔值\r\n整数\r\n浮点数\r\nNull\r\n时间\r\n日期\r\n\r\n使用一个例子来快速了解纯量的基本使用：\r\nboolean:     - TRUE  #true,True都可以    - FALSE  #false，False都可以float:    - 3.14    - 6.8523015e+5  #可以使用科学计数法int:    - 123    - 0b1010_0111_0100_1010_1110    #二进制表示null:    nodeName: &#x27;node&#x27;    parent: ~  #使用~表示nullstring:    - 哈哈    - &#x27;Hello world&#x27;  #可以使用双引号或者单引号包裹特殊字符    - newline      newline2    #字符串可以拆成多行，每一行会被转化成一个空格date:    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dddatetime:     -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\r\n引用\r\n锚点和引用是YAML中避免重复配置的强大功能。它类似于编程中的变量定义和使用。\r\n\r\n锚点（Anchor）：使用 &amp;\r\n符号定义，相当于给一段配置起个名字\r\n引用（Reference）：使用 *\r\n符号引用，相当于使用之前定义的配置\r\n合并（Merge）：使用 &lt;&lt;\r\n符号，将引用的内容合并到当前位置\r\n\r\n简单值的引用\r\n# 定义锚点 - 给值起个名字database_host: &amp;db_host &quot;localhost&quot;cache_host: &amp;cache_host &quot;redis.example.com&quot;# 使用引用 - 复用之前定义的值services:  api:    database_url: *db_host    # 相当于 &quot;localhost&quot;    cache_url: *cache_host    # 相当于 &quot;redis.example.com&quot;    worker:    database_url: *db_host    # 同样是 &quot;localhost&quot;    cache_url: *cache_host    # 同样是 &quot;redis.example.com&quot;\r\n相当于\r\n# 等价于以下配置database_host: &quot;localhost&quot;cache_host: &quot;redis.example.com&quot;services:  api:    database_url: &quot;localhost&quot;    cache_url: &quot;redis.example.com&quot;    worker:    database_url: &quot;localhost&quot;    cache_url: &quot;redis.example.com&quot;\r\n对象的引用和合并\r\n&amp;\r\n用来建立锚点（defaults），&lt;&lt;\r\n表示合并到当前数据，***** 用来引用锚点。\r\n# 定义一个配置对象的锚点default_database: &amp;db_defaults  driver: postgresql  port: 5432  pool_size: 10  timeout: 30  ssl: true# 使用 &lt;&lt; 合并操作符development:  database:    &lt;&lt;: *db_defaults        # 合并所有默认配置    host: localhost         # 添加新的属性    name: dev_database      # 添加新的属性production:  database:    &lt;&lt;: *db_defaults        # 再次使用相同的默认配置    host: prod.db.com       # 添加不同的host    name: prod_database     # 添加不同的name    ssl: false              # 覆盖默认的ssl设置\r\n解析结果\r\n# 等价于以下完整配置default_database:  driver: postgresql  port: 5432  pool_size: 10  timeout: 30  ssl: truedevelopment:  database:    driver: postgresql      # 来自 *db_defaults    port: 5432             # 来自 *db_defaults      pool_size: 10          # 来自 *db_defaults    timeout: 30            # 来自 *db_defaults    ssl: true              # 来自 *db_defaults    host: localhost        # 新增的属性    name: dev_database     # 新增的属性production:  database:    driver: postgresql      # 来自 *db_defaults    port: 5432             # 来自 *db_defaults    pool_size: 10          # 来自 *db_defaults    timeout: 30            # 来自 *db_defaults    ssl: false             # 覆盖了默认值true    host: prod.db.com      # 新增的属性    name: prod_database    # 新增的属性\r\n数组的引用\r\n# 定义数组锚点common_dependencies: &amp;common_deps  - lodash  - moment  - axiosbasic_tools: &amp;basic_tools  - webpack  - babel# 直接引用整个数组frontend_project:  dependencies: *common_deps  # 相当于：  # dependencies:  #   - lodash  #   - moment    #   - axios# 在数组中混合使用引用和新元素backend_project:  dependencies:    - express           # 新增的依赖    - *common_deps      # 引用整个数组，会展开    - mongoose          # 再新增的依赖# 组合多个数组引用fullstack_project:  dependencies:    - react    - *common_deps      # 展开 common_deps    - *basic_tools      # 展开 basic_tools    - typescript\r\n相当于\r\n# backend_project 等价于：backend_project:  dependencies:    - express    - lodash           # 来自 *common_deps    - moment           # 来自 *common_deps      - axios            # 来自 *common_deps    - mongoose# fullstack_project 等价于：fullstack_project:  dependencies:    - react    - lodash           # 来自 *common_deps    - moment           # 来自 *common_deps    - axios            # 来自 *common_deps    - webpack          # 来自 *basic_tools    - babel            # 来自 *basic_tools    - typescript\r\n多个锚点的组合使用\r\n# 定义多个不同用途的锚点database_config: &amp;db_config  driver: mysql  charset: utf8mb4  pool_min: 5  pool_max: 20cache_config: &amp;cache_config  provider: redis  ttl: 3600  max_memory: &quot;512mb&quot;logging_config: &amp;log_config  level: info  format: json  rotation: daily# 组合使用多个锚点microservices:  user_service:    &lt;&lt;: *db_config      # 合并数据库配置    &lt;&lt;: *cache_config   # 合并缓存配置      &lt;&lt;: *log_config     # 合并日志配置    port: 8001          # 服务特有配置      order_service:    &lt;&lt;: *db_config      # 复用数据库配置    &lt;&lt;: *log_config     # 复用日志配置    port: 8002          # 不同的端口    # 注意：这里没有使用缓存配置      payment_service:    &lt;&lt;: *db_config      # 复用数据库配置    &lt;&lt;: *cache_config   # 复用缓存配置    port: 8003    # 覆盖日志级别    level: debug        # 这会覆盖 log_config 中的 level\r\n相当于\r\n# user_service 等价于：microservices:  user_service:    # 来自 db_config    driver: mysql    charset: utf8mb4    pool_min: 5    pool_max: 20    # 来自 cache_config    provider: redis    ttl: 3600    max_memory: &quot;512mb&quot;    # 来自 log_config    level: info    format: json    rotation: daily    # 服务特有    port: 8001  order_service:    # 来自 db_config    driver: mysql    charset: utf8mb4    pool_min: 5    pool_max: 20    # 来自 log_config    level: info    format: json    rotation: daily    # 服务特有    port: 8002\r\nyaml 的多文档支持\r\n# 第一个文档---name: Document 1type: configdata:  key1: value1  key2: value2# 第二个文档---name: Document 2type: dataitems:  - item1  - item2  - item3# 文档结束标记（可选）...\r\n标签和类型转换\r\n# 显式类型标签integer_value: !!int &quot;123&quot;float_value: !!float &quot;456.789&quot;string_value: !!str 123boolean_value: !!bool &quot;yes&quot;# 自定义标签custom_object: !MyClass  property1: value1  property2: value2# 二进制数据binary_data: !!binary |  R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5  OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+  +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\r\nSpring Boot 管理配置文件\r\n注入配置文件\r\nyaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值，它允许开发者以声明式的方式配置应用程序\r\nSpring\r\nBoot支持将YAML配置文件中的属性值自动注入到Java类中，主要通过以下几种方式实现：\r\n使用@Value注解与配置文件占位符\r\n@Value注解可以直接用于字段、方法参数和构造器参数，以注入配置文件中的值。它适用于简单的配置项。\r\nserver:  port: 8080  app:  name: MyApplication  version: 1.0.0  author: ergoutree\r\nproperties 也可以这样\r\nserver.port=8080app.name=MyApplicationapp.version=1.0.0app.author=ergoutree\r\nJava类示例：\r\n@Componentpublic class AppInfoService &#123;        @Value(&quot;$&#123;app.name&#125;&quot;)    private String appName;        @Value(&quot;$&#123;app.version&#125;&quot;)    private String version;        @Value(&quot;$&#123;server.port&#125;&quot;)    private int serverPort;        // 支持默认值，如果配置不存在则使用默认值    @Value(&quot;$&#123;app.description:这是一个Spring Boot应用&#125;&quot;)    private String description;        public void printAppInfo() &#123;        System.out.println(&quot;应用名称: &quot; + appName);        System.out.println(&quot;版本: &quot; + version);        System.out.println(&quot;端口: &quot; + serverPort);        System.out.println(&quot;描述: &quot; + description);    &#125;&#125;\r\n\r\n@Value(\"$&#123;app.name&#125;\") 会自动将YAML中的\r\napp.name 值注入到 appName 字段\r\n支持嵌套属性，如 server.port\r\n可以设置默认值，语法是 $&#123;key:defaultValue&#125;\r\n\r\n@ConfigurationProperties:\r\n@ConfigurationProperties 是\r\nSpring Boot 中的一个注解，用于将配置文件中的属性值绑定到 Java Bean\r\n上。提供了一种更类型安全的方式来处理配置。这种方式适合注入一组相关的配置属性，更加优雅和类型安全。\r\n通常，这个注解用于将外部属性文件中的属性值映射到应用程序的配置类中，以便在整个应用程序中方便地访问和使用这些属性。\r\n这个注解通常与 @Configuration（声明是一个配置类） 或\r\n@Component（声明是一个bean）一起使用，将配置属性绑定到一个特定的\r\nJava Bean，然后以便让 Spring 容器识别并管理这个 Bean。\r\n通过在类上使用\r\n@ConfigurationProperties，可以将属性文件中的键与 Java Bean\r\n的字段或属性进行映射。\r\ndatabase:  host: localhost  port: 3306  username: root  password: 123456  driver-class-name: com.mysql.cj.jdbc.Driver  connection-timeout: 30000  max-connections: 10email:  smtp:    host: smtp.qq.com    port: 587    username: example@qq.com    password: your-password  from: noreply@example.com  templates:    welcome: welcome-template.html    reset-password: reset-password-template.html\r\n@Component@ConfigurationProperties(prefix = &quot;database&quot;)@Data  // Lombok注解，自动生成getter/setterpublic class DatabaseProperties &#123;    private String host;    private int port;    private String username;    private String password;    private String driverClassName;    private long connectionTimeout;    private int maxConnections;&#125;@Component   // 声明为 Spring Bean@ConfigurationProperties(prefix = &quot;email&quot;)@Datapublic class EmailProperties &#123;    private Smtp smtp = new Smtp();    private String from;    private Map&lt;String, String&gt; templates = new HashMap&lt;&gt;();        @Data    public static class Smtp &#123;        private String host;        private int port;        private String username;        private String password;    &#125;&#125;\r\n@Servicepublic class EmailService &#123;        private final EmailProperties emailProperties;        public EmailService(EmailProperties emailProperties) &#123;        this.emailProperties = emailProperties;    &#125;        public void sendEmail() &#123;        System.out.println(&quot;SMTP主机: &quot; + emailProperties.getSmtp().getHost());        System.out.println(&quot;SMTP端口: &quot; + emailProperties.getSmtp().getPort());        System.out.println(&quot;发件人: &quot; + emailProperties.getFrom());        System.out.println(&quot;欢迎模板: &quot; + emailProperties.getTemplates().get(&quot;welcome&quot;));    &#125;&#125;\r\n说明：\r\n\r\n@ConfigurationProperties(prefix = \"database\")\r\n会将所有以 database 开头的配置映射到该类\r\n支持嵌套对象，如 email.smtp 会映射到\r\nEmailProperties.Smtp 类\r\n支持集合类型，如 Map templates\r\n需要提供标准的getter/setter方法（可使用Lombok简化）\r\n\r\n在Spring\r\nBoot的启动类或配置类上添加@EnableConfigurationProperties注解来启用@ConfigurationProperties支持\r\n对于Spring Boot 2.2及以上版本，这一步通常是可选的，因为Spring\r\nBoot会自动配置\r\nEnvironment方式\r\n在Spring\r\nBoot中，Environment抽象是Spring框架提供的一个接口，它允许你访问配置属性以及应用程序的环境。虽然Environment不是一个专门用于注入配置的方式（像@Value或@ConfigurationProperties那样），但它可以在某些情况下非常有用，特别是当你需要访问低级别的配置信息或进行条件化配置时。\r\nEnvironment\r\n接口提供了多种方法来获取配置属性，包括通过键名（key）直接访问和通过解析占位符（placeholders）来访问。\r\n也就是说，读取环境变量，但是不仅仅读取环境变量它会从多个配置源读取配置，包括但不限于：\r\n\r\n.环境变量（Operating System Environment Variables）\r\n系统属性（System Properties）\r\n配置文件\r\n\r\n@Componentpublic class EnvironmentService &#123;        private final Environment environment;        // 构造函数注入    public EnvironmentService(Environment environment) &#123;        this.environment = environment;    &#125;        // 或者使用@Autowired字段注入    // @Autowired    // private Environment environment;        public void demonstrateEnvironment() &#123;        // 获取配置属性        String appName = environment.getProperty(&quot;app.name&quot;);        Integer serverPort = environment.getProperty(&quot;server.port&quot;, Integer.class);        String description = environment.getProperty(&quot;app.description&quot;, &quot;默认描述&quot;);                System.out.println(&quot;应用名称: &quot; + appName);        System.out.println(&quot;服务端口: &quot; + serverPort);        System.out.println(&quot;应用描述: &quot; + description);                // 获取当前激活的Profile        String[] activeProfiles = environment.getActiveProfiles();        System.out.println(&quot;激活的Profile: &quot; + Arrays.toString(activeProfiles));                // 检查属性是否存在        if (environment.containsProperty(&quot;database.url&quot;)) &#123;            System.out.println(&quot;数据库URL: &quot; + environment.getProperty(&quot;database.url&quot;));        &#125;    &#125;&#125;\r\nEnvironment 接口的常用方法\r\n@Servicepublic class ConfigurationService &#123;        private final Environment env;        public ConfigurationService(Environment env) &#123;        this.env = env;    &#125;        public void demonstrateEnvironmentMethods() &#123;        // 1. getProperty() - 获取属性值        String stringValue = env.getProperty(&quot;app.name&quot;);                // 2. getProperty(key, targetType) - 带类型转换        Integer intValue = env.getProperty(&quot;server.port&quot;, Integer.class);        Boolean boolValue = env.getProperty(&quot;app.debug&quot;, Boolean.class);                // 3. getProperty(key, defaultValue) - 带默认值        String valueWithDefault = env.getProperty(&quot;app.title&quot;, &quot;默认标题&quot;);                // 4. getProperty(key, targetType, defaultValue) - 带类型转换和默认值        Integer portWithDefault = env.getProperty(&quot;custom.port&quot;, Integer.class, 9090);                // 5. getRequiredProperty() - 必需属性，不存在会抛异常        try &#123;            String requiredValue = env.getRequiredProperty(&quot;app.name&quot;);            System.out.println(&quot;必需属性: &quot; + requiredValue);        &#125; catch (IllegalStateException e) &#123;            System.out.println(&quot;必需属性不存在: &quot; + e.getMessage());        &#125;                // 6. containsProperty() - 检查属性是否存在        boolean hasProperty = env.containsProperty(&quot;app.version&quot;);                // 7. getActiveProfiles() - 获取激活的Profile        String[] activeProfiles = env.getActiveProfiles();                // 8. getDefaultProfiles() - 获取默认Profile        String[] defaultProfiles = env.getDefaultProfiles();                // 9. acceptsProfiles() - 检查Profile是否激活        boolean acceptsDev = env.acceptsProfiles(&quot;dev&quot;);        boolean acceptsDevOrTest = env.acceptsProfiles(&quot;dev&quot;, &quot;test&quot;);                System.out.println(&quot;字符串值: &quot; + stringValue);        System.out.println(&quot;整数值: &quot; + intValue);        System.out.println(&quot;布尔值: &quot; + boolValue);        System.out.println(&quot;带默认值: &quot; + valueWithDefault);        System.out.println(&quot;端口带默认值: &quot; + portWithDefault);        System.out.println(&quot;包含版本属性: &quot; + hasProperty);        System.out.println(&quot;激活的Profile: &quot; + Arrays.toString(activeProfiles));        System.out.println(&quot;默认Profile: &quot; + Arrays.toString(defaultProfiles));        System.out.println(&quot;接受dev Profile: &quot; + acceptsDev);        System.out.println(&quot;接受dev或test Profile: &quot; + acceptsDevOrTest);    &#125;&#125;\r\n\r\nEnvironment提供了对配置属性的广泛访问，但它不是类型安全的。若需要类型安全的配置绑定，建议使用@ConfigurationProperties。\r\nEnvironment 还提供了对活动 profiles\r\n的访问，这在进行条件化配置时非常有用。\r\n当你需要访问 Spring Boot 的 application.properties 或\r\napplication.yml 文件中的配置时，Environment\r\n是一个很好的选择，但它也可以访问其他来源的配置，如命令行参数、JNDI、servlet上下文参数等。\r\n\r\n@Configuration注解+@Bean\r\n（还可以加@Import引入三方）\r\n先用@Configuration标记一个类作为配置类，相当于 XML\r\n中的&lt;beans&gt;标签\r\n\r\n配置类会被 Spring 容器扫描并处理。\r\n配置类中的@Bean方法会被容器调用以创建和管理 Bean。\r\n配置类本身也是一个 Bean，可以被其他组件注入。\r\n\r\n然后用@Bean标记其中的方法，返回一个对象并注册为 Spring\r\n容器中的 Bean。\r\n\r\n方法名默认作为 Bean\r\n的名称（可通过name属性指定其他名称）。\r\n可以指定 Bean 的作用域（如@Scope(\"prototype\")）。\r\n可以通过@DependsOn指定依赖关系。\r\n\r\n之后不同的地方就是，使用@Import导入其他配置类，将它们的\r\nBean 定义合并到当前配置中。\r\n\r\n引入第三方库的配置类。\r\n模块化配置，将相关配置分散到多个类中。\r\n导入没有使用@Configuration注解的普通类（会被当作配置类处理）。\r\n\r\n这是基础配置类与 Bean 定义\r\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AppConfig &#123;    @Bean    public MyService myService() &#123;        return new MyServiceImpl(); // 创建并返回一个Bean    &#125;    @Bean(name = &quot;customDataSource&quot;)    public DataSource dataSource() &#123;        // 配置并返回数据源        return DataSourceBuilder.create()                .url(&quot;jdbc:mysql://localhost:3306/mydb&quot;)                .username(&quot;root&quot;)                .password(&quot;password&quot;)                .build();    &#125;&#125;\r\n在这之上，我们就可以使用@Import引入其他配置类\r\nimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import(&#123;DatabaseConfig.class, SecurityConfig.class&#125;) // 导入其他配置类public class AppConfig &#123;    // 可以继续定义其他Bean&#125;// DatabaseConfig.java@Configurationpublic class DatabaseConfig &#123;    @Bean    public DataSource dataSource() &#123;        // 配置数据源    &#125;&#125;// SecurityConfig.java@Configurationpublic class SecurityConfig &#123;    @Bean    public AuthenticationManager authenticationManager() &#123;        // 配置认证管理器    &#125;&#125;\r\n使用 @PropertySources\r\n@PropertySources是@PropertySource的容器注解，用于同时指定多个配置文件源。\r\n创建多个自定义配置文件\r\n# custom.properties:custom.app.name=自定义应用custom.app.version=2.0.0custom.database.driver=mysqlcustom.cache.enabled=truecustom.cache.ttl=3600# business.properties:business.module.user=用户管理模块business.module.order=订单处理模块business.feature.payment=truebusiness.feature.notification=false\r\n使用@PropertySource的配置类示例\r\n基本用法，指定了使用 custom.properties\r\n@Configuration@PropertySource(&quot;classpath:custom.properties&quot;)public class CustomConfiguration &#123;        @Autowired    private Environment env;        @Bean    public CustomAppProperties customAppProperties() &#123;        CustomAppProperties props = new CustomAppProperties();        props.setName(env.getProperty(&quot;custom.app.name&quot;));        props.setVersion(env.getProperty(&quot;custom.app.version&quot;));        props.setDatabaseDriver(env.getProperty(&quot;custom.database.driver&quot;));        props.setCacheEnabled(env.getProperty(&quot;custom.cache.enabled&quot;, Boolean.class, false));        props.setCacheTtl(env.getProperty(&quot;custom.cache.ttl&quot;, Integer.class, 1800));        return props;    &#125;&#125;@Datapublic class CustomAppProperties &#123;    private String name;    private String version;    private String databaseDriver;    private boolean cacheEnabled;    private int cacheTtl;&#125;\r\n@PropertySources多文件配置\r\n@Configuration@PropertySources(&#123;    @PropertySource(&quot;classpath:custom.properties&quot;),    @PropertySource(&quot;classpath:business.properties&quot;),    @PropertySource(value = &quot;classpath:optional.properties&quot;, ignoreResourceNotFound = true),    @PropertySource(value = &quot;file:$&#123;user.home&#125;/app-config.properties&quot;, ignoreResourceNotFound = true)&#125;)public class MultiplePropertySourcesConfiguration &#123;        @Autowired    private Environment env;        @Bean    public ApplicationSettings applicationSettings() &#123;        ApplicationSettings settings = new ApplicationSettings();                // 从custom.properties读取        settings.setAppName(env.getProperty(&quot;custom.app.name&quot;));        settings.setAppVersion(env.getProperty(&quot;custom.app.version&quot;));        settings.setCacheEnabled(env.getProperty(&quot;custom.cache.enabled&quot;, Boolean.class));                // 从business.properties读取        settings.setUserModule(env.getProperty(&quot;business.module.user&quot;));        settings.setOrderModule(env.getProperty(&quot;business.module.order&quot;));        settings.setPaymentEnabled(env.getProperty(&quot;business.feature.payment&quot;, Boolean.class));                return settings;    &#125;        @PostConstruct   // 在 Bean 初始化后执行    public void printConfiguration() &#123;        System.out.println(&quot;=== 配置信息 ===&quot;);        System.out.println(&quot;应用名称: &quot; + env.getProperty(&quot;custom.app.name&quot;));        System.out.println(&quot;应用版本: &quot; + env.getProperty(&quot;custom.app.version&quot;));        System.out.println(&quot;用户模块: &quot; + env.getProperty(&quot;business.module.user&quot;));        System.out.println(&quot;订单模块: &quot; + env.getProperty(&quot;business.module.order&quot;));        System.out.println(&quot;缓存启用: &quot; + env.getProperty(&quot;custom.cache.enabled&quot;));        System.out.println(&quot;支付功能: &quot; + env.getProperty(&quot;business.feature.payment&quot;));    &#125;&#125;@Datapublic class ApplicationSettings &#123;    private String appName;    private String appVersion;    private String userModule;    private String orderModule;    private Boolean cacheEnabled;    private Boolean paymentEnabled;&#125;\r\n\r\n加载多个配置文件：通过@PropertySources注解可以声明加载多个配置文件。\r\n\r\nclasspath: 前缀表示从类路径加载。\r\nfile:\r\n前缀表示从文件系统加载，支持使用环境变量（如$&#123;user.home&#125;）。\r\n\r\n加载顺序：配置文件按声明顺序加载，后加载的文件会覆盖前面文件中同名的属性（例如，如果app-config.properties和custom.properties都有custom.app.name属性，将使用app-config.properties中的值）。\r\n可选文件：通过ignoreResourceNotFound = true指定可选文件，如果文件不存在则忽略（如optional.properties和用户主目录下的配置文件）。\r\n\r\n条件化属性源\r\n@Configurationpublic class ConditionalPropertySourceConfiguration &#123;        @Configuration    @Profile(&quot;dev&quot;)    @PropertySources(&#123;        @PropertySource(&quot;classpath:dev.properties&quot;),        @PropertySource(&quot;classpath:dev-database.properties&quot;)    &#125;)    static class DevConfiguration &#123;    &#125;        @Configuration    @Profile(&quot;prod&quot;)    @PropertySources(&#123;        @PropertySource(&quot;classpath:prod.properties&quot;),        @PropertySource(&quot;classpath:prod-database.properties&quot;)    &#125;)    static class ProdConfiguration &#123;    &#125;        @Configuration    @Profile(&quot;test&quot;)    @PropertySource(&quot;classpath:test.properties&quot;)    static class TestConfiguration &#123;    &#125;&#125;\r\n\r\n@Profile\r\n注解：根据激活的环境（如dev、prod、test）选择性加载配置类。\r\n@PropertySource\r\n注解：然后加载特定环境的配置文件。实现环境配置分离\r\n\r\n使用\r\n@ImportResource 加载 XML 配置文件\r\n如果你有传统的 Spring XML 配置文件，需要在 Spring Boot 中加载。\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;myService&quot; class=&quot;com.example.MyService&quot;&gt;        &lt;property name=&quot;message&quot; value=&quot;Hello from XML!&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;@SpringBootApplication@ImportResource(&quot;classpath:applicationContext.xml&quot;)  // 加载 XML 配置public class MyApp &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MyApp.class, args);    &#125;&#125;\r\nSpring\r\nBoot 中的 application.properties 与 application.yaml\r\n其实SpringBoot的配置文件有.properties和.yml两种形式，两种配置文件的效果类似，只不过是格式不同而已\r\nSpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的\r\n\r\napplication.properties\r\n\r\n语法：使用 key=value 格式，用\r\n. 分隔层级。\r\n简单直接，适合简单配置。\r\n支持占位符引用（如 $&#123;app.name&#125;）。\r\n不支持复杂的嵌套结构（需重复前缀）。\r\n\r\napplication.yaml /\r\napplication.yml\r\n\r\n语法：使用 key: value\r\n格式，通过缩进表示层级。\r\n结构清晰，适合复杂配置（减少重复前缀）。\r\n支持列表、对象嵌套。\r\n更易读，尤其对于多层次配置。\r\n\r\n\r\n注意：\r\n\r\n当properties和yml同时存在时，properties的优先级会比yml高\r\n两种文件都是用#注释，yml\r\n的优点在于可以省去一下重复代码\r\n在properties文件里面的. 连接在yml文件里面全部换成\r\n：\r\n进行连接，并且每一级之间必须换行，在第二级开始应该进行几个空格的缩进，如果是同级的就不需要进行缩进\r\n\r\nproperties 文件和 yml\r\n文件优先级：\r\nSpring Boot\r\n对配置文件的加载遵循特定的顺序和优先级，总结如下：\r\n单文件优先级\r\n\r\n相同类型文件：\r\n\r\n高优先级位置的文件覆盖低优先级位置的文件。\r\n优先级从高到低：\r\n\r\n命令行参数（如 --server.port=8081）。\r\n\r\n```bash java -jar app.jar –server.port=8081\r\n–spring.profiles.active=prod    - 直接在启动应用时传入的参数   - 格式：`--属性名=值`   - 优先级最高，会覆盖所有其他配置2. 环境变量（如 `SERVER_PORT=8081`）。   ```bash   export SERVER_PORT=8081   export SPRING_PROFILES_ACTIVE=prod\r\n操作系统级别的环境变量\r\nSpring Boot会自动将环境变量转换为配置属性\r\n命名规则：大写字母，用下划线分隔\r\n\r\nSPRING_APPLICATION_JSON 环境变量（JSON\r\n格式配置）。\r\nexport SPRING_APPLICATION_JSON=&#x27;&#123;&quot;server.port&quot;:8081,&quot;logging.level.root&quot;:&quot;DEBUG&quot;&#125;&#x27;\r\n\r\n特殊的环境变量，值为JSON格式\r\n\r\n\r\n\r\n可以一次性设置多个配置项\r\n\r\n比普通环境变量优先级稍低\r\n\r\n\r\n\r\njava:comp/env JNDI 属性。\r\n // 在Java EE容器中通过JNDI设置Context ctx = new InitialContext(); ctx.bind(&quot;java:comp/env/server.port&quot;, &quot;8081&quot;);\r\n\r\n主要用于Java EE环境\r\n通过JNDI（Java命名和目录接口）设置的属性\r\n\r\nJava 系统属性（System.getProperties()）。\r\njava -Dserver.port=8081 -jar app.jar\r\n\r\n通过-D参数设置的JVM系统属性\r\n也可以在代码中通过System.setProperty()设置\r\n\r\nRandomValuePropertySource（随机值，如\r\nrandom.*）。\r\n\r\n# 在配置文件中使用随机值my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.uuid=$&#123;random.uuid&#125;\r\n\r\nSpring Boot内置的随机值生成器\r\n用于生成随机配置值\r\n\r\n应用外部的 application-&#123;profile&#125;.properties 或\r\n.yaml（如\r\nconfig/application.properties）。\r\nproject/├── app.jar├── config/│   ├── application-dev.properties    # 外部Profile配置│   └── application-prod.properties\r\n\r\n位于jar包外部的带环境标识的配置文件\r\n通常放在config/目录下\r\n优先级高于应用内部的同类文件\r\n\r\n应用内部的 application-&#123;profile&#125;.properties 或\r\n.yaml（如\r\nsrc/main/resources/application-dev.properties）。\r\nsrc/main/resources/├── application.properties├── application-dev.properties    # 内部Profile配置└── application-prod.properties\r\n\r\n打包在jar内的带环境标识的配置文件\r\n位于src/main/resources/目录\r\n\r\n应用外部的 application.properties 或\r\n.yaml。\r\nproject/├── app.jar├── config/│   └── application.properties    # 外部通用配置\r\n\r\njar包外部的通用配置文件\r\n不带profile后缀的配置文件\r\n\r\n应用内部的 application.properties 或\r\n.yaml（最低优先级）。\r\nsrc/main/resources/└── application.properties    # 内部通用配置，优先级最低\r\n\r\n打包在jar内的通用配置文件\r\n优先级最低，最容易被其他配置覆盖\r\n\r\n\r\n\r\n\r\n同路径下\r\n.properties 与 .yaml 的优先级\r\n\r\n当 application.properties 和\r\napplication.yaml 同时存在于同一位置时\r\n\r\n.properties 文件优先级更高，会覆盖\r\n.yaml 中的同名属性。\r\n示例\r\n\r\n若 application.properties 包含\r\nserver.port=8080，而 application.yaml 包含\r\nserver.port=8081，则最终端口为 8080。\r\n\r\n\r\n\r\n不同路径下的配置文件\r\n\r\n外部配置 &gt; 内部配置\r\n\r\n位于应用外部（如 config/\r\n目录）的配置文件优先级高于应用内部（src/main/resources）的配置文件。\r\n\r\n\r\n特定环境配置（application-&#123;profile&#125;.properties）\r\n\r\n特定环境配置 &gt; 通用配置：\r\n\r\n激活的环境配置（如\r\napplication-dev.properties）会覆盖通用配置（application.properties）。\r\n若同时存在 application-dev.properties 和\r\napplication-dev.yaml，则 .properties\r\n仍优先。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n场景\r\n优先级顺序（高 → 低）\r\n\r\n\r\n\r\n\r\n同类型文件\r\n外部 &gt; 内部，特定环境 &gt; 通用环境\r\n\r\n\r\n同路径下 .properties vs .yaml\r\n.properties &gt; .yaml\r\n\r\n\r\n特定环境配置\r\napplication-&#123;profile&#125;.properties &gt;\r\napplication.properties\r\n\r\n\r\n\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","语言基础","Spring Boot","Java框架","配置文件"]},{"title":"Spring Boot part6-Web开发之Web场景与静态资源","url":"/posts/10985.html","content":"该文章较多源码分析））\r\nWeb 场景中的自动配置\r\n如何使用 Spring Boot，进行 web 开发\r\nSpring Boot 的 Web 开发能力，由 SpringMVC 提供，给予了 Spring MVC\r\n自动配置的能力\r\n一般来说，在 Spring Initliazer 中，勾选一个web starter\r\n场景，再选上一个 Lombok 就可以了。\r\n前面说过，Spring Boot 将会帮我们自动配置好 web\r\n开发场景中需要的相关配置，只需要在配置文件中指定少量配置就可以运行起来了，我们只需要注意在业务代码中就可以了。\r\n自动配置\r\nSpring Boot 的自动配置类是其核心特性之一，通过\r\n@EnableAutoConfiguration 注解和\r\nAutoConfigurationImportSelector 机制，会从类路径下的\r\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.imports\r\n文件中加载自动配置类\r\n\r\n整合 Web 场景\r\n&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;/dependency&gt;\r\n引入了 autoconfigure功能\r\n@EnableAutoConfiguration\r\n会使用@Import(AutoConfigurationImportSelector.class)批量导入一些组件\r\n加载META-INF/spring/org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.imports文件中配置的所有组件\r\n大约重要的所有自动配置类如下\r\n\r\nWeb 相关自动配置类\r\n\r\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration\r\n配置 Spring MVC\r\n的核心组件，如控制器、视图解析器、静态资源处理等。\r\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration\r\n配置嵌入式 Servlet 容器（如 Tomcat、Jetty）的工厂类。\r\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration\r\n配置 HTTP 消息转换器（如 JSON、XML 转换）。\r\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration\r\n配置错误处理页面和异常处理机制。\r\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration\r\n基于 Spring WebFlux，支持 Netty 服务器的响应式编程模型，新增对\r\nWebAssembly 部署的支持。\r\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration\r\n默认使用 Jackson 2.16+，新增对 JSON Schema 自动生成的支持（通过\r\n@Schema 注解）。\r\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration\r\n（响应式 Web）配置 Reactive 模式的 Web 服务器工厂。\r\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration\r\n配置 WebSocket 的 Servlet 支持。\r\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration\r\n配置响应式 WebSocket 支持。\r\n\r\n数据访问相关自动配置类\r\n\r\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\r\n配置数据源（DataSource），支持 JDBC 连接池。默认连接池为 HikariCP\r\n5.0。\r\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration\r\n配置 JDBC Template，简化数据库操作。\r\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration\r\n配置 JPA（Hibernate 实现），支持实体映射和数据库操作。\r\norg.springframework.boot.autoconfigure.mybatis.MybatisAutoConfiguration\r\n（MyBatis 框架）配置 MyBatis 集成，自动扫描 mapper 接口和 XML\r\n配置。\r\norg.springframework.boot.autoconfigure.redis.RedisAutoConfiguration\r\n配置 Redis 缓存连接和操作组件。\r\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration\r\n配置 MongoDB 数据库连接和操作组件。\r\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration\r\n配置 Cassandra 数据库连接。\r\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchAutoConfiguration\r\n配置 Elasticsearch 搜索引擎连接。\r\n\r\n缓存与消息中间件相关\r\n\r\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration\r\n配置 Spring 缓存抽象（Cache），支持多种缓存实现（如\r\nRedis、Caffeine）。\r\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration\r\n配置 Kafka 消息中间件的生产者和消费者。\r\norg.springframework.boot.autoconfigure.rabbit.RabbitAutoConfiguration\r\n配置 RabbitMQ 消息中间件的连接和组件。\r\norg.springframework.boot.autoconfigure.activemq.ActiveMQAutoConfiguration\r\n配置 ActiveMQ 消息中间件。\r\n\r\n安全与认证相关\r\n\r\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration\r\n配置 Spring Security 的基本安全规则。\r\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration\r\n配置用户认证服务（UserDetailsService）。\r\norg.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration\r\n配置 OAuth 2.0 客户端认证。\r\norg.springframework.boot.autoconfigure.security.oauth2.resource.OAuth2ResourceServerAutoConfiguration\r\n配置 OAuth 2.0 资源服务器。\r\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration\r\n配置 HTTP 会话（Session）管理，支持内存、Redis 等存储方式。\r\n\r\n日志与监控相关\r\n\r\norg.springframework.boot.autoconfigure.logging.LoggingAutoConfiguration\r\n配置日志系统（默认使用 Logback），支持日志级别、输出格式等。\r\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration\r\n配置 JMX 管理功能，用于应用监控。\r\norg.springframework.boot.autoconfigure.actuate.metrics.MetricsAutoConfiguration\r\n配置应用指标收集（如 CPU、内存、HTTP 接口耗时）。\r\norg.springframework.boot.autoconfigure.actuate.web.WebEndpointAutoConfiguration\r\n配置 Spring Boot Actuator 的 Web 端点（如\r\n/health、/info）。\r\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration\r\n配置数据库变更管理工具 Liquibase，支持版本控制。\r\norg.springframework.boot.autoconfigure.actuate.observability.ObservabilityAutoConfiguration\r\n内置 Micrometer 1.11.0 和 OTel SDK\r\n1.24.0，自动配置应用指标、链路追踪（默认采样率 100%）。\r\n\r\n\r\n这里只列出了常用的，在 Maven 项目中，查看\r\nspring-boot-autoconfigure 依赖的\r\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.imports\r\n文件，该文件列出了所有可用配置类（3.5.0 约包含 200+\r\n个配置类）。\r\n绑定了配置文件的一堆配置项\r\n\r\nSpring MVC 的所有配置 spring.mvc\r\nWeb 场景通用的配置 spring.web\r\n文件上传配置 spring.servlet.multipart\r\n服务器的一些配置 server 比如编码方式\r\n\r\n如何找：\r\n\r\n\r\nimage-20250528151243616\r\n\r\n\r\n\r\n\r\nimage-20250528151256719\r\n\r\n默认效果\r\n我们上面说了Spring Boot 对 Spring MVC\r\n的自动配置（AutoConfiguration）机制，那么如何在保持默认配置的同时进行自定义扩展，或者完全接管\r\nMVC 配置。所以我们要了解 Spring Boot 对 Spring MVC 的默认配置\r\nSpring Boot 通过 WebMvcAutoConfiguration 类为 Spring MVC\r\n提供了默认配置，主要包含以下默认效果\r\n\r\n包含了 ContentNegotiatingViewResolver 和\r\nBeanNameViewResolver组件，方便视图解析\r\n\r\nContentNegotiatingViewResolver\r\n会根据请求的 Accept 头（如\r\napplication/json、text/html）选择合适的视图解析器，支持内容协商（如返回\r\nJSON 或 HTML）。\r\nBeanNameViewResolver 按 Bean\r\n名称解析视图（例如，控制器返回的视图名与 Bean 名称匹配时生效）\r\n\r\n默认的静态资源处理机制：静态资源放在 static\r\n文件夹下即可直接访问\r\n自动注册了\r\nConverter,GenericConverter,Formatter\r\n组件，适配常见的数据类型转换和格式化需求。\r\n\r\nConverter：类型转换器（如字符串转日期）。\r\nGenericConverter：通用类型转换器（支持更复杂的类型转换逻辑）。\r\nFormatter：格式化器（如日期格式化\r\nyyyy-MM-dd）。\r\n\r\n支持 HttpMessageConverters，可以方便返回 json\r\n等数据类型\r\n\r\nHttpMessageConverters 自动配置\r\nJSON（默认使用 Jackson）、XML（JAXB）等消息转换器，支持\r\n@RequestBody 和 @ResponseBody。\r\n\r\n注册 MessageCodesResolver，方便国际化及错误消息处理\r\n\r\nMessageCodesResolver\r\n处理国际化消息和错误码（如表单验证错误），配合\r\nmessages.properties 使用。\r\n\r\n支持静态index.html，若存在\r\nstatic/index.html，则自动映射为根路径 /\r\n的默认页面\r\n自动使用\r\nConfigurableWebBindingInitializer，实现消息处理、数据绑定、类型转化等功能\r\n\r\nConfigurableWebBindingInitializer\r\n初始化数据绑定器，支持自定义属性编辑器、验证器等。\r\n\r\n\r\n重要：\r\n\r\n如果想保持 boot mvc 的默认配置，并且自定义更多的 mvc\r\n配置，如：interceptors, formatters,\r\nview controllers 等，可以使用\r\n@Configuration 注解添加一个 WebMvcConfigurer\r\n类型的配置类， 并不要标注 @EnableWebMvc。\r\n如果想保持 boot mvc 的默认配置，但要自定义核心组件实例，比如：\r\nRequestMappingHandlerMapping, RequestMappingHandlerAdapter, 或\r\nExceptionHandlerExceptionResolver，给容器中放一个 WebMvcRegistrations\r\n组件即可\r\n如果想全面接管 Spring MVC，@Configuration 标注一个配置类，并加上\r\n@EnableWebMvc\r\n注解，实现 WebMvcConfigurer 接口\r\n\r\nSpring MVC 的请求处理流程：\r\n\r\n客户端发送 HTTP 请求 → DispatcherServlet 接收请求 → 通过\r\nRequestMappingHandlerMapping 找到对应的控制器方法 →\r\n执行方法并返回结果。\r\nRequestMappingHandlerMapping\r\n是这个流程的核心组件，决定了请求如何被路由到具体方法。\r\n\r\n自定义 MVC 配置的三种方式\r\n\r\n扩展默认配置（推荐方式）\r\n\r\n\r\n方式：创建 @Configuration 类并实现\r\nWebMvcConfigurer 接口，不添加\r\n@EnableWebMvc。\r\n效果：保持 Spring Boot\r\n的默认配置，仅添加或修改部分功能（如拦截器、格式化器）。\r\n可扩展的常用功能：\r\n\r\n拦截器（addInterceptors）\r\n格式化器 / 转换器（addFormatters）\r\n视图控制器（addViewControllers）\r\n静态资源处理器（addResourceHandlers）\r\nCORS 配置（addCorsMappings）\r\n\r\n示例\r\n@Configurationpublic class MyWebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);    &#125;        @Override    public void addFormatters(FormatterRegistry registry) &#123;        registry.addFormatter(new MyDateFormatter());    &#125;&#125;\r\n\r\n\r\n自定义核心 MVC 组件\r\n\r\n方式：创建 WebMvcRegistrations\r\n类型的 Bean，覆盖特定组件的创建逻辑。\r\n\r\nWebMvcRegistrations 是 Spring MVC\r\n提供的一个扩展接口，允许开发者替换默认的核心 MVC\r\n组件（如请求映射处理器、请求适配器、异常解析器等），同时保留\r\nSpring Boot 的其他自动配置。\r\n\r\n效果：保持默认配置，但替换核心组件（如\r\nRequestMappingHandlerMapping）。\r\n可自定义的核心组件：\r\n\r\nRequestMappingHandlerMapping（请求映射处理器）\r\nRequestMappingHandlerAdapter（请求处理适配器）\r\nExceptionHandlerExceptionResolver（异常处理解析器）\r\n\r\n示例\r\n@Configurationpublic class MyWebMvcRegistrations implements WebMvcRegistrations &#123;    // RequestMappingHandlerMapping：负责将 HTTP 请求映射到对应的控制器方法（即处理 @RequestMapping、@GetMapping 等注解）    // 通过自定义 RequestMappingHandlerMapping，可以改变请求映射的默认行为（如添加自定义拦截规则、修改路径匹配策略等）。    @Override    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() &#123;        return new CustomRequestMappingHandlerMapping();    &#125;&#125;\r\n\r\n完全接管 MVC 配置\r\n\r\n方式：创建 @Configuration 类并添加\r\n@EnableWebMvc 注解，实现 WebMvcConfigurer\r\n接口。**\r\n效果：禁用 Spring Boot 的所有 MVC\r\n自动配置，完全由开发者手动配置\r\n注意：启用 @EnableWebMvc 后，Spring\r\nBoot 的所有 MVC\r\n默认配置（如静态资源处理、内容协商）将失效，需手动配置所有功能。\r\n示例：\r\n@Configuration@EnableWebMvc // 禁用 Spring Boot 的 MVC 自动配置public class MyWebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        // 手动配置视图解析器        registry.jsp(&quot;/WEB-INF/views/&quot;, &quot;.jsp&quot;);    &#125;        @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        // 手动配置消息转换器        converters.add(new MappingJackson2HttpMessageConverter());    &#125;&#125;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n全自动\r\n直接编写控制器逻辑\r\n\r\n全部使用自动配置默认效果\r\n\r\n\r\n\r\n\r\n手自一体\r\n@Configuration + 配置 WebMvcConfigurer +\r\n配置 WebMvcRegistrations\r\n不要标注@EnableWebMvc\r\n自动配置效果 手动设置部分功能 定义 MVC 底层组件\r\n\r\n\r\n全手动\r\n@Configuration + 配置\r\nWebMvcConfigurer\r\n标注@EnableWebMvc\r\n禁用自动配置效果 全手动设置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n场景\r\n方式\r\n注解\r\n接口 / 组件\r\n\r\n\r\n\r\n\r\n扩展默认配置（如添加拦截器）\r\n扩展配置\r\n@Configuration\r\nWebMvcConfigurer\r\n\r\n\r\n替换核心组件（如自定义请求映射）\r\n自定义组件\r\n@Configuration\r\nWebMvcRegistrations\r\n\r\n\r\n完全控制 MVC 配置（如使用 JSP 视图）\r\n完全接管\r\n@Configuration+@EnableWebMvc\r\nWebMvcConfigurer\r\n\r\n\r\n\r\n总结：所有的自定义模式，给容器类放一个配置类\r\n@Configuration 实现\r\nWebMvcConfigurer，不要标注@EnableWebMvc注解，实现了手自一体的模式。\r\n两种模式\r\n\r\n前后分离模式：@RestController 响应 JSON 数据\r\n将前端和后端作为两个独立的应用进行开发和部署。前端专注于页面展示和用户交互，通过\r\nAPI 与后端进行数据交互；后端专注于业务逻辑处理、数据存储与读取，仅提供\r\nRESTful API 接口给前端调用。\r\n\r\n前端：使用现代前端框架如 Vue.js、React、Angular\r\n等构建单页应用（SPA）或多页应用（MPA） 。以 Vue.js 为例，通过 Vue Router\r\n进行路由管理，利用 Axios 等工具发起 HTTP\r\n请求获取后端数据，然后在组件中进行数据渲染和交互逻辑处理。\r\n后端：使用 @RestController\r\n注解标识控制器类，该注解组合了 @Controller 和\r\n@ResponseBody，表示方法返回值会直接序列化为 JSON\r\n等格式响应给前端。后端基于 Spring Boot 等框架搭建 RESTful\r\nAPI，例如定义接口 /api/user/login\r\n用于用户登录验证，返回包含用户信息的 JSON 数据。\r\n\r\n前后不分离模式：@Controller + Thymeleaf 模板引擎\r\n前端页面的渲染由后端直接处理，后端将数据填充到模板中，然后返回完整的\r\nHTML 页面给浏览器。这种模式下，前后端的耦合度较高。\r\n\r\n后端：使用 @Controller\r\n注解标识控制器类，配合 Thymeleaf、Freemarker 等模板引擎。以 Thymeleaf\r\n为例，在控制器方法中获取业务数据，如查询用户信息，然后将数据模型传递给\r\nThymeleaf 模板。Thymeleaf 模板中通过特定语法（如\r\nth:text、th:each 等）将数据渲染到 HTML\r\n页面中，最终返回完整渲染后的 HTML 页面给前端浏览器。\r\n前端：主要负责页面的基本样式和简单交互，如 HTML\r\n结构搭建、CSS 样式编写，JavaScript\r\n实现简单的表单验证等。相比前后分离模式，前端的逻辑处理相对简单。\r\n\r\n\r\nSpring Boot\r\n对静态资源的映射配置规则\r\n先来讲解一下 Spring Boot\r\n对于静态资源的相关配置规则，我们现在暂时选择来开发一个前后端没有分离的很彻底的应用，如果前后端分离的很彻底，我们只用\r\nSpring Boot 来做后端接口，就不涉及到 Spring Boot\r\n是如何管理静态资源方面的内容了。\r\nWebMvcAutoConfiguration 原理\r\n这个自动配置类的写法如下\r\n生效条件\r\n@AutoConfiguration(    after = &#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)   // 在这些自动配置之后@ConditionalOnWebApplication(    type = Type.SERVLET)   // 如果是 Web 应用就生效，类似 Servlet，Reactive响应式@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)   // 当类路径下存在这三个类才生效@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)   // 规定当 Spring 容器中不存在这个类及其子类的 Bean 才会生效时才会生效@AutoConfigureOrder(-2147483638)   // 指定自动配置类的加载顺序，数值越小优先级越高@ImportRuntimeHints(&#123;WebResourcesRuntimeHints.class&#125;)   // 引入运行时提示相关的配置类。public class WebMvcAutoConfiguration &#123;&#125;\r\n以下是详细解释\r\n\r\n@AutoConfiguration(after = &#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)\r\n\r\n含义：@AutoConfiguration 是 Spring\r\nBoot 用于标识自动配置类的注解 。after\r\n属性指定了该自动配置类的加载顺序，即\r\nWebMvcAutoConfiguration 会在\r\nDispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration\r\n和 ValidationAutoConfiguration 之后进行加载。这确保了在配置\r\nSpring MVC 相关功能时，其依赖的前置组件（如\r\nDispatcherServlet\r\n相关配置、任务执行配置、验证配置）已经完成配置。\r\n作用：保证配置顺序正确，避免因依赖组件未配置而导致的错误，使整个自动配置流程有序进行。\r\n\r\n@ConditionalOnWebApplication(type = Type.SERVLET)\r\n\r\n含义：@ConditionalOnWebApplication\r\n是条件注解，只有当应用是 Web\r\n应用时才会生效。type = Type.SERVLET 限定了仅在 Servlet\r\n类型的 Web 应用场景下该自动配置类才会起作用，像基于 Spring WebFlux\r\n的响应式 Web 应用（Type.REACTIVE）则不会触发此配置。\r\n作用：精准定位适用场景，避免在非 Servlet 类型的 Web\r\n应用中加载不必要的 Spring MVC 配置，提升应用启动性能和配置准确性。\r\n\r\n@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)\r\n\r\n含义：该条件注解表示只有当类路径下存在\r\nServlet.class、DispatcherServlet.class 和\r\nWebMvcConfigurer.class\r\n这几个类时，WebMvcAutoConfiguration\r\n才会生效。Servlet 是 Java Web\r\n开发基础规范类；DispatcherServlet 是 Spring MVC\r\n中负责接收请求并分发到对应处理器的核心\r\nservlet；WebMvcConfigurer 是用于自定义 Spring MVC\r\n配置的接口。这意味着只有引入了相关依赖（如 Spring MVC\r\n依赖），确保这些类存在于项目中，才会进行 Spring MVC 的自动配置。\r\n作用：根据项目实际引入的依赖来判断是否进行 Spring\r\nMVC\r\n相关配置，防止在没有相关依赖的项目中错误加载配置，保证配置的有效性和针对性。\r\n\r\n@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)\r\n\r\n含义：此注解规定当 Spring 容器中不存在\r\nWebMvcConfigurationSupport 及其子类的 Bean\r\n时，WebMvcAutoConfiguration\r\n才会生效。如果开发者自定义了继承 WebMvcConfigurationSupport\r\n的配置类，Spring Boot 认为开发者要对 Spring MVC 进行全面自定义，就会跳过\r\nWebMvcAutoConfiguration 的自动配置。\r\n作用：平衡自动配置和开发者自定义配置的关系，让开发者有能力完全接管\r\nSpring MVC 配置，同时在未进行深度自定义时享受自动配置带来的便利。\r\n\r\n@AutoConfigureOrder(-2147483638)\r\n\r\n含义：@AutoConfigureOrder\r\n用于指定自动配置类的加载顺序，数值越小优先级越高。这里设置为\r\n-2147483638，表明它在自动配置类加载顺序中处于较高优先级，能在一些依赖它的配置之前完成加载。\r\n作用：保证在整个自动配置体系中，Spring MVC\r\n的相关配置能按照预期顺序加载，避免因顺序问题导致的配置冲突或错误。\r\n\r\n@ImportRuntimeHints(&#123;WebResourcesRuntimeHints.class&#125;)\r\n\r\n含义：@ImportRuntimeHints\r\n注解用于引入运行时提示相关的配置类。WebResourcesRuntimeHints.class\r\n会提供关于 Web\r\n资源（如静态资源）在运行时的一些提示信息，帮助应用在运行时更高效地处理和管理这些资源，比如优化资源的查找、加载等操作。\r\n作用：提升应用在运行时对 Web\r\n资源的处理效率和性能，确保资源相关功能的正确执行。\r\n\r\n\r\n效果\r\n那么生效之后是什么效果\r\n放了两个 Filter：\r\n@Bean   @ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)   @ConditionalOnBooleanProperty(&#123;&quot;spring.mvc.hiddenmethod.filter.enabled&quot;&#125;)   public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;       return new OrderedHiddenHttpMethodFilter();   &#125;   @Bean   @ConditionalOnMissingBean(&#123;FormContentFilter.class&#125;)   @ConditionalOnBooleanProperty(       name = &#123;&quot;spring.mvc.formcontent.filter.enabled&quot;&#125;,       matchIfMissing = true   )   public OrderedFormContentFilter formContentFilter() &#123;       return new OrderedFormContentFilter();   &#125;\r\n\r\nHiddenHttpMethodFilter：页面表单可以提交 Rest\r\n请求（GET，POST，PUT，DELETE）\r\nFormContentFilter：表单内容 Filter，只有\r\nGET(数据发url后) POST(数据放请求体)\r\n请求可以携带数据，PUT，DELETE的请求体数据会被忽略\r\n\r\n效果的第一个是这个\r\n该类作为 Spring Boot 自动配置和开发者自定义配置的桥梁，既加载默认的\r\nMVC 配置（通过\r\nEnableWebMvcConfiguration），又允许开发者通过实现\r\nWebMvcConfigurer 接口进行扩展。\r\n// 声明该类是一个配置类，不代理 Bean 方法，即每次调用配置类中的 Bean 方法时，直接创建新实例，而非从 Spring 容器中获取    @Configuration(        proxyBeanMethods = false    )    // 导入 EnableWebMvcConfiguration 类，是 Spring MVC 的核心配置类    @Import(&#123;EnableWebMvcConfiguration.class&#125;)\t// 启用配置属性绑定，将 application.properties 或 application.yml 中的配置项映射到 WebMvcProperties 和 WebProperties 类的实例中    @EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)   // 指定配置类的加载顺序，数值越小优先级越高    @Order(0)    public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware &#123;        ....    &#125;\r\n\r\n实现接口\r\n\r\nWebMvcConfigurer： 提供自定义 Spring\r\nMVC\r\n配置的回调方法（如添加拦截器、配置消息转换器）。通过实现该接口，可在不使用\r\n@EnableWebMvc 的情况下定制 MVC 功能。\r\nServletContextAware： 允许 Bean 获取\r\nServletContext 引用，用于访问 Servlet\r\n容器相关信息（如获取应用上下文路径）。\r\n\r\n\r\n给容器中放了WebMvcConfigurer组件：给 SpringMVC\r\n添加各种定制功能\r\n\r\n所有的功能最终会和配置文件进行绑定\r\nWebMvcProperties：spring.mvc配置文件\r\nWebProperties：spring.web配置文件\r\n\r\nWebMvcConfigurer\r\n这里是 WebMvcConfigurer 这个接口的源码，提供了配置\r\nSpring MVC 底层的所有组件入口\r\n// WebMvcConfigurer接口用于对Spring MVC进行自定义配置public interface WebMvcConfigurer &#123;    // 配置路径匹配相关策略，比如设置路径匹配的后缀策略、路径分隔符等    default void configurePathMatch(PathMatchConfigurer configurer) &#123;    &#125;    // 配置内容协商策略，例如根据请求头中的Accept字段决定返回的数据格式（如JSON、XML等）    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;    &#125;    // 异步支持，配置异步支持相关参数，如异步请求的超时时间、任务执行器等    default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;    &#125;    // 配置默认Servlet处理策略，比如当Spring MVC无法处理请求时，是否转发给默认Servlet    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;    &#125;    // 向FormatterRegistry中添加自定义的格式化器，用于数据类型的格式化和解析，如日期格式化等    default void addFormatters(FormatterRegistry registry) &#123;    &#125;    // 向InterceptorRegistry中添加自定义的拦截器，可用于在请求处理前后执行自定义逻辑，如权限校验、日志记录等    default void addInterceptors(InterceptorRegistry registry) &#123;    &#125;    // 向ResourceHandlerRegistry中添加自定义的资源处理器，用于处理静态资源（如CSS、JS文件）的映射路径等    default void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    &#125;    // 向CorsRegistry中添加跨域资源共享（CORS）的映射配置，解决跨域访问问题    default void addCorsMappings(CorsRegistry registry) &#123;    &#125;    // 向ViewControllerRegistry中添加视图控制器，用于直接映射请求到视图，而无需经过控制器方法处理    default void addViewControllers(ViewControllerRegistry registry) &#123;    &#125;    // 配置视图解析器，比如设置视图解析器的前缀、后缀，选择具体的视图解析器实现类等    default void configureViewResolvers(ViewResolverRegistry registry) &#123;    &#125;    // 向HandlerMethodArgumentResolver列表中添加自定义的处理器方法参数解析器，用于解析控制器方法的参数    default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;    &#125;    // 向HandlerMethodReturnValueHandler列表中添加自定义的处理器方法返回值处理器，用于处理控制器方法的返回值    default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;    &#125;    // 配置HTTP消息转换器，如设置默认的JSON转换器、XML转换器等，决定如何将请求数据转换为对象以及将对象转换为响应数据    default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    &#125;    // 扩展已有的HTTP消息转换器列表，可在已有的消息转换器基础上添加自定义的转换器    default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    &#125;    // 配置处理器异常解析器，用于处理控制器方法中抛出的异常，如自定义异常处理逻辑、异常视图映射等    default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    &#125;    // 扩展已有的处理器异常解析器列表，可在已有的异常解析器基础上添加自定义的异常解析器    default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    &#125;    // 向ErrorResponse.Interceptor列表中添加自定义的错误响应拦截器，用于在错误响应返回给客户端之前进行处理    default void addErrorResponseInterceptors(List&lt;ErrorResponse.Interceptor&gt; interceptors) &#123;    &#125;    // 获取自定义的验证器，如果返回非null，则使用该验证器进行数据验证    @Nullable    default Validator getValidator() &#123;        return null;    &#125;    // 获取自定义的消息码解析器，用于解析和处理国际化消息码等相关操作    @Nullable    default MessageCodesResolver getMessageCodesResolver() &#123;        return null;    &#125;&#125;\r\n\r\n其中addResourceHandlers就是专门处理静态资源规则的资源处理器，就是来做静态资源映射\r\n\r\naddResourceHandlers分析\r\n默认的静态资源规则源码\r\n/** * 配置静态资源处理器，用于处理Web应用中的静态资源请求（如CSS、JS、图片等） * @param registry 资源处理器注册器，用于注册静态资源处理规则 */public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    // 检查是否启用默认静态资源映射（通过spring.web.resources.add-mappings属性控制）    if (!this.resourceProperties.isAddMappings()) &#123;        logger.debug(&quot;Default resource handling disabled&quot;);    &#125; else &#123;        // 1. 配置WebJars资源映射        // WebJars是将前端依赖（如jQuery、Bootstrap）打包成JAR的标准，可通过Maven/Gradle引入        this.addResourceHandler(            registry,             this.mvcProperties.getWebjarsPathPattern(), // 请求路径模式，默认是&quot;/webjars/**&quot;            &quot;classpath:/META-INF/resources/webjars/&quot;// 资源存放位置，WebJars规范定义的默认路径        );                // 2. 配置普通静态资源映射        this.addResourceHandler(            registry,             this.mvcProperties.getStaticPathPattern(), // 请求路径模式，默认是&quot;/**&quot;            (registration) -&gt; &#123;                // 添加静态资源的物理位置（可通过spring.web.resources.static-locations配置）                // 默认位置包括：classpath:/static/、classpath:/public/等            registration.addResourceLocations(this.resourceProperties.getStaticLocations());                            // 如果存在ServletContext（即非测试环境），添加ServletContext根路径资源                if (this.servletContext != null) &#123;                    ServletContextResource resource = new ServletContextResource(this.servletContext, &quot;/&quot;);                    registration.addResourceLocations(new Resource[]&#123;resource&#125;);                &#125;            &#125;        );    &#125;&#125;\r\n规则一：可以看到其中的webjars，这是一种重要的配置规则，访问/webjars/**路径就去classpath:/META-INF/rescources/webjars/下找资源\r\n规则二：访问/**，就去\r\nclasspath:/static/等静态资源的默认的四个位置找\r\nprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;;\r\n规则三：静态资源默认都有缓存规则的设置\r\n\r\n如果说浏览器访问了一个静态资源，服务器这个资源没有发生变化，下次访问的时候可以直接让浏览器用自己缓存中的东西，就不用给浏览器发请求\r\n\r\n/** * 注册静态资源处理器，将指定URL模式映射到对应资源位置，并应用缓存配置 *  * @param registry   资源处理器注册器 * @param pattern    请求路径模式（如&quot;/webjars/**&quot;或&quot;/**&quot;） * @param customizer 自定义资源位置的回调函数 */private void addResourceHandler(ResourceHandlerRegistry registry, String pattern, Consumer&lt;ResourceHandlerRegistration&gt; customizer) &#123;    // 检查是否已有相同模式的映射，避免重复注册    if (!registry.hasMappingForPattern(pattern)) &#123;        // 创建资源处理器注册，将URL模式映射到资源位置        ResourceHandlerRegistration registration = registry.addResourceHandler(new String[]&#123;pattern&#125;);                // 应用自定义资源位置（如classpath:/static/或ServletContext根路径）        customizer.accept(registration);                // 配置缓存策略：        // 1. 设置缓存周期（秒），对应配置项spring.web.resources.cache.period        registration.setCachePeriod(this.getSeconds(this.resourceProperties.getCache().getPeriod()));                // 2. 设置HTTP缓存控制头（如Cache-Control: max-age=3600）        registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());                // 3. 启用Last-Modified时间戳支持（基于文件修改时间验证缓存）        registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());                // 应用自定义配置（如Gzip压缩、资源链处理器等）        this.customizeResourceHandlerRegistration(registration);    &#125;&#125;\r\n\r\n所有缓存的设置，直接通过配置文件：spring.web\r\ncachePeriod：缓存周期；多久不用找服务器要新的。默认没有，以\r\ns 为单位\r\ncacheControl：HTTP\r\n缓存控制；https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\r\nuseLastModified：是否使用最后一次修改。\r\n也适用自定义：\r\n\r\n配置文件覆盖默认值\r\n\r\n# 禁用缓存（开发环境常用）spring.web.resources.cache.period=0# 启用缓存并设置1小时有效期（生产环境）spring.web.resources.cache.period=3600# 自定义静态资源路径和缓存控制spring.web.resources.static-locations=classpath:/custom-static/spring.web.resources.cache.cachecontrol.max-age=86400\r\n\r\nJava 代码自定义 通过实现\r\nWebMvcConfigurer 手动配置：\r\n\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/custom/**&quot;)                .addResourceLocations(&quot;classpath:/custom-resources/&quot;)                .setCachePeriod(3600)  // 覆盖配置文件设置                .setUseLastModified(true);    &#125;&#125;\r\n\r\nHTTP 缓存机制详解\r\n缓存配置的参数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置项\r\n对应属性\r\n默认值\r\n作用\r\n\r\n\r\n\r\n\r\nspring.web.resources.cache.period\r\nresourceProperties.getCache().getPeriod()\r\nnull\r\n缓存过期时间（秒），设置后响应头添加\r\nCache-Control: max-age=xxx\r\n\r\n\r\nspring.web.resources.cache.cachecontrol.*\r\nresourceProperties.getCache().getCachecontrol()\r\n见下方\r\n细粒度控制 HTTP 缓存头（如\r\nno-cache、must-revalidate）\r\n\r\n\r\nspring.web.resources.cache.use-last-modified\r\nresourceProperties.getCache().isUseLastModified()\r\ntrue\r\n是否使用文件修改时间（Last-Modified 头）验证缓存\r\n\r\n\r\n\r\n继续上述在addResourceHandler部分关于缓存的内容中，此方法通过以下方式控制缓存：\r\n强缓存（Cache-Control）\r\n\r\n当设置 cachePeriod 时，响应头添加\r\nCache-Control: max-age=xxx，浏览器直接使用本地缓存，无需请求服务器。\r\nspring.web.resources.cache.period=3600  # 缓存1小时\r\n协商缓存（Last-Modified）\r\n\r\n默认启用 useLastModified，响应头添加\r\nLast-Modified 时间戳。\r\n下次请求时，浏览器发送 If-Modified-Since\r\n头，服务器比较时间戳决定是否返回新资源。\r\n\r\n细粒度控制 通过\r\nspring.web.resources.cache.cachecontrol.* 配置：\r\nspring.web.resources.cache.cachecontrol.max-age=3600  # 等同 cache.periodspring.web.resources.cache.cachecontrol.no-cache=true  # 禁用强缓存spring.web.resources.cache.cachecontrol.must-revalidate=true  # 缓存过期前必须验证\r\n\r\nEnableWebMvcConfiguration\r\n源码\r\n   // Spring Boot给容器放了WebMvcConfigurationSupport组件// 如果我们自己放了WebMvcConfigurationSupport 组件，Spring boot 的 WebMvcAutoConfiguration 都会失效   @Configuration(       proxyBeanMethods = false   ) // 将 WebProperties 类与配置文件（如 application.properties）绑定，允许通过配置文件自定义 Web 相关属性。   @EnableConfigurationProperties(&#123;WebProperties.class&#125;)   public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;&#125;\r\n\r\nDelegatingWebMvcConfiguration 是 Spring MVC\r\n的核心配置类，它实现了 WebMvcConfigurationSupport\r\n并聚合了所有 WebMvcConfigurer 实例的配置。\r\n\r\n允许开发者通过实现 WebMvcConfigurer\r\n接口自定义配置，而无需完全接管 MVC 配置（即不使用\r\n@EnableWebMvc）。\r\n\r\n通过实现 ResourceLoaderAware 接口，该类可获取\r\nResourceLoader\r\n实例，用于加载类路径或文件系统中的资源。在配置静态资源处理器时，可通过\r\nResourceLoader 定位资源位置（如\r\nclasspath:/static/）。\r\n\r\n使用 webjars\r\n首先 Spring Boot 的有个叫 webjars 的东西，所有通过 pom.xml\r\n引入的静态资源，都在/webjars/**下（这个在静态资源的自动配置类中可以找到），也就是说\r\nSpring Boot 会自动去 classpath:/META-INF/resources/webjars/\r\n找资源，webjars 以 jar\r\n包的方式引入静态资源（也就是说，我们都可以通过http://localhost:8080/webjars/xx访问对应的静态资源）\r\n各种静态资源 jar 都可以通过 pom.xml 依赖的方式引入 ，我们引入 JQuery\r\n看看，引入的 JQuery 的依赖包下边，可以看到 webjars 内容长这样\r\n现在我们引入了 jQuery\r\n的静态资源，我们启动项目，来试一下能不能通过对应的路径访问\r\n所以通过 SpringBoot\r\n来开发相关的静态资源，非常方便，我们只要引入对应的 webjars\r\n就可以了，Spring Boot\r\n不需要我们进行过多的配置，有自己默认配置的规则。\r\n就是用 pom.xml 中导入依赖，然后可以用\r\nclasspath:/META-INF/resources/webjars/找资源\r\n使用resources\r\n当然如果我们想要用自己的静态资源，不想使用webjars的东西，这个时候就需要另外一个映射规则就是/**（也就是说，我们通过http://localhost:8080/xxx.js访问静态资源，这时候就是使用\r\nresources 规则了。\r\n默认静态资源路径\r\n静态资源映射规则此事在WebMvcAutoConfigurationAdapter亦有记载\r\n除了使用 webjars，Spring Boot\r\n默认提供了更直接的静态资源管理方式——直接将静态文件放在项目的\r\nresources 目录下。以下是详细的配置规则和使用案例：\r\nSpring Boot 默认会在以下位置查找静态资源（优先级从高到低）：\r\n\r\nclasspath:/META-INF/resources/\r\nclasspath:/resources/\r\nclasspath:/static/\r\nclasspath:/public/\r\nServletContext 根目录（如\r\nsrc/main/webapp/）\r\n\r\n当浏览器发起 /xxx 请求时，Spring Boot\r\n会依次在这些目录中查找名为 xxx 的文件。\r\nsrc/main/resources/    ├─ META-INF/resources/   # 优先级最高    ├─ resources/            # 优先级次之    ├─ static/               # 最常用的静态资源目录    │    ├─ css/    │    ├─ js/    │    └─ images/    └─ public/               # 优先级最低\r\n访问静态资源\r\n假设在 static/images 目录下放置\r\nlogo.png，访问方式为：\r\nhttp://localhost:8080/images/logo.png\r\n无需在 URL 中添加 static，直接通过资源路径访问。\r\n例如：在 src/main/resources/static 下创建\r\nindex.html：\r\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Welcome to Spring Boot!&lt;/h1&gt;    &lt;img src=&quot;/images/spring-logo.png&quot; alt=&quot;Spring Logo&quot;&gt;&lt;/body&gt;&lt;/html&gt;\r\n将图片 spring-logo.png 放入 static/images/\r\n目录。\r\n启动应用后：\r\n\r\n访问首页：http://localhost:8080/index.html\r\n访问图片：http://localhost:8080/images/spring-logo.png\r\n\r\n注意存在的问题：\r\n缓存问题\r\n修改静态资源后，浏览器可能缓存旧文件。可通过以下方式解决：\r\n\r\n强制刷新（Ctrl + F5）\r\n在资源URL中添加版本号：/css/style.css?v=1.0\r\n\r\n自定义静态资源路径\r\n默认静态资源位置：\r\nclasspath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public/\r\n自定义单个位置：\r\n# application.ymlspring:  web:    resources:      static-locations: classpath:/custom/\r\n如果默认路径不满足需求，可在\r\napplication.properties 中自定义多个位置：\r\n# 修改静态资源访问前缀spring.mvc.static-path-pattern=/assets/**# 添加新的静态资源目录（覆盖默认配置）spring.web.resources.static-locations=classpath:/custom-static/,classpath:/static/\r\n\r\n创建 resources/custom-static/hello.html\r\n配置后访问：http://localhost:8080/assets/hello.html\r\n\r\n通过 Java 配置自定义：\r\n\r\n实现 WebMvcConfigurer\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;        @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        // 添加自定义静态资源映射        registry.addResourceHandler(&quot;/assets/**&quot;)                .addResourceLocations(&quot;classpath:/custom-assets/&quot;)                .setCachePeriod(3600); // 设置缓存时间                // 保持默认的静态资源映射        registry.addResourceHandler(&quot;/**&quot;)                .addResourceLocations(&quot;classpath:/static/&quot;,                                     &quot;classpath:/public/&quot;,                                    &quot;classpath:/custom/&quot;);    &#125;        @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        // 自定义欢迎页控制器        registry.addViewController(&quot;/&quot;).setViewName(&quot;forward:/index.html&quot;);        registry.setOrder(Ordered.HIGHEST_PRECEDENCE);    &#125;&#125;\r\n自定义 ResourceHttpRequestHandler\r\nResourceHttpRequestHandler 是 Spring MVC\r\n中的一个类，它是 HttpRequestHandler\r\n的实现类，主要作用是处理静态资源请求，根据配置的资源位置查找请求对应的静态资源文件\r\n@Configuration public class CustomResourceConfig &#123;    @Bean     public SimpleUrlHandlerMapping customResourceHandlerMapping() &#123;        // 创建一个SimpleUrlHandlerMapping实例，用于处理URL映射        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();         // 创建一个HashMap来存储URL和对应的处理器        Map&lt;String, ResourceHttpRequestHandler&gt; urlMap = new HashMap&lt;&gt;();         // 创建一个ResourceHttpRequestHandler实例，用于处理资源请求        ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();         // 设置处理器查找资源的位置，这里指定了两个路径        handler.setLocationValues(Arrays.asList(            &quot;classpath:/custom/&quot;,            &quot;classpath:/static/&quot;        ));         // 将&quot;/**&quot;路径映射到创建的处理器        urlMap.put(&quot;/**&quot;, handler);         // 设置URL映射关系        mapping.setUrlMap(urlMap);         // 设置该映射的顺序，值越大优先级越低，这里设置为Integer.MAX_VALUE - 1        mapping.setOrder(Integer.MAX_VALUE - 1);         return mapping;    &#125;&#125;\r\n\r\n注意路径匹配规则问题：\r\n\r\n避免Controller的请求路径与静态资源名称冲突。例如，若存在\r\n/user 接口，则无法通过 /user.html\r\n访问静态页面。\r\n\r\n配置欢迎页映射\r\n静态资源文件夹下的所有index.html页面，会被/映射；\r\n也就是说我们直接访问http://localhost:8080/就直接访问静态资源文件夹中的index.html，相当于我们以前Spring\r\nMVC 下面的index.jsp，比如我们现在随机选 public\r\n的静态资源文件夹下创建index.html\r\n源码：\r\nBean 配置入口\r\n@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;    return (WelcomePageHandlerMapping)this.createWelcomePageHandlerMapping(applicationContext, mvcConversionService, mvcResourceUrlProvider, WelcomePageHandlerMapping::new);&#125;\r\n这个 Bean 配置方法创建了 WelcomePageHandlerMapping\r\n实例，该实例负责处理欢迎页的路径映射。Spring Boot\r\n通过自动配置机制在容器启动时创建此映射器。\r\n进入到其中的 WelcomePageHandlerMapping类\r\nWelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Resource indexHtmlResource, String staticPathPattern) &#123;        this.setOrder(2);        WelcomePage welcomePage = WelcomePage.resolve(templateAvailabilityProviders, applicationContext, indexHtmlResource, staticPathPattern);        if (welcomePage != WelcomePage.UNRESOLVED) &#123;            logger.info(LogMessage.of(() -&gt; &#123;                return !welcomePage.isTemplated() ? &quot;Adding welcome page: &quot; + String.valueOf(indexHtmlResource) : &quot;Adding welcome page template: index&quot;;            &#125;));            ParameterizableViewController controller = new ParameterizableViewController();            controller.setViewName(welcomePage.getViewName());            this.setRootHandler(controller);        &#125;    &#125;\r\n欢迎页解析部分\r\nstatic WelcomePage resolve(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Resource indexHtmlResource, String staticPathPattern) &#123;        if (indexHtmlResource != null &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123;            return new WelcomePage(&quot;forward:index.html&quot;, false);        &#125; else &#123;            return templateAvailabilityProviders.getProvider(&quot;index&quot;, applicationContext) != null ? new WelcomePage(&quot;index&quot;, true) : UNRESOLVED;        &#125;    &#125;\r\n源码分析：\r\n\r\nHandlerMapping：根据请求路径/a找那个\r\nhandler 能处理请求\r\n\r\n是 Spring MVC 中负责根据请求路径找到对应处理器（Handler）的组件\r\nWelcomePageHandlerMapping:\r\n\r\n访问 /**\r\n路径下的所有请求，都在以前四个静态资源路径下找，欢迎页也一样\r\n找 index.html：只要静态资源的位置有一个\r\nindex.html 页面，项目启动默认访问\r\n\r\n\r\n欢迎页解析:\r\n\r\nWelcomePage.resolve()\r\n方法会按照以下优先级查找欢迎页：\r\n\r\n首先检查是否存在 index 模板文件（如 index.html,\r\nindex.ftl, index.jsp 等）\r\n如果没有模板，则查找静态资源目录下的 index.html\r\n文件\r\n\r\n当存在模板引擎和对应的 index\r\n模板时，会优先使用模板渲染。\r\nsrc/main/resources/templates/index.html (Thymeleaf)src/main/resources/templates/index.ftl (FreeMarker)\r\n\r\n\r\n\r\n控制器创建: 如果找到欢迎页，创建\r\nParameterizableViewController 来处理根路径请求\r\n\r\n配置自定义\r\n当然，如果我们不想要使用SpringBoot默认的静态资源文件夹，我们还可以定义静态资源的映射\r\n默认情况下，静态资源路径模式为 /**\r\n如需自定义欢迎页行为，可以通过以下方式：\r\n# application.ymlspring:  mvc:    static-path-pattern: /static/** # 修改静态资源路径模式  web:    resources:      static-locations: classpath:/custom/ # 自定义静态资源位置\r\n\r\n当 static-path-pattern 不是 /**\r\n时，欢迎页功能会被禁用，这是因为 WelcomePage.resolve()\r\n方法中有明确的检查，如果必须修改静态资源路径模式，可以通过自定义控制器来实现欢迎页\r\n自定义控制器的 @RequestMapping(\"/\")\r\n会覆盖默认的欢迎页映射\r\n完全禁用欢迎页：\r\n# application.ymlspring:  web:    resources:      add-mappings: false  # 禁用所有静态资源映射\r\n使用 profile 特定的欢迎页\r\n@Controller@Profile(&quot;production&quot;)public class ProductionWelcomeController &#123;        @RequestMapping(&quot;/&quot;)    public String productionWelcome() &#123;        return &quot;production-index&quot;;    &#125;&#125;@Controller@Profile(&quot;development&quot;)public class DevelopmentWelcomeController &#123;        @RequestMapping(&quot;/&quot;)    public String developmentWelcome() &#123;        return &quot;dev-index&quot;;    &#125;&#125;\r\n要注意了，如果自己定义了静态资源映射之后，默认的文件夹就都不生效了，相当于原来的那些访问方式都不生效了。\r\n\r\nFavicon 规则\r\n这个和欢迎页规则差不多，默认情况下在静态资源目录下找favicon.ico\r\n当然，如果我们不想要使用SpringBoot默认的静态资源文件夹，我们还可以定义静态资源的映射\r\n但是这是一个隐形规则，是根据浏览器实现的，不是 Spring\r\nBoot让他变的\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","源码分析"]},{"title":"Spring Boot part8-自定义WebmvcConfigurer实现管理配置及其机制的剖析","url":"/posts/20127.html","content":"自定义WebmvcConfigurer能实现管理什么\r\n在 Spring\r\n框架中，WebMvcConfigurer接口是一个非常重要的配置接口，它允许开发者通过自定义配置来扩展和定制\r\nSpring MVC\r\n的默认行为。通过实现WebMvcConfigurer接口（或继承WebMvcConfigurationSupport类），可以对\r\nSpring MVC 的多个核心功能进行灵活配置。\r\n以下是自定义WebMvcConfigurer能实现的主要功能及详细说明：\r\n请求映射与处理器配置\r\n\r\n自定义处理器映射（HandlerMapping）和适配器（HandlerAdapter）\r\n\r\n可以注册自定义的HandlerMapping（如基于注解的RequestMappingHandlerMapping）或HandlerAdapter（如RequestMappingHandlerAdapter），用于处理不同类型的请求映射逻辑。\r\n场景：自定义 URL 匹配规则、处理特殊请求格式（如\r\nRESTful API 版本控制）。\r\n\r\n静态资源处理\r\n\r\n配置静态资源（如\r\nHTML、CSS、JS、图片等）的访问路径和缓存策略：\r\n@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    registry.addResourceHandler(&quot;/static/**&quot;)            .addResourceLocations(&quot;classpath:/static/&quot;)            .setCachePeriod(3600); // 缓存1小时&#125;\r\n场景：将静态资源映射到类路径、文件系统路径或 CDN 地址。\r\n\r\n\r\n视图与数据格式化\r\n\r\n视图解析器配置\r\n\r\n注册自定义视图解析器（如 Thymeleaf、FreeMarker、JSP\r\n等），或修改默认视图解析规则：\r\n@Overridepublic void configureViewResolvers(ViewResolverRegistry registry) &#123;    registry.jsp(&quot;/WEB-INF/views/&quot;, &quot;.jsp&quot;); // JSP视图解析器&#125;\r\n场景：使用模板引擎时配置视图前缀、后缀或自定义视图解析逻辑。\r\n\r\n数据格式化与转换\r\n\r\n注册自定义的Converter（类型转换器）和Formatter（格式化器），处理请求参数和响应结果的类型转换：\r\n@Overridepublic void addFormatters(FormatterRegistry registry) &#123;    registry.addConverter(String.class, LocalDate.class, new StringToLocalDateConverter());&#125;\r\n场景：将字符串参数自动转换为LocalDate、Enum等类型，或格式化日期、数字等响应数据。\r\n\r\n\r\n拦截器与请求处理\r\n\r\n拦截器注册\r\n\r\n配置拦截器（HandlerInterceptor），用于预处理请求或后处理响应：\r\n@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(new LoginInterceptor())            .addPathPatterns(&quot;/api/**&quot;) // 拦截路径            .excludePathPatterns(&quot;/api/public/**&quot;); // 排除路径&#125;\r\n场景：实现登录认证、请求日志记录、性能监控等功能。\r\n\r\n跨域请求处理（CORS）\r\n\r\n配置跨域资源共享（CORS）规则，允许前端跨域访问后端 API：\r\n\r\n@Overridepublic void addCorsMappings(CorsRegistry registry) &#123;    registry.addMapping(&quot;/api/**&quot;)            .allowedOrigins(&quot;https://example.com&quot;)            .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)            .allowedHeaders(&quot;*&quot;)            .maxAge(3600);&#125;\r\n\r\n场景：前后端分离项目中解决跨域访问限制。\r\n\r\n\r\n请求处理与参数配置\r\n\r\n请求参数处理\r\n\r\n配置RequestBody和RequestParam的解析规则，如设置\r\nJSON 解析器（Jackson）、表单解析器等：\r\n@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    // 添加自定义JSON转换器    converters.add(new MappingJackson2HttpMessageConverter(objectMapper));&#125;\r\n场景：自定义请求体解析（如处理特殊格式的\r\nJSON、XML）或响应数据序列化规则\r\n\r\n异步请求处理\r\n\r\n配置异步请求处理（如DeferredResult、WebSocket）的相关参数：\r\n@Overridepublic void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;    configurer.setDefaultTimeout(30000); // 异步请求超时时间    configurer.registerCallableInterceptors(new TimeoutCallableInterceptor());&#125;\r\n场景：实现长轮询、WebSocket 通信等异步业务场景。\r\n\r\n\r\nRESTful API 特性增强\r\n\r\n内容协商（Content Negotiation）\r\n\r\n配置不同请求 Accept 头对应的响应格式（如 JSON、XML、HTML）\r\n@Overridepublic void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;    configurer.favorPathExtension(true) // 基于URL后缀（.json/.xml）            .favorParameter(true) // 基于参数（?format=json）            .parameterName(&quot;format&quot;)            .defaultContentType(MediaType.APPLICATION_JSON);&#125;\r\n场景：根据客户端请求头返回不同格式的数据，提升 API\r\n兼容性。\r\n\r\nHTTP 消息转换器\r\n\r\n自定义HttpMessageConverter，处理请求和响应的消息转换（如添加\r\nProtobuf、CSV 支持）：\r\n@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    converters.add(new ProtobufHttpMessageConverter());&#125;\r\n\r\n\r\n其他功能扩展\r\n\r\n异常处理配置\r\n\r\n注册全局异常处理器（@ControllerAdvice+@ExceptionHandler），或通过WebMvcConfigurer间接配置：\r\n场景：统一处理 API 异常，返回标准化错误响应。\r\n\r\n默认 Servlet 处理\r\n\r\n配置 Spring MVC 对默认 Servlet（如 Tomcat 的默认\r\nServlet）的处理策略：\r\n场景：处理静态资源请求时，若 Spring MVC\r\n未匹配到对应处理器，交由容器默认 Servlet 处理。\r\n\r\n\r\n自定义 WebMvcConfigurer\r\n配置类的三种自定义方式\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n全自动\r\n直接编写控制器逻辑\r\n\r\n全部使用自动配置默认效果\r\n\r\n\r\n\r\n\r\n手自一体\r\n@Configuration + 配置 WebMvcConfigurer +\r\n配置 WebMvcRegistrations\r\n不要标注@EnableWebMvc\r\n自动配置效果 手动设置部分功能 定义 MVC 底层组件\r\n\r\n\r\n全手动\r\n@Configuration + 配置\r\nWebMvcConfigurer\r\n标注@EnableWebMvc\r\n禁用自动配置效果 全手动设置\r\n\r\n\r\n\r\n总结：所有的自定义模式，给容器类放一个配置类\r\n@Configuration 实现\r\nWebMvcConfigurer，不要标注@EnableWebMvc注解，实现了手自一体的模式。\r\n一些问题\r\n\r\n@EnableWebMvc的影响\r\n\r\n若配置类添加@EnableWebMvc，会完全覆盖 Spring MVC\r\n的自动配置（如默认视图解析器、消息转换器等），需手动配置所有需要的功能。\r\n若仅需扩展部分功能，建议不添加@EnableWebMvc，保持\r\nSpring Boot 的自动配置。\r\n\r\n优先级与顺序\r\n\r\n多个WebMvcConfigurer实现类的配置会合并生效，可通过@Order注解控制优先级。\r\n\r\n与WebMvcConfigurationSupport的区别\r\n\r\nWebMvcConfigurationSupport是一个基类，提供更底层的配置能力，但会完全禁用\r\nSpring Boot 的自动配置；\r\nWebMvcConfigurer接口则更轻量级，用于扩展而非覆盖默认配置，推荐优先使用。\r\n\r\n\r\n自定义配置类实现\r\nWebMvcConfigurer 接口\r\n容器中只要有 一个 WebMvcConfigurer\r\n组件，就能自定义底层，配置的底层行为都会生效\r\n路径和缓存配置，手自一体模式\r\n@Configuration  // 告诉 Spring 这是一个配置类，给容器中放一个 WebMvcConfigurer 组件，就能自定义底层public class MyConfigWebmvcConfigurer implements WebMvcConfigurer 组件，就能自定义底层 &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        // 保留以前的        WebMvcConfigurer.super.addResourceHandlers(registry);        // 自己加规则        registry.addResourceHandler(&quot;/static/**&quot;)   // 访问static下的路径                .addResourceLocations(&quot;classpath:/ergou/&quot;, &quot;classpath:/templates/&quot;)   // 就会跳转到这两个文件夹下访问                .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS));   // 配置缓存存活时间        &#125;&#125;\r\n或者，第二种模式\r\n@Configuration  // 告诉 Spring 这是一个配置类public class MyConfigWebmvcConfigurer implements WebMvcConfigurer &#123;    @Bean    public WebMvcConfigurer myWebMvcConfigurer() &#123;        return new WebMvcConfigurer() &#123;            @Override            public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;                // 保留以前的                WebMvcConfigurer.super.addResourceHandlers(registry);                // 自己加规则                registry.addResourceHandler(&quot;/static/**&quot;)   // 访问static下的路径                        .addResourceLocations(&quot;classpath:/ergou/&quot;, &quot;classpath:/templates/&quot;)   // 就会跳转到这两个文件夹下访问                        .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS));   // 配置缓存存活时间            &#125;        &#125;;    &#125;&#125;\r\n\r\n\r\nimage-20250529105651424\r\n\r\n一个比较完整的自定义配置类实现 WebMvcConfigurer 接口\r\npackage edu.software.ergoutree.springbootwebpart1.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.CacheControl;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.*;import org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver;import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.Locale;import java.util.concurrent.TimeUnit;@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    // 静态资源处理配置    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        // 保留Spring默认静态资源处理（如classpath:/static/等）        WebMvcConfigurer.super.addResourceHandlers(registry);                // 自定义静态资源规则        registry.addResourceHandler(&quot;/static/**&quot;)                .addResourceLocations(&quot;classpath:/ergou/&quot;, &quot;classpath:/templates/&quot;)                .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS))                .resourceChain(true)                .addResolver(new org.springframework.web.servlet.resource.PathResourceResolver());                        // 配置其他静态资源（如上传文件）        registry.addResourceHandler(&quot;/uploads/**&quot;)                .addResourceLocations(&quot;file:/data/uploads/&quot;);    &#125;        // 拦截器配置    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录认证拦截器        registry.addInterceptor(loginInterceptor())                .addPathPatterns(&quot;/api/private/**&quot;)                .excludePathPatterns(&quot;/api/private/login&quot;);                        // 国际化拦截器        registry.addInterceptor(localeChangeInterceptor());    &#125;        // 跨域资源共享配置    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOrigins(&quot;https://example.com&quot;, &quot;http://localhost:8080&quot;)                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)                .allowedHeaders(&quot;*&quot;)                .allowCredentials(true)                .maxAge(3600);    &#125;        // 消息转换器配置（处理JSON、XML等格式）    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        // 自定义JSON转换器（设置字符集、日期格式等）        MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter();        jsonConverter.setDefaultCharset(StandardCharsets.UTF_8);        // 可配置ObjectMapper（如日期格式化）        converters.add(jsonConverter);                // 其他转换器...    &#125;        // 视图解析器配置    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        // 配置JSP视图解析器        registry.jsp(&quot;/WEB-INF/views/&quot;, &quot;.jsp&quot;);                // 或配置模板引擎（如Thymeleaf）        // registry.enableThymeleaf();    &#125;        // 数据格式化配置    @Override    public void addFormatters(FormatterRegistry registry) &#123;        // 注册自定义类型转换器        // registry.addConverter(new StringToLocalDateConverter());                // 注册自定义格式化器        // registry.addFormatter(new DateFormatter(&quot;yyyy-MM-dd&quot;));    &#125;        // 异步请求配置    @Override    public void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;        configurer.setDefaultTimeout(30000); // 30秒超时        // configurer.registerCallableInterceptors(new TimeoutCallableInterceptor());    &#125;        // 内容协商配置（处理不同客户端的格式请求）    @Override    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;        configurer.favorPathExtension(true)                .favorParameter(true)                .parameterName(&quot;format&quot;)                .defaultContentType(org.springframework.http.MediaType.APPLICATION_JSON)                .mediaType(&quot;json&quot;, org.springframework.http.MediaType.APPLICATION_JSON)                .mediaType(&quot;xml&quot;, org.springframework.http.MediaType.APPLICATION_XML);    &#125;        // 国际化配置 - 区域解析器    @Bean    public LocaleResolver localeResolver() &#123;        AcceptHeaderLocaleResolver resolver = new AcceptHeaderLocaleResolver();        resolver.setDefaultLocale(Locale.CHINA);        return resolver;    &#125;        // 国际化配置 - 语言参数拦截器    @Bean    public LocaleChangeInterceptor localeChangeInterceptor() &#123;        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();        interceptor.setParamName(&quot;lang&quot;); // 通过?lang=en切换语言        return interceptor;    &#125;        // 自定义拦截器 Bean    @Bean    public LoginInterceptor loginInterceptor() &#123;        return new LoginInterceptor();    &#125;        // 示例：自定义拦截器类    private static class LoginInterceptor implements HandlerInterceptor &#123;        @Override        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;            // 登录认证逻辑            String token = request.getHeader(&quot;Authorization&quot;);            if (token == null || !validateToken(token)) &#123;                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);                return false;            &#125;            return true;        &#125;                private boolean validateToken(String token) &#123;            // 实际项目中应调用认证服务            return true;        &#125;    &#125;&#125;\r\n为什么我们容器中放一个\r\nWebMvcConfigurer 就能配置底层行为\r\nSpring\r\nMVC的配置机制是一个典型的”组合模式”应用，通过WebMvcConfigurer接口提供了一种灵活的方式来定制MVC行为。\r\n其中的核心组件关系如下\r\n[WebMvcAutoConfiguration]       |       |--- [WebMvcAutoConfigurationAdapter] (实现WebMvcConfigurer)       |       |--- [EnableWebMvcConfiguration] (继承DelegatingWebMvcConfiguration)               |               |--- [DelegatingWebMvcConfiguration] (继承WebMvcConfigurationSupport)                       |                       |--- [WebMvcConfigurerComposite] (聚合所有WebMvcConfigurer)\r\n自动配置入口 是 WebMvcAutoConfiguration，Spring Boot\r\n的自动配置类WebMvcAutoConfiguration是整个过程的总入口\r\n在 public class WebMvcAutoConfiguration\r\n自动配置类中，有这么两个类WebMvcAutoConfigurationAdapter和EnableWebMvcConfiguration\r\nWebMvcAutoConfigurationAdapter\r\n有一个 WebMvcAutoConfigurationAdapter类，这个类是Spring\r\nBoot 早期版本中用于自动配置 Spring MVC\r\n的一个适配器类，主要功能是在不覆盖自动配置的前提下，允许开发者通过继承该类来扩展或自定义\r\nSpring MVC\r\n的配置。所以说，自动配置入口中会有这个类来支持用户自定义自动配置的内容。\r\n这个类中的配置最先执行（Order=0），其他自定义WebMvcConfigurer按@Order注解顺序执行\r\n@Configuration(       proxyBeanMethods = false   )   @Import(&#123;EnableWebMvcConfiguration.class&#125;)   @EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)   @Order(0)   public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware &#123;          &#125;\r\n其中：\r\n\r\n@Import(EnableWebMvcConfiguration.class)引入了核心配置\r\nWebMvcAutoConfigurationAdapter本身也是一个WebMvcConfigurer实现\r\n\r\nEnableWebMvcConfiguration\r\nEnableWebMvcConfiguration这个类，继承了DelegatingWebMvcConfiguration类，这两个类都生效\r\n这个类主要功能就是在 @EnableWebMvc\r\n注解被启用时发挥作用，而WebMvcAutoConfiguration 是 Spring\r\nBoot 自动配置 MVC 的主类，在未启用 @EnableWebMvc 时生效\r\n所以说，这个类是WebMvcAutoConfiguration支持全手动配置的一个重要入口类\r\n@Configuration(    proxyBeanMethods = false)@EnableConfigurationProperties(&#123;WebProperties.class&#125;)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;\r\n而且还继承了DelegatingWebMvcConfiguration类，这个类是配置委托链\r\nDelegatingWebMvcConfiguration\r\nEnableWebMvcConfiguration继承了DelegatingWebMvcConfiguration，这是整个机制的核心，作为\r\n@EnableWebMvc 注解的实际载体，负责收集并应用所有实现了\r\nWebMvcConfigurer 接口的配置类。\r\n而且DelegatingWebMvcConfiguration 还继承自\r\nWebMvcConfigurationSupport（Spring MVC\r\n的基础配置类），并在其基础上实现了配置的委派机制。\r\n源码中有一段这个利用IoC和DI\r\n，把容器中所有的WebMvcConfigurer的 Bean\r\n注入进来，实现将开发者自定义的配置与 Spring MVC 的默认配置进行整合。\r\n在 WebMvcConfigurationSupport\r\n的基础上，DelegatingWebMvcConfiguration\r\n将关键配置方法的实现委托给收集到的 WebMvcConfigurer\r\n之后，WebMvcConfigurerComposite\r\n类负责按顺序执行所有配置器的方法：\r\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;    // 持有一个 WebMvcConfigurer 组合器，用于按顺序执行所有配置器的方法    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();    /**     * 自动注入所有实现了 WebMvcConfigurer 接口的 Bean。     * required = false 表示允许容器中没有 WebMvcConfigurer Bean。     */    @Autowired(required = false)    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;        if (!CollectionUtils.isEmpty(configurers)) &#123;            // 将所有 WebMvcConfigurer 注册到组合器中            this.configurers.addWebMvcConfigurers(configurers);        &#125;    &#125;                   /**     * 覆盖父类的路径匹配配置方法，委派给所有注册的 WebMvcConfigurer 处理。     * 这样，每个 WebMvcConfigurer 实现都可以参与路径匹配的定制。     */    @Override    protected void configurePathMatch(PathMatchConfigurer configurer) &#123;        // 调用所有 WebMvcConfigurer 的 configurePathMatch 方法        this.configurers.configurePathMatch(configurer);                // 注意：父类 WebMvcConfigurationSupport 的默认实现会在这里被忽略，        // 完全由 WebMvcConfigurer 的实现控制配置。    &#125;        /**     * 覆盖父类的静态资源处理器配置方法。     * 允许 WebMvcConfigurer 实现添加或修改静态资源映射规则。     */    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        this.configurers.addResourceHandlers(registry);    &#125;        // 其他配置方法...也都是覆盖为主&#125;\r\n\r\n自动装配所有WebMvcConfigurer：通过@Autowired注入容器中所有WebMvcConfigurer实现\r\n委托模式：将配置工作委托给WebMvcConfigurerComposite\r\n方法覆盖：重写父类WebMvcConfigurationSupport的所有配置方法\r\n\r\n别人调用\r\nDelegatingWebMvcConfiguration类的方法配置底层规则，而它调用所有的WebMvcConfigurer的配置底层方法，这个类将工作委托给组合对象\r\n当应用中添加 @EnableWebMvc 注解时，Spring 会导入\r\nDelegatingWebMvcConfiguration，然后 Spring 扫描容器中的所有\r\nBean，找出实现了 WebMvcConfigurer\r\n接口的类，将这些配置器注入到 DelegatingWebMvcConfiguration\r\n的 configurers 字段中。\r\nWebMvcConfigurerComposite\r\n还有一个配置聚合器，WebMvcConfigurerComposite是实际处理多个配置器的核心类，通过WebMvcConfigurerComposite统一处理多个配置器\r\nclass WebMvcConfigurerComposite implements WebMvcConfigurer &#123;    private final List&lt;WebMvcConfigurer&gt; delegates = new ArrayList&lt;&gt;();        public void addWebMvcConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;        if (!CollectionUtils.isEmpty(configurers)) &#123;            this.delegates.addAll(configurers);        &#125;    &#125;        @Override    public void configurePathMatch(PathMatchConfigurer configurer) &#123;        for (WebMvcConfigurer delegate : this.delegates) &#123;            delegate.configurePathMatch(configurer);        &#125;    &#125;        // 实现其他接口方法...&#125;\r\n\r\n收集所有WebMvcConfigurer实例\r\n遍历调用每个配置器的对应方法\r\n保证所有自定义配置都能生效\r\n\r\n流程分析\r\n所以说，当Spring MVC初始化时，完整的调用链如下：\r\n\r\nDispatcherServlet初始化触发MVC配置\r\nWebMvcConfigurationSupport中的配置方法被调用\r\nDelegatingWebMvcConfiguration重写的方法被执行\r\nWebMvcConfigurerComposite遍历所有WebMvcConfigurer\r\n最终执行到开发者自定义的配置逻辑\r\n\r\n配置生效过程也就是\r\n\r\nSpring容器初始化时发现MyWebMvcConfig\r\nDelegatingWebMvcConfiguration通过@Autowired收集到该配置器\r\nMVC初始化时调用configurePathMatch方法\r\nWebMvcConfigurerComposite遍历调用所有配置器的该方法\r\n最终PathMatchConfigurer被配置为不使用尾部斜杠匹配\r\n\r\nWebMvcConfigurer的源码回顾\r\n这里是 WebMvcConfigurer 这个接口的源码，提供了配置\r\nSpring MVC 底层的所有组件入口\r\n// WebMvcConfigurer接口用于对Spring MVC进行自定义配置public interface WebMvcConfigurer &#123;    // 配置路径匹配相关策略，比如设置路径匹配的后缀策略、路径分隔符等    default void configurePathMatch(PathMatchConfigurer configurer) &#123;    &#125;    // 配置内容协商策略，例如根据请求头中的Accept字段决定返回的数据格式（如JSON、XML等）    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;    &#125;    // 异步支持，配置异步支持相关参数，如异步请求的超时时间、任务执行器等    default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123;    &#125;    // 配置默认Servlet处理策略，比如当Spring MVC无法处理请求时，是否转发给默认Servlet    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;    &#125;    // 向FormatterRegistry中添加自定义的格式化器，用于数据类型的格式化和解析，如日期格式化等    default void addFormatters(FormatterRegistry registry) &#123;    &#125;    // 向InterceptorRegistry中添加自定义的拦截器，可用于在请求处理前后执行自定义逻辑，如权限校验、日志记录等    default void addInterceptors(InterceptorRegistry registry) &#123;    &#125;    // 向ResourceHandlerRegistry中添加自定义的资源处理器，用于处理静态资源（如CSS、JS文件）的映射路径等    default void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    &#125;    // 向CorsRegistry中添加跨域资源共享（CORS）的映射配置，解决跨域访问问题    default void addCorsMappings(CorsRegistry registry) &#123;    &#125;    // 向ViewControllerRegistry中添加视图控制器，用于直接映射请求到视图，而无需经过控制器方法处理    default void addViewControllers(ViewControllerRegistry registry) &#123;    &#125;    // 配置视图解析器，比如设置视图解析器的前缀、后缀，选择具体的视图解析器实现类等    default void configureViewResolvers(ViewResolverRegistry registry) &#123;    &#125;    // 向HandlerMethodArgumentResolver列表中添加自定义的处理器方法参数解析器，用于解析控制器方法的参数    default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;    &#125;    // 向HandlerMethodReturnValueHandler列表中添加自定义的处理器方法返回值处理器，用于处理控制器方法的返回值    default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123;    &#125;    // 配置HTTP消息转换器，如设置默认的JSON转换器、XML转换器等，决定如何将请求数据转换为对象以及将对象转换为响应数据    default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    &#125;    // 扩展已有的HTTP消息转换器列表，可在已有的消息转换器基础上添加自定义的转换器    default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    &#125;    // 配置处理器异常解析器，用于处理控制器方法中抛出的异常，如自定义异常处理逻辑、异常视图映射等    default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    &#125;    // 扩展已有的处理器异常解析器列表，可在已有的异常解析器基础上添加自定义的异常解析器    default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    &#125;    // 向ErrorResponse.Interceptor列表中添加自定义的错误响应拦截器，用于在错误响应返回给客户端之前进行处理    default void addErrorResponseInterceptors(List&lt;ErrorResponse.Interceptor&gt; interceptors) &#123;    &#125;    // 获取自定义的验证器，如果返回非null，则使用该验证器进行数据验证    @Nullable    default Validator getValidator() &#123;        return null;    &#125;    // 获取自定义的消息码解析器，用于解析和处理国际化消息码等相关操作    @Nullable    default MessageCodesResolver getMessageCodesResolver() &#123;        return null;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","学习","Spring系列","Spring Boot","Java框架","配置相关"]},{"title":"Spring Farmewrok part1-Spring生态介绍和入门","url":"/posts/26666.html","content":"Spring 和 Spring Framework\r\nSpring、Spring Framework、Spring Boot、Spring Cloud的区别。\r\n首先不少人乐意把 Spring Framework 叫做 spring，但是 spring framework\r\n只是 spring中的一个模型，核心是Ioc和aop，而spring是一个生态，spring\r\n是框架。\r\n\r\n\r\nimage-20250416143538464\r\n\r\n\r\n\r\nimage-20250416143538464\r\n\r\n\r\n\r\nimage-20250416143638910\r\n\r\n\r\n\r\nimage-20250416143638910\r\n\r\nSpring是一个生态体系（也可以说是技术体系），是集大成者，它包含了\r\nSpring Framework、Spring Boot、Spring Cloud 等（还包括Spring Cloud data\r\nflow、spring data、spring integration、spring batch、spring\r\nsecurity、spring hateoas），如下图所示（部分截图）：\r\n\r\nSpring Framework\r\nSpring\r\nFramework是整个spring生态的基石，它可是硬生生的消灭了Java官方主推的企业级开发标准EJB，从而实现一统天下。\r\nSpring Framework为基于现代企业应用提供了一个全面的编程和配置的模型 -\r\n在任何类型部署平台上\r\nSpring\r\nFramework为依赖注入、事务管理、WEB应用、数据访问等提供了核心的支持，专注于企业级应用程序的“管道”，以便开发团队可以专注于应用程序的业务逻辑。\r\nSpring Boot\r\n搭建项目的脚手架、黏合剂，整合周边生态\r\nSpring\r\nBoot这家伙简直就是对Java企业级应用开发进行了一场浩浩荡荡的革命。如果稍微有几年工作经验的老油条，应该都记得以前的Java\r\nWeb开发模式：Tomcat + WAR包。\r\nSpring Boot能够让你非常容易的创建一个单机版本、生产级别的基于spring\r\nframework的应用。然后，“just run”即可。Spring\r\nBoot默认集成了很多第三方包，让构建独立的生产级别的Spring应用变得简单，开箱即用，以便你能以最小的代价开始一个项目。\r\nSpring Cloud\r\nSpring Clound的出现真正简化了分布式架构的开发\r\nSpring Cloud事实上是一整套基于Spring\r\nBoot的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：配置管理、注册中心、服务发现、限流、网关、链路追踪等。\r\nSpring Boot是build anything，而Spring Cloud是coordinate\r\nanything，Spring Cloud的每一个微服务解决方案都是基于Spring\r\nBoot构建的：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\nSpring Cloud Alibaba\r\nSpring Cloud\r\nAlibaba为分布式应用开发提供一站式解决方案，它包含分布式应用程序开发所需的所有组件，使你可以轻松地使用Spring\r\nCloud开发应用程序。\r\n使用Spring Cloud\r\nAlibaba，你只需要增加一些注解和少量的配置，即可将Spring\r\nCloud应用连接到阿里巴巴的分布式解决方案，并可使用阿里巴巴的中间件构建分布式系统\r\nSpring Framework主要包括什么\r\nSpring Framework主要包括几个模块：\r\n\r\n支持IoC和AOP的容器；\r\n支持JDBC和ORM的数据访问模块；\r\n支持声明式事务的模块；\r\n支持基于Servlet的MVC开发；\r\n支持基于Reactive的Web开发；\r\n以及集成JMS、JavaMail、JMX、缓存等其他模块。\r\n\r\nSpring版本5.x 和 6.x的区别\r\n\r\n\r\nimage-20250416135252699\r\n\r\n\r\n\r\nimage-20250416135252699\r\n\r\nSpring官网是spring.io\r\n为什么要学Spring Framework\r\nSpring Framework 是其他 Spring 子项目的基础\r\n无论是传统企业应用还是云原生微服务，Spring Framework 的核心思想（如\r\nIoC、AOP）均贯穿始终\r\nSpring Framework 是整个 Spring 技术栈的基石，其他子项目（如 Spring\r\nBoot、Spring MVC、Spring Cloud\r\n等）均基于其核心功能扩展。它通过控制反转（IoC）、依赖注入（DI）和面向切面编程（AOP）等机制，为上层模块提供统一的基础设施支持\r\n而且S pring Framework 其分层架构（如 Core、AOP、Data Access、Web\r\n等模块）允许开发者按需选择功能，避免冗余依赖。这种灵活性使得 Spring\r\n能够适配从传统单体应用到现代微服务的多样化需求\r\nSpring Framework 提供与多种企业级技术（如\r\nJDBC、JPA、Hibernate、消息队列等）的无缝集成能力，简化了复杂系统的开发\r\n学习 Spring Framework 是掌握 Spring Boot（快速开发）、Spring\r\nCloud（微服务）等高级框架的前提。例如，Spring Boot\r\n的自动配置机制本质上是基于 Spring Framework 的条件化 Bean 加载实现\r\n\r\nSpring\r\nFramework 官方文档\r\nSpring\r\nFramework 源码\r\nSpring\r\n入门课程（W3CSchool）\r\n\r\nSpring Framework特点\r\n\r\n非侵入式：Spring Framework开发应用程序时，Spring\r\n对应用程序本身的结构影响特别小，应用代码基本不会被 Spring 特定的 API\r\n所束缚。开发者能够在不依赖 Spring\r\n框架的环境下对代码进行编译、测试和运行。当项目需要更换框架或者调整架构时，由于代码没有与\r\nSpring 框架深度绑定，迁移工作会相对轻松。开发者可以逐步移除 Spring\r\n相关的配置和依赖，而不会对业务逻辑代码造成重大影响。\r\n控制反转IoC：控制反转是 Spring\r\n框架的核心特性之一，它将对象的创建和依赖关系的管理从应用程序代码转移到了\r\nSpring\r\n容器中。通过控制反转，对象之间的依赖关系变得更加灵活，降低了组件之间的耦合度。\r\n面向切面编程AOP：面向切面编程允许开发者将横切关注点（如日志记录、事务管理、权限验证等）从业务逻辑中分离出来，以提高代码的可维护性和复用性。通过\r\nAOP，我们可以将通用的横切关注点代码封装到切面中，在多个业务模块中复用这些代码，减少了代码的重复编写。\r\n容器：Spring\r\n框架提供了强大的容器功能，用于管理对象的生命周期和依赖关系。IoC是一个容器，包含并且管理组件对象的生命周期，组件享受到了容器化的管理，屏蔽了大量的细节。Spring\r\n容器通过依赖注入的方式将对象之间的依赖关系注入到对象中，使得对象之间的协作更加灵活。\r\n组件化：Spring\r\n鼓励开发者将应用程序拆分成多个独立的组件，每个组件负责特定的功能。开发者可以将不同的业务功能封装成独立的组件，这些组件可以独立开发、测试和部署。组件化的开发方式使得代码结构更加清晰，易于维护和扩展。当需要添加新的功能时，只需要开发新的组件并将其集成到应用中即可。\r\n一站式：Spring\r\n框架提供了一站式的解决方案，涵盖了企业级应用开发的各个方面。可以整合各种企业应用的开源框架和优秀的第三方类库。\r\n\r\nSpring6 的模块组成\r\n\r\n\r\nimage-20250422090232709\r\n\r\n\r\n\r\nimage-20250422090232709\r\n\r\nSpring Framework 主要是围绕 Core 部分\r\n\r\n\r\nimage-20250416154223849\r\n\r\n\r\n\r\nimage-20250416154223849\r\n\r\nSpring Core：核心容器\r\n\r\n\r\nimage-20250416154542715\r\n\r\n\r\n\r\nimage-20250416154542715\r\n\r\nSpring AOP\r\n\r\n\r\nimage-20250416154553397\r\n\r\n\r\n\r\nimage-20250416154553397\r\n\r\nSpring Data Access\r\n\r\n\r\nimage-20250416154623457\r\n\r\n\r\n\r\nimage-20250416154623457\r\n\r\nSpring Web\r\n就是大家通常说的Spring MVC部分\r\n\r\n\r\nimage-20250416172213876\r\n\r\n\r\n\r\nimage-20250416172213876\r\n\r\nSpring Message 和 Spring test\r\n\r\n\r\nimage-20250416172240188\r\n\r\n\r\n\r\nimage-20250416172240188\r\n\r\n如何创建工程\r\n父工程 spring6 子工程 你自己项目名称\r\n开发步骤：\r\n\r\n引入spring相关依赖\r\n创建类，定义属性和方法\r\n按照spring要求创建配置文件 xml\r\nspring配置文件配置相关信息\r\n进行测试\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringBoot part0?INF-SpringBoot这个框架都需要学习什么","url":"/posts/39918.html","content":"前言\r\n本文章说是 Spring Boot 这个框架都需要学习什么，不如说是 Spring Boot\r\n框架都有什么需要学习。\r\n对于初学者看看了解脉络还是很可以的，对于学完的高手看看可以总结查缺。\r\n所以，这篇文章的目标是详细与简便兼具的一个要点，详细是有些东西多的地方就相对详细，简便意思是随时浏览随时清晰，而且本文会根据我的\r\nSpring Boot 学习持续更新。\r\n其实 Spring Boot 这个框架东西并没有那么多，但是前提是你学习了 Spring\r\nFramework，因为 Bean 的管理，IoC（控制反转）与\r\nDI（依赖注入），AOP（面向切面编程），这些东西确实是有些难以理解和贴近框架底层的。\r\nSpring Boot 框架其实不包含 ORM 框架，但是一般学的时候，好像都是带着\r\nMyBatis 或 MyBatis-Plus， Spring Data JPA（Repository\r\n接口、@Query等）和 JPA 规范与 Hibernate 一起学了。\r\nSpring MVC 架构其实我是没有学的，因为感觉东西不少而且 Thymeleaf 或\r\nFreeMarker（前后端不分离场景）用的不是很多，但是 MVC 架构打我第一个 Java\r\n小项目就是用的这种设计模式，这种设计模式还是蛮舒服的。\r\nRESTful API 开发 和 @Validated\r\n参数校验什么的，还是有一些头疼的。\r\n\r\n在学习 Spring Boot\r\n之前，确保掌握以下知识：\r\nJavaSE 基础：\r\n基本的 Web 知识：\r\n\r\nHTTP 协议基础（GET/POST 请求）。\r\nServlet\r\nJSON 数据格式。\r\n\r\nMaven 或 Gradle：学习如何管理依赖。\r\n数据库MySQL\r\nSpring Framework\r\n\r\n认识 Spring 和 Spring\r\nBoot\r\n我们刚开始学习 JavaWeb 的时候，使用 Servlet/JSP\r\n做开发，一个接口搞一个 Servlet\r\n，很头大，后来我们通过隐藏域或者反射等方式，可以减少 Servlet\r\n的创建，但是依然不方便。\r\n再后来，我们引入 Struts2/SpringMVC 这一类的框架，来简化我们的开发\r\n，和 Servlet/JSP\r\n相比，引入框架之后，生产力确实提高了不少，但是用久了，又发现了新的问题，即配置繁琐易出错，要做一个新项目，先搭建环境，环境搭建来搭建去，就是那几行配置，不同的项目，可能就是包不同，其他大部分的配置都是一样的。\r\nJava\r\n总是被人诟病配置繁琐代码量巨大，这就是其中一个表现。那么怎么办？Spring\r\nBoot 应运而生，Spring Boot 是 Pivotal 团队在 2013 年开始研发的一个基于\r\nSpring 的全新框架，试图将 Spring 中臃肿的配置进行简化，使 Java\r\n开发更加轻量与快速，这个框架非常活跃，官方也非常重视。\r\n从 Spring Boot 诞生的过程中，我们可以看到：\r\n\r\nSpring Boot 并非另起炉灶，而是在现有的 Spring\r\n框架的基础上整出来的，它把 Spring 中繁琐的配置进行了简化。\r\nSpring Boot 降低了 Spring 家族的使用门槛，使新手更易上手 Spring\r\n框架。\r\n\r\n既然 Spring Boot 不是另起炉灶，那么 Spring Boot 学习要不要跳过 SSM\r\n呢？\r\n别\r\n因为即使你跳过了 SSM 直接去学习 Spring Boot，实际上还是在学习 Spring\r\n中的东西，那既然这样，我们还不如坐下来，老老实实把 Spring 过一遍。\r\nSpring 我习惯叫做 Spring Framework\r\n\r\nSpring Framework 是一个全面的框架，用于企业级开发。\r\n包括依赖注入 (DI)、面向切面编程 (AOP)、数据访问、事务管理等。\r\n\r\nSpring Boot 是对 Spring 的简化和增强：\r\n\r\n无需繁琐配置（XML 配置，使用 properties）。\r\n提供内嵌服务器（Tomcat、Jetty）。\r\n快速启动 Web 应用程序。\r\n\r\n官方文档： Spring\r\nBoot 官方文档\r\n\r\n一、Spring Boot\r\n基础入门\r\n1. 核心思想与优势\r\n\r\n约定优于配置（Convention over\r\nConfiguration）：Spring Boot\r\n遵循约定优于配置的原则，简单来说就是你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。它为开发者提供了一系列的默认配置，使得开发者可以快速搭建项目。例如，Spring\r\nBoot 默认使用嵌入式 Tomcat 作为服务器，默认的配置文件名为\r\napplication.properties 或\r\napplication.yml。\r\nSpringBoot\r\nStarter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。而且SpringBoot采用\r\nJavaConfig 的方式对 Spring\r\n进行配置，并且提供了大量的注解，极大的提高了工作效率。\r\n自动配置（Auto-Configuration）原理：Spring Boot\r\n的自动配置功能是通过 spring-boot-autoconfigure\r\n模块实现的。利用了Spring对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们。该模块根据类路径下的依赖和配置信息，自动为应用程序配置所需的\r\nBean。例如，如果类路径下存在 H2 数据库的依赖，Spring Boot 会自动配置 H2\r\n数据库的数据源。\r\n起步依赖（Starter Dependencies）的作用：起步依赖是\r\nSpring Boot\r\n提供的一种简化依赖管理的方式。它将一组相关的依赖打包成一个依赖，开发者只需要引入该依赖，就可以自动引入所需的所有依赖。例如，spring-boot-starter-web\r\n依赖包含了 Spring MVC、嵌入式 Tomcat 等依赖。\r\n使部署变得简单：SpringBoot 内置了三种 Servlet\r\n容器，Tomcat，Jetty，undertow。我们只需要一个Java的运行环境就可以跑\r\nSpringBoot 的项目了，SpringBoot 的项目可以打成一个jar包。\r\n\r\n2. 快速搭建项目\r\n\r\n使用 Spring\r\nInitializr 生成项目：Spring Initializr\r\n是一个在线的项目生成工具，IDEA\r\n集成了这个，很方便，它可以帮助我们快速生成 Spring Boot\r\n项目。我们只需要选择项目的元数据、依赖和构建工具，就可以生成一个基本的\r\nSpring Boot 项目。\r\n项目结构解析（src/main/java、resources\r\n目录）：src/main/java 目录是 Java\r\n源代码的存放目录，我们可以在该目录下创建包和类。resources\r\n目录是资源文件的存放目录，如配置文件、静态资源等。\r\nSpring Initializr 生成的标准项目结构如下：\r\nsrc├── main│   ├── java│   │   └── com│   │       └── example│   │           └── demo│   │               ├── DemoApplication.java      # 启动类│   │               ├── controller              # 控制器层│   │               ├── service                 # 服务层│   │               ├── repository              # 数据访问层（DAO）│   │               ├── entity                  # 实体类│   │               └── config                  # 配置类│   └── resources│       ├── application.properties            # 配置文件│       ├── static                    # 静态资源（CSS/JS/图片）│       ├── templates                 # 模板文件（Thymeleaf/FreeMarker）│       └── META-INF│           └── resources             # 元数据资源└── test    └── java        └── com            └── example                └── demo                    ├── DemoApplicationTests.java  # 测试类                    ├── controller                 # 控制器测试                    └── service                    # 服务测试等等\r\n\r\n\r\nimg\r\n\r\n启动类 @SpringBootApplication\r\n的作用：@SpringBootApplication\r\n是一个组合注解，它包含了\r\n@SpringBootConfiguration、@EnableAutoConfiguration\r\n和 @ComponentScan\r\n三个注解。@SpringBootConfiguration\r\n表示该类是一个配置类，@EnableAutoConfiguration\r\n启用自动配置功能，@ComponentScan 扫描组件。\r\n\r\n3. 配置文件与优先级\r\n\r\napplication.properties vs\r\napplication.yml：application.properties\r\n和 application.yml 都是 Spring Boot\r\n支持的配置文件格式。application.properties\r\n是传统的属性文件格式，使用键值对的方式进行配置。application.yml\r\n是 YAML\r\n格式的配置文件，使用缩进和冒号的方式进行配置，更加简洁易读。如果是2.4.0之前版本，优先级properties&gt;yaml；但是如果是2.4.0的版本，优先级yaml&gt;properties。\r\n配置加载顺序（命令行参数 &gt; 外部文件 &gt;\r\n内部配置）：Spring Boot\r\n会按照一定的顺序加载配置文件，命令行参数的优先级最高，其次是外部文件，最后是内部配置文件。但是通常情况下，我们认为，根目录下的config中的application.properties的优先级大于项目根目录下的application.properties，大于\r\nresources文件夹config中的application.properties，大于resources文件夹根目录下的application.properties，并且相同配置文件按顺序加载可以实现互补，但是不会被覆盖。\r\n多环境配置（spring.profiles.active）：我们可以使用\r\nspring.profiles.active\r\n属性来指定当前的环境，如开发环境、测试环境、生产环境等。Spring Boot\r\n会根据该属性加载对应的配置文件，如\r\napplication-dev.properties、application-test.properties、application-prod.properties。\r\n自定义配置项（@Value 与\r\n@ConfigurationProperties）：我们可以使用\r\n@Value 注解或 @ConfigurationProperties\r\n注解来读取自定义配置项。@Value\r\n注解用于读取单个配置项，@ConfigurationProperties\r\n注解用于读取一组配置项。\r\n自定义application.properties配置文件注入IOC容器（属性注入的两种方式）：Spring\r\nBoot 支持将自定义配置从 application.properties 或\r\napplication.yml 直接注入到 Spring IOC 容器的 Bean\r\n中，常用以下两种方式：\r\n\r\n使用 @Value\r\n注解，适用于单个属性的注入，直接绑定到字段，适用于简单类型；\r\n使用 @ConfigurationProperties\r\n注解：用于将配置文件（如 application.properties 或\r\napplication.yml）中的属性适用于批量绑定一组配置到对象，还可以在公共\r\n@Bean\r\n方法上使用它，将属性绑定到控件之外的第三方组件。\r\n\r\n松散绑定：Spring Boot\r\n使用一些宽松的规则将环境属性绑定到@ConfigurationProperties\r\nbean，因此环境属性名和 bean\r\n属性名之间不需要完全匹配，比如在application.properties文件里定义一个\r\nfirst-name=tom，而且可以支持多种命名风格的属性名，在对应\r\nbean 类中使用 firstName 也能获取到对应的值，这就是松散绑定。\r\n# 标准驼峰式（Java 风格）app.user.firstName=John# 烤肉串式（Kebab Case，推荐）app.user.first-name=John# 蛇形式（Snake Case）app.user.first_name=John# 大写下划线式（UPPER_SNAKE_CASE）app.user.FIRST_NAME=John\r\n\r\n\r\n@Componentpublic class MyService &#123;    @Value(&quot;$&#123;custom.property.name&#125;&quot;) // 读取配置项    private String name;    @Value(&quot;$&#123;custom.property.timeout:1000&#125;&quot;) // 带默认值    private int timeout;&#125;/////////////////////////@Component@ConfigurationProperties(prefix = &quot;custom&quot;) // 指定配置前缀public class CustomConfig &#123;    private String propertyName;    private int timeout;    private List&lt;String&gt; list;    // 必须提供 Setter 方法    public void setPropertyName(String propertyName) &#123;        this.propertyName = propertyName;    &#125;    // 其他 Setter...&#125;\r\n# 使用 @Value 注解custom.property.name=SpringBootcustom.property.timeout=2000#  使用 @ConfigurationProperties 注解custom:  property-name: &quot;SpringBoot&quot;  timeout: 2000  list: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\r\n\r\n二、Spring Boot\r\n核心机制\r\n1. 自动配置原理\r\n\r\nspring-boot-autoconfigure\r\n模块的作用：spring-boot-autoconfigure 模块是\r\nSpring Boot\r\n自动配置的核心模块，它包含了大量的自动配置类。这些自动配置类根据类路径下的依赖和配置信息，自动为应用程序配置所需的\r\nBean。\r\n@EnableAutoConfiguration 与\r\nMETA-INF/spring.factories：@EnableAutoConfiguration\r\n注解用于启用自动配置功能，它会扫描\r\nMETA-INF/spring.factories\r\n文件，该文件中定义了所有的自动配置类。\r\n条件注解（@ConditionalOnClass,\r\n@ConditionalOnMissingBean）：条件注解是 Spring\r\nBoot 提供的一种灵活的配置方式，它可以根据条件来决定是否加载某个\r\nBean。例如，@ConditionalOnClass\r\n注解表示只有当指定的类存在于类路径中时，才会加载该\r\nBean；@ConditionalOnMissingBean 注解表示只有当指定的 Bean\r\n不存在时，才会加载该 Bean。\r\n\r\n关于条件注解的讲解：\r\n\r\n@ConditionalOnBean：仅仅在当前上下文中存在某个对象时，才会实例化一个Bean。\r\n@ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。\r\n@ConditionalOnExpression：当表达式为true的时候，才会实例化一个Bean。基于SpEL表达式的条件判断。\r\n@ConditionalOnMissingBean：仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean。\r\n@ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。\r\n@ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。\r\n@ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。\r\n@ConditionalOnNotWebApplication：当项目不是一个Web项目时进行实例化。\r\n@ConditionalOnProperty：当指定的属性有指定的值时进行实例化。\r\n@ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。\r\n@ConditionalOnResource：当类路径下有指定的资源时触发实例化。\r\n@ConditionalOnJndi：在JNDI存在的条件下触发实例化。\r\n@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。\r\n\r\n\r\nSpring Boot数据源自动配置：Spring Boot\r\n的数据源自动配置主要通过spring-boot-autoconfigure模块实现，该模块是\r\nSpring Boot\r\n自动配置的核心模块，包含了大量的自动配置类，这些类会根据类路径下的依赖和配置信息，自动为应用程序配置所需的\r\nBean。对于数据源配置而言，它会根据项目中引入的数据库相关依赖（如\r\nH2、MySQL 等），自动配置相应的数据源。\r\n\r\napplication.properties文件中数据源指定的命名规则是因为底层源码设定了需要这样才能获取，注入DataSourceProperties类对象中。数据源自动配置连接池默认指定Hikari，通过指定TYPE就可以实现更换连接池。\r\n@EnableAutoConfiguration：这个注解用于启用自动配置功能，它会扫描META-INF/spring.factories文件，该文件中定义了所有的自动配置类。当\r\nSpring Boot\r\n应用启动时，@EnableAutoConfiguration会触发自动配置机制，让\r\nSpring Boot 去查找并应用合适的数据源自动配置类。\r\nMETA-INF/spring.factories：在这个文件中，会指定数据源自动配置类（如DataSourceAutoConfiguration），Spring\r\nBoot\r\n启动时会读取该文件，加载相应的自动配置类。启动时，@EnableAutoConfiguration\r\n会读取这些类并应用条件注解，决定是否生效。\r\n\r\n\r\n2. Bean 管理与扩展\r\n\r\nSpring Boot 对 Spring Bean 的增强：Spring Boot 在\r\nSpring 的基础上对 Bean\r\n管理进行了增强，如自动配置、条件注解等。这些增强功能使得我们可以更加方便地管理\r\nBean。\r\n自定义 Bean 覆盖默认配置（如替换内嵌\r\nTomcat）：我们可以通过自定义 Bean 来覆盖 Spring Boot\r\n的默认配置。例如，我们可以自定义一个嵌入式服务器 Bean，来替换默认的\r\nTomcat 服务器。\r\n@Primary、@Qualifier 解决 Bean\r\n冲突：当存在多个相同类型的 Bean 时，我们可以使用\r\n@Primary 注解来指定一个主要的 Bean，或者使用\r\n@Qualifier 注解来指定具体的 Bean。\r\n\r\n3. 内嵌容器与启动流程\r\n\r\n内嵌 Tomcat/Jetty/Undertow 的配置与切换：Spring\r\nBoot 默认使用嵌入式 Tomcat\r\n作为服务器，我们可以通过修改依赖和配置来切换到 Jetty 或 Undertow\r\n服务器。\r\n启动类 SpringApplication.run()\r\n的源码简析：SpringApplication.run() 方法是 Spring\r\nBoot 应用程序的启动入口，它会创建一个 Spring\r\n应用上下文，并启动嵌入式服务器。\r\n自定义 Banner 与启动参数：我们可以通过在\r\nresources 目录下创建 banner.txt\r\n文件来自定义启动\r\nBanner，也可以通过命令行参数或配置文件来设置启动参数。\r\n内嵌 tomcat 原理：Spring Boot 默认支持\r\nTomcat，Jetty，和 Undertow 作为底层容器。而 Spring Boot\r\n默认使用Tomcat，一旦引入spring-boot-starter-web模块，就默认使用\r\nTomcat\r\n容器。核心启动类在启动的时候，进入AutoConfigurationImportSelector类中的getAutoConfigurationEntry方法去各个模块\r\nWEB-INF\r\n下的spring.factories配置文件中加载相关配置类，获取到ServletWebServerFactoryAutoConfiguration自动配置类，也就是\r\ntomcat\r\n自动配置。ServletWebServerFactoryAutoConfiguration注解类中@Import引入的EmbeddedTomcat类里面TomcatServletWebServerFactory工厂类的getWebServer方法一旦被启动他就会创建并启动内嵌tomcat。\r\n\r\n总结内嵌 Tomcart 启动流程：\r\n\r\n触发自动配置：\r\n引入 spring-boot-starter-web\r\n后，ServletWebServerFactoryAutoConfiguration\r\n自动生效。\r\n创建 WebServer：\r\nTomcatServletWebServerFactory 的\r\ngetWebServer() 方法初始化 Tomcat 实例。\r\n端口绑定与启动：\r\n读取 server.port 配置（默认 8080），绑定端口并启动\r\nTomcat。\r\n\r\n\r\n\r\n三、Spring Boot\r\n集成与扩展\r\n1. 数据访问\r\n\r\n整合 JDBC：spring-boot-starter-jdbc +\r\nDataSource 配置：我们可以使用\r\nspring-boot-starter-jdbc 依赖来整合 JDBC，通过配置\r\nDataSource 来连接数据库。\r\n整合 JPA：spring-boot-starter-data-jpa +\r\n自动建表：使用 spring-boot-starter-data-jpa\r\n依赖可以整合 JPA，Spring Data JPA 会根据实体类自动生成数据库表。\r\n整合 MyBatis：mybatis-spring-boot-starter +\r\n注解 / XML 配置：通过 mybatis-spring-boot-starter\r\n依赖可以整合 MyBatis，我们可以使用注解或 XML 文件来配置 SQL 语句。\r\n事务管理：@Transactional\r\n的生效条件：@Transactional\r\n注解用于开启事务，它的生效条件包括方法必须是 public 的，类必须被 Spring\r\n管理等。\r\n\r\n2. Web 开发\r\n\r\n快速构建 RESTful\r\nAPI（@RestController、@GetMapping\r\n等）：使用 @RestController 注解可以快速构建\r\nRESTful API，@GetMapping 等注解用于处理 HTTP 请求。\r\n请求参数处理（@RequestParam、@PathVariable、@RequestBody）：@RequestParam\r\n用于处理查询参数，@PathVariable\r\n用于处理路径参数，@RequestBody 用于处理请求体。\r\n统一响应格式与全局异常处理（@ControllerAdvice）：使用\r\n@ControllerAdvice\r\n注解可以实现统一响应格式和全局异常处理。\r\n文件上传与下载（MultipartFile）：通过\r\nMultipartFile 可以实现文件上传，使用\r\nResponseEntity 可以实现文件下载。\r\n\r\n3. 安全与权限\r\n\r\n整合 Spring\r\nSecurity：spring-boot-starter-security：使用\r\nspring-boot-starter-security 依赖可以整合 Spring\r\nSecurity，实现安全认证和授权。\r\n基础认证配置（内存用户、数据库用户）：可以配置内存用户或从数据库中获取用户信息进行认证。\r\n自定义登录页与权限规则：可以自定义登录页和权限规则，实现个性化的安全配置。\r\n\r\n4. 缓存与消息队列\r\n\r\n整合 Redis：spring-boot-starter-data-redis +\r\nRedisTemplate：使用\r\nspring-boot-starter-data-redis 依赖可以整合 Redis，通过\r\nRedisTemplate 可以操作 Redis 缓存。\r\n整合\r\nRabbitMQ/Kafka：spring-boot-starter-amqp/kafka：使用\r\nspring-boot-starter-amqp 或\r\nspring-boot-starter-kafka 依赖可以整合 RabbitMQ 或 Kafka\r\n消息队列。\r\n声明式缓存（@Cacheable、@CacheEvict）：使用\r\n@Cacheable\r\n等注解可以实现声明式缓存，提高应用程序的性能。\r\n\r\n5. 日志管理\r\n\r\nSLF4J：SLF4J（Simple Logging Facade for\r\nJava）是日志门面，提供统一的日志 API，Spring Boot 默认使用\r\nSLF4J 作为日志门面（抽象层），并集成了 Logback\r\n作为默认的日志实现框架，允许开发者在不修改代码的情况下切换底层日志框架（如\r\nLogback、Log4j2）。并集成 Logback\r\n作为日志实现框架。由于每一个日志的实现框架都有自己的配置文件，所以在使用\r\nSLF4j 之后，配置文件还是要使用实现日志框架的配置文件。\r\n统一日志依赖：Spring Boot 通过\r\nspring-boot-starter-logging 默认引入 SLF4J +\r\nLogback，其他框架（如 MyBatis、Spring Security）的日志也会被桥接到\r\nSLF4J。这意味着开发者在使用这些框架时，无需额外配置日志，所有日志都会统一输出。在\r\nMaven 项目中，spring-boot-starter-web 依赖会自动引入\r\nspring-boot-starter-logging：\r\nSpring Boot 的日志配置：开发者可以通过 SLF4J\r\n提供的日志级别（如\r\nTRACE、DEBUG、INFO、WARN、ERROR）来控制日志的输出粒度。\r\n\r\n默认日志输出：\r\n\r\n控制台输出：Spring Boot 默认会将日志输出到控制台，INFO\r\n级别及以上；\r\n文件输出：需手动配置 logging.file.name 或\r\nlogging.file.path。\r\n\r\n日志级别配置：可以通过 logging.level\r\n属性来配置不同包或类的日志级别。\r\n日志输出格式配置：可以通过 logging.pattern.console 和\r\nlogging.pattern.file\r\n来配置控制台和文件的日志输出格式。\r\n\r\nlogging:  level:    root: INFO    com.example.demo: DEBUG  # 包级别日志  file:    name: app.log           # 日志文件路径  pattern:    console: &quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&quot;    file: &quot;%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&quot;\r\n自定义日志输出：可以在配置文件编写日志相关配置实现自定义日志输出。\r\n\r\n自定义 Logback：可以在 src/main/resources 目录下创建\r\nlogback-spring.xml 文件，进行自定义 Logback 配置。\r\n\r\n替换日志框架：虽然 Spring Boot 默认使用 Logback\r\n作为日志实现框架，但开发者可以根据需要替换为其他日志框架，如\r\nLog4j2。\r\n\r\n切换为 Log4j2\r\n排除默认 Logback：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;\r\n引入 Log4j2 Starter：\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;\r\n配置 log4j2-spring.xml：\r\n&lt;Configuration&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n\r\n日志性能优化：在高并发场景下，日志输出可能会成为性能瓶颈。可以通过异步日志的方式来减少\r\nI/O 阻塞，提升性能。\r\nLogback 配置示例：\r\n&lt;appender name=&quot;ASYNC_FILE&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;    &lt;appender-ref ref=&quot;FILE&quot;/&gt;&lt;/appender&gt;\r\nLog4j2 配置示例\r\n&lt;Configuration&gt;    &lt;Appenders&gt;        &lt;Async name=&quot;Async&quot;&gt;            &lt;AppenderRef ref=&quot;File&quot;/&gt;        &lt;/Async&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Async&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n\r\n四、Spring Boot\r\n高级特性\r\n1. 自定义 Starter\r\n\r\n创建自己的 Starter 模块：可以创建一个独立的\r\nMaven 或 Gradle 模块作为 Starter。\r\n\r\n实现：\r\n\r\n创建 Maven 模块：\r\n\r\n定义 xxx-spring-boot-starter 和\r\nxxx-spring-boot-autoconfigure 两个模块。\r\n\r\n编写自动配置类：\r\n@Configuration@ConditionalOnClass(MyService.class)@EnableConfigurationProperties(MyProperties.class)public class MyAutoConfiguration &#123;    @Bean    @ConditionalOnMissingBean    public MyService myService(MyProperties properties) &#123;        return new MyService(properties);    &#125;&#125;\r\n注册配置类：在\r\nsrc/main/resources/META-INF/spring.factories 中添加：\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.MyAutoConfiguration\r\n\r\n\r\nSpring Boot 中的 starter：Spring Boot 中的\r\nstarter 是一种非常重要的机制，能够抛弃以前繁杂的配置，将其统一集成进\r\nstarter，应用者只需要在 maven 中引入 starter 依赖，Spring Boot\r\n就能自动扫描到要加载的信息并启动相应的默认配置。starter\r\n让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。Spring\r\nBoot会自动通过 classpath 路径下的类发现需要的 Bean，并注册进 IOC\r\n容器。Spring Boot提供了针对日常企业应用研发各种场景的\r\nspring-boot-starter\r\n依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。简而言之，starter\r\n就是一个外部的项目，我们需要使用它的时候就可以在当前 Spring Boot\r\n项目中引入它，Spring Boot会自动完成装配。\r\n编写 Auto-Configuration\r\n类与条件注解：编写自动配置类和使用条件注解来实现自定义配置。\r\n打包并发布 Starter（供其他项目依赖）：将 Starter\r\n模块打包并发布到 Maven 仓库，供其他项目依赖。\r\n自定义Starter热插拔技术：\r\n\r\n2. 监控与管理\r\n\r\nActuator 端点（/health, /metrics,\r\n/env）：Actuator 提供了一系列的端点，如\r\n/health 用于检查应用程序的健康状态，/metrics\r\n用于查看应用程序的指标信息。\r\n自定义健康检查（HealthIndicator）：可以自定义健康检查类，实现\r\nHealthIndicator 接口。\r\n整合 Prometheus 暴露指标：可以将 Actuator\r\n的指标信息暴露给 Prometheus 进行监控。\r\n\r\n3. 测试与调试\r\n\r\n单元测试：@SpringBootTest +\r\nMockMvc：使用 @SpringBootTest\r\n注解进行集成测试，使用 MockMvc 进行模拟 HTTP\r\n请求。\r\n测试切片（@WebMvcTest,\r\n@DataJpaTest）：使用测试切片注解可以只加载部分组件进行测试。\r\n热部署（DevTools 的自动重启）：通过\r\nspring-boot-devtools\r\n依赖实现热部署，可以实现不重启服务器情况下，对项目进行即时编译，修改代码后自动重启应用，提升开发效率。\r\n热部署就是我们在编辑器上启动项目，然后改动相关的代码，然后编辑器自动触发编译，替换掉历史的\r\n.class 文件后，项目检测到有文件变更后会重启 spring boot\r\n项目。内部主要是通过引入的插件对我们的 classpath 资源变化进行监听，当\r\nclasspath 有变化，才会触发重启。\r\n\r\n4. 性能优化\r\n\r\n启动速度优化（懒加载 @Lazy）：使用\r\n@Lazy 注解可以实现 Bean\r\n的懒加载，提高应用程序的启动速度。\r\n内存与线程池调优（Tomcat 线程池配置）：可以通过配置\r\nTomcat 线程池来优化内存和性能。\r\n关闭不必要的自动配置（exclude\r\n参数）：使用 exclude\r\n参数可以关闭不必要的自动配置，减少应用程序的启动时间。\r\n\r\n5.Spring Boot缓存\r\n\r\n缓存概念及缓存注解:\r\n5个核心接口\r\n缓存注解@Cacheable实现\r\n\r\n五、实战与部署\r\n1. 项目实战\r\n\r\n从零搭建一个 Spring Boot\r\n项目（含数据库、API、安全）：按照前面所学的知识，从零开始搭建一个完整的\r\nSpring Boot 项目，包括数据库连接、API 开发和安全认证。\r\n集成 Swagger 生成 API\r\n文档（springdoc-openapi）：使用\r\nspringdoc-openapi 依赖可以集成 Swagger，自动生成 API\r\n文档。\r\n日志配置（Logback 日志分级与文件输出）：使用\r\nLogback 进行日志配置，实现日志分级和文件输出。\r\n\r\n2. 打包与部署\r\n\r\n打包为可执行 JAR（mvn package）：使用\r\nmvn package 命令可以将项目打包为可执行 JAR 文件。\r\n打包为 WAR 包部署：修改 pom.xml 配置为\r\nwar，添加依赖&lt;javax.serlvet&gt;servlet 的\r\napi，然后排除Spring Boot内置 Tomcat，最后需要改造启动类，打包交给外置\r\nTomcat 运行\r\nJAR 与 WAR 的差异：\r\n\r\njar更加简单方便，使用 java -jar xx.jar 就可以启动。所以打成 jar\r\n包的最多。而 war包可以部署到tomcat的 webapps\r\n中，随Tomcat的启动而启动。具体使用哪种方式，应视应用场景而定。\r\n打jar包时不会把src/main/webapp 下的内容打到jar包里\r\n(你认为的打到jar包里面，路径是不行的会报404)打war包时会把src/main/webapp\r\n下的内容打到war包里。\r\n打成什么文件包进行部署与项目业务有关，就像提供 rest\r\n服务的项目需要打包成\r\njar文件，用命令运行很方便。而有大量css、js、html，且需要经常改动的项目，打成\r\nwar\r\n包去运行比较方便，因为改动静态资源可以直接覆盖，很快看到改动后的效果，这是\r\njar 包不能比的。\r\n\r\n多环境打包（-Pprod\r\n激活生产配置）：使用 -Pprod\r\n参数可以激活生产环境的配置进行打包。线上环境prod(product)、开发环境dev(development)、测试环境test、提测环境qa、单元测试unitest等等多种环境进行不同配置。\r\nDocker 化部署（编写 Dockerfile + 多阶段构建）：编写\r\nDockerfile 并使用多阶段构建将项目打包为 Docker\r\n镜像，实现容器化部署。\r\n监控插件-Acturator：Spring\r\nboot作为微服务框架，除了它强大的快速开发功能外，还有就是它提供了actuator模块，引入该模块能够自动为Spring\r\nboot应用提供一系列用于监控的端点。Spring Boot Actuator提供了对单个Spring\r\nBoot的监控，信息包含：应用状态、内存、线程、堆栈等等，比较全面的监控了Spring\r\nBoot应用的整个生命周期。\r\nActuator 的 REST 接口：\r\n\r\n3. 生产级配置\r\n\r\n健康检查与优雅停机：配置健康检查端点，实现应用程序的优雅停机。\r\n配置 HTTPS（SSL 证书）：配置 SSL 证书，实现\r\nHTTPS 访问。\r\n使用 Spring Boot Admin\r\n监控多服务：使用 Spring Boot Admin 可以监控多个\r\nSpring Boot 服务的运行状态。\r\n\r\n六、扩展学习（Spring Boot\r\n生态）\r\n1. 响应式编程\r\n\r\nSpring WebFlux（Reactive 编程）：Spring WebFlux 是\r\nSpring 提供的响应式编程框架，它基于 Reactor\r\n库，支持异步、非阻塞的请求处理。\r\nspring-boot-starter-webflux 构建响应式\r\nAPI：使用 spring-boot-starter-webflux\r\n依赖可以快速构建响应式 API。\r\n对比 MVC 与 WebFlux 的适用场景：MVC\r\n适用于传统的同步请求处理场景，WebFlux\r\n适用于高并发、异步的请求处理场景。\r\n\r\n2. 云原生支持\r\n\r\n整合 Kubernetes（ConfigMap、Secret）：可以将 Spring\r\nBoot 应用程序部署到 Kubernetes 集群中，使用 ConfigMap 和 Secret\r\n进行配置管理。\r\n服务发现与配置中心（Spring Cloud 集成）：通过\r\nSpring Cloud 可以实现服务发现和配置中心，如使用 Eureka\r\n进行服务发现，使用 Config Server 进行配置管理。\r\nService Mesh（Istio）：可以使用 Istio 作为 Service\r\nMesh 来管理 Spring Boot 应用程序的网络流量。\r\n\r\n3. 源码深度\r\n\r\nSpring Boot 启动流程源码分析：深入分析 Spring Boot\r\n启动流程的源码，了解其内部实现原理。\r\n常用设计模式（工厂、单例、代理等）：学习 Spring\r\nBoot 中常用的设计模式，如工厂模式、单例模式、代理模式等。\r\n核心注解 @SpringBootApplication\r\n源码分析：分析 @SpringBootApplication\r\n注解的源码，了解其背后的实现机制。\r\n自动配置加载流程追踪（Debug 启动过程）：通过 Debug\r\n启动过程，追踪自动配置的加载流程。\r\n\r\n4. 版本意识：\r\n\r\n注意 Spring Boot 2.x 与 3.x 的区别（如 Jakarta EE 9+）。Spring Boot\r\n3.x 基于 Jakarta EE 9+，与 Spring Boot 2.x\r\n有一些不兼容的地方，在升级时需要注意。\r\n\r\n七、Spring\r\nBoot源码分析\r\n1.\r\nspring-boot-starter-parent\r\n2.spring-boot-starter-web\r\n3.自动配置@SpringBootApplication\r\n4.自动配置@SpringBootConfiguration\r\n5.自动配置@\r\nEnableAutoConfiguration\r\n6.自动配置@Import(AutoConfigurationImportSelector\r\n.class)\r\n7.AutoConfigurationEntry\r\n方法\r\n8.自动配置HttpEncodingAutoConfiguration\r\n9.@ComponentScan注解\r\n10.源码剖析Run方法整体流程\r\n11.自动配置DispatcherServlet加载\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","框架知识","JavaEE","Spring系列","Spring Boot","Java框架","知识总结"]},{"title":"Spring Framework Part3-IoC基于XML管理Bean上篇","url":"/posts/17876.html","content":"基于XML管理bean\r\n搭建基本环境\r\n在这之前，建议在父工程中的pom文件里导入我们需要的依赖，这样其里面的子工程会自动添加，会方便许多\r\n父工程(Spring6)的pom.xml文件，导入相关依赖\r\n&lt;!-- 依赖关系定义 --&gt;    &lt;dependencies&gt;                &lt;!--log4j2的依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.19.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;            &lt;version&gt;2.19.0&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 引入Spring Context依赖，它是Spring框架的基础模块，提供了环境配置、Bean生命周期管理、事件传播等功能 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;6.0.2&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 引入JUnit5测试框架，用于编写和运行单元测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;            &lt;version&gt;5.3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\r\n设置成功刷新后，Maven里应该是这样子的\r\n\r\n\r\nimage-20250419201336427\r\n\r\n搭建子模块spring6-ioc-xml\r\n在Spring6父工程中创建子模块，在子模块中的resources文件夹下创建配置文件–bean.xml\r\n创建相关的User类，以便后续测试使用，注意有分包的好习惯\r\npackage com.sakurapaid.spring.iocxml; public class User &#123;    private String name;    private int age;     public void test() &#123;        System.out.println(&quot;这是一个test测试输出~(￣▽￣)／&quot;);    &#125;&#125;\r\n获取bean实例\r\n首先在bean.xml配置文件中进行配置\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean id=&quot;user&quot; class=&quot;com.sakurapaid.spring.iocxml.User&quot;&gt;        &lt;/bean&gt;&lt;/beans&gt;\r\n在Spring的XML配置文件中，&lt;bean&gt;元素用于定义一个Bean实例。id\r\n属性为 Bean 定义一个唯一标识符，可以通过这个标识符在其他地方引用这个\r\nBean 。class 属性指定了创建 Bean 实例时使用的类，它告诉 Spring\r\n容器要实例化哪个类。\r\n例如，在示例中，&lt;bean id=\"user\" class=\"com.sakurapaid.spring.iocxml.User\"&gt;表示Spring将实例化一个com.sakurapaid.spring.iocxml.User类的\r\nBean，并将其标识符设置为”user”。（这样就省去了自己手动创建实例化对象相关的操作）\r\n其中与XML\r\nSchema相关的部分格式是固定的，我们只关注&lt;bean&gt;的配置\r\n\r\n每个`都有一个id`标识，相当于Bean的唯一ID；\r\n在userServiceBean中，通过``注入了另一个Bean；\r\nBean的顺序不重要，Spring根据依赖关系会自动正确初始化。\r\n\r\n只不过Spring容器是通过读取XML文件后使用反射完成的。\r\n如果注入的不是Bean，而是boolean、int、String这样的数据类型，则通过value注入，例如，创建一个HikariDataSource：\r\n&lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt;    &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt;    &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;\r\n再创建一个相关的测试类UserTest.Java\r\npackage com.sakurapaid.spring.iocxml; public class UserTest &#123;    public static void main(String[] args) &#123;     &#125;&#125;\r\n根据id获取\r\n// 方式一：根据Bean的id获取实例User user1 = (User) context.getBean(&quot;user&quot;);System.out.println(user1);\r\n根据Bean的类型获取实例\r\n// 方式二：根据Bean的类型获取实例User user2 = (User) context.getBean(User.class);System.out.println(user2);\r\n根据Bean的id和类型获取实例\r\n//方式三：根据Bean的id和类型获取实例User user3 = context.getBean(&quot;user&quot;, User.class);System.out.println(user3);\r\n输出都是一样的\r\n/** * UserTest类用于演示通过XML配置文件进行Spring IOC（Inverse of Control）的简单示例。 */package com.sakurapaid.spring.iocxml; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserTest &#123;    /**     * 主函数入口，演示了三种方式从Spring容器中获取Bean实例。     */    public static void main(String[] args) &#123;        // 创建Spring容器，使用ClassPathXmlApplicationContext加载名为&quot;bean.xml&quot;的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);         // 方式一：根据Bean的id获取实例        User user1 = (User) context.getBean(&quot;user&quot;);        System.out.println(user1);         // 方式二：根据Bean的类型获取实例        User user2 = (User) context.getBean(User.class);        System.out.println(user2);         // 方式三：根据Bean的id和类型获取实例        User user3 = context.getBean(&quot;user&quot;, User.class);        System.out.println(user3);    &#125;&#125;// 输出/*com.ergoutree.User@48793befcom.ergoutree.User@48793befcom.ergoutree.User@48793bef*/\r\n在传统的编程方式中，我们通常需要在代码中通过 new\r\n关键字创建对象实例，同时还需要手动管理对象之间的依赖关系。然而，在这段Spring的IoC示例中：\r\n我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：\r\n通过 ClassPathXmlApplicationContext 加载了名为 “bean.xml”\r\n的Spring配置文件，这个配置文件中定义了Bean（这里是 User\r\n类的实例）的创建方式和依赖关系。\r\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);\r\n然后，我们通过三种不同的方式从Spring容器中获取 User 类的实例：\r\n\r\n直接通过Bean的id（“user”）获取。\r\n根据Bean的类型（User.class）获取唯一匹配的Bean。\r\n同时指定Bean的id和类型获取实例。\r\n\r\n从Spring容器中“取出”装配好的Bean然后使用它\r\n// 获取Bean:UserService userService = context.getBean(UserService.class);// 正常调用:User user = userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);\r\n在以上每步中，都没有直接执行 new User() 来创建对象，而是由Spring\r\nIoC容器负责创建并管理这些对象。这就是所谓的“控制反转”：对象的创建控制权从应用代码转移到了Spring容器，从而实现了对象的生命周期管理、依赖关系注入等高级功能，减少了代码之间的耦合度，增强了系统的可维护性和可扩展性。\r\n注意点\r\n当在Spring的IoC容器中配置了两个相同类型的Bean，会怎么样？\r\n当在Spring的IoC容器中配置了两个相同类型的Bean时，例如：\r\n&lt;bean id=&quot;user1&quot; class=&quot;com.ergoutree.spring.iocxml.User&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.ergoutree.spring.iocxml.User&quot;&gt;&lt;/bean&gt;\r\n这时，如果你试图仅根据类型(User.class)来获取Bean，Spring容器会因为无法确定具体应该返回哪个Bean实例而抛出异常。当Spring容器中存在多个同类型Bean定义时，若仅根据类型来查找，容器无法唯一确定应该返回哪一个Bean实例，因为按照类型查找期望得到的是唯一的匹配Bean。\r\n如果需要根据类型获取Bean，需要确保容器中对应类型的Bean只有一个，或者通过Bean的id来明确指定要获取的Bean。\r\n\r\n\r\n如果一个实现类实现了接口，根据接口类型可以获取 bean\r\n吗？\r\n\r\nUserDao 接口\r\npublic interface UserDao &#123;    public void test();&#125;\r\nUserDaoImpl 实现类\r\npublic class UserDaoImpl implements UserDao &#123;    @Override    public void test()&#123;        System.out.println(&quot;UserDao01 test&quot;);    &#125;&#125;\r\nUserTest 添加\r\nUserDao bean = context.getBean(UserDao.class);        System.out.println(bean);        bean.test();\r\n最后运行抛出异常 因为 bean.xml 中没有进行配置\r\nException in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#x27;com.ergoutree.interf.UserDao&#x27; available\r\n因为UserDao是一个接口，接口是不能有自己的对象，只能由实现它的类userDaoImp01来创建对象，所以下面\r\n&lt;bean id=&quot;userDaoImp01&quot;   class=&quot;com.sakurapaid.spring.iocxml.interf.UserDaoImp01&quot;&gt;&lt;/bean&gt;\r\n&lt;bean&gt; 元素是用来声明和定义Spring\r\nIoC容器中托管的一个Bean实例。\r\nid=“userDaoImp01”：这部分指定了在Spring容器中的Bean的唯一标识符，通过这个ID，你可以从容器中获取或引用这个Bean实例。\r\nclass=\"com.sakurapaid.spring.iocxml.interf.UserDaoImp01\"：这部分定义了Bean的实现类，即当\r\nSpring 容器创建这个Bean 时，会使用这个类的信息来生成 Bean\r\n的实例。尽管UserDao是个接口，但在实际应用中，我们需要通过其实现类UserDaoImp01\r\n来创建对象，因为接口不能实例化，只有具体的实现类才能生成对象实例。\r\n此配置意味着Spring IoC容器将在启动时根据 UserDaoImp01\r\n类的无参构造函数来创建一个Bean实例，并将其注册到容器中，之后在任何需要\r\nUserDao 接口的地方，都可以通过 Spring 容器自动注入或通过 getBean\r\n方法根据 Bean 的 ID（这里是”userDaoImp01”）来获取到这个实现了 UserDao\r\n接口的具体实例。这就是Spring框架中的依赖注入（DI）机制。\r\n所以回答最上面的问题，如果就一个实现类实现了接口，根据接口类型可以获取\r\nbean 吗？\r\n是的，如果只有一个实现类实现了接口，并且这个实现类已经在Spring的IoC容器中配置为一个Bean，那么根据接口类型是可以成功获取到对应的Bean实例的。\r\n前提条件：\r\n\r\n实现类已经在Spring配置文件（如：bean.xml）中被正确配置为一个Bean。\r\n配置时指定了实现类的全限定名作为class属性的值。\r\n在IoC容器中根据接口类型获取Bean时，容器中没有其他同样实现了该接口的Bean定义，即接口的实现类在容器中是唯一的。\r\n\r\n\r\n\r\n如果一个接口有多个实现类，这些实现类都配置了\r\nbean，根据接口类型可以获取 bean 吗？\r\n\r\n不可以，如果一个接口有多个实现类，并且这些实现类都被配置成了Spring容器中的Bean，那么直接根据接口类型来获取Bean将会抛出NoUniqueBeanDefinitionException异常，因为Spring容器无法确定应该返回哪个Bean实例。\r\n例如，有两个实现类UserDaoImp01和UserDaoImp02都实现了UserDao接口，并且都在Spring配置文件中配置为Bean：\r\n&lt;bean id=&quot;userDaoImp01&quot; class=&quot;com.ergoutree.interf.UserDaoImp01&quot;/&gt;&lt;bean id=&quot;userDaoImp02&quot; class=&quot;com.ergoutree.interf.UserDaoImp02&quot;/&gt;\r\n相当于在Spring的IoC容器中配置了两个相同类型的Bean\r\n依赖注入之 setter 注入\r\n总体结构\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n创建学生类Student\r\npublic class Student &#123;    private String name;    private int age;        public Student() &#123;&#125;     public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;     public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;     public int getAge() &#123;        return age;    &#125;     public void setAge(int age) &#123;        this.age = age;    &#125;     public String toString() &#123;        return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;&#125;&quot;;    &#125;&#125;\r\nbean-di.xml 配置文件\r\n这里的******元素对应于****Student****类中的setter方法**\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置student的name属性为&quot;ergoutree&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;ergoutree&quot;&gt; &lt;/property&gt;        &lt;!-- 设置student的age属性为18 --&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt; &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试类\r\n当Spring容器读取并解析bean-di.xml配置文件时，会创建一个Student实例，并通过调用对应的setter方法（setName\r\n和setAge），将值”ergoutree”注入到name属性，将值18注入到age属性，从而完成依赖注入。\r\npublic class StudentTest &#123;    @Test    public void test() &#123;        // 创建ClassPathXmlApplicationContext实例，并加载名为&quot;bean-di.xml&quot;的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        // 通过上下文对象获取名为&quot;student&quot;的Bean实例，其类型为Student类        Student student = context.getBean(&quot;student&quot;, Student.class);        // 打印学生对象的信息        System.out.println(student);    &#125;&#125;\r\n\r\n\r\n依赖注入之构造器注入\r\n在Student类中添加有参构造\r\npublic Student(String name) &#123;&#125;\r\n配置bean-di.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置student的name属性为&quot;ergoutree&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;ergoutree&quot;&gt; &lt;/property&gt;        &lt;!-- 设置student的age属性为18 --&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt; &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;studentcon&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 通过构造器参数name传入值&quot;ergou&quot; --&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;ergou&quot;&gt; &lt;/constructor-arg&gt;        &lt;!-- 通过构造器参数age传入值&quot;19&quot; --&gt;        &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt; &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n这里使用了&lt;constructor-arg&gt;标签来指定构造函数的参数。根据注释，我们知道\r\nStudent\r\n类应该有一个带有两个参数（name和age）的构造函数，类似于下面的Java代码：\r\npublic class Student &#123;    private String name;    private int age;     // 构造函数注入    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    // 省略其他代码...&#125;\r\nconstructor-arg标签还有两个属性可以进一步描述构造器参数：\r\nindex属性：指定参数所在位置的索引（从0开始）\r\nname属性：指定参数名\r\n测试方法\r\n@Test    public void test2() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        // 通过上下文对象获取名为&quot;student&quot;的Bean实例，其类型为Student类        Student student = context.getBean(&quot;studentcon&quot;, Student.class);        // 打印学生对象的信息        System.out.println(student);    &#125;\r\n当Spring容器加载并解析XML配置文件时，它会找到studentcon这个bean，并根据&lt;constructor-arg&gt;标签提供的信息，调用\r\nStudent\r\n类的相应构造函数，传入”ergou”作为name参数，传入19作为age参数，从而创建并初始化Student实例。\r\n最终，通过context.getBean(\"studentcon\", Student.class)获取到了通过构造器注入生成的Student实例，并将其打印出来。\r\n特殊值处理\r\n某些XML配置片段在Spring框架中的意义\r\n\r\n字面量赋值\r\n\r\n&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;\r\n在Spring的XML配置中，&lt;property&gt;标签是用来设置Bean属性值的。这里的value=\"张三\"就是将字面量“张三”赋给名为”name”的属性。这意味着当你在Bean中引用该属性时，它的值就是字符串”张三”，而不是一个变量或者表达式的结果。\r\n\r\n设置null值\r\n\r\n&lt;property name=&quot;name&quot;&gt;    &lt;null /&gt;&lt;/property&gt;\r\n这种方式是用来给Bean的属性设置 null\r\n值的。与直接使用value=\"null\"不同，后者会被当作字符串”null”而非实际的Java\r\nnull值处理。\r\n&lt;null /&gt;标签告诉Spring容器将此属性值设为空引用。\r\n注意下面的这样写法\r\n&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;\r\n这样的写法，为name所赋的值是字符串null\r\n\r\nXML实体\r\n\r\n&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;\r\n在XML中，“&lt;” 和 “&gt;”\r\n等特殊字符有特殊的含义，它们分别表示标签的开始和结束。如果你想在属性值中包含这样的字符，需要使用XML实体来转义。\r\n例如，XML实体如 &amp;lt 代替小于号 &lt;\r\n，这样解析器就会知道这是一个小于符号，而不是标签的起始。XML实体如\r\n&amp;gt代替大于号 &gt;\r\n\r\nCDATA节\r\n\r\nCDATA(Characters\r\nData)是一种在XML文档中嵌入大段文本的方式，其中的内容不会被XML解析器解析为标记或实体。在这里，如果你的属性值可能包含大量的特殊字符或者需要包含XML语法结构，为了防止解析错误，可以将这部分内容放在&lt;![CDATA[ ... ]]&gt;之中。因此，&lt;![CDATA[a &lt; b]]&gt;意味着a&lt; b被当作纯文本对待，里面的\r\n\"&lt;\"字符不会被解析成标签开始。\r\n为对象类型属性赋值\r\n示例\r\n准备工作\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n部门类\r\npackage com.ergoutree.diobj;public class Department &#123;    private String name;    public void sout() &#123;        System.out.println(&quot;部门名: &quot; + name);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\r\n员工类\r\npackage com.ergoutree.diobj;public class Employee &#123;    private Department department;    private String name;    private int age;    public void work() &#123;        System.out.println(&quot;员工: &quot; + name + &quot;，年龄: &quot; + age);        department.sout();    &#125;    public Department getDepartment() &#123;        return department;    &#125;    public void setDepartment(Department department) &#123;        this.department = department;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\r\n引用外部bean，配置 bean-diobj.xml\r\n&lt;property name=\"department\" ref=\"department\"/&gt;这一行表示：当Spring容器初始化\r\n“employee” 这个 Bean\r\n时，会自动查找ID为”department”的Bean，并将该Bean的实例注入到 Employee\r\n类的 department 属性上，实现了依赖注入。\r\n   &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;   &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;       &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;       &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;   &lt;/bean&gt;&lt;!--外部bean使用ref指定依赖所注入的对象--&gt;   &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;   &lt;bean id=&quot;employee&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;       &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;       &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;       &lt;!-- 设置员工年龄为 20 --&gt;       &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;       &lt;!--通过ref属性指定依赖注入的对象--&gt;       &lt;!-- 将该员工所属部门设置为 &quot;department&quot;，实现依赖注入 --&gt;       &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;   &lt;/bean&gt;\r\n测试输出\r\n在测试类EmployeeTest中，我们通过Spring应用上下文加载XML配置文件，然后获取”employee”这个Bean的实例，并调用其work方法。由于依赖注入已经完成，此时调用employee.work()方法时，不仅会输出员工的基本信息，还会通过注入的department对象输出部门名称。\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;employee&quot;, Employee.class);        employee.work();    &#125;&#125;\r\n总结起来，这种引用外部 bean 的方式就是在配置文件中通过 ref\r\n属性指定了依赖对象，Spring\r\n容器负责自动装配这些依赖关系，使得类之间的耦合度降低，提高了程序的可维护性和灵活性。\r\n内部bean\r\n内部bean（Inner\r\nBean）是在Spring配置文件中直接定义并初始化的一个Bean，它不是顶级Bean（Root\r\nBean），而是作为另一个Bean的属性值出现。在给出的示例中，我们展示了如何通过内部bean的方式来注入Employee类的department属性。\r\n在bean配置上和内部bean有所区别，但能达到一样的效果\r\n在XML配置文件中，对于employee2这个Bean的定义，我们不再通过ref属性引用已经定义好的外部Bean，而是直接在其department属性内部定义一个新的Department\r\nBean。\r\n这里的新Department\r\nBean没有显式定义ID，因为它是一个内部Bean，由Spring容器自动生成一个唯一的ID。同时，它拥有自己的属性设置，如name属性被设置为”开发部”。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;!--外部bean方式--&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;employee1&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;    &lt;/bean&gt;        &lt;!--内部bean方式--&gt;    &lt;bean id=&quot;employee2&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot;&gt;               &lt;bean class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;                   &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;               &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;  &lt;/beans&gt;\r\n当Spring容器加载配置文件并初始化 employee2 这个Bean时，它会发现\r\ndepartment 属性需要注入一个 Department 类型的 Bean\r\n。于是，它会在当前上下文中查找匹配的 Bean 定义，发现内部定义的\r\nDepartment Bean，然后创建并初始化这个内部 Bean，并将其实例注入到\r\nemployee2 的 department 属性上。\r\n在测试类 EmployeeTest 中，我们仅获取并操作了使用内部 bean 方式注入的\r\nEmployee 实例（employee2），同样能够达到与外部 bean\r\n方式相同的效果，即输出员工基本信息以及所属部门名称。\r\n内部 bean 方式的优势在于可以在同一个配置块内清晰地展示和组织 Bean\r\n之间的依赖关系，简化配置文件结构。但在某些场景下，如果某个 Bean\r\n会被多个其他 Bean 共享，使用外部 bean 并通过 ref 引用则更为合适。\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;employee2&quot;, Employee.class);        employee.work();    &#125;&#125;\r\n级联属性赋值\r\n不常用\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;!--外部bean方式--&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;employee1&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;    &lt;/bean&gt;        &lt;!--内部bean方式--&gt;    &lt;bean id=&quot;employee2&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot;&gt;               &lt;bean class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;                   &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;               &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!--级联属性赋值--&gt;    &lt;bean id=&quot;department3&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;employee3&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!-- 级联属性赋值，直接为 employee3 的属性赋值 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;department3&quot;/&gt;        &lt;property name=&quot;department.name&quot; value=&quot;测试部&quot;/&gt;    &lt;/bean&gt; &lt;/beans&gt;\r\n级联属性赋值是针对对象类型属性的进一步操作，当一个 Bean\r\n的属性是另一个对象类型时，我们不仅可以为这个对象属性赋值，还可以直接为该对象属性的内部属性进行赋值。\r\n在单独的 &lt;bean&gt;标签中，把 bean 对象所依赖的类通过\r\n&lt;property&gt; 中标出，也是使用 ref\r\n级联属性赋值时，要确保被赋值的对象属性已经正确实例化\r\n级联属性赋值的优先级高于直接在被引用的 Bean\r\n中设置的属性值，即后配置的值会覆盖前面已配置的值。\r\n\r\n为数组类型属性赋值\r\n修改Employee员工类\r\n主要是新增了数组成员和及其输出\r\npublic class Employee &#123;    private Department department;    private String name;    private int age;    private String[] hobby;    public Employee() &#123;&#125;    public Employee(Department department, String name, int age, String[] hobby) &#123;        this.department = department;        this.name = name;        this.age = age;        this.hobby = hobby;    &#125;    public void work() &#123;        System.out.println(&quot;员工: &quot; + name + &quot;，年龄: &quot; + age);        department.sout();        // 遍历数组        System.out.println(Arrays.toString(hobby));    &#125;    public Department getDepartment() &#123;        return department;    &#125;    public void setDepartment(Department department) &#123;        this.department = department;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String[] getHobby() &#123;        return hobby;    &#125;    public void setHobby(String[] hobby) &#123;        this.hobby = hobby;    &#125;    public String toString() &#123;        return &quot;Employee&#123;department = &quot; + department + &quot;, name = &quot; + name + &quot;, age = &quot; + age + &quot;, hobby = &quot; + hobby + &quot;&#125;&quot;;    &#125;&#125;\r\n编辑 spring 配置文件\r\n&lt;property&gt;标签用于设置 Employee\r\n类中对应的属性值。对于数组类型的\"hobby\"属性，我们使用了&lt;array&gt;标签来进行嵌套注入。在&lt;array&gt;标签内部，通过多个&lt;value&gt;标签来分别指定数组中的每个元素值。\r\n所以当Spring容器创建\"employee\"这个 Bean\r\n时，它会自动将这些值注入到 Employee 对象的 “hobby”\r\n数组属性中，最终得到的数组内容即为 [“吃饭”, “睡觉”, “打gal”] 。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;    &lt;bean id=&quot;employee&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置员工年龄为 20 --&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!--通过ref属性指定依赖注入的对象--&gt;        &lt;!-- 将该员工所属部门设置为 &quot;department&quot;，实现依赖注入 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;                &lt;property name=&quot;hobby&quot;&gt;            &lt;array&gt;                &lt;value&gt;吃饭&lt;/value&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;打gal&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试输出\r\n\r\n\r\nimage-20250420202752367\r\n\r\n\r\n\r\nimage-20250420202752367\r\n\r\n\r\n为集合类型属性赋值\r\n为 List 集合类型属性赋值\r\n修改Department部门类\r\n多了个List集合，一个部门有很多人，再定义个输出方法\r\nimport java.util.List;public class Department &#123;    //一个部门有很多人    private List&lt;Employee&gt; employees;    //部门名称    private String name;    public void sout() &#123;        System.out.println(&quot;部门名: &quot; + name);        for (Employee emp : employees)&#123;            System.out.println(emp.getName());        &#125;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public List&lt;Employee&gt; getEmployees() &#123;        return employees;    &#125;    public void setEmployees(List&lt;Employee&gt; employees) &#123;        this.employees = employees;    &#125;&#125;\r\n定义 Spring 配置文件\r\n两个员工 bean 和一个部门 bean\r\n在 XML 配置文件中，首先定义了两个 Employee 类型的\r\nBean（emp1和emp2），它们分别具有不同的属性值，包括名字、年龄和兴趣爱好列表（hobby）。这里的\r\nhobby\r\n属性是一个列表类型，使用&lt;list&gt;标签进行配置，通过多个&lt;value&gt;子标签为列表添加元素。\r\n然后，定义了一个 Department 类型的\r\nBean（dept），它具有一个名字属性和一个 employees 集合属性。employees\r\n属性也是一个列表类型，用于存放 Department 下的多个 Employee\r\n对象。这里使用&lt;list&gt;标签，并通过&lt;ref&gt;子标签引用前面定义好的\r\nEmployee Bean（emp1和emp2），从而将这两个 Employee 对象注入到 Department\r\n的 employees 集合属性中。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;    &lt;bean id=&quot;emp1&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置员工年龄为 20 --&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!--通过ref属性指定依赖注入的对象--&gt;        &lt;!-- 将该员工所属部门设置为 &quot;dept&quot;，实现依赖注入 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;dept&quot;/&gt;        &lt;property name=&quot;hobby&quot;&gt;            &lt;array&gt;                &lt;value&gt;吃饭&lt;/value&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;打gal&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 定义另一个员工对象，员工2 --&gt;    &lt;bean id=&quot;emp2&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 员工的名字 --&gt;        &lt;property name=&quot;name&quot; value=&quot;Lucy&quot; /&gt;        &lt;!-- 员工的年龄 --&gt;        &lt;property name=&quot;age&quot; value=&quot;21&quot; /&gt;        &lt;!-- 员工的爱好，以列表形式 --&gt;        &lt;property name=&quot;hobby&quot;&gt;            &lt;list&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;学习&lt;/value&gt;                &lt;value&gt;吃饭&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 定义一个部门对象 --&gt;    &lt;bean id=&quot;dept&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 部门的名字 --&gt;        &lt;property name=&quot;name&quot; value=&quot;财政部&quot; /&gt;        &lt;!-- 部门下的员工列表 --&gt;        &lt;property name=&quot;employees&quot;&gt;            &lt;list&gt;                &lt;!-- 引用员工1对象 --&gt;                &lt;ref bean=&quot;emp1&quot; /&gt;                &lt;!-- 引用员工2对象 --&gt;                &lt;ref bean=&quot;emp2&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试输出\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;emp1&quot;, Employee.class);        employee.work();        Department dept = context.getBean(&quot;dept&quot;, Department.class);        dept.sout();    &#125;&#125;\r\n\r\n\r\nimage-20250420203805345\r\n\r\n\r\n\r\nimage-20250420203805345\r\n\r\n为Map集合类型赋值\r\n修改 student 类，添加一个 Map\r\n类型的属性，用于存储学生的课程和对应的成绩\r\npackage com.ergoutree.di;import java.util.Map;public class Student &#123;    private String name;    private int age;    private Map&lt;String, Integer&gt; scores;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student(String name) &#123;&#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Map&lt;String, Integer&gt; getScores() &#123;        return scores;    &#125;    public void setScores(Map&lt;String, Integer&gt; scores) &#123;        this.scores = scores;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, scores=&quot; + scores + &quot;&#125;&quot;;    &#125;&#125;\r\n修改 bean-di.xml\r\n&lt;bean id=&quot;student2&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置学生姓名 --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置学生的成绩 Map --&gt;        &lt;property name=&quot;scores&quot;&gt;            &lt;map&gt;                &lt;!-- 键值对：课程名和对应的成绩 --&gt;                &lt;entry key=&quot;数学&quot; value=&quot;90&quot;/&gt;                &lt;entry key=&quot;英语&quot; value=&quot;85&quot;/&gt;                &lt;entry key=&quot;语文&quot; value=&quot;88&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;\r\n\r\n&lt;map&gt; 标签：用于定义一个\r\nMap 集合，在 标签内部使用 标签来定义\r\nMap 中的键值对。\r\n&lt;entry&gt; 标签：key\r\n属性指定键，value\r\n属性指定值。这里的键和值都是基本数据类型（字符串和整数）\r\n键和值的类型：在 &lt;entry&gt;\r\n标签中，key 和 value 属性的值会根据 Bean\r\n属性的类型自动进行类型转换。如果键或值是复杂对象，你可以使用\r\nkey-ref 和 value-ref 引用其他 Bean。\r\n\r\n测试\r\n@Test    public void test3() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        Student student = context.getBean(&quot;student2&quot;, Student.class);        System.out.println(student);    &#125;// 输出// Student&#123;name=&#x27;张三&#x27;, scores=&#123;数学=90, 英语=85, 语文=88&#125;&#125;\r\n引用集合类型的 bean\r\n修改学生类\r\n新增一个 List 集合，管理课程\r\npackage com.ergoutree.di;import java.util.*;public class Student &#123;    private String name;    private int age;    private Map&lt;String, Integer&gt; scores;    private int stu_id;    private List&lt;Lesson&gt; listLessons;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void sout()&#123;        // 输出学生的基本信息        System.out.println(&quot;学生id : &quot; + stu_id + &quot;, &quot; +                &quot;学生姓名 : &quot; + name);        System.out.println();        // 输出课程集合        System.out.print(&quot;课程集合 : &quot;);        for(Lesson lesson : listLessons)&#123;            System.out.print(lesson.getLessonName() + &quot; &quot;);        &#125;    &#125;    public Student(String name) &#123;&#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Map&lt;String, Integer&gt; getScores() &#123;        return scores;    &#125;    public void setScores(Map&lt;String, Integer&gt; scores) &#123;        this.scores = scores;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, scores=&quot; + scores + &quot;&#125;&quot;;    &#125;&#125;\r\n对应的Lesson类\r\npublic class Lesson &#123;    private String lessonName;    public String getLessonName() &#123;        return lessonName;    &#125;    public void setLessonName(String lessonName) &#123;        this.lessonName = lessonName;    &#125;&#125;\r\n配置Spring文件\r\n使用util:list、util:map标签必须引入相应的命名空间\r\n代码样式放在上的，需要用时直接复制粘贴即可\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util    http://www.springframework.org/schema/util/spring-util.xsd    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\r\n&lt;bean id=&quot;studentcon&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;!-- 通过构造器参数name传入值&quot;ergou&quot; --&gt;       &lt;constructor-arg name=&quot;name&quot; value=&quot;ergou&quot;&gt; &lt;/constructor-arg&gt;       &lt;!-- 通过构造器参数age传入值&quot;19&quot; --&gt;       &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt; &lt;/constructor-arg&gt;   &lt;/bean&gt;   &lt;bean id=&quot;student2&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;!-- 设置学生姓名 --&gt;       &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;       &lt;!-- 设置学生的成绩 Map --&gt;       &lt;property name=&quot;scores&quot;&gt;           &lt;map&gt;               &lt;!-- 键值对：课程名和对应的成绩 --&gt;               &lt;entry key=&quot;数学&quot; value=&quot;90&quot;/&gt;               &lt;entry key=&quot;英语&quot; value=&quot;85&quot;/&gt;               &lt;entry key=&quot;语文&quot; value=&quot;88&quot;/&gt;           &lt;/map&gt;       &lt;/property&gt;   &lt;/bean&gt;   &lt;bean id=&quot;student3&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;property name=&quot;stu_id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;name&quot; value=&quot;王昊&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;listLessons&quot; ref=&quot;listlessons&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!--新建的lesson bean--&gt;   &lt;bean id=&quot;lesson1&quot; class=&quot;com.ergoutree.di.Lesson&quot;&gt;       &lt;property name=&quot;lessonName&quot; value=&quot;liang_zi_qi&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;bean id=&quot;lesson2&quot; class=&quot;com.ergoutree.di.Lesson&quot;&gt;       &lt;property name=&quot;lessonName&quot; value=&quot;wanghao&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!--课程列表包含bean--&gt;   &lt;util:list id=&quot;listlessons&quot;&gt;       &lt;ref bean=&quot;lesson1&quot;&gt;&lt;/ref&gt;       &lt;ref bean=&quot;lesson2&quot;&gt;&lt;/ref&gt;   &lt;/util:list&gt;\r\n测试\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class MapAndListTest &#123;    @Test    public void test()&#123;        // 加载名为&quot;bean-diMapAndList.xml&quot;的XML配置文件，创建ApplicationContext上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diMapAndList.xml&quot;);        // 从上下文中获取名为&quot;student&quot;的Bean实例，其类型为Student        Student student = context.getBean(&quot;student&quot;, Student.class);        // 调用Student实例的sout方法，输出相关信息        student.sout();    &#125;&#125;\r\n\r\n\r\nimage-20250421163559144\r\n\r\n\r\n\r\nimage-20250421163559144\r\n\r\n\r\n由于篇幅太长，转到 下篇\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework part10-Spring国际化详解","url":"/posts/19023.html","content":"I18n 国际化概述\r\n国际化也称作 i18n ，其来源是英文单词 internationalization 的首末字符\r\ni 和 n ，18为中间的字符数。由于软件发行\r\n可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通\r\n过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。\r\n主要通过分离程序的核心逻辑与语言、区域相关的资源（如文本、日期格式、货币符号等），使程序能适应不同国家\r\n/ 地区的语言和文化习惯。\r\nJava国际化\r\nJava自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法：\r\n/** * This method must be called only for creating the Locale.* * constants due to making shortcuts. */private static Locale createConstant(String lang, String country) &#123;    BaseLocale base = BaseLocale.createInstance(lang, country);    return getInstance(base, null);&#125;\r\nLocale 类\r\n\r\n作用：代表特定的语言和区域（如 zh_CN\r\n表示中文（中国），en_US 表示英文（美国））。\r\n\r\n资源文件（Resource Bundle）\r\n存储不同语言 / 区域的文本数据，文件名格式为\r\nbaseName_languageCode_countryCode.properties（如\r\nmessage_zh_CN.properties）。\r\n配置文件命名规则：\r\n\r\n基础名（baseName）：自定义，如\r\nmessage。\r\n语言代码（languageCode）：遵循 ISO 639-1 标准（如\r\nzh 中文，en 英文）。\r\n国家 / 地区代码（countryCode）：遵循 ISO 3166-1\r\n标准（如 CN 中国，US 美国）。\r\n\r\nbasename_language_country.properties\r\n必须遵循以上的命名规则，java 才会识别。其中，basename\r\n是必须的，语言和国家是可选的。这里存在一个优先级概念，如果同时提供了\r\nmessages.properties 和\r\nmessages_zh_CN.propertes 两个配置文件，如果提供的\r\nlocale\r\n符合en_CN，那么优先查找messages_en_CN.propertes配置文件，如果没查找到，再查找messages.properties配置文件。最后，提示下，所有的配置文件必须放在classpath中，一般放在resources目录下\r\nResourceBundle 类\r\n\r\n作用：加载资源文件并根据 Locale\r\n获取对应语言的文本。\r\n核心方法\r\n\r\nResourceBundle.getBundle(String baseName, Locale locale)：根据基础名和区域加载资源文件。\r\ngetString(String key)：根据键获取对应的值。\r\n\r\n\r\n演示 Java 国际化\r\n创建资源文件\r\n\r\n\r\nimage-20250521171839434\r\n\r\n# message.propertiesgreeting=Hello, Default!welcome=Default welcome message# message_zh_CN.propertiesgreeting=你好，世界！welcome=欢迎使用国际化功能# message_en_US.propertiesgreeting=Hello, World!welcome=Welcome to i18n!\r\n编写 Java 代码演示国际化\r\nimport java.util.Locale;import java.util.ResourceBundle;public class I18nExample &#123;    public static void main(String[] args) &#123;        // 测试中文（中国）        Locale zhCN = Locale.CHINA;        printMessage(zhCN);        // 测试英文（美国）        Locale enUS = Locale.US;        printMessage(enUS);        // 测试未知区域（使用默认资源文件）        Locale frCA = new Locale(&quot;fr&quot;, &quot;CA&quot;); // 法语（加拿大），无对应资源文件        printMessage(frCA);    &#125;    private static void printMessage(Locale locale) &#123;        // 加载资源文件（基础名为 &quot;message&quot;，区域为 locale）        ResourceBundle bundle = ResourceBundle.getBundle(&quot;message&quot;, locale);        String greeting = bundle.getString(&quot;greeting&quot;);        String welcome = bundle.getString(&quot;welcome&quot;);        System.out.println(&quot;===== Locale: &quot; + locale + &quot; =====&quot;);        System.out.println(greeting);        System.out.println(welcome);        System.out.println();    &#125;&#125;\r\n输出\r\n\r\n\r\nimage-20250521171821295\r\n\r\nSpring 中支持国际化\r\nMessageSource接口\r\n加载资源文件并根据Locale提供国际化消息。\r\nspring中国际化是通过MessageSource这个接口来支持的\r\npublic interface MessageSource &#123;     /**     * 获取国际化信息     * @param code 表示国际化资源中的属性名；     * @param args用于传递格式化串占位符所用的运行参数；     * @param defaultMessage 当在资源找不到对应属性名时，返回defaultMessage参数所指定的默认信息；     * @param locale 表示本地化对象     */    @Nullable    String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);     /**     * 与上面的方法类似，只不过在找不到资源中对应的属性名时，直接抛出NoSuchMessageException异常     */    String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException;     /**     * @param MessageSourceResolvable 将属性名、参数数组以及默认信息封装起来，它的功能和第一个方法相同     */    String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException; &#125;\r\n常见实现类\r\n\r\nResourceBundleMessageSource\r\n这个是基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源，需遵循上述的特定文件命名规则。\r\nReloadableResourceBundleMessageSource\r\n这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息，支持资源文件热加载（开发环境实用）。\r\nStaticMessageSource\r\n它允许通过编程的方式提供国际化信息，可以通过这个来实现db中存储国际化信息的功能。\r\n\r\nLocaleResolver 接口\r\n解析用户请求中的Locale信息（如浏览器语言、URL\r\n参数、Cookie 等）。\r\n\r\n常用实现类\r\n\r\nAcceptHeaderLocaleResolver：基于浏览器请求头中的Accept-Language。\r\nSessionLocaleResolver：基于用户会话（Session）存储Locale。\r\nCookieLocaleResolver：基于 Cookie\r\n存储Locale。\r\nFixedLocaleResolver：固定Locale，不动态变化。\r\n\r\n\r\n使用Spring6国际化\r\n创建资源文件\r\n国际化文件命名格式：基本名称 _ 语言 _\r\n国家.properties\r\n\r\n默认文件：messages.properties\r\ngreeting=Hello!welcome=Welcome to Spring i18nwww.ergoutree.com=welcome &#123;0&#125;,时间:&#123;1&#125;\r\n中文文件：messages_zh_CN.properties\r\ngreeting=你好！welcome=欢迎使用Spring国际化www.ergoutree.com=欢迎&#123;0&#125;,时间:&#123;1&#125;\r\n英文文件：messages_en_US.properties\r\ngreeting=Hello!welcome=Welcome to Spring i18nwww.ergoutree.com=welcome &#123;0&#125;,time:&#123;1&#125;\r\n\r\n在 Spring 配置文件中定义MessageSource\r\nBean，指定资源文件位置\r\nbean名称必须为：messageSource\r\n@Configurationpublic class AppConfig &#123;    @Bean    public MessageSource messageSource() &#123;        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();        messageSource.setBasenames(&quot;messages&quot;); // 资源文件基础名（无需扩展名）        messageSource.setDefaultEncoding(&quot;UTF-8&quot;); // 防止中文乱码        return messageSource;    &#125;&#125;\r\n测试\r\npublic class I18nTest &#123;    public static void main(String[] args) &#123;        // 加载Spring配置        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);                // 获取MessageSource Bean        org.springframework.context.MessageSource messageSource =                 context.getBean(&quot;messageSource&quot;, org.springframework.context.MessageSource.class);                // 测试不同Locale        testLocale(messageSource, Locale.US);      // 英文（美国）        testLocale(messageSource, Locale.CHINA);  // 中文（中国）        testLocale(messageSource, new Locale(&quot;fr&quot;)); // 法语（无对应文件，使用默认）    &#125;        private static void testLocale(org.springframework.context.MessageSource messageSource, Locale locale) &#123;        System.out.println(&quot;=== Locale: &quot; + locale + &quot; ===&quot;);                // 普通消息        String greeting = messageSource.getMessage(&quot;greeting&quot;, null, locale);        String welcome = messageSource.getMessage(&quot;welcome&quot;, null, locale);                // 带参数的消息        String paramMessage = messageSource.getMessage(            &quot;www.ergoutree.com&quot;,             new Object[]&#123;&quot;Alice&quot;, new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date())&#125;,             locale        );                System.out.println(greeting);        System.out.println(welcome);        System.out.println(paramMessage);        System.out.println();    &#125;&#125;\r\n配置 LocaleResolver\r\n以SessionLocaleResolver为例（存储Locale到\r\nSession）：\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Bean    public LocaleResolver localeResolver() &#123;        SessionLocaleResolver slr = new SessionLocaleResolver();        slr.setDefaultLocale(Locale.US); // 默认Locale        return slr;    &#125;&#125;\r\n配置 LocaleChangeInterceptor\r\n允许通过 URL\r\n参数（如?lang=en）切换Locale：\r\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();        interceptor.setParamName(&quot;lang&quot;); // URL参数名        registry.addInterceptor(interceptor);    &#125;&#125;\r\n监控国际化文件的变化\r\n在 Spring\r\n框架中，ReloadableResourceBundleMessageSource类是ResourceBundleMessageSource的增强版本，支持动态监控资源文件的变化，无需重启应用即可生效。这在开发和测试环境中特别有用。\r\n用ReloadableResourceBundleMessageSource这个类，功能和上面案例中的ResourceBundleMessageSource类似，不过多了个可以监控国际化资源文件变化的功能，有个方法用来设置缓存时间：\r\npublic void setCacheMillis(long cacheMillis)\r\n\r\n-1：表示永远缓存\r\n0：每次获取国际化信息的时候，都会重新读取国际化文件\r\n大于0：上次读取配置文件的时间距离当前时间超过了这个时间，重新读取国际化文件\r\n\r\n还有个按秒设置缓存时间的方法setCacheSeconds，和setCacheMillis类似\r\n@Configurationpublic class AppConfig &#123;    @Bean    public MessageSource messageSource() &#123;        ReloadableResourceBundleMessageSource messageSource =             new ReloadableResourceBundleMessageSource();                // 设置资源文件基础名（无需扩展名）        messageSource.setBasenames(&quot;classpath:messages&quot;);                // 设置编码，防止中文乱码        messageSource.setDefaultEncoding(&quot;UTF-8&quot;);                // 设置缓存时间（开发环境建议设为0，生产环境可设为较长时间如60秒）        messageSource.setCacheSeconds(0); // 每次请求都重新加载                return messageSource;    &#125;&#125;\r\n测试\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ReloadableResourceBundleMessageSource;import java.util.Locale;import java.util.concurrent.TimeUnit;public class ReloadableI18nTest &#123;    public static void main(String[] args) throws Exception &#123;        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);        ReloadableResourceBundleMessageSource messageSource =             context.getBean(&quot;messageSource&quot;, ReloadableResourceBundleMessageSource.class);                // 初始加载        printMessage(messageSource);                // 修改messages_zh_CN.properties文件内容（手动操作）        System.out.println(&quot;\\n&gt;&gt;&gt; 请在5秒内修改messages_zh_CN.properties文件内容... &lt;&lt;&lt;\\n&quot;);        TimeUnit.SECONDS.sleep(5);                // 再次加载（如果缓存时间为0，将显示最新内容）        printMessage(messageSource);    &#125;        private static void printMessage(ReloadableResourceBundleMessageSource messageSource) &#123;        Locale zhCN = Locale.CHINA;        System.out.println(&quot;当前缓存时间: &quot; + messageSource.getCacheMillis() + &quot;ms&quot;);        System.out.println(&quot;greeting: &quot; + messageSource.getMessage(&quot;greeting&quot;, null, zhCN));    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework part3-IoC基于XML管理Bean下篇","url":"/posts/55768.html","content":"接着上篇进行\r\n\r\np 命名空间\r\n引入 p 命名空间\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util       http://www.springframework.org/schema/util/spring-util.xsd       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\r\n引入p命名空间后，可以通过以下方式为bean的各个属性赋值\r\n&lt;!-- p命名空间方式 --&gt;    &lt;bean id=&quot;student1&quot; class=&quot;com.ergoutree.di.Student&quot;          p:stu_id=&quot;1411&quot; p:name=&quot;李四&quot; p:listLessons-ref=&quot;lesson1&quot; p:mapTeachers-ref=&quot;mapTeachers&quot;&gt;    &lt;/bean&gt;\r\n测试后依旧成立\r\n\r\n引入外部属性文件\r\n在Spring框架中，引入外部属性文件是一种管理应用程序配置的有效方法。当我们在Spring的\r\nXML\r\n配置文件中直接编写大量的固定配置信息（如数据库用户名、密码、URL，或是服务器IP地址、端口号等），这些信息如果频繁变动，将会使得配置文件变得难以维护，而且每当配置信息发生变化时，开发人员就需要打开源代码去修改XML配置文件，然后再重新打包部署项目，这是一个繁琐的过程。\r\n为了解决这个问题，Spring\r\n支持将这些容易变化的配置项提取出来，存放在单独的 properties\r\n文件中，如database.properties 或 application.properties\r\n。这些文件通常包含键值对的形式，例如\r\ndatabase.properties文件\r\ndb.username=admindb.password=secretpassworddb.url=jdbc:mysql://localhost:3306/mydatabase\r\n接下来，在Spring的XML配置文件中，我们可以使用PropertyPlaceholderConfigurer（在较旧版本中）或&lt;context:property-placeholder&gt;（在Spring\r\n3.1及以上版本推荐使用）来引入和解析这些外部属性文件：\r\n&lt;!-- Spring 3.1+ 使用context命名空间简化引入 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;...&quot;&gt;          &lt;!-- 引入外部属性文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;    &lt;!-- 使用外部属性文件中的值注入Bean --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;       &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;       &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;\r\n这样一来，当数据库的连接信息需要变更时，我们只需要修改database.properties文件，而不需要碰触到Spring的XML配置文件或Java代码。这样既实现了配置的模块化，又增强了配置的可维护性，同时降低了因配置变更导致的应用程序整体重新部署的频率。\r\n此外，这种模式还可以方便地根据不同的环境（如开发、测试、生产）切换不同的配置文件，实现灵活部署。\r\n\r\nbean作用域/生命周期\r\n作用域\r\n在Spring框架中，Bean（Java对象）的作用域指的是在应用程序的整个生命周期中，对于某个特定的Bean对象，Spring容器是如何管理和创建其实例的。Bean\r\n的作用域决定了容器在何时以及如何创建Bean实例，以及这些实例之间的关系。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n取值\r\n含义\r\n创建对象\r\n\r\n\r\n\r\n\r\nsingleton（默认）单实例\r\n在IOC容器中，这个bean的对象始终为单实例\r\nIOC容器初始化时\r\n\r\n\r\nprototype 多实例\r\n这个bean在IOC容器中有多个实例\r\n获取bean时\r\n\r\n\r\n\r\n如果实在 WebApplicationContext 环境下还有几个作用域\r\n\r\n\r\n\r\n取值\r\n含义\r\n\r\n\r\n\r\n\r\nrequest\r\n在一个请求范围内有效\r\n\r\n\r\nsession\r\n在一个会话范围内有效\r\n\r\n\r\n\r\nsingleton 作用域：\r\n\r\n含义：当指定一个Bean为singleton时，Spring容器会在启动时创建该Bean的一个实例，并在整个容器的生命周期内，任何对该Bean的请求都将返回同一个共享的实例。这意味着不论有多少个地方请求该Bean，始终只会有一个Bean实例存在。\r\n创建对象的时机：\r\nSpring容器在初始化时（加载配置文件并创建Bean的过程中），就会创建singleton作用域的Bean实例。\r\n\r\nprototype 作用域：\r\n\r\n含义：\r\n当指定一个Bean为prototype时，每次客户端请求一个Bean时，Spring容器都会创建一个新的Bean实例，也就是说，每次getBean()方法被调用时都会产生一个新的对象实例。\r\n创建对象的时机：\r\nprototype作用域的Bean实例是在客户端请求时创建的，即每次调用ApplicationContext.getBean()方法请求一个prototype类型的Bean时，Spring容器才会创建新的实例。\r\n\r\n示例：\r\n新建 Order 类\r\npublic class Order &#123;&#125;\r\n新建 bean-scope.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--单实例对象演示 通过 scope 属性配置单实例还是多实例--&gt;    &lt;bean id=&quot;order&quot; class=&quot;com.ergoutree.scope.Order&quot; scope=&quot;singleton&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n新建 TestOrder\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestOrder &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-scope.xml&quot;);        // 单实例对象，输出地址相同        Order order = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order);        Order order2 = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order2);    &#125;&#125;\r\n可以发现输出地址是一样的，单实例对象\r\n然而带上多实例对象，发现并非是一个实例化的对象\r\npublic class TestOrder &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-scope.xml&quot;);        // 单实例对象，输出地址相同        Order order = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order);        Order order2 = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order2);        // 多实例对象        Order order3 = context.getBean(&quot;order2&quot;, Order.class);        System.out.println(order3);        Order order4 = context.getBean(&quot;order2&quot;, Order.class);        System.out.println(order4);    &#125;&#125;\r\n输出结果\r\ncom.ergoutree.scope.Order@7b8b43c7com.ergoutree.scope.Order@7b8b43c7com.ergoutree.scope.Order@44c73c26com.ergoutree.scope.Order@41005828\r\n\r\n生命周期\r\n关于Bean的生命周期：\r\n除了Bean的作用域之外，Bean还有一个完整的生命周期，它包括以下几个阶段：\r\n\r\n实例化（Instantiation）：\r\n\r\n这是Bean生命周期的起点，类似于开始备料，即调用Bean的无参构造函数创建Bean实例。Spring容器通过反射机制找到合适的构造函数并创建Bean对象。\r\n\r\n依赖注入（Dependency Injection，DI）：\r\n\r\n类似于加入必要的调料，Spring容器根据配置信息，通过setter方法、构造函数注入或其他注解方式（如@Autowired）将Bean依赖的其他对象注入到当前Bean中。\r\n\r\nBean的后置处理器（Post Processor Before Initialization）：\r\n\r\n在Bean初始化之前，Spring容器会对Bean进行一系列额外的处理。例如，Spring的BeanPostProcessor接口提供了两个方法postProcessBeforeInitialization()和postProcessAfterInitialization()，在这一步骤中，Spring会调用postProcessBeforeInitialization()方法对Bean进行自定义的预处理。\r\n\r\n初始化（Initialization）：\r\n\r\n此阶段相当于烹饪前的准备工作，如预热烤箱。Spring容器在完成所有依赖注入后，会检查Bean是否实现了InitializingBean接口，若实现了则调用afterPropertiesSet()方法；或者在配置文件中通过init-method属性指定了初始化方法，此时Spring容器会调用该方法对Bean进行初始化。\r\n\r\nBean的后置处理器（Post Processor After Initialization）：\r\n\r\n初始化完成后，Spring容器会调用postProcessAfterInitialization()方法进一步处理Bean。这一阶段可用于在Bean正式投入使用前进行一些补充性的定制化工作。\r\n\r\n使用（Use）：\r\n\r\n到了这个阶段，Bean就如同完成烹饪的菜肴一样，已经准备好供客户（应用程序）使用。通过Spring容器的getBean()方法，可以在应用程序中任意位置获取并使用这个Bean实例。\r\n\r\n销毁（Destruction）：\r\n\r\n当Bean不再需要时，比如应用程序关闭或容器被销毁时，Spring容器会触发Bean的销毁过程。如果Bean实现了DisposableBean接口，则调用destroy()方法；或者在配置文件中通过destroy-method属性指定了销毁方法，Spring容器会调用该方法释放资源，如关闭数据库连接、清除缓存等，这就好比客人用餐结束后清理餐具、打扫卫生。\r\n\r\nIOC容器关闭：\r\n\r\n当整个IoC容器需要关闭时，所有处于singleton作用域的Bean都会经历销毁阶段，以确保相关资源得到妥善释放，整个容器生命周期结束。\r\n\r\n\r\n总的来说，在Spring框架中，Bean的作用域是指Bean实例的创建策略，而生命周期则是指Bean实例从创建到销毁的过程。通过理解并合理配置Bean的作用域和生命周期，可以更好地管理和控制Bean实例的行为，提高应用效率和资源利用率。\r\n示例：\r\n创建 Applyskd 类\r\npublic class Applyskd &#123;    private String name;    //初始化方法    public void init() &#123;        System.out.println(&quot;生命周期：3、初始化~&quot;);    &#125;    //销毁方法    public void destroy() &#123;        System.out.println(&quot;生命周期：5、销毁~&quot;);    &#125;    public Applyskd() &#123;        System.out.println(&quot;生命周期：1、创建对象~&quot;);    &#125;    public Applyskd(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;生命周期：2、依赖注入~&quot;);        this.name = name;    &#125;    public String toString() &#123;        return &quot;User&#123;name = &quot; + name + &quot;&#125;&quot;;    &#125;&#125;\r\n创建 xml 配置文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个名为&quot;user&quot;的Bean，对应于com.ergoutree.liferoutine.Applyskd类 --&gt;    &lt;!-- 该Bean的生命周期由Spring容器管理 --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.ergoutree.liferoutine.Applyskd&quot;          scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;sakura&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 注解解释：    id属性：为Bean定义一个唯一标识符；    class属性：指定Bean的实现类；    scope属性：定义Bean的作用域，此处为&quot;singleton&quot;，表示该Bean在容器中只存在一个实例；    init-method属性：指定Bean初始化时要执行的方法，此处为&quot;init&quot;；    destroy-method属性：指定Bean销毁时要执行的方法，此处为&quot;destroy&quot;。 --&gt;&lt;/beans&gt;\r\n测试结果\r\npublic class Test &#123;    @org.junit.jupiter.api.Test    public void test() &#123;        //想要实现bean生命周期的销毁，需要使用ClassPathXmlApplicationContext        //而不是用ApplicationContext，它里面没有destroy方法        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-lifeRoutine.xml&quot;);        Applyskd bean = context.getBean(Applyskd.class);        System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用~&quot;);        bean.destroy();    &#125;&#125;/*生命周期：1、创建对象~生命周期：2、依赖注入~生命周期：3、初始化~生命周期：4、通过IOC容器获取bean并使用~生命周期：5、销毁~*/\r\n\r\n基于 xml 自动装配\r\n自动装配：\r\n\r\n根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值\r\n\r\nSpring 自动装配：\r\n\r\n它能在背后悄悄帮你处理Bean之间的关联关系。当你定义了一些Bean，并告诉Spring使用自动装配时，Spring会在创建这些Bean时，自动找出并填充它们所需要的依赖对象。\r\n打个比方，假设你在装修房子，有电工、木工和油漆工三个工种。如果没有自动装配，你需要亲自安排电工去做电线安装，木工去做家具组装，油漆工去做刷漆工作。而有了自动装配功能，你只需要告诉Spring哪个房间需要装修，Spring会根据每个工人的技能（电工擅长电，木工擅长木工活，油漆工擅长刷漆）自动分配任务，不需要你一一指定谁去做什么。\r\n在Spring中，不同的自动装配策略相当于不同的分工规则，比如按名字找合适的工人（byName）、按工种找合适的工人（byType）等。这样，你就可以更加专注于整体的设计和规划，而无需过于关注每个细小环节的具体实施。\r\n\r\n主要有如下几种自动装配的策略：\r\n\r\nbyName\r\n\r\nSpring容器会根据Bean的属性名查找IoC容器中ID（或name）与该属性名相同的Bean进行注入。\r\nSpring会看你的Bean缺少什么“工具”，然后去查找名字一样的工具。\r\n\r\nbyType:\r\n\r\nSpring容器会查找IoC容器中类型与待注入属性类型匹配的Bean进行注入。如果有多个类型匹配的Bean，则会抛出异常，除非其中一个被标记为主Bean。\r\nSpring会根据你的Bean需要的工具类型，去找仓库里拥有同样类型的工具。\r\n\r\nconstructor\r\n\r\n类似于byType，但专门针对构造函数参数，根据构造函数参数类型查找并注入Bean。\r\n当你创建Bean时，Spring会检查构造函数需要哪些工具，然后自动提供正确的工具。\r\n\r\ndefault / no\r\n\r\n这是默认策略，表示不进行自动装配，所有依赖都需要显式配置。\r\n如果关闭自动装配，那就得你自己一个个地把工具交给Bean。\r\n\r\n\r\n通过启用自动装配功能，Spring可以帮助开发者减少大量手动配置依赖注入的工作，提高开发效率，同时保持代码结构清晰。不过，过度依赖自动装配可能会导致问题不易排查，因此在实际项目中应合理权衡是否使用自动装配以及选择哪种装配策略。\r\n总之，自动装配就是Spring帮你自动完成对象间的依赖关系建立，让你编写代码时更轻松，不过要注意避免因自动装配带来的不确定性，适当地结合显式配置更为稳健。\r\n代码示例：\r\n做一个UserController、UserService、UserDao三层之间的实际场景模拟\r\n创建UserController\r\npublic class UserController &#123;    //生成service层对象    private UserService userService;    //设置service属性set方法    public void setUserService(UserService userService)    &#123;        this.userService = userService;    &#125;    public void conMethod()&#123;        //调用service层方法        userService.setMethod();        System.out.println(&quot;UserController方法执行了~&quot;);    &#125;&#125;\r\n创建 UserDao 接口 和 UserDaoImpl 实现类\r\npublic interface UserDao &#123;    public void method();&#125;\r\npublic class UserDaoImpl implements UserDao &#123;    @Override    public void method() &#123;        System.out.println(&quot;UserDao方法执行了~&quot;);    &#125;&#125;\r\n创建UserService 接口 和 UserServiceImpl 实现类\r\npublic interface UserService &#123;    public void setMethod();&#125;\r\npublic class UserServiceImpl implements UserService &#123;    //生成dao层对象    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void setMethod() &#123;        //调用dao层方法        userDao.method();        System.out.println(&quot;UserService方法执行了~&quot;);    &#125;&#125;\r\n上面的都还是准备工作，现在就实现真正的自动装配\r\n使用bean标签的autowire属性设置自动装配效果\r\n根据类型进行自动装配–byType\r\n若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null\r\n若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常\r\nNoUniqueBeanDefinitionException\r\n配置spring bean xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;controller&quot; class=&quot;com.ergoutree.user.UserController&quot; autowire=&quot;byType&quot;&gt;    &lt;/bean&gt;    &lt;bean id=&quot;service&quot; class=&quot;com.ergoutree.user.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;            &lt;/bean&gt;    &lt;bean id=&quot;dao&quot; class=&quot;com.ergoutree.user.UserDaoImpl&quot; autowire=&quot;byType&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n根据属性名进行自动装配–byName\r\n配置spring bean\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;controller&quot; class=&quot;com.ergoutree.user.UserController&quot; autowire=&quot;byName&quot;&gt;    &lt;/bean&gt;    &lt;bean id=&quot;service&quot; class=&quot;com.ergoutree.user.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;            &lt;/bean&gt;    &lt;bean id=&quot;dao&quot; class=&quot;com.ergoutree.user.UserDaoImpl&quot; autowire=&quot;byName&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试结果\r\nclass autoTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-user.xml&quot;);        UserController controller = (UserController) context.getBean(&quot;controller&quot;);        controller.conMethod();    &#125;&#125;\r\n\r\n\r\nimage-20250422160019960\r\n\r\n\r\n\r\nimage-20250422160019960\r\n\r\nApplicationContext\r\n我们从创建Spring容器的代码：\r\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-user.xml&quot;);\r\n可以看到，Spring容器就是ApplicationContext，它是一个接口，有很多实现类，这里我们选择ClassPathXmlApplicationContext，表示它会自动从classpath（文件管理系统）中查找指定的XML配置文件。\r\n获得了ApplicationContext的实例，就获得了IoC容器的引用。从ApplicationContext中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：\r\nUserService userService = context.getBean(UserService.class);\r\nSpring还提供另一种IoC容器叫BeanFactory，使用方式和ApplicationContext类似\r\nBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));MailService mailService = factory.getBean(MailService.class);\r\nBeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringFrameworkPart4-IoC基于注解管理bean","url":"/posts/29786.html","content":"IoC 基于注解方式操作 Bean\r\n管理\r\n使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。\r\n使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。\r\n我们可以使用Annotation配置\r\n基于注解配置 Bean\r\n在Spring中，基于注解方式配置Bean，主要应用于项目开发中的组件，eg :\r\nController, Service, DAO.\r\n常用的组件注解的形式有——\r\n\r\n@Component :\r\n表示当前注解标识的是一个组件，相当于定义了一个Bean，它有一个可选的名称，默认是mailService，即小写开头的类名。\r\n@Controller :\r\n表示当前注解标识的是一个控制器，通常用于Servlet\r\n@Service :\r\n表示当前注解标识的是一个处理业务逻辑的类，通常用于Service。\r\n@Repository :\r\n表示当前注解标识的是一个持久化层的类，通常用于DAO类。\r\n\r\n应用实例\r\n首先，在已有jar包的基础上，各种依赖\r\n我们依旧根据“Web层调用Service层，Service层调用DAO层”的分层设计思想，分别在web,\r\nservice, dao包下新建PotUserServlet, PotUserServiceImpl,\r\nPotUserDAOImpl类；并在component包下新建一个CyanComponent类\r\nPotUserServlet类代码如下 :\r\n（使用@Controller注解标记）\r\nimport org.springframework.stereotype.Controller;@Controllerpublic class PotUserServlet &#123;&#125;\r\nPotUserServiceImpl类代码如下 :\r\n(使用@Service注解标记)\r\nimport org.springframework.stereotype.Service;@Servicepublic class PotUserServiceImpl &#123;&#125;\r\nPotUserDAOImpl类代码如下 :\r\n(使用@Repository注解标记)\r\nimport org.springframework.stereotype.Repository;@Repositorypublic class PotUserDAOImpl &#123;&#125;\r\n新建一个配置文件beans_annotation.xml，在配置文件中通过context命名空间配置自动扫描，格式如下\r\n&lt;context:component-scan base-package=\"...\"/&gt; 其中\r\n\r\ncontext:component-scan表示配置对指定包的自动扫描，并创建对象到容器；\r\n属性base-package表示被扫描的包；\r\n配置达到的效果是：Spring\r\n容器创建时，就会扫描base-package对应包下所有的用@Controller, @Service, @Repository, @Component注解标记的类，并将其实例化，放入到IOC容器中。\r\n\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.web&quot;/&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.service&quot;/&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.dao&quot;/&gt;&lt;/beans&gt;\r\n接着，新建一个测试类，用于定义进行单元测试的方法。\r\nTestBeanByAnnotation类代码如下\r\n@SpringBootTestclass SpringNoteBeanApplicationTests &#123;    @Test    public void annotationIntro() &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans_annotation.xml&quot;);        /*            PS :            基于注解配置创建的Bean对象，默认id是类名首字母小写。            eg : PotUserServlet类Bean对象的id = potUserServlet.         */        PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);        PotUserServiceImpl potUserServiceImpl = ioc.getBean(&quot;potUserServiceImpl&quot;, PotUserServiceImpl.class);        PotUserDAOImpl potUserDAOImpl = ioc.getBean(&quot;potUserDAOImpl&quot;, PotUserDAOImpl.class);        System.out.println(&quot;potUserServlet = &quot; + potUserServlet);        System.out.println(&quot;potUserServiceImpl = &quot; + potUserServiceImpl);        System.out.println(&quot;potUserDAOImpl = &quot; + potUserDAOImpl);    &#125;&#125;/*输出如下potUserServlet = edu.software.ergoutree.springnotebean.web.PotUserServlet@fe87dddpotUserServiceImpl = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@4eea94a4potUserDAOImpl = edu.software.ergoutree.springnotebean.dao.PotUserDAOImpl@7c281eb */\r\n注意后面@之后的内容\r\n注意事项：\r\n\r\n若想配置自动扫描一个包下所有的子包，可以使用通配符 * 来指定。eg\r\n:&lt;context:component-scan base-package=\"com.cyan.spring.*\"/&gt;，表示会自动扫描com.cyan.spring包下所有的子包。即使不使用通配符\r\n* ，Spring\r\nIOC容器也会默认扫描base-package所指定包的全部子包。\r\n**Spring的IOC容器不能检测一个使用了@Controller注解的类究竟是否为一个控制器（其他注解同理），即注解的名称只是用于程序员自己识别当前标识的组件类型，Spring\r\nIOC容器只要扫描到注解标识的类就会创建其对象，并不会去识别注解的含义。\r\ncontext:component-scan亦可支持只扫描满足特定要求的类，需要用到resource-pattern属性，格式为:\r\nresource-pattern=“特定要求”/&gt;.\r\neg：\r\n表示只扫描com.cyan.spring.web包下的以”Pot”开头的类。\r\nSpring IOC容器还支持扫描时指定过滤某些类 以及\r\n在扫描时指定扫描某些类。\r\n\r\n指定过滤某些类 :\r\n通过&lt;context:exclude-filter/&gt;标签来指定（该标签要放在&lt;context:component-scan&gt;标签内），其中，type属性表示根据什么规则来进行过滤，expression属性则表示具体要过滤的类型。\r\n&lt;!--    (1) context:component-scan表示配置自动扫描，        base-package=&quot;com.cyan.spring&quot;表示扫描com.cyan.spring下的所有子包。    (2) context:exclude-filter表示配置过滤的类，        type=&quot;annotation&quot;表示以注解类型为规则进行过滤，        expression=&quot;org.springframework.stereotype.Service&quot;表示以该注解标记的类会被过滤掉，不会被扫描。--&gt;&lt;context:component-scan base-package=&quot;com.cyan.spring&quot;&gt;    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt;\r\n指定扫描某些类 :\r\n通过&lt;context:include-filter/&gt;标签来指定（该标签要放在&lt;context:component-scan&gt;标签内），其中，type\r\n属性表示根据什么规则来进行扫描，expression\r\n属性则表示具体要扫描的类型。可见，&lt;context:include-filter/&gt;标签\r\n和\r\n上文的&lt;context:exclude-filter/&gt;标签在格式上非常类似，不过需要注意的一点是，&lt;context:include-filter/&gt;标签在使用时还需要在&lt;context:include-filter/&gt;标签中额外标识一个属性use-default-filters=\"false\"，表示不再使用默认扫描机制。\r\n&lt;!--    表示指定扫描com.cyan.spring包及其所有子包下的————使用了@Service注解标记的类。--&gt;&lt;context:component-scan base-package=&quot;com.cyan.spring&quot; use-default-filters=&quot;false&quot;&gt;    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt;\r\n\r\n使用注解标记后，默认情况下所创建的Bean对象的id =\r\n类名首字母小写；但也可以借助注解的value属性手动指定id值，且value可以省略。注解的value属性（注解中定义的方法实际上对应的是注解的属性，而不是传统意义上的方法。），如下图所示\r\n:\r\n\r\n\r\nimg\r\n\r\n我们可以在配置注解时，给出指定的id值\r\n\r\n\r\nimg\r\n\r\n进入Debug界面，在IOC容器的beanFactory –&gt;\r\nsingletonObjects下，可以看到bean对象的id值已经变成了我们在配置@Service注解时给出的value\r\n= “…” 的值。如下图所示 :\r\n\r\n\r\nimg\r\n\r\n\r\n全注解开发\r\n如果完全不使用 XML 来配置 Spring 的 IoC 容器，我们可以使用 Java\r\n配置类来替代。下面是对之前例子的更改\r\n我们保持之前定义的类不变，即\r\nPotUserServlet、PotUserServiceImpl 和\r\nPotUserDAOImpl，这些类依然使用相应的注解进行标记。\r\n// PotUserServlet.javaimport org.springframework.stereotype.Controller;@Controllerpublic class PotUserServlet &#123;&#125;// PotUserServiceImpl.javaimport org.springframework.stereotype.Service;@Servicepublic class PotUserServiceImpl &#123;&#125;// PotUserDAOImpl.javaimport org.springframework.stereotype.Repository;@Repositorypublic class PotUserDAOImpl &#123;&#125;\r\n我们需要创建一个 Java 配置类来替代 beans_annotation.xml\r\n文件。使用 @Configuration\r\n注解标记该类，表示这是一个配置类，使用 @ComponentScan\r\n注解来指定要扫描的包\r\n@Configuration\r\n\r\n作用：该注解用于标记一个类为 Spring\r\n的配置类，类似于 XML 配置文件。配置类中可以定义 Bean\r\n的创建和依赖关系。\r\n\r\n@ComponentScan\r\n\r\n作用：该注解用于指定 Spring 容器要扫描的包，Spring\r\n会自动扫描这些包及其子包下使用\r\n@Controller、@Service、@Repository、@Component\r\n等注解标记的类，并将它们注册为\r\nBean，并根据@Autowired进行装配。\r\n属性\r\n\r\nbasePackages：指定要扫描的包的名称，可以是一个数组，用于指定多个包。\r\nbasePackageClasses：指定要扫描的包下的某个类，Spring\r\n会扫描该类所在的包及其子包。\r\nincludeFilters 和\r\nexcludeFilters：用于指定扫描时的过滤规则，类似于 XML 中的\r\n和。\r\n\r\n\r\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &#123;    &quot;edu.software.ergoutree.springnotebean.web&quot;,    &quot;edu.software.ergoutree.springnotebean.service&quot;,    &quot;edu.software.ergoutree.springnotebean.dao&quot;&#125;)public class AppConfig &#123;&#125;\r\n测试类也需要进行相应的修改，使用\r\nAnnotationConfigApplicationContext 来加载 Java 配置类\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.junit.jupiter.api.Test;public class TestBeanByAnnotation &#123;    @Test    public void annotationIntro() &#123;        // 使用 AnnotationConfigApplicationContext 加载 Java 配置类        // AnnotationConfigApplicationContext\t   //作用：这是一个 Spring 容器的实现类，用于加载 Java 配置类。通过它可以创建一个基于 Java 配置的 Spring 应用上下文。        ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);        PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);        PotUserServiceImpl potUserServiceImpl = ioc.getBean(&quot;potUserServiceImpl&quot;, PotUserServiceImpl.class);        PotUserDAOImpl potUserDAOImpl = ioc.getBean(&quot;potUserDAOImpl&quot;, PotUserDAOImpl.class);        System.out.println(&quot;potUserServlet = &quot; + potUserServlet);        System.out.println(&quot;potUserServiceImpl = &quot; + potUserServiceImpl);        System.out.println(&quot;potUserDAOImpl = &quot; + potUserDAOImpl);    &#125;&#125;\r\n使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：\r\n\r\n每个Bean被标注为@Component并正确使用@Autowired注入；\r\n配置类被标注为@Configuration和@ComponentScan；\r\n所有Bean均在指定包以及子包内。\r\n\r\n使用@ComponentScan非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置AppConfig位于自定义的顶层包（例如com.itranswarp.learnjava），其他Bean按类别放入子包。\r\n自动装配\r\nSpring\r\n基于注解配置和管理Bean也可实现自动装配，使用的注解主要是两种，分别是@AutoWired和@Resource。\r\n@Autowired自动装配：根据属性类型进行自动装配\r\n使用@Autowired就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，@Autowired大幅简化了注入，因为它不但可以写在set()方法上，还可以直接写在字段上，甚至可以写在构造方法中\r\n@Componentpublic class UserService &#123;    MailService mailService;    public UserService(@Autowired MailService mailService) &#123;        this.mailService = mailService;    &#125;    ...&#125;\r\n当类中的某个属性上使用@Autowired注解标识时，会在IOC容器中查找待装配的组件的类型，如果有唯一的bean对象与之匹配，则使用该bean对象进行装配。\r\n若待装配的属性在IOC容器中对应有多个同类型的bean对象，则使用待装配的属性的属性名作为id值再进行查找，若找到就进行装配，若找不到就抛出异常。\r\n若想在使用@Autowired注解时也指定id值，可以配合@Qualifier注解，@Qualifier：根据名称进行注入，目的在于区别同一接口下有多个实现类，根据类型就无法选择，如下图所示\r\n:\r\n\r\n\r\nimg\r\n\r\n@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）\r\n//@Resource //根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao;\r\n@Value：注入普通类型属性\r\n@Value(value = &quot;abc&quot;)private String name\r\n示例\r\n新建一个beans_Auto.xml配置文件，在配置文件中配置要扫描的包\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.*&quot;/&gt;&lt;/beans&gt;\r\n以PotUserServlet和PotUserServiceImpl类为例，在PotUserServlet类中维护一个PotUserServiceImpl类的属性，使用@Autowired对其进行自动装配。\r\nPotUserServlet类代码如下 :\r\n（在register()方法中打印出属性potUserService，与测试类中获取到的Bean对象进行比较）\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PotUserService &#123;    //Web层调用Service层    @Autowired    private PotUserServiceImpl potUserService;    // 定义用户注册方法的 demo    public void register()&#123;        System.out.println(&quot;PotUserServlet &#x27;s register() is invoked~~~&quot;);        System.out.println(&quot;potUserService = &quot; + potUserService);        potUserService.register();    &#125;&#125;\r\nPotUserServiceImpl类代码如下 :\r\n（注意，此处给出了指定的id值[value=“potUserServiceImpl01”]）\r\nimport org.springframework.stereotype.Service;@Service(value=&quot;potUserServiceImpl01&quot;)public class PotUserServiceImpl &#123;    //定义注册用户的方法    public void register() &#123;        System.out.println(&quot;PotUserServiceImpl &#x27;s register() is invoked~&quot;);    &#125;&#125;\r\n在测试类中定义单元测试方法，在测试类中单独通过 id\r\n获取到PotUserServiceImpl类的 Bean 对象，与\r\nPotUserServlet的register方法中打印出的Bean对象进行对比，查看是否为同一个对象。testAutoAssembleByAutoWired()方法代码如下\r\n@Testpublic void testAutoAssembleByAutoWired() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean_Auto.xml&quot;);    PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);    potUserServlet.register();    PotUserServiceImpl potUserServiceImpl01 = ioc.getBean(&quot;potUserServiceImpl01&quot;, PotUserServiceImpl.class);    System.out.println(&quot;potUserServiceImpl01 = &quot; + potUserServiceImpl01);&#125;/*PotUserServlet &#x27;s register() is invoked~~~potUserService = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@ebda593PotUserServiceImpl &#x27;s register() is invoked~potUserServiceImpl01 = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@ebda593 */\r\n可以看到，由于此时我们在bean_Auto.xml中配置了自动扫描，而使用@Service注解时，我们又给出了value = \"potUserServiceImpl01\"的指定id。所以最终IOC容器中只有一个PotUserServiceImpl类型的\r\nbean\r\n对象[根据类型进行自动装配]，并且其id = potUserServiceImpl01。因此，在测试方法中，我们通过id = potUserServiceImpl01获取到的Bean对象就是自动装配的Bean对象。\r\n\r\n@Resource自动装配\r\n@Resource有两个属性比较重要，分别是name\r\n和\r\ntype；Spring将@Resource注解的name属性解析为bean对象的id值，而将type属性解析为bean对象的类型。\r\n当使用name属性时，采取byName的自动注入策略；当使用type属性时，采取byType的自动注入策略。\r\n若@Resource注解未指定name 和\r\ntype，则优先使用byName注入策略，若匹配不上再采取byType注入策略，若仍然匹配不上，报错。\r\nJDK17.0不支持@Resource注解。\r\n将 Resource 改为 by Type 策略\r\n\r\n\r\nimg\r\n\r\n此时，由于IOC容器中只有唯一一个PotUserServiceImpl类型的Bean对象，所以可以装配成功。\r\n\r\n\r\nimg\r\n\r\n但是，如果此时我们在beans_Auto.xml中再配置一个以上PotUserServiceImpl类型的bean对象\r\n[注意：基于注解配置Bean和基于XML配置Bean，两者配置的Bean对象是互不干扰的，但容器中总共存在的Bean对象的数量会发生改变]\r\n那么再次运行testAutoAssembleByResource()方法，就会报错\r\n当@Resource注解采取“**byType”注入策略时，同样要求当前IOC容器中只有唯一一个该类型的Bean对象。\r\n泛型依赖注入\r\n\r\nSpring提供了基于泛型依赖的注入机制，以更好地管理有继承和相互依赖的Bean的自动装配。\r\n泛型依赖注入需要用到@Autowired注解。\r\n泛型依赖注入，本质是利用了OOP的多态机制。eg :\r\nBasicService中维护有一个使用了泛型的BasicDAO类的属性。\r\n\r\n实例：\r\n首先需要创建下面这五个类，如下图所示 :\r\n（最终要实现——将OrderDAO类型的Bean对象装配给BasicService中维护的BasicDAO类型的属性[多态]）\r\n\r\n\r\nimg\r\n\r\nOrder类代码如下 : （作为JavaBean类）\r\npublic class Order &#123;&#125;\r\nBasicDAO类代码如下 : （定义了save()抽象方法）\r\npublic abstract class BasicDAO&lt;T&gt; &#123;    public abstract void save();&#125;\r\nOrderDAO类代码如下 :\r\n(继承自BasicDAO，并重写BasicDAO的save方法)\r\nimport org.springframework.stereotype.Repository;@Repositorypublic class OrderDAO extends BasicDAO&lt;Order&gt; &#123;    @Override    public void save()&#123;        System.out.println(&quot;OrderDAO &#x27;s save() is invoked~&quot;);    &#125;&#125;\r\nBasicService类代码如下 :\r\n(注意，针对basicDAO属性使用了@Autowire自动装配，最终会将OrderDAO类型的对象引用给basicDAO属性，构成多态)\r\nimport org.springframework.beans.factory.annotation.Autowired;public class BasicService&lt;T&gt; &#123;    @Autowired    private BasicDAO&lt;T&gt; basicDAO;    public void save() &#123;        basicDAO.save();    &#125;&#125;\r\nOrderService类代码如下 : (继承自BasicService)\r\n@Servicepublic class OrderService extends BasicService&lt;Order&gt;&#123;&#125;\r\n然后配置文件 xml 配置一下\r\n测试输出发现 OrderService 被装配，且 bean 对象是\r\nbasicDAO属性，形成了多态\r\n@Test    public void testParameterizedTypeDependencyInjection() &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean_parame.xml&quot;);        OrderService orderService = ioc.getBean(&quot;orderService&quot;, OrderService.class);        orderService.save();    &#125;    // OrderDAO &#x27;s save() is invoked~\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework Part5-Spring中的AOP面向切面编程","url":"/posts/50477.html","content":"什么是\r\nAOP，如何理解面向切面编程\r\nAOP,\r\nAspect Oriented Programming\r\n，即面向切面编程。\r\n通过预编译方法和运行期间动态代理的方式实现，在不修改源代码的方式下，给程序动态统一添加额外功能的一种技术。\r\n\r\nAOP是对面向对象编程OOP的一个补充。\r\n它的目的是将复杂的需求分解为不同的切面，将散布在系统中的公共功能集中解决。\r\n它的实际含义是在运行时将代码切入到类的指定方法、指定位置上，将不同方法的同一个位置抽象为一个切面对象，并对该对象进行编程。\r\n\r\n\r\nAOP 的目的是为了解耦 其次是简化开发，AOP 是 Spring 的核心\r\n面向切面编程\r\n他是一套规范，通过预编译方式和运行期间动态代理实现程序的统一维护\r\n核心概念 就是\r\n将分散在各个业务逻辑代码中的相同的代码通过横向切割的方式抽取到一个独立的模块中\r\n\r\n\r\nimg\r\n\r\nAOP的优点\r\n\r\n降低模块之间的耦合度\r\n使系统更容易扩展\r\n更好的代码复用\r\n非业务代码更加集中，不分散，便于统一管理\r\n业务代码更加简洁纯粹，不掺杂其他的代码的影响\r\n\r\nAOP中出现的一些概念\r\n\r\n切面：横切关注点，从每个方法中抽取的非核心业务，被模块化的抽象对象，横切关注点的模块化，比如下标提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为在哪干和干什么集合；\r\n通知：切面对象完成的工作（非业务代码），在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before\r\nadvice）、后置通知(after advice)、环绕通知（around\r\nadvice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为干什么；\r\n目标：被通知的对象（即被横切的对象），需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；由于Spring\r\nAOP\r\n通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为对谁干；\r\n代理：切面、通知、目标混合之后的对象。封装通知方法的类\r\nAOP代理：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。在AOP中表示为怎么实现的一种典型方式；\r\n连接点：通知要插入业务代码的具体位置，表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为spring允许你使用通知的地方；（如Spring实现中的JoinPoint）\r\n切入点：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为在哪里干的集合；\r\n织入：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java\r\nAOP框架一样，在运行时完成织入。在AOP中表示为怎么实现的；\r\n引入：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）,\r\n在AOP中表示为干什么（引入什么）；\r\n\r\n\r\n\r\nimg\r\n\r\nAOP 的核心是连接点\r\n连接点是我们需要关注的程序拓展点\r\n可能是类初始化 方法执行 方法调用 字段调用 异常处理等\r\nSpring 支持的连接点是方法执行点\r\n切入点是一系列连接点的集合，Spring默认使用AspectJ语法，在AOP中抽象表示为可以进行操作的集合\r\n之后就是通知\r\n通知就是我们在连接点上执行的行为\r\n连接点 切入点 通知组合在一起 就是一个切面\r\n把切面映入到其他应用程序或者对象上，创建一个被通知的对象，这些就是织入，Spring\r\n在运行时完成织入 ，在 AOP 中表示为怎么实现的，实现方式\r\n通知类型：\r\n\r\n前置通知（Before advice）：\r\n在被代理的目标方法之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\r\n后置通知（After returning advice）：\r\n在被代理的目标方法后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\r\n异常通知（After throwing advice）：\r\n在被代理的目标方法抛出异常退出时执行的通知。\r\n最终通知（After (finally) advice）：\r\n当被代理的目标方法最终说明的时候执行的通知（不论是正常返回还是异常退出）。\r\n环绕通知（Around Advice）：\r\n包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\r\n\r\n环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知，推荐你使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成同样的事情。用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要在JoinPoint上调用用于环绕通知的proceed()方法，就不会有调用的问题。\r\nSpring AOP和 AspectJ\r\n是什么关系\r\nAspectJ 是一个更加强大的 AOP 框架 是一个 AOP 标准\r\n如果只是简单的业务 可以使用 AOP\r\nAOP 一个重要的原则就是无侵入性\r\nAspectJ 重要的是 一般在编译期进行 即静态织入\r\n在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。\r\n动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java\r\nJDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring\r\nAOP采用的就是基于运行时增强的代理技术。 \r\nSpring AOP更易用，AspectJ更强大\r\nJava中的代理模式实现AOP\r\n创建一个计算器接口，定义四个方法\r\npackage edu.software.ergoutree.spring6aop.example;public interface Calculator &#123;    public int add(int a, int b);    public int subtract(int a, int b);    public int multiply(int a, int b);    public int divide(int a, int b);&#125;\r\n创建一个带日志输出的实现类\r\n高耦合的写法，每次打印日志都要手动完成\r\npackage edu.software.ergoutree.spring6aop.example;// 带日志的实现类// 发现日志功能对核心功能没有影响，但是混合到一起了，既要关心核心业务逻辑，还要关注日志，维护困难public class CalculatirLogImpl implements Calculator&#123;    @Override    public int add(int a, int b) &#123;        System.out.println(&quot;[日志] add 方法开始&quot;);        int result = a + b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] add 方法结束&quot;);        return result;    &#125;    @Override    public int subtract(int a, int b) &#123;        System.out.println(&quot;[日志] sub 方法开始&quot;);        int result = a - b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] sub 方法结束&quot;);        return result;    &#125;    @Override    public int multiply(int a, int b) &#123;        System.out.println(&quot;[日志] mul 方法开始&quot;);        int result = a * b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] mul 方法结束&quot;);        return result;    &#125;    @Override    public int divide(int a, int b) &#123;        System.out.println(&quot;[日志] div 方法开始&quot;);        int result = a / b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] div 方法结束&quot;);        return result;    &#125;&#125;\r\n使用静态代理进行优化\r\n上方代码中，日志信息和业务逻辑的耦合性很高，不利于代码的维护。\r\n关于静态代理和动态代理的部分，可以看我的另一篇文章，这里只做简单讲解\r\n介绍：代理是一种设计模式，提供一个代理类，调用方法的时候使用代理类间接调用，让不属于目标方法核心方法中的代码解耦出来，减少对目标方法的调用和打扰，同时让功能更加集中统一更利于维护\r\n静态代理是通过创建一个代理类来实现对目标对象的访问控制。下面是计算器例子改为静态代理的实现方式\r\npackage edu.software.ergoutree.spring6aop.example;// 代理类public class CalculatorProxy implements Calculator &#123;    // 传递被代理的目标对象    private final Calculator target;      public CalculatorProxy(Calculator target) &#123;        this.target = target;    &#125;    @Override    public int add(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行add方法&quot;);   // 关于代理的日志仅仅是记录操作，不代表没有实现代理        // 调用目标对象的方法实现核心业务的实现        int result = target.add(a, b);        System.out.println(&quot;代理: add方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int subtract(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行subtract方法&quot;);        int result = target.subtract(a, b);        System.out.println(&quot;代理: subtract方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int multiply(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行multiply方法&quot;);        int result = target.multiply(a, b);        System.out.println(&quot;代理: multiply方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int divide(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行divide方法&quot;);        try &#123;            int result = target.divide(a, b);            System.out.println(&quot;代理: divide方法执行完成，结果=&quot; + result);            return result;        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;代理: divide方法执行出错 - &quot; + e.getMessage());            throw e;        &#125;    &#125;&#125;\r\n测试类\r\npackage edu.software.ergoutree.spring6aop.example;public class Main &#123;    public static void main(String[] args) &#123;        // 创建目标对象        Calculator target = new CalculatorImpl();                // 创建代理对象，传入目标对象        Calculator proxy = new CalculatorProxy(target);                // 通过代理对象调用方法        System.out.println(&quot;10 + 5 = &quot; + proxy.add(10, 5));        System.out.println(&quot;10 - 5 = &quot; + proxy.subtract(10, 5));        System.out.println(&quot;10 * 5 = &quot; + proxy.multiply(10, 5));        System.out.println(&quot;10 / 5 = &quot; + proxy.divide(10, 5));                // 测试除法异常        try &#123;            System.out.println(&quot;10 / 0 = &quot; + proxy.divide(10, 0));        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n使用动态代理优化\r\n静态代理没有实现对日志的统一管理，实际上并没有进行多少的优化\r\n\r\n\r\nimage-20250422204359251\r\n\r\n定义计算器接口和实现类都不变，我们添加一个日志处理器，实现\r\nInvocationHandler 接口\r\n// 日志处理器，实现 InvocationHandler 接口class LogHandler implements InvocationHandler &#123;    private final Object target;    public LogHandler(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        String methodName = method.getName();        System.out.println(&quot;[日志] &quot; + methodName + &quot; 方法开始&quot;);        Object result = method.invoke(target, args);        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] &quot; + methodName + &quot; 方法结束&quot;);        return result;    &#125;&#125;\r\n// 测试类public class DynamicProxyExample &#123;    public static void main(String[] args) &#123;        // 创建目标对象        Calculator calculator = new CalculatorImpl();        // 创建日志处理器        LogHandler logHandler = new LogHandler(calculator);        // 创建代理对象        Calculator proxyCalculator = (Calculator) Proxy.newProxyInstance(                calculator.getClass().getClassLoader(),                calculator.getClass().getInterfaces(),                logHandler        );        // 调用代理对象的方法        proxyCalculator.add(2, 3);        proxyCalculator.subtract(5, 2);        proxyCalculator.multiply(3, 4);        proxyCalculator.divide(10, 2);    &#125;&#125;\r\n在上述动态代理的例子中，我们通过 InvocationHandler\r\n实现了日志功能的增强。然而，当项目变得复杂时，手动编写代理逻辑会变得繁琐，并且难以维护。这时候，Spring\r\nAOP（面向切面编程）就可以发挥作用了。\r\nSpring AOP 是 Spring\r\n框架的一个重要特性，它允许我们在不修改原有代码的情况下，对程序进行增强。Spring\r\nAOP\r\n基于动态代理实现，提供了一种更加简洁、灵活的方式来实现横切关注点（如日志、事务管理等）。\r\n动态代理的工厂类\r\npackage edu.software.ergoutree.spring6aop.example;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyFactory &#123;    // 目标对象    private Object target;    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    // 返回代理对象    public Object getProxy() &#123;        /*        Proxy.newProxyInstance() 方法有三个参数        第一个参数 ClassLoader：加载动态生成代理类的加载器        第二个参数 class&lt;?&gt;[] interfaces:目标对象实现的所有接口的class类型的数组        第三个参数 InvocationHandler 设置代理对象实现目标对象方法的过程         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() &#123;            // 第一个参数 代理对象            // 第二个参数 需要重写的目标对象的方法            // 第三个参数 method方法里面的参数            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                // 方法调用前的日志输出                System.out.println(&quot;[动态代理日志] 开始执行 &quot; + method.getName() + &quot; 方法，参数: &quot; +                        java.util.Arrays.toString(args));                // 调用目标的方法                Object result = method.invoke(target, args);                // 方法调用后的日志输出                System.out.println(&quot;[动态代理日志] &quot; + method.getName() + &quot; 方法执行完毕，结果: &quot; + result);                System.out.println(&quot;----------------------------------&quot;);                return result;            &#125;        &#125;;        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);    &#125;&#125;\r\n测试\r\npackage edu.software.ergoutree.spring6aop.example;public class CalcutorTestProxy &#123;    public static void main(String[] args) &#123;        Calculator target = new CalculatorImpl();        // 创建代理工厂        ProxyFactory proxyFactory = new ProxyFactory(target);        // 获取代理对象        Calculator proxy = (Calculator) proxyFactory.getProxy();        // 通过代理对象调用方法        System.out.println(&quot;===== 测试加法 =====&quot;);        int addResult = proxy.add(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + addResult);        System.out.println(&quot;\\n===== 测试减法 =====&quot;);        int subtractResult = proxy.subtract(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + subtractResult);        System.out.println(&quot;\\n===== 测试乘法 =====&quot;);        int multiplyResult = proxy.multiply(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + multiplyResult);        System.out.println(&quot;\\n===== 测试除法 =====&quot;);        int divideResult = proxy.divide(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + divideResult);        // 测试异常情况        try &#123;            System.out.println(&quot;\\n===== 测试除法异常 =====&quot;);            proxy.divide(10, 0);        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getClass().getName());        &#125;    &#125;&#125;\r\n基于注解的 AOP\r\n技术说明\r\n动态代理分类：JDK动态代理 和 cglib动态代理\r\n有接口，使用 JDK\r\n动态代理，生成接口实现类的代理对象，代理对象和目标对象都实现同样的接口\r\n无接口，使用 cglib 动态代理，生成子类的代理对象，继承目标类\r\n\r\n\r\nimage-20250423163635376\r\n\r\n动态代理分为JDK动态代理和glib动态代理\r\n当目标类有接口的情况使用JDK动态代理和cglib动态代理，\r\n没有接口时只能使用cgib动态代理\r\nJDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1,和目标类实现相同的接口●cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类\r\n动态代理(InvocationHandler) :\r\nJDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求*“代理对象和目标对象实现同样的接口**\r\n(兄弟两个拜把子模式)。\r\ncglib:\r\n通过继承被代理的目标类(认干爹模式)实现代理，所以不需要目标类实现接口。\r\nAspectJ:是AOP思想的一种实现。本质上是静态代理，将代理逻辑”织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。\r\nSpring只是借用了 AspectJ中的注解。\r\n使用注解配置AOP\r\nSpring AOP允许使用基于注解的方式实现AOP，这样做可以简化Spring配置文件的臃肿代码。\r\n\r\n\r\nimage-20250423163517236\r\n\r\n步骤：\r\n\r\n引入 AOP 相关依赖\r\n创建目标资源\r\n\r\n接口\r\n实现类\r\n\r\n创建切面类\r\n\r\n切入点\r\n通知类型\r\n\r\n\r\n实例\r\n所以先创建 LogAspect 切面类\r\npackage edu.software.ergoutree.spring6aop.anoaop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;// 切面类@Component  // IoC容器中进行管理@Aspect   // 表示是一个切面类public class LogAspect &#123;    // 定义切入点表达式，匹配Calculator接口的所有方法    @Pointcut(&quot;execution(* edu.software.ergoutree.spring6aop.anoaop.Calculator.*(..))&quot;)    public void calculatorPointcut() &#123;&#125;    // 设置切入点和通知类型    // 通知类型  前置 返回 异常 后置 环绕    // 前置  @Before(value=&quot;切入点表达式配置切入点&quot;)    // 单独写切入点表达式@Before(value=&quot;execution(public int edu.software.ergoutree.spring6aop.anoaop.CalculatorImpl.add(..))&quot;)    @Before(&quot;calculatorPointcut()&quot;)    public void beforeMethod(JoinPoint joinPoint) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;前置通知，方法名&quot; + methodName + &quot; 参数 &quot; + args);    &#125;    // 后置通知（最终通知）    @After(&quot;calculatorPointcut()&quot;)    public void afterMethod(JoinPoint joinPoint) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;后置通知，方法名&quot; + methodName + &quot; 参数 &quot; + args);    &#125;    // 返回通知    // 返回  @AfterReturning(value = &quot;切入点表达式&quot;, returning = &quot;增强的目标方法返回值（和方法中的Object一样）&quot;)    @AfterReturning(value = &quot;calculatorPointcut()&quot;, returning = &quot;result&quot;)    public void afterReturningMethod(JoinPoint joinPoint, Object result) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;返回通知，方法名&quot; + methodName + &quot; 参数 &quot; + args + &quot;目标方法的返回值&quot; + result);    &#125;    // 异常通知，目标方法出现了异常，这个通知会执行    // @AfterThrowing(value = &quot;切入点表达式&quot;, throwing = &quot;目标方法的异常信息&quot;)    @AfterThrowing(value = &quot;calculatorPointcut()&quot;, throwing = &quot;ex&quot;)    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;异常通知 方法 &quot; + methodName + &quot; 参数 &quot; + args + &quot; 执行抛出异常: &quot; + ex.getMessage());    &#125;    // 环绕通知    @Around(&quot;calculatorPointcut()&quot;)    public Object aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123;        String methodName = joinPoint.getSignature().getName();        Object[] args = joinPoint.getArgs();        System.out.println(&quot;Logger-&gt;环绕通知-前 方法 &quot; + methodName + &quot; 开始执行，参数: &quot; + Arrays.toString(args));        try &#123;            System.out.println(&quot;Logger-&gt;环绕通知-目标方法之前执行&quot;);            // 执行目标方法            Object result = joinPoint.proceed();            System.out.println(&quot;Logger-&gt;环绕通知-目标方法之后执行 方法 &quot; + methodName + &quot; 执行成功，结果: &quot; + result);            return result;        &#125; catch (Exception e) &#123;            System.out.println(&quot;Logger-&gt;环绕通知-异常 方法 &quot; + methodName + &quot; 执行失败，异常: &quot; + e.getMessage());            throw e;        &#125; finally &#123;            System.out.println(&quot;Logger-&gt;环绕通知-最终 方法 &quot; + methodName + &quot; 执行结束&quot;);        &#125;    &#125;    // 环绕通知另一个应用，计算执行时间    @Around(&quot;calculatorPointcut()&quot;)    public Object timingAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;        long start = System.currentTimeMillis();        try &#123;            return joinPoint.proceed();        &#125; finally &#123;            long end = System.currentTimeMillis();            System.out.println(&quot;方法 &quot; + joinPoint.getSignature().getName()                    + &quot; 执行耗时: &quot; + (end - start) + &quot;ms&quot;);        &#125;    &#125;&#125;\r\n关于切入点表达式\r\n语法细节：\r\n\r\n用号代替”权限修饰符”和“返回值”部分表示”权限修饰符”和“返回值”不限\r\n在包名的部分，一个*号只能代表包的层次结构中的一层，表示这一层是任意的。\r\n例如: *.Hello匹配com.Hello, 不匹配com.atguigu.Hello\r\n在包名的部分，使用\r\n*..表示包名任意，包的层次深度任意\r\n在类名的部分，类名部分整体用 * 号代替,表示类名任意\r\n在类名的部分，可以使用 * 号代替类名的一部分\r\n\r\n例如:\r\n*Service匹配所有名称以Service结尾的类或接口\r\n\r\n在方法名部分，可以使用 * 号表示方法名任意\r\n在方法名部分，可以使用 * 号代替方法名的一部分\r\n\r\n例如: *Operation匹配所有方法名以Operation结尾的方法\r\n\r\n在方法参数列表部分，使用(..)表示参数列表任意\r\n在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头\r\n在方法参数列表部分，基本数据类型和对应的包装类型是不一-样的\r\n\r\n切入点表达式中使用int和实际方法中Integer 是不匹配的\r\n\r\n在方法返回值部分，如果想要明确指定一个返回值类型，\r\n那么必须同时写明楫限修饰符。\r\n\r\n例如: execution(public int ..Service,(..,int))正确\r\n例如: execution( int ..Service.*(..,int))错误\r\n\r\n\r\n完整例子：\r\nexecution(访问修饰符 增强方法的返回类型 增强方法所在类全路径.方法名)\r\n\r\n\r\nimage-20250423165621177\r\n\r\n关于 环绕通知\r\n环绕通知的特点\r\n\r\n功能最强大的通知类型：可以控制目标方法是否执行、何时执行、如何执行\r\n唯一能控制方法执行的切入点：可以决定是否调用proceed()方法来执行目标方法\r\n可以修改返回值：在方法执行前后对返回值进行处理\r\n可以处理异常：捕获并处理目标方法抛出的异常\r\n\r\naroundMethod 的方法参数说明\r\n需要注意的是，环绕通知必须接收一个类型为ProceedingJoinPoint的参数，返回值也必须是Object类型，且必须抛出异常\r\n\r\nProceedingJoinPoint：继承自JoinPoint，新增了proceed()方法\r\n\r\nproceed()：执行目标方法，返回目标方法的返回值\r\nproceed(Object[] args)：使用新参数执行目标方法\r\n\r\n\r\n与其他通知的执行顺序\r\n当环绕通知与其他通知共存时，执行顺序为：\r\n\r\n环绕通知的前半部分\r\n前置通知\r\n目标方法\r\n返回通知/异常通知\r\n后置通知\r\n环绕通知的后半部分\r\n\r\n重用切入表达式\r\n关于 @Pointcut\r\n@Pointcut 是 Spring AOP\r\n里的一个注解，其作用是定义一个切入点（Pointcut）\r\npublic void calculatorPointcut() &#123;&#125;\r\n这是一个空方法，其作用是为切入点命名。通过这种方式，可以在其他通知注解（如\r\n@Before、@After 等）中引用这个切入点\r\n创建 bean.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6aop.anoaop&quot;&gt;    &lt;/context:component-scan&gt;    &lt;!--开启Aspectj自动代理，为目标类自动生成代理--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\r\n当然也可以用注解类\r\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@ComponentScan(&quot;edu.software.ergoutree.spring6aop.anoaop&quot;)@EnableAspectJAutoProxy // 启用AOP自动代理public class AppConfig &#123;&#125;\r\n基于 XML 的AOP实现\r\n因为Spring AOP的代理对象由IoC容器自动生成，所以开发者无须过多关注代理对象生成的过程，只需选择连接点、创建切面、定义切点并在XML文件中添加配置信息即可。\r\n\r\n\r\nimage-20250423174728711\r\n\r\n配置切面\r\n在Spring的配置文件中，配置切面使用的是&lt;aop:aspect&gt;元素，该元素会将一个已定义好的Spring Bean转换成切面Bean，因此，在使用&lt;aop:aspect&gt;元素之前，要在配置文件中先定义一个普通的Spring Bean。Spring Bean定义完成后，通过&lt;aop:aspect&gt;元素的ref属性即可引用该\r\nBean。\r\n配置&lt;aop:aspect&gt;元素时，通常会指定 id 和 ref\r\n这两个属性 \r\n配置切入点\r\n在Spring的配置文件中，切入点是通过&lt;aop:pointcut&gt;元素来定义的，表示该切入点是全局切入点，它可被多个切面共享；当&lt;aop:pointcut&gt;元素作为&lt;aop:aspect&gt;元素的子元素时，表示该切入点只对当前切面有效。\r\n在定义&lt;aop:aspect&gt;元素时，通常会指定 id 和\r\nexpression 这两个属性\r\n\r\n\r\n\r\n属性名称\r\n描述\r\n\r\n\r\n\r\n\r\nid\r\n用于指定切入点的唯一标识\r\n\r\n\r\nexpression\r\n用于指定切入点关联的切入点表达式\r\n\r\n\r\n\r\n配置通知\r\n在Spring的配置文件中，使用&lt;aop:aspect&gt;元素配置了5种常用通知，如表所示，5种通知分别为前置通知、后置通知、环绕通知、返回通知和异常通知，&lt;aop:aspect&gt;元素的常用属性如表4所示。\r\n\r\n\r\nimage-20250423175046604\r\n\r\n实例\r\n文件结构\r\nsrc/├── main/│   ├── java/│   │   └── edu.software.ergoutree.spring6aop.xmlaop/│   │       ├── Calculator.java          # 接口│   │       ├── CalculatorImpl.java      # 实现类│   │       └── LogAspect.java           # 切面类│   └── resources/│       └── bean-aopxml.xml                     # XML配置└── test/    └── java/        └── CalculatorAOPTest.java          # 测试类\r\n导入AspectJ框架相关JAR包的依赖，在pom.xml中添加的代码如下：\r\n&lt;dependency&gt;\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t&lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;\t&lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\t&lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt;\r\n计算器的接口和实现类依旧用上面的那个\r\n切面类，定义了5种通知\r\n// LogAspect.javapackage edu.software.ergoutree.spring6aop.xmlaop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;public class LogAspect &#123;    // 前置通知    public void beforeAdvice(JoinPoint joinPoint) &#123;        System.out.println(&quot;[前置] 方法名: &quot; + joinPoint.getSignature().getName());    &#125;    // 后置通知（无论是否异常都会执行）    public void afterAdvice(JoinPoint joinPoint) &#123;        System.out.println(&quot;[后置] 方法执行完毕&quot;);    &#125;    // 返回通知    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;        System.out.println(&quot;[返回] 结果: &quot; + result);    &#125;    // 异常通知    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) &#123;        System.out.println(&quot;[异常] 错误信息: &quot; + ex.getMessage());    &#125;    // 环绕通知    public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable &#123;        System.out.println(&quot;[环绕前] 参数: &quot; + pjp.getArgs()[0] + &quot;, &quot; + pjp.getArgs()[1]);        Object result = pjp.proceed(); // 执行目标方法        System.out.println(&quot;[环绕后] 结果: &quot; + result);        return result;    &#125;&#125;\r\nxml 配置 bean-aopxml.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6aop.xmlaop&quot;/&gt;    &lt;!-- 定义切面Bean --&gt;    &lt;bean id=&quot;logAspect&quot; class=&quot;edu.software.ergoutree.spring6aop.xmlaop.LogAspect&quot;/&gt;    &lt;!-- AOP配置 --&gt;    &lt;aop:config&gt;        &lt;aop:aspect ref=&quot;logAspect&quot;&gt;            &lt;!-- 定义切入点表达式 --&gt;            &lt;aop:pointcut id=&quot;calculatorMethods&quot;                          expression=&quot;execution(* edu.software.ergoutree.spring6aop.xmlaop.Calculator.*(..))&quot;/&gt;            &lt;!-- 五种通知绑定到切入点 --&gt;            &lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;            &lt;aop:after method=&quot;afterAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;            &lt;aop:after-returning method=&quot;afterReturningAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot; returning=&quot;result&quot;/&gt;            &lt;aop:after-throwing method=&quot;afterThrowingAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot; throwing=&quot;ex&quot;/&gt;            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;!-- 显式声明Calculator类型的Bean --&gt;    &lt;bean id=&quot;calculator&quot; class=&quot;edu.software.ergoutree.spring6aop.xmlaop.CalculatorImpl&quot;/&gt;&lt;/beans&gt;\r\n测试\r\npackage edu.software.ergoutree.spring6aop;import edu.software.ergoutree.spring6aop.xmlaop.Calculator;import edu.software.ergoutree.spring6aop.xmlaop.CalculatorImpl;import org.junit.jupiter.api.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class CalculatroAOPTest &#123;    @Test    public void Test1() &#123;        try (ClassPathXmlApplicationContext context =                     new ClassPathXmlApplicationContext(&quot;bean-aopxml.xml&quot;)) &#123;            CalculatorImpl calculator = context.getBean(&quot;calculator&quot;, CalculatorImpl.class);            // 正常测试            System.out.println(&quot;=== 正常测试 ===&quot;);            calculator.add(5, 3);            calculator.divide(6, 2);            // 异常测试（除数为0）            System.out.println(&quot;\\n=== 异常测试 ===&quot;);            try &#123;                calculator.divide(6, 0);            &#125; catch (ArithmeticException ignored) &#123;&#125;        &#125;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"SpringFrameworkPart6-Spring Framework常用注解","url":"/posts/undefined.html","content":"Spring框架核心注解\r\nSpring的一个核心功能是IOC，就是将Bean初始化加载到容器中，Bean是如何加载到容器的，可以使用Spring注解方式或者Spring\r\nXML配置方式。\r\nSpring注解方式减少了配置文件内容，更加便于管理，并且使用注解可以大大提高了开发效率！\r\n注解本身是没有功能的，和xml一样，注解和xml都是一种元数据，元数据即解释数据的数据，也就是所谓的配置。\r\n我们可以通过\r\norg.springframework.beans.factory.annotation 和\r\norg.springframework.context.annotation 包中的注解来使用\r\nSpring DI 引擎的功能。\r\n\r\nxml用来管理bean；\r\n注解只负责完成属性的注入；\r\n\r\n使用注解需要开启对注解的支持\r\n&lt;context:component-scan base-package=&quot;com.guo&quot;&gt;&lt;/context:component-scan&gt;&lt;context:annotation-config/&gt;\r\n\r\n常用注解\r\n给容器中注入组件\r\n包扫描+组件标注注解\r\n\r\n@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean\r\n\r\n作用：是一个泛化的组件注解，用于标记一个类作为 Spring\r\n容器中的一个组件，让 Spring 能够自动扫描并将其纳入容器管理。\r\n使用：当一个类不属于特定的层（如控制层、业务层、数据访问层），但又需要被\r\nSpring\r\n容器管理时，就可以使用@Component注解。例如，一些工具类、配置类等可以使用该注解。\r\n@Controller、@Service、@Repository都可以称为@Component。@Controller、@Service、@Reponsitory都组合了 @Component注解。为了区分三层不同的作用，因此分别为三层起了不同的名字。\r\n\r\n@Controller：应用在控制层\r\n\r\n作用：用于标记控制层的组件，主要处理用户的请求和视图的展示。它负责接收客户端的请求，调用相应的业务逻辑方法，并将结果返回给客户端。\r\n使用场景：在 Web 应用中，通常用于处理 HTTP\r\n请求的控制器类上。比如，处理用户登录、注册请求，或者根据用户的操作返回相应页面的控制器。\r\n\r\n@Service：应用在service层（业务逻辑层）\r\n\r\n作用：用于标记业务层的组件，主要包含应用的业务逻辑。它通常会调用数据访问层的方法来完成数据库操作，并对数据进行处理和业务规则的应用。\r\n使用场景：在处理复杂业务逻辑的服务类上使用，如用户服务、订单服务等。例如，在电商应用中，计算订单总价、处理库存更新等业务逻辑就可以放在@Service注解标记的类中。\r\n\r\n@Repository：应用在dao层（实现类）（数据访问层）\r\n\r\n作用：用于标记数据访问层的组件，主要负责与数据库进行交互，执行数据库的增删改查操作。它提供了一种将数据访问逻辑封装起来的方式，使得业务层可以方便地调用数据访问方法。\r\n使用场景：在与数据库交互的 DAO（Data Access\r\nObject）类上使用。比如，在用户管理系统中，实现用户数据的存储、查询、更新和删除操作的类就可以使用@Repository注解。\r\n\r\n\r\n配置相关注解\r\n配置管理\r\n\r\n@Configuration\r\n\r\n作用：标记类为配置类，替代XML配置文件。配置类中可以声明@Bean方法，Spring容器会将其作为Bean定义的来源。\r\n使用：\r\n@Configurationpublic class AppConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new HikariDataSource();    &#125;&#125;\r\n\r\n@ComponentScan\r\n\r\n作用：自动扫描指定包路径下的组件（如@Component,\r\n@Service, @Repository等），并将其注册为Spring\r\nBean。\r\n属性：\r\n\r\nbasePackages：指定扫描的包路径（支持多个）\r\nexcludeFilters：排除不需要扫描的组件\r\n\r\n使用\r\n@Configuration@ComponentScan(basePackages = &quot;com.example.service&quot;,               excludeFilters = @ComponentScan.Filter(type=FilterType.ANNOTATION, classes=Controller.class))public class AppConfig &#123;&#125;\r\n\r\n@AliasFor\r\n\r\n作用：为注解属性声明别名（用于元注解组合）主要用于元注解组合时实现属性覆盖\r\n\r\n@PropertySource\r\n\r\n作用：加载外部属性文件到Spring Environment\r\n特性：\r\n\r\n支持classpath:、file:等前缀\r\n支持多个文件（Spring 4+使用@PropertySources）\r\n\r\n使用：\r\n@Configuration@PropertySource(&quot;classpath:app.properties&quot;)@PropertySource(value = &quot;file:/etc/config/override.properties&quot;, ignoreResourceNotFound = true)public class AppConfig &#123; ... &#125;\r\n扩展：@PropertySources\r\n\r\n可以使用此注解指定多个 @PropertySource 配置：\r\n@Configuration@PropertySources(&#123;     @PropertySource(&quot;classpath:/annotations.properties&quot;),    @PropertySource(&quot;classpath:/vehicle-factory.properties&quot;)&#125;)class VehicleFactoryConfig &#123;&#125;\r\n注意，自 Java 8\r\n以来，可以通过上述重复注解的特性来实现同样的功能。\r\n\r\n\r\n\r\nBean管理\r\n\r\n@Bean：导入第三方包里面的注解\r\n\r\n作用：@Bean注解通常用于在 Java 配置类中定义\r\nBean。当你需要将第三方库中的类或者你自己编写的但不适合用组件扫描注解标注的类纳入\r\nSpring\r\n容器管理时，就可以使用@Bean注解。它允许你以编程的方式创建和配置\r\nBean。\r\n特性：\r\n\r\n方法名默认作为Bean名称\r\n支持initMethod/destroyMethod配置生命周期方法\r\n\r\n使用\r\n@Configurationpublic class DataSourceConfig &#123;    @Bean(name = &quot;primaryDataSource&quot;, initMethod = &quot;init&quot;)    public DataSource dataSource() &#123;        return new HikariDataSource();    &#125;&#125;\r\n\r\n@Conditional：\r\n\r\n作用：这是一个元注解，用于自定义条件化创建\r\nBean。可以根据指定的条件决定是否创建某个 Bean。基于条件决定是否注册\r\nBean（自定义条件逻辑）。它需要配合一个条件类（Condition\r\nClass）使用，条件类通过实现Condition接口，定义了Bean加载的条件逻辑。\r\n使用：\r\n@Component@Conditional(MyCondition.class)public class MyConditionalComponent &#123;    public void doSomething() &#123;        System.out.println(&quot;Conditional component...&quot;);    &#125;&#125;\r\n在上述代码中，MyConditionalComponent类仅在MyCondition条件满足时才会被加载。这种方式使得开发者可以根据运行时环境或配置动态决定Bean的加载，增强了应用的灵活性。通过这种方式，开发者可以实现按需加载Bean，从而优化应用的性能和资源利用率。\r\n\r\n@ConditionalOnProperty（Spring\r\nBoot特有）\r\n\r\n作用：根据配置文件中的属性值来决定是否创建 Bean。\r\n```java import\r\norg.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\r\nimport org.springframework.context.annotation.Bean; import\r\norg.springframework.context.annotation.Configuration;\r\n@Configuration public class\r\nPropertyConfig { @Bean\r\n@ConditionalOnProperty(name =\r\n“myapp.feature.enabled”, havingValue = “true”) public MyFeature\r\nmyFeature() { return new MyFeature(); } }     在这个例子中，只有当配置文件（如`application.properties`）中`myapp.feature.enabled`属性的值为`true`时，`myFeature` Bean 才会被创建。  - @Order  - 作用：定义Bean的加载/执行顺序（数值越小优先级越高）  - **应用场景**：    - 多个Bean实现同一接口时指定注入顺序    - AOP切面的执行顺序  - 使用：    ```java    @Component    @Order(1)    public class ValidationFilter implements Filter &#123; ... &#125;\r\n\r\n@ApplicationScope\r\n\r\n作用：定义 Bean 的作用域为 ServletContext 级别\r\n\r\n@Scope：Bean作用域注解\r\n\r\n作用：@Scope注解用于定义Bean的作用域。它支持以下几种作用域：\r\n取值\r\n\r\nSingleton：单例作用域，Spring容器中只有一个实例（默认值）。\r\nPrototype：原型作用域，每次请求都会创建一个新的实例。\r\nSession：会话作用域，每个用户会话对应一个实例。\r\nRequest：请求作用域，每个HTTP请求对应一个实例。\r\n\r\n使用：\r\n@Component@Scope(&quot;prototype&quot;)public class MyComponent &#123;    public void doSomething() &#123;        System.out.println(&quot;Doing something...&quot;);    &#125;&#125;\r\n在上述代码中，MyComponent类被标记为原型作用域。这意味着每次请求该Bean时，Spring都会创建一个新的实例。这种方式适用于需要独立实例的场景，例如工具类或状态管理类。通过@Scope注解，开发者可以灵活地控制Bean的生命周期，从而更好地满足应用的需求。\r\n扩展：\r\n@RequestScope\r\n/ @SessionScope\r\n/ @ApplicationScope\r\n\r\n作用：Web作用域的快捷注解（Spring 4+）\r\n等价于：@Scope(\"request\"),\r\n@Scope(\"session\"), @Scope(\"application\")\r\n\r\n\r\n@PostConstruct\r\n\r\n作用：@PostConstruct注解用于定义Bean初始化后的方法。被标记的方法会在Bean实例化并注入依赖后自动执行，通常用于执行初始化逻辑。\r\n使用：\r\n@Componentpublic class MyComponent &#123;    @PostConstruct    public void init() &#123;        System.out.println(&quot;Bean initialized...&quot;);    &#125;&#125;\r\nMyComponent类的init()方法被标记为初始化后执行。这意味着在Bean实例化并注入依赖后，Spring会自动调用该方法。这种方式使得开发者可以在Bean初始化阶段执行必要的逻辑，例如资源分配或状态初始化。通过这种方式，开发者可以确保Bean在使用前处于正确的状态。\r\n\r\n@PreDestroy\r\n\r\n作用：@PreDestroy注解用于定义Bean销毁前的方法。被标记的方法会在Bean销毁前自动执行，通常用于执行清理逻辑。\r\n使用和@PostConstruct类似\r\n\r\n@DependsOn：依赖关系管理\r\n\r\n作用：强制指定当前Bean的依赖项，确保依赖项先初始化\r\n使用\r\n@Bean@DependsOn(&quot;databaseInitializer&quot;)public DataSource dataSource() &#123; ... &#125;\r\n\r\n@Description\r\n\r\n作用：为Bean添加描述信息（通常用于JMX等管理场景）\r\n\r\n@Value\r\n\r\n作用：在Spring应用中，配置文件（如application.properties）通常用于存储应用的配置信息。通过@Value注解，开发者可以将配置文件中的属性值注入到Bean中。\r\n\r\n$&#123;&#125;：从Environment中取值\r\n#&#123;&#125;：SpEL表达式\r\n\r\n使用：\r\n@Componentpublic class MyComponent &#123;    @Value(&quot;$&#123;my.property&#125;&quot;)    private String property;&#125;\r\n在上述代码中，@Value注解将配置文件中的my.property属性值注入到property字段中。这种方式使得开发者可以灵活地从配置文件中读取配置信息，而无需手动解析配置文件。通过这种方式，开发者可以实现配置的动态化管理，从而增强应用的灵活性。\r\n\r\n@Profile\r\n\r\n作用：在多环境开发中，某些Bean可能仅在特定环境下需要被加载。通过@Profile注解，开发者可以定义Bean所属的环境，例如开发环境（dev）、测试环境（test）或生产环境（prod）。\r\n\r\n\r\nImport组件导入\r\n\r\n@Import：导入其他配置类或组件（如@Configuration类）\r\n\r\n作用：将配置类、普通类或其他组件导入到当前 Spring\r\n容器中，支持导入 @Configuration\r\n类、ImportSelector 实现类和\r\nImportBeanDefinitionRegistrar 实现类\r\n使用：\r\n@Import(SomeService.class)@Configurationpublic class AppConfig &#123;    // ...&#125;\r\n这样，SomeService 类就会被注册为 Spring 容器中的一个\r\nbean。\r\n使用ImportSelector动态导入\r\nImportSelector\r\n是一个接口，可以实现动态选择要导入的类：\r\npublic class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        // 根据条件动态返回要导入的类        return new String[] &#123;            &quot;com.example.ServiceA&quot;,            &quot;com.example.ServiceB&quot;        &#125;;    &#125;&#125;@Import(MyImportSelector.class)@Configurationpublic class AppConfig &#123;    // ...&#125;\r\n\r\n@ImportResource\r\n\r\n作用：导入 XML 配置文件\r\n使用：\r\n@Configuration@ImportResource(&quot;classpath:legacy-config.xml&quot;)public class HybridConfig &#123; ... &#125;\r\n\r\n\r\n依赖注入注解\r\n\r\n@Autowired\r\n\r\n作用：自动注入依赖（默认按类型匹配），@Autowired 是\r\nSpring 中最常用的依赖注入注解，其主要功能是自动装配\r\nBean。它可以作用于构造函数、字段、方法之上。默认情况下，它会依据类型进行自动装配，如果存在多个相同类型的\r\nBean，就会抛出异常。\r\n\r\n@Qualifier\r\n\r\n作用：当存在多个相同类型的 Bean 时，@Autowired\r\n仅依据类型注入会产生歧义，此时就需要使用 @Qualifier\r\n注解来指定要注入的 Bean 的名称，以此解决歧义问题。\r\n使用场景：\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;interface MyComponent &#123;&#125;class MyComponentImpl1 implements MyComponent &#123;&#125;class MyComponentImpl2 implements MyComponent &#123;&#125;@Servicepublic class MyService &#123;    private MyComponent myComponent;    @Autowired    @Qualifier(&quot;myComponentImpl1&quot;)    public MyService(MyComponent myComponent) &#123;        this.myComponent = myComponent;    &#125;    // 其他方法&#125;\r\n\r\n@Resource\r\n\r\n作用：它默认按照名称进行注入，如果找不到匹配的名称，就会按照类型进行注入。是Java标准注解，用于按名称注入依赖关系。与@Autowired类似，@Resource也可以用于字段、构造函数或方法。不同之处在于，@Resource支持通过name属性指定注入的Bean名称，这在存在多个同类型Bean时非常有用。\r\n\r\n@Inject\r\n\r\n作用：@Inject是Java标准注解，用于声明依赖注入。它与@Autowired功能类似都是依据类型进行注入，但遵循Java标准规范。不过，@Inject\r\n没有 required 属性，即默认情况下注入的 Bean\r\n必须存在。在Spring环境中，@Inject和@Autowired可以互换使用，但在某些情况下（例如与Java\r\nEE集成时），@Inject可能是更好的选择。\r\n\r\n@Value\r\n\r\n作用：@Value 注解主要用于将外部配置的值注入到 Bean\r\n的字段中，这些外部配置可以来自属性文件、环境变量等。（如@Value(\"$&#123;key&#125;\")或\r\nSpEL 表达式）\r\n\r\n@Primary\r\n\r\n作用：当容器中存在多个相同类型的 Bean 时，使用\r\n@Autowired 进行依赖注入会产生歧义。@Primary\r\n注解的作用就是指定在这种情况下优先注入被该注解标记的 Bean。\r\n\r\n@Required\r\n\r\n作用：@Required 注解用于标记 Bean\r\n的属性为必需的，即要求在配置 Bean 时必须为该属性注入值。不过，从 Spring\r\n5.1\r\n开始，该注解已被标记为过时，推荐使用构造器注入来确保依赖的必需性。\r\n使用：构造器注入能在对象创建时就确保依赖的注入，避免了在运行时出现依赖未注入的问题，提高了代码的健壮性。\r\nimport org.springframework.stereotype.Component;@Componentclass MyBean &#123;    private final String requiredProperty;    public MyBean(String requiredProperty) &#123;        this.requiredProperty = requiredProperty;    &#125;&#125;\r\n\r\n@Lookup\r\n\r\n作用：@Lookup\r\n注解用于声明查找方法，主要用于获取原型作用域的 Bean。在 Spring 中，单例\r\nBean\r\n默认会在容器启动时创建，并且在整个应用生命周期中只有一个实例。而原型作用域的\r\nBean 每次被请求时都会创建一个新的实例。当单例 Bean 需要使用原型作用域的\r\nBean 时，使用 @Lookup 注解可以确保每次获取到的都是新的原型\r\nBean 实例。\r\n\r\n\r\nAOP与切面编程\r\n\r\n@Aspect\r\n\r\n作用：该注解用于把一个类标记为切面类。切面类里包含了切入点和通知，这些可以对特定的方法进行增强。\r\n\r\n@Pointcut\r\n\r\n作用：@Pointcut\r\n注解用于定义切点表达式，以此指定切入点。切入点明确了在哪些方法执行时会触发通知。\r\n\r\n@Before\r\n\r\n作用：@Before\r\n注解定义的是前置通知，它会在目标方法执行之前执行。\r\n\r\n@After\r\n\r\n作用：@After\r\n注解定义的是后置通知，无论目标方法是否抛出异常，它都会在目标方法执行之后执行。\r\n\r\n@AfterReturning\r\n\r\n作用：@AfterReturning\r\n注解定义的是返回通知，它会在目标方法成功返回后执行。\r\n\r\n@AfterThrowing\r\n\r\n作用：@AfterThrowing\r\n注解定义的是异常通知，它会在目标方法抛出异常后执行\r\n\r\n@Around\r\n\r\n作用：@Around\r\n注解定义的是环绕通知，它能够完全控制目标方法的执行，既可以在目标方法执行前后添加额外的逻辑，还能决定是否执行目标方法。\r\n\r\n@EnableAspectJAutoProxy\r\n\r\n作用：@EnableAspectJAutoProxy 注解用于启用 AspectJ\r\n自动代理功能，它需要和 @Configuration 注解一起使用，这样\r\nSpring 就能自动识别并应用切面类。\r\n\r\n@DeclareParents\r\n\r\n作用：@DeclareParents\r\n注解用于引入其他接口到目标类，从而实现接口增强。通过这个注解，目标类可以在不修改原有代码的情况下拥有新的接口和实现。\r\n使用：\r\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;import org.springframework.stereotype.Component;interface NewFeature &#123;    void performNewFeature();&#125;class NewFeatureImpl implements NewFeature &#123;    @Override    public void performNewFeature() &#123;        System.out.println(&quot;Performing new feature&quot;);    &#125;&#125;@Aspect@Componentpublic class IntroductionAspect &#123;    @DeclareParents(value = &quot;com.example.service.*+&quot;, defaultImpl = NewFeatureImpl.class)    public static NewFeature newFeature;&#125;\r\n在这个例子中，IntroductionAspect 切面类使用\r\n@DeclareParents 注解将 NewFeature 接口引入到\r\ncom.example.service 包下的所有类中，默认实现为\r\nNewFeatureImpl 类。\r\n\r\n\r\nJSON常用注解\r\n\r\n@JsonIgnoreProperties\r\n\r\n作用：此注解是类注解，作用是json序列化时将java\r\nbean中的一些属性忽略掉，序列化和反序列化都受影响。\r\n使用：\r\n//生成json时将name和age属性过滤@JsonIgnoreProperties(&#123;&quot;name&quot;&#125;,&#123;&quot;age&quot;&#125;)public class  user &#123;     private  String name;    private int age;&#125;\r\n\r\n@JsonIgnore\r\n\r\n作用：此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。\r\n\r\n@JsonFormat\r\n\r\n作用：此注解用于属性或者方法上（最好是属性上），格式化日期/时间类型字段\r\n参数：\r\n\r\nshape：数据类型（如Shape.STRING）\r\npattern：自定义格式（如\"yyyy-MM-dd HH:mm\"）\r\n\r\n使用：\r\npublic class Event &#123;    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy/MM/dd&quot;)    private LocalDate eventDate;&#125;\r\n\r\n@JsonInclude\r\n\r\n作用：控制序列化时包含属性的规则\r\n取值：\r\n\r\nInclude.NON_NULL：排除null值\r\nInclude.NON_EMPTY：排除空值/空集合\r\n\r\n\r\n@JsonSerialize\r\n\r\n作用：@JsonSerialize 注解通常用在属性或者\r\ngetter 方法上，其主要作用是在对象序列化为 JSON\r\n格式时，嵌入自定义的序列化逻辑。在处理一些特殊类型的数据或者需要对数据进行特定格式转换时，这个注解就非常有用\r\n\r\n@JsonDeserialize\r\n\r\n作用：@JsonDeserialize 注解用于属性或者\r\nsetter 方法上，它的作用是在将 JSON 数据反序列化为 Java\r\n对象时，嵌入自定义的反序列化逻辑。当 JSON 数据的格式和 Java\r\n对象的属性类型不完全匹配，或者需要对数据进行一些预处理时，就可以使用这个注解。\r\n\r\n@Transient\r\n\r\n作用：在使用对象关系映射（ORM）框架（如 Hibernate）时，如果一个 Java\r\n类的属性并非对应数据库表中的字段，就需要使用 @Transient\r\n注解来标记这个属性。如果不标记，ORM\r\n框架默认会将其视为数据库表字段，可能会导致错误。\r\n\r\n@JsonIgnoreType\r\n\r\n作用：@JsonIgnoreType\r\n注解标注在类上，当其他类将该类作为属性时，这个属性在序列化过程中会被忽略，不会出现在生成的\r\nJSON 数据中\r\n\r\n\r\n事件，异步与定时任务\r\n\r\n@EnableAsync\r\n\r\n作用：配置类中通过此注解开启对异步任务的支持；当你在配置类上添加了这个注解后，Spring\r\n会自动扫描带有 @Async\r\n注解的方法，并将这些方法的执行交给线程池来处理，从而实现异步执行。\r\n\r\n@Async：\r\n\r\n作用：@Async\r\n注解用于标记一个方法为异步方法。当调用这个方法时，Spring\r\n会将该方法的执行从当前线程中分离出来，放到线程池中异步执行，调用者线程不会被阻塞，可以继续执行后续的代码。\r\n使用：\r\nimport org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService &#123;    @Async    public void asyncMethod() &#123;        try &#123;            // 模拟耗时操作            Thread.sleep(3000);            System.out.println(&quot;异步方法执行完成&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n在调用 asyncMethod\r\n时，调用者线程不会等待该方法执行完毕，而是会继续执行后续代码。\r\n\r\n@EnableScheduling\r\n\r\n作用：此注解同样用在配置类上，用于开启 Spring\r\n的定时任务调度功能。添加该注解后，Spring 会自动扫描带有\r\n@Scheduled\r\n注解的方法，并按照指定的时间规则定时执行这些方法。\r\n\r\n@Scheduled：\r\n\r\n作用：@Scheduled\r\n注解用于标记一个方法为定时任务方法，它可以指定方法的执行时间规则。该注解支持多种时间表达式，常见的有\r\nfixedRate、fixedDelay 和 cron\r\n等。\r\n属性：\r\n\r\nfixedRate：指定方法执行的时间间隔，单位为毫秒。无论方法执行时间长短，下一次执行都会在上一次开始后的指定时间间隔后启动。\r\nfixedDelay：指定方法执行完成后，下一次执行的延迟时间，单位为毫秒。即上一次方法执行完毕后，等待指定的时间再执行下一次。\r\ncron：使用 Cron\r\n表达式来指定方法的执行时间，Cron\r\n表达式可以更灵活地定义执行时间规则。\r\n\r\n\r\n\r\nEnable***注解\r\n这些注解主要是用来开启对xxx的支持：\r\n\r\n@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；\r\n@EnableAsync：开启异步方法的支持；\r\n@EnableScheduling：开启计划任务的支持；\r\n@EnableWebMvc：开启web\r\nMVC的配置支持；\r\n@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；\r\n@EnableJpaRepositories：开启对SpringData\r\nJPA Repository的支持；\r\n@EnableTransactionManagement：开启注解式事务的支持；\r\n@EnableCaching：开启注解式的缓存支持；\r\n\r\n测试相关\r\n\r\n@RunWith\r\n\r\n作用：运行器，Spring中通常用于对JUnit的支持\r\n\r\n@ContextConfiguration\r\n\r\n作用：用来加载配置配置文件，其中classes属性用来加载配置类。\r\n使用\r\n@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath*:/*.xml&quot;&#125;)public class CDPlayerTest &#123;&#125;\r\n@ContextConfiguration这个注解通常与@RunWith(SpringJUnit4ClassRunner.class)联合使用用来测试。\r\n@ContextConfiguration括号里的locations\r\n=\r\n{“classpath:/.xml”}就表示将classpath路径里所有的xml文件都包括进来，自动扫描的bean就可以拿到，此时就可以在测试类中使用@Autowired注解来获取之前自动扫描包下的所有bean。\r\n\r\n@SpringBootTest\r\n\r\n作用：启动完整Spring应用上下文\r\n参数：\r\n\r\nwebEnvironment：定义Web环境模式\r\nclasses：显式指定配置类\r\n\r\n示例：\r\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)class ApplicationIntegrationTests &#123; ... &#125;\r\n\r\n@MockBean\r\n\r\n作用：向应用上下文注入Mock对象（替换现有Bean）\r\n示例：\r\n\r\n@SpringBootTestclass UserServiceTest &#123;    @MockBean    private UserRepository userRepository;        @Autowired    private UserService userService;&#125;\r\n@SpyBean\r\n\r\n作用：对现有Bean进行部分Mock（保留原始实现）\r\n示例：\r\n\r\n@SpyBeanprivate EmailService emailService;\r\n@TestConfiguration\r\n\r\n作用：定义测试专用的配置类\r\n示例\r\n@TestConfigurationstatic class TestConfig &#123;    @Bean    public Clock testClock() &#123;        return Clock.fixed(Instant.now(), ZoneId.systemDefault());    &#125;&#125;\r\n\r\n\r\n其他注解\r\n\r\n@EqualsAndHashCode（Lombok）\r\n\r\n作用：自动生成 equals() 和 hashCode()\r\n方法，避免手动编写冗余代码。\r\n参数：\r\n\r\ncallSuper：是否包含父类的字段（默认false）。若为true，生成的方法会调用super.equals()。\r\nexclude/of：排除或指定参与计算的字段。\r\n\r\n注意：需添加 Lombok 依赖\r\n使用\r\n@EqualsAndHashCode(callSuper = true, exclude = &quot;age&quot;)public class Person extends Human &#123;    private String name;    private int age;&#125;\r\n\r\n@XmlAccessorType (JAXB)\r\n\r\n作用：控制 JAXB 如何将 Java 对象与 XML\r\n互相转换，指定字段/属性的访问方式。类级别的注解，定义这个类中何种类型需要映射到XML。\r\n属性：\r\n\r\nXmlAccessType.FIELD：映射这个类中的所有字段到XML\r\nXmlAccessType.PROPERTY：映射这个类中的属性（get/set方法）到XML\r\nXmlAccessType.PUBLIC_MEMBER：将这个类中的所有public的field或property同时映射到XML（默认）\r\nXmlAccessType.NONE：不映射\r\n\r\n\r\n\r\n引用自Spring Framework\r\n的详细注解大全的注解表格\r\n核心容器与配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Configuration\r\n标记类为配置类，替代 XML 配置\r\n\r\n\r\n@Bean\r\n在配置类中声明一个 Bean，由 Spring 容器管理\r\n\r\n\r\n@Component\r\n通用组件注解，标记类为 Spring 管理的 Bean\r\n\r\n\r\n@ComponentScan\r\n自动扫描并注册指定包下的组件（如@Component、@Service等）\r\n\r\n\r\n@Import\r\n导入其他配置类或组件（如@Configuration类）\r\n\r\n\r\n@PropertySource\r\n加载外部属性文件（如.properties或.yml）\r\n\r\n\r\n@Lazy\r\n延迟初始化 Bean\r\n\r\n\r\n@Scope\r\n定义 Bean 的作用域（如singleton\r\n、prototype 、request等）\r\n\r\n\r\n@DependsOn\r\n指定当前 Bean 依赖的其他 Bean，确保初始化顺序\r\n\r\n\r\n@Profile\r\n指定 Bean\r\n或配置仅在特定环境下生效（如dev、prod）\r\n\r\n\r\n@Conditional\r\n基于条件决定是否注册 Bean（自定义条件逻辑）\r\n\r\n\r\n@Service\r\n标记服务层组件（@Component的特化）\r\n\r\n\r\n@Repository\r\n标记数据访问层组件（@Component的特化），支持异常转换\r\n\r\n\r\n@Controller\r\n标记 MVC 控制器组件（@Component的特化）\r\n\r\n\r\n@Role\r\n定义 Bean 的角色（如ROLE_APPLICATION\r\n、ROLE_INFRASTRUCTURE）\r\n\r\n\r\n@Description\r\n为 Bean 添加描述信息（通常用于监控或文档）\r\n\r\n\r\n@PropertySources\r\n组合多个@PropertySource\r\n\r\n\r\n@ImportResource\r\n导入 XML 配置文件\r\n\r\n\r\n@Order\r\n定义 Bean 的加载顺序（值越小优先级越高）\r\n\r\n\r\n@AliasFor\r\n为注解属性声明别名（用于元注解组合）\r\n\r\n\r\n@RequestScope\r\n定义 Bean 的作用域为 HTTP 请求级别\r\n\r\n\r\n@SessionScope\r\n定义 Bean 的作用域为 HTTP 会话级别\r\n\r\n\r\n@ApplicationScope\r\n定义 Bean 的作用域为 ServletContext 级别\r\n\r\n\r\n\r\n依赖注入（DI）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Autowired\r\n自动注入依赖（默认按类型匹配）\r\n\r\n\r\n@Qualifier\r\n按名称指定注入的 Bean，配合@Autowired使用\r\n\r\n\r\n@Primary\r\n当存在多个同类型 Bean 时，优先注入被标记的 Bean\r\n\r\n\r\n@Value\r\n注入属性值（如@Value(\"$&#123;key&#125;\")或 SpEL 表达式）\r\n\r\n\r\n@Required\r\n标记 Bean 属性为必需（已过时，推荐使用构造器注入）\r\n\r\n\r\n@Lookup\r\n声明查找方法，用于获取原型作用域的 Bean\r\n\r\n\r\n@Resource\r\nJSR-250 注解，按名称注入依赖（类似@Autowired +\r\n@Qualifier）\r\n\r\n\r\n@Inject\r\nJSR-330\r\n注解（需引入javax.inject），功能类似@Autowired\r\n\r\n\r\n\r\nAOP 与切面编程\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Aspect\r\n标记类为切面类\r\n\r\n\r\n@Pointcut\r\n定义切点表达式，指定切入点\r\n\r\n\r\n@Before\r\n在目标方法执行前执行\r\n\r\n\r\n@After\r\n在目标方法执行后执行（无论是否抛出异常）\r\n\r\n\r\n@AfterReturning\r\n在目标方法成功返回后执行\r\n\r\n\r\n@AfterThrowing\r\n在目标方法抛出异常后执行\r\n\r\n\r\n@Around\r\n环绕通知，可完全控制目标方法执行\r\n\r\n\r\n@EnableAspectJAutoProxy\r\n启用 AspectJ 自动代理（需配合@Configuration）\r\n\r\n\r\n@DeclareParents\r\n引入其他接口到目标类（实现接口增强）\r\n\r\n\r\n\r\n数据访问与事务\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Transactional\r\n声明事务管理（类或方法级别），可配置隔离级别、传播行为等\r\n\r\n\r\n@Repository\r\n标记数据访问层（DAO）组件，支持异常转换（如将 SQL 异常转换为 Spring\r\n异常）\r\n\r\n\r\n@PersistenceContext\r\n注入 JPA 的EntityManager\r\n\r\n\r\n@PersistenceUnit\r\n注入 JPA 的EntityManagerFactory\r\n\r\n\r\n@Sql\r\n在测试方法执行前 / 后运行 SQL 脚本\r\n\r\n\r\n@SqlMergeMode\r\n控制测试类与方法的@Sql注解合并方式\r\n\r\n\r\n\r\nWeb/MVC 相关\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Controller\r\n标记类为 MVC 控制器\r\n\r\n\r\n@RequestMapping\r\n映射 HTTP 请求路径（支持method\r\n、produces等属性）\r\n\r\n\r\n@RequestParam\r\n绑定请求参数到方法参数\r\n\r\n\r\n@PathVariable\r\n绑定 URL 路径变量到方法参数\r\n\r\n\r\n@RequestBody\r\n将请求体反序列化为对象（如 JSON/XML）\r\n\r\n\r\n@ResponseBody\r\n将方法返回值序列化为响应体（如 JSON）\r\n\r\n\r\n@ModelAttribute\r\n绑定请求参数到模型对象，或添加模型数据\r\n\r\n\r\n@SessionAttributes\r\n将模型属性存储到 HTTP Session 中\r\n\r\n\r\n@CookieValue\r\n绑定 Cookie 值到方法参数\r\n\r\n\r\n@RequestHeader\r\n绑定请求头到方法参数\r\n\r\n\r\n@ExceptionHandler\r\n处理控制器内的异常\r\n\r\n\r\n@ControllerAdvice\r\n全局异常处理类，可结合@ExceptionHandler\r\n\r\n\r\n@InitBinder\r\n自定义请求参数绑定逻辑\r\n\r\n\r\n@CrossOrigin\r\n允许跨域请求（Spring 4.2 + 支持）\r\n\r\n\r\n@RestController\r\n组合@Controller和@ResponseBody（Spring\r\n4.0+）\r\n\r\n\r\n@GetMapping/@PostMapping\r\n@RequestMapping的快捷方式（如@GetMapping(\"/path\")）\r\n\r\n\r\n@PutMapping\r\n@RequestMapping(method = PUT)的快捷方式\r\n\r\n\r\n@DeleteMapping\r\n@RequestMapping(method = DELETE)的快捷方式\r\n\r\n\r\n@PatchMapping\r\n@RequestMapping(method = PATCH)的快捷方式\r\n\r\n\r\n@MatrixVariable\r\n绑定 URL 矩阵变量（如/users;id=1）\r\n\r\n\r\n@RestControllerAdvice\r\n组合@ControllerAdvice和@ResponseBody\r\n\r\n\r\n@ResponseStatus\r\n定义 HTTP\r\n响应状态码（如@ResponseStatus(HttpStatus.NOT_FOUND)）\r\n\r\n\r\n\r\n测试相关\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@ContextConfiguration\r\n指定测试类的 Spring 配置（如 XML 或配置类）\r\n\r\n\r\n@WebAppConfiguration\r\n标记测试类需要加载 Web 应用上下文\r\n\r\n\r\n@DirtiesContext\r\n标记测试后需要重置 Spring 上下文\r\n\r\n\r\n@TestExecutionListeners\r\n自定义测试执行监听器\r\n\r\n\r\n@TestPropertySource\r\n为测试类指定属性文件或键值对\r\n\r\n\r\n@DynamicPropertySource\r\n动态注册测试属性（如集成测试中的数据库端口）\r\n\r\n\r\n@Sql\r\n在测试方法执行前 / 后运行 SQL 脚本\r\n\r\n\r\n\r\n事件与异步\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@EventListener\r\n标记方法为事件监听器（监听 Spring 事件）\r\n\r\n\r\n@Async\r\n标记方法为异步执行（需启用@EnableAsync）\r\n\r\n\r\n@EnableAsync\r\n启用异步方法执行支持\r\n\r\n\r\n@Scheduled\r\n定义定时任务（需启用@EnableScheduling）\r\n\r\n\r\n@EnableScheduling\r\n启用定时任务支持\r\n\r\n\r\n\r\n消息与 WebSocket\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@MessageMapping\r\n映射消息到处理方法（如 WebSocket 消息）\r\n\r\n\r\n@SubscribeMapping\r\n处理订阅请求（如 STOMP 协议）\r\n\r\n\r\n@SendTo\r\n指定方法返回值的发送目标（如广播消息）\r\n\r\n\r\n@DestinationVariable\r\n绑定消息目标路径中的变量\r\n\r\n\r\n@MessageExceptionHandler\r\n处理消息处理过程中的异常\r\n\r\n\r\n\r\n缓存相关\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Cacheable\r\n缓存方法结果（需启用@EnableCaching）\r\n\r\n\r\n@CachePut\r\n更新缓存\r\n\r\n\r\n@CacheEvict\r\n清除缓存\r\n\r\n\r\n@Caching\r\n组合多个缓存操作\r\n\r\n\r\n@CacheConfig\r\n在类级别统一配置缓存属性\r\n\r\n\r\n@EnableCaching\r\n启用缓存支持\r\n\r\n\r\n\r\n校验与格式化\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Valid\r\n触发 Bean 验证（JSR-303/JSR-349 规范，需引入 Hibernate\r\nValidator）\r\n\r\n\r\n@Validated\r\nSpring 的校验注解，支持分组校验\r\n\r\n\r\n@DateTimeFormat\r\n格式化日期时间字段（如@DateTimeFormat(pattern = \"yyyy-MM-dd\")）\r\n\r\n\r\n@NumberFormat\r\n格式化数字字段\r\n\r\n\r\n\r\nJSR 标准注解支持\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@PostConstruct\r\nJSR-250 注解，标记 Bean 初始化后执行的方法\r\n\r\n\r\n@PreDestroy\r\nJSR-250 注解，标记 Bean 销毁前执行的方法\r\n\r\n\r\n@Resource\r\nJSR-250 注解，按名称注入依赖（类似@Autowired +\r\n@Qualifier）\r\n\r\n\r\n@Inject\r\nJSR-330\r\n注解（需引入javax.inject），功能类似@Autowired\r\n\r\n\r\n@Named\r\nJSR-330\r\n注解，功能类似@Component或@Qualifier\r\n\r\n\r\n\r\n空安全注解\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@NonNull\r\n标记字段、参数或返回值不可为null（编译时检查）\r\n\r\n\r\n@Nullable\r\n标记字段、参数或返回值可为null\r\n\r\n\r\n@NonNullApi\r\n包级别注解，默认所有参数和返回值不可为null\r\n\r\n\r\n@NonNullFields\r\n包级别注解，默认所有字段不可为null\r\n\r\n\r\n\r\n响应式编程（WebFlux）\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@WebFluxTest\r\n针对 WebFlux 控制器的切片测试\r\n\r\n\r\n@EnableWebFlux\r\n启用 WebFlux 配置（替代@EnableWebMvc）\r\n\r\n\r\n\r\n国际化与资源\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@MessageSource\r\n注入国际化消息源（需配置ResourceBundleMessageSource）\r\n\r\n\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"SpringFrameworkPart7-JDBCTemplate事务-上","url":"/posts/58016.html","content":"什么是 JdbcTemplate\r\nSpring 框架对 JDBC 进行封装，使用 JdbcTemplate\r\n方便实现对数据库操作。\r\nJdbcTemplate 是 Spring 框架 提供的一个核心 JDBC\r\n工具类，位于 org.springframework.jdbc.core\r\n包中。它简化了 JDBC 数据库操作，避免了繁琐的 JDBC\r\n代码编写，提高了开发效率。\r\n在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。\r\n作用：\r\n\r\n执行 SQL 语句：JdbcTemplate 提供了多种方法来执行 SQL\r\n语句，包括查询、更新、插入、删除等。\r\n\r\n处理结果集：JdbcTemplate 可以自动将查询结果转换为 Java\r\n对象，简化了结果集的处理。\r\n\r\n管理数据库连接：JdbcTemplate\r\n自动管理数据库连接的获取和释放，避免了资源泄漏。\r\n\r\n处理异常：JdbcTemplate 将 JDBC 异常转换为 Spring\r\n的统一数据访问异常，方便进行异常处理。\r\n\r\n支持事务：JdbcTemplate 可以与 Spring\r\n的事务管理机制集成，实现事务控制。\r\n\r\nJava程序使用JDBC接口访问关系数据库的时候，需要以下几步：\r\n\r\n创建全局DataSource实例，表示数据库连接池；\r\n在需要读写数据库的方法内部，按如下步骤访问数据库：\r\n\r\n从全局DataSource实例获取Connection实例；\r\n通过Connection实例创建PreparedStatement实例；\r\n执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。\r\n\r\n\r\n正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务。\r\n实现CURD 增删改查\r\n我们可以将 JdbcTemplate 的创建权交给 Spring，将数据源 DataSource\r\n的创建权也交给 Spring\r\n在Spring容器内部将数据源 DataSource 注入到 JdbcTemplate\r\n模版对象中,然后通过 Spring 容器获得 JdbcTemplate 对象来执行操作\r\n准备工作\r\n新建子模块，引入如下依赖\r\n&lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;         &lt;scope&gt;runtime&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifactId&gt;lombok&lt;/artifactId&gt;         &lt;optional&gt;true&lt;/optional&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;\r\n创建 jdbc.properties，配置数据库连接池\r\n将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护\r\nspring.application.name=spring6-jdbcspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/SpringJDBCTemple?serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=truespring.datasource.username=spring.datasource.password=\r\n配置 Spring 的配置文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 开启组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6jdbc&quot;/&gt;    &lt;!-- 引入外部属性文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;spring.datasource.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;spring.datasource.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;spring.datasource.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置JdbcTemplate, 注入 DataSource--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启事务注解 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n创建需要连接的数据库\r\nCREATE DATABASE IF NOT EXISTS SpringJDBCTemple;USE SpringJDBCTemple;CREATE TABLE IF NOT EXISTS t_user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(50) NOT NULL,    age INT,    email VARCHAR(100)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \r\n进行测试\r\npackage edu.software.ergoutree.spring6jdbc;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass Spring6JdbcApplicationTests &#123;    @Test    public void testJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //通过接口来获取数据源对象        DataSource dataSource = ioc.getBean(&quot;dataSource&quot;, DataSource.class);        Connection connection = dataSource.getConnection();        System.out.println(&quot;dataSource&#x27;s class = &quot; + dataSource.getConnection());        System.out.println(&quot;connection = &quot; + connection);        connection.close();    &#125;&#125;\r\n通过 JDBCTemplate\r\n实现数据的添加，修改，删除\r\n实例\r\n向表中新增两条记录，用两种方法实现\r\n// 数据添加@Testpublic void InsertJdbcTemplate() throws SQLException &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    DataSource dataSource = ioc.getBean(&quot;dataSource&quot;, DataSource.class);    Connection connection = dataSource.getConnection();    System.out.println(&quot;dataSource&#x27;s class = &quot; + dataSource.getConnection());    System.out.println(&quot;connection = &quot; + connection);    JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);    String sql1 = &quot;INSERT INTO t_user VALUE (1113, &#x27;zjmd&#x27;, 23, &#x27;3783489@qq.com&#x27;);&quot;;    String sql2 = &quot;INSERT INTO t_user VALUE (?, ?, ?, ?);&quot;;    // 添加方式1  通过execute的方式    jdbcTemplate.execute(sql1);    //添加方式二 ：通过update方法添加，按照顺序传递参数    int affectedRows = jdbcTemplate.update(sql2, 221, &quot;wh&quot;, 34, &quot;234e3434@email.com&quot;);    System.out.println(&quot;affected rows = &quot; + affectedRows);    connection.close();&#125;\r\n测试通过，发现可以插入数据\r\n注意的是 excute()是 JDBC\r\n原生方法的简单封装，用于执行完整 SQL 字符串\r\n// 注意：需手动转义参数值，避免安全问题！int id = 111;String name = &quot;zjm&quot;;int age = 23;String unsafeSql = String.format(&quot;INSERT INTO t_user VALUES (%d, &#x27;%s&#x27;, %d)&quot;, id, name, age);jdbcTemplate.execute(unsafeSql); // 仅用于演示，生产环境禁止！// 只能做到静态sql语句的插入\r\n修改和删除的方法类\r\n// 数据修改    @Test    public void UpdateJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);        // 方式1：直接执行静态SQL        String sql1 = &quot;UPDATE t_user SET name=&#x27;zjm_updated&#x27;, age=25 WHERE id=1113&quot;;        jdbcTemplate.execute(sql1);        // 方式2：使用参数化SQL（推荐）        String sql2 = &quot;UPDATE t_user SET name=?, age=? WHERE id=?&quot;;        int affectedRows = jdbcTemplate.update(sql2, &quot;wh_updated&quot;, 35, 221);        System.out.println(&quot;Updated rows: &quot; + affectedRows);    &#125;\r\n// 数据删除    @Test    public void DeleteJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);        // 方式1：直接执行静态SQL        String sql1 = &quot;DELETE FROM t_user WHERE id=1113&quot;;        jdbcTemplate.execute(sql1);        // 方式2：使用参数化SQL（推荐）        String sql2 = &quot;DELETE FROM t_user WHERE id=?&quot;;        int affectedRows = jdbcTemplate.update(sql2, 221);        System.out.println(&quot;Deleted rows: &quot; + affectedRows);    &#125;\r\nupdate方法详解\r\n可以看到，JDBCTemplate对数据库的增删改操作都是update方法，执行最终的效果只根据语句有关系\r\nupdate 方法的主要作用是执行 SQL\r\n语句并返回受影响的行数。它可以执行的 SQL 语句包括\r\nINSERT、UPDATE 和 DELETE\r\n语句。\r\n返回值：update 方法的返回值是一个整数，表示 SQL\r\n语句执行后受影响的行数\r\n\r\n\r\nimage-20250427171122032\r\n\r\n其中方法的重载形式：\r\nint update(String sql)\r\n\r\n参数说明：\r\n\r\nsql：要执行的 SQL 语句。\r\n\r\n使用场景：当 SQL\r\n语句中不包含参数时，可以使用这个方法。例如，删除表中所有数据：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;DELETE FROM users&quot;;int rows = jdbcTemplate.update(sql);System.out.println(&quot;删除的行数: &quot; + rows);\r\nint update(String sql, @Nullable Object... args)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL 语句，其中可以包含占位符\r\n?。\r\nargs：SQL\r\n语句中占位符对应的参数值，参数的顺序要和占位符的顺序一致。\r\n\r\n使用场景：当 SQL\r\n语句中包含参数时，可以使用这个方法。例如，插入一条新记录：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;;Object[] args = &#123;&quot;John&quot;, 25&#125;;int rows = jdbcTemplate.update(sql, args);System.out.println(&quot;插入的行数: &quot; + rows);\r\nint update(String sql, PreparedStatementSetter pss)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL 语句，其中可以包含占位符\r\n?。\r\npss：一个 PreparedStatementSetter\r\n接口的实现类，用于设置 PreparedStatement 对象的参数。\r\n\r\n使用场景：当需要更复杂的参数设置逻辑时，可以使用这个方法。例如：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.PreparedStatementSetter;import java.sql.PreparedStatement;import java.sql.SQLException;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;UPDATE users SET age = ? WHERE name = ?&quot;;int age = 26;String name = &quot;John&quot;;int rows = jdbcTemplate.update(sql, new PreparedStatementSetter() &#123;    @Override    public void setValues(PreparedStatement ps) throws SQLException &#123;        ps.setInt(1, age);        ps.setString(2, name);    &#125;&#125;);System.out.println(&quot;更新的行数: &quot; + rows);\r\n异常处理\r\nupdate 方法可能会抛出 DataAccessException\r\n及其子类的异常，例如 SQLException\r\n等。在实际使用中，建议捕获这些异常并进行相应的处理。例如：\r\nimport org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;DELETE FROM users&quot;;try &#123;    int rows = jdbcTemplate.update(sql);    System.out.println(&quot;删除的行数: &quot; + rows);&#125; catch (DataAccessException e) &#123;    System.err.println(&quot;数据库操作出错: &quot; + e.getMessage());&#125;\r\n通过 JDBCTemplate\r\n实现数据的查询\r\n案例\r\n// 数据查询    @Test    public void SelectJdbcTemplate() throws SQLException &#123;        String sql = &quot;SELECT * FROM t_user WHERE id=?&quot;;        // 查询返回 Map        Map&lt;String, Object&gt; userMap = jdbcTemplate.queryForMap(sql, 1113);        System.out.println(&quot;User as Map: &quot; + userMap);        // 查询返回对象        // 写法1        User user = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; &#123;            User u = new User();            u.setId(rs.getInt(&quot;id&quot;));            u.setName(rs.getString(&quot;name&quot;));            u.setAge(rs.getInt(&quot;age&quot;));            u.setEmail(rs.getString(&quot;email&quot;));            return u;        &#125;, 1113);        System.out.println(&quot;User as Object: &quot; + user);        // 写法2        User user2 = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 1113);        System.out.println(&quot;User as Object: &quot; + user2);        // 返回集合        // 返回List&lt;User&gt;        List&lt;User&gt; users = jdbcTemplate.query(sql, (rs, rowNum) -&gt; &#123;            User u = new User();            u.setId(rs.getInt(&quot;id&quot;));            u.setName(rs.getString(&quot;name&quot;));            u.setAge(rs.getInt(&quot;age&quot;));            u.setEmail(rs.getString(&quot;email&quot;));            return u;        &#125;, 20);        System.out.println(&quot;Users as Objects: &quot; + users);        // 返回List&lt;Map&gt;        List&lt;Map&lt;String, Object&gt;&gt; userMaps = jdbcTemplate.queryForList(sql, 20);        System.out.println(&quot;Users as Maps: &quot; + userMaps);        // 返回单个值，查询有多少记录        String sql2 = &quot;select count(*) from t_user&quot;;        Integer count = jdbcTemplate.queryForObject(sql2, Integer.class);        System.out.println(&quot;Count of users: &quot; + count);    &#125;\r\nqueryForObject方法详解\r\n可以看到，JDBCTemplate对数据库的增删改操作都是queryForObject方法，执行的结果跟这个方法重载的各种类型有关系。\r\n在queryForObject()方法中，传入SQL以及SQL参数后，JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，我们提供的RowMapper需要做的事情就是把ResultSet的当前行映射成一个JavaBean并返回。整个过程中，使用Connection、PreparedStatement和ResultSet都不需要我们手动管理。\r\nJdbcTemplate 中的 queryForObject\r\n方法主要用于执行 SQL 查询语句，并期望返回单个结果对象（集合）.\r\nqueryForObject\r\n方法用于执行查询操作，且预期查询结果为单个对象。当你确定查询只会返回一条记录时，就可以使用这个方法将结果映射到指定的对象类型中。\r\n常见重载形式\r\nT queryForObject(String sql, Class requiredType)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL\r\n查询语句，此语句一般用于查询单个值，如查询某一列的总和、平均值等。\r\n\r\nrequiredType：期望返回结果的类型，比如\r\nInteger、String 等。\r\n使用场景：当查询结果是单个值时使用。例如，查询\r\nusers 表中的用户总数：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT COUNT(*) FROM users&quot;;Integer userCount = jdbcTemplate.queryForObject(sql, Integer.class);System.out.println(&quot;用户总数: &quot; + userCount);\r\nT queryForObject(String sql, Object[] args, Class requiredType)\r\n\r\n参数说明\r\n\r\nsql：包含占位符 ? 的 SQL 查询语句。\r\n\r\nargs：SQL\r\n语句中占位符对应的参数值数组，参数顺序需与占位符顺序一致。\r\n\r\nrequiredType：期望返回结果的类型。\r\n\r\n使用场景：当查询语句包含参数且结果为单个值时使用。例如，查询名为\r\nJohn 的用户的年龄：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT age FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;John&quot;&#125;;Integer age = jdbcTemplate.queryForObject(sql, args, Integer.class);System.out.println(&quot;John 的年龄: &quot; + age);\r\nT queryForObject(String sql, RowMapper rowMapper)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL 查询语句，用于查询完整的记录。\r\n\r\nrowMapper：RowMapper\r\n接口的实现类，用于将查询结果集中的每一行数据映射到指定类型的对象。\r\n使用场景：当查询结果是一条完整的记录，需要将其映射到自定义对象时使用。例如，查询\r\nid 为 1 的用户信息\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT * FROM users WHERE id = 1&quot;;User user = jdbcTemplate.queryForObject(sql, new RowMapper&lt;User&gt;() &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        return user;    &#125;&#125;);System.out.println(user);\r\nT queryForObject(String sql, Object[] args, RowMapper rowMapper)\r\n\r\n参数说明\r\n\r\nsql：包含占位符 ? 的 SQL 查询语句。\r\n\r\nargs：SQL 语句中占位符对应的参数值数组。\r\n\r\nrowMapper：RowMapper\r\n接口的实现类，用于将查询结果集中的每一行数据映射到指定类型的对象。\r\n\r\n使用场景：当查询语句包含参数，且需要将查询结果映射到自定义对象时使用。例如，查询名为\r\nJohn 的用户信息：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT * FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;John&quot;&#125;;User user = jdbcTemplate.queryForObject(sql, args, new RowMapper&lt;User&gt;() &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        return user;    &#125;&#125;);System.out.println(user);\r\n返回值\r\nqueryForObject\r\n方法的返回值是一个指定类型的对象。如果查询结果为空，该方法可能会抛出\r\nEmptyResultDataAccessException\r\n异常；如果查询结果有多条记录，也会抛出异常。\r\n异常处理\r\n在使用 queryForObject\r\n方法时，需要注意处理可能抛出的异常，如\r\nEmptyResultDataAccessException 和\r\nIncorrectResultSizeDataAccessException。\r\nimport org.springframework.dao.EmptyResultDataAccessException;import org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT age FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;NonExistentUser&quot;&#125;;try &#123;    Integer age = jdbcTemplate.queryForObject(sql, args, Integer.class);    System.out.println(&quot;年龄: &quot; + age);&#125; catch (EmptyResultDataAccessException e) &#123;    System.err.println(&quot;未找到符合条件的记录: &quot; + e.getMessage());&#125;\r\n更进阶的使用\r\n数据批量处理\r\nJdbcTemplate 提供 batchUpdate()\r\n方法实现批量操作，适合一次性处理大量数据，提升性能。\r\n参数说明：\r\n\r\nbatchUpdate(String sql, List batchArgs)：\r\n\r\nbatchArgs 中每个 Object[] 对应 SQL\r\n中的一组参数。\r\n\r\n\r\n@Testpublic void BatchInsertJdbcTemplate() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (?, ?, ?)&quot;;        // 批量数据：参数为 Object 数组的集合    List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();    batchArgs.add(new Object[]&#123;&quot;Alice&quot;, 28, &quot;alice@example.com&quot;&#125;);    batchArgs.add(new Object[]&#123;&quot;Bob&quot;, 32, &quot;bob@example.com&quot;&#125;);    batchArgs.add(new Object[]&#123;&quot;Charlie&quot;, 25, &quot;charlie@example.com&quot;&#125;);    // 执行批量插入    int[] affectedRows = jdbcTemplate.batchUpdate(sql, batchArgs);    System.out.println(&quot;插入行数统计: &quot; + Arrays.toString(affectedRows));&#125;\r\n查询到的数据封装到 Bean 对象\r\n通过 RowMapper 或 BeanPropertyRowMapper\r\n将结果集自动映射到 Java 对象。\r\n自定义 RowMapper\r\npublic class UserRowMapper implements RowMapper&lt;User&gt; &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        user.setEmail(rs.getString(&quot;email&quot;));        return user;    &#125;&#125;// 使用示例@Testpublic void QueryWithCustomRowMapper() &#123;    String sql = &quot;SELECT * FROM t_user WHERE age &gt; ?&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         new UserRowMapper(),         20  // 参数：age &gt; 20    );    System.out.println(&quot;Users: &quot; + users);&#125;\r\n使用 BeanPropertyRowMapper\r\nSpring 提供的自动映射工具，要求数据库字段名与 Java 对象属性名一致（如\r\nuser_name → userName）。\r\n@Testpublic void QueryWithBeanPropertyRowMapper() &#123;    String sql = &quot;SELECT * FROM t_user&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         new BeanPropertyRowMapper&lt;&gt;(User.class)    );    System.out.println(&quot;Users: &quot; + users);&#125;\r\n查询到的数据以Bean对象的形式封装到集合中\r\n直接使用 query() 方法返回\r\nList，适用于查询多条记录。\r\n@Testpublic void QueryAllUsersAsBeanList() &#123;    String sql = &quot;SELECT * FROM t_user&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         (rs, rowNum) -&gt; &#123;            User user = new User();            user.setId(rs.getInt(&quot;id&quot;));            user.setName(rs.getString(&quot;name&quot;));            user.setAge(rs.getInt(&quot;age&quot;));            user.setEmail(rs.getString(&quot;email&quot;));            return user;        &#125;    );    System.out.println(&quot;All Users: &quot; + users);&#125;\r\n查询单行单列的具体字段\r\n使用 queryForObject() 直接返回基本类型值（如\r\nInteger, String）。\r\n@Testpublic void QuerySingleValue() &#123;    // 查询最大年龄    String sqlMaxAge = &quot;SELECT MAX(age) FROM t_user&quot;;    Integer maxAge = jdbcTemplate.queryForObject(sqlMaxAge, Integer.class);    System.out.println(&quot;最大年龄: &quot; + maxAge);    // 查询特定用户的邮箱    String sqlEmail = &quot;SELECT email FROM t_user WHERE name = ?&quot;;    String email = jdbcTemplate.queryForObject(        sqlEmail,         String.class,         &quot;Alice&quot;    );    System.out.println(&quot;Alice 的邮箱: &quot; + email);&#125;\r\n使用具名参数添加数据\r\n以往我们使用SQL语句时，总是用到占位符 ?\r\n，就像我们上面刚刚用到的SQL语句\r\n这么做有个问题——除非我们知道对应表的结构，不然就无法确定这个占位符?\r\n应该传入什么参数。\r\n使用具名参数可以很好的解决这个问题。\r\n通过 NamedParameterJdbcTemplate 支持具名参数（如\r\n:name），提升 SQL 可读性。\r\n首先在之前的 xml 配置文件下新配置一个 NamedParameterJdbcTemplate\r\n对象，如下\r\n&lt;bean id=&quot;namedParameterJdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;\r\n@Testpublic void InsertWithNamedParameters() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    NamedParameterJdbcTemplate namedTemplate = ioc.getBean(        &quot;namedParameterJdbcTemplate&quot;,         NamedParameterJdbcTemplate.class    );    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (:name, :age, :email)&quot;;        // 使用 Map 传递参数    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();    params.put(&quot;name&quot;, &quot;David&quot;);    params.put(&quot;age&quot;, 29);    params.put(&quot;email&quot;, &quot;david@example.com&quot;);    int affectedRows = namedTemplate.update(sql, params);    System.out.println(&quot;插入行数: &quot; + affectedRows);&#125;\r\n使用 SqlParameterSource\r\n更灵活的传参方式（支持 Bean 对象自动映射）：\r\n@Testpublic void InsertWithSqlParameterSource() &#123;    NamedParameterJdbcTemplate namedTemplate = ...; // 获取 Bean    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (:name, :age, :email)&quot;;        // 使用 BeanPropertySqlParameterSource    User newUser = new User();    newUser.setName(&quot;Eva&quot;);    newUser.setAge(27);    newUser.setEmail(&quot;eva@example.com&quot;);        SqlParameterSource params = new BeanPropertySqlParameterSource(newUser);    int affectedRows = namedTemplate.update(sql, params);    System.out.println(&quot;插入行数: &quot; + affectedRows);&#125;\r\n总结\r\n我们总结一下JdbcTemplate的用法，那就是：\r\n\r\n针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper；\r\n针对更新操作，优选update()，因为只需提供SQL语句和参数；\r\n任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。\r\n\r\n实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。\r\n例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下\r\nSELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringFrameworkPart7-JDBCTemplate事务-下","url":"/posts/8801.html","content":"声明式事务控制\r\n关于事务\r\n理解事务\r\n事务是一组操作的执行单元，相对于数据库操作来讲，事务管理的是一组SQL指令，比如增加，修改，删除等\r\n事务的一致性，要求，这个事务内的操作必须全部执行成功，如果在此过程种出现了差错，比如有一条SQL语句没有执行成功，那么这一组操作都将全部回滚\r\n事务由事务开始和事务结束之间执行的全部数据库操作组成。\r\n事务四大特性\r\n原子性A：事务是不可分割的最小操作单元，要么全成功，要么全失败\r\n一致性C：事务完成时，必须所据都保持一致状态\r\n隔离性I：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下进行\r\n持久性D：事务一旦提交或回滚，他对数据库的改变是永久的\r\n声明式事务控制\r\n理解声明式事务\r\nSpring\r\n对事务逻辑的代码有封装，在配置文件中或者注解管理即可实现相关操作\r\nSpring\r\n的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在Spring\r\n配置文件中声明式的处理事务来代替代码式的处理事务\r\n声明式事务处理的作用\r\n\r\n事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可\r\n在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便\r\n\r\nSpring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。如果手写事务代码，使用try...catch如下\r\nTransactionStatus tx = null;try &#123;    // 开启事务:    tx = txManager.getTransaction(new DefaultTransactionDefinition());    // 相关JDBC操作:    jdbcTemplate.update(&quot;...&quot;);    jdbcTemplate.update(&quot;...&quot;);    // 提交事务:    txManager.commit(tx);&#125; catch (RuntimeException e) &#123;    // 回滚事务:    txManager.rollback(tx);    throw e;&#125;\r\nSpring为啥要抽象出PlatformTransactionManager和TransactionStatus？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java\r\nTransaction\r\nAPI）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。\r\nSpring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager。因为我们的代码只需要JDBC事务，因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：\r\n@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\r\nSpring 声明式事务控制底层就是AOP\r\n编程式：自己写代码实现功能\r\n声明式：通过配置让框架实现框架实现\r\n编程式事务控制\r\n相关对象\r\nPlatformTransactionManager\r\nPlatformTransactionManager 接口是 spring\r\n的事务管理器，它里面提供了我们常用的操作事务的方法。例如获取事务状态、提交事务和回滚事务等。\r\n\r\n\r\nimg\r\n\r\nPlatformTransactionManager是接口类型，不同的 Dao\r\n层技术则有不同的实现类\r\n例如：\r\n\r\nDao 层技术是jdbc 或 mybatis\r\n时：org.springframework.jdbc.datasource.DataSourceTransactionManager\r\nDao\r\n层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager\r\n\r\nTransactionDefinition\r\nTransactionDefinition\r\n是事务的定义信息对象，包含了事务的隔离级别、传播行为、超时时间和是否只读等信息。\r\n\r\n\r\n在这里插入图片描述\r\n\r\nTransactionStatus\r\nTransactionStatus\r\n接口提供的是事务具体的运行状态，方法介绍如下。\r\n在 Spring 的编程式事务管理里，TransactionStatus 对象由\r\nPlatformTransactionManager 的 getTransaction()\r\n方法返回。它记录了事务的当前状态，例如事务是否为新开启的、是否已完成等，并且能让开发者对事务进行控制，比如提交或者回滚事务。\r\n常用方法\r\n\r\nisNewTransaction()\r\n\r\n\r\n功能：判断当前事务是否为新开启的事务。若返回\r\ntrue，表示该事务是在此次调用 getTransaction()\r\n方法时新开启的；若返回\r\nfalse，则说明当前事务是已存在事务的一部分（比如在事务传播行为是\r\nREQUIRED 时，加入了已有的事务）。\r\n\r\n\r\nhasSavepoint()\r\n\r\n\r\n功能：判断当前事务是否有保存点。保存点是事务中的一个标记，可让事务部分回滚到该标记处，而非整个事务回滚。\r\n\r\n\r\nsetRollbackOnly()\r\n\r\n\r\n功能：将当前事务标记为仅回滚。一旦调用此方法，事务在结束时会被强制回滚，即便后续代码尝试提交事务也不会生效。\r\n\r\n\r\nisRollbackOnly()\r\n\r\n\r\n功能：检查当前事务是否已被标记为仅回滚。\r\n\r\n\r\nisCompleted()\r\n\r\n\r\n功能：判断事务是否已经完成，即是否已经提交或者回滚。\r\n\r\n声明式事务控制说明\r\n使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：\r\n@Configuration@ComponentScan@EnableTransactionManagement // 启用声明式@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;\r\n然后，对需要事务支持的方法，加一个@Transactional注解：\r\n@Componentpublic class UserService &#123;    // 此public方法自动具有事务支持:    @Transactional    public User register(String email, String password, String name) &#123;       ...    &#125;&#125;\r\n或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：\r\n@Component@Transactionalpublic class UserService &#123;    ...&#125;\r\n事务隔离级别\r\nSQL 标准定义了四种隔离级别，MySQL\r\n全都支持。这四种隔离级别分别是：\r\n\r\n读未提交（READ UNCOMMITTED）\r\n读提交 （READ COMMITTED）\r\n可重复读 （REPEATABLE READ）\r\n串行化 （SERIALIZABLE）\r\n\r\n从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是\r\nMySQL 的默认级别。\r\n事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了\r\n4 种隔离级别对这三个问题的解决程度\r\n\r\n\r\nimg\r\n\r\n事务传播行为\r\n\r\nREQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）\r\nSUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）\r\nMANDATORY：使用当前的事务，如果当前没有事务，就抛出异常\r\nREQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。\r\nNOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\r\nNEVER：以非事务方式运行，如果当前存在事务，抛出异常\r\nNESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行\r\nREQUIRED 类似的操作\r\n超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置\r\n是否只读：建议查询时设置为只读\r\n\r\n示例\r\n假设我们有一个简单的用户账户表，需要进行转账操作。\r\n我们需要配置 Spring 的上下文和数据源\r\n&lt;!-- applicationContext.xml --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置 JdbcTemplate --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置业务服务 --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.example.AccountService&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n然后，我们创建一个 AccountService 类来处理转账业务：\r\npackage com.example;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.TransactionDefinition;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.DefaultTransactionDefinition;public class AccountService &#123;    private JdbcTemplate jdbcTemplate;    private PlatformTransactionManager transactionManager;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;        this.transactionManager = transactionManager;    &#125;    public void transferMoney(int fromAccountId, int toAccountId, double amount) &#123;        // 定义事务属性        TransactionDefinition def = new DefaultTransactionDefinition();        // 获取事务状态        TransactionStatus status = transactionManager.getTransaction(def);        try &#123;            // 减少转出账户的余额            jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, amount, fromAccountId);            // 模拟异常            // int result = 1 / 0;            // 增加转入账户的余额            jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, amount, toAccountId);            // 提交事务            transactionManager.commit(status);        &#125; catch (Exception e) &#123;            // 回滚事务            transactionManager.rollback(status);            e.printStackTrace();        &#125;    &#125;&#125;\r\n最后，我们可以编写一个测试类来调用 AccountService 的\r\ntransferMoney 方法\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123;    public static void main(String[] args) &#123;        // 加载 Spring 上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        // 获取 AccountService 实例        AccountService accountService = (AccountService) context.getBean(&quot;accountService&quot;);        // 执行转账操作        accountService.transferMoney(1, 2, 100.0);    &#125;&#125;\r\n在这个示例中，我们使用 PlatformTransactionManager 和\r\nTransactionDefinition 来手动管理事务。在\r\ntransferMoney\r\n方法中，我们首先获取事务状态，然后执行数据库操作，如果操作过程中出现异常，我们会回滚事务，否则提交事务。\r\n基于 XML 的声明式事务控制\r\nSpring\r\n的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在\r\nSpring 配置文件中声明式的处理事务来代替代码式的处理事务。\r\n声明式事务控制明确事项：\r\n\r\n谁是切点？\r\n谁是通知？\r\n配置切面？\r\n\r\n配置事务管理器与命名空间\r\n在 applicationContext.xml\r\n中添加事务相关命名空间及事务管理器配置：\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;           http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd           http://www.springframework.org/schema/tx           http://www.springframework.org/schema/tx/spring-tx.xsd           http://www.springframework.org/schema/aop           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 数据源配置（同上） --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- JdbcTemplate 配置（同上） --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 业务服务 --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.example.AccountService&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 声明式事务配置 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 配置事务属性：方法名匹配规则 --&gt;            &lt;tx:method name=&quot;transferMoney&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;                        timeout=&quot;-1&quot; read-only=&quot;false&quot; rollback-for=&quot;Exception&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- AOP 切面配置 --&gt;    &lt;aop:config&gt;        &lt;!-- 定义切点：匹配业务层方法 --&gt;        &lt;aop:pointcut id=&quot;servicePointcut&quot;                       expression=&quot;execution(* com.example.AccountService.*(..))&quot;/&gt;        &lt;!-- 将事务通知与切点关联 --&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\r\n\r\n\r\n\r\n配置项\r\n作用\r\n\r\n\r\n\r\n\r\n&lt;tx:advice&gt;\r\n定义事务通知，指定事务管理器和事务属性\r\n\r\n\r\n&lt;tx:method&gt;\r\n配置具体方法的事务规则（如传播行为、隔离级别）\r\n\r\n\r\n&lt;aop:pointcut&gt;\r\n定义切点，匹配需要事务管理的方法\r\n\r\n\r\n&lt;aop:advisor&gt;\r\n将事务通知与切点关联，实现声明式事务控制\r\n\r\n\r\n\r\n移除 AccountService 中的\r\nPlatformTransactionManager 依赖和手动事务管理代码：\r\npackage com.example;import org.springframework.jdbc.core.JdbcTemplate;public class AccountService &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public void transferMoney(int fromAccountId, int toAccountId, double amount) &#123;        // 减少转出账户的余额        jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, amount, fromAccountId);        // 模拟异常（测试回滚）        // int result = 1 / 0;        // 增加转入账户的余额        jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, amount, toAccountId);    &#125;&#125;\r\n事务属性详解\r\n在 &lt;tx:method&gt; 标签中配置事务规则：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n属性\r\n说明\r\n\r\n\r\n\r\n\r\nname\r\n匹配的方法名（支持通配符，如 * 表示所有方法）\r\n\r\n\r\npropagation\r\n事务传播行为（默认 REQUIRED）\r\n\r\n\r\nisolation\r\n事务隔离级别（默认\r\nDEFAULT，使用数据库默认隔离级别）\r\n\r\n\r\ntimeout\r\n事务超时时间（单位秒，默认 -1 表示不超时）\r\n\r\n\r\nread-only\r\n是否只读事务（默认 false，查询操作建议设为\r\ntrue）\r\n\r\n\r\nrollback-for\r\n触发回滚的异常类型（如 Exception\r\n表示所有异常均回滚）\r\n\r\n\r\nno-rollback-for\r\n不触发回滚的异常类型\r\n\r\n\r\n\r\n编写测试类验证事务是否生效\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        AccountService accountService = (AccountService) context.getBean(&quot;accountService&quot;);        try &#123;            // 正常转账（事务提交）            accountService.transferMoney(1, 2, 100.0);                        // 模拟异常（事务回滚）            // accountService.transferMoney(1, 2, 100.0); // 内部有 int result = 1 / 0;        &#125; catch (Exception e) &#123;            System.err.println(&quot;事务回滚：&quot; + e.getMessage());        &#125;    &#125;&#125;\r\n基于注解的声明式事务控制\r\n注解的方式，只需在方法上面加一个@Transaction注解，那么方法执行之前spring会自动开启一个事务，方法执行完毕之后，会自动提交或者回滚事务，而方法内部没有任何事务相关代码，用起来特别的方便。\r\n将会通过如下完整示例进行说明\r\n首先创建数据库表\r\n-- 银行账户表CREATE TABLE IF NOT EXISTS t_account (    id INT PRIMARY KEY AUTO_INCREMENT,    account_no VARCHAR(20) NOT NULL UNIQUE,    account_name VARCHAR(50) NOT NULL,    balance DECIMAL(10,2) NOT NULL DEFAULT 0.00,    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- 交易记录表CREATE TABLE IF NOT EXISTS t_transaction (    id INT PRIMARY KEY AUTO_INCREMENT,    from_account_id INT NOT NULL,    to_account_id INT NOT NULL,    amount DECIMAL(10,2) NOT NULL,    transaction_time DATETIME DEFAULT CURRENT_TIMESTAMP,    status VARCHAR(20) NOT NULL,    remark VARCHAR(200),    FOREIGN KEY (from_account_id) REFERENCES t_account(id),    FOREIGN KEY (to_account_id) REFERENCES t_account(id)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n创建实体类\r\n// 实体类 账户package edu.software.ergoutree.spring6jdbc.affairs.entity;import lombok.Data;import java.math.BigDecimal;import java.time.LocalDateTime;@Datapublic class Account &#123;    private Integer id;    private String accountNo;    private String accountName;    private BigDecimal balance;    private LocalDateTime createTime;    private LocalDateTime updateTime;&#125;\r\n// 实体类 表示一次交易package edu.software.ergoutree.spring6jdbc.affairs.entity;import lombok.Data;import java.math.BigDecimal;import java.time.LocalDateTime;@Datapublic class Transaction &#123;    private Integer id;    private Integer fromAccountId;    private Integer toAccountId;    private BigDecimal amount;    private LocalDateTime transactionTime;    private String status;    private String remark;&#125;\r\n创建 DAO 层\r\npackage edu.software.ergoutree.spring6jdbc.affairs.dao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import java.math.BigDecimal;// 账户数据访问对象的接口public interface AccountDao &#123;    Account findById(Integer id);   // 根据账户 ID 查询账户信息    Account findByAccountNo(String accountNo);   // 根据账户号码查询账户信息    void updateBalance(Integer id, BigDecimal balance);   // 更新指定账户的余额    void save(Account account);   // 保存新的账户信息到数据库&#125;\r\n// 实现了 AccountDao 接口，使用 JdbcTemplate 与数据库进行交互。package edu.software.ergoutree.spring6jdbc.affairs.dao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.math.BigDecimal;@Repositorypublic class AccountDaoImpl implements AccountDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public Account findById(Integer id) &#123;        String sql = &quot;SELECT * FROM t_account WHERE id = ?&quot;;        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), id);    &#125;    @Override    public Account findByAccountNo(String accountNo) &#123;        String sql = &quot;SELECT * FROM t_account WHERE account_no = ?&quot;;        // 将查询结果映射到 Account 实体类。        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), accountNo);    &#125;    @Override    public void updateBalance(Integer id, BigDecimal balance) &#123;        String sql = &quot;UPDATE t_account SET balance = ? WHERE id = ?&quot;;        jdbcTemplate.update(sql, balance, id);    &#125;    @Override    public void save(Account account) &#123;        String sql = &quot;INSERT INTO t_account (account_no, account_name, balance) VALUES (?, ?, ?)&quot;;        jdbcTemplate.update(sql, account.getAccountNo(), account.getAccountName(), account.getBalance());    &#125;&#125;\r\n创建 Service 层\r\npackage edu.software.ergoutree.spring6jdbc.affairs.service;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import java.math.BigDecimal;// 定义了账户服务的接口public interface AccountService &#123;    void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount);  // 转账    Account createAccount(Account account);   // 新建账户    Account getAccount(String accountNo);   // 根据账户号码查询账户信息&#125; \r\npackage edu.software.ergoutree.spring6jdbc.affairs.service;import edu.software.ergoutree.spring6jdbc.affairs.dao.AccountDao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.math.BigDecimal;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao accountDao;    @Override    // @Transactional 用于声明事务的属性    @Transactional(        propagation = Propagation.REQUIRED,        rollbackFor = Exception.class,   // 任何异常都会触发回滚。        timeout = 30    )    public void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;        // 查询转出账户        Account fromAccount = accountDao.findByAccountNo(fromAccountNo);        if (fromAccount == null) &#123;            throw new RuntimeException(&quot;转出账户不存在&quot;);        &#125;        // 查询转入账户        Account toAccount = accountDao.findByAccountNo(toAccountNo);        if (toAccount == null) &#123;            throw new RuntimeException(&quot;转入账户不存在&quot;);        &#125;        // 检查余额是否足够        if (fromAccount.getBalance().compareTo(amount) &lt; 0) &#123;            throw new RuntimeException(&quot;账户余额不足&quot;);        &#125;        // 执行转账        BigDecimal fromBalance = fromAccount.getBalance().subtract(amount);        BigDecimal toBalance = toAccount.getBalance().add(amount);        // 更新账户余额        accountDao.updateBalance(fromAccount.getId(), fromBalance);        accountDao.updateBalance(toAccount.getId(), toBalance);    &#125;    @Override    @Transactional(propagation = Propagation.REQUIRED)    public Account createAccount(Account account) &#123;        accountDao.save(account);        return account;    &#125;    @Override    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)    public Account getAccount(String accountNo) &#123;        return accountDao.findByAccountNo(accountNo);    &#125;&#125; \r\n我们对需使用事务的目标上加@Transaction注解\r\n\r\n@Transaction放在接口上，那么接口的实现类中所有public都被spring自动加上事务\r\n@Transaction放在类上，那么当前类以及其下无限级子类中所有pubilc方法将被spring自动加上事务\r\n@Transaction放在public方法上，那么该方法将被spring自动加上事务\r\n注意：@Transaction只对public方法有效\r\n\r\n下面我们看一下@Transactional源码：\r\n@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Transactional &#123;     /**     * 指定事务管理器的bean名称，如果容器中有多事务管理器PlatformTransactionManager，     * 那么你得告诉spring，当前配置需要使用哪个事务管理器     */    @AliasFor(&quot;transactionManager&quot;)    String value() default &quot;&quot;;     /**     * 同value，value和transactionManager选配一个就行，也可以为空，如果为空，默认会从容器中按照类型查找一个事务管理器bean     */    @AliasFor(&quot;value&quot;)    String transactionManager() default &quot;&quot;;     /**     * 事务的传播属性     */    Propagation propagation() default Propagation.REQUIRED;     /**     * 事务的隔离级别，就是制定数据库的隔离级别，数据库隔离级别大家知道么？不知道的可以去补一下     */    Isolation isolation() default Isolation.DEFAULT;     /**     * 事务执行的超时时间（秒），执行一个方法，比如有问题，那我不可能等你一天吧，可能最多我只能等你10秒     * 10秒后，还没有执行完毕，就弹出一个超时异常吧     */    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;     /**     * 是否是只读事务，比如某个方法中只有查询操作，我们可以指定事务是只读的     * 设置了这个参数，可能数据库会做一些性能优化，提升查询速度     */    boolean readOnly() default false;     /**     * 定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常及其子类异常的时候，spring会让事务回滚     * 如果不配做，那么默认会在 RuntimeException 或者 Error 情况下，事务才会回滚      */    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;     /**     * 和 rollbackFor 作用一样，只是这个地方使用的是类名     */    String[] rollbackForClassName() default &#123;&#125;;     /**     * 定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常的时候，事务不会回滚     */    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;     /**     * 和 noRollbackFor 作用一样，只是这个地方使用的是类名     */    String[] noRollbackForClassName() default &#123;&#125;; &#125;\r\n参数介绍\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数\r\n描述\r\n\r\n\r\n\r\n\r\nvalue\r\n指定事务管理器的bean名称，如果容器中有多事务管理器PlatformTransactionManager，那么你得告诉spring，当前配置需要使用哪个事务管理器\r\n\r\n\r\ntransactionManager\r\n同value，value和transactionManager选配一个就行，也可以为空，如果为空，默认会从容器中按照类型查找一个事务管理器bean\r\n\r\n\r\npropagation\r\n事务的传播属性，下篇文章详细介绍\r\n\r\n\r\nisolation\r\n事务的隔离级别，就是制定数据库的隔离级别，数据库隔离级别大家知道么？不知道的可以去补一下\r\n\r\n\r\ntimeout\r\n事务执行的超时时间（秒），执行一个方法，比如有问题，那我不可能等你一天吧，可能最多我只能等你10秒\r\n10秒后，还没有执行完毕，就弹出一个超时异常吧\r\n\r\n\r\nreadOnly\r\n是否是只读事务，比如某个方法中只有查询操作，我们可以指定事务是只读的\r\n设置了这个参数，可能数据库会做一些性能优化，提升查询速度\r\n\r\n\r\nrollbackFor\r\n定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常及其子类异常的时候，spring会让事务回滚\r\n如果不配做，那么默认会在 RuntimeException 或者 Error\r\n情况下，事务才会回滚\r\n\r\n\r\nrollbackForClassName\r\n同 rollbackFor，只是这个地方使用的是类名\r\n\r\n\r\nnoRollbackFor\r\n定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常的时候，事务不会回滚\r\n\r\n\r\nnoRollbackForClassName\r\n同 noRollbackFor，只是这个地方使用的是类名\r\n\r\n\r\n\r\n通过 @Transactional 注解，Spring\r\n会自动管理事务的开始、提交和回滚。在@Transaction标注类或者目标方法上执行业务操作，此时这些方法会自动被spring进行事务管理\r\n在 transfer\r\n方法中，如果在转账过程中出现任何异常，事务会自动回滚，确保数据的一致性\r\n下面讲解一些出现的注解：\r\n\r\n@Transactional注解 ：用于声明事务的属性。\r\n\r\npropagation：事务传播行为\r\n\r\nPropagation.REQUIRED\r\n表示如果当前没有事务，则创建一个新事务；如果已经存在一个事务，则加入该事务。\r\nPropagation.SUPPORTS\r\n表示如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行。\r\n\r\nrollbackFor：指定哪些异常会触发事务回滚，这里指定为\r\nException.class 表示任何异常都会触发回滚。\r\ntimeout：指定事务的超时时间，单位为秒。\r\nreadOnly：指定事务是否为只读事务，用于提高查询性能。\r\nisolation ：指定事务的隔离级别\r\n\r\n\r\n扩展事务功能\r\n嵌套事务与传播行为 REQUIRES_NEW\r\n场景: 日志记录操作需要独立事务，不受主事务回滚影响。\r\n@Servicepublic class LogService &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    // 独立事务：即使转账失败，日志仍需记录    @Transactional(propagation = Propagation.REQUIRES_NEW)    public void logTransaction(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;        String sql = &quot;INSERT INTO t_transaction (from_account_id, to_account_id, amount, status) VALUES (?, ?, ?, ?)&quot;;        jdbcTemplate.update(sql, fromAccountNo, toAccountNo, amount, &quot;PROCESSING&quot;);    &#125;&#125;// 修改 AccountServiceImpl 的转账方法@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;    // ...原有逻辑...    // 记录交易日志（独立事务）    logService.logTransaction(fromAccountNo, toAccountNo, amount);    // 模拟异常（主事务回滚，但日志记录成功）    // int a = 1 / 0;&#125;\r\n控制隔离级别和只读事务的配置\r\n// 控制隔离级别解决脏读问题@Transactional(isolation = Isolation.READ_COMMITTED)public BigDecimal getAccountBalance(String accountNo) &#123;    return accountDao.findByAccountNo(accountNo).getBalance();&#125;// 只读事务优化查询@Transactional(readOnly = true)public List&lt;Transaction&gt; getTransactionHistory(String accountNo) &#123;    return accountDao.getTransactionHistory(accountNo);&#125;\r\n注解优先级和类级的配置\r\n@Service@Transactional(isolation = Isolation.READ_COMMITTED, timeout = 10) // 类级默认配置public class AccountServiceImpl implements AccountService &#123;    @Override    @Transactional(isolation = Isolation.SERIALIZABLE, timeout = 30) // 方法级覆盖    public void highConcurrencyTransfer(...) &#123; ... &#125;&#125;\r\n若容器中存在多个事务管理器，需通过 transactionManager\r\n指定：\r\n@Transactional(transactionManager = &quot;orderTransactionManager&quot;)public void createOrder(...) &#123; ... &#125;\r\n新建一个测试类测试上述代码能否正常执行\r\npackage edu.software.ergoutree.spring6jdbc.affairs;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import edu.software.ergoutree.spring6jdbc.affairs.service.AccountService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import java.math.BigDecimal;import static org.junit.jupiter.api.Assertions.*;@SpringBootTest@Transactionalpublic class AccountServiceTest &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer() &#123;        // 创建两个账户        Account account1 = new Account();        account1.setAccountNo(&quot;1001&quot;);        account1.setAccountName(&quot;张三&quot;);        account1.setBalance(new BigDecimal(&quot;1000.00&quot;));        accountService.createAccount(account1);        Account account2 = new Account();        account2.setAccountNo(&quot;1002&quot;);        account2.setAccountName(&quot;李四&quot;);        account2.setBalance(new BigDecimal(&quot;500.00&quot;));        accountService.createAccount(account2);        // 执行转账        accountService.transfer(&quot;1001&quot;, &quot;1002&quot;, new BigDecimal(&quot;200.00&quot;));        // 验证转账结果        Account updatedAccount1 = accountService.getAccount(&quot;1001&quot;);        Account updatedAccount2 = accountService.getAccount(&quot;1002&quot;);        assertEquals(new BigDecimal(&quot;800.00&quot;), updatedAccount1.getBalance());        assertEquals(new BigDecimal(&quot;700.00&quot;), updatedAccount2.getBalance());    &#125;    @Test    public void testTransferWithInsufficientBalance() &#123;        // 创建两个账户        Account account1 = new Account();        account1.setAccountNo(&quot;1003&quot;);        account1.setAccountName(&quot;王五&quot;);        account1.setBalance(new BigDecimal(&quot;100.00&quot;));        accountService.createAccount(account1);        Account account2 = new Account();        account2.setAccountNo(&quot;1004&quot;);        account2.setAccountName(&quot;赵六&quot;);        account2.setBalance(new BigDecimal(&quot;500.00&quot;));        accountService.createAccount(account2);        // 尝试转账超过余额的金额        assertThrows(RuntimeException.class, () -&gt; &#123;            accountService.transfer(&quot;1003&quot;, &quot;1004&quot;, new BigDecimal(&quot;200.00&quot;));        &#125;);        // 验证余额未改变        Account updatedAccount1 = accountService.getAccount(&quot;1003&quot;);        Account updatedAccount2 = accountService.getAccount(&quot;1004&quot;);        assertEquals(new BigDecimal(&quot;100.00&quot;), updatedAccount1.getBalance());        assertEquals(new BigDecimal(&quot;500.00&quot;), updatedAccount2.getBalance());    &#125;&#125; \r\n另外可以操作如下测试方法\r\n@Testpublic void testNestedTransaction() &#123;    // 创建账户    Account account1 = accountService.createAccount(...);    Account account2 = accountService.createAccount(...);    try &#123;        // 转账并记录日志（主事务抛异常）        accountService.transfer(&quot;1001&quot;, &quot;1002&quot;, new BigDecimal(&quot;200.00&quot;));    &#125; catch (Exception e) &#123;        // 验证主事务回滚        Account updatedAccount1 = accountService.getAccount(&quot;1001&quot;);        assertEquals(1000.00, updatedAccount1.getBalance());        // 验证日志记录事务提交        List&lt;Transaction&gt; logs = logService.getTransactionHistory(&quot;1001&quot;);        assertFalse(logs.isEmpty());    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework part8-Spring Resources接口与资源访问","url":"/posts/54991.html","content":"Resource接口和实现类\r\nResource接口\r\nJDK提供的访问资源的类(如java.NET.URL,File)等并不能很好很方便的满足各种底层资源的访问需求。Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。\r\nSpring的Resource接口位于org.sprigframework.core.io中。旨在实现一个更強大的接口，用于抽象对低级资源的方向。以下演示了Resource接口定义的方法\r\n/** * 用于描述资源的接口，该接口抽象了底层资源的实际类型，如文件或类路径资源。 * * &lt;p&gt;对于每个资源，如果它在物理形式上存在，都可以打开一个输入流，但只有某些资源才能返回 URL 或文件句柄。具体行为取决于其实现。 */public interface Resource extends InputStreamSource &#123;    /**     * 判断此资源是否在物理形式上真正存在。     */    boolean exists();    /**     * 指示是否可以通过 &#123;@link #getInputStream()&#125; 读取此资源的非空内容。     * 实际的内容读取可能仍然失败。     */    default boolean isReadable() &#123;        return exists();    &#125;    /**     * 指示此资源是否代表一个打开的流的句柄。     * 如果为 true，则输入流不能被多次读取，并且在读取后必须被关闭，以避免资源泄露。     */    default boolean isOpen() &#123;        return false;    &#125;    /**     * 判断此资源是否代表文件系统中的文件。     */    default boolean isFile() &#123;        return false;    &#125;    /**     * 返回此资源的 URL 句柄。     */    URL getURL() throws IOException;    /**     * 返回此资源的 URI 句柄。     */    URI getURI() throws IOException;    /**     * 返回此资源的文件句柄。     */    File getFile() throws IOException;    /**     * 返回一个 &#123;@link ReadableByteChannel&#125;。     */    default ReadableByteChannel readableChannel() throws IOException &#123;        return Channels.newChannel(getInputStream());    &#125;    /**     * 确定此资源的内容长度。     */    long contentLength() throws IOException;    /**     * 确定此资源的最后修改时间戳。     */    long lastModified() throws IOException;    /**     * 创建相对于此资源的资源。     */    Resource createRelative(String relativePath) throws IOException;    /**     * 返回此资源的文件名。     */    @Nullable    String getFilename();    /**     * 返回此资源的描述，用于在处理资源时的错误输出。     */    String getDescription();&#125;\r\nResource接口継承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。\r\nInputStreamSource接口，只有一个方法:\r\n/** * 表示可以提供输入流的资源或对象的接口。 */public interface InputStreamSource &#123;\t/**\t * 返回基础资源内容的 InputStream。\t * 期望每次调用都会创建一个新的流。\t * @return 基础资源的输入流（不能为 null）\t * @throws java.io.FileNotFoundException 如果基础资源不存在\t * @throws IOException 如果无法打开内容流\t */\tInputStream getInputStream() throws IOException;&#125;\r\nResource的实现类\r\nResource接口是Spring资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成，每个实现类代表-一种资源访问策略。Resource-一般包括这些实现类:\r\nUrlResource，ClassPathResource，FilsSystemResource，ServletContextResource，InputStreamResource，ByteArrayResource\r\nUrlResource\r\n用于访问通过 URL 表示的资源，比如 http://\r\n开头的网络资源（如网页、远程文件等），也可以是 file://\r\n开头的本地文件资源。它会根据 URL\r\n的协议来决定如何获取资源。例如，当你需要访问一个远程服务器上的文件时，就可以使用\r\nUrlResource。代码示例如下\r\nimport org.springframework.core.io.UrlResource;import java.net.URL;public class UrlResourceExample &#123;    public static void main(String[] args) throws Exception &#123;        URL url = new URL(&quot;http://example.com/somefile.txt&quot;);        UrlResource resource = new UrlResource(url);        // 这里可以进行资源的读取等操作，比如获取输入流        java.io.InputStream inputStream = resource.getInputStream();        // 处理输入流        inputStream.close();    &#125;&#125;\r\nClassPathResource\r\n用于访问类路径下的资源文件。在 Java 项目中，类路径通常包含\r\nsrc/main/resources（在 Maven 或 Gradle\r\n项目结构中）这样的目录。它会从类加载器的类路径中查找资源。例如，如果你有一个配置文件\r\napplication.properties 放在 src/main/resources\r\n目录下，你可以通过 ClassPathResource\r\n来获取它。示例代码：\r\npackage edu.software.ergoutree.springresources;import org.springframework.core.io.ClassPathResource;import java.io.IOException;import java.io.InputStream;// 访问类路径下的资源public class ClassPathDemo &#123;    public static void main(String[] args) &#123;        loadClassPathResources(&quot;test&quot;);    &#125;    public static void loadClassPathResources(String path)&#123;        // 创建对象 ClassPathResource        ClassPathResource resource = new ClassPathResource(path);        System.out.println(resource.getFilename());        System.out.println(resource.getDescription());        try &#123;            InputStream in = resource.getInputStream();            byte[] bytes = new byte[in.available()];            while (in.read(bytes) != -1)&#123;                System.out.println(new String(bytes));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\r\nFileSystemResource\r\n用于访问本地文件系统中的资源。它通过文件路径来定位资源，不管是绝对路径还是相对路径（相对于当前工作目录）。比如你要访问本地磁盘上的一个文件，就可以使用\r\nFileSystemResource。\r\npackage edu.software.ergoutree.springresources;import org.springframework.core.io.FileSystemResource;import java.io.IOException;import java.io.InputStream;// 访问系统资源public class FileSystemResourceDemo &#123;    public static void loadFileResource(String fileName) &#123;        // 创建对象        FileSystemResource resource = new FileSystemResource(fileName);        System.out.println(resource.getFilename());        System.out.println(resource.getDescription());        try &#123;            InputStream in = resource.getInputStream();            byte[] bytes = new byte[in.available()];            while (in.read(bytes) != -1)&#123;                System.out.println(new String(bytes));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        loadFileResource(&quot;Spring Framework\\\\Spring6Exp\\\\spring-resources\\\\src\\\\main\\\\resources\\\\test&quot;);    &#125;&#125;\r\nServletContextResource\r\n\r\n主要用于在 Web 应用（基于 Servlet 的应用）中访问\r\nServletContext 相关的资源。它根据\r\nServletContext 来解析资源路径，通常用于访问 Web\r\n应用根目录下的资源，比如 WEB-INF 目录下的文件。在 Spring\r\nWeb 应用中使用较多。例如：\r\nimport org.springframework.web.context.ServletContextAware;import org.springframework.web.context.support.ServletContextResource;import javax.servlet.ServletContext;public class ServletContextResourceExample implements ServletContextAware &#123;    private ServletContext servletContext;    @Override    public void setServletContext(ServletContext servletContext) &#123;        this.servletContext = servletContext;    &#125;    public void accessResource() &#123;        ServletContextResource resource = new ServletContextResource(servletContext, &quot;/WEB-INF/somefile.txt&quot;);        try &#123;            java.io.InputStream inputStream = resource.getInputStream();            // 处理输入流            inputStream.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\nInputStreamResource\r\n允许你将一个已有的 InputStream 包装成\r\nResource\r\n对象。当你已经通过其他方式获取到了一个输入流，但是又想将其作为\r\nResource\r\n来使用时，就可以使用这个类。比如从数据库中读取二进制数据得到了一个\r\nInputStream，然后可以将其包装为\r\nInputStreamResource。示例：\r\nimport org.springframework.core.io.InputStreamResource;import java.io.ByteArrayInputStream;import java.io.IOException;public class InputStreamResourceExample &#123;    public static void main(String[] args) throws IOException &#123;        String data = &quot;Some sample data&quot;;        ByteArrayInputStream inputStream = new ByteArrayInputStream(data.getBytes());        InputStreamResource resource = new InputStreamResource(inputStream);        // 这里可以对 resource 进行操作，比如获取输入流        java.io.InputStream actualInputStream = resource.getInputStream();        // 处理输入流        actualInputStream.close();    &#125;&#125;\r\nByteArrayResource\r\n用于将字节数组包装成 Resource\r\n对象。它适用于将内存中的字节数据当作一种资源来处理。例如，如果你在程序中生成了一些字节数据，然后想要以\r\nResource 的形式使用它，就可以使用\r\nByteArrayResource。示例代码：\r\nimport org.springframework.core.io.ByteArrayResource;import java.io.IOException;public class ByteArrayResourceExample &#123;    public static void main(String[] args) throws IOException &#123;        byte[] byteArray = &quot;Hello, World!&quot;.getBytes();        ByteArrayResource resource = new ByteArrayResource(byteArray);        // 可以获取输入流来读取字节数组内容        java.io.InputStream inputStream = resource.getInputStream();        // 处理输入流        inputStream.close();    &#125;&#125;\r\n这些 Resource 接口的实现类，为在 Spring\r\n应用中访问不同类型的资源提供了方便和统一的方式，使得开发者可以根据具体的资源来源选择合适的实现类来进行资源操作。\r\n\r\nResourceLoader接口\r\nSpring提供了如下两个标志性接口\r\nResourceLoader：该接口的实现类实例可以获得一个Resource实例\r\nResourceLoaderAware:该接口的实现类实例可以获得一个ResourceLoader的引用\r\norg.springframework.core.io.ResourceLoader 是 Spring\r\n框架中的一个关键接口，它定义了如何获取资源（例如类路径资源、文件系统资源或网页资源）的策略。这个接口是\r\nSpring\r\n资源加载抽象的核心，使得应用程序可以从不同的资源位置以统一的方式加载资源。\r\nSpring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是\r\nFileSystemXmlApplicationContext, res\r\n就是FileSystemResource实例;如果ApplicationContext是\r\nClassPathXmIApplicationContext, res\r\n就是ClassPathResource实例\r\n当Spring应用需要进行资源访问时，实际上并不需要直接使用 Resource\r\n实现类，而是调用 ResourceLoader 实例的\r\ngetResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策\r\n略，从而将应用程序和具体的资源访问策略分离开来\r\n另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、\r\nFileSystemResource等实现类.（多态）\r\nResource res = ctx.getResource(&quot;classpath:bean.xml&quot;);Resource res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;https://localhost8080.bean.xml&quot;);\r\n主要功能\r\n\r\n统一资源加载 ResourceLoader\r\n提供了一个标准化的方法来加载资源，不论资源是存放在类路径、文件系统、网络URL还是其他位置。\r\n资源位置解析 根据提供的资源字符串位置（如 “classpath:”, “file:”,\r\n“http:”），ResourceLoader 可以确定资源的类型，并为其创建相应的 Resource\r\n实例。\r\n返回 Resource 实例 通过 Resource getResource(String location)\r\n方法，ResourceLoader 返回一个 Resource\r\n对象，代表了指定位置的资源。这使得读取和操作资源变得简单且统一。\r\n与 ClassLoader 的交互 ResourceLoader 通过 ClassLoader\r\ngetClassLoader() 方法返回与其关联的\r\nClassLoader。这使得资源加载策略可以与特定的类加载器关联。\r\n扩展性 ResourceLoader\r\n是一个接口，这意味着我们可以实现自己的资源加载策略，或者扩展默认的策略以满足特定需求。\r\n内置实现与整合\r\nSpring 提供了默认的 ResourceLoader 实现，如\r\nDefaultResourceLoader。但更重要的是，org.springframework.context.ApplicationContext\r\n也实现了 ResourceLoader，这意味着 Spring\r\n上下文本身就是一个资源加载器。\r\n\r\n接口源码\r\nResourceLoader 接口为 Spring\r\n框架定义了资源加载策略。它提供了获取资源的方法，并公开了其使用的\r\nClassLoader。通过这种策略，资源可以从各种来源（如类路径、文件系统等）以统一方式加载。这提供了资源加载的灵活性和一致性，并支持各种资源描述符，如\r\nURL、类路径等。此外，它还允许对资源句柄进行多次重新使用和读取。\r\n/** * 用于加载资源（例如类路径或文件系统资源）的策略接口。 * 一个 ApplicationContext 需要提供此功能以及扩展的 ResourcePatternResolver 支持。 *  * DefaultResourceLoader 是一个独立的实现，可在 ApplicationContext 外部使用，并被 ResourceEditor 使用。 *  * 当在 ApplicationContext 中运行时，类型为 Resource 和 Resource[] 的 Bean 属性可以从字符串中填充，使用特定上下文的资源加载策略。 * * @author Juergen Hoeller * @since 10.03.2004 */public interface ResourceLoader &#123;\t/** 用于从类路径加载的伪 URL 前缀：&quot;classpath:&quot;。 */\tString CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\t/**\t * 返回指定资源位置的 Resource 句柄。\t * 该句柄应始终是一个可重用的资源描述符，允许进行多次 Resource#getInputStream() 调用。\t * 必须支持完全限定的 URLs，例如 &quot;file:C:/test.dat&quot;。\t * 必须支持类路径伪-URLs，例如 &quot;classpath:test.dat&quot;。\t * 应支持相对文件路径，例如 &quot;WEB-INF/test.dat&quot;。\t * （这将是实现特定的，通常由 ApplicationContext 实现提供。）\t * 请注意，Resource 句柄并不意味着资源存在；我们需要调用 Resource#exists 来检查其存在性。\t *\t * @param location 资源位置\t */\tResource getResource(String location);\t/**\t * 公开此 ResourceLoader 使用的 ClassLoader。\t * 需要直接访问 ClassLoader 的客户端可以与 ResourceLoader 以统一的方式这样做，而不是依赖线程上下文 ClassLoader。\t *\t * @return ClassLoader（仅当连系统 ClassLoader 都不可访问时为 null）\t */\t@Nullable\tClassLoader getClassLoader();&#125;\r\npublic class ResourceLoaderDemo &#123;        public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext();        Resource resource = context.getResource(&quot;test&quot;);                ApplicationContext ctx = new FileSystemXmlApplicationContext();        Resource resource2 = context.getResource(&quot;test&quot;);    &#125;&#125;\r\n主要实现\r\n\r\nDefaultResourceLoader\r\n\r\n这是基本的资源加载器实现。它可以处理 “classpath:”\r\n前缀的资源，如果没有提供这样的前缀，它会尝试使用类加载器或文件系统来加载资源。\r\n\r\n使用 DefaultResourceLoader\r\n从不同的资源（类路径和文件系统）加载内容。\r\n示例\r\npublic class DefaultResourceLoaderDemo &#123;    public static void main(String[] args) &#123;        DefaultResourceLoader loader = new DefaultResourceLoader();        // 从类路径加载资源        Resource classpathResource = loader.getResource(&quot;classpath:application.properties&quot;);        try (InputStream is = classpathResource.getInputStream()) &#123;            // 读取和处理资源内容            System.out.println(&quot;Classpath = &quot;+ new String(is.readAllBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 加载文件系统中的资源        Resource fileResource = loader.getResource(&quot;file:/idea-work-space-xcs/spring-reading/spring-resources/spring-resource-resourceLoader/myfile1.txt&quot;);        try (InputStream is = fileResource.getInputStream()) &#123;            // 读取和处理资源内容            System.out.println(&quot;File = &quot;+ new String(is.readAllBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n运行结果发现\r\n从类路径上，我们加载了一个文件：application.properties。这意味着在我们的项目的类路径中，有这个文件。\r\n从文件系统上，我们加载了一个文件：myfile1.txt。这些文件位于我们之前在代码中硬编码的文件路径\r\n/idea-work-space-xcs/spring-reading/spring-resources/spring-resource-resourceLoader/\r\n下。\r\n与其他组件的关系\r\n\r\nApplicationContext\r\n所有的 Spring ApplicationContext 都实现了\r\nResourceLoader。这意味着我们可以使用 Spring\r\n上下文本身来加载资源。\r\nResource\r\nResourceLoader 返回 Resource\r\n对象，它代表实际的资源，可以是文件系统中的文件、类路径资源、URLs\r\n等。Resource 提供了访问和读取资源内容的方法。\r\nResourcePatternResolver 这是 ResourceLoader\r\n的扩展，可以解析给定的位置模式以加载多个资源。PathMatchingResourcePatternResolver\r\n是它的主要实现。\r\nResourceEditor 这是一个属性编辑器，用于将字符串转换为 Resource\r\n对象。它内部使用 ResourceLoader 来执行转换。\r\nResourceLoaderAware\r\n这是一个特殊的接口，任何 bean\r\n如果实现了它，那么它就可以在被创建时获得对 ResourceLoader\r\n的引用，这样它就可以自己加载资源。\r\nEmbeddedValueResolverAware\r\n一些组件，如属性占位符处理器，可能需要解析值中的动态部分。它们可以使用\r\nResourceLoader\r\n作为解析这些值的一部分，特别是当值代表资源位置时。\r\nPathMatchingResourcePatternResolver\r\n它是 ResourcePatternResolver 的一个实现，它扩展了 ResourceLoader\r\n来处理以 “classpath*:”\r\n开头的资源模式，这允许加载所有匹配的资源，而不仅仅是第一个找到的资源。\r\n\r\n常见问题\r\n\r\n加载类路径资源 使用前缀\r\n“classpath:”，例如：loader.getResource(“classpath:myconfig.xml”)。\r\n加载文件系统资源\r\n使用前缀\r\n“file:”，例如：loader.getResource(“file:/path/to/myconfig.xml”)。\r\n加载URL资源\r\n直接使用\r\nURL，例如：loader.getResource(“http://www.example.com/config.xml”)。\r\n资源不存在 使用 Resource.exists()\r\n方法检查资源是否存在。确保路径或位置正确，并且资源真的存在于预期的位置。\r\n如何读取资源内容 从 Resource 对象中获取\r\nInputStream，例如：resource.getInputStream()。\r\n从 Resource 获取到文件路径 使用\r\nResource.getFile()。但请注意，这并不总是有效的，例如当资源实际上是一个类路径资源或URL资源时。\r\n自动注入 ResourceLoader 实现 ResourceLoaderAware 接口，Spring\r\n将自动为我们的 bean 提供 ResourceLoader 的引用。\r\n扩展或自定义资源加载机制 我们可以实现自己的 ResourceLoader\r\n或继承现有的实现，如 DefaultResourceLoader\r\n加载资源时考虑环境或属性占位符 使用 PropertyPlaceholderConfigurer\r\n或 PropertySourcesPlaceholderConfigurer 与 @Value 注解可以解析属性值中的资源路径\r\n\r\n\r\nResourceLoaderAware 接口\r\n在 Spring 中，ResourceLoaderAware\r\n接口是一个回调接口，它提供了一个用于设置 Bean 所在的ResourceLoader\r\n的方法。当一个 Bean 实现了 ResourceLoaderAware 接口时，在该 Bean\r\n实例被实例化后，Spring 容器会调用 setResourceLoader 方法，并将该 Bean\r\n所在的 ResourceLoader 作为参数传递进去。\r\n源码\r\n\r\n\r\nimg\r\n\r\nResourceLoaderAware 主要用于获取加载当前 Bean 的\r\nResourceLoader，使得 Bean\r\n能够在运行时获取到关于资源加载的能力。\r\n使用\r\n要让一个Bean实现 ResourceLoaderAware\r\n接口，需要按以下步骤进行\r\n\r\n\r\nimg\r\n\r\npackage org.example.cheney;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import java.io.InputStream;public class DemoBean implements ResourceLoaderAware &#123;    private ResourceLoader resourceLoader;    @Override    public void setResourceLoader(ResourceLoader resourceLoader) &#123;        this.resourceLoader = resourceLoader;        System.out.println(&quot;【ResourceLoaderAware】: 通过 ResourceLoader 创建 Bean&quot;);    &#125;    public void loadResource(String resourceName) throws Exception &#123;        // 使用 ResourceLoader 加载资源        System.out.println(&quot;加载的文件名是: &quot; + resourceName);        Resource resource = resourceLoader.getResource(resourceName);        InputStream inputStream = resource.getInputStream();        // 读取资源内容        byte[] contentBytes = new byte[inputStream.available()];        inputStream.read(contentBytes);        String content = new String(contentBytes);        System.out.println(&quot;文件内容:\\n&quot; + content);    &#125;&#125;\r\n配置bean\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;       &gt;    &lt;bean id=&quot;demoBean&quot; class=&quot;org.example.cheney.DemoBean&quot;/&gt;&lt;/beans&gt;\r\n测试输出\r\npackage org.example.cheney;import org.springframework.context.support.AbstractXmlApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123;    public static void main(String[] args) throws Exception &#123;        String location = &quot;applicationContext.xml&quot;;        try (AbstractXmlApplicationContext context = new ClassPathXmlApplicationContext(location)) &#123;            DemoBean demo = (DemoBean) context.getBean(&quot;demoBean&quot;);            demo.loadResource(&quot;classpath:demo.txt&quot;);            System.out.println(&quot;End.&quot;);        &#125;    &#125;&#125;\r\nResourceLoaderAware 接口通常用于以下场景：\r\n\r\n加载资源：\r\n当一个 Bean 需要在运行时加载外部资源时，可以使用 ResourceLoaderAware\r\n获取 ResourceLoader 并使用它加载资源\r\n处理资源相关逻辑： 当一个 Bean\r\n与资源相关的操作时，例如读取配置文件、加载模板文件等，可以使用\r\nResourceLoaderAware 获取 ResourceLoader\r\n\r\n\r\n使用Resource作为属性\r\n前面介绍了Spring提供的资源访问策略，但这些依赖访问策略要么需要使用Resource实现类，要么需要使用\r\nApplicationContext来获取资源。实际上，当应用程序中的Bean实例需要访问资源时，Spring有更好的解决方\r\n法：直接利用依赖注入。从这个意义上来看，Spring框架不仅充分利用了策略模式来简化资源访问，而且还将策\r\n略模式和IoC进行充分地结合，最大程度地简化了Spring资源访问。\r\n归纳起来，如果Bean实例需要访问资源，有如下两种解决方案：\r\n\r\n代码中获取Resource实例。\r\n使用依赖注入\r\n\r\n对于第一种方式，当程序获取Resource实例时，总需要提供Resource所在的位置，不管通过FileSystemResource创建实例，还是通过ClassPathResource创建实例，或者通过ApplicationContext的getResource()方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让Spring为Bean实例依赖注入资源。\r\n示例\r\npackage edu.software.ergoutree.springresources.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestBean &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        RescoureBean rescoureBean = context.getBean(RescoureBean.class);        rescoureBean.pares();    &#125;&#125;\r\nbean配置\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--解耦合--&gt;    &lt;bean id=&quot;rescoureBean&quot; class=&quot;edu.software.ergoutree.springresources.di.RescoureBean&quot;&gt;        &lt;property name=&quot;resource&quot; value=&quot;classpath*:test&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试\r\npackage edu.software.ergoutree.springresources.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestBean &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        RescoureBean rescoureBean = context.getBean(RescoureBean.class);        rescoureBean.pares();    &#125;&#125;\r\n\r\n应用程序上下文和资源路径–Resource\r\n指定访问策略\r\n在 Spring\r\n框架中，应用程序上下文（ApplicationContext）不仅负责管理\r\nBean 的生命周期，还提供了资源加载的能力。通过\r\nApplicationContext，开发者可以方便地访问不同类型的资源，而无需关心底层的资源访问细节。ApplicationContext\r\n本身实现了 ResourceLoader\r\n接口，因此可以直接通过上下文加载资源。\r\n资源路径的指定方式\r\nSpring\r\n支持多种资源路径的指定方式，开发者可以通过不同的前缀来强制使用特定的资源访问策略。以下是常见的资源路径前缀及其对应的访问策略：\r\n\r\nclasspath:\r\n表示从类路径下加载资源。例如：\r\nResource resource = context.getResource(&quot;classpath:config.properties&quot;);\r\n这会从类路径（如 src/main/resources）中查找\r\nconfig.properties 文件。\r\nfile:\r\n表示从文件系统中加载资源。例如：\r\nResource resource = context.getResource(&quot;file:/path/to/config.properties&quot;);\r\n这会从文件系统的指定路径加载文件。\r\nhttp: 或 https:\r\n表示从网络 URL 加载资源。例如：\r\nResource resource = context.getResource(&quot;https://example.com/config.properties&quot;);\r\n这会通过 HTTP 或 HTTPS 协议从远程服务器加载资源。\r\n无前缀\r\n如果没有指定前缀，ApplicationContext\r\n会根据上下文类型决定默认的资源访问策略：\r\n\r\n对于\r\nClassPathXmlApplicationContext，默认从类路径加载资源。\r\n对于\r\nFileSystemXmlApplicationContext，默认从文件系统加载资源。\r\n\r\n\r\n示例代码\r\n以下是一个完整的示例，展示如何通过 ApplicationContext\r\n加载不同类型的资源：\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import java.io.IOException;import java.io.InputStream;public class ResourceLoadingDemo &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext();        // 从类路径加载资源        Resource classpathResource = context.getResource(&quot;classpath:application.properties&quot;);        printResourceContent(classpathResource);        // 从文件系统加载资源        Resource fileResource = context.getResource(&quot;file:/path/to/myfile.txt&quot;);        printResourceContent(fileResource);        // 从网络 URL 加载资源        Resource urlResource = context.getResource(&quot;https://example.com/data.json&quot;);        printResourceContent(urlResource);    &#125;    private static void printResourceContent(Resource resource) &#123;        try (InputStream inputStream = resource.getInputStream()) &#123;            byte[] bytes = inputStream.readAllBytes();            System.out.println(&quot;Resource content: &quot; + new String(bytes));        &#125; catch (IOException e) &#123;            System.err.println(&quot;Failed to read resource: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n资源路径的通配符支持\r\nSpring 还支持使用通配符加载多个资源，例如：\r\n\r\nclasspath*:：从所有类路径下匹配的资源加载。加载多个\r\nfile: 或 classpath:\r\n结合通配符：匹配符合模式的文件。\r\n\r\nResource[] resources = context.getResources(&quot;classpath*:config/*.properties&quot;);for (Resource res : resources) &#123;    System.out.println(&quot;Found resource: &quot; + res.getFilename());&#125;\r\n通过 ApplicationContext\r\n加载资源时，开发者可以通过前缀指定资源的访问策略，从而实现灵活的资源管理。这种方式不仅简化了代码，还提高了应用程序的可维护性和可扩展性。无论是类路径资源、文件系统资源还是网络资源，Spring\r\n都提供了统一的访问接口，使得资源加载变得简单而高效。\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"butterfly配置文件速读-自查用","url":"/posts/62149.html","content":"转自 Butterfly\r\n文档(三) 主题配置\r\n\r\n_config.butterfly.yml\r\n# --------------------------------------# 导航设置# --------------------------------------nav:  # 导航栏 Logo 图片  logo:  # 是否显示标题  display_title: true  # 是否固定导航栏  fixed: falsemenu:  # 首页: / || fas fa-home  # 列表||fas fa-list:  #   音乐: /music/ || fas fa-music  #   电影: /movies/ || fas fa-video# --------------------------------------# 代码块设置# --------------------------------------code_blocks:  # 代码块主题: darker / pale night / light / ocean / false  theme: light  # 是否使用 Mac 风格  macStyle: false  # 代码块高度限制（单位: px）  height_limit: false  # 是否自动换行  word_wrap: false  # 工具栏  # 是否显示复制按钮  copy: true  # 是否显示语言标签  language: true  # true: 收缩代码块 | false: 展开代码块 | none: 展开代码块并隐藏按钮  shrink: false  # 是否显示全屏显示代码块按钮  fullpage: false# 社交媒体链接# 格式:#   icon: 链接 || 描述 || 颜色social:# --------------------------------------# 图片设置# --------------------------------------# 网站的 favicon 图标favicon: /img/favicon.png# 头像设置avatar:  # 头像图片链接  img: https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png  # 是否启用头像效果  effect: false# 禁用所有横幅图片disable_top_img: false# 如果页面未设置横幅，则显示默认的横幅图片default_top_img:# 主页的横幅图片index_img:# 归档页的横幅图片archive_img:# 注意: 是标签页（单个标签），不是标签页面（所有标签）tag_img:# 标签页的横幅图片，可以为每个标签设置横幅图片# 格式:#  - 标签名: 图片链接tag_per_img:# 注意: 是分类页（单个分类），不是分类页面（所有分类）category_img:# 分类页的横幅图片，可以为每个分类设置横幅图片# 格式:#  - 分类名: 图片链接category_per_img:# 页脚的背景图片footer_img: false# 网站背景# 可以设置为颜色或图片# 图片格式: url(http://xxxxxx.com/xxx.jpg)background:# 封面设置cover:  # 是否禁用封面  index_enable: true  aside_enable: true  archives_enable: true  # 主页封面的位置  # 选择: left/right/both  position: both  # 当未设置封面时，显示默认封面  default_cover:    # - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg# 替换损坏的图片error_img:  # 友链页面的错误图片  flink: /img/friend_404.gif  # 文章页面的错误图片  post_page: /img/404.jpg# 简单的 404 页面error_404:  # 是否启用 404 页面  enable: false  # 404 页面的副标题  subtitle: &#x27;Page Not Found&#x27;  # 404 页面的卡片背景图片  background: https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png# 文章元数据设置post_meta:  # 主页页面  page:    # 日期类型: created / updated / both    date_type: created    # 日期格式: date / relative    date_format: date    # 是否显示分类    categories: true    # 是否显示标签    tags: false    # 是否显示文字标签    label: true  # 文章页面  post:    # 元数据位置: left / center    position: left    # 日期类型: created / updated / both    date_type: both    # 日期格式: date / relative    date_format: date    # 是否显示分类    categories: true    # 是否显示标签    tags: true    # 是否显示文字标签    label: true# --------------------------------------# 首页设置# --------------------------------------# 首页头图的设置# 默认: 头图全屏，站点信息在中间# 站点信息的位置，例如: 300px/300em/300rem/10%index_site_info_top:# 头图的高度，例如: 300px/300em/300remindex_top_img_height:# 首页的副标题设置subtitle:  # 是否启用副标题  enable: false  # 是否启用打字机效果  effect: true  # 自定义 typed.js  # https://github.com/mattboldt/typed.js/#customization  typed_option:  # 来源 - 调用第三方服务 API（仅限中文）  # 它将首先显示来源，然后显示副标题内容  # 选择: false/1/2/3  # false - 禁用此功能  # 1 - hitokoto.cn  # 2 - yijuzhan.com  # 3 - jinrishici.com  source: false  # 如果关闭打字机效果，副标题将仅显示 sub 的第一行内容  sub:# 首页文章佈局# 1: 行佈局# 2: 列布局index_layout: 1# 在首页显示文章简介# 1: 描述# 2: 两者（如果存在描述，将显示描述，否则显示自动摘要）# 3: 自动摘要（默认）# false: 不显示文章简介index_post_content:  method: 3  # 如果设置 method 为 2 或 3，需要配置长度  length: 500# --------------------------------------# 文章设置# --------------------------------------toc:  # 是否在文章中显示目录  post: true  # 是否在页面中显示目录  page: false  # 是否显示目录编号  number: true  # 是否默认展开目录  expand: false  # 是否使用简洁风格（仅适用于文章）  style_simple: false  # 是否显示滚动百分比  scroll_percent: truepost_copyright:  # 是否启用版权声明  enable: true  # 是否进行文章 URL 解码  decode: false  # 作者链接  author_href:  # 许可证类型  license: CC BY-NC-SA 4.0  # 许可证链接  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/# 贊助/打赏reward:  # 是否启用打赏  enable: false  # 打赏案例文本  text:  QR_code:    # - img: /img/wechat.jpg    #   link:    #   text: 微信    # - img: /img/alipay.jpg    #   link:    #   text: 支付宝# 文章编辑# 轻鬆在线浏览和编辑博客源代码post_edit:  # 是否启用在线编辑  enable: false  # url: https://github.com/用户名/仓库名/edit/分支名/子目录名/  # 例如: https://github.com/jerryc127/butterfly.js.org/edit/main/source/  url:# 相关文章related_post:  # 是否显示相关文章  enable: true  # 显示的文章数量  limit: 6  # 选择: created / updated  date_type: created# 选择: 1 / 2 / false# 1: “下一篇文章”将链接到旧文章# 2: “下一篇文章”将链接到新文章# false: 禁用分页post_pagination: 1# 显示文章过期通知noticeOutdate:  # 是否启用过期通知  enable: false  # 样式: simple / flat  style: flat  # 多少天后显示通知  limit_day: 365  # 位置: top / bottom  position: top  message_prev: 已经过了  message_next: 天自上次更新，文章内容可能已过时。# --------------------------------------# 页脚设置# --------------------------------------footer:  owner:    # 是否启用所有者显示    enable: true    # 网站创建年份    since: 2019  # 自定义文本  custom_text:  # 主题和框架的版权声明  copyright: true# --------------------------------------# 侧边栏设置# --------------------------------------aside:  # 是否启用侧边栏  enable: true  # 是否默认隐藏侧边栏  hide: false  # 是否在右下角显示隐藏侧边栏的按钮  button: true  # 移动设备上是否启用侧边栏  mobile: true  # 侧边栏位置：left / right  position: right  display:    # 归档页面是否显示侧边栏    archive: true    # 标签页面是否显示侧边栏    tag: true    # 分类页面是否显示侧边栏    category: true  card_author:    # 是否显示作者信息卡片    enable: true    # 作者描述    description:    button:      # 是否显示按钮      enable: true      # 按钮图标      icon: fab fa-github      # 按钮文本      text: Follow Me      # 按钮链接      link: https://github.com/xxxxxx  card_announcement:    # 是否显示公告卡片    enable: true    # 公告内容    content: This is my Blog  card_recent_post:    # 是否显示最近文章卡片    enable: true    # 显示文章数量，0 表示显示所有    limit: 5    # 排序方式：date / updated    sort: date    sort_order:  card_newest_comments:    # 是否显示最新评论卡片    enable: false    sort_order:    # 显示评论数量    limit: 6    # 单位：分钟，保存数据到 localStorage    storage: 10    # 是否显示头像    avatar: true  card_categories:    # 是否显示分类卡片    enable: true    # 显示分类数量，0 表示显示所有    limit: 8    # 选择：none / true / false    expand: none    sort_order:  card_tags:    # 是否显示标签卡片    enable: true    # 显示标签数量，0 表示显示所有    limit: 40    # 是否启用颜色    color: false    # 标签排序方式：random/name/length    orderby: random    # 排序顺序：1 表示升序，-1 表示降序    order: 1    sort_order:  card_archives:    # 是否显示归档卡片    enable: true    # 归档类型：monthly / yearly    type: monthly    # 日期格式，例如：YYYY年MM月    format: MMMM YYYY    # 排序顺序：1 表示升序，-1 表示降序    order: -1    # 显示归档数量，0 表示显示所有    limit: 8    sort_order:  card_post_series:    # 是否显示系列文章卡片    enable: true    # 标题显示系列名称    series_title: false    # 排序方式：title 或 date    orderBy: &#x27;date&#x27;    # 排序顺序：1 表示升序，-1 表示降序    order: -1  card_webinfo:    # 是否显示网站信息卡片    enable: true    # 是否显示文章数量    post_count: true    # 是否显示最后推送日期    last_push_date: true    sort_order:    # 发佈日期与当前日期的时间差    # 格式：Month/Day/Year Time 或 Year/Month/Day Time    # 如果不启用此功能，请留空    runtime_date:# --------------------------------------# 右下角按钮设置# --------------------------------------# 右下角按钮与底部的距离（默认单位：px）rightside_bottom:# 简繁转换设置translate:  # 是否启用简繁转换  enable: false  # 按钮文本  default: 繁  # 网站语言（1 - 繁体中文 / 2 - 简体中文）  defaultEncoding: 2  # 转换延迟  translateDelay: 0  # 按钮在简体中文时的文本  msgToTraditionalChinese: &#x27;繁&#x27;  # 按钮在繁体中文时的文本  msgToSimplifiedChinese: &#x27;简&#x27;# 閲读模式readmode: true# 暗黑模式设置darkmode:  # 是否启用暗黑模式  enable: true  # 切换暗黑/明亮模式的按钮  button: true  # 是否自动切换暗黑/明亮模式  # autoChangeMode: 1  跟随系统设置，如果系统不支持暗黑模式，则在晚上 6 点到早上 6 点之间切换暗黑模式  # autoChangeMode: 2  在晚上 6 点到早上 6 点之间切换暗黑模式  # autoChangeMode: false  不自动切换  autoChangeMode: false  # 设置明亮模式时间，值在 0 到 24 之间。如果未设置，默认值为 6 和 18  start:  end:# 在返回顶部按钮中显示滚动百分比rightside_scroll_percent: false# 不要修改以下设置，除非你知道它们的工作原理# 选择：readmode,translate,darkmode,hideAside,toc,chat,comment# 不要重复相同的值rightside_item_order:  # 是否启用右侧项目顺序  enable: false  # 隐藏的默认项目：readmode,translate,darkmode,hideAside  hide:  # 显示的默认项目：toc,chat,comment  show:# --------------------------------------# 全局设置# --------------------------------------# 锚点设置anchor:  # 滚动时，URL 将根据标题 ID 更新  auto_update: false  # 点击标题滚动并更新锚点  click_to_scroll: false# 图片标题photofigcaption: false# 复制设置copy:  # 是否启用复制功能  enable: true  # 在复制的内容后添加版权信息  copyright:    enable: false    # 当复制字符数超过 limit_count 时添加版权信息    limit_count: 150# 需要安装 hexo-wordcount 插件wordcount:  # 是否启用字数统计  enable: false  # 在文章元信息中显示字数统计  post_wordcount: true  # 在文章元信息中显示閲读时间  min2read: true  # 在侧边栏网站信息中显示总字数  total_wordcount: true# 不蒜子 PV / UV 统计busuanzi:  # 网站 UV 统计  site_uv: true  # 网站 PV 统计  site_pv: true  # 页面 PV 统计  page_pv: true# --------------------------------------# 数学公式设置# --------------------------------------# 关于 per_page# 如果设置为 true，将在每个页面加载 mathjax/katex 脚本# 如果设置为 false，将根据你的设置加载 mathjax/katex 脚本（在页面的 front-matter 中添加 &#x27;mathjax: true&#x27; 或者 &#x27;katex: true&#x27;）math:  # 选择：mathjax, katex  # 如果不需要数学公式，保持为空  use:  per_page: true  hide_scrollbar: false  mathjax:    # 启用上下文菜单    enableMenu: true    # 选择：all / ams / none，这控制是否对公式编号以及如何编号    tags: none  katex:    # 启用复制 KaTeX 公式    copy_tex: false# --------------------------------------# 搜索设置# --------------------------------------search:  # 选择：algolia_search / local_search / docsearch  # 如果不需要搜索功能，保持为空  use:  placeholder:  # Algolia 搜索  algolia_search:    # 每页搜索结果数量    hitsPerPage: 6  # 本地搜索  local_search:    # 页面加载时预加载搜索数据    preload: false    # 每篇文章显示的顶部 n 个搜索结果，设置为 -1 显示所有结果    top_n_per_article: 1    # 将 HTML 字符串反转义为可读内容    unescape: false    CDN:  # Docsearch  # https://docsearch.algolia.com/  docsearch:    appId:    apiKey:    indexName:    option:# --------------------------------------# 分享系统# --------------------------------------share:  # 选择：sharejs / addtoany  # 如果不需要分享功能，保持为空  use: sharejs  # Share.js  # https://github.com/overtrue/share.js  sharejs:    sites: facebook,twitter,wechat,weibo,qq  # AddToAny  # https://www.addtoany.com/  addtoany:    item: facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link# --------------------------------------# 评论系统# --------------------------------------comments:  # 最多两个评论系统，第一个将作为默认显示  # 如果不需要评论功能，保持为空  # 选择：Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk  # 两个评论系统的格式：Disqus,Waline  use:  # 按钮旁边显示评论系统名称  text: true  # 懒加载：评论系统将在评论元素进入浏览器视口时加载  # 如果设置为 true，评论计数将无效  lazyload: false  # 在文章顶部图片中显示评论计数  count: false  # 在主页显示评论计数  card_post_count: false# Disqus 评论插件配置# 官方文档：https://disqus.com/disqus:  # Disqus 的 shortname  shortname:  # 最新评论小部件的 API 密钥  apikey:# 使用 Disqus API 渲染评论的替代方案# 官方文档：https://github.com/SukkaW/DisqusJSdisqusjs:  # Disqus 的 shortname  shortname:  # API 密钥  apikey:  # 其他可选配置  option:# Livere 评论插件配置# 官方文档：https://www.livere.com/livere:  # Livere 的用户 ID  uid:# Gitalk 评论插件配置# 官方文档：https://github.com/gitalk/gitalkgitalk:  # GitHub 应用的客户端 ID  client_id:  # GitHub 应用的客户端密钥  client_secret:  # 存储评论的仓库名称  repo:  # 仓库拥有者的用户名  owner:  # 管理员用户名列表  admin:  # 其他可选配置  option:# Valine 评论插件配置# 官方文档：https://valine.js.orgvaline:  # LeanCloud 应用的 appId  appId:  # LeanCloud 应用的 appKey  appKey:  # 评论者头像样式  avatar: monsterid  # 该配置适用于国内自定义域名用户，海外版本将自动检测（无需手动填写）  serverURLs:  # 评论框背景图片  bg:  # 使用 Valine 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# Waline 评论插件配置，一个简单的评论系统，基于 Valine 开发，支持后端# 官方文档：https://waline.js.org/waline:  # 服务器 URL  serverURL:  # 评论框背景图片  bg:  # 使用 Waline 的访客计数作为页面的访客量  pageview: false  # 其他可选配置  option:# Utterances 评论插件配置# 官方文档：https://utteranc.es/utterances:  # 存储评论的 GitHub 仓库  repo:  # 问题映射方式，可选值：pathname/url/title/og:title  issue_term: pathname  # 浅色主题，可选值：github-light  light_theme: github-light  # 深色主题，可选值：photon-dark  dark_theme: photon-dark# Facebook 评论插件配置# 官方文档：https://developers.facebook.com/docs/plugins/comments/facebook_comments:  # 应用 ID  app_id:  # 用户 ID，可选  user_id:  # 每页显示评论数  pageSize: 10  # 评论排序方式，可选值：social / time / reverse_time  order_by: social  # 语言设置  lang: zh_TW# Twikoo 评论插件配置# 官方文档：https://github.com/imaegoo/twikootwikoo:  # 环境 ID  envId:  # 区域  region:  # 使用 Twikoo 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# Giscus 评论插件配置# 官方文档：https://giscus.app/giscus:  # 仓库地址  repo:  # 仓库 ID  repo_id:  # 分类 ID  category_id:  # 主题配置，light 为浅色主题，dark 为深色主题  theme:    light: light    dark: dark  # 其他可选配置  option:# Remark42 评论插件配置# 官方文档：https://remark42.com/docs/configuration/frontend/remark42:  # 服务器地址  host:  # 站点 ID  siteId:  # 其他可选配置  option:# Artalk 评论插件配置# 官方文档：https://artalk.js.org/guide/frontend/config.htmlartalk:  # 服务器地址  server:  # 站点名  site:  # 使用 Artalk 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# --------------------------------------# 聊天服务配置# --------------------------------------chat:  # 聊天服务类型，可选值：chatra/tidio/crisp，如果不需要聊天功能则留空  use:  # 推荐使用聊天按钮，会在网站右下角创建一个按钮，并隐藏原始按钮  rightside_button: false  # 原始聊天按钮在向上滚动时显示，向下滚动时隐藏  button_hide_show: false# Chatra 聊天服务配置# 官方网站：https://chatra.io/chatra:  # Chatra 服务 ID  id:# Tidio 聊天服务配置# 官方网站：https://www.tidio.com/tidio:  # Tidio 公钥  public_key:# Crisp 聊天服务配置# 官方网站：https://crisp.chat/en/crisp:  # Crisp 网站 ID  website_id:# --------------------------------------# 分析服务配置# --------------------------------------# 百度统计配置# 官方网站：https://tongji.baidu.com/web/welcome/loginbaidu_analytics:# 谷歌分析配置# 官方网站：https://analytics.google.com/analytics/web/google_analytics:# Cloudflare 分析配置# 官方网站：https://www.cloudflare.com/zh-tw/web-analytics/cloudflare_analytics:# Microsoft Clarity 分析配置# 官方网站：https://clarity.microsoft.com/microsoft_clarity:# --------------------------------------# 广告配置# --------------------------------------# Google Adsense 广告配置google_adsense:  # 是否启用  enable: false  # 是否自动投放广告  auto_ads: true  # 广告脚本 URL  js: https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js  # 客户 ID  client:  # 是否启用页面级广告  enable_page_level_ads: true# 手动插入广告配置，如果不需要广告则留空ad:  # 在首页每三个帖子后插入广告  index:  # 在侧边栏插入广告  aside:  # 在文章分页前插入广告  post:# --------------------------------------# 站点验证配置# --------------------------------------site_verification:  # 示例：  # - name: google-site-verification  #   content: xxxxxx  # - name: baidu-site-verification  #   content: xxxxxxx# --------------------------------------# 美化 / 效果# --------------------------------------# 主题颜色自定义# 注意：颜色值必须用双引号，如 &quot;#000&quot;，否则可能会导致错误！# 主题颜色配置# theme_color:#   是否启用主题颜色#   enable: true#   主颜色#   main: &quot;#49B1F5&quot;#   分页器颜色#   paginator: &quot;#00c4b6&quot;#   按钮悬停颜色#   button_hover: &quot;#FF7242&quot;#   文本选择颜色#   text_selection: &quot;#00c4b6&quot;#   链接颜色#   link_color: &quot;#99a9bf&quot;#   元数据颜色#   meta_color: &quot;#858585&quot;#   水平线颜色#   hr_color: &quot;#A4D8FA&quot;#   代码前景色#   code_foreground: &quot;#F47466&quot;#   代码背景色#   code_background: &quot;rgba(27, 31, 35, .05)&quot;#   目录颜色#   toc_color: &quot;#00c4b6&quot;#   引用块填充颜色#   blockquote_padding_color: &quot;#49b1f5&quot;#   引用块背景颜色#   blockquote_background_color: &quot;#49b1f5&quot;#   滚动条颜色#   scrollbar_color: &quot;#49b1f5&quot;#   浅色模式下的主题颜色#   meta_theme_color_light: &quot;ffffff&quot;#   深色模式下的主题颜色#   meta_theme_color_dark: &quot;#0d0d0d&quot;# 分类和标签页面的用户界面设置# 选择：index - 与主页 UI 相同 / default - 与归档 UI 相同# 留空或设置为 indexcategory_ui:tag_ui:# 拉伸行使每行宽度相等text_align_justify: false# 为页眉和页脚添加遮罩mask:  header: true  footer: true# 加载动画preloader:  # 是否启用加载动画  enable: false  # 资源  # 1. 全屏加载  # 2. 进度条  source: 1  # pace 主题 (参见 https://codebyzach.github.io/pace/)  pace_css_url:# 页面过渡效果enter_transitions: true# 默认显示模式 - light (默认) / darkdisplay_mode: light# 美化文章内容的配置beautify:  # 是否启用美化  enable: false  # 指定美化的范围 (site 或 post)  field: post  # 指定标题前缀图标，如 &#x27;\\f0c1&#x27;  title-prefix-icon:  # 指定标题前缀图标的颜色，如 &#x27;#F47466&#x27;  title-prefix-icon-color:# 全局字体设置# 除非您知道它们的工作原理，否则不要修改以下设置font:  global-font-size:  code-font-size:  font-family:  code-font-family:# 网站标题和副标题的字体设置blog_title_font:  font_link:  font-family:# 分隔符图标的设置hr_icon:  # 是否启用分隔符图标  enable: true  # Font Awesome 图标的 unicode 值，如 &#x27;\\3423&#x27;  icon:  icon-top:# 打字机效果# https://github.com/disjukr/activate-power-modeactivate_power_mode:  # 是否启用打字机效果  enable: false  # 是否启用彩色效果  colorful: true  # 是否启用震动效果  shake: true  # 是否在移动设备上启用  mobile: false# 背景效果# --------------------------------------# canvas_ribbon# 参见: https://github.com/hustcc/ribbon.jscanvas_ribbon:  # 是否启用 canvas_ribbon  enable: false  # ribbon 的大小  size: 150  # ribbon 的不透明度 (0 ~ 1)  alpha: 0.6  zIndex: -1  # 是否点击更改颜色  click_to_change: false  # 是否在移动设备上启用  mobile: false# Fluttering Ribboncanvas_fluttering_ribbon:  # 是否启用 Fluttering Ribbon  enable: false  # 是否在移动设备上启用  mobile: false# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest:  # 是否启用 canvas_nest  enable: false  # 线条颜色，默认: &#x27;0,0,0&#x27;; RGB 值: (R,G,B).(注意: 使用 &#x27;,&#x27; 分隔.)  color: &#x27;0,0,255&#x27;  # 线条的不透明度 (0~1)  opacity: 0.7  # 背景的 z-index 属性  zIndex: -1  # 线条数量  count: 99  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 烟花fireworks:  # 是否启用烟花效果  enable: false  zIndex: 9999  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 心形符号click_heart:  # 是否启用心形符号效果  enable: false  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 文字clickShowText:  # 是否启用文字效果  enable: false  text:    # - I    # - LOVE    # - YOU  fontSize: 15px  # 是否随机显示文字  random: false  # 是否在移动设备上启用  mobile: false# --------------------------------------# 灯箱设置# --------------------------------------# 选择: fancybox / medium_zoom# https://github.com/francoischalifour/medium-zoom# https://fancyapps.com/fancybox/# 如果不需要灯箱效果，请留空lightbox:# --------------------------------------# 标签外挂设置# --------------------------------------# 系列series:  # 是否启用系列  enable: false  # 按标题或日期排序  orderBy: &#x27;title&#x27;  # 排序方式。1, asc 为升序; -1, desc 为降序  order: 1  # 是否显示编号  number: true# ABCJS - ABC 音乐符号插件# https://github.com/paulrosen/abcjsabcjs:  # 是否启用 ABCJS  enable: false  # 是否每页启用  per_page: true# Mermaid# https://github.com/mermaid-js/mermaidmermaid:  # 是否启用 Mermaid  enable: false  # 使用代码块编写 Mermaid 图表  code_write: false  # 内置主题: default / forest / dark / neutral  theme:    light: default    dark: dark# chartjs# 参见 https://www.chartjs.org/docs/latest/chartjs:  enable: false  # 除非你了解它们的工作原理，否则不要修改。  # 默认设置仅在未指定 MD 语法时使用。  # 图表的字体颜色  fontColor:    light: &quot;rgba(0, 0, 0, 0.8)&quot;    dark: &quot;rgba(255, 255, 255, 0.8)&quot;  # 图表的边框颜色  borderColor:    light: &quot;rgba(0, 0, 0, 0.1)&quot;    dark: &quot;rgba(255, 255, 255, 0.2)&quot;  # 雷达图和极区图的刻度标签背景颜色  scale_ticks_backdropColor:    light: &quot;transparent&quot;    dark: &quot;transparent&quot;# Note - Bootstrap 提示框note:  # Note 标签样式值:  #  - simple    bs-callout 旧警告样式。默认。  #  - modern    bs-callout 新 (v2-v3) 警告样式。  #  - flat      扁平提示框样式，带背景，如 Mozilla 或 StackOverflow。  #  - disabled  禁用所有 Note 标签的 CSS 样式。  style: flat  # 是否显示图标  icons: true  # 边框半径  border_radius: 3  # 背景颜色偏移百分比 (modern: -12 | 12; flat: -18 | 6)。  # 也应用于标签变量。此选项可与禁用的 Note 标签一起使用。  light_bg_offset: 0# --------------------------------------# 其他设置# --------------------------------------# https://github.com/MoOx/pjaxpjax:  # 是否启用 pjax  enable: false  # 排除指定页面不使用 pjax，如 &#x27;/music/&#x27;  exclude:    # - /xxxxxx/# 注入 CSS 和脚本 (aplayer/meting)aplayerInject:  # 是否启用注入  enable: false  # 是否每页启用  per_page: true# Snackbar - Toast 通知# https://github.com/polonel/SnackBar# 位置: top-left / top-center / top-right / bottom-left / bottom-center / bottom-rightsnackbar:  # 是否启用 Snackbar  enable: false  # 通知位置  position: bottom-left  # 浅色模式和深色模式下的通知背景颜色  bg_light: &#x27;#49b1f5&#x27;  bg_dark: &#x27;#1f1f1f&#x27;# Instant.page# https://instant.page/instantpage: false# Lazyload# https://github.com/verlok/vanilla-lazyloadlazyload:  # 是否启用 Lazyload  enable: false  # 使用浏览器的原生 lazyload 而不是 vanilla-lazyload  native: false  # 指定使用 Lazyload 的范围 (site 或 post)  field: site  placeholder:  blur: false# PWA# 参见 https://github.com/JLHwung/hexo-offline# ---------------pwa:  # 是否启用 PWA  enable: false  # PWA manifest 文件路径  manifest:  # Apple Touch 图标路径  apple_touch_icon:  # 32x32 像素的 favicon 图标路径  favicon_32_32:  # 16x16 像素的 favicon 图标路径  favicon_16_16:  # mask 图标路径  mask_icon:# Open graph meta tags# 参见 https://hexo.io/docs/helpers#open-graphOpen_Graph_meta:  # 是否启用 Open Graph meta 标签  enable: true  option:    # twitter_card:    # twitter_image:    # twitter_id:    # twitter_site:    # google_plus:    # fb_admins:    # fb_app_id:# 结构化数据# https://developers.google.com/search/docs/guides/intro-structured-datastructured_data: true# 添加供应商前缀以确保兼容性# 是否启用 CSS 前缀css_prefix: true# Inject# 插入代码到 head（在 &#x27;&lt;/head&gt;&#x27; 标签之前）和底部（在 &#x27;&lt;/body&gt;&#x27; 标签之前）inject:  head:    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;  bottom:    # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;# CDN 设置# 除非你知道它们的工作原理，否则不要修改以下设置CDN:  # 内部和第三方脚本的 CDN 提供商  # 两者的选项：local/jsdelivr/unpkg/cdnjs/custom  # 注意： Dev 版本只能使用 &#x27;local&#x27; 作为内部脚本  # 注意：将第三方脚本设置为 &#x27;local&#x27; 时，需要安装 hexo-butterfly-extjs  internal_provider: local  third_party_provider: jsdelivr  # 是否在 URL 中添加版本号，true 或 false  version: false  # 自定义格式  # 例如：https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125;  custom_format:  option:\r\n","categories":["实用","配置相关"],"tags":["Hexo","其他","配置文件","实用类"]},{"title":"Spring中使用Hibernate整合","url":"/posts/48924.html","content":"Spring中使用Hibernate\r\nHibernate是最流行的ORM框架之一，而Spring提供了对Hibernate的出色集成支持。\r\n本文介绍如何在传统Spring框架(非Spring Boot)中集成Hibernate。\r\n项目搭建结构\r\n我们先写一个例子，来看看 Spring 中如何使用和体现 Hibernate\r\n项目结构\r\n典型的Spring框架集成Hibernate的项目目录结构（Maven项目）：\r\nsrc/├── main/│   ├── java/│   │   └── com/│   │       └── yourcompany/│   │           └── yourapp/│   │               ├── config/               # Spring配置类│   │               │   └── HibernateConfig.java│   │               ├── controller/           # 控制器层│   │               │   └── EmployeeController.java│   │               ├── service/              # 服务层│   │               │   ├── EmployeeService.java│   │               │   └── impl/│   │               │       └── EmployeeServiceImpl.java│   │               ├── dao/                  # 数据访问层│   │               │   ├── EmployeeDao.java│   │               │   └── impl/│   │               │       └── EmployeeDaoImpl.java│   │               ├── model/                # 实体类│   │               │   ├── Employee.java│   │               │   ├── Department.java│   │               │   └── enums/            # 枚举类型│   │               │       └── EmployeeStatus.java│   │               ├── dto/                  # 数据传输对象│   │               │   └── EmployeeDTO.java│   │               └── AppMain.java          # 主启动类│   ├── resources/│   │   ├── application.properties           # 应用配置│   │   ├── hibernate.cfg.xml                # Hibernate配置(可选)│   │   ├── messages/                        # 国际化资源│   │   │   └── messages.properties│   │   └── META-INF/│   │       └── persistence.xml              # JPA配置(可选)│   └── webapp/                              # Web相关资源(如果是Web应用)│       ├── WEB-INF/│       │   ├── views/                       # 视图文件│       │   │   └── employees.jsp│       │   └── web.xml                      # Web部署描述符│       └── resources/                       # 静态资源│           ├── css/│           ├── js/│           └── images/└── test/                                    # 测试代码    └── java/        └── com/            └── yourcompany/                └── yourapp/                    ├── service/                    │   └── EmployeeServiceTest.java                    └── dao/                        └── EmployeeDaoTest.java\r\n但是本次演示，还是打算写成简单一些的方式\r\n添加依赖\r\n&lt;dependencies&gt;    &lt;!-- Spring核心依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.20&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- Spring ORM (包含对Hibernate的支持) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.20&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- Hibernate核心 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;        &lt;version&gt;5.6.10.Final&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 数据库驱动 (以MySQL为例) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.29&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 连接池 (HikariCP推荐) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;        &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;        &lt;version&gt;5.0.1&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- JTA API (可选，需要事务管理时) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;        &lt;artifactId&gt;javax.transaction-api&lt;/artifactId&gt;        &lt;version&gt;1.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n配置 Spring 配置文件\r\n创建Spring配置文件applicationContext.xml，application.properties，或者使用Java配置类：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 启用注解驱动 --&gt;    &lt;context:annotation-config/&gt;    &lt;!--配置了组件扫描路径，Spring 会自动扫描指定包下的 @Component、@Service 等注解的类--&gt;    &lt;context:component-scan base-package=&quot;com.yourpackage&quot;/&gt;        &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot; destroy-method=&quot;close&quot;&gt;        &lt;!--配置 MySQL 数据库连接信息，包括驱动类、URL、用户名和密码--&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;your_username&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;your_password&quot;/&gt;        &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 配置Hibernate SessionFactory --&gt;    &lt;!-- 指定扫描实体类的包路径 --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;        &lt;!--设置 Hibernate 的方言、SQL 显示、格式化和 DDL 自动更新等属性--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;                &lt;!-- 其他Hibernate属性 --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!-- 配置事务管理器 --&gt;    &lt;!-- 配置 Hibernate 事务管理器，启用注解驱动的事务管理 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 启用注解驱动的事务管理 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;\r\nproperties 貌似是给 spring boot 用的，纯framework貌似都用xml\r\n我感觉这个更方便\r\n# 数据源配置spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;serverTimezone=UTCspring.datasource.username=your_usernamespring.datasource.password=your_passwordspring.datasource.hikari.maximum-pool-size=10# Hibernate配置spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialectspring.jpa.show-sql=truespring.jpa.properties.hibernate.format_sql=truespring.jpa.hibernate.ddl-auto=update# 扫描实体类的包路径spring.jpa.hibernate.packages-to-scan=com.yourpackage.model\r\n确保主应用类上有 @SpringBootApplication\r\n注解，它包含了 @ComponentScan 功能\r\nJava 配置方式\r\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.orm.hibernate5.HibernateTransactionManager;import org.springframework.orm.hibernate5.LocalSessionFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;import java.util.Properties;@Configuration@EnableTransactionManagementpublic class HibernateConfig &#123;    @Bean    public DataSource dataSource() &#123;        HikariDataSource dataSource = new HikariDataSource();        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;serverTimezone=UTC&quot;);        dataSource.setUsername(&quot;your_username&quot;);        dataSource.setPassword(&quot;your_password&quot;);        dataSource.setMaximumPoolSize(10);        return dataSource;    &#125;    @Bean    public LocalSessionFactoryBean sessionFactory() &#123;        LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();        sessionFactory.setDataSource(dataSource());        sessionFactory.setPackagesToScan(&quot;com.yourpackage.model&quot;);        sessionFactory.setHibernateProperties(hibernateProperties());        return sessionFactory;    &#125;    private Properties hibernateProperties() &#123;        Properties properties = new Properties();        properties.setProperty(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQL8Dialect&quot;);        properties.setProperty(&quot;hibernate.show_sql&quot;, &quot;true&quot;);        properties.setProperty(&quot;hibernate.format_sql&quot;, &quot;true&quot;);        properties.setProperty(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;);        // 其他Hibernate属性        return properties;    &#125;    @Bean    public PlatformTransactionManager transactionManager() &#123;        HibernateTransactionManager transactionManager = new HibernateTransactionManager();        transactionManager.setSessionFactory(sessionFactory().getObject());        return transactionManager;    &#125;&#125;\r\n创建实体类\r\n使用Hibernate注解定义实体类\r\nimport javax.persistence.*;import java.util.Date;/** * 员工实体类，映射数据库中的 employees 表 * 包含员工的基本信息和所属部门关联 */@Entity@Table(name = &quot;employees&quot;)    // 映射到 employees 表public class Employee &#123;        /**     * 员工ID，主键，自增长     * 使用 GenerationType.IDENTITY 依赖数据库的自增机制     */    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        /**     * 员工名，不可为空，最大长度50     */    @Column(name = &quot;first_name&quot;, nullable = false, length = 50)    private String firstName;        /**     * 员工姓，不可为空，最大长度50     */    @Column(name = &quot;last_name&quot;, nullable = false, length = 50)    private String lastName;        /**     * 员工邮箱，不可为空，必须唯一     * 通常用于系统登录或联系信息     */    @Column(nullable = false, unique = true)    private String email;        /**     * 雇佣日期，仅存储日期部分（忽略时间）     * 使用 TemporalType.DATE 映射到数据库的 DATE 类型     */    @Column(name = &quot;hire_date&quot;)    @Temporal(TemporalType.DATE)    private Date hireDate;        /**     * 所属部门，多对一关联     * 使用 FetchType.LAZY 实现延迟加载，避免查询员工时立即加载部门信息     * 通过 department_id 外键关联 departments 表     */    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name = &quot;department_id&quot;)    private Department department;        // 构造函数    public Employee() &#123; &#125;        public Employee(String firstName, String lastName, String email, Date hireDate) &#123;        this.firstName = firstName;        this.lastName = lastName;        this.email = email;        this.hireDate = hireDate;    &#125;&#125;\r\n创建DAO层\r\n传统Hibernate DAO实现\r\n这里使用了大量 session 的方法和 query 等常用 api 的方法，体现了\r\nHibernate 的使用\r\nimport org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 员工数据访问对象（DAO） * 负责与数据库进行交互，处理 Employee 实体的持久化操作 */@Repository@Transactionalpublic class EmployeeDao &#123;        /**     * Hibernate SessionFactory，由 Spring 容器注入     * 用于获取与数据库的会话（Session）     */    @Autowired    private SessionFactory sessionFactory;        /**     * 获取当前线程绑定的 Hibernate Session     * 在 @Transactional 注解的事务上下文中，Spring 会自动管理 Session 的生命周期     */    protected Session getCurrentSession() &#123;        return sessionFactory.getCurrentSession();    &#125;        /**     * 根据 ID 查询员工     * @param id 员工 ID     * @return 对应的 Employee 对象，若不存在则返回 null     */    public Employee findById(Long id) &#123;        return getCurrentSession().get(Employee.class, id);    &#125;        /**     * 保存或更新员工信息     * - 若员工 ID 为空（null），则执行插入操作     * - 若员工 ID 已存在，则执行更新操作     * @param employee 要保存或更新的 Employee 对象     */    public void save(Employee employee) &#123;        getCurrentSession().saveOrUpdate(employee);    &#125;        /**     * 删除员工记录     * @param employee 要删除的 Employee 对象     */    public void delete(Employee employee) &#123;        getCurrentSession().delete(employee);    &#125;        /**     * 查询所有员工     * @return 包含所有 Employee 对象的列表     */    @SuppressWarnings(&quot;unchecked&quot;)    public List&lt;Employee&gt; findAll() &#123;        return getCurrentSession().createQuery(&quot;from Employee&quot;).list();    &#125;        /**     * 根据姓氏查询员工     * @param lastName 要查询的姓氏     * @return 包含匹配 Employee 对象的列表     */    public List&lt;Employee&gt; findByLastName(String lastName) &#123;        return getCurrentSession()                .createQuery(&quot;from Employee where lastName = :lastName&quot;, Employee.class)                .setParameter(&quot;lastName&quot;, lastName)                .list();    &#125;&#125;\r\n主要注解解析\r\n\r\n@Repository\r\n\r\n\r\n作用\r\n\r\n声明该类为 Spring 的数据访问组件（DAO），是 @Component\r\n的特殊化版本。\r\n自动将 DAO 类注册为 Spring Bean，并支持 Spring\r\n的数据访问异常转换（将 Hibernate/JPA 异常转换为 Spring 的\r\nDataAccessException 体系）。\r\n\r\n\r\n\r\n@Transactional\r\n\r\n\r\n作用\r\n\r\n声明该类的所有公共方法都在事务管理下执行。\r\n默认配置下：\r\n\r\n事务传播行为为\r\nPROPAGATION_REQUIRED（若当前无事务，则创建新事务；否则加入当前事务）。\r\n事务隔离级别为数据库默认级别。\r\n所有 RuntimeException 会触发事务回滚，受检异常（如\r\nIOException）不会触发回滚。\r\n\r\n\r\n\r\n\r\n@Autowired\r\n\r\n\r\n作用\r\n\r\n通过类型自动注入依赖的 Bean（此处注入\r\nSessionFactory）。\r\nSpring 会在容器中查找 SessionFactory 类型的 Bean\r\n并注入。\r\n\r\n\r\n方法解析\r\n\r\ngetCurrentSession()\r\n\r\n\r\n功能：获取当前线程绑定的\r\nSession。\r\n关键点\r\n\r\n在 @Transactional\r\n注解的事务上下文中，Session 由 Spring\r\n自动管理，无需手动关闭。\r\n若不在事务中调用此方法，会抛出异常。\r\n\r\n\r\n\r\nfindById(Long id)\r\n\r\n\r\n功能：根据 ID 查询员工。\r\nHibernate 方法\r\n\r\nSession.get(Class, id)：立即查询数据库，若记录不存在返回\r\nnull。\r\n\r\n\r\n\r\nsave(Employee employee)\r\n\r\n\r\n功能：保存或更新员工。\r\nHibernate 方法\r\n\r\n``` Session.saveOrUpdate(Object)     - 若对象的 ID 为 `null` 或未持久化状态，执行 `INSERT`。    - 若对象的 ID 已存在，执行 `UPDATE`。4. `delete(Employee employee)`- **功能**：删除员工记录。- Hibernate 方法  - `Session.delete(Object)`：将对象从持久化状态变为删除状态，事务提交时执行 `DELETE` 语句。5. `findAll()`- **功能**：查询所有员工。- Hibernate 查询  - `Session.createQuery(&quot;from Employee&quot;)`：使用 HQL（Hibernate Query Language）查询，等价于 SQL 的 `SELECT * FROM employees`。  - `@SuppressWarnings(&quot;unchecked&quot;)`：抑制原始类型警告（Hibernate 5.2 前的 `createQuery()` 返回未泛型化的 `Query` 对象）。6. `findByLastName(String lastName)`- **功能**：根据姓氏查询员工。- Hibernate 查询  - `createQuery(&quot;from Employee where lastName = :lastName&quot;, Employee.class)`：使用具名参数的 HQL 查询，防止 SQL 注入。  - `setParameter(&quot;lastName&quot;, lastName)`：绑定参数值。### 服务层实现```javaimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 员工服务层 * 处理员工相关的业务逻辑，调用 DAO 层完成数据持久化操作 */@Servicepublic class EmployeeService &#123;        /**     * 员工数据访问对象     * 由 Spring 容器自动注入，用于执行数据库操作     */    @Autowired    private EmployeeDao employeeDao;        /**     * 根据 ID 获取员工信息     * @param id 员工 ID     * @return 对应的员工对象，若不存在则返回 null     */    @Transactional(readOnly = true)    public Employee getEmployeeById(Long id) &#123;        return employeeDao.findById(id);    &#125;        /**     * 保存或更新员工信息     * - 新增员工：当员工对象 ID 为空时     * - 更新员工：当员工对象 ID 已存在时     * @param employee 员工对象     */    @Transactional    public void saveEmployee(Employee employee) &#123;        employeeDao.save(employee);    &#125;        /**     * 删除员工信息     * @param employee 要删除的员工对象     */    @Transactional    public void deleteEmployee(Employee employee) &#123;        employeeDao.delete(employee);    &#125;        /**     * 获取所有员工列表     * @return 包含所有员工的列表     */    @Transactional(readOnly = true)    public List&lt;Employee&gt; getAllEmployees() &#123;        return employeeDao.findAll();    &#125;        /**     * 根据姓氏搜索员工     * @param lastName 姓氏     * @return 匹配的员工列表     */    @Transactional(readOnly = true)    public List&lt;Employee&gt; searchByLastName(String lastName) &#123;        return employeeDao.findByLastName(lastName);    &#125;&#125;\r\n\r\n\r\n主要注解解析\r\n\r\n@Service\r\n\r\n\r\n作用\r\n\r\n声明该类为 Spring 的服务层组件，是 @Component\r\n的特殊化版本。\r\n用于标识业务逻辑层，提高代码可读性和可维护性。\r\n\r\nSpring 容器行为\r\n\r\n自动扫描并注册为 Bean，可通过依赖注入使用。\r\n\r\n\r\n\r\n@Autowired\r\n\r\n\r\n作用\r\n\r\n通过类型自动注入依赖的 Bean（此处注入\r\nEmployeeDao）。\r\n\r\n依赖注入方式\r\n\r\n字段注入：简洁但不利于单元测试（建议使用构造器注入，Spring 4.3+\r\n支持单参构造器省略 @Autowired）。\r\n\r\n\r\n\r\n@Transactional\r\n\r\n\r\n作用\r\n\r\n声明方法在事务管理下执行，确保数据操作的原子性、一致性、隔离性和持久性（ACID）。\r\n\r\n关键属性\r\n\r\n```java readOnly = true     - 标记为只读事务，优化查询性能（如禁用缓存刷新、数据库优化等）。    - 仅用于查询方法，不可用于增删改操作。- 默认配置  - 传播行为：`PROPAGATION_REQUIRED`（若当前无事务，则创建新事务；否则加入当前事务）。  - 隔离级别：使用数据库默认级别（如 MySQL 的 `REPEATABLE READ`）。  - 回滚规则：默认对 `RuntimeException` 和 `Error` 回滚，对受检异常（如 `IOException`）不回滚。#### **方法解析**1. `getEmployeeById(Long id)`- **功能**：根据 ID 查询员工。- 事务特性  - `readOnly = true`：优化查询性能。- 业务逻辑  - 直接委派给 DAO 层执行数据库查询。2. `saveEmployee(Employee employee)`- **功能**：保存或更新员工信息。- 事务特性  - 读写事务，确保操作的原子性。- 业务逻辑  - 调用 DAO 层的 `save` 方法，可能触发 `INSERT` 或 `UPDATE`。3. `deleteEmployee(Employee employee)`- **功能**：删除员工信息。- 事务特性  - 读写事务，确保操作的原子性。- 业务逻辑  - 调用 DAO 层的 `delete` 方法执行物理删除。4. `getAllEmployees()`- **功能**：获取所有员工列表。- 事务特性  - `readOnly = true`：优化查询性能。- 业务逻辑  - 直接委派给 DAO 层查询所有记录。5. `searchByLastName(String lastName)`- **功能**：根据姓氏搜索员工。- 事务特性  - `readOnly = true`：优化查询性能。- 业务逻辑  - 直接委派给 DAO 层执行条件查询。#### **服务层设计原则**1. **单一职责**：   - 专注业务逻辑处理，不涉及数据访问细节（由 DAO 负责）。2. **事务边界**：   - 在服务层控制事务边界，确保业务操作的原子性（如转账需同时更新两个账户）。3. **数据校验**：   - 可在此层添加参数校验逻辑（示例中未体现，实际项目需添加）。4. **异常处理**：   - 可捕获 DAO 层异常并转换为业务异常（示例中未体现，实际项目需添加）。5. **事务传播**：   - 若方法间存在调用关系，需注意事务传播行为（默认 `REQUIRED` 可满足多数场景）。#### **注意事项**1. **事务嵌套**：   - 若服务层方法相互调用，需注意事务传播行为可能导致的意外结果（如内层方法异常导致整个事务回滚）。2. **只读事务**：   - 确保 `readOnly = true` 仅用于纯查询方法，否则可能导致数据无法持久化。3. **异常类型**：   - 业务异常建议继承 `RuntimeException`，确保事务自动回滚。### 事务管理Spring提供了声明式事务管理，可以通过注解轻松配置：```javaimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.hibernate.Hibernate; // Hibernate 特定 API@Service@Transactionalpublic class DepartmentService &#123;        @Autowired    private DepartmentDao departmentDao;        @Autowired    private EmployeeDao employeeDao;        /**     * 获取部门及其所有员工（包含延迟加载的员工集合）     * @param deptId 部门 ID     * @return 包含完整员工列表的部门对象     */    @Transactional(readOnly = true)    public Department getDepartmentWithEmployees(Long deptId) &#123;        // 1. 通过 DAO 查询部门（此时员工集合为延迟加载的代理对象）        Department dept = departmentDao.findById(deptId);                // 2. 强制初始化延迟加载的员工集合        // Hibernate 特定方法，在事务未关闭前触发 SQL 查询        Hibernate.initialize(dept.getEmployees());                // 3. 返回已初始化员工集合的部门对象        return dept;    &#125;        /**     * 批量转移员工到新部门     * @param fromDeptId 源部门 ID     * @param toDeptId   目标部门 ID     * @param employeeIds 待转移员工 ID 列表     */    @Transactional(rollbackFor = Exception.class)    public void transferEmployees(Long fromDeptId, Long toDeptId, List&lt;Long&gt; employeeIds) &#123;        // 1. 获取源部门和目标部门        Department fromDept = departmentDao.findById(fromDeptId);        Department toDept = departmentDao.findById(toDeptId);                // 2. 遍历员工 ID 列表，逐个转移        for (Long empId : employeeIds) &#123;            Employee emp = employeeDao.findById(empId);                        // 3. 从源部门移除员工（业务逻辑由实体类方法实现）            fromDept.removeEmployee(emp);                        // 4. 添加到目标部门（业务逻辑由实体类方法实现）            toDept.addEmployee(emp);                        // 5. 保存员工（更新部门关联）            employeeDao.save(emp);        &#125;                // 6. 保存部门变更（可选，取决于实体关系配置）        departmentDao.save(fromDept);        departmentDao.save(toDept);    &#125;&#125;\r\n\r\n\r\n主要注解解析\r\n\r\n@Service\r\n\r\n\r\n作用\r\n\r\n声明该类为 Spring 的服务层组件，负责业务逻辑处理。\r\n\r\nSpring 容器行为\r\n\r\n自动扫描并注册为 Bean，支持依赖注入。\r\n\r\n\r\n\r\n@Transactional（类级别）\r\n\r\n\r\n作用\r\n\r\n为所有公共方法提供默认事务配置。\r\n\r\n默认配置\r\n\r\n传播行为：PROPAGATION_REQUIRED（必要时创建新事务）。\r\n隔离级别：使用数据库默认级别。\r\n回滚规则：仅对 RuntimeException 和 Error\r\n回滚。\r\n\r\n\r\n\r\n@Transactional(readOnly = true)（方法级别）\r\n\r\n\r\n作用\r\n\r\n覆盖类级别的事务配置，标记方法为只读事务。\r\n\r\n优化点\r\n\r\nHibernate 会优化查询执行（如禁用脏检查）。\r\n数据库可优化只读事务的锁策略。\r\n\r\n\r\n\r\n@Transactional(rollbackFor = Exception.class)（方法级别）\r\n\r\n\r\n作用\r\n\r\n覆盖类级别的回滚规则，指定所有异常（包括受检异常）都触发事务回滚。\r\n\r\n适用场景\r\n\r\n确保业务异常（如\r\nValidationException）也能触发回滚。\r\n\r\n\r\n方法解析\r\n\r\ngetDepartmentWithEmployees(Long deptId)\r\n\r\n\r\n功能：获取部门及其所有员工。\r\nHibernate 集成点\r\n\r\n延迟加载处理\r\n\r\ndepartmentDao.findById(deptId) 返回的\r\nDepartment 对象中，employees 集合是 Hibernate\r\n代理对象（未初始化）。\r\nHibernate.initialize(dept.getEmployees()) 强制触发 SQL\r\n查询，在事务未关闭前加载员工数据。\r\n\r\nSession 生命周期\r\n\r\n方法在事务内执行，Session 保持打开状态，允许延迟加载初始化。\r\n\r\n\r\n\r\n\r\ntransferEmployees(...)\r\n\r\n\r\n功能：批量转移员工到新部门。\r\nHibernate 集成点\r\n\r\n实体状态管理\r\n\r\n通过 DAO 获取的 Department 和 Employee\r\n对象处于持久化状态。\r\n修改持久化对象的关联关系（如\r\nremoveEmployee、addEmployee）会被 Hibernate\r\n自动跟踪。\r\n\r\n级联操作\r\n\r\nemployeeDao.save(emp) 可能无需调用（取决于实体类的\r\ncascade 配置）。\r\n若 Department 实体配置了\r\ncascade = CascadeType.ALL，则直接保存部门即可同步员工关联。\r\n\r\n事务一致性\r\n\r\n整个方法在单个事务中执行，确保数据一致性（要么全部转移成功，要么全部失败）。\r\n\r\n\r\n\r\nHibernate 集成关键点\r\n\r\n延迟加载（Lazy Loading）处理：\r\n\r\n通过 Hibernate.initialize()\r\n强制初始化延迟集合，避免在事务外访问时抛出\r\nLazyInitializationException。\r\n依赖 @Transactional 保持 Session 打开状态。\r\n\r\n实体状态管理：\r\n\r\nHibernate 跟踪持久化对象的状态变化，事务提交时自动生成 SQL。\r\n示例中通过 removeEmployee 和 addEmployee\r\n修改实体关系，无需手动编写 SQL。\r\n\r\n级联操作：\r\n\r\n实体类的 @OneToMany 或 @ManyToOne\r\n注解可能配置了 cascade 属性（如\r\nCascadeType.PERSIST、CascadeType.MERGE），决定关联对象的自动持久化行为。\r\n\r\nSession 生命周期：\r\n\r\nSpring 的 @Transactional 管理 Hibernate Session\r\n的打开、关闭和刷新。\r\n方法执行期间 Session 保持打开，允许多次数据库操作。\r\n\r\n\r\n注意事项\r\n\r\nN+1 查询问题：\r\n\r\ngetDepartmentWithEmployees 方法通过\r\nHibernate.initialize() 解决了 N+1\r\n查询问题（先查部门，再查所有员工）。\r\n更优方案：使用 JOIN FETCH 优化查询（如\r\nSELECT d FROM Department d JOIN FETCH d.employees WHERE d.id = :id）。\r\n\r\n事务边界：\r\n\r\ntransferEmployees\r\n方法必须在单个事务内执行，否则可能导致数据不一致（如部分员工转移成功，部分失败）。\r\n\r\n异常处理：\r\n\r\nrollbackFor = Exception.class\r\n确保所有异常都触发回滚，但需谨慎使用，避免掩盖业务问题。\r\n\r\n实体关系维护：\r\n\r\n示例假设 Department 实体的 removeEmployee\r\n和 addEmployee 方法同时维护双向关联（即更新\r\nEmployee 的 department 字段）。\r\n若未正确维护双向关联，可能导致数据库与对象状态不一致。\r\n\r\n\r\n高级配置\r\n二级缓存配置\r\n为什么配置二级缓存，什么时候配置\r\n\r\n减少数据库访问压力\r\n\r\n\r\n原理：将常用数据存储在应用服务器内存或分布式缓存中（如\r\nEhcache），避免重复查询数据库。\r\n场景：高并发读场景（如商品详情、字典表），减少数据库\r\nI/O 负载，提升系统吞吐量。\r\n\r\n\r\n提升查询性能\r\n\r\n\r\n原理：直接从缓存中读取数据，响应速度远快于数据库查询（内存访问速度比磁盘快\r\n10 万倍以上）。\r\n场景：频繁查询但不常更新的数据（如用户档案、配置信息），降低延迟，改善用户体验。\r\n\r\n\r\n减轻应用层压力\r\n\r\n\r\n原理：缓存分担了应用层的数据处理压力，尤其在复杂关联查询（如Department关联Employee）时，避免重复执行\r\nHibernate 的对象关系映射（ORM）操作。\r\n\r\n\r\n降低资源消耗\r\n\r\n\r\n原理：减少数据库连接的创建和释放频率，降低 JDBC\r\n操作的资源开销（如连接池压力）。\r\n\r\n添加Ehcache依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;    &lt;version&gt;5.6.10.Final&lt;/version&gt;&lt;/dependency&gt;\r\n在Hibernate配置中添加\r\nprivate Properties hibernateProperties() &#123;    Properties properties = new Properties();    // 其他配置...    properties.setProperty(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;true&quot;);    properties.setProperty(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;);    properties.setProperty(&quot;hibernate.javax.cache.provider&quot;, &quot;org.ehcache.jsr107.EhcacheCachingProvider&quot;);    properties.setProperty(&quot;hibernate.cache.use_query_cache&quot;, &quot;true&quot;);    return properties;&#125;\r\n在实体类上添加缓存注解\r\n@Entity@Cacheable // 声明实体类可缓存@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) // 配置缓存策略public class Department &#123;    // 使用READ_WRITE策略：支持读写操作，通过数据库事务保证缓存与数据库一致性    // 适用于读多写少、需要事务安全的场景&#125;\r\n延迟加载与缓存\r\npublic Department getDepartmentWithEmployees(Long deptId) &#123;    Department dept = departmentDao.findById(deptId);    Hibernate.initialize(dept.getEmployees()); // 手动初始化懒加载集合    return dept;&#125;\r\n若Department的employees集合使用二级缓存，初始化时会直接从缓存加载数据，避免执行SELECT * FROM employees WHERE department_id = ?的\r\nSQL 查询\r\n集成测试\r\nimport org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.transaction.annotation.Transactional;@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;HibernateConfig.class&#125;)@Transactionalpublic class EmployeeServiceTest &#123;        @Autowired    private EmployeeService employeeService;        @Test    public void testSaveAndFindEmployee() &#123;        Employee emp = new Employee();        emp.setFirstName(&quot;John&quot;);        emp.setLastName(&quot;Doe&quot;);        emp.setEmail(&quot;john.doe@example.com&quot;);        emp.setHireDate(new Date());                employeeService.saveEmployee(emp);                Employee found = employeeService.getEmployeeById(emp.getId());        assertNotNull(found);        assertEquals(&quot;John&quot;, found.getFirstName());    &#125;&#125;\r\n与传统Hibernate的区别\r\n在纯Hibernate应用中，你需要手动管理：\r\n\r\nSessionFactory的创建和关闭\r\nSession的生命周期\r\n事务边界\r\n异常处理\r\n\r\n而在Spring集成Hibernate中：\r\n\r\nSpring管理SessionFactory的生命周期\r\n通过HibernateTemplate或@Transactional自动管理Session\r\n声明式事务管理\r\nSpring的统一异常体系转换Hibernate异常\r\n\r\n关于配置 SessionFactory\r\n\r\n本部分感谢\r\nhttps://www.cnblogs.com/jwen1994/p/11299355.html，个人做出完善和修改\r\n\r\n使用 Hibernate\r\n框架的首要工作是编写Hibernate的配置文件，其次是如何使用这些配置文件实例化\r\nSessionFactory，创建 Hibernate 的基础设施。\r\nSpring 为创建 SessionFactory 提供了一个好用的 FactoryBean\r\n工厂类：org.springframework.orm.hibernateX.LocalSessionFactoryBean，通过配置一些必要的属性，就可以获取一个SessionFactoryBean。\r\nLocalSessionFactoryBean配置灵活度很高，支持开发者的不同习惯，让开发者拥有充分的选择权——这是Spring一贯的风格。\r\n贴合Hibernate的配置方式\r\n使用 HibernateAPI 创建一个 SessionFactory 的过程\r\n\r\n首先编写好对象关系的映射文件 xxx.hbm.xml；\r\n然后通过 Hibernate 的配置文件 hibernate.cfg.xml 将所有的\r\nxxx.hbm.xml 映射文件组装起来；\r\n最后通过以下经典的代码得到 SessionFactory 的实例：\r\nConfiguration cfg = new Configuration().configure(&quot;hibernate.cfg.xml&quot;)：SessionFactory sessionFactory = cfg.buildSessionFactory()；\r\n\r\nhibernate.cfg.xml 配置文件拥有创建 Hibernate\r\n基础设施所需的配置信息，来看一个最简单的 Hibernate 配置文件\r\n&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;property name=&quot;connection.driver_class&quot;&gt;            com.mysql.jdbc.Driver        &lt;/property&gt;        &lt;property name=&quot;connection.url&quot;&gt;            jdbc:mysql://localhost:3306/sampledb        &lt;/property&gt;        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;connection.password&quot;&gt;1234&lt;/property&gt;        &lt;property name=&quot;dialect&quot;&gt;            org.hibernate.dialect.MySQLDialect        &lt;/property&gt;        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;        &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;        &lt;mapping resource=&quot;com/smart/domain/Forum.hbm.xml&quot; /&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;\r\n这个配置文件定义了3个方面的信息：数据源、映射文件及 Hibernate\r\n控制属性。\r\n既然在 Hibernate 中可以使用一个配置文件创建一个\r\nSessionFactory 实例，在 Spring\r\n中也可以顺理成章地通过指定一个Hibernate配置文件，利用\r\nLocalSessionFactoryBean 来达到相同的目的。\r\n&lt;!-- 直接使用hibernate配置 --&gt;&lt;bean id=&quot;sessionFactory&quot;　　class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;　　p:configLocation=&quot;classpath:hibernate.cfg.xml&quot;/&gt;①      &lt;!--对应我上述xml文件中，也是使用了这种方式--&gt;&lt;!-- 配置Hibernate SessionFactory --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;\r\n如①处所示，通过 configLocation\r\n属性指定了一个Hibernate 配置文件。如果有多个\r\nHibernate 配置文件，则可以通过 configLocations\r\n属性指定，多个文件之间用逗号分隔。\r\nLocalSessionFactoryBean 将利用 Hibernate\r\n配置文件创建一个 SessionFactory 代理对象，以便和 Spring\r\n的事务管理机制配合工作：当数据访问代码使用 SessionFactory\r\n时，可以获取线程绑定的\r\nSession，不管工作在本地或全局的事务，都能正确参与到当前的\r\nSpring 事务管理中去。\r\n更具 Spring\r\n风格的配置\r\nSpring 对 ORM\r\n技术的一个重要支持就是提供统一的数据源管理机制，也许更多的开发者更愿意使用\r\nSpring 配置数据源，即在 Spring 容器中定义数据源、指定映射文件、设置\r\nHibernate 控制属性等信息，完成集成组装的工作，完全抛开 hibernate.cfg.xml\r\n配置文件，如下面代码所示。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;    &lt;!-- 1. 加载外部属性文件 --&gt;    &lt;!--加载类路径下的 jdbc.properties 文件，使配置中可使用 $&#123;key&#125; 占位符引用属性值。--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;        &lt;!-- 2. 配置数据源 (使用 DBCP 连接池) --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;          p:driverClassName=&quot;$&#123;jdbc.driverClassName&#125;&quot;          p:url=&quot;$&#123;jdbc.url&#125;&quot;          p:username=&quot;$&#123;jdbc.username&#125;&quot;          p:password=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;!-- 3. 配置 Hibernate SessionFactory --&gt;    &lt;!-- 数据源注入：通过 p:dataSource-ref=&quot;dataSource&quot; 关联数据源 --&gt;    &lt;bean id=&quot;sessionFactory&quot;          class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;          p:dataSource-ref=&quot;dataSource&quot;&gt; &lt;!-- 注入数据源 --&gt;                  &lt;!-- ②指定实体类映射文件位置 --&gt;        &lt;property name=&quot;mappingLocations&quot;&gt;            &lt;list&gt;                &lt;value&gt;classpath*:/com/smart/orm/domain/Forum.hbm.xml&lt;/value&gt;                &lt;value&gt;classpath*:/com/smart/orm/domain/Topic.hbm.xml&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;                &lt;!-- 配置 Hibernate 核心属性 --&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;                    org.hibernate.dialect.MySQLDialect &lt;!-- 指定数据库方言 --&gt;                &lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;                    true &lt;!-- 显示执行的 SQL 语句 --&gt;                &lt;/prop&gt;                &lt;!-- 其他可配置属性:                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;!-- 自动更新数据库表结构 --&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;!-- 格式化 SQL 输出 --&gt;                &lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt; &lt;!-- 添加 SQL 注释 --&gt;                &lt;prop key=&quot;hibernate.connection.autocommit&quot;&gt;false&lt;/prop&gt; &lt;!-- 禁用自动提交 --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!-- 4. 配置事务管理器 --&gt;    &lt;!--集成 Hibernate 事务管理--&gt;    &lt;bean id=&quot;transactionManager&quot;           class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 5. 启用注解驱动的事务管理 --&gt;    &lt;!--启用 @Transactional 注解支持--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;        &lt;!-- 6. 其他 Bean 配置 (示例) --&gt;    &lt;bean id=&quot;forumService&quot; class=&quot;com.smart.service.ForumServiceImpl&quot;&gt;        &lt;property name=&quot;forumDao&quot; ref=&quot;forumDao&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;forumDao&quot; class=&quot;com.smart.dao.hibernate.ForumDaoHibernate&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n数据源、映射文件及 Hibernate 控制属性这三方面的信息在\r\nLocalSessionFactoryBean 中得到了完美集成，完全替代了\r\nhibernate.cfg.xml 的作用，但这种配置对于 Spring 开发者而言更加亲切。\r\n首先\r\n&lt;bean id=&quot;sessionFactory&quot;      class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;      p:dataSource-ref=&quot;dataSource&quot;&gt; &lt;!-- 注入数据源 --&gt;\r\n处指定的数据源是 Spring 容器中的数据源，不管是直接在 Spring\r\n容器中配置，还是通过  从 EJB\r\n容器中获取，对引用者而言是完全透明的。\r\n其次，凭借 Spring 资源处理的强大功能，指定 Hibernate\r\n映射文件变得相当灵活。在②&lt;property name=\"mappingLocations\"&gt;处采用了逐个指定映射文件的方法，其实这个方法是最笨拙的。由于\r\nmappingLocations 属性的类型是\r\nResource[]，因此它还支持以下简洁的配置方式：\r\n通过 Ant 风格的通配符\r\n批量加载指定包下的所有映射文件，避免逐个罗列。\r\n示例配置：\r\n&lt;property name=&quot;mappingLocations&quot;&gt;    &lt;list&gt;        &lt;!-- 扫描 com.smart.orm.domain 包及其所有子包下的所有 hbm.xml 文件 --&gt;        &lt;value&gt;classpath*:/com/smart/orm/domain/**/*.hbm.xml&lt;/value&gt;        &lt;!-- 扫描 classpath 根目录下的所有 hbm.xml 文件 --&gt;        &lt;value&gt;classpath*:/*.hbm.xml&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;\r\n若使用 JPA 注解（如 @Entity） 替代传统\r\n.hbm.xml 映射文件，可通过 packagesToScan\r\n属性自动扫描实体类所在包，彻底摆脱手动配置映射路径的繁琐。\r\n&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;    &lt;!-- 数据源注入 --&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 自动扫描实体类所在包（替代 mappingLocations） --&gt;    &lt;property name=&quot;packagesToScan&quot;&gt;        &lt;list&gt;            &lt;value&gt;com.smart.orm.domain&lt;/value&gt; &lt;!-- 扫描单个包 --&gt;            &lt;value&gt;com.other.module.entity&lt;/value&gt; &lt;!-- 支持多包 --&gt;        &lt;/list&gt;    &lt;/property&gt;        &lt;!-- Hibernate 属性配置 --&gt;    &lt;property name=&quot;hibernateProperties&quot;&gt;        &lt;props&gt;            &lt;!-- 启用 JPA 注解驱动 --&gt;            &lt;prop key=&quot;hibernate.archive.autodetection&quot;&gt;class, hbm&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\r\n\r\nSpring 会扫描 packagesToScan 指定的包，自动识别标注\r\n@Entity、@MappedSuperclass 等注解的类。\r\n无需手动维护映射文件列表，完全契合 “约定优于配置” 原则。\r\n\r\n若厌倦 XML 配置，可改用纯 Java 代码配置 SessionFactory：\r\n@Configuration@EnableTransactionManagementpublic class HibernateConfig &#123;    @Bean    public LocalSessionFactoryBean sessionFactory(DataSource dataSource) &#123;        LocalSessionFactoryBean factory = new LocalSessionFactoryBean();        factory.setDataSource(dataSource);        factory.setPackagesToScan(&quot;com.smart.orm.domain&quot;); // 包扫描        Properties hibernateProps = new Properties();        hibernateProps.put(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQLDialect&quot;);        factory.setHibernateProperties(hibernateProps);        return factory;    &#125;&#125;\r\n对应了我上面java配置类配置 SessionFactory 的部分\r\n使用\r\nHibernateTemplate\r\n基于模板类使用 Hibernate 是最简单的方式，它可以在不牺牲 Hibernate\r\n强大功能的前提下，以一种更简洁的方式使用 Hibernate，极大地降低了\r\nHibernate 的使用难度。按照 Spring 的风格，它提供了使用模板的支持类\r\nHibernateDaoSupport，并通过\r\ngetHibernateTemplate()方法向子类开放模板类实例的调用。\r\n把我的Dao类拿过来作为分析\r\nimport org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;@Repository@Transactionalpublic class EmployeeDao &#123;        @Autowired    private SessionFactory sessionFactory;        protected Session getCurrentSession() &#123;      // 获取 Session        return sessionFactory.getCurrentSession();    &#125;        public Employee findById(Long id) &#123;        return getCurrentSession().get(Employee.class, id);   // 获取实体对象    &#125;        public void save(Employee employee) &#123;        getCurrentSession().saveOrUpdate(employee);    //①保存实体对象    &#125;        public void update(Employee employee) &#123;         getCurrentSession().update(employee);//②更改实体对象    &#125;        public void delete(Employee employee) &#123;        getCurrentSession().delete(employee);    &#125;        @SuppressWarnings(&quot;unchecked&quot;)    public List&lt;Employee&gt; findAll() &#123;        return getCurrentSession().createQuery(&quot;from Employee&quot;).list();    &#125;        public List&lt;Employee&gt; findByLastName(String lastName) &#123;        // 使用 hql 查询        return getCurrentSession()                .createQuery(&quot;from Employee where lastName = :lastName&quot;, Employee.class)                .setParameter(&quot;lastName&quot;, lastName)                .list();    &#125;&#125;\r\nHibernateTemplate 代理了 HibernateSession\r\n的大多数持久化操作，并以一种更简洁的方式提供调用。 HibernateTemplate\r\n所提供的大部分方法对于 Hibernate\r\n开发者来说都是熟悉亲切的，模板类的方法大都可以在 Session\r\n接口中找到镜像。\r\n基于\r\nHibernateTemplate 的 DAO 重构\r\n传统方式通过 SessionFactory.getCurrentSession() 获取\r\nSession，而使用 HibernateTemplate 时，需继承\r\nHibernateDaoSupport 类，该类提供模板实例\r\nhibernateTemplate，并自动管理 Session\r\n的生命周期（包括事务和异常处理）。\r\nimport org.springframework.orm.hibernate5.support.HibernateDaoSupport;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class EmployeeDao extends HibernateDaoSupport &#123; // 继承 HibernateDaoSupport        // 无需手动注入 SessionFactory，由父类通过 setSessionFactory 方法自动注入        public Employee findById(Long id) &#123;        return getHibernateTemplate().get(Employee.class, id); // 直接使用模板方法    &#125;        public void save(Employee employee) &#123;        getHibernateTemplate().saveOrUpdate(employee); // 模板方法替代原生 Session    &#125;        public void update(Employee employee) &#123;        getHibernateTemplate().update(employee); // 等效于原生 Session.update()    &#125;        public void delete(Employee employee) &#123;        getHibernateTemplate().delete(employee); // 模板方法替代原生 Session    &#125;        public List&lt;Employee&gt; findAll() &#123;        return getHibernateTemplate().find(&quot;from Employee&quot;); // 简化 HQL 查询    &#125;        public List&lt;Employee&gt; findByLastName(String lastName) &#123;        // 使用命名参数的简化写法        return getHibernateTemplate().findByNamedParam(            &quot;from Employee where lastName = :lastName&quot;,             &quot;lastName&quot;,             lastName        );    &#125;&#125;\r\n\r\n继承 HibernateDaoSupport：\r\n\r\n父类提供 hibernateTemplate 模板实例，通过\r\ngetHibernateTemplate() 访问。\r\n自动处理 Session 的打开、关闭和异常转换（如将 Hibernate\r\n异常转为 Spring DataAccessException）。\r\n\r\n简化的 API 调用：\r\n\r\ngetHibernateTemplate().get(...) 替代\r\nsessionFactory.getCurrentSession().get(...)。\r\nfindByNamedParam(...)\r\n方法直接处理命名参数，无需手动创建 Query 对象。\r\n\r\n无需手动管理事务：\r\n\r\n事务由 Spring 的 @Transactional 注解统一管理（需在\r\nService 层或 DAO 层方法上声明）。\r\n\r\n\r\n常用的API方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\nget(Class entityClass, Serializable id)\r\n根据 ID 获取实体（等效 Session.get()）。\r\n\r\n\r\nload(Class entityClass, Serializable id)\r\n根据 ID 加载实体（支持延迟加载，等效\r\nSession.load()）。\r\n\r\n\r\nsave(Object entity)\r\n保存新实体（等效 Session.save()）。\r\n\r\n\r\nupdate(Object entity)\r\n更新现有实体（等效 Session.update()）。\r\n\r\n\r\nsaveOrUpdate(Object entity)\r\n自动判断保存或更新（等效\r\nSession.saveOrUpdate()）。\r\n\r\n\r\ndelete(Object entity)\r\n删除实体（等效 Session.delete()）。\r\n\r\n\r\nfind(String hql)\r\n执行 HQL 查询，返回结果列表（等效\r\nSession.createQuery(...).list()）。\r\n\r\n\r\nfindByNamedParam(String hql, String paramName, Object value)\r\n使用命名参数的 HQL 查询，防止 SQL 注入。\r\n\r\n\r\nexecute(HibernateCallback action)\r\n执行自定义回调逻辑，支持原生 Session 操作。\r\n\r\n\r\n\r\n使用回调接口（HibernateCallback）\r\n一般情况下，使用模板类的简单代理方法就可以满足要求了，如果希望使用更多\r\nHibernate 底层的功能，则可以使用回调接口。Spring\r\n定义了一个回调接口org.springframework.orm.hibernate5.HibernateCallback，该接口拥有唯一的方法，如下：\r\nT dolnHibernate(org.hibernate.Session session) throws HibernateException,SQLException\r\n该接口配合 HibernateTemplate 进行工作，它无须关心 HibernateSession\r\n的打开/关闭等操作，仅需定义数据访问逻辑即可。可以通过该接口返回结果，结果可以是一个实体对象或一个实体对象的\r\nList。回调接口中抛出的异常将传播到模板类中并被转换成 Spring DAO\r\n异常体系的对应类。\r\nHibernateTemplate 定义了两个使用 HibernateCallback\r\n回调接口的方法。\r\n\r\n&lt;T&gt; T execute(HibernateCallback\r\naction)：一般使用该方法执行数据更新、新增等操作。\r\nList executeFind(HibernateCallback&lt;?&gt;\r\naction)：一般使用该方法执行数据查询操作，返回的结果是一个List。\r\n\r\npublic long getEmployeeNum() &#123;    Long EmployeeNum = getHibernateTemplate().execute(            new HibernateCallback&lt;Long&gt;() &#123;                public Long doInHibernate(Session session) throws HibernateException&#123;                    Object obj = session.createQuery(&quot;select count(e.EmployeeId) from Employee e&quot;)                            .list()                            .iterator()                            .next();                    return (Long) obj;                &#125;            &#125;);    return EmployeeNum;&#125;\r\n当需要执行模板类未封装的原生操作（如分页查询、存储过程调用）时，可通过\r\nexecute 方法传入 HibernateCallback\r\n回调接口，在其中使用原生 Session API。\r\npublic List&lt;Employee&gt; findByPage(int pageNum, int pageSize) &#123;    int firstResult = (pageNum - 1) * pageSize;    return getHibernateTemplate().execute(session -&gt; &#123;        Query&lt;Employee&gt; query = session.createQuery(&quot;from Employee&quot;, Employee.class);        query.setFirstResult(firstResult);        query.setMaxResults(pageSize);        return query.getResultList();    &#125;);&#125;\r\n关键点：\r\n\r\n回调接口中的 session 是当前事务绑定的\r\nSession，无需手动关闭。\r\n可直接使用原生 Query 对象，实现复杂查询逻辑（如\r\nsetParameter()、setLockMode() 等）。\r\n\r\n在 Spring 中配置 DAO\r\n在编写好基于 HibernateTemplate的DAO 类后，接下来要做的就是在 Spring\r\n中进行具体配置，使该 DAO 生效\r\n为 HibernateDaoSupport 注入\r\nSessionFactory HibernateDaoSupport\r\n父类需要 SessionFactory 来创建\r\nHibernateTemplate，可通过 XML 中\r\n`的sessionFactory` 属性注入。\r\n\t&lt;!-- 启用注解驱动和组件扫描 --&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.yourpackage&quot;/&gt; &lt;!-- 扫描 DAO、Service 等组件 --&gt;    &lt;!-- 配置 Hibernate SessionFactory --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt; &lt;!-- 扫描实体类包 --&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;!-- 开发环境自动更新表结构 --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置 DAO：为 HibernateDaoSupport 注入 sessionFactory --&gt;    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.yourpackage.dao.EmployeeDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;!-- 关键配置 --&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n\r\n&lt;bean id=\"employeeDao\"&gt;中的\r\nsessionFactory 属性： 必须为\r\nHibernateDaoSupport 子类注入\r\nSessionFactory，否则 hibernateTemplate\r\n无法初始化。\r\n组件扫描： context:component-scan\r\n会自动扫描标注 @Repository 的\r\nEmployeeDao，无需手动注册 Bean（若 XML 中显式声明\r\nBean，则以 XML 配置为准）。\r\n这样 Dao 类的 @Repository 及 @Autowired 注解就可以起作用，将\r\nForumHibernateDao 装配为 Spring 容器中的 Bean。\r\n\r\n注解配置的详解\r\n和 Spring 类似，Hibernate 不但可以使用 XML 提供 ORM\r\n的配置信息，也可以直接在领域对象类中通过注解定义 ORM 映射信息。Hibernate\r\n不但自已定义了一套注解，还支持 JPA 注解。这种方式比传统的 XML\r\n映射文件更加直观、简洁，并且将映射信息直接与实体类关联在一起。\r\nimport javax.persistence.*;import java.util.Date;@Entity@Table(name = &quot;employees&quot;)public class Employee &#123;        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;first_name&quot;, nullable = false, length = 50)    private String firstName;        @Column(name = &quot;last_name&quot;, nullable = false, length = 50)    private String lastName;        @Column(nullable = false, unique = true)    private String email;        @Column(name = &quot;hire_date&quot;)    @Temporal(TemporalType.DATE)  // @Temporal：定义日期类型的精度    private Date hireDate;        @ManyToOne(fetch = FetchType.LAZY)   // 定义多对一关联,fetch = FetchType.LAZY：启用延迟加载    @JoinColumn(name = &quot;department_id&quot;)  // @JoinColumn：指定外键列名    private Department department;        // 构造函数、getter和setter    // ...&#125;\r\nHibemate 通过 AnnotationConfiguration 的\r\naddAnnotatedClass()或 addPackage()方法加载使用\r\nJPA 注解的实体类，获取映射的元数据信息，并在此基础上创建\r\nSessionFactory 实例。\r\n需要特别注意的是，使用 addPackage 并不是加载类包下所有标注了 ORM\r\n注解的实体类，而是加载类包下 package-info.java 文件中定义的\r\nAnnotation，而该类包下的所有持久化类仍然需要通过 addAnnotatedClass()\r\n方法加载。\r\nSpring 专门提供了一个配套的\r\nAnnotationSessionFactoryBean，用于创建基于 JPA 注解的\r\nSessionFactory。\r\n&lt;bean id=&quot;sessionFactory&quot;       class=&quot;org.springframework.orm.hibernate5.annotation.AnnotationSessionFactoryBean&quot;  p:dataSource—ref=&quot;dataSource&quot;&gt;    &lt;property name=&quot;annotatedClasses&quot;&gt;②        &lt;list&gt;            &lt;value&gt;com.smart.orm.domain.Forum&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--或--&gt;    &lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/prop&gt;            &lt;!-- 其他Hibernate配置 --&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\r\nAnnotationSessionFactoryBean 扩展了 LocalSessionFactoryBean\r\n类，增强的功能是：可以根据实体类的注解获取 ORM\r\n的配置信息。也可以混合使用 XML 配置和注解配置对象关系映射，Hibernate\r\n内部自动将这些元数据信息进行整合，并不会产生冲突。\r\nannotatedCIasses 属性指定使用 JPA\r\n注解的实体类名，如②处所示。如果实体类比较多，不要想当然地以为通过annotatedPackages\r\n属性指定实体类所在包名就可以了，annotatedPackages\r\n在内部通过调用 Hibernate 的 AnnotationConfiguration 的\r\naddPackage() 方法加载包中package-info.java\r\n文件定义的 Annotation，而非包中标注注解的实体类。\r\nSpring 为了通过扫描方式加载带注解的实体类，提供了一个易用的\r\npackagesToScan 属性，可以指定一系列包名，Spring\r\n将扫描并加载这些包路径（包括子包）的所有带注解实体类。\r\npackagesToScan 属性可接收多个类包路径，用逗号分隔即可，例如：\r\n&lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt;\r\n事务处理\r\nSpring 的通用事务管理模型对 Hibernate\r\n是完全适用的，包括编程式事务、基于 TransactionProxyFactoryBean、基于\r\naop/tx 及基于 @Transaction\r\n注解的事务管理。在这里，仅给出基于 @Transaction 注解的事务管理。\r\n@Service@Transactionalpublic class DepartmentService &#123;        @Autowired    private DepartmentDao departmentDao;        @Autowired    private EmployeeDao employeeDao;        // 类级别的事务配置适用于所有方法    // 方法级别的事务配置会覆盖类级别的配置        @Transactional(readOnly = true)    public Department getDepartmentWithEmployees(Long deptId) &#123;       ...    &#125;        @Transactional(rollbackFor = Exception.class)    public void transferEmployees(Long fromDeptId, Long toDeptId, List&lt;Long&gt; employeeIds) &#123;      ...    &#125;&#125;\r\n其次，在 Spring 配置文件中配置 Hibernate\r\n事务管理器，并启用注解驱动事务。\r\n &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;        &lt;!--为事务管理器指定sessionFactory--&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;        &lt;!--②默认查找名为transactionManager的事务管理器，因此可以不显示指定--&gt;\t\t&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 启用注解驱动的事务管理 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;\r\nHibernate 的事务管理器需要注入一个 sessionFactory\r\n实例，将其命名为 transactionManager 后，在\r\n&lt;tx:annotation-driven/&gt; 中就无须通过\r\ntransaction-manager 默认显式指定了。不管\r\nDepartmentServiceImpl所用的 DAO 是基于 HibernateTemplate\r\n还是基于 Hibernate 原生的API，DepartmentServiceImpl\r\n中的所有方法都具有事务性。\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识","Spring Data JPA","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"Hello World","url":"/posts/16107.html","content":"常用命令\r\nQuick Start\r\nCreate a new post\r\n$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\nWrite Drafts\r\nhexo n draft draft1\r\n在source\\目录下创建_drafts目录，并生成一个draft1.md文件\r\n当你编辑完草稿后，可以把文章推送到_posts目录下\r\n$ hexo publish &lt;file_name&gt;\r\n或\r\nhexo --draft\r\nDeploy In Github\r\n# 清理旧文件hexo clean# 生成新文件hexo g# 部署到 GitHub Pageshexo dhexo server\r\n引用图片\r\n![alt](path [title])\r\npath是必选的，表示图片的路径，可使用绝对或相对路径。\r\nalt是可选的，是图片无法加载时的替代描述文本。\r\ntitle是可选的，是图片的标题\r\n将所有文章的图片放到source/images\r\n文件夹中，然后使用markdown语句引用图片\r\n或\r\n为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：\r\n\r\n在博客根目录打开_config.yml文件做如下修改：\r\nyaml post_asset_folder: true\r\n然后使用hexo n text命令后创建一个使用post布局名为text的文章，你将发现hexo在\\source\\_post文件夹下创建了一个\\text文件夹以及同名的.md文件：\r\n最后就可以打开text.md文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。注意：请不要自作聪明将text.md文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用\r\n\r\nhexo插入图片的原生语法\r\n使用 Hexo 的 asset_img 标签\r\n&#123;% asset_img 文件名.后缀 图片描述 %&#125;\r\n\r\n需要将图片放在 source/images/ 目录下（或\r\n_config.yml 中 post_asset_folder: true\r\n时与文章同名的文件夹中）\r\n文件名需要包含后缀（如 .jpg, .png\r\n等）\r\n\r\n使用 HTML 的 标签\r\n&lt;img src=&quot;图片路径&quot; alt=&quot;图片描述&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;\r\n插入视频\r\n&lt;video width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;source src=video_path&gt;&lt;/video&gt;\r\n\r\nvideo_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。\r\nwidth和height是视频区块的宽度和高度，可自定义。\r\n\r\n引用和代码区块\r\n&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content...&#123;% endblockquote %&#125;\r\n例如：\r\nQuick Start\r\nluzhengli hello-worldluzhengli.github.io/2020/04/10/hello-world\r\n还有一种简单的引用语法：\r\n&gt; 这也是引用&gt;&gt; 引用1&gt;&gt; 饮用2\r\n\r\n这也是引用\r\n引用1\r\n饮用2\r\n\r\n代码用Hexo的太麻烦了\r\n用markdown原来的```得了\r\nMermaid画流程图\r\n语法\r\n\n    内容\n  \r\nbutterfly主题的标签外挂语法\r\n&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;&#123;% note [class] [no-icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125;\r\nbutterfly主题下的tag-hide\r\n如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。\r\ninline 在文本里面添加按钮隐藏内容，只限文字\r\n( content 不能包含英文逗号，可用 &amp;sbquo;)\r\n&#123;% hideInline content,display,bg,color %&#125;\r\n参数 解释 content 文本内容 display 【可选】按钮显示的文字 bg\r\n【可选】按钮的背景颜色 color 【可选】按钮文字的颜色\r\n哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人? &#123;% hideInline ErgouTree %&#125;\r\n哪个英文字母最酷？ 查看答案因为西装裤(C装酷)\r\n门里站着一个人? ClickErgouTree\r\nbutterfly主题下的tabs\r\n&#123;% tabs Unique name, [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\n\r\n\r\nimage-20250415170911049\r\n\r\n\r\n\r\nimage-20250415170911049\r\n\r\n&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\ntest1 1test1 2test1 3This is Tab 1.This is Tab 2.This is Tab 3.\r\n&#123;% tabs test4 %&#125;&lt;!-- tab 第一个Tab --&gt;**tab 名字为第一个 Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有 Tab 名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\n第一个Tab炸弹tab 名字为第一个 Tab只有图标 没有 Tab 名字名字+icon\r\n文章写完之后\r\n编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。\r\n生成/删除静态文件\r\n\r\n生成静态文件命令：hexo generate或 hexo g\r\n删除静态文件命令：hexo clean\r\n\r\n正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果\r\npublic 目录存在，那么 hexo g\r\n只会重新生成改动的文件。\r\n如果发生了一些错误，可以先删除静态文件，然后再重新生成。hexo g命令还提供了一个参数-f提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。\r\n启动本地端口\r\n\r\n命令：hexo server或 hexo s\r\n\r\n"},{"title":"Docker和WSL2的安装","url":"/posts/61013.html","content":"Docker简介\r\n简而言之，Docker\r\n是一个可供开发者通过容器(container)来构建，运行和共享应用(application)的平台。用容器来部署应用被称为集装箱化(containerization)。\r\n\r\nDocker\r\n就像一个盒子，里面可以装很多物件，如果需要某些物件，可以直接将该盒子拿走，而不需要从该盒子中一件一件的取。\r\nDocker中文社区、Docker中文文档\r\n\r\nDocker 包括三个基本概念:\r\n\r\n镜像（Image）\r\n\r\nDocker的镜像概念类似于虚拟机里的镜像(比如.ISO文件)，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。\r\n例如：一个镜像可以包含一个完整的 ubuntu\r\n操作系统环境，里面仅安装了MySQL或用户需要的其它应用程序。\r\n这里的镜像就如下方虚拟机创建时候使用的镜像类似。这个镜像便于移动,并且这个镜像我们可以交给任何人使用,其他人使用的时候也很方便,只需要将其实例化即可。\r\n\r\n\r\n容器（Container）\r\n\r\nDocker容器是由Docker镜像创建的运行实例，类似VM虚拟机，支持启动，停止，删除等。\r\n每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。\r\n容器就类似与虚拟机中我们创建好的虚拟机系统,之后我们所有的操作都是在容器中进行的,我们的程序也是运行在容器中。\r\n\r\n\r\n仓库（Repository）\r\n\r\n镜像便于传播,而仓库就是专门用来传播这些镜像的地方,他有点类似与Github,或者你可以把他看成一个存放各种镜像的镜像商店\r\nDocker官方的仓库:\r\n他的服务器处于国外,所以下载速度较慢,不过我们可以通过换源解决。\r\ndaocloud国内仓库:\r\n国内也有一些优秀的商店，他和Docker官方的仓库的区别类似与Github和Gitee的区别。\r\n网易云镜像中心\r\n\r\n\r\n本博客主要解决在Windows环境下,快速上手使用Docker的问题,主要会介绍在Windows系统下Docker\r\nDesktop的安装,Docker\r\n基础命令,比如说下载镜像、实例化镜像、使用容器、关闭容器、删除容器、使用仓库、创建镜像等模块的使用。其他系统应该除了安装外其他操作都可以通用。\r\nDocker安装(Winodws)\r\n开启 Hyper-V\r\n程序与功能中，启用或关闭 Windows 功能\r\n\r\n\r\nimage-20250428162725009\r\n\r\n\r\n\r\necb02f08-dae6-486f-a04d-59bb367bc266\r\n\r\n下载 Docker Desktop\r\nGet Started with\r\nDocker\r\n\r\n\r\nimage-20250428163024009\r\n\r\n打开安装包加载一会后一般会弹出两个选项,在较旧的Windows10或之前的系统会出现如下所示的相关提示。我们把第一个选上,第二个根据需求选择即可。\r\n\r\n\r\n在这里插入图片描述\r\n\r\n而较新的Windows则会出现一个使用wsl2的提示(最少是1903以上,推荐为2004或更高版本),如果使用wsl2则docker的性能会发挥更好。如下图,这里推荐使用WSL2,如果之后安装完成后发生报错可能是WSL2版本比较老,需要更新导致的\r\n\r\n\r\nimage-20250428163938231\r\n\r\n换源，使用阿里云\r\n注册一个阿里云阿里云账号。进入管理控制台界面。\r\n进入控制台\r\n\r\n\r\nimage-20250428164255993\r\n\r\n进入产品与服务\r\n\r\n\r\nimage-20250428164322730\r\n\r\n进入镜像加速器中，获取加速器地址\r\n\r\n\r\nimg\r\n\r\n打开安装好的docker的主界面：在设置界面找到Docker\r\nEngin，将复制好的加速器地址填入即可\r\n\r\n\r\nimage-20250428164537614\r\n\r\n&#123;  &quot;registry-mirrors&quot;:[    &quot;仓库地址&quot;  ],  &quot;builder&quot;: &#123;    &quot;gc&quot;: &#123;      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,      &quot;enabled&quot;: true    &#125;  &#125;,  &quot;experimental&quot;: true&#125;\r\ngithub上有个项目:docker_mirror，可以自动检测在你的网络环境下哪个源是最快的\r\n启动Docker\r\nwindows下启动docker打开桌面的docker图标启动即可。\r\n启动成功后，在Win + R\r\n输入cmd进入windows命令行界面， 输入docker\r\n-v，查看docker版本：\r\n\r\n\r\nimage-20250428164845950\r\n\r\n首先我们输入docker run hello-world是否会出现下图所示的提示,如果出现报错,环境配置可能出现了问题。\r\n我在配置时候出现了Docker无法拉取镜像并提示网络超时的问题，这里以我为例子解决一下\r\n\r\n\r\nimage-20250428165752120\r\n\r\n命令docker images显示说明images镜像中没有helloworld这个文件\r\n\r\n\r\nimage-20250429082113700\r\n\r\n这时我们只需要创建一个daemon.json文件，然后进入这个文件中添加如下内容：\r\n&#123;  &quot;registry-mirrors&quot;: [&quot;https://alzgoonw.mirror.aliyuncs.com&quot;]  &#125;\r\n然后保存退出，并重启docker\r\n另一个错误\r\n\r\n\r\nimage-20250429081800880\r\n\r\n未运行Docker\r\nDesktop，要运行了之后再跑Docker的命令才行！\r\n安装完成Docker后,默认每次开机的时候都会自动启动,但我们也可以手动启动,关闭或者重启Docker\r\n# 启动dockersudo service docker start# 重启dockersudo service docker restart# 停止dockersudo service docker stop\r\n汉化 Docker Desktop\r\n下载对应版本的中文语言包\r\n访问 GitHub，下载适用于 Docker Desktop 的中文语言包，链接地址为：DockerDesktop-CN\r\n选择对应你的版本\r\n\r\n\r\nimage-20250429084714943\r\n\r\n导航至 Docker 的安装目录，路径默认为：\r\nC:\\Program Files\\Docker\\Docker\\frontend\\resources\r\n在该目录下找到 app.asar\r\n文件，建议先备份原文件，然后将复制的中文语言包中的 app.asar\r\n文件粘贴并替换原有文件。\r\n\r\n\r\nimage-20250429084926061\r\n\r\n完成替换后，请关闭 Docker Desktop，然后重新启动该程序。此时，Docker\r\nDesktop 应该以中文界面显示。\r\n\r\n\r\nimage-20250429085059211\r\n\r\nWSL2安装\r\nWSL（Windows Subsystem for\r\nLinux）是微软开发的一项技术，允许用户在Windows系统中直接运行完整的Linux环境，无需虚拟机。通过操作系统级虚拟化，WSL将Linux子系统无缝嵌入Windows，提供原生Linux命令行工具、软件包管理器及应用程序支持。它具有轻量化、文件系统集成、良好的交互性及开发效率提升等优点，消除了Windows与Linux之间的隔阂，尤其适合开发者和需在Windows平台上使用Linux工具的用户。\r\n启用 WSL 功能\r\n\r\n打开开始菜单，在开始菜单中点击应用与程序\r\n在应用与程序选项里面，鼠标滚到最底下，点击程序与功能\r\n点击选项启用或关闭 Windows 功能\r\n在弹出的窗口中勾选 虚拟机平台（Virtual Machine Platform） 和 适用于\r\nLinux 的 Windows 子系统。\r\n\r\n\r\n\r\nimage-20250428171228273\r\n\r\ndos命令自动安装\r\n对于 windows10 版本2004（内部版本19041或更高）及更新版本或者\r\nwindows11，可以直接用 dos命令安装\r\n管理员打开 cmd 或者 powershell，依次\r\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\r\n\r\n\r\nimage-20250428172741625\r\n\r\n启用虚拟机功能\r\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\r\n将 WSL\r\n2 设置为默认版本\r\nwsl --set-default-version 2\r\n更新 wsl 内核\r\nwsl --update\r\n列出发行版本并且选择一个安装\r\nwsl --list --online\r\nwsl --install -d Ubuntu-24.04\r\n\r\n\r\nimage-20250428172805603\r\n\r\n之后使用 wsl.exe -d Ubuntu-24.04 启动\r\n\r\n\r\nimage-20250428173029325\r\n\r\n下次想要使用 wsl 的话，在 cmd 或者 powershell 内输入 wsl\r\n命令即可：\r\n\r\n\r\nimg\r\n\r\nWindows 下的所有文件都被挂载在了 /mnt 下，在Windows\r\n终端中的任意目录下输入 wsl，即可进入 Linux 对应的路径。\r\n错误修复：\r\n无法访问。你可能没有权限使用网络资源。请与这台服务器的管理员联系以查明你是否有访问权限\r\n\r\n\r\nimage-20250429075311855\r\n\r\nWSL报告”请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化”\r\n在 启用或关闭windows\r\n功能中，查看是否勾选虚拟机平台\r\n将注册表HKEY_LOCAL_MACHINE\r\n和HKEY_LOCAL_MACHINE\r\n两个键值中ProviderOrder的值从\r\ncbfs6,P9NP,RDPNP,LanmanWorkstation,webclient改为\r\nP9NP,RDPNP,LanmanWorkstation,webclient \r\n在资源管理器中的\r\n「地址栏」输入：\\\\wsl.localhost 或者\r\n\\\\wsl.localhost\\ 也有概率直接就好了\r\n导出到D盘\r\n注意接下来的操作需要使用 管理员权限的 cmd或pw\r\n首先，查看可用的 WSL 发行版\r\nwsl --list --online\r\n查看你的版本\r\nwsl -l -v \r\n关闭ubuntu\r\nwsl --shutdown Ubuntu-24.04\r\n导出Ubuntu到指定位置\r\nwsl --export Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04\\Ubuntu-24.04.tar\r\n取消注册原有的 Ubuntu,注销\r\nwsl --unregister Ubuntu-24.04\r\n导入虚拟机到指定位置\r\nwsl --import Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04\\Ubuntu-24.04.tar --version 2\r\n现在在目录下，WSL2 发行版的文件存储在一个\r\n虚拟磁盘映像文件（ext4.vhdx） 中，该文件用于存储整个\r\nUbuntu-20.04 文件系统，如下图所示：\r\n\r\n\r\nimage-20250429152524713\r\n\r\n导入完成后，你可以启动 WSL\r\nwsl -d Ubuntu-24.04\r\n添加新用户并设置其管理员权限，需要 root 权限\r\n切换到 root 用户\r\n在 WSL 的 Ubuntu 系统中，使用 su 命令切换到 root\r\n用户：\r\nsu -\r\n执行该命令后，系统会提示你输入 root 用户的密码。如果你之前没有设置过\r\nroot 密码，可以使用以下命令设置：\r\nsudo passwd root\r\n按照提示输入当前用户的密码，然后设置新的 root 密码。\r\n添加新用户\r\nsudo adduser --allow-bad-names yourname\r\n赋予新用户管理员权限\r\n在 Ubuntu 系统中，管理员权限通常通过将用户添加到 sudo\r\n组来实现。使用以下命令将 ErgouTree 用户添加到\r\nsudo 组：\r\nsudo usermod -aG sudo ErgouTree\r\n验证\r\n# 切换到新用户su - ErgouTree# 验证管理员权限sudo ls /root\r\n","categories":["教程","配置教程"],"tags":["配置相关","Docker","Linux","虚拟机技术","容器技术","教程类","实用技术"]},{"title":"markdown中编写数学公式相关语法","url":"/posts/63908.html","content":"使用Markdown语法编写数学公式\r\n在Markdown中使用LaTeX语法编写数学公式起始是一个乍一看很费劲不方便的事情，但是貌似没有别的更好更优秀的通用数学显示了，所以来学习一下这个语法\r\n\r\n插入公式的基本语法\r\n\r\n行内公式\r\n$ 公式内容 $，在这两个美元符号之间输入LaTex语法，即可实现在行内插入公式。\r\n质能公式：E = mc2\r\n二次方程根：$x = \\frac{-b \\pm \\sqrt{b^2 -\r\n4ac}}{2a}$\r\n质能公式：$E = mc^2$  二次方程根：$x = \\frac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125;$\r\n质能公式：$E = mc^2$  二次方程根：$x = \\frac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125;$\r\n公式块：$$ +\r\n回车，会出现一对$$ $$的符号，在这一对符号之间输入LaTex语法，即可实现在行间插入公式。\r\n牛顿第二定律：\r\nF = ma\r\n或\r\n[ F = ma ]\r\n  牛顿第二定律：    $$ F = ma $$    或  \\[ F = ma \\]\r\n\r\n貌似 \\[...\\]\r\n包裹，也可以，但是typora是解析不出来的，就不用了\r\n\r\n\r\n美元符号需在英文输入法下进行输入。中文输入法是\r\n￥\r\n\r\n插入希腊字母\r\n希腊字母的LaTex语法见下图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n希腊字母/希伯来字母\r\n读音（LaTeX 表示）\r\n希腊字母/希伯来字母\r\n读音（LaTeX 表示）\r\n希腊字母/希伯来字母\r\n读音（LaTeX 表示）\r\n\r\n\r\n\r\n\r\nα\r\n\r\nκ\r\n\r\nψ\r\n\r\n\r\n\r\nβ\r\n\r\nλ\r\n\r\nρ\r\n\r\n\r\n\r\nχ\r\n\r\nμ\r\n\r\nσ\r\n\r\n\r\n\r\nδ\r\n\r\nν\r\n\r\nτ\r\n\r\n\r\n\r\nε\r\n\r\nο\r\no\r\nθ\r\n\r\n\r\n\r\nη\r\n\r\nω\r\n\r\nυ\r\n\r\n\r\n\r\nγ\r\n\r\nϕ\r\n\r\nξ\r\n\r\n\r\n\r\nι\r\n\r\nπ\r\n\r\nζ\r\n\r\n\r\n\r\nF\r\n\r\nε\r\n\r\nΔ\r\n\r\n\r\n\r\nϰ\r\n\r\nϖ\r\n\r\nΓ\r\n\r\n\r\n\r\nφ\r\n\r\nϱ\r\n\r\nΛ\r\n\r\n\r\n\r\nΩ\r\n\r\nϕ\r\n\r\nΘ\r\n\r\n\r\n\r\nΥ\r\n\r\nΠ\r\n\r\nΞ\r\n\r\n\r\n\r\nΨ\r\n\r\nΣ\r\n\r\nא\r\n\r\n\r\n\r\nב\r\n\r\nד\r\n\r\nג\r\n\r\n\r\n\r\n\r\nα β γ δ ϵ ζ α\r\n$\\alpha$$\\beta$$\\gamma$$\\delta$$\\epsilon$$\\zeta$  $$ \\alpha $$\r\n唉 4k 吃。。。。\r\n\r\n插入定界符号\r\n总览图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n|\r\n\r\n竖线，可用于表示绝对值、矩阵元素分隔等\r\n\r\n\r\n{\r\n{\r\n左花括号，常用于集合、分段函数定义等\r\n\r\n\r\n⌊\r\n\r\n左向下取整符号，用于表示向下取整函数\r\n\r\n\r\n/\r\n/\r\n除号或表示斜向的分隔\r\n\r\n\r\n⇑\r\n\r\n大向上箭头\r\n\r\n\r\n⌞\r\n\r\n左下直角符号\r\n\r\n\r\n∥\r\n\r\n表示平行，如两直线平行\r\n\r\n\r\n}\r\n}\r\n右花括号\r\n\r\n\r\n⌋\r\n\r\n右向下取整符号\r\n\r\n\r\n∖\r\n\r\n反斜杠，在数学中有时用于集合运算表示差集等\r\n\r\n\r\n↑\r\n\r\n向上箭头\r\n\r\n\r\n⌟\r\n\r\n右下直角符号\r\n\r\n\r\n‖\r\n\r\n双竖线，可用于表示范数等\r\n\r\n\r\n⟨\r\n\r\n左尖括号，常用于表示内积等\r\n\r\n\r\n⌈\r\n\r\n左向上取整符号，用于表示向上取整函数\r\n\r\n\r\n[\r\n[\r\n左方括号，常用于区间表示等\r\n\r\n\r\n⇓\r\n\r\n大向下箭头\r\n\r\n\r\n⌜\r\n\r\n左上直角符号\r\n\r\n\r\n⌝\r\n\r\n右下直角符号\r\n\r\n\r\n]\r\n]\r\n] 右方括号\r\n\r\n\r\n\r\n举例\r\n∖ ∥\r\n$$\\backslash$$$$\\|$$\r\n括号之间可以更改大小以实现嵌套\r\n\r\n\r\nimg\r\n\r\n插入矩阵\r\n矩阵中的各元素通过用$来分隔，\\\\来换行。\r\n$$\r\n\\begin{matrix}\r\n0&amp;1&amp;2\\\\\r\n3&amp;4&amp;5\\\\\r\n6&amp;7&amp;8\\\\\r\n\\end{matrix}\r\n$$\r\n $$ \\begin&#123;matrix&#125; 0&amp;1&amp;2\\\\ 3&amp;4&amp;5\\\\ 6&amp;7&amp;8\\\\ \\end&#123;matrix&#125;$$\r\n$$\r\n\\begin{Vmatrix}\r\n0&amp;1&amp;2\\\\\r\n3&amp;4&amp;5\\\\\r\n6&amp;7&amp;8\\\\\r\n\\end{Vmatrix}\r\n$$\r\n\\begin&#123;Vmatrix&#125;0&amp;1&amp;2\\\\3&amp;4&amp;5\\\\6&amp;7&amp;8\\\\\\end&#123;Vmatrix&#125;\r\n输出分段函数\r\n用\\begin&#123;cases&#125;和\\end&#123;cases&#125;来构造分段函数，中间则用\\\\来分段:\r\n$$\r\nf(x) =\r\n\\begin{cases}\r\n2x,\\,\\,x&gt;0\\\\\r\n3x,\\,\\,x\\le0\\\\\r\n\\end{cases}\r\n$$\r\nf(x) = \\begin&#123;cases&#125;2x,\\,\\,x&gt;0\\\\3x,\\,\\,x\\le0\\\\\\end&#123;cases&#125;\r\n输出方程组\r\n使用\r\n\\begin&#123;cases&#125; ... \\end&#123;cases&#125;，中间则用\\\\来分段:\r\n$$\r\nf(x) = \\begin{cases}\r\n0, &amp; x &lt; 0 \\\\\r\n1, &amp; x \\geq 0\r\n\\end{cases}\r\n$$\r\nf(x) = \\begin&#123;cases&#125;0, &amp; x &lt; 0 \\\\1, &amp; x \\geq 0\\end&#123;cases&#125;\r\n匹配内容\r\n将上述定界符与\\left和right组合使用可以使得定界符匹配其内容的高度。\r\n比如要构建一个如下的矩阵的行列式： $$\r\n\\left|\r\n\\begin{matrix}\r\n    a &amp; b &amp; c &amp; 1 \\\\\r\n    d &amp; e &amp; f &amp; \\epsilon\\\\\r\n    g &amp; h &amp; i &amp; n\r\n   \\end{matrix}\r\n   \\right|\r\n$$\r\n\\left|  \\begin&#123;matrix&#125;   a &amp; b &amp; c &amp; 1 \\\\   d &amp; e &amp; f &amp; \\epsilon\\\\   g &amp; h &amp; i &amp; n  \\end&#123;matrix&#125;  \\right|\r\n\r\n插入运算符号\r\n总览图\r\n\r\n\r\nimg\r\n\r\n×、*、÷、±、∓、≤、≥、≶\r\n$\\times$、$\\ast$、$\\div$、$\\pm$、$\\mp$、$\\leq$、$\\geq$、$\\lessgtr$\r\n这里我挑出一些常用的给大家列出来：\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n+\r\n+\r\n加法运算符号\r\n\r\n\r\n−\r\n-\r\n减法运算符号\r\n\r\n\r\n×\r\n\r\n乘法运算符号\r\n\r\n\r\n÷\r\n\r\n除法运算符号\r\n\r\n\r\n⋅\r\n\r\n点乘符号，用于乘法、函数复合等\r\n\r\n\r\n±\r\n\r\n正负号\r\n\r\n\r\n∓\r\n\r\n与±相反的符号\r\n\r\n\r\n∩\r\n\r\n集合交集运算符号\r\n\r\n\r\n∪\r\n\r\n集合并集运算符号\r\n\r\n\r\n≡\r\n\r\n恒等于、同余（数论）\r\n\r\n\r\n≅\r\n\r\n同构（代数）、全等（几何）\r\n\r\n\r\n≠\r\n\r\n不等于\r\n\r\n\r\n≈\r\n\r\n约等于\r\n\r\n\r\n∼\r\n\r\n相似（几何）、等价（代数）等\r\n\r\n\r\n∈\r\n\r\n属于（集合论）\r\n\r\n\r\n∉\r\n\r\n不属于（集合论）\r\n\r\n\r\n⊆\r\n\r\n子集关系\r\n\r\n\r\n⊇\r\n\r\n超集关系\r\n\r\n\r\n⊊\r\n\r\n真子集关系\r\n\r\n\r\n⊋\r\n\r\n真超集关系\r\n\r\n\r\n≤\r\n\r\n小于等于\r\n\r\n\r\n≥\r\n\r\n大于等于\r\n\r\n\r\n&lt;\r\n\r\n小于\r\n\r\n\r\n&gt;\r\n\r\n大于\r\n\r\n\r\n∥\r\n\r\n平行（几何等）\r\n\r\n\r\n⟂\r\n\r\n垂直、正交（向量等）\r\n\r\n\r\n∨\r\n\r\n逻辑或、格论并运算\r\n\r\n\r\n∧\r\n\r\n逻辑与、格论交运算\r\n\r\n\r\n⊗\r\n\r\n张量积（线性代数等）\r\n\r\n\r\n⊕\r\n\r\n直和（线性代数）、异或（逻辑）\r\n\r\n\r\n∫\r\n\r\n积分符号\r\n\r\n\r\n∑\r\n\r\n求和符号\r\n\r\n\r\n∏\r\n\r\n求积符号\r\n\r\n\r\nlim \r\n\r\n极限符号\r\n\r\n\r\n∞\r\n\r\n无穷大\r\n\r\n\r\n$\\sqrt{}$\r\n\r\n平方根符号\r\n\r\n\r\n$\\sqrt[n]{}$\r\n\r\nn次方根符号\r\n\r\n\r\n≈\r\n\r\n近似等于\r\n\r\n\r\n≐\r\n\r\n近似等于、定义为\r\n\r\n\r\n∝\r\n\r\n成正比\r\n\r\n\r\n|\r\n\r\n竖线，可表示绝对值等\r\n\r\n\r\n⟨\r\n\r\n左尖括号，用于内积等\r\n\r\n\r\n⟩\r\n\r\n右尖括号，用于内积等\r\n\r\n\r\n⌊\r\n\r\n向下取整符号\r\n\r\n\r\n⌋\r\n\r\n向下取整符号\r\n\r\n\r\n⌈\r\n\r\n向上取整符号\r\n\r\n\r\n⌉\r\n\r\n向上取整符号\r\n\r\n\r\n\r\n\r\n插入数学结构\r\n总览图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n$\\frac{abc}{xyz}$\r\n\r\n表示分数，分子为abc，分母为xyz\r\n\r\n\r\n$\\overline{abc}$\r\n\r\n在abc上方加一条横线，常用于表示平均值等\r\n\r\n\r\n$\\overrightarrow{abc}$\r\n\r\n在abc上方加向右箭头，常表示向量\r\n\r\n\r\nf′\r\nf’\r\n表示函数f的一阶导数\r\n\r\n\r\n$\\underline{abc}$\r\n\r\n在abc下方加一条横线\r\n\r\n\r\n$\\overleftarrow{abc}$\r\n\r\n在abc上方加向左箭头\r\n\r\n\r\n$\\sqrt{abc}$\r\n\r\n表示abc的平方根\r\n\r\n\r\n$\\widehat{abc}$\r\n\r\n在abc上方加帽状符号，常用于表示傅里叶变换等中的符号\r\n\r\n\r\n$\\overbrace{abc}$\r\n\r\n在abc上方加花括号\r\n\r\n\r\n$\\sqrt[n]{abc}$\r\n\r\n表示abc的n次方根\r\n\r\n\r\n$\\widetilde{abc}$\r\n\r\n在abc上方加波浪线，常用于表示一些变换后的符号\r\n\r\n\r\n$\\underbrace{abc}$\r\n\r\n在abc下方加花括号\r\n\r\n\r\n\r\n分式结构\r\n\r\n分式：\\frac&#123;分子&#125;&#123;分母&#125;\r\n$\\frac{a}{b}$ → $\\frac{a}{b}$\r\n$\\frac{\\partial f}{\\partial x}$ → $\\frac{\\partial f}{\\partial x}$\r\n\\frac&#123;a&#125;&#123;b&#125; → \\frac&#123;a&#125;&#123;b&#125;  \\frac&#123;\\partial f&#125;&#123;\\partial x&#125; → \\frac&#123;\\partial f&#125;&#123;\\partial x&#125;\r\n\r\n根式结构\r\n\r\n根式：\\sqrt[n]&#123;表达式&#125;\r\n$\\sqrt{2}$ → $\\sqrt{2}$\r\n$\\sqrt[3]{x+y}$ → $\\sqrt[3]{x+y}$\r\n\\sqrt&#123;2&#125; → \\sqrt&#123;2&#125;\\sqrt[3]&#123;x+y&#125; → \\sqrt[3]&#123;x+y&#125;\r\n\r\n上下标结构\r\n\r\n上标：用 ^，如 x^2 →\r\nx2x2\r\n下标：用 _，如 x_1 →\r\nx1x1\r\n复合上下标：用 &#123;&#125;\r\n包裹多字符内容与作用范围，注意其间的连接\r\nxn + 1\r\n→ xn + 1\r\n$\\sum_{i=1}^n i^2$ → $\\sum_{i=1}^n i^2$\r\nϵ&lt;! − −swig￼42 − −&gt;\r\nX23γ(n϶233)\r\n$$\r\n\\lim\\limits_{x\\to\\infty}\\exp(-x) = 0\r\n$$\r\n$x^&#123;n+1&#125;$ → $x^&#123;n+1&#125;$    $\\sum_&#123;i=1&#125;^n i^2$ → $\\sum_&#123;i=1&#125;^n i^2$  $\\epsilon^&#123;&#123;(n+1)&#125;^\\sqrt&#123;2&#125;&#125;$  $X_&#123;23\\gamma&#125;(&#123;n_&#123;\\backepsilon_&#123;233&#125;&#125;&#125;)$  $$  \\lim\\limits_&#123;x\\to\\infty&#125;\\exp(-x) = 0  $$\r\n\r\n其他的也是都一样用，按照图上的查就行了\r\n\r\n插入函数名称\r\n所有符号都可以跟数学结构混合使用，包括数学结构也可以\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n函数名\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\narccos \r\n\r\n反余弦函数，是余弦函数cos 的反函数\r\n\r\n\r\narcsin \r\n\r\n反正弦函数，是正弦函数sin 的反函数\r\n\r\n\r\narctan \r\n\r\n反正切函数，是正切函数tan 的反函数\r\n\r\n\r\narg \r\n\r\n复数的辐角，在复变函数中用于表示复数的角度\r\n\r\n\r\ncos \r\n\r\n余弦函数，三角函数的一种\r\n\r\n\r\ncosh \r\n\r\n双曲余弦函数，双曲函数的一种\r\n\r\n\r\ncot \r\n\r\n余切函数，三角函数中tan 的倒数\r\n\r\n\r\ncoth \r\n\r\n双曲余切函数，双曲函数的一种\r\n\r\n\r\ncsc \r\n\r\n余割函数，是正弦函数sin 的倒数\r\n\r\n\r\ndeg \r\n\r\n表示角度的度数\r\n\r\n\r\ndet \r\n\r\n行列式，用于方阵，是一个数值\r\n\r\n\r\ndim \r\n\r\n维数，用于表示向量空间等的维度\r\n\r\n\r\nexp \r\n\r\n指数函数，通常以e为底，即exp (x) = ex\r\n\r\n\r\ngcd \r\n\r\n最大公约数，用于求两个或多个整数的最大公因数\r\n\r\n\r\nhom \r\n\r\n同态，在抽象代数中用于表示两个代数结构之间的同态映射\r\n\r\n\r\ninf \r\n\r\n下确界，集合的最大下界\r\n\r\n\r\nker \r\n\r\n核，在线性代数中表示线性变换的核空间\r\n\r\n\r\nlg \r\n\r\n常用对数，即以10为底的对数\r\n\r\n\r\nlim \r\n\r\n极限，用于表示函数或数列在某点的极限值\r\n\r\n\r\nliminf \r\n\r\n下极限，是数列极限相关概念\r\n\r\n\r\nlimsup \r\n\r\n上极限，是数列极限相关概念\r\n\r\n\r\nln \r\n\r\n自然对数，即以e为底的对数\r\n\r\n\r\nlog \r\n\r\n对数函数，默认底数不定，可根据上下文确定\r\n\r\n\r\nmax \r\n\r\n最大值，用于求一组数中的最大值\r\n\r\n\r\nmin \r\n\r\n最小值，用于求一组数中的最小值\r\n\r\n\r\nPr \r\n\r\n概率，在概率论中表示事件发生的概率\r\n\r\n\r\nsec \r\n\r\n正割函数，是余弦函数cos 的倒数\r\n\r\n\r\nsin \r\n\r\n正弦函数，三角函数的一种\r\n\r\n\r\nsinh \r\n\r\n双曲正弦函数，双曲函数的一种\r\n\r\n\r\nsup \r\n\r\n上确界，集合的最小上界\r\n\r\n\r\ntan \r\n\r\n正切函数，三角函数的一种\r\n\r\n\r\ntanh \r\n\r\n双曲正切函数，双曲函数的一种\r\n\r\n\r\n\r\n$$\r\n\\tan(at-n\\pi)\\\\\r\n\\sin\\\\\r\n\\cos\\\\\r\n\\log\\\\\r\n$$\r\n\\tan(at-n\\pi)\\\\\\sin\\\\\\cos\\\\\\log\\\\\r\n\r\n插入可变符号\r\n总览图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n∑\r\n\r\n求和符号，用于表示对一系列数求和\r\n\r\n\r\n∫\r\n\r\n积分符号，用于表示积分运算\r\n\r\n\r\n⨄\r\n\r\n不相交并集符号，用于表示集合的不相交并运算\r\n\r\n\r\n⨁\r\n\r\n直和符号，常用于线性代数等领域表示向量空间的直和\r\n\r\n\r\n⋁\r\n\r\n逻辑或（在格论等中表示并运算）符号\r\n\r\n\r\n∏\r\n\r\n求积符号，用于表示对一系列数求乘积\r\n\r\n\r\n∮\r\n\r\n闭合曲线积分符号，用于表示在闭合曲线上的积分\r\n\r\n\r\n⋂\r\n\r\n交集符号，用于表示集合的交集运算\r\n\r\n\r\n⨂\r\n\r\n张量积符号，用于表示张量之间的乘积运算\r\n\r\n\r\n⋀\r\n\r\n逻辑与（在格论等中表示交运算）符号\r\n\r\n\r\n∐\r\n\r\n余积符号，在范畴论等中有应用\r\n\r\n\r\n∬\r\n\r\n二重积分符号，用于表示对二元函数的积分\r\n\r\n\r\n⋃\r\n\r\n并集符号，用于表示集合的并集运算\r\n\r\n\r\n⨀\r\n\r\n一种广义的乘法运算符号\r\n\r\n\r\n⨆\r\n\r\n无交并集符号，强调集合元素不相交的并集\r\n\r\n\r\n\r\n补充说明：\r\n\r\n第一列为原图左侧符号，第三列为原图右侧符号\r\n\\text&#123;&#125;包裹的内容为原图自定义标签，非标准LaTeX符号\r\n标准符号已用$$...$$标记确保在Markdown中正确显示大小\r\n原图第三行存在排版混乱，已按原始内容保留\r\n\r\n⋂⋃⨁⨂∑∫∮∬\r\n$$\\bigcap\\bigcup\\bigoplus\\bigotimes\\sum\\int\\oint\\iint$$\r\n积分\r\n积分：\\int_&#123;下限&#125;^&#123;上限&#125; $$\r\n\\int_{0}^{\\infty} e^{-x} dx = 1$ → $\\int_{0}^{\\infty} e^{-x} dx = 1\r\n$$\r\n$\\int_&#123;0&#125;^&#123;\\infty&#125; e^&#123;-x&#125; dx = 1$ → $\\int_&#123;0&#125;^&#123;\\infty&#125; e^&#123;-x&#125; dx = 1$\r\n求和，连乘积\r\n求和/连乘积：\\sum 和 \\prod\r\n$$\r\n\\sum_{i=1}^n i = \\frac{n(n+1)}{2} → \\sum_{i=1}^n i = \\frac{n(n+1)}{2}\r\n$$\r\n$\\sum_&#123;i=1&#125;^n i = \\frac&#123;n(n+1)&#125;&#123;2&#125;$ → $\\sum_&#123;i=1&#125;^n i = \\frac&#123;n(n+1)&#125;&#123;2&#125;$\r\n$$\r\n\\prod_{\\alpha = 2}^n \\alpha\r\n$$\r\n\\prod_&#123;\\alpha = 2&#125;^n \\alpha\r\n\r\n插入箭头符号\r\n总表\r\n\r\n\r\nimg\r\n\r\n这里我挑出一些常用的给大家，方便查找：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n←\r\n\r\n向左箭头，常用于表示映射方向、数列极限趋近方向等\r\n\r\n\r\n⇐\r\n\r\n向左双箭头，在逻辑中可表示逻辑蕴含的反向\r\n\r\n\r\n→\r\n\r\n向右箭头，用于表示函数映射方向、趋向等\r\n\r\n\r\n⇒\r\n\r\n向右双箭头，在逻辑中表示逻辑蕴含\r\n\r\n\r\n↔︎\r\n\r\n双向箭头，可表示双向映射、等价关系等\r\n\r\n\r\n⇔\r\n\r\n双向双箭头，在逻辑中表示等价关系\r\n\r\n\r\n↑\r\n\r\n向上箭头，可用于表示递增、上极限方向等\r\n\r\n\r\n↓\r\n\r\n向下箭头，可用于表示递减、下极限方向等\r\n\r\n\r\n↕\r\n\r\n上下双向箭头，可表示某种上下变化或可逆的过程\r\n\r\n\r\n↦\r\n\r\n映射符号，用于表示函数中元素的对应关系\r\n\r\n\r\n↦\r\n\r\n长映射符号，强调映射关系，常用于更正式的数学定义中\r\n\r\n\r\n↗\r\n\r\n向右上箭头，可表示方向、趋势等\r\n\r\n\r\n↘\r\n\r\n向右下箭头，可表示方向、趋势等\r\n\r\n\r\n↙\r\n\r\n向左下箭头，可表示方向、趋势等\r\n\r\n\r\n↖\r\n\r\n向左上箭头，可表示方向、趋势等\r\n\r\n\r\n\r\n\r\n插入其他符号\r\n\r\n\r\nimg\r\n\r\n♡、∞、∭、∂\r\n$\\heartsuit$、$\\infty$、$\\iiint$、$\\partial$\r\n这个我也挑出一些常用的给大家，方便查找：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n∞\r\n\r\n无穷大，在极限、集合基数等概念中常用\r\n\r\n\r\n∇\r\n\r\nnabla算子，在向量分析中表示梯度、散度、旋度等\r\n\r\n\r\n∂\r\n\r\n偏导数符号，用于多元函数求偏导\r\n\r\n\r\n∀\r\n\r\n全称量词，表示“对于所有的”\r\n\r\n\r\n∃\r\n\r\n存在量词，表示“存在”\r\n\r\n\r\n∅\r\n\r\n空集符号，表示不含任何元素的集合\r\n\r\n\r\n∠\r\n\r\n角的符号，用于表示角度\r\n\r\n\r\n∡\r\n\r\n用于强调角度测量的符号\r\n\r\n\r\n⋯\r\n\r\n省略号，用于表示序列等的延续\r\n\r\n\r\n⋮\r\n\r\n垂直省略号，常用于矩阵、数列等表示\r\n\r\n\r\n⋱\r\n\r\n斜向省略号，常见于矩阵表示中\r\n\r\n\r\nℑ\r\n\r\n表示复数的虚部\r\n\r\n\r\nℜ\r\n\r\n表示复数的实部\r\n\r\n\r\n△\r\n\r\n三角形符号，可用于表示三角形相关概念\r\n\r\n\r\n′\r\n\r\n撇号，常用于表示导数、转置等\r\n\r\n\r\n♮\r\n\r\n自然符号，在音乐理论等领域有应用，在数学中有时用于特定结构\r\n\r\n\r\n\r\n\r\n字体\r\n字体风格\r\n更多详见：Font\r\nsizes, families, and styles\r\n\r\n\r\nimg\r\n\r\n数学字体\r\n\r\n罗马字体（Roman） \\mathrm\r\nsin(x) + cos(x)\r\n\r\n$\\mathrm&#123;sin&#125;(x) + \\mathrm&#123;cos&#125;(x)$\r\n\r\n粗体（Bold） \\mathbf\r\nA ⋅ x = b\r\n$\\mathbf&#123;A&#125; \\cdot \\mathbf&#123;x&#125; = \\mathbf&#123;b&#125;$\r\n斜体 \\mathit\r\n在 LaTeX\r\n中，数学公式默认使用斜体字体。但如果你想明确指定为斜体，可以使用\r\n\\mathit 命令。\r\nabc\r\n$\\mathit&#123;abc&#125;$\r\n花体\r\n使用 \\mathcal\r\n命令可以将公式中的部分内容设置为花体字体，常用于表示集合、范畴等。\r\nℱ\r\n$\\mathcal&#123;F&#125;$\r\n黑板粗体（Blackboard bold）\r\n使用 \\mathbb\r\n命令可以将公式中的部分内容设置为黑板粗体，常用于表示数集\r\nℝ, ℕ, ℤ\r\n$\\mathbb&#123;R&#125;, \\mathbb&#123;N&#125;, \\mathbb&#123;Z&#125;$\r\n哥特体\r\n使用 \\mathfrak\r\n命令可以将公式中的部分内容设置为哥特体字体，常用于表示李代数、理想等。\r\n𝔤, 𝔥\r\n$\\mathfrak&#123;g&#125;, \\mathfrak&#123;h&#125;$\r\n\r\n更多详见：Mathematical\r\nfonts\r\n字体大小\r\n在 LaTeX\r\n中，可以使用不同的命令来调整字体的大小，以下是一些常用的字体大小调整命令\r\n\r\n\r\n\r\n命令\r\n字体大小\r\n\r\n\r\n\r\n\r\n\\tiny\r\n极小号字体\r\n\r\n\r\n\\scriptsize\r\nscriptsize 号字体\r\n\r\n\r\n\\footnotesize\r\nfootnotesize 号字体\r\n\r\n\r\n\\small\r\n小号字体\r\n\r\n\r\n\\normalsize\r\n正常大小字体\r\n\r\n\r\n\\large\r\n大号字体\r\n\r\n\r\n\\Large\r\n更大号字体\r\n\r\n\r\n\\LARGE\r\n非常大号字体\r\n\r\n\r\n\\huge\r\n巨大号字体\r\n\r\n\r\n\\Huge\r\n超级巨大号字体\r\n\r\n\r\n\r\n$\\tiny x + y$$\\scriptsize x + y$$\\footnotesize x + y$$\\small x + y$$\\normalsize x + y$$\\large x + y$$\\Large x + y$$\\LARGE x + y$$\\huge x + y$$\\Huge x + y$\r\n$\\tiny x + y$ $\\scriptsize x + y$ $\\small x + y$ $\\normalsize x + y$ $\\large x + y$ $\\Large x + y$ $\\LARGE x + y$ $\\huge x + y$ $\\Huge x + y$\r\n\r\n对齐\r\n多行公式对齐（align环境）\r\n使用\\begin&#123;align&#125;和\\end&#123;align&#125;，&amp;指定对齐位置：\r\n$$\r\n\\begin{align}\r\nf(x) &amp;= (x+1)^2 \\\\\r\n     &amp;= x^2 + 2x + 1 \\\\\r\n\\int f(x)dx &amp;= \\frac{1}{3}x^3 + x^2 + x + C\r\n\\end{align}\r\n$$\r\n\\begin&#123;align&#125;f(x) &amp;= (x+1)^2 \\\\     &amp;= x^2 + 2x + 1 \\\\\\int f(x)dx &amp;= \\frac&#123;1&#125;&#123;3&#125;x^3 + x^2 + x + C\\end&#123;align&#125;\r\n多公式居中（gather环境）\r\n$$\r\n\\begin{gather}\r\na = b + c \\\\\r\nd = e^f + g \\\\\r\n\\lim_{x\\to0}\\frac{\\sin x}{x} = 1\r\n\\end{gather}\r\n$$\r\n\\begin&#123;gather&#125;a = b + c \\\\d = e^f + g \\\\\\lim_&#123;x\\to0&#125;\\frac&#123;\\sin x&#125;&#123;x&#125; = 1\\end&#123;gather&#125;\r\n分段函数对齐（cases环境）\r\n$$\r\nf(x) = \\begin{cases}\r\nx^2 &amp; \\text{if } x \\geq 0 \\\\\r\n-{\\color{red}x^3} &amp; \\text{if } x &lt; 0\r\n\\end{cases}\r\n$$\r\nf(x) = \\begin&#123;cases&#125;x^2 &amp; \\text&#123;if &#125; x \\geq 0 \\\\-&#123;\\color&#123;red&#125;x^3&#125; &amp; \\text&#123;if &#125; x &lt; 0\\end&#123;cases&#125;\r\n矩阵对齐（array环境）\r\n$$\r\n\\left[\r\n\\begin{array}{cc|c}\r\n1 &amp; 2 &amp; 3 \\\\\r\n\\hline\r\n4 &amp; \\color{blue}5 &amp; 6 \\\\\r\n7 &amp; 8 &amp; 9\r\n\\end{array}\r\n\\right]\r\n$$\r\n$$\\left[\\begin&#123;array&#125;&#123;cc|c&#125; 1 &amp; 2 &amp; 3 \\\\ \\hline4 &amp; \\color&#123;blue&#125;5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;array&#125;\\right]$$\r\n拆分、对齐方程\r\n用 &amp; 指定对齐位置，\\\\ 换行： $$\r\n\\begin{align}\r\nf(x) &amp;= (x+1)^2 + 3 \\label{eq1} \\\\\r\n     &amp;= x^2 + 2x + 4 \\label{eq2} \\\\\r\n\\int f(x)dx &amp;= \\frac{1}{3}x^3 + x^2 + 4x + C \\label{eq3}\r\n\\end{align}\r\n$$\r\n$$\\begin&#123;align&#125;f(x) &amp;= (x+1)^2 + 3 \\label&#123;eq1&#125; \\\\     &amp;= x^2 + 2x + 4 \\label&#123;eq2&#125; \\\\\\int f(x)dx &amp;= \\frac&#123;1&#125;&#123;3&#125;x^3 + x^2 + 4x + C \\label&#123;eq3&#125;\\end&#123;align&#125;$$\r\n多列对齐 $$\r\n\\begin{align}\r\na &amp;= b &amp; x &amp;= y \\\\\r\nc &amp;= d &amp; z &amp;= w\r\n\\end{align}\r\n$$\r\n$$\\begin&#123;align&#125;a &amp;= b &amp; x &amp;= y \\\\c &amp;= d &amp; z &amp;= w\\end&#123;align&#125;$$\r\n居中显示方程（不以等号对齐）\r\ngather 环境 $$\r\n\\begin{gather}\r\na = b + c \\\\\r\nd = e^f + g \\notag \\\\  \r\n\\lim_{x\\to0}\\frac{\\sin x}{x} = 1\r\n\\end{gather}\r\n$$\r\n\\begin&#123;gather&#125;a = b + c \\\\d = e^f + g \\notag \\\\  % 取消单行编号\\lim_&#123;x\\to0&#125;\\frac&#123;\\sin x&#125;&#123;x&#125; = 1\\end&#123;gather&#125;\r\n单行居中\r\n$$ \\boxed{E = mc^2} $$\r\n$$ \\boxed&#123;E = mc^2&#125; $$\r\n综合对齐\r\n$$\r\n\\begin{align}\r\n\\color{red}\\nabla \\cdot \\mathbf{E} &amp;= \\frac{\\rho}{\\epsilon_0} \\\\\r\n\\color{blue}\\nabla \\times \\mathbf{E} &amp;= -\\frac{\\partial\r\n\\mathbf{B}}{\\partial t} \\\\\r\n\\color{green}\\int_{\\partial \\Omega} \\omega &amp;= \\int_\\Omega d\\omega\r\n\\quad \\text{(Stokes定理)}\r\n\\end{align}\r\n$$\r\n$$\\begin&#123;align&#125;\\color&#123;red&#125;\\nabla \\cdot \\mathbf&#123;E&#125; &amp;= \\frac&#123;\\rho&#125;&#123;\\epsilon_0&#125; \\\\\\color&#123;blue&#125;\\nabla \\times \\mathbf&#123;E&#125; &amp;= -\\frac&#123;\\partial \\mathbf&#123;B&#125;&#125;&#123;\\partial t&#125; \\\\\\color&#123;green&#125;\\int_&#123;\\partial \\Omega&#125; \\omega &amp;= \\int_\\Omega d\\omega \\quad \\text&#123;(Stokes定理)&#125;\\end&#123;align&#125;$$\r\n\r\n间距控制\r\n\r\n\r\nimg\r\n\r\n1. 水平间距\r\n\r\n\r\n\r\n命令\r\n间距大小\r\n示例\r\n\r\n\r\n\r\n\r\n\\,\r\n小空格 (3/18em)\r\n$x\\,y$ → x yxy\r\n\r\n\r\n\\:\r\n中空格 (4/18em)\r\n$x\\:y$ → x yxy\r\n\r\n\r\n\\;\r\n大空格 (5/18em)\r\n$x\\;y$ → x  yxy\r\n\r\n\r\n\\quad\r\n1em\r\n$x\\quad y$ → xyxy\r\n\r\n\r\n\\qquad\r\n2em\r\n$x\\qquad y$ → xyxy\r\n\r\n\r\n\\!\r\n负间距 (-3/18em)\r\n$x\\!y$ → x ⁣yxy\r\n\r\n\r\n\r\n2. 垂直间距\r\n在换行时添加间距（仅在某些环境中有效）： $$\r\n\\begin{align}\r\nf(x) &amp;= x^2 \\\\[5pt]     \r\nf'(x) &amp;= 2x \\\\[10pt]     \r\nf''(x) &amp;= 2\r\n\\end{align}\r\n$$\r\n\\begin&#123;align&#125;f(x) &amp;= x^2 \\\\[5pt]      % 增加5pt间距f&#x27;(x) &amp;= 2x \\\\[10pt]     % 增加10pt间距f&#x27;&#x27;(x) &amp;= 2\\end&#123;align&#125;\r\n3. 矩阵间距调整\r\n$$\r\n\\begin{pmatrix}\r\n1 &amp; \\frac{1}{2} \\\\[6pt]  \r\n3 &amp; \\frac{1}{4}\r\n\\end{pmatrix}\r\n$$\r\n\\begin&#123;pmatrix&#125;1 &amp; \\frac&#123;1&#125;&#123;2&#125; \\\\[6pt]  3 &amp; \\frac&#123;1&#125;&#123;4&#125;\\end&#123;pmatrix&#125;\r\n\r\n颜色\r\n基础颜色语法\r\n在LaTeX数学公式中使用\\color&#123;颜色名&#125;命令设置颜色： x + y = z\r\n$$ \\color&#123;red&#125; x + \\color&#123;blue&#125; y = \\color&#123;green&#125; z $$\r\n常用颜色名称\r\n\r\n\r\n\r\n颜色名\r\n示例\r\n\r\n\r\n\r\n\r\nred\r\n\\color&#123;red&#125; text\r\n\r\n\r\nblue\r\n\\color&#123;blue&#125; text\r\n\r\n\r\ngreen\r\n\\color&#123;green&#125; text\r\n\r\n\r\nyellow\r\n\\color&#123;yellow&#125; text\r\n\r\n\r\ncyan\r\n\\color&#123;cyan&#125; text\r\n\r\n\r\nmagenta\r\n\\color&#123;magenta&#125; text\r\n\r\n\r\nblack\r\n\\color&#123;black&#125; text\r\n\r\n\r\nwhite\r\n\\color&#123;white&#125; text\r\n\r\n\r\ngray\r\n\\color&#123;gray&#125; text\r\n\r\n\r\ndarkred\r\n\\color&#123;darkred&#125; text\r\n\r\n\r\n\r\nRGB自定义颜色\r\n使用\\color[rgb]&#123;R,G,B&#125;格式（值范围0-1）： $$\r\n\\color[rgb]{0.5,0.2,0.8} f(x) = \\sqrt{x}\r\n$$\r\n$$\\color[rgb]&#123;0.5,0.2,0.8&#125; f(x) = \\sqrt&#123;x&#125;$$\r\n局部着色\r\n用花括号限定作用范围： x + y&lt;! − −swig￼43 − −&gt;\r\n$$&#123;\\color&#123;red&#125;x&#125; + &#123;\\color&#123;blue&#125;y&#125;^&#123;&#123;\\color&#123;green&#125;2&#125;&#125;$$\r\n\r\n注意事项\r\n\r\n空格处理：LaTeX 默认忽略空格，需用\r\n\\, 或 \\quad 添加空格，如 x\\,y →\r\nx yxy。\r\n转义字符：在公式中直接书写 #,\r\n%, _ 等符号需用 \\ 转义，如\r\n\\# → ##, \\% → %%。\r\n多行对齐：使用 aligned\r\n环境实现公式对齐：\r\n$$\r\n\\begin{aligned}\r\nf(x) &amp;= (x + 1)^2 \\\\\r\n     &amp;= x^2 + 2x + 1\r\n\\end{aligned}\r\n$$\r\n\\begin&#123;aligned&#125;f(x) &amp;= (x + 1)^2 \\\\     &amp;= x^2 + 2x + 1\\end&#123;aligned&#125;\r\n\r\n\r\n之后再有用到的再补充，感觉够多了\r\n","categories":["实用","语言方面"],"tags":["markdown","实用知识","常用知识","语法知识","语言方面","数学","LateX"]},{"title":"markdown常用语法","url":"/posts/43275.html","content":"markdown常用语法\r\n标题\r\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\r\n#后必须要有空格 还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。Heading level 1===============Heading level 2--------------- 在实际渲染中，‘#’\r\n号数量对应标题级别，一个 ‘#’ 是一级标题，两个 ‘#’\r\n是二级标题，以此类推。\r\n#的叠加可以很多，但是当过多之后，会变的比正常字体还要小，可以利用这个特性\r\n ## 段落和换行 #### 换行\r\n句子末尾双空格代表换行。或者多个空格进行换行\r\n 貌似也可以\r\n#### 段落 处理段落就是用空白行将一行或多行文本进行分割\r\n注意：不要用空格（spaces）或制表符（ tabs）缩进段落。\r\n ## 强调 *斜体文本*   前后各添加一个星号或下划线  _斜体文本_**粗体文本**   前后各添加两个星号或下划线  __粗体文本__***加粗斜体文本***~~删除线文本~~ 粗体和斜体可以混合用\r\n ## 代码块 行内代码：用反引号\r\n包裹代码片段，如System.out.println(“Hello World”);\r\n代码块：使用三个反引号\r\n包裹代码块，并可在其后指定语言（可选，用于语法高亮）\r\n​```代码语言内部代码注意```需要闭合   貌似三个波浪号也可以~~~ ~~~\r\n### 链接- **行内式链接**：`[链接文本](链接地址 &quot;可选标题&quot;)`，例如：[百度](https://www.baidu.com &quot;百度首页&quot;)- **参考式链接**： [链接文本][链接标识][链接标识]: 链接地址 &quot;可选标题&quot;  ## 引用 &gt; 这是一段引用文本&gt; 引用可以有多行&gt; 若有多段引用，可在每段前加 &gt; 符号。&gt; 嵌套块引用\r\n块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。\r\n块引用可以包含其他 Markdown 格式的元素。但并非所有元素都可以使用\r\n我已经验证了强调和段落换行表格可以用\r\n​```markdown &gt; 这是一段引用文本 &gt; 引用可以嵌套 &gt; &gt; 我继续引用\r\n&gt; &gt; &gt; &gt; &gt; 我还引用 &gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用  &gt; &gt; &gt;&gt; &gt; &gt; ***## 分割 — *** ___ 以上三种写法都可生成一条分隔线。  ***## 列表### 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。  数字不必按数学顺序排列，但是列表应当以数字 1 起始。  ​```markdown1. 列表项12. 列表项2   1. 子列表项1   2. 子列表项23. 列表项3\r\n### 无序列表 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*)\r\n或加号 (+) 。 缩进一个或多个列表项可创建嵌套列表。 - 列表项1  - 子列表项1  - 子列表项2+ 列表项2* 列表项3 ###\r\n列表中来回嵌套的问题\r\n在如果需要列表中嵌套其他元素，基本所有都可以，甚至图片，拿代码块举例子\r\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符\r\n1.  列表行12.  下面是代码        &amp;&lt;html&gt;          &amp;lt;head&gt;            &amp;lt;title&gt;Test&amp;lt;/title&gt;          &amp;lt;/head&gt;3.  同样的，列表也可以嵌套列表 1. 列表行1 2. 下面是代码\r\n    &lt;html&gt;\r\n      &lt;head&gt;\r\n        &lt;title&gt;Test&amp;lt;/title&gt;\r\n      &lt;/head&gt;\r\n\r\n同样的，列表也可以嵌套列表 *** ## 表格 ### 基本表格语法\r\n表头与内容分隔：使用 | 来分隔表格的列，表头与表格内容之间通过 — 分隔，—\r\n还可用于指定列的对齐方式。\r\n| 表头1 | 表头2 | 表头3 || :---: | :-- | --: || 居中内容 | 左对齐内容 | 右对齐内容 || 第二行数据1 | 第二行数据2 | 第二行数据3 | | 表头1 | 表头2 | 表头3 | | :—: | :– | –: | | 居中内容 |\r\n左对齐内容 | 右对齐内容 | | 第二行数据1 | 第二行数据2 | 第二行数据3 |\r\n### 表格内容换行 如果表格内容需要换行，可以直接在 Markdown 源文件中使用\r\nHTML 的  标签。\r\n支持扩展语法的编辑器中，也可以通过在单元格内容中按回车键进行换行，然后适当缩进以保持格式。\r\n| 列1 | 列2 || ---- | ---- || 长内容 &lt;br&gt; 换行显示 | 其他内容 | | 列1 | 列2 | | —- | —- | | 长内容  换行显示 |\r\n其他内容 | ### 合并单元格 标准 Markdown\r\n语法本身不支持直接合并单元格。\r\n不过，在一些特定的 Markdown 渲染器（如在 Markdown 中嵌入 HTML\r\n时），可以使用 HTML 的\r\n\r\n标签来实现。\r\n ## 图片 行内式图片：\r\n例如：，换成你自己的图片链接\r\n参考式图片： ![替代文本][图片标识][图片标识]: 图片地址 &quot;可选标题&quot;  ## 任务列表\r\n任务列表可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。\r\n在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。\r\n要选择一个复选框，请在方括号[x]之间添加 x 。\r\n\r\n- [x] Write the press release- [ ] Update the website- [ ] Contact the media\r\n\r\nWrite the press\r\nrelease\r\nUpdate the website\r\nContact the media *** ## 转义字符\r\n在字符前面添加反斜杠字符  ，这样markdown会识别不去执行该符号\r\n例如\r\n* Without the backslash, this would be a bullet in an unordered\r\nlist.\r\n\r\nWithout the backslash, this would be a bullet in an unordered list.\r\n不加就会被识别成列表\r\n ## 内嵌html代码 对于 Markdown\r\n涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。\r\n如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML\r\n标签添加到Markdown 文本中即可\r\nhtml里面咋用，在这里就可以咋用\r\n ## 插入表情符号 可以简单地从Emojipedia\r\n等来源复制表情符号并将其粘贴到文档中。\r\n许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。\r\n\r\n目录导航\r\n[[TOC]] \r\n隐藏注释\r\n\r\n数学公式\r\n本质上就是插入latex代码，但是在markdown中插入latex代码需要用两个$符号\r\n行内公式：$E=mc^2$块级公式：$$\\begin&#123;bmatrix&#125;1 &amp; 0 \\\\0 &amp; 1\\end&#123;bmatrix&#125;$$\r\n流程图（需渲染器支持）\r\n```mermaid\r\ngraph TD\r\nA[开始] –&gt; B(处理逻辑)\r\nB –&gt; C{判断}\r\nC –&gt;|是| D[结果1]\r\nC –&gt;|否| E[结果2]\r\n```\r\ngraph TD\n    A[开始] --&gt; B(处理逻辑)\n    B --&gt; C&#123;判断&#125;\n    C --&gt;|是| D[结果1]\n    C --&gt;|否| E[结果2]\r\n","categories":["实用","语言方面"],"tags":["常用知识","语言方面","实用工具"]},{"title":"mapStruct对象转换相关注解的使用","url":"/posts/13973.html","content":"理解 @Mapper 注解的核心功能\r\n@Mapper 注解是现代 Java\r\n开发中用于简化对象转换的重要工具，最著名的实现是 MapStruct 框架，它是\r\nJava\r\n中最流行的对象映射框架。它的设计理念是通过编译时代码生成来替代传统的反射机制，从而实现高性能的对象映射转换。\r\n所以，我们从 MapStruct 使用来讲 @Mapper\r\n注解的使用及其对象转换方案。\r\nMapStruct\r\n是一个代码生成器，它的主要功能是在编译时根据注解配置自动生成高性能的映射实现代码，避免了手写转换代码的繁琐和运行时反射的性能损耗。这个工具基于“约定优于配置”的原则，极大地简化了\r\nJava Bean 类型之间的映射实现过程。\r\n在多层架构的应用中，经常需要在不同的对象模型之间进行转换，例如在持久层的实体和传输层的\r\nDTO（Data Transfer\r\nObject，数据传输对象）之间。手动编写这种映射代码是一项繁琐且容易出错的任务。MapStruct通过自动化的方式解决了这个问题，它可以在编译时生成映射代码，从而保证了高性能、快速的开发反馈以及严格的错误检查。\r\n@Mapper 注解用于标记一个\r\n接口或抽象类，声明它是一个对象转换器（Mapper），其核心功能是：自动生成代码，将一种对象（如\r\nDTO、VO、Entity）的字段值映射到另一种对象，避免手动编写重复的\r\nsetter/getter 逻辑。\r\n// 1. 定义Mapper接口@Mapperpublic interface UserMapper &#123;    UserDTO toDto(UserEntity entity);  // Entity → DTO    UserEntity toEntity(UserDTO dto);  // DTO → Entity&#125;// 2. 编译后，MapStruct自动生成实现类（如UserMapperImpl）UserDTO userDTO = userMapper.toDto(userEntity); // 自动映射同名字段\r\n具体来说，使用MapStruct时，开发者只需要定义一个接口，并在接口中定义转换方法。然后，MapStruct会自动生成实现这些方法的代码。这些生成的代码使用纯方法调用，因此速度快、类型安全且易于理解。\r\n不同对象之间都是什么意思\r\n相信看到这个文章的应该都知道，但是我还是说一下，我记得我写过全面的文章\r\n\r\nPOJO（Plian Ordinary Java\r\nObject）：简单普通的Java对象，就是最简单的Java对象，最基本的Java\r\nBean只是在属性上加上 get 和 set\r\n方法，POJO可转化为以下的PO、DTO、VO等，比如说：在service中传递的Java\r\nBean就叫DTO。\r\nEntity：Entity就是模型类，通常定义在 model\r\n层里面，相当于MVC的M层，属于数据模型层，一个 Entity\r\n实体类代表一个数据库的一张表。其中的属性定义数据表中的字段，实体类的字段数量\r\n&gt;= 数据库表中需要操作的字段数量，其中，也有另一种叫法PO(Persistent\r\nObject) 持久对象，本质上并无差别\r\nDTO（Data Transfer\r\nObject）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。属于一种比较底层基础得操作，具体到对某个表得增删改查，换句话说，某个dao一定是和数据库中的某一张表一一对应的，而且其中也只是封装了增删改查得方法。\r\nVO(View Object)：VO有人理解为Value Object，也有人理解为View\r\nObject，我是理解为后者，因为更偏向与表达的意思是表现层对象，用于业务层之间的数据传递，但是是在前端页面层展示被封装的VO数据。\r\nDO（Domain\r\nObject）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\r\nDAO（Data Assess Object）：数据访问对象，相当于DAO层，mapper\r\n层直接与数据库打交道(执行SQL语句)，接口提供给 service\r\n层。一般写在业务层，当业务逻辑比较复杂时，可能会用到比较多的业务对象，这样就可以将多个PO、VO封装成一个BO对象用于数据传递。\r\n\r\n核心特性与原理\r\n自动字段映射\r\n\r\n同名匹配：默认按字段名自动映射（如\r\nentity.name → dto.name）。\r\n类型兼容：支持基本类型、包装类、String、集合等常见类型的转换。\r\n嵌套对象：可递归映射嵌套对象（如\r\nUserDTO.department ←→\r\nUserEntity.department）。\r\n\r\n编译时生成代码\r\n\r\n原理：MapStruct 在编译期（非运行时反射）生成高效的\r\nJava 映射代码，运行时无需通过反射进行属性拷贝，性能接近手写\r\nsetter/getter。\r\n优势：\r\n\r\n零运行时开销：生成的代码直接调用字段赋值，无反射或代理。\r\n易调试：生成的代码可见，便于排查问题。\r\n\r\n\r\n类型安全\r\n\r\nMapStruct\r\n在编译时生成映射代码并进行类型检查，如果源对象和目标对象的属性不匹配，会在编译阶段就报错。\r\n而且MapStruct不依赖于任何第三方库，可以很容易地集成到任何项目中。\r\n支持 Spring：通过\r\n@Mapper(componentModel = \"spring\") 生成 Spring\r\nBean。\r\n组合其他工具：可结合 Lombok、JPA\r\n等使用。\r\n\r\n基本工作原理\r\nMapStruct 的核心工作流程是：\r\n\r\n定义接口并使用 @Mapper 注解标记\r\n在接口中声明映射方法\r\n在编译时，MapStruct 处理器会生成实现这些方法的具体类\r\n这些生成的类执行实际的对象转换操作\r\n\r\nMapStruct 生成的代码高效且类型安全，通常比手动编写的代码更高效。\r\nMapStruct 的类型转换\r\nMapStruct 支持多种类型转换方式：\r\n\r\n内置转换：自动处理基本类型及其包装类之间的转换\r\n字符串转换：自动处理字符串与基本类型之间的转换\r\n枚举转换：自动处理名称相同的枚举值转换\r\n日期转换：通过 @Mapping 的\r\ndateFormat 属性指定格式\r\n自定义转换：通过 @Named\r\n注解定义自定义转换方法\r\n使用其他映射器：通过 uses\r\n属性引入其他映射器\r\n\r\n使用\r\n导入依赖\r\n在你的pom.xml文件中添加MapStruct的依赖：\r\n\r\norg.mapstruct:mapstruct：包含了一些必要的注解，例如@Mapping。若我们使用的JDK版本高于1.8，当我们在pom里面导入依赖时候，建议使用坐标是：org.mapstruct:mapstruct-jdk8，这可以帮助我们利用一些Java8的新特性。\r\norg.mapstruct:mapstruct-processor：注解处理器，根据注解自动生成mapper的实现。\r\n\r\n&lt;!--mapstruct核心--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;  \t&lt;!-- jdk8以下就使用mapstruct --&gt;    &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt;    &lt;version&gt;1.5.5.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!--mapstruct编译--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;    &lt;version&gt;1.5.5.Final&lt;/version&gt;&lt;/dependency&gt;\r\n一些配置\r\n其中注解的基本使用\r\n@Mapper 基础接口的定义\r\n@Mapper 是 MapStruct\r\n的核心注解，用于标记接口或抽象类作为映射器。MapStruct\r\n会在编译时为这些接口生成实现类，自动生成实现类代码，支持配置全局映射策略。它会定义所有映射方法的入口，适用于任何需要对象转换的场景。\r\n关键属性：\r\n\r\ncomponentModel：指定组件模型（如\r\nspring、cdi），用于依赖注入。\r\nuses：引入其他映射器或工具类。\r\nunmappedTargetPolicy：未映射字段的处理策略（如\r\nIGNORE 或 ERROR）。\r\n\r\n// 用户实体类 - 通常对应数据库表结构public class User &#123;    private Long id;    private String username;    private String email;    private String phone;    private Date createTime;    private Boolean isActive;        // 构造方法、getter、setter 省略...&#125;// 用户DTO类 - 用于数据传输，通常会隐藏一些敏感字段public class UserDto &#123;    private Long id;    private String username;    private String email;    private String phone;    private String createTime; // 注意：这里是String类型，与实体类不同    private Boolean isActive;        // 构造方法、getter、setter 省略...&#125;// 定义映射器接口@Mapperpublic interface UserMapper &#123;    // 将User实体转换为UserDto    // MapStruct会自动匹配同名字段进行映射    UserDto toDto(User user);        // 将UserDto转换为User实体    // 支持双向转换，方便在不同层之间传递数据    User toEntity(UserDto userDto);        // 批量转换：将User列表转换为UserDto列表    // MapStruct自动支持集合类型的转换    List&lt;UserDto&gt; toDtoList(List&lt;User&gt; users);        // 批量转换：将UserDto列表转换为User列表    List&lt;User&gt; toEntityList(List&lt;UserDto&gt; dtos);&#125;\r\n这是最基本的使用方式，MapStruct\r\n会根据字段名自动匹配并生成转换代码。当源对象和目标对象的字段名完全一致时，会自动进行映射。\r\n映射出的代码示例如下，相当于\r\npublic class UserMapperImpl implements UserMapper &#123;    private final AddressMapper addressMapper = new AddressMapperImpl();        @Override    public UserDto toDto(User user) &#123;        if (user == null) &#123;            return null;        &#125;                UserDto userDto = new UserDto();        userDto.setId(user.getId());        userDto.setUsername(user.getUsername());        userDto.setPhone(user.getPhone());        userDto.setEmail(user.getEmail());        userDto.setCreateTime(user.getCreateTime());        userDto.setIsActive(user.getIsActive());                return userDto;    &#125;        // 其他方法实现...&#125;\r\n在生成的方法实现中，源类型（例如Person）的所有可读属性都将被复制到目标类型（例如PersonDto）的相应属性中：\r\n\r\n当一个属性与其目标实体对应的名称相同时，它将被隐式映射。\r\n当属性在目标实体中具有不同的名称时，可以通过@Mapping注释指定其名称。\r\n\r\n默认方式获取映射器实例\r\n\r\n@Mapping 基础接口的定义\r\n当源对象和目标对象的字段名不一致，或者需要特殊处理时，使用\r\n@Mapping\r\n注解。它只会定义单个字段的映射规则，支持属性名转换、表达式、常量等。在字段名不一致、类型转换、动态赋值时使用\r\n关键属性：\r\n\r\nsource：源对象属性名（支持嵌套路径，如\r\nuser.address.city）。\r\ntarget：目标对象属性名。\r\nexpression：自定义转换逻辑（如调用方法）。\r\nconstant：固定值映射。\r\nignore：忽略该字段。\r\n\r\n@Mapperpublic interface UserMapper &#123;    @Mapping(source = &quot;userName&quot;, target = &quot;name&quot;)    @Mapping(source = &quot;userAddress&quot;, target = &quot;address&quot;)    @Mapping(target = &quot;createTime&quot;, expression = &quot;java(new java.util.Date())&quot;)    @Mapping(target = &quot;status&quot;, constant = &quot;ACTIVE&quot;)    @Mapping(target = &quot;password&quot;, ignore = true)    UserDTO toUserDTO(User user);&#125;\r\n上述代码的映射相当于如下代码的实现\r\npublic UserDTO toUserDTO(User user) &#123;    if (user == null) &#123;        return null;    &#125;        UserDTO userDTO = new UserDTO();    userDTO.setName(user.getUserName());  // 字段名映射    userDTO.setAddress(user.getUserAddress());  // 字段名映射    userDTO.setCreateTime(new java.util.Date());  // 表达式映射    userDTO.setStatus(&quot;ACTIVE&quot;);  // 常量映射    // password 字段被忽略，不会被映射        return userDTO;&#125;\r\n这个注解可以使用@Mappings进行多个 @Mapping\r\n注解的组合，用于定义多个字段映射规则。当需要\r\n需要同时配置多个字段的映射关系时，这么写比较整洁\r\n@Mapperpublic interface UserMapper &#123;    @Mappings(&#123;        @Mapping(source = &quot;id&quot;, target = &quot;userId&quot;),        @Mapping(source = &quot;email&quot;, target = &quot;contactInfo&quot;),        @Mapping(source = &quot;birthDate&quot;, target = &quot;age&quot;, qualifiedByName = &quot;BirthDateToAge&quot;)    &#125;)    UserDTO toUserDTO(User user);&#125;\r\n@BeanMapping\r\n用于配置整个方法的映射行为。如忽略未映射字段或空值处理。\r\n关键属性：\r\n\r\nignoreByDefault：忽略所有未明确映射的字段\r\nnullValuePropertyMappingStrategy：处理 null\r\n值的策略\r\nnullValueCheckStrategy：null 值检查策略\r\n\r\n@Mapperpublic interface UserMapper &#123;    @BeanMapping(ignoreByDefault = true)  // 忽略所有未明确映射的字段    @Mapping(source = &quot;id&quot;, target = &quot;userId&quot;)    @Mapping(source = &quot;name&quot;, target = &quot;fullName&quot;)    UserDTO toUserDTO(User user);        @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)    void updateUserFromDto(UserDTO dto, @MappingTarget User user);  // 更新现有对象&#125;\r\n@BeforeMapping / @AfterMapping\r\n允许在映射前后执行自定义逻辑。在动态修改源/目标对象、填充额外字段、调用外部服务时候使用，一般用于格式化日期\r\n@Mapperpublic interface UserMapper &#123;    @BeforeMapping    default void mapBefore(User user, @MappingTarget UserDTO dto) &#123;        // 在映射前执行        if (user.getStatus() == UserStatus.INACTIVE) &#123;            dto.setInactive(true);        &#125;    &#125;        @AfterMapping    default void mapAfter(User user, @MappingTarget UserDTO dto) &#123;        // 在映射后执行        if (dto.getAge() &gt; 18) &#123;            dto.setAdult(true);        &#125;    &#125;        UserDTO toUserDTO(User user);&#125;\r\n@IterableMapping\r\n定义集合类型（如\r\nList、Set）元素的映射规则。集合元素类型转换或批量映射时候进行使用\r\n关键属性：\r\n\r\nelementTargetType：目标元素类型。\r\ndateFormat：日期格式化。\r\n\r\n@Mapperpublic interface UserMapper &#123;    @IterableMapping(qualifiedByName = &quot;userToDto&quot;)    List&lt;UserDTO&gt; toDtoList(List&lt;User&gt; users);        @Named(&quot;userToDto&quot;)    default UserDTO userToDto(User user) &#123;        // 自定义映射逻辑        UserDTO dto = new UserDTO();        dto.setId(user.getId());        dto.setName(user.getName() + &quot; (DTO)&quot;);        return dto;    &#125;&#125;\r\n@MapMapping\r\n用于配置 Map\r\n类型的映射。使用起来和上述@IterableMapping并无明显差距\r\n关键属性：\r\n\r\nkeyDateFormat /\r\nvalueDateFormat：键或值的日期格式。\r\nmapNullToEmpty：空 Map 处理。\r\n\r\n@Mapperpublic interface UserMapper &#123;    @MapMapping(keyDateFormat = &quot;yyyy-MM-dd&quot;, valueDateFormat = &quot;HH:mm:ss&quot;)    Map&lt;String, String&gt; mapToStringMap(Map&lt;Date, Date&gt; dateMap);        @MapMapping(valueTransformation = &quot;toString&quot;)    Map&lt;String, String&gt; toStringMap(Map&lt;String, Integer&gt; intMap);&#125;\r\n@MapperConfig\r\n定义可重用的映射配置，供多个映射器继承。便于统一配置公共策略（如日期格式、空值处理）。\r\n@MapperConfig(    componentModel = &quot;spring&quot;,    unmappedTargetPolicy = ReportingPolicy.IGNORE,    uses = &#123;AddressMapper.class&#125;)public interface MyMapperConfig &#123;&#125;@Mapper(config = MyMapperConfig.class)public interface UserMapper &#123;    // 使用共享配置的映射器&#125;\r\n@InheritConfiguration / @InheritInverseConfiguration\r\n重用现有映射配置。继承正向或逆向映射规则，避免重复配置。\r\n\r\n@InheritConfiguration：正向转换，原mapper →\r\n转换后类型的mapper\r\n@InheritInverseConfiguration：逆向转换，转换后类型的mapper\r\n→ 原mapper\r\n\r\n@Mapperpublic interface UserMapper &#123;    @Mapping(source = &quot;id&quot;, target = &quot;userId&quot;)    @Mapping(source = &quot;email&quot;, target = &quot;contactInfo&quot;)    UserDTO toUserDTO(User user);        @InheritConfiguration(name = &quot;toUserDTO&quot;)    List&lt;UserDTO&gt; toUserDTOList(List&lt;User&gt; users);        @InheritInverseConfiguration(name = &quot;toUserDTO&quot;)    User toUser(UserDTO dto);&#125;\r\n@ValueMapping\r\n配置枚举类型的映射。\r\n@Mapperpublic interface StatusMapper &#123;    @ValueMapping(source = &quot;INACTIVE&quot;, target = &quot;DISABLED&quot;)    @ValueMapping(source = &quot;ACTIVE&quot;, target = &quot;ENABLED&quot;)    @ValueMapping(source = &quot;PENDING&quot;, target = &quot;ON_HOLD&quot;)    @ValueMapping(source = &quot;DELETED&quot;, target = &quot;NULL&quot;)    @ValueMapping(source = &quot;NULL&quot;, target = &quot;DEFAULT&quot;)    UserStatusDto toDto(UserStatus status);&#125;\r\n此外，MapStruct 还提供了特殊的源/目标值 NULL 和\r\nANY，可以用于处理源枚举值为 null 或未映射的情况。\r\n@Mapperpublic interface EnumMapper &#123;    @ValueMappings(&#123;        @ValueMapping(source = &quot;TYPE_A&quot;, target = &quot;TYPE_X&quot;),        @ValueMapping(source = &quot;TYPE_B&quot;, target = &quot;TYPE_Y&quot;),        @ValueMapping(source = &quot;TYPE_C&quot;, target = &quot;TYPE_Z&quot;),        @ValueMapping(source = &quot;NULL&quot;, target = &quot;TYPE_Z&quot;),        @ValueMapping(source = &quot;ANY&quot;, target = &quot;TYPE_X&quot;)    &#125;)    TargetEnum sourceToTarget(SourceEnum sourceEnum);&#125;\r\n@Context\r\n在映射过程中传递上下文信息。\r\n需要外部数据参与映射逻辑（如权限校验）时候使用。\r\n@Mapperpublic interface UserMapper &#123;    UserDTO toDto(User user, @Context Locale locale);        default String formatDate(Date date, @Context Locale locale) &#123;        // 使用上下文信息进行格式化        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, locale).format(date);    &#125;&#125;\r\n@Named\r\n为映射方法命名，便于在其他地方引用。\r\n@Mapperpublic interface UserMapper &#123;    @Mapping(source = &quot;birthDate&quot;, target = &quot;age&quot;, qualifiedByName = &quot;BirthDateToAge&quot;)    UserDTO toDto(User user);        @Named(&quot;BirthDateToAge&quot;)    default Integer birthDateToAge(Date birthDate) &#123;        // 计算年龄的逻辑        if (birthDate == null) &#123;            return null;        &#125;        Calendar birth = Calendar.getInstance();        birth.setTime(birthDate);        Calendar now = Calendar.getInstance();        int age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR);        if (now.get(Calendar.DAY_OF_YEAR) &lt; birth.get(Calendar.DAY_OF_YEAR)) &#123;            age--;        &#125;        return age;    &#125;&#125;\r\n属性讲解\r\ncomponentModel 属性\r\n@Mapper 注解的 componentModel\r\n属性用于指定自动生成的接口实现类的组件类型，这个属性支持四个值：\r\n\r\ndefault: 这是默认的情况，mapstruct\r\n不使用任何组件类型,\r\n可以通过Mappers.getMapper(Class)方式获取自动生成的实例对象。\r\nspring:\r\n生成的实现类上面会自动添加一个@Component注解，可以通过Spring的\r\n@Autowired或者@Resource方式进行注入\r\n@Mapper(componentModel = &quot;spring&quot;)public interface PersonMapper &#123;    @Mapping(source = &quot;name&quot;, target = &quot;fullName&quot;)    PersonDto personToPersonDto(Person person);&#125;\r\n@Servicepublic class PersonService &#123;    @Autowired  \tprivate PersonMapper personMapper;      \tpublic PersonDto convert(Person person)&#123;      PersonDto dto = personMapper.personToPersonDto(person);      return dto;    &#125;   &#125;\r\njsr330:\r\n生成的实现类上会添加@javax.inject.Named\r\n和@Singleton注解，可以通过\r\n@Inject注解获取\r\n\r\nnullValueCheckStrategy 属性\r\n是否在生成的实现类中，对每一个属性进行null检查，可选值有两个：ON_IMPLICIT_CONVERSION（默认值）和\r\nALWAYS 。\r\nALWAYS\r\nALWAYS 表示在赋值之前，对每一个属性进行!=\r\nnull的检查。\r\nON_IMPLICIT_CONVERSION\r\nON_IMPLICIT_CONVERSION则表示直接进行赋值，不进行 != null\r\n判断。\r\nnullValuePropertyMappingStrategy属性\r\n指定当源属性为null或者不存在时目标属性生成值的策略，可选值有：\r\n\r\nSET_TO_NULL（默认值）\r\n当源属性为null或者不存在时，设置目标属性的值为null。\r\nSET_TO_DEFAULT\r\n根据源属性的类型，设置指定的默认值。\r\n\r\n源属性是List，则默认值是ArrayList；\r\n源属性是String，则默认值是”“；\r\n源属性是基本类型，则默认值是0或者false；\r\n源属性是Map，则默认值是LinkedHashMap；\r\n源属性是数组，则默认值是空数组。\r\n\r\nIGNORE\r\n如果源属性是null或者不存在，则不会将null赋值给目标属性，目标属性是什么值就保持什么值。\r\n\r\n指定默认值\r\n在@Mapper接口类里面的转换方法上添加@Mapping注解的时候，如果需要指定默认值\r\ntarget()\r\n必须添加，source()可以不添加，则直接使用defaultValue\r\nMapStruct也支持默认值映射，你可以使用@Mapping注解的defaultValue参数来实现这一点：\r\n@Mapping(target = &quot;describe&quot;, defaultValue = &quot;默认值&quot;)PersonDTO conver(Person person);\r\n自定义映射\r\n在某些情况下，可能需要自定义字段映射。可以通过在@Mapping注解中使用expression或qualifiedByName参数来实现这一点。\r\nqualifiedByName这个参数允许你引用一个具有@Named注解的方法作为自定义的映射逻辑\r\n@Mapperpublic interface OrderMapper &#123;      @Mapping(target = &quot;customerName&quot;, source = &quot;customer&quot;, qualifiedByName = &quot;fullName&quot;)    OrderDto orderToOrderDto(Order order);\t\t@Named(&quot;fullName&quot;)\t\tdefault String customerToString(Customer customer) &#123;    \t\treturn customer.getFirstName() + &quot; &quot; + customer.getLastName();\t\t&#125;&#125;\r\n在这个例子中，orderToOrderDto方法将Order的customer字段（类型为Customer）转换为OrderDto的customerName字段（类型为String），并且使用了customerToString方法来获取全名。\r\nexperssion\r\nexpression这个参数允许你使用Java表达式来定义字段映射。这在源和目标字段之间需要一些特定逻辑时非常有用。\r\n注意：\r\n这个属性不能与source()、defaultValue()、defaultExpression()、qualifiedBy()、qualifiedByName()或constant()一起使用。\r\n@Mapperpublic interface OrderMapper &#123;    @Mapping(target = &quot;orderDate&quot;, expression = &quot;java(new java.text.SimpleDateFormat(\\&quot;yyyy-MM-dd\\&quot;).format(order.getCreationDate()))&quot;)    OrderDto orderToOrderDto(Order order);&#125;\r\n在这个例子中，orderToOrderDto方法将Order的creationDate字段（类型为Date）转换为OrderDto的orderDate字段（类型为String），并且使用了特定的日期格式。\r\n@BeanMapping在映射方法级别提供更详细的配置\r\n从MapStruct\r\n1.5开始，可以使用@BeanMapping注解在MapStruct中用于在映射方法级别提供更详细的配置。这个注解有许多参数可以使用。\r\n\r\nresultType:\r\n这个参数允许你指定映射方法的返回类型。这在目标类型可以是多个实现类时非常有用。\r\n如果目标类型有多个实现类，并且你希望在映射时使用特定的实现类。通过指定resultType，你可以确保生成的映射代码使用正确的目标类型\r\n@BeanMapping(resultType = CarDto.class)CarDto map(Car car);\r\nqualifiedBy和qualifiedByName:\r\n这两个参数允许你引用一个具有@Qualifier或@Named注解的方法作为自定义的映射逻辑。\r\n@BeanMapping(qualifiedByName = &quot;fullName&quot;)PersonDto personToPersonDto(Person person);@Named(&quot;fullName&quot;)default String customerToString(Customer customer) &#123;    return customer.getFirstName() + &quot; &quot; + customer.getLastName();&#125;\r\nignoreByDefault:\r\n这个参数允许你忽略所有未明确映射的属性。然后，你可以使用@Mapping注解来明确需要映射的属性。\r\n@BeanMapping(ignoreByDefault = true)@Mapping(target = &quot;name&quot;, source = &quot;fullName&quot;)PersonDto personToPersonDto(Person person);\r\nnullValuePropertyMappingStrategy:\r\n这个参数允许你指定当源属性为null时应如何处理目标属性。例如，你可以选择是否在源属性为null时调用目标的setter方法。\r\n@BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)PersonDto personToPersonDto(Person person);\r\n\r\n使用装饰器增强Mapper\r\n你可以使用装饰器来增强你的Mapper。\r\nMapStruct\r\n装饰器是一种强大的机制，允许你在生成的映射代码基础上添加自定义逻辑，而不需要完全重写映射方法。这在需要处理复杂业务逻辑、添加额外验证或执行副作用操作时特别有用。\r\n装饰器本质上是一个抽象类或接口，它实现了你的映射器接口，并在映射方法执行前后添加自定义逻辑。MapStruct\r\n会在生成的代码中自动调用这些装饰器方法。\r\npublic abstract class UserMapperDecorator implements UserMapper &#123;    // 注入原始的映射器实现    private final UserMapper delegate;        public UserMapperDecorator(UserMapper delegate) &#123;        this.delegate = delegate;    &#125;        // 重写需要增强的方法    @Override    public UserDto toDto(User user) &#123;        // 映射前的逻辑        System.out.println(&quot;开始映射用户: &quot; + (user != null ? user.getId() : &quot;null&quot;));                // 调用委托实现进行实际映射        UserDto dto = delegate.toDto(user);                // 映射后的逻辑        if (dto != null) &#123;            // 增强映射结果            dto.setDisplayName(dto.getName() + &quot; (已映射)&quot;);            // 可以添加业务逻辑，如计算派生字段            dto.setAge(calculateAge(user.getBirthDate()));        &#125;                return dto;    &#125;        // 自定义方法    private int calculateAge(Date birthDate) &#123;        // 计算年龄的逻辑        if (birthDate == null) return 0;                Calendar birth = Calendar.getInstance();        birth.setTime(birthDate);        Calendar now = Calendar.getInstance();                int age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR);        if (now.get(Calendar.DAY_OF_YEAR) &lt; birth.get(Calendar.DAY_OF_YEAR)) &#123;            age--;        &#125;                return age;    &#125;&#125;\r\n当 MapStruct 生成代码时，它会创建一个 UserMapper\r\n的实现类，这个实现类会委托给 UserMapperDecorator\r\n处理。装饰器类中没有重写的方法会由 MapStruct 自动生成。\r\n@Mapper(componentModel = &quot;spring&quot;)@DecoratedWith(UserMapperDecorator.class) // 指定装饰器public interface UserMapper &#123;    UserDto toDto(User user);    User toEntity(UserDto dto);&#125;\r\n常量映射\r\n@Mapping注解constant属性可以用于将源对象的某个固定值映射到目标对象的属性：\r\n@Mapperpublic interface CarMapper &#123;    @Mapping(target = &quot;carType&quot;, constant = &quot;SEDAN&quot;)    CarDto carToCarDto(Car car);&#125;\r\n在这个例子中，carToCarDto方法将会把CarDto的carType字段设置为SEDAN，无论Car对象的实际内容如何。\r\n转换情景与规则\r\n默认方式获取映射器实例\r\n在实现类的时候， 如果属性名称相同，\r\n则会进行对应的转化。通过此种方式，\r\n我们可以快速的编写出转换的方法。、\r\n适用于 Source 和 Target\r\n需要转化的属性是完全相同的，也就是说转换前后不会出现不同的字段\r\n// 用户实体类 - 通常对应数据库表结构public class User &#123;    private Long id;    private String username;    private String email;    private String phone;    private Date createTime;    private Boolean isActive;        // 构造方法、getter、setter 省略...&#125;// 用户DTO类 - 用于数据传输，通常会隐藏一些敏感字段public class UserDto &#123;    private Long id;    private String username;    private String email;    private String phone;    private String createTime; // 注意：这里是String类型，与实体类不同    private Boolean isActive;        // 构造方法、getter、setter 省略...&#125;// 定义映射器接口@Mapperpublic interface UserMapper &#123;    // 将User实体转换为UserDto    // MapStruct会自动匹配同名字段进行映射    UserDto toDto(User user);        // 将UserDto转换为User实体    // 支持双向转换，方便在不同层之间传递数据    User toEntity(UserDto userDto);        // 批量转换：将User列表转换为UserDto列表    // MapStruct自动支持集合类型的转换    List&lt;UserDto&gt; toDtoList(List&lt;User&gt; users);        // 批量转换：将UserDto列表转换为User列表    List&lt;User&gt; toEntityList(List&lt;UserDto&gt; dtos);&#125;\r\n在需要进行类型转换的地方，使用在@Mapper映射器接口中定义的方法就会自动进行转换\r\n@Servicepublic class UserService &#123;        // 通过Mappers.getMapper()获取自动生成的实例    private final UserMapper userMapper = Mappers.getMapper(UserMapper.class);        public UserDto getUserById(Long id) &#123;        // 假设从数据库查询到User实体        User user = userRepository.findById(id);                // 使用映射器将实体转换为DTO        // 编译后生成的代码会直接调用setter/getter方法，性能接近手写代码        return userMapper.toDto(user);    &#125;        public List&lt;UserDto&gt; getAllUsers() &#123;        List&lt;User&gt; users = userRepository.findAll();                // 批量转换，MapStruct会自动处理集合中的每个元素        return userMapper.toDtoList(users);    &#125;&#125;\r\n编译后，MapStruct 会生成类似以下的实现代码：\r\n// 这是MapStruct自动生成的实现类，开发者无需编写@Generated(    value = &quot;org.mapstruct.ap.MappingProcessor&quot;,    date = &quot;2024-01-01T10:00:00+0800&quot;,    comments = &quot;version: 1.5.5.Final, compiler: javac, environment: Java 11&quot;)public class UserMapperImpl implements UserMapper &#123;    @Override    public UserDto toDto(User user) &#123;        if (user == null) &#123;            return null; // 自动进行null检查        &#125;        UserDto userDto = new UserDto();                // 直接调用getter/setter方法，无反射开销        userDto.setId(user.getId());        userDto.setUsername(user.getUsername());        userDto.setEmail(user.getEmail());        userDto.setPhone(user.getPhone());        userDto.setIsActive(user.getIsActive());                // 对于Date到String的转换，MapStruct会自动处理        if (user.getCreateTime() != null) &#123;            userDto.setCreateTime(user.getCreateTime().toString());        &#125;        return userDto;    &#125;    @Override    public User toEntity(UserDto userDto) &#123;        if (userDto == null) &#123;            return null;        &#125;        User user = new User();                user.setId(userDto.getId());        user.setUsername(userDto.getUsername());        user.setEmail(userDto.getEmail());        user.setPhone(userDto.getPhone());        user.setIsActive(userDto.getIsActive());                // String到Date的转换需要特殊处理（后面会介绍如何配置）        // 这里简化处理...        return user;    &#125;    @Override    public List&lt;UserDto&gt; toDtoList(List&lt;User&gt; users) &#123;        if (users == null) &#123;            return null;        &#125;        List&lt;UserDto&gt; list = new ArrayList&lt;UserDto&gt;(users.size());        // 遍历集合，逐个转换        for (User user : users) &#123;            list.add(toDto(user));        &#125;        return list;    &#125;    // toEntityList方法实现类似...&#125;\r\n字段映射配置\r\n属性名不相同， 在需要进行互相转化的时候， 则我们可以通过\r\n@Mapping 注解来进行转化.\r\n这适用于当源对象和目标对象的字段名不一致，或者需要特殊的转换逻辑时\r\n@Mapperpublic interface ProductMapper &#123;    @Mapping(source = &quot;productName&quot;, target = &quot;name&quot;)    @Mapping(source = &quot;productPrice&quot;, target = &quot;price&quot;)    @Mapping(source = &quot;createdTime&quot;, target = &quot;createDate&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;)    ProductDto toDto(Product product);&#125;\r\n有时候我们不希望某些字段参与映射，可以使用 ignore = true\r\n来忽略它们：\r\n// 订单实体类public class Order &#123;    private Long orderId;    private String orderNumber;    private BigDecimal totalAmount;    private Date createTime;    private String internalNotes;  // 内部备注，不对外暴露    private Integer version;       // 版本号，乐观锁字段    private String auditLog;       // 审计日志，敏感信息        // getter、setter省略...&#125;// 订单DTO类public class OrderDto &#123;    private Long orderId;    private String orderNumber;    private BigDecimal totalAmount;    private String createTime;    // 注意：没有internalNotes、version、auditLog字段        // getter、setter省略...&#125;@Mapperpublic interface OrderMapper &#123;        // 忽略敏感字段和内部字段    @Mapping(target = &quot;internalNotes&quot;, ignore = true)  // 忽略内部备注    @Mapping(target = &quot;version&quot;, ignore = true)        // 忽略版本字段    @Mapping(target = &quot;auditLog&quot;, ignore = true)       // 忽略审计日志    @Mapping(source = &quot;createTime&quot;, target = &quot;createTime&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;)    OrderDto toDto(Order order);        // DTO转实体时，被忽略的字段不会被设置，保持默认值或null    @Mapping(source = &quot;createTime&quot;, target = &quot;createTime&quot;, dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;)    Order toEntity(OrderDto dto);&#125;\r\n嵌套对象映射\r\n这是比较复杂的映射场景，MapStruct\r\n支持嵌套对象的自动映射，当对象包含其他对象时，会递归进行映射：\r\n当源对象和目标对象都包含嵌套结构时，MapStruct\r\n会自动递归处理这些嵌套对象\r\n// 部门实体public class Department &#123;    private Long deptId;    private String deptName;    private String location;        // getter、setter省略...&#125;// 部门DTOpublic class DepartmentDto &#123;    private Long deptId;    private String deptName;    private String location;        // getter、setter省略...&#125;// 员工实体 - 包含部门对象public class Employee &#123;    private Long empId;    private String empName;    private String email;    private Department department; // 嵌套的部门对象        // getter、setter省略...&#125;// 员工DTO - 同样包含部门DTO对象public class EmployeeDto &#123;    private Long empId;    private String empName;    private String email;    private DepartmentDto department; // 嵌套的部门DTO对象        // getter、setter省略...&#125;// 需要先定义部门映射器@Mapperpublic interface DepartmentMapper &#123;    DepartmentDto toDto(Department department);    Department toEntity(DepartmentDto dto);&#125;// 员工映射器 - 会自动处理嵌套对象@Mapper(uses = DepartmentMapper.class) // 指定依赖的映射器public interface EmployeeMapper &#123;        // MapStruct会自动检测到department字段是嵌套对象    // 并使用DepartmentMapper来进行转换    EmployeeDto toDto(Employee employee);        Employee toEntity(EmployeeDto dto);&#125;\r\n此时嵌套映射的工作原理\r\n\r\nMapStruct 会自动检测到 Employee 中的\r\ndepartment 字段是一个 Department 对象\r\n它会查找是否有可用的 Department 到\r\nDepartmentDto 的映射方法\r\n如果找到了（通过 uses 属性指定的\r\nDepartmentMapper），就会使用该映射器处理嵌套对象\r\n如果没找到，会尝试自动生成映射逻辑\r\n\r\n如果其中遇到了更复杂的嵌套处理路径，我们可以使用\r\n@Mapping(source = \"嵌套字段\", target = \"目标字段\")\r\n@Mapperpublic interface OrderMapper &#123;    @Mapping(source = &quot;customer.address.city&quot;, target = &quot;deliveryCity&quot;)    OrderDto toDto(Order order);&#125;\r\n在这个例子中，toDto方法将customer的address.city属性映射到OrderDto的deliveryCity属性。\r\n使用自定义的转换\r\n有时候，对于某些类型， 无法通过代码生成器的形式来进行处理。 那么，\r\n就需要自定义的方法来进行转换。或者当MapStruct的默认转换逻辑无法满足复杂业务需求时，我们也可以在映射器中定义自定义方法：\r\n这时候， 我们可以在接口(同一个接口， 后续还有调用别的 Mapper\r\n的方法)中定义默认方法(Java8及之后)。\r\n自定义转换方法可以是：\r\n\r\n同一映射器接口中的默认方法\r\n其他映射器中的方法（通过 uses 属性引用）\r\n静态工具类中的方法（通过 uses 属性引用）\r\n\r\n@Mapperpublic interface UserMapper &#123;        // 基本映射方法，引用自定义转换    @Mapping(source = &quot;createTime&quot;, target = &quot;createDate&quot;, dateFormat = &quot;yyyy-MM-dd&quot;)    @Mapping(source = &quot;status&quot;, target = &quot;statusText&quot;, qualifiedByName = &quot;statusToText&quot;)    @Mapping(target = &quot;fullName&quot;, expression = &quot;java(formatFullName(user.getFirstName(), user.getLastName()))&quot;)    UserDto toDto(User user);        // 自定义转换方法：将状态码转换为文本描述    @Named(&quot;statusToText&quot;) // 指定方法名，供@Mapping使用    default String statusToText(Integer status) &#123;        if (status == null) &#123;            return &quot;未知&quot;;        &#125;        switch (status) &#123;            case 1:                return &quot;激活&quot;;            case 0:                return &quot;禁用&quot;;            case -1:                return &quot;删除&quot;;            default:                return &quot;未知状态&quot;;        &#125;    &#125;        // 自定义方法：处理复杂的业务逻辑    default String formatFullName(String firstName, String lastName) &#123;        if (firstName == null &amp;&amp; lastName == null) &#123;            return null;        &#125;        if (firstName == null) &#123;            return lastName;        &#125;        if (lastName == null) &#123;            return firstName;        &#125;        return firstName + &quot; &quot; + lastName;    &#125;&#125;\r\n使用外部工具类进行自定义转换\r\n// 工具类public class DateFormatters &#123;    public static String formatDate(Date date) &#123;        if (date == null) return null;        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        return format.format(date);    &#125;&#125;// 映射器@Mapper(uses = DateFormatters.class)public interface UserMapper &#123;    @Mapping(source = &quot;birthDate&quot;, target = &quot;formattedBirthDate&quot;, qualifiedByName = &quot;formatDate&quot;)    UserDto toDto(User user);&#125;\r\n也可以使用 @Context 传递上下文信息\r\n@Mapperpublic interface UserMapper &#123;    UserDto toDto(User user, @Context Locale locale);        default String formatDate(Date date, @Context Locale locale) &#123;        if (date == null) return null;        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, locale);        return format.format(date);    &#125;&#125;// 使用示例Locale locale = Locale.CHINA;UserDto dto = userMapper.toDto(user, locale);\r\n多转一\r\n我们在实际的业务中少不了将多个对象转换成一个的场景。 MapStruct\r\n当然也支持多转一的操作。\r\n\r\n将多个实体对象合并为一个 DTO\r\n将表单数据和查询参数合并为一个业务对象\r\n将配置信息和运行时数据合并为一个完整的上下文对象\r\n\r\nMapStruct\r\n通过方法参数实现多对象映射，只需要在映射方法中声明多个源对象参数即可\r\n@Mapperpublic interface CarMapper &#123;    // 多个源对象映射到一个目标对象    @Mapping(source = &quot;car.make&quot;, target = &quot;manufacturer&quot;)    @Mapping(source = &quot;car.numberOfSeats&quot;, target = &quot;seatCount&quot;)    @Mapping(source = &quot;owner.name&quot;, target = &quot;ownerName&quot;)    CarDto carAndOwnerToCarDto(Car car, Person owner);        // 支持更多源对象    CarFullInfoDto carAndOwnerAndConfigToCarFullInfoDto(Car car, Person owner, CarConfig config);&#125;\r\n字段冲突处理\r\n当多个源对象包含同名属性时，MapStruct\r\n默认使用最后一个参数中的值：\r\n@Mapperpublic interface ConflictMapper &#123;    // 如果Source1和Source2都有name属性，将使用Source2中的值    Target mergeSources(Source1 source1, Source2 source2);        // 显式指定使用哪个源对象的属性    @Mapping(source = &quot;source1.name&quot;, target = &quot;nameFromSource1&quot;)    @Mapping(source = &quot;source2.name&quot;, target = &quot;nameFromSource2&quot;)    TargetWithBothNames mergeSourcesWithBothNames(Source1 source1, Source2 source2);&#125;\r\n使用 @MappingTarget\r\n处理已存在的目标对象\r\n@Mapperpublic interface UpdateMapper &#123;    // 将source1和source2的属性合并到已存在的target对象中    void updateTarget(@MappingTarget Target target, Source1 source1, Source2 source2);&#125;\r\n更新现有 bean 对象\r\n在实际应用中，我们经常需要更新一个已存在的对象，而不是创建一个新对象。MapStruct\r\n提供了专门的机制来处理这种情况。\r\n使用 @MappingTarget 注解\r\n@Mapperpublic interface UserMapper &#123;    // 将DTO中的属性更新到已存在的实体对象中    void updateUserFromDto(UserDto userDto, @MappingTarget User user);        // 支持多个源对象更新    void updateUserFromDtoAndConfig(UserDto userDto, UserConfig config, @MappingTarget User user);        // 集合更新    void updateUserListFromDtoList(List&lt;UserDto&gt; userDtos, @MappingTarget List&lt;User&gt; users);&#125;\r\n可以使用 @BeanMapping\r\n进行更详细的配置更新策略\r\n@Mapperpublic interface CarMapper &#123;    // 忽略null值更新    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);        // 忽略未映射的属性    @BeanMapping(ignoreByDefault = true)    @Mapping(source = &quot;name&quot;, target = &quot;name&quot;)    @Mapping(source = &quot;price&quot;, target = &quot;price&quot;)    void updateCarWithSelectedFields(CarDto carDto, @MappingTarget Car car);&#125;\r\n","categories":["Java相关","框架相关小知识","其他实用知识"],"tags":["实用知识","JavaWeb","框架知识","常用知识","学习","JavaEE","Java框架"]},{"title":"个人向galgame原声带或相关音乐整理及其资源","url":"/posts/40344.html","content":"也是一直以来打算整理一下自己爱听的galgame ost\r\n或者其他galgame相关的音乐，按照专辑的方式进行整理，同时我有的也会扒下来上传\r\n就借助这个机会，好好的搞一下吧\r\n顺序随缘\r\n持续更新\r\n\r\n\r\n【FLAC+MP3】AIR ORIGINAL\r\nSOUNDTRACK\r\n神尾观铃镇楼\r\n\r\n\r\n\r\nAIR ORIGINAL SOUNDTRACK\r\n\r\n通过网盘分享的文件：AIR ORIGINAL SOUNDTRACK.zip\r\n13XeUCWQxV19snaDqzz48uA?pwd=1174 提取码: 1174 解压 10086\r\n\r\n【WAV】ゲーム「水葬銀貨のイストリア」Sound\r\nTrack／ウグイスカグラ\r\n\r\n\r\n【WAV】ゲーム「水葬銀貨のイストリア」Sound\r\nTrack／ウグイスカグラ\r\n\r\n【WAV】ゲーム「水葬銀貨のイストリア」Sound Track／ウグイスカグラ.zip\r\n百度网盘\r\n提取码: 1174\r\n\r\n【FLAC】さよならアーリーサマー／やなぎなぎ、麻枝准\r\n\r\n\r\nimg\r\n\r\n百度网盘\r\n提取码: 1174 需要改后缀\r\n解压码www.summerpockets.com 因为是鸟白岛演绎厅的资源\r\n\r\n【WAV】ゲーム「Summer\r\nPockets REFLECTION BLUE」EDM Arrange Album「De-Stress Summer」／Key\r\nSounds Label\r\n\r\n\r\n【WAV】ゲーム「Summer Pockets REFLECTION\r\nBLUE」EDM Arrange Album「De-Stress Summer」／Key Sounds\r\nLabel\r\n\r\n百度网盘\r\n1174\r\n解压码www.summerpockets.com 因为是鸟白岛演绎厅的资源\r\n\r\n【WAV】ゲーム「HEAVEN\r\nBURNS RED」Original Sound Track Vol.2／Key Sounds Label\r\n /1zGCb-DbVtiZw7OEhjtrEAw?pwd=1174 提取码: 1174\r\n\r\n【FLAC】オーガスト歴代ボーカル\r\nピアノアレンジ集「SPROUT AUGUST」／AUGUST.zip\r\n\r\n\r\n【WAV】オーガスト歴代ボーカル\r\nピアノアレンジ集「SPROUT AUGUST」／AUGUST\r\n\r\n通过网盘分享的文件：【FLAC】オーガスト歴代ボーカル\r\nピアノアレンジ集「SPROUT AUGUST」／AUGUST.zip\r\n/s/18sbtkuMKA4Y0pCgZnt9Vug?pwd=1174 提取码: 1174\r\n\r\n【WAV】Symphony\r\nSounds Request 3／Symphony Sounds.zip\r\n\r\ns/1egfV1odE2EYjNly2zOHSOw?pwd=1174 提取码: 1174\r\n\r\n【FLAC】アニメ「この世の果てで恋を唄う少女YU-NO」Original\r\nSound Track Vol.1+Vol.2／MAGES\r\n\r\n\r\nimg\r\n\r\n/s/11H4oSdj7eLC8DnjLczy3OA?pwd=1174 提取码: 1174\r\n解压密码：www.summerpockets.com\r\n\r\n【WAV／MP4】ゲーム「Kanon」16bit\r\nArrangements／Key Sounds Label\r\n \\1c6qn8xBuPZKcZa7r48aeig?pwd=1174 提取码: 1174\r\n解压密码：www.summerpockets.com\r\n\r\n【MP3+FLAC】White\r\nEternity of AstralAir ORIGINAL SOUNDTRACK PLUS\r\n\r\n\r\nimage-20250508091102092\r\n\r\n通过网盘分享的文件：White Eternity of AstralAir ORIGINAL SOUNDTRACK\r\nPLUS 解10086.zip 链接:\r\nhttps://pan.baidu.com/s/1n67xwWghZ6AHxl3x5UwXlg?pwd=1174 提取码:\r\n1174\r\n解压10086\r\n\r\n【MP3+FLAC】Key+Lia Best\r\n2001-2010\r\n\r\n\r\n\r\nimage-20250507203048688\r\n\r\n通过网盘分享的文件：【FLAC】Key+Lia Best 2001-2010.zip\r\n1uQsB0IOIx3WiV-alVB30Hg?pwd=1174 提取码: 1174\r\n\r\n【FLAC+MP3】Kanon\r\nAIR Piano Arrange Album Re-feel\r\n\r\n\r\nKanon AIR Piano Arrange Album Re-feel\r\n1esxDlcRiuVKFVnSHSehd7A?pwd=1174 提取码: 1174\r\n\r\n【FLAC+MP3】CLANNAD ORIGINAL\r\nSOUNDTRACK\r\n1e-8hP1MQxodUMCvR3AYw5g?pwd=1174 提取码: 1174\r\n\r\n【WAV】ゲーム「夢と色でできている」USB\r\nMemory with Digital Contents／feng\r\n\r\n\r\n【WAV】ゲーム「夢と色でできている」USB\r\nMemory with Digital Contents／feng\r\n\r\n通过网盘分享的文件：【WAV】ゲーム「夢と色でできている」USB Memory\r\nwith Digital Contents／feng 链接:\r\nhttps://pan.baidu.com/s/1KFY7ByNth5tp9VPDyBglkw?pwd=1174 提取码:\r\n1174\r\n\r\n【WAV】fengコンプリートボーカルアルバム／feng\r\n\r\n\r\nimg\r\n\r\n通过网盘分享的文件：feng Complete Vocal Album.zip 链接:\r\nhttps://pan.baidu.com/s/1NtXdmhhizF9JlCR4qTFi7g?pwd=1174 提取码:\r\n1174\r\n解压10086\r\n\r\n【FLAC+MP3】FAVORITE\r\n15th ANNIVERSARY VOCAL COLLECTION\r\n\r\n\r\nimage-20250508100048280\r\n\r\nMP3: 1lJbEcMMquJ3XgJ7UI003uQ?pwd=1174 提取码: 1174\r\nFLAC:\r\n解压10086\r\n通过网盘分享的文件：FAVORITE 15th ANNIVERSARY VOCAL COLLECTION 链接:\r\nhttps://pan.baidu.com/s/12PkkRzwkNPo71vxaaH5HnA?pwd=1174 提取码:\r\n1174\r\n\r\n【FLAC】鍵音祭\r\n(セットリスト)／Key Sounds Labe\r\n\r\n\r\nimg\r\n\r\n来自鸟白岛放映厅的资源\r\n通过网盘分享的文件：【FLAC】鍵音祭 (セットリスト)／Key Sounds Labe\r\n1DdJwmZ1DvbJ0erWJN1ZMqQ?pwd=1174 提取码: 1174\r\n解压 www.summerpockets.com\r\n\r\n【WAV】ゲーム「フレラバ\r\n～Friend to Lover～」Mini Fandisc &amp; Full Sound Track／SMEE\r\n\r\n\r\nimg\r\n\r\n通过网盘分享的文件：【WAV】ゲーム「フレラバ ～Friend to Lover～」Mini\r\nFandisc &amp; Full Sound Track／SMEE 1SI5G8FG2tSenoIdsm5wDBw?pwd=1174\r\n提取码: 1174\r\n解压 鸟白岛演绎厅-www.summerpockets.com\r\n\r\n【FLAC】向日葵の教会と長い夏休み\r\nサウンドトラック Himawari no Kyoukai to Nagai Natsuyasumi Soundtrack\r\nCD\r\n\r\n\r\nimage-20250508100956196\r\n\r\n通过网盘分享的文件：Himawari no Kyoukai to Nagai Natsuyasumi\r\nSoundtrack CD.zip 1sH6YwII1vADiQQ95ho4Y7Q?pwd=1174 提取码: 1174\r\n解压 10086\r\n\r\n【WAV】Key\r\nORCHESTRA CONCERT 2018／Key Sounds Label\r\n\r\n\r\nimg\r\n\r\n通过网盘分享的文件：【WAV】Key ORCHESTRA CONCERT 2018／Key Sounds\r\nLabel 17JZcyCw6nE2–xxXU2dSOA?pwd=1174 提取码: 1174\r\n解压 鸟白岛演绎厅-www.summerpockets.com\r\n\r\n","categories":["其他","galgame相关"],"tags":["其他","galgame","音乐"]},{"title":"个人总结的Java技术栈路线-持续更新","url":"/posts/14621.html","content":"Java SE部分\r\n\r\n基础语法\r\n\r\n变量与数据类型：基本数据类型（byte、short、int、long、float、double、char、boolean），引用数据类型（类、接口、数组、字符串等），变量的声明、初始化和作用域。\r\n运算符：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符等。\r\n流程控制：顺序结构、选择结构（if - else、switch -\r\ncase）、循环结构（for、while、do - while），以及 break、continue\r\n关键字的使用。\r\n方法：方法的定义、参数传递、返回值，方法的重载和递归调用。\r\n数组：一维数组和多维数组的声明、初始化、遍历和常用操作。\r\n\r\n面向对象编程\r\n\r\n类与对象：类的定义，对象的创建和使用，构造方法，this\r\n关键字。\r\n封装：访问修饰符（public、private、protected、默认），成员变量的封装和访问控制。\r\n继承：继承的概念，extends 关键字，方法重写，super\r\n关键字，继承的层次结构和多态性。\r\n多态：对象的多态性，方法的动态绑定，向上转型和向下转型。\r\n抽象类与接口：抽象类的定义和使用，抽象方法，接口的定义和实现，接口的多实现和默认方法。\r\n\r\n常用类\r\n\r\nString\r\n类：字符串的创建、操作（拼接、截取、替换等），字符串的比较，不可变特性。\r\nStringBuilder 与\r\nStringBuffer：可变字符串，两者的区别和适用场景。\r\n包装类：基本数据类型的包装类（Integer、Double、Boolean\r\n等），自动装箱和拆箱。\r\nMath\r\n类：数学运算相关的方法，如随机数生成、三角函数、指数运算等。\r\nDate 与 Calendar\r\n类：日期和时间的处理，获取当前日期和时间，日期的格式化和解析。\r\nFile\r\n类：文件和目录的操作，文件的创建、删除、读取、写入，目录的创建和遍历。\r\n\r\n内部类和包装类\r\n\r\n内部类\r\n\r\n成员内部类：定义在另一个类的内部，作为外部类的一个成员，可以访问外部类的所有成员。\r\n静态内部类：使用 static\r\n修饰的内部类，只能访问外部类的静态成员。\r\n局部内部类：定义在方法内部，只能在该方法内部使用。\r\n匿名内部类：没有显式的类名，通常用于创建一次性的对象，常用于实现接口或继承抽象类。\r\n\r\n包装类\r\n\r\n基本数据类型对应的包装类：Byte、Short、Integer、Long、Float、Double、Character、Boolean。\r\n自动装箱和拆箱：Java\r\n提供了自动将基本数据类型转换为包装类对象（装箱）和将包装类对象转换为基本数据类型（拆箱）的功能。\r\n\r\n\r\n注解\r\n\r\n内置注解：如 @Override\r\n用于标识方法重写；@Deprecated\r\n用于标记已过时的元素；@SuppressWarnings\r\n用于抑制编译器警告。\r\n元注解：用于定义注解的注解，如\r\n@Retention\r\n用于指定注解的保留策略（SOURCE、CLASS、RUNTIME）；@Target\r\n用于指定注解可以应用的目标元素类型。\r\n自定义注解：可以通过 @interface\r\n关键字定义自己的注解，并使用元注解进行配置。\r\n\r\n动态代理\r\n\r\n概念：在运行时动态创建代理类和代理对象，无需手动编写代理类的代码。\r\nJava 中的动态代理实现\r\n\r\n基于接口的动态代理：使用\r\njava.lang.reflect.Proxy 类和\r\njava.lang.reflect.InvocationHandler 接口实现。\r\n基于类的动态代理：使用第三方库如 CGLIB\r\n实现，它可以为没有实现接口的类创建代理。\r\n\r\n\r\n枚举\r\n\r\n基本概念：枚举是一种特殊的类，用于定义一组固定的常量。\r\n枚举的定义和使用：使用 enum\r\n关键字定义枚举类型，枚举常量默认是 public static final\r\n的。\r\n枚举的方法：枚举类型可以有自己的构造方法、成员变量和方法，还可以实现接口。\r\n\r\n集合框架\r\n\r\nList 接口：有序、可重复的集合，常用实现类有\r\nArrayList、LinkedList，列表的添加、删除、查找等操作。\r\nSet 接口：无序、不可重复的集合，常用实现类有\r\nHashSet、TreeSet，集合的交、并、差等操作。\r\nMap 接口：键值对形式的集合，常用实现类有\r\nHashMap、TreeMap、Hashtable，映射的添加、获取、遍历等操作。\r\nQueue\r\n接口：队列，先进先出（FIFO）的数据结构，常用实现类有\r\nLinkedList、PriorityQueue。\r\n迭代器（Iterator）：用于遍历集合元素，统一的遍历方式，避免对集合内部结构的暴露。\r\n\r\n异常处理\r\n\r\n异常体系：Throwable 类，Error 和 Exception\r\n的区别，受检异常和非受检异常。\r\ntry - catch - finally 语句：捕获和处理异常，finally\r\n块的作用，多个 catch 块的使用。\r\nthrow 与 throws\r\n关键字：手动抛出异常，声明方法可能抛出的异常。\r\n自定义异常：创建自定义异常类，用于特定业务场景下的异常处理。\r\n\r\n多线程\r\n\r\n线程基础：线程的概念，进程与线程的区别，线程的生命周期（新建、就绪、运行、阻塞、死亡）。\r\n创建线程的方式：继承 Thread 类，实现 Runnable\r\n接口，使用 Callable 接口和 Future 获取线程执行结果。\r\n线程同步：synchronized\r\n关键字，同步方法和同步块，解决线程安全问题。\r\n线程通信：wait ()、notify ()、notifyAll ()\r\n方法，生产者 - 消费者模型。\r\n线程池：Executor\r\n框架，线程池的创建和使用，常见的线程池类型（如\r\nFixedThreadPool、CachedThreadPool 等）。\r\n\r\n并发编程\r\n\r\n原子操作：Atomic 类（如\r\nAtomicInteger、AtomicBoolean 等），利用 CAS（Compare and\r\nSwap）实现原子操作。\r\n并发集合：ConcurrentHashMap、CopyOnWriteArrayList\r\n等，支持高并发访问的集合类。\r\nLock\r\n接口：可重入锁（ReentrantLock），读写锁（ReentrantReadWriteLock），用于更灵活的线程同步控制。\r\n并发工具类：CountDownLatch、CyclicBarrier、Semaphore\r\n等，用于协调多个线程的执行。\r\n\r\nJava I/O\r\n\r\n字节流：InputStream 和 OutputStream 及其子类，如\r\nFileInputStream、FileOutputStream，用于读写字节数据。\r\n字符流：Reader 和 Writer 及其子类，如\r\nFileReader、FileWriter，用于读写字符数据，字符编码的转换。\r\n缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter，提高读写效率。\r\n对象流：ObjectInputStream 和\r\nObjectOutputStream，用于对象的序列化和反序列化。\r\nNIO（New\r\nI/O）：通道（Channel）、缓冲区（Buffer）、选择器（Selector），基于非阻塞的\r\nI/O 模型，提高 I/O 性能。\r\n\r\n反射机制\r\n\r\nClass 类：获取类的 Class 对象，通过 Class\r\n对象获取类的构造方法、成员变量、成员方法等信息。\r\n反射的应用：动态创建对象，调用对象的方法，访问和修改对象的成员变量，在框架开发和插件化开发中有广泛应用。\r\n\r\n泛型\r\n\r\n泛型的定义：在类、接口、方法中使用类型参数，提高代码的复用性和类型安全性。\r\n泛型的通配符：？、？extends T、？super T\r\n的含义和使用场景。\r\n泛型擦除：泛型在编译后的类型擦除机制，以及带来的一些限制和注意事项。\r\n\r\n网络编程\r\n\r\nHTTP协议：深入理解请求头/响应头结构、状态码、Cookie/Session机制\r\nNIO进阶：Selector多路复用、ByteBuffer内存池优化、Netty底层原理\r\nWebSocket：实现即时通讯功能，对比HTTP长轮询方案\r\n实战案例：开发简易HTTP服务器（支持GET/POST）、实现文件断点续传\r\n\r\nJUnit和断言\r\n新特性\r\n\r\nJava 8+：Lambda表达式、Stream\r\nAPI、Optional空安全处理\r\nJava\r\n11+：ZGC低延迟垃圾回收器、var局部变量类型推断\r\nJava 17+：密封类（sealed class）、模式匹配（Pattern\r\nMatching）\r\n实战案例：用Stream重构集合处理代码，实现并行数据清洗\r\n\r\n\r\nJava进阶部分\r\n\r\n高并发\r\n\r\n并发工具进阶：\r\n\r\nLongAdder vs AtomicLong性能对比\r\nStampedLock乐观锁实现高吞吐量场景\r\n\r\n并发模式：\r\n\r\nFork/Join框架实现分治算法\r\nDisruptor无锁队列在金融交易系统中的应用\r\n\r\n实战案例：设计百万级QPS的抢购系统（库存防超卖）\r\n\r\n分布式\r\n\r\n一致性协议：Raft选举机制、ZAB协议在ZooKeeper中的应用\r\n分布式存储：Ceph对象存储原理、MinIO私有云部署\r\n实战案例：基于Paxos算法实现分布式锁服务\r\n\r\n微服务\r\n\r\nService Mesh：Istio流量管理、链路加密（mTLS）\r\nServerless：Spring Cloud\r\nFunction实现无服务器架构\r\n实战案例：将单体应用改造为Serverless微服务集群\r\n\r\nJVM\r\n内存分析：\r\n\r\nMAT工具分析堆内存泄漏\r\nJProfiler定位CPU热点方法\r\n\r\nGC调优：\r\n\r\nG1回收器Region划分策略\r\n大对象分配优化（-XX:PretenureSizeThreshold）\r\n\r\n\r\n数据库部分\r\n关系型数据库：MySQL PostgreSQL\r\nNoSQL：MongoDB Redis\r\n缓存：\r\n搜索引擎：\r\n\r\nElasticsearch：\r\n\r\nWeb前端部分\r\n\r\n前端基础 HTML/ CSS/ JavaScript AJAX jQuery\r\n有精力可以学一下 TypeScript 很像js\r\n前端框架\r\n\r\nReact：组件化开发、Hooks、状态管理（Redux/Context\r\nAPI）27。\r\nVue.js：Vue 3组合式API、Pinia/Vuex状态管理37。\r\n\r\n工程化工具\r\n\r\nWebpack模块打包、Babel转译、NPM/Yarn依赖管理8。\r\n\r\n前后端协作：\r\n\r\nRESTful API设计\r\n\r\n使用Swagger/OpenAPI生成文档，Postman调试接口8。\r\n\r\nSSR与静态站点\r\n\r\n学习Next.js（React）或Nuxt.js（Vue）实现服务端渲染57。\r\n\r\n\r\n\r\nJavaEE与Web后端部分\r\nJ2EE基础\r\n\r\nServlet\r\nTomcat（Web服务器）\r\nJSP /\r\nNginx\r\n\r\n常用框架\r\n\r\nSpring部分\r\nMyBatis\r\nNetty\r\n工作流\r\n实用工具类库\r\n\r\n高性能和高可用\r\n\r\nCDN\r\n消息队列\r\n负载均衡\r\n\r\nDevOps与云原生\r\n1. 容器化与编排\r\n\r\nDocker：镜像构建、Docker Compose多容器管理28。\r\nKubernetes：Pod部署、Service暴露、Ingress路由管理710。\r\n\r\n2. CI/CD与监控\r\n\r\nJenkins/GitLab\r\nCI：自动化构建、测试与部署流水线810。\r\n云服务：AWS\r\nEC2/S3、阿里云容器服务，实现弹性伸缩与负载均衡28。\r\n\r\n其他内容\r\n构建工具\r\n\r\nMaven\r\nGradle\r\n\r\n版本控制\r\n\r\nGit\r\nGithub\r\n\r\n测试部分\r\nLinux与服务器部分\r\n远程调用\r\n设计模式\r\n\r\n\r\nJava 后端学习路线概览-1\r\n\r\nSpring部分\r\n第一阶段：Spring核心原理与基础框架\r\n1. Spring Framework\r\nCore\r\n\r\n核心目标：理解IoC/DI、AOP设计思想\r\n重点内容：\r\n\r\nIoC容器：Bean生命周期、@Component/@Bean注解、XML配置与JavaConfig对比\r\n依赖注入：@Autowired原理、构造器注入 vs\r\nSetter注入、解决循环依赖\r\nAOP编程：\r\n\r\nJDK动态代理与CGLIB区别\r\n实现日志记录/事务管理（@Around、@Before等切面注解）\r\n\r\nSpring\r\nJDBC：JdbcTemplate使用，对比原生JDBC的优势\r\n\r\n实践项目：实现一个银行转账系统，手动模拟事务管理（不依赖Spring事务注解）\r\n\r\n2. Spring MVC\r\n\r\n核心目标：从Servlet过渡到MVC框架\r\n关键衔接：对比Servlet开发模式 →\r\nDispatcherServlet工作原理\r\n重点内容：\r\n\r\n请求处理流程：HandlerMapping → Controller → ViewResolver\r\n注解驱动开发：@Controller/@RequestMapping/@RequestBody\r\n参数绑定：@RequestParam/@PathVariable/@ModelAttribute\r\n视图技术：Thymeleaf模板引擎集成（替代JSP）\r\n\r\n实践项目：开发博客系统的文章管理模块（CRUD+分页）\r\n\r\n\r\n第二阶段：现代Spring开发范式\r\n3. Spring Boot\r\n\r\n核心目标：掌握自动化配置与生产级应用构建\r\n重点内容：\r\n\r\nStarter机制：分析spring-boot-starter-web的自动配置过程\r\n外部化配置：多环境配置（application-{profile}.yml）、@ConfigurationProperties\r\n嵌入式容器：Tomcat vs Undertow性能对比\r\nActuator：健康检查、Metrics监控端点配置\r\n测试：@SpringBootTest集成测试、MockMVC模拟HTTP请求\r\n\r\n实践项目：改造第一阶段项目为Spring\r\nBoot版本，增加Swagger API文档\r\n\r\n4. Spring Security\r\n\r\n核心目标：构建安全认证体系\r\n学习路径：\r\n\r\n基础认证：内存认证 → JDBC认证 → 自定义UserDetailsService\r\n表单登录 vs JWT认证：实现无状态认证（搭配JJWT库）\r\n权限控制：方法级安全（@PreAuthorize）、ACL权限模型\r\nOAuth2.0：授权码模式实现（整合GitHub登录）\r\n\r\n实践项目：为博客系统增加RBAC权限管理，支持JWT+OAuth2混合认证\r\n\r\n\r\n第三阶段：企业级整合与深度优化\r\n5. 数据持久化整合\r\n\r\nSpring Data JPA：\r\n\r\nRepository动态代理机制\r\n@Query注解实现复杂查询\r\n审计功能（@CreatedDate）\r\n\r\nMyBatis Plus：\r\n\r\n通用Mapper与条件构造器\r\n分页插件原理分析\r\n\r\n多数据源配置：AbstractRoutingDataSource动态切换\r\n性能优化：\r\n\r\n二级缓存整合（Ehcache/Redis）\r\n批处理优化（JdbcTemplate批量插入）\r\n\r\n\r\n6. 响应式编程\r\n\r\nSpring WebFlux：\r\n\r\nReactor编程模型（Flux/Mono）\r\n对比Servlet阻塞模型的性能优势\r\n整合MongoDB Reactive驱动\r\n\r\n\r\n\r\n第四阶段：微服务架构进阶\r\n7. Spring Cloud\r\n\r\n基础组件：\r\n\r\n服务注册发现：Eureka vs Nacos注册中心对比\r\n配置中心：Spring Cloud Config + Bus动态刷新\r\n服务调用：OpenFeign声明式客户端 + Hystrix熔断\r\n\r\n进阶方案：\r\n\r\n网关：Spring Cloud Gateway动态路由配置\r\n链路追踪：Sleuth + Zipkin全链路监控\r\n分布式事务：Seata AT模式实现\r\n\r\n实践项目：拆解博客系统为微服务架构（用户服务/内容服务/评论服务）\r\n\r\n\r\n\r\n必读文档：\r\n\r\nSpring\r\nFramework官方文档\r\nSpring\r\nBoot Reference Guide\r\n\r\n深度书籍：\r\n\r\n《Spring揭秘》（深入理解设计思想）\r\n《Spring Boot编程思想》（核心原理剖析）\r\n\r\n\r\n按照这个路径学习，建议每完成一个阶段就进行知识图谱绘制（如用XMind整理技术点关联），遇到问题优先查阅官方文档，同时结合Github优质开源项目（如spring-petclinic）进行对比学习。\r\n","categories":["Java学习","技术栈路线与知识总结"],"tags":["其他","学习","知识总结","计算机理论知识"]},{"title":"一些分布函数的数字特征的求解过程","url":"/posts/50276.html","content":"前言\r\n在这里主要是进行求一些常见分布的一些数字特性，包括期望，方差等\r\n主要写的是计算过程，这些分布的数字特征是怎么计算来的，我个人喜欢把计算过程写的比较详细，感觉多的大概扫一眼就知道这东西其实都是怎么求的了\r\n两点分布\r\n重复一下分布表示\r\n设随机变量 X 服从参数为\r\np\r\n的两点分布（也称为伯努利分布），其概率质量函数为：\r\nP(X = 1) = p,  P(X = 0) = 1 − p\r\n其中 0 ≤ p ≤ 1。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\nE[X] = ∑xx ⋅ P(X = x) = 0 ⋅ P(X = 0) + 1 ⋅ P(X = 1)\r\n代入概率质量函数：\r\nE[X] = 0 ⋅ (1 − p) + 1 ⋅ p = p\r\n因此，两点分布的期望为：\r\nE[X] = p\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\nD(X) = E[X2] − (E[X])2\r\n计算 E[X2] E[X2] = ∑xx2 ⋅ P(X = x) = 02 ⋅ P(X = 0) + 12 ⋅ P(X = 1)\r\n代入概率质量函数：\r\nE[X2] = 0 ⋅ (1 − p) + 1 ⋅ p = p\r\n将 E[X2] = p\r\n和 E[X] = p\r\n代入方差公式：\r\nD(X) = p − p2 = p(1 − p)\r\n因此，两点分布的方差为：\r\nD(X) = p(1 − p)\r\n标准差\r\n标准差是方差的平方根：\r\n$$\r\n\\sigma_X = \\sqrt{\\text{Var}(X)} = \\sqrt{p(1 - p)}\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\nMX(t) = E[etX] = ∑xetxP(X = x)\r\n代入概率质量函数：\r\nMX(t) = et ⋅ 0P(X = 0) + et ⋅ 1P(X = 1) = (1 − p) + etp\r\n因此，矩生成函数为：\r\nMX(t) = 1 − p + pet\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\nϕX(t) = E[eitX] = ∑xeitxP(X = x)\r\n代入概率质量函数：\r\nϕX(t) = eit ⋅ 0P(X = 0) + eit ⋅ 1P(X = 1) = (1 − p) + eitp\r\n因此，特征函数为：\r\nϕX(t) = 1 − p + peit\r\n总结\r\n对于两点分布 X ∼ Bernoulli(p)，其数字特征为：\r\n\r\n期望：E[X] = p\r\n方差：D(X) = p(1 − p)\r\n标准差：$\\sigma_X = \\sqrt{p(1 -\r\np)}$\r\n矩生成函数：MX(t) = 1 − p + pet\r\n特征函数：ϕX(t) = 1 − p + peit\r\n\r\n二项分布\r\n重复一下分布表示\r\n设随机变量 X 服从参数为\r\nn 和 p 的二项分布，记作 X ∼ Binomial(n, p)，其概率质量函数为：\r\n$$\r\nP(X = k) = \\binom{n}{k} p^k (1 - p)^{n - k}, \\quad k = 0, 1, \\dots, n\r\n$$\r\n其中 0 ≤ p ≤ 1，n 为正整数。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\n$$\r\nE[X] = \\sum_{k=0}^n k \\cdot P(X = k) = \\sum_{k=0}^n k \\binom{n}{k} p^k\r\n(1 - p)^{n - k}\r\n$$\r\n利用组合恒等式 $k \\binom{n}{k} = n \\binom{n\r\n- 1}{k - 1}$（k ≥ 1），重新表示求和：\r\n$$\r\nE[X] = \\sum_{k=1}^n n \\binom{n - 1}{k - 1} p^k (1 - p)^{n - k}\r\n$$\r\n提取 np，并令\r\nj = k − 1：\r\n$$\r\nE[X] = n p \\sum_{j=0}^{n - 1} \\binom{n - 1}{j} p^j (1 - p)^{n - 1 - j}\r\n$$\r\n求和部分是二项式展开 (p + (1 − p))n − 1 = 1，因此：\r\nE[X] = np\r\n因此，二项分布的期望为：\r\nE[X] = np\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\nD(X) = E[X2] − (E[X])2\r\n计算 E[X2]\r\n首先计算 E[X(X − 1)]：\r\n$$\r\nE[X(X - 1)] = \\sum_{k=0}^n k (k - 1) \\binom{n}{k} p^k (1 - p)^{n - k}\r\n$$\r\n对于 k ≥ 2，利用恒等式\r\n$k (k - 1) \\binom{n}{k} = n (n - 1) \\binom{n -\r\n2}{k - 2}$：\r\n$$\r\nE[X(X - 1)] = \\sum_{k=2}^n n (n - 1) \\binom{n - 2}{k - 2} p^k (1 - p)^{n\r\n- k}\r\n$$\r\n提取 n(n − 1)p2，并令\r\nj = k − 2：\r\n$$\r\nE[X(X - 1)] = n (n - 1) p^2 \\sum_{j=0}^{n - 2} \\binom{n - 2}{j} p^j (1 -\r\np)^{n - 2 - j}\r\n$$\r\n求和部分是二项式展开 (p + (1 − p))n − 2 = 1，因此：\r\nE[X(X − 1)] = n(n − 1)p2\r\n注意到 E[X2] = E[X(X − 1)] + E[X]，因此：\r\nE[X2] = n(n − 1)p2 + np\r\n将 E[X2] 和 E[X] = np\r\n代入方差公式：\r\nD(X) = n(n − 1)p2 + np − (np)2 = np(1 − p)\r\n因此，二项分布的方差为：\r\nD(X) = np(1 − p)\r\n标准差\r\n标准差是方差的平方根：\r\n$$\r\n\\sigma_X = \\sqrt{D(X)} = \\sqrt{n p (1 - p)}\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\n$$\r\nM_X(t) = E[e^{tX}] = \\sum_{k=0}^n e^{t k} \\binom{n}{k} p^k (1 - p)^{n -\r\nk}\r\n$$\r\n将 etkpk\r\n合并：\r\n$$\r\nM_X(t) = \\sum_{k=0}^n \\binom{n}{k} (p e^t)^k (1 - p)^{n - k}\r\n$$\r\n根据二项式定理，求和结果为：\r\nMX(t) = (1 − p + pet)n\r\n因此，矩生成函数为：\r\nMX(t) = (1 − p + pet)n\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\n$$\r\n\\phi_X(t) = E[e^{i t X}] = \\sum_{k=0}^n e^{i t k} \\binom{n}{k} p^k (1 -\r\np)^{n - k}\r\n$$\r\n类似矩生成函数的推导：\r\n$$\r\n\\phi_X(t) = \\sum_{k=0}^n \\binom{n}{k} (p e^{i t})^k (1 - p)^{n - k} =\r\n\\left(1 - p + p e^{i t}\\right)^n\r\n$$\r\n因此，特征函数为：\r\nϕX(t) = (1 − p + peit)n\r\n总结\r\n对于二项分布 X ∼ Binomial(n, p)，其数字特征为：\r\n\r\n期望：E[X] = np\r\n方差：D(X) = np(1 − p)\r\n标准差：$\\sigma_X = \\sqrt{n p (1 -\r\np)}$\r\n矩生成函数：MX(t) = (1 − p + pet)n\r\n特征函数：ϕX(t) = (1 − p + peit)n\r\n\r\n泊松分布\r\n重复一下分布表示\r\n设随机变量 X 服从参数为\r\nλ 的泊松分布，记作 X ∼ Poisson(λ)，其概率质量函数为：\r\n$$\r\nP(X = k) = \\frac{e^{-\\lambda} \\lambda^k}{k!}, \\quad k = 0, 1, 2, \\dots\r\n$$\r\n其中 λ &gt; 0。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\n$$\r\nE[X] = \\sum_{k=0}^\\infty k \\cdot \\frac{e^{-\\lambda} \\lambda^k}{k!}\r\n$$\r\n计算期望 $ E[X] :$ E[X] =\r\n{k=0}^k P(X=k) = {k=0}^k $$\r\n当 $ k=0$ 时，首项为 0：\r\n$$ 0 = 0 $$\r\n因此求和下限从 $ k=1 $ 开始：\r\n$$ E[X] = _{k=1}^k $$\r\n化简 $ :$ = $$\r\n代入原式得： $$\r\nE[X] = e^{-\\lambda} \\sum_{k=1}^\\infty \\frac{\\lambda^k}{(k-1)!}\r\n$$ 其中令 j = k − 1，并利用 eλ\r\n的泰勒展开，\r\n变量替换 $ j = k-1 $：\r\n当 $ k=1 $ 时，$ j=0 $；当 $ k $ 时，$ j $。\r\n同时，$ k = j+1 ，代入得：$ E[X] =\r\ne^{-} {j=0}^ = e^{-} {j=0}^ $$ 之后利用指数函数的泰勒展开：\r\n已知指数函数的泰勒级数为： $$\r\ne^x = \\sum_{j=0}^\\infty \\frac{x^j}{j!}\r\n$$ 令 $ x = ，则：$\r\n_{j=0}^ = e^ 代入并化简：\r\nE[X] = e^{-} e^= e^{-+ } = = $$ 因此，泊松分布的期望为：\r\nE[X] = λ\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\nD(X) = E[X2] − (E[X])2\r\n计算 E[X2]\r\n通过 E[X(X − 1)]\r\n计算：\r\n$$\r\nE[X(X-1)] = \\sum_{k=0}^\\infty k(k-1) \\frac{e^{-\\lambda} \\lambda^k}{k!} =\r\ne^{-\\lambda} \\lambda^2 \\sum_{k=2}^\\infty \\frac{\\lambda^{k-2}}{(k-2)!} =\r\n\\lambda^2\r\n$$\r\n因此：\r\nE[X2] = E[X(X − 1)] + E[X] = λ2 + λ\r\n那么方差 D(X) = (λ2 + λ) − λ2 = λ\r\n因此，泊松分布的方差为：\r\nD(X) = λ\r\n标准差\r\n标准差是方差的平方根：\r\n$$\r\n\\sigma_X = \\sqrt{D(X)} = \\sqrt{\\lambda}\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\n$$\r\nM_X(t) = E[e^{tX}] = \\sum_{k=0}^\\infty e^{tk} \\frac{e^{-\\lambda}\r\n\\lambda^k}{k!} = e^{-\\lambda} \\sum_{k=0}^\\infty \\frac{(\\lambda\r\ne^t)^k}{k!}\r\n$$\r\n根据指数函数的泰勒展开：\r\nMX(t) = e−λeλet = eλ(et − 1)\r\n因此，矩生成函数为：\r\nMX(t) = eλ(et − 1)\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\n$$\r\n\\phi_X(t) = E[e^{itX}] = \\sum_{k=0}^\\infty e^{itk} \\frac{e^{-\\lambda}\r\n\\lambda^k}{k!} = e^{-\\lambda} \\sum_{k=0}^\\infty \\frac{(\\lambda\r\ne^{it})^k}{k!}\r\n$$\r\n同样利用指数函数的展开：\r\nϕX(t) = e−λeλeit = eλ(eit − 1)\r\n因此，特征函数为：\r\nϕX(t) = eλ(eit − 1)\r\n总结\r\n对于泊松分布 X ∼ Poisson(λ)，其数字特征为：\r\n\r\n期望：E[X] = λ\r\n方差：D(X) = λ\r\n标准差：$\\sigma_X =\r\n\\sqrt{\\lambda}$\r\n矩生成函数：MX(t) = eλ(et − 1)\r\n特征函数：ϕX(t) = eλ(eit − 1)\r\n\r\n均匀分布\r\n重复一下分布表示\r\n上面都是离散的，这次是连续的\r\n设随机变量 X 服从区间 [a, b] 上的均匀分布，记作\r\nX ∼ U(a, b)，其概率密度函数为：\r\n$$\r\nf(x) = \\begin{cases}\r\n\\frac{1}{b-a}, &amp; a \\leq x \\leq b \\\\\r\n0, &amp; \\text{其他}\r\n\\end{cases}\r\n$$\r\n其中 −∞ &lt; a &lt; b &lt; ∞。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\n$$\r\nE[X] = \\int_{-\\infty}^{\\infty} x f(x) dx = \\int_a^b x \\cdot\r\n\\frac{1}{b-a} dx\r\n$$\r\n计算积分：\r\n$$\r\nE[X] = \\frac{1}{b-a} \\int_a^b x dx = \\frac{1}{b-a} \\left[ \\frac{x^2}{2}\r\n\\right]_a^b = \\frac{b^2 - a^2}{2(b-a)} = \\frac{a + b}{2}\r\n$$\r\n因此，均匀分布的期望为：\r\n$$\r\nE[X] = \\frac{a + b}{2}\r\n$$\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\nD(X) = E[X2] − (E[X])2\r\n计算 E[X2] $$\r\nE[X^2] = \\int_{-\\infty}^{\\infty} x^2 f(x) dx = \\int_a^b x^2 \\cdot\r\n\\frac{1}{b-a} dx\r\n$$\r\n计算积分：\r\n$$\r\nE[X^2] = \\frac{1}{b-a} \\int_a^b x^2 dx = \\frac{1}{b-a} \\left[\r\n\\frac{x^3}{3} \\right]_a^b = \\frac{b^3 - a^3}{3(b-a)}\r\n$$\r\n因式分解分子：\r\nb3 − a3 = (b − a)(b2 + ab + a2)\r\n因此：\r\n$$\r\nE[X^2] = \\frac{b^2 + ab + a^2}{3}\r\n$$\r\n将 E[X2] 和 $E[X] = \\frac{a+b}{2}$ 代入：\r\n$$\r\nD(X) = \\frac{b^2 + ab + a^2}{3} - \\left( \\frac{a+b}{2} \\right)^2 =\r\n\\frac{4(b^2 + ab + a^2) - 3(a^2 + 2ab + b^2)}{12} = \\frac{(b-a)^2}{12}\r\n$$\r\n因此，均匀分布的方差为：\r\n$$\r\nD(X) = \\frac{(b - a)^2}{12}\r\n$$\r\n标准差\r\n标准差是方差的平方根：\r\n$$\r\n\\sigma_X = \\sqrt{D(X)} = \\frac{b - a}{2\\sqrt{3}}\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\n$$\r\nM_X(t) = E[e^{tX}] = \\int_a^b e^{tx} \\cdot \\frac{1}{b-a} dx\r\n$$\r\n计算积分（当 t ≠ 0\r\n时）：\r\n$$\r\nM_X(t) = \\frac{1}{b-a} \\left[ \\frac{e^{tx}}{t} \\right]_a^b =\r\n\\frac{e^{tb} - e^{ta}}{t(b-a)}\r\n$$\r\n当 t = 0 时：\r\nMX(0) = E[e0] = 1\r\n因此，矩生成函数为：\r\n$$\r\nM_X(t) = \\begin{cases}\r\n\\frac{e^{tb} - e^{ta}}{t(b-a)}, &amp; t \\neq 0 \\\\\r\n1, &amp; t = 0\r\n\\end{cases}\r\n$$\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\n$$\r\n\\phi_X(t) = E[e^{itX}] = \\int_a^b e^{itx} \\cdot \\frac{1}{b-a} dx\r\n$$\r\n计算积分：\r\n$$\r\n\\phi_X(t) = \\frac{1}{b-a} \\left[ \\frac{e^{itx}}{it} \\right]_a^b =\r\n\\frac{e^{itb} - e^{ita}}{it(b-a)}\r\n$$\r\n因此，特征函数为：\r\n$$\r\n\\phi_X(t) = \\frac{e^{itb} - e^{ita}}{it(b-a)}\r\n$$\r\n总结\r\n对于均匀分布 X ∼ U(a, b)，其数字特征为：\r\n\r\n期望：$E[X] = \\frac{a + b}{2}$\r\n方差：$D(X) = \\frac{(b -\r\na)^2}{12}$\r\n标准差：$\\sigma_X = \\frac{b -\r\na}{2\\sqrt{3}}$\r\n矩生成函数： $$\r\nM_X(t) = \\begin{cases}\r\n\\frac{e^{tb} - e^{ta}}{t(b-a)}, &amp; t \\neq 0 \\\\\r\n1, &amp; t = 0\r\n\\end{cases}\r\n$$\r\n特征函数：$\\phi_X(t) = \\frac{e^{itb} -\r\ne^{ita}}{it(b-a)}$\r\n\r\n指数分布的数字特征\r\n重复一下分布表示\r\n设随机变量 X 服从参数为\r\nλ 的指数分布，记作 X ∼ Exp(λ)，其概率密度函数为：\r\n$$\r\nf(x) = \\begin{cases}\r\n\\lambda e^{-\\lambda x}, &amp; x \\geq 0 \\\\\r\n0, &amp; x &lt; 0\r\n\\end{cases}\r\n$$\r\n其中 λ &gt; 0。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\nE[X] = ∫−∞∞xf(x)dx = ∫0∞xλe−λxdx\r\n使用分部积分法计算： 设 u = x，dv = λe−λxdx，则\r\ndu = dx，v = −e−λx\r\n$$\r\nE[X] = \\left[ -x e^{-\\lambda x} \\right]_0^{\\infty} + \\int_0^{\\infty}\r\ne^{-\\lambda x} dx = 0 + \\left[ -\\frac{1}{\\lambda} e^{-\\lambda x}\r\n\\right]_0^{\\infty} = \\frac{1}{\\lambda}\r\n$$\r\n因此，指数分布的期望为：\r\n$$\r\nE[X] = \\frac{1}{\\lambda}\r\n$$\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\nD(X) = E[X2] − (E[X])2\r\n计算 E[X2] E[X2] = ∫0∞x2λe−λxdx\r\n使用分部积分法： 设 u = x2，dv = λe−λxdx，则\r\ndu = 2xdx，v = −e−λx\r\n$$\r\nE[X^2] = \\left[ -x^2 e^{-\\lambda x} \\right]_0^{\\infty} +\r\n2\\int_0^{\\infty} x e^{-\\lambda x} dx = 0 + \\frac{2}{\\lambda} E[X] =\r\n\\frac{2}{\\lambda^2}\r\n$$\r\n计算方差 $$\r\nD(X) = \\frac{2}{\\lambda^2} - \\left( \\frac{1}{\\lambda} \\right)^2 =\r\n\\frac{1}{\\lambda^2}\r\n$$\r\n因此，指数分布的方差为：\r\n$$\r\nD(X) = \\frac{1}{\\lambda^2}\r\n$$\r\n标准差\r\n标准差是方差的平方根：\r\n$$\r\n\\sigma_X = \\sqrt{D(X)} = \\frac{1}{\\lambda}\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\nMX(t) = E[etX] = ∫0∞etxλe−λxdx = λ∫0∞e−(λ − t)xdx\r\n当 t &lt; λ\r\n时积分收敛：\r\n$$\r\nM_X(t) = \\lambda \\left[ \\frac{e^{-(\\lambda - t)x}}{-(\\lambda - t)}\r\n\\right]_0^{\\infty} = \\frac{\\lambda}{\\lambda - t}\r\n$$\r\n因此，矩生成函数为：\r\n$$\r\nM_X(t) = \\frac{\\lambda}{\\lambda - t}, \\quad t &lt; \\lambda\r\n$$\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\nϕX(t) = E[eitX] = ∫0∞eitxλe−λxdx = λ∫0∞e−(λ − it)xdx\r\n计算积分：\r\n$$\r\n\\phi_X(t) = \\lambda \\left[ \\frac{e^{-(\\lambda - it)x}}{-(\\lambda - it)}\r\n\\right]_0^{\\infty} = \\frac{\\lambda}{\\lambda - it}\r\n$$\r\n因此，特征函数为：\r\n$$\r\n\\phi_X(t) = \\frac{\\lambda}{\\lambda - it}\r\n$$\r\n总结\r\n对于指数分布 X ∼ Exp(λ)，其数字特征为：\r\n\r\n期望：$E[X] =\r\n\\frac{1}{\\lambda}$\r\n方差：$D(X) =\r\n\\frac{1}{\\lambda^2}$\r\n标准差：$\\sigma_X =\r\n\\frac{1}{\\lambda}$\r\n矩生成函数：$M_X(t) =\r\n\\frac{\\lambda}{\\lambda - t}, \\quad t &lt; \\lambda$\r\n特征函数：$\\phi_X(t) =\r\n\\frac{\\lambda}{\\lambda - it}$\r\n\r\n正态分布\r\n重复一下分布形式\r\n设随机变量 X 服从参数为\r\nμ 和 σ2 的正态分布，记作 X ∼ N(μ, σ2)，其概率密度函数为：\r\n$$\r\nf(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},\r\n\\quad -\\infty &lt; x &lt; \\infty\r\n$$\r\n其中 μ ∈ ℝ，σ &gt; 0。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\n$$\r\nE[X] = \\int_{-\\infty}^{\\infty} x f(x) dx = \\frac{1}{\\sqrt{2\\pi}\\sigma}\r\n\\int_{-\\infty}^{\\infty} x e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} dx\r\n$$\r\n作变量替换 $z =\r\n\\frac{x-\\mu}{\\sigma}$，则 x = μ + σz，dx = σdz：\r\n$$\r\nE[X] = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} (\\mu + \\sigma z)\r\ne^{-\\frac{z^2}{2}} dz\r\n$$\r\n拆分为两个积分：\r\n$$\r\nE[X] = \\mu \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty}\r\ne^{-\\frac{z^2}{2}} dz + \\frac{\\sigma}{\\sqrt{2\\pi}}\r\n\\int_{-\\infty}^{\\infty} z e^{-\\frac{z^2}{2}} dz\r\n$$\r\n第一个积分等于1（标准正态分布的全概率），第二个积分是奇函数在对称区间积分为0：\r\n$$\r\nE[X] = \\mu \\cdot 1 + \\frac{\\sigma}{\\sqrt{2\\pi}} \\cdot 0 = \\mu\r\n$$\r\n因此，正态分布的期望为：\r\nE[X] = μ\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\n$$\r\nD(X) = E[(X-\\mu)^2] = \\frac{1}{\\sqrt{2\\pi}\\sigma}\r\n\\int_{-\\infty}^{\\infty} (x-\\mu)^2 e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} dx\r\n$$\r\n同样作变量替换 $z =\r\n\\frac{x-\\mu}{\\sigma}$：\r\n$$\r\nD(X) = \\frac{\\sigma^2}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} z^2\r\ne^{-\\frac{z^2}{2}} dz\r\n$$\r\n利用分部积分法，设 u = z，$dv = z e^{-\\frac{z^2}{2}}dz$，则 du = dz，$v = -e^{-\\frac{z^2}{2}}$：\r\n$$\r\n\\int z^2 e^{-\\frac{z^2}{2}} dz = -z e^{-\\frac{z^2}{2}}\r\n\\Big|_{-\\infty}^{\\infty} + \\int e^{-\\frac{z^2}{2}} dz = \\sqrt{2\\pi}\r\n$$\r\n因此：\r\n$$\r\nD(X) = \\frac{\\sigma^2}{\\sqrt{2\\pi}} \\cdot \\sqrt{2\\pi} = \\sigma^2\r\n$$\r\n因此，正态分布的方差为：\r\nD(X) = σ2\r\n标准差\r\n标准差是方差的平方根：\r\n$$\r\n\\sigma_X = \\sqrt{D(X)} = \\sigma\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\n$$\r\nM_X(t) = E[e^{tX}] = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty}\r\ne^{tx} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} dx\r\n$$\r\n合并指数项并配方：\r\n$$\r\ntx - \\frac{(x-\\mu)^2}{2\\sigma^2} = -\\frac{x^2 - 2\\mu x + \\mu^2 -\r\n2\\sigma^2 t x}{2\\sigma^2}\r\n= -\\frac{x^2 - 2(\\mu + \\sigma^2 t)x + \\mu^2}{2\\sigma^2}\r\n$$\r\n配方得：\r\n$$\r\n= -\\frac{[x - (\\mu + \\sigma^2 t)]^2 - (\\mu + \\sigma^2 t)^2 +\r\n\\mu^2}{2\\sigma^2}\r\n= -\\frac{[x - (\\mu + \\sigma^2 t)]^2}{2\\sigma^2} + \\mu t + \\frac{\\sigma^2\r\nt^2}{2}\r\n$$\r\n因此：\r\n$$\r\nM_X(t) = e^{\\mu t + \\frac{\\sigma^2 t^2}{2}} \\cdot\r\n\\frac{1}{\\sqrt{2\\pi}\\sigma} \\int_{-\\infty}^{\\infty} e^{-\\frac{[x - (\\mu\r\n+ \\sigma^2 t)]^2}{2\\sigma^2}} dx = e^{\\mu t + \\frac{\\sigma^2 t^2}{2}}\r\n$$\r\n因此，矩生成函数为：\r\n$$\r\nM_X(t) = e^{\\mu t + \\frac{\\sigma^2 t^2}{2}}\r\n$$\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\n$$\r\n\\phi_X(t) = E[e^{itX}] = M_X(it) = e^{\\mu it + \\frac{\\sigma^2\r\n(it)^2}{2}} = e^{i\\mu t - \\frac{\\sigma^2 t^2}{2}}\r\n$$\r\n因此，特征函数为：\r\n$$\r\n\\phi_X(t) = e^{i\\mu t - \\frac{\\sigma^2 t^2}{2}}\r\n$$\r\n总结\r\n对于正态分布 X ∼ N(μ, σ2)，其数字特征为：\r\n\r\n期望：E[X] = μ\r\n方差：D(X) = σ2\r\n标准差：σX = σ\r\n矩生成函数：$M_X(t) = e^{\\mu t +\r\n\\frac{\\sigma^2 t^2}{2}}$\r\n特征函数：$\\phi_X(t) = e^{i\\mu t -\r\n\\frac{\\sigma^2 t^2}{2}}$\r\n\r\nχ2分布\r\n重复一下分布形式\r\n设 Z1, Z2, …, Zn\r\n是独立同分布的标准正态随机变量（即 Zi ∼ N(0, 1)），则随机变量：\r\n$$\r\n\\chi^2 = \\sum_{i=1}^n Z_i^2\r\n$$ 服从自由度为 n\r\n的卡方分布，记作 X ∼ χ2(n)。\r\n对于 x &gt; 0，其概率密度函数为： $$\r\nf(x;n) = \\frac{1}{2^{n/2}\\Gamma(n/2)} x^{n/2-1} e^{-x/2}\r\n$$ 其中 Γ(⋅)\r\n是Gamma函数，满足： - Γ(k) = (k − 1)! 当\r\nk 为正整数 - $\\Gamma(1/2) = \\sqrt{\\pi}$\r\n数学期望\r\n推导过程： $$\r\n\\begin{aligned}\r\nE[X] &amp;= E\\left[\\sum_{i=1}^n Z_i^2\\right] \\\\\r\n&amp;= \\sum_{i=1}^n E[Z_i^2] \\quad \\text{(线性性质)} \\\\\r\n&amp;= n \\cdot E[Z_1^2] \\quad \\text{(同分布)} \\\\\r\n&amp;= n \\cdot \\left(\\text{Var}(Z_1) + (E[Z_1])^2\\right) \\\\\r\n&amp;= n \\cdot (1 + 0) = n\r\n\\end{aligned}\r\n$$\r\n方差\r\n推导过程： 先计算 E[X2]： $$\r\n\\begin{aligned}\r\nE[X^2] &amp;= E\\left[\\left(\\sum_{i=1}^n Z_i^2\\right)^2\\right] \\\\\r\n&amp;= E\\left[\\sum_{i=1}^n Z_i^4 + 2\\sum_{i&lt;j} Z_i^2 Z_j^2\\right] \\\\\r\n&amp;= n E[Z_1^4] + 2\\binom{n}{2} E[Z_1^2]E[Z_2^2] \\quad \\text{(独立性)}\r\n\\end{aligned}\r\n$$\r\n计算 E[Z14]（标准正态的四阶矩）：\r\n通过特征函数或直接积分： $$\r\nE[Z^4] = \\int_{-\\infty}^\\infty z^4 \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz =\r\n3\r\n$$\r\n因此： $$\r\n\\begin{aligned}\r\nE[X^2] &amp;= n \\cdot 3 + n(n-1) \\cdot 1 \\cdot 1 \\\\\r\n&amp;= 3n + n^2 - n = n^2 + 2n\r\n\\end{aligned}\r\n$$\r\n最终方差： D(X) = E[X2] − (E[X])2 = (n2 + 2n) − n2 = 2n\r\n矩母函数 (MGF)\r\n矩母函数定义为 MX(t) = E[etX]：\r\n$$\r\n\\begin{aligned}\r\nM_X(t) &amp;= E\\left[\\exp\\left(t \\sum_{i=1}^n Z_i^2\\right)\\right] \\\\\r\n&amp;= \\prod_{i=1}^n E\\left[e^{t Z_i^2}\\right] \\quad \\text{(独立性)} \\\\\r\n&amp;= \\left(E[e^{t Z_1^2}]\\right)^n \\quad \\text{(同分布)}\r\n\\end{aligned}\r\n$$\r\n计算单个 E[etZ2]（t &lt; 1/2）： $$\r\n\\begin{aligned}\r\nE[e^{t Z^2}] &amp;= \\int_{-\\infty}^\\infty e^{t z^2}\r\n\\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz \\\\\r\n&amp;= \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^\\infty e^{-(1/2 - t)z^2} dz\r\n\\\\\r\n&amp;= (1 - 2t)^{-1/2} \\quad \\text{(高斯积分)}\r\n\\end{aligned}\r\n$$\r\n因此： $$\r\nM_X(t) = (1 - 2t)^{-n/2}, \\quad t &lt; \\frac{1}{2}\r\n$$\r\n总结\r\n对于 X ∼ χ2(n)，数字特征为\r\n\r\n期望：n\r\n方差：2n\r\nMGF：MX(t) = (1 − 2t)−n/2\r\n\r\nt分布\r\n重复一下分布形式\r\n设 Z ∼ N(0, 1) 和\r\nV ∼ χ2(n)\r\n相互独立，则随机变量： $$\r\nT = \\frac{Z}{\\sqrt{V/n}}\r\n$$ 服从自由度为 n\r\n的t分布，记作 T ∼ t(n)。\r\n对于 −∞ &lt; t &lt; ∞，其概率密度函数为：\r\n$$\r\nf(t;n) =\r\n\\frac{\\Gamma\\left(\\frac{n+1}{2}\\right)}{\\sqrt{n\\pi}\\Gamma\\left(\\frac{n}{2}\\right)}\r\n\\left(1 + \\frac{t^2}{n}\\right)^{-(n+1)/2}\r\n$$\r\n期望计算\r\n当 n &gt; 1\r\n时： E[T] = 0\r\n推导过程： $$\r\n\\begin{aligned}\r\nE[T] &amp;= E\\left[\\frac{Z}{\\sqrt{V/n}}\\right] \\\\\r\n&amp;= E[Z] \\cdot E\\left[\\frac{1}{\\sqrt{V/n}}\\right] \\quad\r\n\\text{(独立性)} \\\\\r\n&amp;= 0 \\cdot E\\left[\\frac{1}{\\sqrt{V/n}}\\right] = 0\r\n\\end{aligned}\r\n$$ 注：当 n = 1\r\n时（柯西分布），期望不存在\r\n方差计算\r\n当 n &gt; 2\r\n时： $$\r\n\\text{Var}(T) = \\frac{n}{n-2}\r\n$$\r\n推导过程： 先计算 E[T2]： $$\r\n\\begin{aligned}\r\nE[T^2] &amp;= E\\left[\\frac{Z^2}{V/n}\\right] \\\\\r\n&amp;= n E[Z^2] E\\left[\\frac{1}{V}\\right] \\quad \\text{(独立性)} \\\\\r\n&amp;= n \\cdot 1 \\cdot E\\left[\\frac{1}{V}\\right]\r\n\\end{aligned}\r\n$$\r\n计算 E[1/V]，其中\r\nV ∼ χ2(n)：\r\n$$\r\n\\begin{aligned}\r\nE\\left[\\frac{1}{V}\\right] &amp;= \\int_0^\\infty \\frac{1}{v}\r\n\\frac{v^{n/2-1}e^{-v/2}}{2^{n/2}\\Gamma(n/2)} dv \\\\\r\n&amp;= \\frac{1}{2^{n/2}\\Gamma(n/2)} \\int_0^\\infty v^{n/2-2} e^{-v/2} dv\r\n\\\\\r\n&amp;= \\frac{\\Gamma(n/2-1)}{2\\Gamma(n/2)} \\cdot 2^{n/2-1} \\quad\r\n\\text{(令 $u=v/2$)} \\\\\r\n&amp;= \\frac{1}{2(n/2 - 1)} = \\frac{1}{n-2}\r\n\\end{aligned}\r\n$$\r\n因此： $$\r\n\\text{Var}(T) = E[T^2] - (E[T])^2 = \\frac{n}{n-2} - 0 = \\frac{n}{n-2}\r\n$$\r\n注：当 n ≤ 2\r\n时方差不存在\r\n高阶矩\r\n当 k &lt; n 时，k阶矩存在：\r\n\r\n奇数阶矩为0（对称性）\r\n偶数阶矩： $$\r\nE[T^{2m}] = n^m\r\n\\frac{\\Gamma(m+1/2)\\Gamma((n-2m)/2)}{\\sqrt{\\pi}\\Gamma(n/2)}, \\quad 2m\r\n&lt; n\r\n$$\r\n\r\n特例（峰度）： 当 n &gt; 4 时： $$\r\n\\text{Kurtosis} = \\frac{6}{n-4}\r\n$$\r\nΓ分布\r\n重复一下分布形式\r\n设随机变量 X 服从形状参数为\r\nα、尺度参数为 β 的Gamma分布，记作 X ∼ Gamma(α, β)，其概率密度函数为：\r\n$$\r\nf(x) = \\begin{cases}\r\n\\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{\\alpha-1} e^{-\\beta x}, &amp; x\r\n&gt; 0 \\\\\r\n0, &amp; x \\leq 0\r\n\\end{cases}\r\n$$\r\n其中 α &gt; 0，β &gt; 0，Γ(α) 是Gamma函数。\r\n期望（数学期望）\r\n期望 E[X]\r\n的计算公式为：\r\n$$\r\nE[X] = \\int_{0}^{\\infty} x f(x) dx = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)}\r\n\\int_{0}^{\\infty} x^{\\alpha} e^{-\\beta x} dx\r\n$$\r\n利用Gamma函数的定义 Γ(α + 1) = αΓ(α)\r\n和积分性质：\r\n$$\r\n\\int_{0}^{\\infty} x^{\\alpha} e^{-\\beta x} dx =\r\n\\frac{\\Gamma(\\alpha+1)}{\\beta^{\\alpha+1}} = \\frac{\\alpha\r\n\\Gamma(\\alpha)}{\\beta^{\\alpha+1}}\r\n$$\r\n因此：\r\n$$\r\nE[X] = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\cdot \\frac{\\alpha\r\n\\Gamma(\\alpha)}{\\beta^{\\alpha+1}} = \\frac{\\alpha}{\\beta}\r\n$$\r\n方差\r\n方差 D(X)\r\n的计算公式为：\r\nD(X) = E[X2] − (E[X])2\r\n计算 E[X2] $$\r\nE[X^2] = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\int_{0}^{\\infty}\r\nx^{\\alpha+1} e^{-\\beta x} dx\r\n$$\r\n利用Gamma函数性质：\r\n$$\r\n\\int_{0}^{\\infty} x^{\\alpha+1} e^{-\\beta x} dx =\r\n\\frac{\\Gamma(\\alpha+2)}{\\beta^{\\alpha+2}} = \\frac{(\\alpha+1)\\alpha\r\n\\Gamma(\\alpha)}{\\beta^{\\alpha+2}}\r\n$$\r\n因此：\r\n$$\r\nE[X^2] = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\cdot\r\n\\frac{(\\alpha+1)\\alpha \\Gamma(\\alpha)}{\\beta^{\\alpha+2}} =\r\n\\frac{\\alpha(\\alpha+1)}{\\beta^2}\r\n$$\r\n计算方差 $$\r\nD(X) = \\frac{\\alpha(\\alpha+1)}{\\beta^2} - \\left( \\frac{\\alpha}{\\beta}\r\n\\right)^2 = \\frac{\\alpha}{\\beta^2}\r\n$$\r\n矩生成函数（MGF）\r\n矩生成函数 MX(t)\r\n的定义为：\r\n$$\r\nM_X(t) = E[e^{tX}] = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)}\r\n\\int_{0}^{\\infty} x^{\\alpha-1} e^{-(\\beta-t)x} dx\r\n$$\r\n当 t &lt; β\r\n时积分收敛：\r\n$$\r\nM_X(t) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} \\cdot\r\n\\frac{\\Gamma(\\alpha)}{(\\beta-t)^\\alpha} = \\left( \\frac{\\beta}{\\beta-t}\r\n\\right)^\\alpha\r\n$$\r\n特征函数\r\n特征函数 ϕX(t)\r\n的定义为：\r\n$$\r\n\\phi_X(t) = E[e^{itX}] = M_X(it) = \\left( \\frac{\\beta}{\\beta-it}\r\n\\right)^\\alpha\r\n$$\r\n总结\r\n对于Gamma分布 X ∼ Gamma(α, β)，其数字特征为：\r\n\r\n期望：$E[X] =\r\n\\frac{\\alpha}{\\beta}$\r\n方差：$D(X) =\r\n\\frac{\\alpha}{\\beta^2}$\r\n矩生成函数：$M_X(t) = \\left(\r\n\\frac{\\beta}{\\beta-t} \\right)^\\alpha, \\quad t &lt; \\beta$\r\n特征函数：$\\phi_X(t) = \\left(\r\n\\frac{\\beta}{\\beta-it} \\right)^\\alpha$\r\n\r\nF 分布\r\n重复一下分布形式\r\n设 U ∼ χ2(d1)\r\n和 V ∼ χ2(d2)\r\n相互独立，则随机变量： $$\r\nF = \\frac{U/d_1}{V/d_2}\r\n$$ 服从自由度为 (d1, d2)\r\n的F分布，记作 F ∼ F(d1, d2)。\r\n对于 x &gt; 0，其概率密度函数为： $$\r\nf(x;d_1,d_2) =\r\n\\frac{\\Gamma\\left(\\frac{d_1+d_2}{2}\\right)}{\\Gamma\\left(\\frac{d_1}{2}\\right)\\Gamma\\left(\\frac{d_2}{2}\\right)}\r\n\\left(\\frac{d_1}{d_2}\\right)^{d_1/2} \\frac{x^{d_1/2-1}}{\\left(1 +\r\n\\frac{d_1}{d_2}x\\right)^{(d_1+d_2)/2}}\r\n$$\r\n1. 与t分布的关系\r\n若 T ∼ t(n)，则：\r\nT2 ∼ F(1, n)\r\n证明： 设 $T =\r\nZ/\\sqrt{V/n}$，则： $$\r\nT^2 = \\frac{Z^2/1}{V/n} \\sim F(1,n)\r\n$$ 因为 Z2 ∼ χ2(1)。\r\n倒数分布\r\n若 F ∼ F(d1, d2)，则：\r\n$$\r\n\\frac{1}{F} \\sim F(d_2,d_1)\r\n$$\r\n与t分布的关系\r\n若 T ∼ t(n)，则：\r\nT2 ∼ F(1, n)\r\n证明： 设 $T =\r\nZ/\\sqrt{V/n}$，则： $$\r\nT^2 = \\frac{Z^2/1}{V/n} \\sim F(1,n)\r\n$$ 因为 Z2 ∼ χ2(1)。\r\n期望计算\r\n当 d2 &gt; 2 时：\r\n$$\r\nE[F] = \\frac{d_2}{d_2 - 2}\r\n$$\r\n推导过程： $$\r\n\\begin{aligned}\r\nE[F] &amp;= E\\left[\\frac{U/d_1}{V/d_2}\\right] \\\\\r\n&amp;= \\frac{d_2}{d_1} E[U] E\\left[\\frac{1}{V}\\right] \\quad\r\n\\text{(独立性)} \\\\\r\n&amp;= \\frac{d_2}{d_1} \\cdot d_1 \\cdot \\frac{1}{d_2 - 2} \\quad\r\n\\text{(利用 $\\chi^2$ 分布的矩)} \\\\\r\n&amp;= \\frac{d_2}{d_2 - 2}\r\n\\end{aligned}\r\n$$\r\n方差计算\r\n当 d2 &gt; 4 时：\r\n$$\r\n\\text{Var}(F) = \\frac{2d_2^2(d_1 + d_2 - 2)}{d_1(d_2 - 2)^2(d_2 - 4)}\r\n$$\r\n推导过程： 先计算 E[F2]： $$\r\n\\begin{aligned}\r\nE[F^2] &amp;= \\left(\\frac{d_2}{d_1}\\right)^2 E[U^2]\r\nE\\left[\\frac{1}{V^2}\\right] \\\\\r\n&amp;= \\left(\\frac{d_2}{d_1}\\right)^2 (d_1^2 + 2d_1) \\cdot \\frac{1}{(d_2\r\n- 2)(d_2 - 4)} \\\\\r\n&amp;= \\frac{d_2^2(d_1 + 2)}{d_1(d_2 - 2)(d_2 - 4)}\r\n\\end{aligned}\r\n$$\r\n因此方差为： $$\r\n\\begin{aligned}\r\n\\text{Var}(F) &amp;= E[F^2] - (E[F])^2 \\\\\r\n&amp;= \\frac{d_2^2(d_1 + 2)}{d_1(d_2 - 2)(d_2 - 4)} -\r\n\\left(\\frac{d_2}{d_2 - 2}\\right)^2 \\\\\r\n&amp;= \\frac{2d_2^2(d_1 + d_2 - 2)}{d_1(d_2 - 2)^2(d_2 - 4)}\r\n\\end{aligned}\r\n$$\r\n高阶矩\r\nk阶矩存在条件：d2 &gt; 2k $$\r\nE[F^k] = \\left(\\frac{d_2}{d_1}\\right)^k \\frac{\\Gamma\\left(\\frac{d_1}{2}\r\n+ k\\right)\\Gamma\\left(\\frac{d_2}{2} -\r\nk\\right)}{\\Gamma\\left(\\frac{d_1}{2}\\right)\\Gamma\\left(\\frac{d_2}{2}\\right)}\r\n$$\r\n矩母函数 MGF\r\n一般情况\r\n对于 F ∼ F(d1, d2)，其矩母函数\r\nMF(t) = E[etF]\r\n在 t ≥ 0\r\n时不存在，因为： ∫0∞etxf(x; d1, d2)dx  对 t &gt; 0 发散\r\n负半轴存在性\r\n当 t &lt; 0\r\n时，矩母函数可表示为： $$\r\nM_F(t) =\r\n\\frac{\\Gamma\\left(\\frac{d_1+d_2}{2}\\right)}{\\Gamma\\left(\\frac{d_2}{2}\\right)}\r\n\\left(\\frac{d_2}{d_1}\\right)^{d_1/2} U\\left(\\frac{d_1}{2},\r\n1-\\frac{d_2}{2}, -\\frac{d_2}{d_1}t\\right)\r\n$$ 其中 U(a, b, z)\r\n是合流超几何函数（Tricomi’s function）。\r\n特殊情形 (d2 &gt; 2)\r\n当 d2 &gt; 2\r\n时，可展开为： $$\r\nM_F(t) = 1 + \\frac{d_2}{d_2-2}t +\r\n\\frac{d_2^2(d_1+2)}{d_1(d_2-2)(d_2-4)}t^2 + O(t^3), \\quad t \\leq 0\r\n$$\r\n特征函数\r\n积分表达式\r\n特征函数 ϕF(s) = E[eisF]\r\n始终存在： $$\r\n\\phi_F(s) =\r\n\\frac{\\Gamma\\left(\\frac{d_1+d_2}{2}\\right)}{\\Gamma\\left(\\frac{d_2}{2}\\right)}\r\n\\left(\\frac{d_2}{d_1}\\right)^{d_1/2} \\int_0^\\infty e^{isx}\r\n\\frac{x^{d_1/2-1}}{(1+\\frac{d_1}{d_2}x)^{(d_1+d_2)/2}} dx\r\n$$\r\n超几何函数表示\r\n通过变量替换 $u =\r\n\\frac{d_1}{d_2}x$，可得： $$\r\n\\phi_F(s) = {}_1F_1\\left(\\frac{d_1}{2}; \\frac{d_2}{2};\r\n-\\frac{d_2}{d_1}is\\right)\r\n$$ 其中 1F1\r\n是合流超几何函数。\r\n渐近展开\r\n当 |s| → 0 时的近似： $$\r\n\\phi_F(s) \\approx 1 + i\\frac{d_2}{d_2-2}s -\r\n\\frac{d_2^2(d_1+d_2-2)}{d_1(d_2-2)(d_2-4)}s^2 + O(s^3)\r\n$$\r\n柯西分布\r\n重复一下分布形式\r\n设位置参数为 x0，尺度参数为 γ &gt; 0，其概率密度函数为： $$\r\nf(x; x_0, \\gamma) = \\frac{1}{\\pi\\gamma \\left[1 +\r\n\\left(\\frac{x-x_0}{\\gamma}\\right)^2\\right]}\r\n$$\r\n标准柯西分布 当 x0 = 0，γ = 1 时： $$\r\nf(x) = \\frac{1}{\\pi(1+x^2)}\r\n$$\r\n稳定性\r\n若 X1, X2 ∼ Cauchy(x0, γ)\r\n独立，则： X1 + X2 ∼ Cauchy(2x0, 2γ)\r\n倒数分布\r\n若 X ∼ Cauchy(x0, γ)，则：\r\n$$\r\n\\frac{1}{X} \\sim \\text{Cauchy}\\left(\\frac{x_0}{x_0^2+\\gamma^2},\r\n\\frac{\\gamma}{x_0^2+\\gamma^2}\\right)\r\n$$\r\n期望\r\n柯西分布的期望不存在\r\n证明： $$\r\nE[|X|] = \\frac{1}{\\pi} \\int_{-\\infty}^\\infty \\frac{|x|}{1+x^2} dx =\r\n\\infty\r\n$$\r\n方差\r\n柯西分布的方差不存在\r\n证明：\r\n由于 E[X2] ≥ E[|X|]2 = ∞\r\n矩母函数 (MGF)\r\n柯西分布的MGF不存在\r\n证明：\r\n对于任何 t ≠ 0： $$\r\nE[e^{tX}] = \\frac{1}{\\pi} \\int_{-\\infty}^\\in\r\n$$\r\n$$\r\nfty \\frac{e^{tx}}{1+x^2} dx \\quad \\text{发散}\r\n$$\r\n特征函数\r\n特征函数存在： ϕX(s) = E[eisX] = eix0s − γ|s|\r\n推导：\r\n对于标准柯西分布 (x0 = 0, γ = 1)：\r\n$$\r\n\\begin{aligned}\r\n\\phi_X(s) &amp;= \\frac{1}{\\pi} \\int_{-\\infty}^\\infty\r\n\\frac{e^{isx}}{1+x^2} dx \\\\\r\n&amp;= e^{-|s|} \\quad \\text{(通过复变函数留数定理)}\r\n\\end{aligned}\r\n$$\r\n高阶矩\r\n所有阶数的矩均不存在\r\n证明：\r\n对于任何 k ≥ 1： $$\r\nE[|X|^k] = \\frac{1}{\\pi} \\int_{-\\infty}^\\infty \\frac{|x|^k}{1+x^2} dx =\r\n\\infty\r\n$$\r\n偏度与峰度\r\n由于矩不存在： - 偏度：未定义 -\r\n峰度：未定义\r\n所以，柯西分布不使用大数定律和中心极限定理\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"为Hexo博客添加首页轮播图","url":"/posts/25853.html","content":"展示效果\r\n\r\n\r\nimage-20250518231157142\r\n\r\n所以我们需要在首页的最顶端插入所需要的轮播图\r\n安装插件\r\nnpm install hexo-butterfly-swiper --save\r\n配置插件\r\n在_config.butterfly.yml下增加以下配置\r\n# hexo-butterfly-swiper# see https://akilar.top/posts/8e1264d1/swiper:  enable: true # 开关  priority: 5 #过滤器优先权  enable_page: / # 应用页面  timemode: date #date/updated  layout: # 挂载容器类型    type: id    name: recent-posts    index: 0  default_descr: 再怎么看我也不知道怎么描述它的啦！  swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖  swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖  custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁  custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法\r\n插件参数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数\r\n备选值/类型\r\n释义\r\n是否必选\r\n\r\n\r\n\r\n\r\npriority\r\nnumber\r\n过滤器优先级，数值越小执行越早（默认：10）\r\n可选\r\n\r\n\r\nenable\r\ntrue/false\r\n控制开关\r\n必选\r\n\r\n\r\nenable_page\r\npath/all\r\n应用页面的相对路径（如 / 或\r\n/categories/），默认：all\r\n可选\r\n\r\n\r\ntimemode\r\ndate/updated\r\n时间显示模式，默认：date\r\n可选\r\n\r\n\r\nlayout.type\r\nid/class\r\n挂载容器类型（默认：id）\r\n可选\r\n\r\n\r\nlayout.name\r\ntext\r\n挂载容器名称\r\n必选\r\n\r\n\r\nlayout.index\r\n0和正整数\r\n当 layout.type=class 时，指定 class 的索引位置\r\n可选\r\n\r\n\r\ndefault_descr\r\ntext\r\n默认文章描述\r\n可选\r\n\r\n\r\nswiper_css\r\nurl\r\n自定义 Swiper 的 CSS 依赖链接\r\n可选\r\n\r\n\r\nswiper_js\r\nurl\r\n自定义 Swiper 的 JS 依赖链接\r\n可选\r\n\r\n\r\ncustom_css\r\nurl\r\n适配主题的 CSS 补丁文件\r\n可选\r\n\r\n\r\ncustom_js\r\nurl\r\nSwiper 初始化的自定义 JS 文件\r\n可选\r\n\r\n\r\n\r\n展示文章\r\n在文章的front_matter处添加swiper_index的配置即可\r\n\r\nswiper_index #置顶轮播图顺序，非负整数，数字越大越靠前\r\ndescription #文章描述，这里是轮播图展示的描述\r\n\r\n","categories":["教程","配置教程"],"tags":["Hexo","教程","其他","配置相关","教程类"]},{"title":"为Hexo博客绑定你的自定义域名","url":"/posts/12190.html","content":"前言\r\n发现之前用来搞 galgame\r\n网盘转存网站的被我废弃掉之后，多出来一个闲置的域名\r\n就打算把我的 Hexo 博客绑定到上面，要不然每次都要\r\nergou10086.github.io来访问自己的博客，域名太长了。\r\n自定义域名其实是一件比较简单的事情啊，比把hexo部署到服务器简单得多\r\n效果就是如下了\r\n\r\n\r\nimage-20250518174351186\r\n\r\n这里实际上你的 仓库名.github.io\r\n这个域名并没有失效啊，只是指向了这个你自定义的域名\r\n输入 仓库名.github.io\r\n这个域名是会自动跳转到你自定义的域名下的，这个很重要，给需要分配子page和子域名的人说一下\r\n\r\n购买域名\r\n这里笔者使用的是阿里云，可能别的更便宜，我的 .cn 后缀域名现在一年要\r\n42 块，有点贵。。。\r\n另外还有很多人推荐的godaddy也可以。本篇以阿里云为例。\r\n\r\n首先注册阿里云账号，如果有淘宝账号的，可以直接登录。\r\n登录以后，先进行实名认证（购买域名要用到，但是域名申请备案时候还要搞一遍，那个是工信部申请备案的模板，关于如何实名验证，这里就跳过了）。\r\n\r\n这里进入购买域名的位置\r\n\r\n\r\nimage-20250518174737096\r\n\r\n在这搜索你想要注册的域名，建议买没有人用过的，买别人用过的一是贵，二是需要涉及过户\r\n域名其实不贵啊，.cn和 .top\r\n我都比较推荐，.xyz我看也不少人用，我的比较贵，42一年\r\n\r\n\r\nimage-20250518174824781\r\n\r\n备案通常情况下你看他说需要好几天，最慢的其实就是申请备案要搞的那个备案申请模板，有了那个模板几分钟我的就下来了我记得。\r\n\r\n\r\n21e582b3127625b7b97db3243c13b05d\r\n\r\n建议网站上线之后把备案信息放在你的网站页脚处。\r\n\r\n配置域名绑定\r\nwin+R快捷键打开“运行”窗口，输入cmd运行命令行控制台。\r\nping 你的仓库名.github.io 就能看到 GitHub Page\r\n给你绑的是什么 ip 了\r\n\r\n\r\n0d65b4836bd6abee004f93f572b864d8\r\n\r\n这里其实涉及到一些 GitHub Page 的一些配置信息，详情可以访问\r\nGitHub文档，我其实就是照着这个配置的\r\nhttps://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site\r\n进入域名解析列表并对购买的域名进行解析\r\n控制台，有个域名与网站，进去\r\n\r\n\r\nimage-20250518175642122\r\n\r\n\r\n\r\nimage-20250518175709843\r\n\r\n点击解析配置相应的配置\r\n\r\n\r\nimage-20250518175813533\r\n\r\n配置两条解析\r\n\r\n主机记录 www；记录类型\r\nCNAME；设置解析请求需要高级的版本，自动默认；记录值\r\n你的仓库名.github.io；TTL这个默认就是10分钟\r\n\r\nGitHub Pages 要求用户通过 CNAME 记录将自定义域名的 www\r\n子域名指向其默认域名（*.github.io）。\r\n这样配置后，当用户访问 www.yourdomain.com\r\n时，域名系统会将请求转发到 GitHub 服务器，由 GitHub\r\n处理并返回网站内容。\r\nGitHub Pages 的服务器 IP 地址可能会动态变化，使用 CNAME\r\n记录无需手动更新 IP，GitHub 会自动维护其默认域名与实际 IP\r\n的映射关系，避免因 IP 变动导致网站无法访问。\r\n\r\n主机记录 @；记录类型\r\nA；设置解析请求需要高级的版本，自动默认；记录值\r\n上面ping出的IP地址；TTL这个默认就是10分钟\r\n\r\n通过 A 记录指向 IP，确保根域名直接访问正常。\r\n根域名（如 yourdomain.com）无法直接使用 CNAME\r\n记录，因此需要通过 A 记录指向 GitHub Pages 的 IP\r\n地址。这里是为了兼容不支持 CNAME 的场景\r\n通过 ping yourrepo.github.io 可以获取 GitHub Pages\r\n当前的服务器 IP（可能返回多个\r\nIP，需全部配置），确保根域名能正确解析到服务器。\r\n\r\n若需启用 HTTPS，需在 GitHub Pages 中配置自定义域名并等待其自动颁发\r\nSSL 证书（需确保解析记录已生效）。\r\n\r\n关于记录类型其实有些话要说，你看很多人配置，配置主机记录 @的时候用的也是记录类型\r\nCNAME，然后记录值\r\n你的仓库名.github.io，其实这个是无所谓的，在这里我用的是上面ping出的IP地址，主机记录www的配置也可以写成\r\n你ping出的域名，然后记录类型写成A\r\n这俩写法都可以，所以我交叉着用了\r\n你可以点击生效检测，看看你的DNS生效了吗，没生效的情况大部分的备案没过\r\n\r\n\r\nimage-20250518180603900\r\n\r\n\r\n配置 GitHub 指向你的域名\r\n到这里阿里云上的配置就结束了\r\n新建 CNAME 文件\r\n我们需要新建一个 CNAME 文件，注意是 文件 需要把文件后缀名消掉\r\n\r\n\r\nimage-20250518180758215\r\n\r\n如果不做这一步，每次hexo d部署到\r\ngithub上以后，对应仓库的域名设置里的域名会被重置回原来username.github.io，你需要再次设置成你的域名，很麻烦。\r\n配置 apex 域\r\n这里是 GitHub 文档给出的配置教程\r\nhttps://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site\r\n\r\n\r\nimage-20250518175545261\r\n\r\n可以参考一下\r\n配置好了以后，登录github，进入到博客站点对应的仓库，对域名进行设置：\r\n进入 GitHUb Pages\r\n\r\n\r\n79504701a1eef5d4ae12c35683e2f70b\r\n\r\n不要吐槽的我用的汉化插件，我英语是真不行\r\n自定义域的部分输入你的域名，这里会自动进行 DNS\r\n解析，我这里第一次失败是因为我挂着梯子\r\n\r\n\r\n1bd1931bd6841afef6c19d18939221c2\r\n\r\n到此，域名就与你的博客站点绑定上了。\r\n输入你的域名查看能不能正常跳转\r\n\r\nHttps\r\n如果GitHub上可以开启Https直接开启即可，如果不能的话可以在阿里云申请一个免费的SSL证书\r\n\r\n\r\nimg\r\n\r\n","categories":["教程","配置教程"],"tags":["Hexo","教程","网站技术","配置相关","实用类","教程类","实用技术","部署"]},{"title":"为Hexo页脚添加网站运行时间","url":"/posts/26887.html","content":"前言\r\n该教程基于 butterfly 的主题进行配置\r\n因为自己也想弄一个这种东西，结果一搜发现全都是 next 主题的\r\n于是打算根据\r\nhttps://blog.hikariyo.net/js/hexo-realtime-duration-footer/index.html\r\n大佬的教程重新编写整理一个教程，因为我根据他的方法并没有成功弄好））\r\n配置文件修改\r\n本文用 Dayjs 来处理日期。当然，完全可以用原生\r\nDate，但是 js\r\n代码的编写在时间处理上会多出很多需要注意的细节\r\n我使用的是 butterfly\r\n主题。如果读者正在使用别的主题，请查阅对应官方文档寻找如何插入自定义标签与自定义页脚信息。\r\n在主题配置文件（即_config.butterfly.yml）中引入：\r\ninject:  bottom:    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/dayjs@1.11.7/plugin/duration.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;/scripts/realtime.js&quot;&gt;&lt;/script&gt;\r\n注意是 bottom 部分\r\n在自定义页脚中加入一个 span 元素提供显示日期的位置\r\nfooter:  custom_text:     - &#x27;&lt;span id=&quot;realtime_duration&quot;&gt;&lt;/span&gt;&#x27; # 注意要带引号\r\n接下来主要通过 setInterval\r\n实现这样一个实时更新的功能。\r\n实现功能\r\n在 source 目录下创建\r\nscripts/realtime.js，写入以下代码：\r\n(() =&gt; &#123;  dayjs.extend(window.dayjs_plugin_duration)  const el = document.getElementById(&#x27;realtime_duration&#x27;)  // 改成自己的时间  const date = dayjs(&#x27;2022-05-19&#x27;)  setInterval(() =&gt; &#123;    const dur = dayjs.duration(dayjs().diff(date))    const days = String(Math.floor(dur.asDays()))    el.innerHTML = &#x27;已运行&#x27; + days + dur.format(&#x27;天HH时mm分ss秒&#x27;)  &#125;, 1000)&#125;)()\r\n注意是 文件路径为\r\nyour_hexo_blog/source/scripts/realtime.js\r\n如果 source 下没有\r\nscripts，直接新建一个就行\r\n\r\n不成功的额外修改\r\n如果到这里你顺利显示了，就是正常的情况了，接下来都是我自己摸索的额外的不成功的话该如何配置\r\n如果没有成功加载，先去看看你的 public 中存放 js\r\n的文件夹看看有没有成功加载 realtime.js\r\n这里会有一个问题，切换页面，日期显示就会消失？？？\r\n其实就是 Pjax 兼容的问题，你开了 Pjax就会这样，这个官方文档里也说了\r\nPjax 会导致部分 js 失效\r\n改一下就行了\r\ndocument.addEventListener(&#x27;DOMContentLoaded&#x27;, initRuntime)document.addEventListener(&#x27;pjax:complete&#x27;, initRuntime) // 添加Pjax支持function initRuntime() &#123;  dayjs.extend(window.dayjs_plugin_duration)    const el = document.getElementById(&#x27;realtime_duration&#x27;)  if (!el) return // 确保元素存在  const startDate = dayjs(&#x27;2022-05-19T00:00:00+08:00&#x27;)    const updateTime = () =&gt; &#123;    const now = dayjs()    const duration = dayjs.duration(now.diff(startDate))        // 手动拼接时间部分    const days = duration.days()    const hours = duration.hours().toString().padStart(2, &#x27;0&#x27;)    const minutes = duration.minutes().toString().padStart(2, &#x27;0&#x27;)    const seconds = duration.seconds().toString().padStart(2, &#x27;0&#x27;)    el.innerHTML = `网站正常或不正常的运行了$&#123;days&#125;天$&#123;hours&#125;时$&#123;minutes&#125;分$&#123;seconds&#125;秒`  &#125;  updateTime()  setInterval(updateTime, 1000)&#125;\r\n这个 CSS 样式根据需要添加\r\n/* 消除默认间距 */#footer-wrap .footer-separator &#123;  display: none;&#125;/* 时间显示样式 */#realtime_duration &#123;  font-size: 0.9em;  color: #666;  letter-spacing: 0.5px;  white-space: nowrap; /* 防止换行 */&#125;\r\n","categories":["教程","配置教程"],"tags":["Hexo","教程","配置相关","配置文件","实用类","实用技术","错误解决"]},{"title":"为typora更换更新版本的mermaid避免图表无法加载","url":"/posts/23249.html","content":"Typora 是一款广受欢迎的 Markdown 编辑器，它集成了 Mermaid\r\n库，方便用户绘制各类基础图表，如流程图、甘特图、饼图等。然而，Typora 与\r\nMermaid 独立维护，这就导致 Typora 中集成的 Mermaid\r\n版本可能并非最新，进而无法支持最新的图表类型和特性。比如在撰写本文时，截至\r\nMermaid 的最新版本 8.5.1 支持 ER 图，在 Markdown 中输入如下代码：\r\n查看你的 typora 中的 mermaid 版本\r\n​```mermaidinfo\r\ninfo\r\nerDiagram    CUSTOMER &#125;|..|&#123; ORDER : places    ORDER ||--|&#123; LINE-ITEM : contains    CUSTOMER : id (PK)\r\n\n    erDiagram\n    CUSTOMER }|..|{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER : id (PK)\n  \r\n可以用这个代码测试你的 mermaid 版本和 typora版本，在 0.9.86\r\n及以前版本的 Typora 中，只展示空白图表，没有错误信息，报错信息为 Mermaid\r\n语法解析失败。这正是因为 Typora 集成的 Mermaid\r\n版本过低，当前版本集成的是 8.4.0 版本的 Mermaid，而此版本尚未支持 ER\r\n图。这是截至文章编辑时，Mermaid最新版本 8.5.1\r\n中所支持的一种图表\r\n不过，通过一些简单操作，我们可以让 Typora 集成最新版本的\r\nMermaid。\r\nTypora 本质上是由 js 实现的 Markdown 编辑器，Mermaid 也是通过 js\r\n实现的图表库，Typora 以 js 引用的方式集成了\r\nMermaid。所以，要集成最新版本的 Mermaid，我们首先要下载 Mermaid\r\n最新版本的 js 文件。\r\n获取最新版本的 js 文件可以从 Mermaid 的官方 CDN\r\n链接获取，你可以通过访问Mermaid\r\n官方网站，在文档中找到最新版本的 js 文件链接。\r\n也可以从https://cdn.jsdelivr.net/npm/mermaid@版本号右键选择保存到本地进行下载\r\n\r\n\r\nimage-20250608213117901\r\n\r\n可以看到其中的mermaid.min.js就是我们需要的内容\r\n我建议为 typora 搭载 9.3.0 版本的 mermaid，太高了好像还是不行\r\n除了官方提供的CDN下载方式，通过其他渠道下载也可以。\r\n接下来，我们要让 Typora 加载我们下载的最新版本的 js 文件。由于 Typora\r\n通过window.html文件来加载各类资源，我们需要对其进行修改。找到\r\nTypora 的安装目录，不同操作系统下 Typora 的安装目录有所不同：\r\n\r\n在 Windows 系统中，Typora\r\n默认安装在C:\\Users\\你的用户名\\AppData\\Local\\Typora\\目录下。\r\n在 Mac 系统中，Typora\r\n安装在/Applications/Typora.app/Contents/Resources/目录下。\r\n在 Linux\r\n系统中，如果是通过包管理器安装，安装目录可能在/usr/lib/typora/\r\n。\r\n\r\n找到安装目录后，进入resources文件夹，再找到window.html文件。在修改文件之前，强烈建议对window.html文件进行备份，以防修改失误导致\r\nTypora 无法正常使用。备份好文件后，使用文本编辑器（如 Notepad++、Sublime\r\nText\r\n等）打开window.html文件。在文件的``标签内，添加如下代码：\r\n&lt;script&gt;    setInterval(function () &#123;        if (typeof window.mermaid === &#x27;object&#x27;) &#123;            $.getScript(&#x27;./mermaid.min.js&#x27;);        &#125;    &#125;, 1000);&lt;/script&gt;\r\n找了一段别人的\r\n\r\nhttps://qzy.im/blog/2020/05/typora-integrate-the-latest-version-of-mermaid/\r\n\r\n&lt;script&gt;\tconst interval = setInterval(() =&gt; &#123;\t\tconsole.log(&#x27;check mermaid...&#x27;);\t\tif (window.editor &amp;&amp;\t\t\twindow.editor.diagrams &amp;&amp;\t\t\twindow.mermaidAPI) &#123;\t\t\t$.getScript(&#x27;file:///&lt;本地js文件存储的位置&gt;&#x27;)\t\t\t\t.then(() =&gt; &#123;\t\t\t\t\tmermaidAPI = mermaid.mermaidAPI;\t\t\t\t\teditor.diagrams.refreshDiagram(editor);\t\t\t\t\tclearInterval(interval);\t\t\t\t&#125;);\t\t&#125;\t&#125;, 100);&lt;/script&gt;\r\n这段代码的作用是在 Typora 窗口打开后，定时检查自带的 Mermaid\r\n是否已集成。若已集成，就通过 jQuery 从本地加载我们前面下载的 js\r\n文件。注意，这里假设你将下载的mermaid.min.js文件放在了与window.html相同的目录下。如果放置在其他目录，需要修改$.getScript中的路径为实际路径。\r\n完成上述操作后，将下载的最新版本的mermaid.min.js文件复制到window.html所在的目录。此时再打开\r\nTypora，插入 Mermaid 代码，查看 Mermaid\r\n的版本，就可以看到已经成功替换成了最新版。可以通过在 Typora\r\n中输入如下代码来查看版本：\r\n\n    sequenceDiagram\n    Alice-&gt;&gt;John: 你好吗?\n    John--&gt;&gt;Alice: 我很好\n    Alice-&gt;&gt;John: 今天天气不错\n    Note right of John: John思考中\n    John--&gt;&gt;Alice: 是的，很适合户外活动\n  \r\nsequenceDiagram    Alice-&gt;&gt;John: 你好吗?    John--&gt;&gt;Alice: 我很好    Alice-&gt;&gt;John: 今天天气不错    Note right of John: John思考中    John--&gt;&gt;Alice: 是的，很适合户外活动\r\nsequenceDiagram\n    Alice-&gt;&gt;John: 你好吗?\n    John--&gt;&gt;Alice: 我很好\n    Alice-&gt;&gt;John: 今天天气不错\n    Note right of John: John思考中\n    John--&gt;&gt;Alice: 是的，很适合户外活动\r\n类图\r\n\n    classDiagram\n    class Animal {\n        +name: string\n        +age: int\n        +eat(): void\n        +sleep(): void\n    }\n    class Dog {\n        +breed: string\n        +bark(): void\n    }\n    class Cat {\n        +furColor: string\n        +meow(): void\n    }\n    Animal &lt;|-- Dog\n    Animal &lt;|-- Cat\n  \r\nclassDiagram    class Animal &#123;        +name: string        +age: int        +eat(): void        +sleep(): void    &#125;        class Dog &#123;        +breed: string        +bark(): void    &#125;        class Cat &#123;        +furColor: string        +meow(): void    &#125;        Animal &lt;|-- Dog    Animal &lt;|-- Cat\r\nclassDiagram\n    class Animal &#123;\n        +name: string\n        +age: int\n        +eat(): void\n        +sleep(): void\n    &#125;\n    \n    class Dog &#123;\n        +breed: string\n        +bark(): void\n    &#125;\n    \n    class Cat &#123;\n        +furColor: string\n        +meow(): void\n    &#125;\n    \n    Animal &lt;|-- Dog\n    Animal &lt;|-- Cat\r\n甘特图\r\n\n    gantt\n    title 项目开发计划\n    dateFormat  YYYY-MM-DD\n    section 设计阶段\n    需求分析           :a1, 2023-01-01, 30d\n    原型设计           :a2, after a1, 20d\n    section 开发阶段\n    前端开发           :b1, 2023-02-20, 40d\n    后端开发           :b2, 2023-02-20, 50d\n    section 测试阶段\n    单元测试           :c1, after b1, 15d\n    集成测试           :c2, after b2, 20d\n    系统测试           :c3, after c1, 15d\n  \r\ngantt    title 项目开发计划    dateFormat  YYYY-MM-DD    section 设计阶段    需求分析           :a1, 2023-01-01, 30d    原型设计           :a2, after a1, 20d    section 开发阶段    前端开发           :b1, 2023-02-20, 40d    后端开发           :b2, 2023-02-20, 50d    section 测试阶段    单元测试           :c1, after b1, 15d    集成测试           :c2, after b2, 20d    系统测试           :c3, after c1, 15d\r\ngantt\n    title 项目开发计划\n    dateFormat  YYYY-MM-DD\n    section 设计阶段\n    需求分析           :a1, 2023-01-01, 30d\n    原型设计           :a2, after a1, 20d\n    section 开发阶段\n    前端开发           :b1, 2023-02-20, 40d\n    后端开发           :b2, 2023-02-20, 50d\n    section 测试阶段\n    单元测试           :c1, after b1, 15d\n    集成测试           :c2, after b2, 20d\n    系统测试           :c3, after c1, 15d\r\n修改并保存 window.html\r\n文件后，我们重新打开Typora，就发现问题场景示例中的ER图已经可以成功展示了\r\n另外，如果你不想通过修改window.html文件的方式来更新\r\nMermaid 版本，还可以使用一些第三方工具来实现。例如，在 Linux\r\n系统下，可以按照以下步骤操作：\r\n\r\n安装 asar 工具：asar 是一个用于处理 Electron\r\n应用资源文件的工具，Typora 就是基于 Electron\r\n开发的。在终端中输入命令sudo npm install -g asar来全局安装\r\nasar 工具。安装过程中可能需要输入系统密码，按照提示操作即可。\r\n下载 Mermaid 新版本：确定你想要下载的 Mermaid\r\n版本，Mermaid 版本更新较快，可以在 Mermaid\r\n官方网站查看最新版本信息。例如，若要下载 10.9.0\r\n版本，在终端中输入命令npm install mermaid@10.9.0，这会在当前目录下创建一个node_modules文件夹，并将\r\nMermaid 的 10.9.0 版本下载到该文件夹中。\r\n解压 Typora 的 lib.asar 文件：Typora\r\n的资源文件被打包在lib.asar文件中，我们需要解压它来替换其中的\r\nMermaid 文件。进入 Typora\r\n的安装目录，在终端中输入命令asar extract lib.asar extracted，这会在安装目录下创建一个名为extracted的文件夹，里面包含了解压后的\r\nTypora 资源文件。\r\n替换新版 Mermaid 的 js\r\n文件：进入extracted\\resources\\app\\lib\\diagram目录（不同版本路径可能略有差异），这里面有\r\nTypora 自带的mermaid.min.js文件。将我们前面下载的 Mermaid\r\n新版本的mermaid.min.js文件复制到这个目录，并覆盖原文件。为了以防万一，你可以先备份原文件，例如使用命令mv mermaid.min.js mermaid.min.js.bak（在\r\nLinux 系统下）。\r\n修改 frame.js 接入 Mermaid\r\n的文件路径：在extracted\\resources\\app\\renderer目录下找到frame.js文件，使用文本编辑器打开它。在文件中找到类似const n = path.join(app.getAppPath(), '.', 'lib', 'diagram','mermaid.min.js');的语句，将其修改为const n = path.join(app.getAppPath(), 'lib', 'diagram','mermaid.min.js');\r\n。这样修改后，Typora 就会默认使用我们替换后的lib路径下的\r\nMermaid 文件。好处是后续如果想要使用更新版本的\r\nMermaid，直接替换lib/diagram下的mermaid.min.js文件即可。\r\n重新打包 lib.asar\r\n文件：完成上述修改后，需要将extracted文件夹重新打包回lib.asar文件。在终端中，确保当前目录是\r\nTypora 的安装目录，然后输入命令asar pack extracted lib.asar\r\n。这会将修改后的资源文件重新打包成lib.asar文件。\r\n替换原 lib.asar\r\n文件：备份原lib.asar文件，例如mv lib.asar lib.asar.old，然后将新生成的lib.asar文件移动到原来的位置。此时再打开\r\nTypora，就会使用更新后的 Mermaid 版本了。\r\n\r\n通过以上方法，无论是在 Windows、Mac 还是 Linux 系统下，都可以成功为\r\nTypora 更换更新版本的\r\nMermaid，避免因版本过低导致图表无法加载或不支持新特性的问题，在 Typora\r\n中更顺畅地使用 Mermaid 绘制各类图表。\r\n","categories":["教程","错误解决"],"tags":["markdown","教程","错误解决"]},{"title":"使用ABCjs在hexo博客中显示五线谱的测试","url":"/posts/37962.html","content":"本文展示了如何在Hexo博客中使用ABC记谱法显示五线谱。如果您能看到下方的五线谱示例，则说明您的abcjs插件已成功安装并配置。\r\n简单旋律示例\r\n下面是一个简单的C大调音阶示例：\r\nX: 1T: C大调音阶M: 4/4L: 1/8K: CC D E F | G A B c | c B A G | F E D C |\r\n一首经典的生日快乐 X: 2T: Happy BirthdayM: 3/4L: 1/4K: C|&quot;Happy &quot;G2 G | A G C2 | &quot;birth-&quot;G2 G | A G D2 ||&quot;day &quot;G2 G | G4 | &quot;to &quot;E2 E | D C2 C |\r\nX:1\nT:alternate heads\nM:C\nL:1/8\nU:n=!style=normal!\nK:C treble style=rhythm\n&quot;Am&quot; BBBB B2 B&gt;B | &quot;Dm&quot; B2 B/B/B &quot;C&quot; B4 |&quot;Am&quot; B2 nGnB B2 nGnA | &quot;Dm&quot; nDB/B/ nDB/B/ &quot;C&quot; nCB/B/ nCB/B/ |B8| B0 B0 B0 B0 |]\n%%text This translates to:\n[M:C][K:style=normal]\n[A,EAce][A,EAce][A,EAce][A,EAce] [A,EAce]2 [A,EAce]&gt;[A,EAce] |[DAdf]2 [DAdf]/[DAdf]/[DAdf] [CEGce]4 |[A,EAce]2 GA [A,EAce] GA |D[DAdf]/[DAdf]/ D[DAdf]/[DAdf]/ C [CEGce]/[CEGce]/ C[CEGce]/[CEGce]/ |[CEGce]8 | [CEGce]2 [CEGce]2 [CEGce]2 [CEGce]2 |]\nGAB2 !style=harmonic![gb]4|GAB2 [K: style=harmonic]gbgb|\n[K: style=x]\nC/A,/ C/C/E C/zz2|\nw:Rock-y did-nt like that\r\n&#123;% score %&#125;%%gchordfont ItimX: 1T:Money LostM:3/4L:1/8Q:1/4=100C:Paul RosenS:Copyright 2007, Paul RosenR:KlezmerK:DmAde|:&quot;Dm&quot;(f2d)e gf|&quot;A7&quot;e2^c4|&quot;Gm&quot;B&gt;&gt;^c BA BG|&quot;A&quot;A3Ade|&quot;Dm&quot;(f2d)e gf|&quot;A7&quot;e2^c4|&quot;Gm&quot;A&gt;&gt;B &quot;A7&quot;AG FE|1&quot;Dm&quot;D3Ade:|2&quot;Dm&quot;D3DEF||:&quot;Gm&quot;(G2D)E FG|&quot;Dm&quot;A2F4|&quot;Gm&quot;B&gt;&gt;c &quot;A7&quot;BA BG|&quot;Dm&quot;A3 DEF|&quot;Gm&quot;(G2D)EFG|&quot;Dm&quot;A2F4|&quot;E°&quot;E&gt;&gt;Fy &quot;(A7)&quot;ED^C2|1&quot;Dm&quot;D3DEF:|2&quot;Dm&quot;D6||&#123;% endscore %&#125;\r\n%%gchordfont Itim\nX: 1\nT:Money Lost\nM:3/4\nL:1/8\nQ:1/4=100\nC:Paul Rosen\nS:Copyright 2007, Paul Rosen\nR:Klezmer\nK:Dm\nAde|:&quot;Dm&quot;(f2d)e gf|&quot;A7&quot;e2^c4|&quot;Gm&quot;B&gt;&gt;^c BA BG|&quot;A&quot;A3Ade|&quot;Dm&quot;(f2d)e gf|&quot;A7&quot;e2^c4|\n&quot;Gm&quot;A&gt;&gt;B &quot;A7&quot;AG FE|1&quot;Dm&quot;D3Ade:|2&quot;Dm&quot;D3DEF||:&quot;Gm&quot;(G2D)E FG|&quot;Dm&quot;A2F4|&quot;Gm&quot;B&gt;&gt;c &quot;A7&quot;BA BG|\n&quot;Dm&quot;A3 DEF|&quot;Gm&quot;(G2D)EFG|&quot;Dm&quot;A2F4|&quot;E°&quot;E&gt;&gt;Fy &quot;(A7)&quot;ED^C2|1&quot;Dm&quot;D3DEF:|2&quot;Dm&quot;D6||\r\nX:49M:4/4L:1/16%%stretchlast .7Q:1/4=100T:Piano%%staves &#123;(PianoRightHand) (PianoLeftHand)&#125;V:PianoRightHand clef=trebleV:PianoLeftHand clef=bassK:C[V: PianoRightHand] !mp!e2f2 e2d2 c2B2 A4|!&gt;(!B2d2 g4 c6 !&gt;)!e2|!p![G4e4] z4 A4 G4|c12 z4|[A12f12] [g4d4]|z4 !&lt;(!B4 !&lt;)![A8c8]|!mf!A4 z4 d8|B8 [G4c4] z4|f2A2 c4 f4 g4|[f12d12] e4|!&lt;(!A4 A4 c2e2 !&lt;)!g4|!f!e8 z8|[A4d4] z4 A8|BcBA G4 c4 G2B2|A2G2 A2B2 c4 B2G2|c12 z4|][V: PianoLeftHand] [E,12C,12] F,4|[G,8D,8] [C,8E,8]|G,4 C,4 C,4 B,,A,,C,B,,|A,,12 z4|A,,4 B,,4 C,2D,2 B,,C,D,E,|C,2E,2 G,4 E,2F,2 G,4|F,4 A,4 [A,8F,8]|G,2F,2 E,2D,2 [C,4E,4] z4|[F,8A,8] [D,4A,4] z4|F,2G,2 A,2F,2 D,2F,2 C,2B,,2|C,4 F,A,D,F, E,4 z4|C,8 z8|F,4 E,4 F,4 A,4|[D,8G,8] E,4 z4|C,4 [C,4F,4] z4 G,4|C,12 z4|]\r\nX:49\nM:4/4\nL:1/16\n%%stretchlast .7\nQ:1/4=100\nT:Piano\n%%staves &#123;(PianoRightHand) (PianoLeftHand)&#125;\nV:PianoRightHand clef=treble\nV:PianoLeftHand clef=bass\nK:C\n[V: PianoRightHand] !mp!e2f2 e2d2 c2B2 A4|!&gt;(!B2d2 g4 c6 !&gt;)!e2|!p![G4e4] z4 A4 G4|c12 z4|[A12f12] [g4d4]|z4 !&lt;(!B4 !&lt;)![A8c8]|\n!mf!A4 z4 d8|B8 [G4c4] z4|f2A2 c4 f4 g4|[f12d12] e4|!&lt;(!A4 A4 c2e2 !&lt;)!g4|!f!e8 z8|\n[A4d4] z4 A8|BcBA G4 c4 G2B2|A2G2 A2B2 c4 B2G2|c12 z4|]\n[V: PianoLeftHand] [E,12C,12] F,4|[G,8D,8] [C,8E,8]|G,4 C,4 C,4 B,,A,,C,B,,|A,,12 z4|A,,4 B,,4 C,2D,2 B,,C,D,E,|C,2E,2 G,4 E,2F,2 G,4|\nF,4 A,4 [A,8F,8]|G,2F,2 E,2D,2 [C,4E,4] z4|[F,8A,8] [D,4A,4] z4|F,2G,2 A,2F,2 D,2F,2 C,2B,,2|C,4 F,A,D,F, E,4 z4|C,8 z8|\nF,4 E,4 F,4 A,4|[D,8G,8] E,4 z4|C,4 [C,4F,4] z4 G,4|C,12 z4|]\r\n\r\n\r\n\r\n  .abcjs-container {\r\n    margin: 20px 0;\r\n    padding: 15px;\r\n    background-color: #f8f9fa;\r\n    border-radius: 5px;\r\n    overflow-x: auto;\r\n  }\r\n\r\n\r\nX:1\nT:欢乐颂\nC:贝多芬\nM:4/4\nL:1/4\nK:C\nE E F G | G F E D | C C D E | E D D- | E E F G |\r\n\r\nX:2\nT:测试曲目\nM:3/4\nK:G\nD E G | A B d | B A G | E D :|\r\n","categories":["其他","测试"],"tags":["其他","测试","音乐","前端类"]},{"title":"使用@RestController和@Controller的比较说明","url":"/posts/21966.html","content":"才知道原来 yaml 传文章是不支持 @\r\n的，YAML对特殊字符（如@、:等）敏感，直接放在字段值中可能导致解析错误。所以传文章一开始搞了好久））\r\n\r\n一般来说，我在开发的时候更多使用的是@RestController，而不是@Controller，所以突发奇想研究了以下这两者的区别，方便我在以后的使用中更加清晰。\r\n什么是@RestController，什么是@Controller\r\n\r\n首先，@RestController 和 @Controller 都是\r\nSpring Framework 中用于定义控制器的注解。\r\n@Controller 注解标记的类则是传统的控制器类，用于标记处理\r\nHTTP 请求的控制器类。\r\n\r\n对于Spring\r\nMVC框架中，它用于处理客户端发起的请求，并负责将数据填充到视图模板作为响应。\r\n在使用 @Controller 注解的类中，如果需要返回 JSON、XML\r\n等数据，通常需要在方法上使用 @ResponseBody\r\n注解来指示该方法的返回值要作为响应的主体内容，而不是解析为视图。如果返回的是字符串，Spring\r\n会将其视为视图名称，并通过视图解析器渲染对应的视图。\r\n在 @Controller\r\n标记的类中，方法默认返回的是视图名称，而非实际数据。Spring\r\n会通过视图解析器（ViewResolver）\r\n将视图名称映射到具体的视图模板。\r\n\r\n而@RestController 是一个组合注解，它结合了\r\n@Controller 和@ResponseBody\r\n注解的功能（就相当于把两个注解组合在一起）。在使用\r\n@RestController 注解标记的类中，每个方法的返回值都会以 JSON\r\n或 XML 的形式直接写入 HTTP 响应体中，相当于在每个方法上都添加了\r\n@ResponseBody注解。\r\n\r\n专门用于 RESTful API 的控制器，直接返回数据（如\r\nJSON、XML），无需视图解析。方法的返回值会自动通过消息转换器（如\r\nJackson）序列化为 JSON 或其他格式，等价于@Controller +\r\n@ResponseBody的组合\r\n\r\n总地来说，@RestController 适用于构建 RESTful\r\n风格的 API，其中每个方法的返回值会直接序列化为 JSON 或 XML\r\n数据并发送给客户端。而 @Controller 适用于传统的 MVC\r\n架构，它负责处理请求并返回相应的视图。（@RestController下的方法默认返回的是数据格式，@Controller注解标注的类下面的方法默认返回的就是以视图为格式）\r\n@RestController与@Controller的对比\r\n在 Spring\r\n框架中，@RestController和@Controller是两个用于定义控制器的注解，它们的主要区别在于返回值的处理方式。\r\n共同点都是用来表示 Spring 某个类是否可以接收 HTTP 请求\r\n区别则是，@Controller能返回指定的页面，@RestController不行，他是直接返回数据\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n@Controller\r\n@RestController\r\n\r\n\r\n\r\n\r\n默认返回类型\r\n视图名称（需视图解析器）\r\n直接返回数据（JSON/XML）\r\n\r\n\r\n注解组合\r\n单独使用，需配合@ResponseBody返回数据\r\n等价于@Controller + @ResponseBody\r\n\r\n\r\n适用场景\r\n传统 MVC 应用，需要渲染页面\r\nRESTful API，直接返回数据\r\n\r\n\r\n示例返回值处理\r\nreturn \"user-view\"; → 渲染 user-view.jsp\r\nreturn user; → 返回 JSON\r\n&#123;\"id\":1,\"name\":\"John\"&#125;\r\n\r\n\r\n\r\n当设计 RESTful API 时，一般的原则是：\r\n\r\n如果客户端希望获取数据（例如 JSON、XML），则返回数据。\r\n\r\n当你在开发一个单页应用的后端接口时，前端通常会通过 Ajax\r\n请求获取数据（例如 JSON），然后使用 JavaScript\r\n动态更新页面。在这种情况下，你应该返回数据（例如使用\r\n@ResponseBody 注解）。\r\n\r\n如果客户端希望展示数据（例如 HTML 页面），则返回视图。\r\n\r\n当你需要为前端渲染 HTML\r\n页面时，需要返回视图。视图可以包含动态生成的数据，但最终会经过服务器端模板引擎的处理，形成最终的\r\nHTML 页面。\r\n\r\n\r\n对于 @Controller\r\n这个注解主要用于标记 MVC\r\n控制器类。在默认情形下，被它标记的类中的方法返回值会被当作视图名称来处理，Spring\r\n会依据这个名称去查找对应的视图模板，进而渲染出 HTML 页面。\r\n\r\n传统的 Spring MVC 控制器，用于处理 HTTP 请求并返回视图（如\r\nJSP、Thymeleaf 模板等）。\r\n返回值处理\r\n\r\n如果返回的是字符串，Spring\r\n会将其视为视图名称，并通过视图解析器渲染对应的视图。\r\n如果需要返回 JSON、XML\r\n等数据，需要配合@ResponseBody注解使用。\r\n\r\n选择 @Controller 场景：\r\n\r\n传统 Web 应用，需要返回 HTML 页面。\r\n使用 Thymeleaf、JSP 等模板引擎渲染视图。\r\n\r\n\r\n@Controllerpublic class UserController &#123;    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public String getUser(@PathVariable Long id, Model model) &#123;        User user = userService.getUserById(id);        model.addAttribute(&quot;user&quot;, user);        return &quot;user-details&quot;; // 返回视图名称，对应user-details.jsp或Thymeleaf模板    &#125;    @GetMapping(&quot;/api/users/&#123;id&#125;&quot;)    @ResponseBody // 显式声明返回JSON数据    public User getUserApi(@PathVariable Long id) &#123;        return userService.getUserById(id); // 直接返回对象，自动序列化为JSON    &#125;&#125;\r\n对于 @RestController\r\n\r\n专门用于 RESTful API 的控制器，直接返回数据（如\r\nJSON、XML），无需视图解析。\r\n返回值处理\r\n\r\n方法的返回值会自动通过消息转换器（如 Jackson）序列化为 JSON\r\n或其他格式。\r\n等价于@Controller +\r\n@ResponseBody的组合。\r\n\r\n选择 @RestController 场景：\r\n\r\n开发 RESTful API，如前后端分离的项目。\r\n服务间调用（如微服务），返回 JSON/XML 格式数据。\r\n\r\n\r\n@RestController // 相当于@Controller + @ResponseBody@RequestMapping(&quot;/api&quot;)public class UserRestController &#123;    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public User getUser(@PathVariable Long id) &#123;        return userService.getUserById(id); // 直接返回对象，自动序列化为JSON    &#125;    @PostMapping(&quot;/users&quot;)    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) &#123;        User savedUser = userService.saveUser(user);        return ResponseEntity.created(URI.create(&quot;/api/users/&quot; + savedUser.getId())).body(savedUser);    &#125;&#125;\r\n@ResponseBody注解让方法返回值作为响应内容\r\n在使用 @Controller\r\n注解标记的类中，默认情况下，方法的返回值会被解析为一个视图名称，并寻找与该名称匹配的视图进行渲染。这意味着返回的结果会被解析为一个\r\nHTML 页面或者模板引擎所需的数据。\r\n但是有时候需要将方法的返回值直接作为响应的主体内容，而不是解析为视图。为了实现这个目的，我们可以在方法上使用\r\n@ResponseBody 注解。\r\n@ResponseBody 注解表示方法的返回值应该直接写入 HTTP\r\n响应体中，而不是被解析为视图。它告诉 Spring MVC\r\n框架将方法的返回值序列化为特定格式（如 JSON、XML\r\n等）并作为响应的主体内容返回给客户端。\r\n@Controllerpublic class MixedController &#123;    @GetMapping(&quot;/page&quot;)    public String showPage() &#123;        return &quot;page&quot;; // 返回视图    &#125;        @GetMapping(&quot;/data&quot;)    @ResponseBody    public Map&lt;String, String&gt; getData() &#123;        return Map.of(&quot;key&quot;, &quot;value&quot;); // 返回数据    &#125;&#125;\r\n\r\n@Controller +\r\n@ResponseBody：适用于在一个控制器里同时处理视图和数据的情况\r\n\r\n有时候并不需要返回视图，只需要一组数据，这样在方法加上一个@ResponseBody，就可以让返回的格式转换为数据格式\r\n@Controller 方法通常需要配合 @ResponseBody\r\n注解，才能将返回值作为响应的主体内容。\r\n传统的springMVC一般就需要直接返回视图，而现在新兴的前端技术vue在项目中为前后端分离的架构，前端框架负责处理数据和渲染页面，而后端\r\nAPI 则负责提供数据即可，所以对返回视图的要求也就比较少了\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["实用知识","Java技术","框架知识","Spring系列","Spring Framework","Spring Boot","Java框架"]},{"title":"使用exe4j打包Java代码为可执行文件exe","url":"/posts/36301.html","content":"前言\r\n我最近写了一个小工具，这次写的也比较实用，所以也就更加认真，写完了考虑发布一个发行版，所以就研究怎么把\r\nJava 代码进行打包，就看到了 exe4j 这个工具，但是使用 exe4j 工具，将 jar\r\n打包成 exe，如果有额外配置文件，这种就不是很舒服。\r\n虽然步骤比较长，但是打包的效果还是很不错的，很适合小型工具这种文件的打包\r\n首先确保jar能够正常运行，然后使用exe4j工具进行转换为exe，添加相对路径的jre让他能够跟着文件夹走，也就不用依赖系统jdk环境了\r\n博主是使用 JavaFx 的程序为大家示例的\r\n这里给博主的项目引流一下\r\nhttps://github.com/ergou10086/ErgouTreeMarkdownClearup\r\n\r\n将 java 程序打包成 jar 包\r\n首先我们需要把 Java 程序打包成 jar 包，打包之前确保能够正常运行\r\n选择项目结构，Flie\r\n—&gt; Project Structure （或者Ctrl+Shift+Alt+S）\r\n\r\n\r\nimage-20250522172508648\r\n\r\n\r\n进入到工件页面开始打包\r\n然后选择工件，进入到 Artifacts 设置，点击加号，选择为 JAR，选择\r\n来自具有依赖项的模块\r\n注意，这里有着你的 jar 包的存放位置，请注意，这个需要记住\r\n\r\n\r\n210c64fdcf2a2b707fb3653dfa60ba06\r\n\r\n\r\n选择打包\r\n然后 选择要打包的项目，选择要执行的 main 函数和 META-INF\r\n文件存放的路径\r\n\r\n\r\nimg\r\n\r\n当你已经在这个路径下已经建过一个 module 了的话再次新建 module\r\n就会报这个错，只要删除对应的 META-INF 文件夹即可\r\n\r\n构建 jar 包\r\n然后选择 Build 中的 Build\r\nArtifacts，然后在构建工件中选择构建，就会在前面设置的路径下生成我们的\r\njar 包，其实这个 jar\r\n包就已经可以运行了，如果想更方便一点就继续看下去使用 exe4j 把它变成 exe\r\n可执行文件。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n将打包后的jar包打包成exe可执行文件\r\n去下载 exe4j\r\n官网下载\r\nexe4j\r\n\r\nWelcome 页\r\n这个地方最好要注册一下，如果你不注册，打包好的软件每次启动都会报：this executable was created with an evaluation version of exe4j\r\n\r\n\r\nimage-20250522173450064\r\n\r\n“Open Configuration” 部分，点击 [Open]\r\n可加载现有的配置文件，这里我之前用过所以已指定一个路径，点击 [Reopen]\r\n可打开之前保存或加载过的配置。\r\n果之前保存过配置文件，且路径正确（就是 “Open” 按钮后面显示的那个路径\r\n），直接点击 “Open” 按钮加载配置文件，然后根据后续提示操作。\r\n初次使用或无配置文件，直接点击 “下一步” 按钮就行\r\n\r\nProjectType\r\n这是选择打包模式的，咱们是 Jar 打包成 exe，所以说是第二个\r\n\r\n\r\nimg\r\n\r\n\r\nApplication info\r\n这一页主要是两个内容，第一个 General 是填写 打包成 exe\r\n文件的名称，下一个是填路径，是存放 exe 文件的路径\r\n由于我这里没有截图，选择了其他博主的截图\r\n\r\n\r\nimg\r\n\r\n\r\nExecutable info\r\nGUI\r\napplication：图形用户界面应用程序，一般有可视化窗口、按钮、菜单等交互元素，适合大多数有图形界面的\r\nJava 程序。所以这个我们要勾选上，如果你这个有 GUI 页面\r\nIcon File勾选表明会为可执行文件设置图标，也就是你的 exe 的图标\r\nFail if an exception in the main thread is\r\nthrown，若主线程抛出异常，程序将终止运行和 Change working directory\r\nto，可指定程序运行时的工作目录，当前设置为 “.”\r\n，即当前目录，这都是默认的\r\n\r\n\r\nimg\r\n\r\n高级选项那边会有个架构（Architecture (32/64/ARM)\r\n），这个需要选上，否则对于64位机，最后运行exe时会报错\r\n\r\nJava invocation\r\n选择Jar 并Archive后，空白区域会显示已导入的jar，在点击选择Main\r\nclass,若jar导入成功，则会自动搜素main类，也可以自己选择Main类，然后点击next\r\n查看 Jar 包位置\r\n\r\n\r\nimg\r\n\r\n这里需要选择那个加号，导入 jar 包，选择 Archive\r\n\r\n\r\nimg\r\n\r\n\r\nJRE\r\n这里你用的什么\r\nJDK，就选什么就行了，配置一下jdk版本最低版本，最高的可以不写\r\n\r\nConfigure splash screen\r\n这是 exe4j 的 “配置启动画面（Configure splash screen ）” 步骤\r\n，没有就算了\r\n\r\nMessages\r\n我也不太知道，反之 next 就行\r\n\r\n\r\nimg\r\n\r\n\r\nCompile executable\r\n这一步是自动的，意思是在构建 exe 了\r\n\r\nFinished\r\n到这一步就完成了，可以选择打开看看或者保存为配置文件\r\n\r\n\r\nimg\r\n\r\n\r\n可以看到博主的 exe 已经正常运行了\r\n\r\n\r\nimg\r\n\r\n其他方式构建 exe 的之后再发，貌似 javafx\r\n里有自带的构建工具，更加方便实用，那个下次发\r\n","categories":["实用","教程","使用教程"],"tags":["实用知识","Java技术","常用知识","教程类","实用工具","打包或部署","使用知识"]},{"title":"使用aiven免费获取云端数据库并添加到SrpingBoot项目中","url":"/posts/36378.html","content":"前言\r\n之前团队内合作开发时候，在数据库的共享连接方面做法通常是传到ECS服务器上，这次发现一个云端的数据库部署托管平台，而且发现有一核一G的免费mysql云端数据库平台\r\nAiven.io\r\n是一个提供开源数据平台即服务的云平台，支持多种数据库、消息队列和流处理服务。\r\nAiven地址：https://aiven.io/\r\n\r\n在 Aiven 获取云端数据库\r\n本教程以 Mysql 数据库为例\r\n先注册，注册可能需要挂梯子\r\n\r\n\r\nimage-20250520191622819\r\n\r\n注册完后，点击 Create\r\nservice，根据你需要的数据库服务类型选择，本教程以mysql为例\r\n\r\n\r\nimage-20250520192037739\r\n\r\n选择免费的计划，可以看到是一核 1GB 开发够用了\r\n\r\n\r\nimage-20250520192143644\r\n\r\n可以看到其云平台是在新加坡，但是实际上使用不需要梯子，按需要更改下面的\r\nsql 数据库名\r\n\r\n\r\nimage-20250520192229411\r\n\r\n之后就是一顿点击，按需要更改其中的内容，来到如下页面\r\n\r\n\r\nb8e42f52b2db27d456861eea45b4ad0\r\n\r\n其中 Service URL 就是你的整体Mysql各种连接信息，Database name\r\n是你的数据库名，Host 就是主机名\r\n\r\n\r\n\r\nVariable\r\nDescription\r\n\r\n\r\n\r\n\r\nUSER_HOST\r\nHostname for MySQL connection\r\n\r\n\r\nUSER_PORT\r\nPort for MySQL connection\r\n\r\n\r\nUSER_PASSWORD\r\nPassword of your Aiven for MySQL connection\r\n\r\n\r\nDB_NAME\r\nDatabase Name of your Aiven for MySQL connection\r\n\r\n\r\n\r\nCA certificate 是 CA 证书，是需要下载下保存在你项目里的，\r\n使用CA证书的SSL连接是连接到这个数据库的方式\r\n等待其中的数据库从重载变成运行，就可以开始连接了，比较慢\r\n到这里 Aiven 的申请云端数据库的部分就完成了，接下来就是连接了\r\n\r\n连接到 Aiven 的云端数据库\r\n使用 Navicat 连接\r\n在 Navicat 的新建连接里，选择 SSL 连接，选择使用验证，把 CA\r\n证书的地址放进去\r\n\r\n\r\nimage-20250520192944141\r\n\r\n回到常规，主机就是你上面 Aiven 服务器信息页面中的\r\nHost，账号密码也是一样的\r\n\r\n\r\nimage-20250520193116065\r\n\r\n使用 DataGrip 和\r\nIDEA 内置数据库插件工具连接\r\n\r\n\r\nimage-20250520193509862\r\n\r\n这里都是一样的，选择使用SSL，然后上传你的 CA文件\r\n\r\n\r\nimage-20250520193545710\r\n\r\n回到常规这里再编辑就可以了\r\n\r\n\r\nimage-20250520193607133\r\n\r\n这里我配过了，就没有演示，和 Navicat 是一样的\r\n使用 MySQL 命令行连接\r\n这里可以参考 Aiven 的官方文档\r\nhttps://aiven.io/docs/products/mysql/howto/connect-from-cli#using-mysql\r\n在终端中，运行以下代码：\r\nmysql --user 用户名 --password=密码 --host 你那个主机名Host --port 12100 数据库名\r\n要确认连接是否正常工作，可以发出以下查询：\r\nselect 1 + 2 as three;\r\n\r\n在你的 Spring Boot\r\n项目中引入 Aiven 数据库\r\n打开cmd，切换到 CA 证书的目录位置，输入以下命令\r\nkeytool -importcert -alias myca -file ca.pem -keystore truststore.jks -storepass changeit\r\n该命令的作用是用于管理 Java 密钥库（JKS）的命令，主要作用是将\r\nCA 证书（公钥）导入到 Java 信任库中，让 Java\r\n应用程序信任该证书颁发机构（CA）签发的证书。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数\r\n作用\r\n\r\n\r\n\r\n\r\n-importcert\r\n指定执行证书导入操作。\r\n\r\n\r\n-alias myca\r\n为导入的证书设置别名（myca），用于在密钥库中标识该证书。\r\n\r\n\r\n-file ca.pem\r\n指定要导入的证书文件路径（ca.pem），通常是 PEM 格式的\r\nCA 证书。\r\n\r\n\r\n-keystore truststore.jks\r\n指定目标密钥库文件（truststore.jks）。如果文件不存在，会创建一个新的。\r\n\r\n\r\n-storepass changeit\r\n指定密钥库的密码（changeit）。这是 Java\r\n默认密钥库的初始密码。\r\n\r\n\r\n\r\n当 Java 应用程序（如 HTTPS 客户端、SSL/TLS\r\n连接）验证服务器证书时，会检查证书是否由信任库中的 CA 签发。通过导入 CA\r\n证书，可以让 Java 信任该 CA 颁发的所有证书。如果应用程序连接 HTTPS\r\n网站时出现 SSLHandshakeException 或\r\nPKIX path building failed 错误，通常是因为 Java\r\n不信任该网站的 CA 证书。导入对应的 CA 证书可以解决此问题。\r\n输入以下命令验证证书是否导入成功\r\nkeytool -list -v -keystore truststore.jks -storepass changeit | grep myca\r\n可以看到目录下的 pm.ca CA证书文件变成了一个 truststore.jks 文件\r\n\r\n\r\nimage-20250520194157286\r\n\r\n之后打开你的 spring boot 项目配置文件，对 mysql\r\n数据库部分的配置进行修改\r\n# Aiven-Mysql Configspring.datasource.url=jdbc:mysql://你的主机Host名:12100/数据库名?useSSL=true&amp;requireSSL=true&amp;enabledTLSProtocols=TLSv1.2&amp;trustCertificateKeyStoreUrl=file:jks文件位置&amp;trustCertificateKeyStorePassword=changeitspring.datasource.username=你的用户名spring.datasource.password=你的密码spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n如果你是 yml 配置\r\n# Aiven-Mysql Configspring:  datasource:    url: jdbc:mysql://你的主机Host名:12100/数据库名?useSSL=true&amp;requireSSL=true&amp;enabledTLSProtocols=TLSv1.2&amp;trustCertificateKeyStoreUrl=file:jks文件位置&amp;trustCertificateKeyStorePassword=changeit    username: 你的用户名    password: 你的密码    driver-class-name: com.mysql.cj.jdbc.Driver\r\n接下来应该就可以了，启动项目，可以看到我的 Hibernate\r\n已经为我自动创建表\r\n\r\n\r\nimage-20250520194332996\r\n\r\n","categories":["教程","配置教程"],"tags":["实用知识","数据库","MySql","配置相关","教程类"]},{"title":"关于C#中的委托机制的讲解","url":"/posts/18245.html","content":"C# 委托机制深度解析与实战指南\r\n一、委托的本质与核心概念\r\n委托（Delegate） 是 C#\r\n中实现回调机制的核心特性，本质上是一种引用方法的类型安全对象。与 C++\r\n函数指针相比，委托具有以下优势：\r\n\r\n类型安全：委托实例必须匹配方法的签名（参数类型、返回类型）\r\n面向对象封装：委托是派生自System.Delegate的类实例\r\n多播能力：一个委托实例可引用多个方法\r\n跨应用域调用：支持在不同应用域间传递方法引用\r\n\r\n委托的核心组成部分：\r\n\r\n签名定义：指定参数列表和返回类型\r\n目标方法：委托引用的具体方法（静态方法或实例方法）\r\n调用逻辑：通过委托实例调用时执行目标方法\r\n\r\n二、委托的基础用法详解\r\n1. 委托的声明与类型匹配规则\r\n// 声明一个返回int、接收两个int参数的委托public delegate int MathOperation(int a, int b);// 符合该委托签名的方法public static int Add(int x, int y) =&gt; x + y;public static int Multiply(int x, int y) =&gt; x * y;// 类型匹配严格要求：// - 参数数量、类型、顺序必须一致// - 返回类型必须兼容（可协变）public double Divide(double x, double y) =&gt; x / y; // 错误：返回类型不匹配\r\n2. 委托实例的创建与调用优化\r\npublic class DelegateDemo &#123;    public static void Main() &#123;        // 传统实例化方式        MathOperation op1 = new MathOperation(Add);                // C# 2.0后简化语法（省略new关键字）        MathOperation op2 = Multiply;                // 调用委托        int result1 = op1(5, 3);   // 输出8        int result2 = op2(5, 3);   // 输出15                // 委托实例为空时的安全调用        MathOperation op3 = null;        int result3 = op3?.Invoke(5, 3) ?? 0; // C# 6.0空条件操作符，避免NullReferenceException    &#125;&#125;\r\n3. 多播委托的高级特性\r\npublic class MulticastDemo &#123;    public static void Log(string msg) =&gt; Console.WriteLine($&quot;[LOG] &#123;msg&#125;&quot;);    public static void Warn(string msg) =&gt; Console.WriteLine($&quot;[WARN] &#123;msg&#125;&quot;);        public static void Main() &#123;        Action&lt;string&gt; logger = Log;        logger += Warn; // 添加多个方法到委托链                // 调用多播委托        logger(&quot;系统启动&quot;); // 依次执行Log和Warn方法                // 移除特定方法        logger -= Log;        logger(&quot;数据加载&quot;); // 仅执行Warn方法                // 多播委托的返回值处理（仅保留最后一个方法的返回值）        Func&lt;int, int&gt; calculator = x =&gt; x * 2;        calculator += x =&gt; x + 10;        int result = calculator(5); // 先执行x*2=10，再执行x+10=20，返回20    &#125;&#125;\r\n三、委托在核心场景中的实战应用\r\n1. 事件驱动编程模型\r\n// 发布者模式完整实现public class WeatherStation &#123;    // 定义事件参数    public class WeatherUpdateEventArgs : EventArgs &#123;        public double Temperature &#123; get; &#125;        public WeatherUpdateEventArgs(double temp) =&gt; Temperature = temp;    &#125;        // 定义事件委托（使用EventHandler&lt;T&gt;泛型事件模式）    public event EventHandler&lt;WeatherUpdateEventArgs&gt; TemperatureChanged;        // 触发事件的保护方法（线程安全写法）    protected virtual void OnTemperatureChanged(double temp) &#123;        // 复制事件引用避免并发修改问题        EventHandler&lt;WeatherUpdateEventArgs&gt; handler = TemperatureChanged;        handler?.Invoke(this, new WeatherUpdateEventArgs(temp));    &#125;        // 模拟温度更新    public void SimulateTemperatureChange(double newTemp) &#123;        OnTemperatureChanged(newTemp);    &#125;&#125;// 订阅者实现public class DisplayMonitor &#123;    public void Subscribe(WeatherStation station) &#123;        // 使用匿名方法订阅事件        station.TemperatureChanged += (sender, e) =&gt; &#123;            Console.WriteLine($&quot;当前温度: &#123;e.Temperature&#125;°C&quot;);        &#125;;    &#125;&#125;\r\n2. 异步回调与现代异步模式\r\n// 传统异步委托模式（APM）public class AsyncDemo &#123;    public static int Calculate(int x, int y) &#123;        Thread.Sleep(1000); // 模拟耗时操作        return x * y;    &#125;        public static void Main() &#123;        // 定义委托        Func&lt;int, int, int&gt; calculator = Calculate;                // 异步调用（BeginInvoke）        IAsyncResult ar = calculator.BeginInvoke(5, 3, ar =&gt; &#123;            // 异步回调            int result = calculator.EndInvoke(ar);            Console.WriteLine($&quot;计算结果: &#123;result&#125;&quot;);        &#125;, null);                Console.WriteLine(&quot;异步操作已启动，主线程继续执行...&quot;);        Thread.Sleep(2000);    &#125;&#125;// 现代Task-based异步模式（TAP）public async Task&lt;int&gt; CalculateAsync(int x, int y) &#123;    await Task.Delay(1000); // 推荐的异步写法    return x * y;&#125;\r\n3. 泛型委托与类型安全设计\r\n// 泛型委托实现数据转换工厂public class ConverterFactory &#123;    // 定义泛型转换委托    public delegate TOutput Converter&lt;TInput, TOutput&gt;(TInput input);        // 注册转换规则    private Dictionary&lt;Type, Delegate&gt; converters = new Dictionary&lt;Type, Delegate&gt;();        // 注册转换方法    public void RegisterConverter&lt;TInput, TOutput&gt;(Converter&lt;TInput, TOutput&gt; converter) &#123;        converters[typeof(TInput)] = converter;    &#125;        // 执行转换    public TOutput Convert&lt;TInput, TOutput&gt;(TInput input) &#123;        if (converters.TryGetValue(typeof(TInput), out Delegate converter)) &#123;            return ((Converter&lt;TInput, TOutput&gt;)converter)(input);        &#125;        throw new NotSupportedException($&quot;不支持的转换类型: &#123;typeof(TInput)&#125;&quot;);    &#125;&#125;// 使用示例ConverterFactory factory = new ConverterFactory();factory.RegisterConverter&lt;string, int&gt;(int.Parse);int result = factory.Convert&lt;string, int&gt;(&quot;123&quot;); // 输出123\r\n四、内置泛型委托与 Lambda\r\n表达式进阶\r\n1. Action 与 Func 委托家族\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n委托类型\r\n参数数量\r\n返回类型\r\n示例签名\r\n\r\n\r\n\r\n\r\nAction\r\n0\r\nvoid\r\nAction()\r\n\r\n\r\nAction\r\n1\r\nvoid\r\nAction\r\n\r\n\r\nAction&lt;T1, T2&gt;\r\n2\r\nvoid\r\nAction&lt;int, double&gt;\r\n\r\n\r\nFunc\r\n0\r\nTResult\r\nFunc\r\n\r\n\r\nFunc&lt;T1, TResult&gt;\r\n1\r\nTResult\r\nFunc&lt;int, bool&gt;\r\n\r\n\r\nFunc&lt;T1, T2, TResult&gt;\r\n2\r\nTResult\r\nFunc&lt;double, double, double&gt;\r\n\r\n\r\n\r\n2. Lambda 表达式高级技巧\r\n// 捕获外部变量的闭包示例public void ClosureDemo() &#123;    int factor = 2;    Func&lt;int, int&gt; multiplier = x =&gt; x * factor; // 捕获factor变量        factor = 3; // 闭包会保留变量的最新值    int result = multiplier(10); // 10 * 3 = 30        // 避免闭包陷阱：使用局部变量固定值    for (int i = 0; i &lt; 5; i++) &#123;        int temp = i; // 固定当前i的值        Action action = () =&gt; Console.WriteLine(temp);    &#125;&#125;// LINQ中的Lambda应用List&lt;int&gt; numbers = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5 &#125;;var evenNumbers = numbers.Where(n =&gt; n % 2 == 0)  // 筛选偶数                         .Select(n =&gt; n * 2)     // 乘以2                         .ToList();\r\n五、委托的内存管理与性能优化\r\n1. 委托链的内存泄漏风险\r\npublic class EventLeakDemo &#123;    public event EventHandler DataUpdated;        public void Subscribe(Form form) &#123;        // 错误写法：匿名方法会捕获Form实例，导致Form无法释放        DataUpdated += (s, e) =&gt; form.Text = &quot;数据已更新&quot;;                // 正确写法：使用弱引用或显式解绑事件        DataUpdated += OnDataUpdated;    &#125;        private void OnDataUpdated(object sender, EventArgs e) &#123;        // 使用弱引用访问Form实例    &#125;        // 显式解绑事件避免泄漏    public void Unsubscribe() &#123;        DataUpdated -= OnDataUpdated;    &#125;&#125;\r\n2. 委托性能对比与优化策略\r\n// 不同委托实现的性能测试public class DelegatePerformance &#123;    // 普通方法调用    public static int NormalCall(int x, int y) =&gt; x + y;        // 委托调用    public static int DelegateCall(int x, int y) =&gt; x + y;    public static Func&lt;int, int, int&gt; delegateInstance = DelegateCall;        public static void Benchmark() &#123;        const int iterations = 10000000;        Stopwatch sw = Stopwatch.StartNew();                // 普通方法调用        int result1 = 0;        for (int i = 0; i &lt; iterations; i++) &#123;            result1 = NormalCall(1, 2);        &#125;        sw.Stop();        Console.WriteLine($&quot;普通方法: &#123;sw.ElapsedMilliseconds&#125;ms&quot;);                // 委托调用        sw.Restart();        int result2 = 0;        for (int i = 0; i &lt; iterations; i++) &#123;            result2 = delegateInstance(1, 2);        &#125;        sw.Stop();        Console.WriteLine($&quot;委托调用: &#123;sw.ElapsedMilliseconds&#125;ms&quot;);                // 结论：委托调用比普通方法慢约5-10倍，但现代JIT优化后差距缩小    &#125;&#125;\r\n六、委托在设计模式中的应用\r\n\r\n策略模式与委托结合\r\n\r\n// 委托实现策略模式public class PaymentProcessor &#123;    // 定义支付策略委托    public delegate bool PaymentStrategy(decimal amount, string account);        // 执行支付    public bool ProcessPayment(decimal amount, string account, PaymentStrategy strategy) &#123;        return strategy(amount, account);    &#125;        // 具体支付策略    public static bool CreditCardPayment(decimal amount, string account) &#123;        // 信用卡支付逻辑        return true;    &#125;        public static bool PayPalPayment(decimal amount, string account) &#123;        // PayPal支付逻辑        return true;    &#125;&#125;// 使用示例PaymentProcessor processor = new PaymentProcessor();bool result = processor.ProcessPayment(100.0m, &quot;12345&quot;, PaymentProcessor.CreditCardPayment);\r\n\r\n观察者模式的委托实现\r\n\r\n// 委托实现观察者模式（简化版）public class StockMarket &#123;    // 定义价格变化通知委托    public delegate void PriceChangedHandler(string symbol, decimal newPrice);    public event PriceChangedHandler PriceChanged;        public void UpdateStockPrice(string symbol, decimal newPrice) &#123;        PriceChanged?.Invoke(symbol, newPrice);    &#125;&#125;public class Investor &#123;    private readonly string name;        public Investor(string name, StockMarket market) &#123;        this.name = name;        market.PriceChanged += OnPriceChanged;    &#125;        private void OnPriceChanged(string symbol, decimal newPrice) &#123;        Console.WriteLine($&quot;&#123;name&#125; 收到通知: &#123;symbol&#125; 价格变为 &#123;newPrice&#125;&quot;);    &#125;&#125;\r\n七、委托机制的底层实现原理\r\n\r\n委托的内存结构\r\n委托实例在 CLR 中包含以下关键字段：\r\n\r\n**_methodPtr**：指向方法的入口地址\r\n**_target**：指向目标对象（实例方法）或 null（静态方法）\r\n**_next**：指向下一个委托（多播委托链）\r\n\r\n多播委托的本质\r\n多播委托实际上是通过System.Delegate.Combine和System.Delegate.Remove方法实现的链表结构：\r\n\r\n// 多播委托的底层实现等价于MathOperation multiDelegate = null;multiDelegate = (MathOperation)Delegate.Combine(multiDelegate, new MathOperation(Add));multiDelegate = (MathOperation)Delegate.Combine(multiDelegate, new MathOperation(Multiply));\r\n\r\n委托调用的 IL 指令\r\n\r\n// 委托调用的IL代码示例MathOperation op = Add;op(5, 3);// 对应的IL指令IL_0000:  ldnullIL_0001:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(null, ...)IL_0006:  stloc.0     // 存储委托实例IL_0007:  ldloc.0IL_0008:  ldc.i4.5IL_0009:  ldc.i4.3IL_000a:  callvirt   instance int32 MathOperation::Invoke(int32, int32)\r\n八、委托最佳实践与陷阱规避\r\n\r\n事件处理的线程安全：\r\n\r\n// 推荐的事件触发模式protected virtual void OnDataChanged(DataEventArgs e) &#123;    EventHandler&lt;DataEventArgs&gt; handler = DataChanged;    if (handler != null) &#123;        // 跨线程调用时使用同步上下文        if (SynchronizationContext.Current != null) &#123;            SynchronizationContext.Current.Post(state =&gt; handler(this, e), null);        &#125; else &#123;            handler(this, e);        &#125;    &#125;&#125;\r\n\r\n避免闭包陷阱：\r\n\r\n// 错误：所有回调都会使用最后一个i值for (int i = 0; i &lt; 5; i++) &#123;    Task.Run(() =&gt; Console.WriteLine(i)); // 输出5次5&#125;// 正确：使用局部变量捕获当前i值for (int i = 0; i &lt; 5; i++) &#123;    int temp = i;    Task.Run(() =&gt; Console.WriteLine(temp)); // 输出0-4&#125;\r\n\r\n委托与接口的选择：\r\n\r\n\r\n使用委托：逻辑轻量、仅需单次调用、需要动态改变实现\r\n使用接口：逻辑复杂、需要多组相关方法、类型安全要求高\r\n\r\n总结\r\n委托作为 C# 中实现回调机制的核心特性，贯穿于事件处理、异步编程、LINQ\r\n查询等多个关键场景。掌握委托的本质不仅能帮助开发者理解框架底层机制（如事件驱动模型、TPL\r\n任务并行库），还能在设计模式和架构设计中发挥关键作用。从基础的多播委托到复杂的事件聚合，委托始终是连接松耦合组件的桥梁，是\r\nC# 开发者必须精通的核心概念之一。\r\n","categories":["学习类","C#"],"tags":["学习类","语法知识","语言方面","C#"]},{"title":"关于Lombok在高版本IDEA中注解处理不生效的问题解决","url":"/posts/42179.html","content":"环境：\r\nIntelliJ IDEA 2024.1 + Spring Boot + Maven\r\n\r\n问题描述\r\n使用Lombok中的@Data注解标注其中实体类的时候，依旧会出现找不到\r\nget set 方法的问题\r\n\r\n解决方案\r\n先从通用的解决方案说起\r\n再说到比较针对性的解决方案\r\n\r\n方式1：\r\n\r\n检查是否安装 Lombok 插件\r\n\r\n\r\nimage-20250515093928330\r\n\r\n\r\n\r\n方式2\r\n是否打开注解自动加载运行\r\n\r\n\r\nimage-20250515094349492\r\n\r\n不止默认模块，项目对应模块也要开启\r\n\r\n\r\nimage-20250515094425419\r\n\r\n\r\n方式3：\r\n修改其中的存储相对于下列位置生成的源\r\n\r\n\r\nimage-20250515094502710\r\n\r\n把需要启用注解处理的模块和默认模块中的，存储相对于下列位置生成的源，调整为模块内容根\r\n\r\n方式4：\r\n不要在项目创建时引入，而是项目创建后直接在pom.xml以&lt;dependency&gt;的方式引入\r\n&lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.30&lt;/version&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;\r\n\r\n方式5\r\n调整 Lombok 的版本\r\n给lombok注解加入1.18.30的版本号，并删除下方build中所有和lombok有关的配置。\r\n注意版本一定得是1.18.30，并且不要忘记刷新maven仓库。\r\n\r\n\r\nimage-20250515094809800\r\n\r\n\r\n方式6\r\n删除 &lt;build&gt;下所有关于 Lombok 的\r\n&lt;plugins&gt;\r\n&lt;build&gt;        &lt;plugins&gt;            &lt;!--            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;annotationProcessorPaths&gt;                        &lt;path&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/path&gt;                    &lt;/annotationProcessorPaths&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            --&gt;            &lt;!--            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            --&gt;        &lt;/plugins&gt;    &lt;/build&gt;\r\n\r\n差不多这样问题就解决了\r\nLombok 插件与版本有关那个部分，我没有看到 Lombok\r\n插件有提到限定版本，反之就 1.18.30 是可以的，高了不行，低了不行\r\n","categories":["教程","错误解决"],"tags":["教程","学习类","实用知识","Java技术","常用知识","Maven","错误解决"]},{"title":"关于微软商店弹出操作需要internet 0x800704cf","url":"/posts/10235.html","content":"在微软商店 时会遇到这样的问题，导致一些应用无法下载，会弹出\r\n操作需要internet_0x800704cf，然后阻塞。\r\n首先，进入微软商店下东西是不能开梯子的，如果连接了 VPN\r\n或下载了第三方防火墙应用，建议断开 VPN，卸载第三方防火墙应用。\r\n解决方法与步骤\r\n\r\ninternet选项： 勾选SSL3.0, TLS1.0, TLS1.1, TLS1.2, TLS1.3\r\n\r\n\r\nimage-20250604175412290\r\n\r\n\r\n\r\nimage-20250604175425807\r\n\r\n找到代理，\r\n打开自动检测设置，关闭使用设置脚本，关闭使用代理服务器\r\n\r\n\r\nimage-20250604175438908\r\n\r\n\r\n如果上述方法不行，可以采取下述\r\n\r\n按 “Windows 徽标键+X”，启动 “Windows\r\nPowerShell（管理员）”，输入以下命令，回车后重启设备：\r\n\r\nnetsh winsock reset\r\nnetsh int ip reset\r\n\r\n也是需要打开 Internet 选项，点击高级，并勾选 “使用 SSL 3.0”、”使用\r\nTLS 1.0“、”使用 TLS 1.1“、”使用 TLS\r\n1.2“，应用后重启电脑，查看能否解决问题。\r\n\r\n实在不行需要更改 DNS\r\n\r\n右键网络连接图标，选择 “打开网络和共享中心”。\r\n点击现在连接的网络名称，打开网络状态窗口，点击\r\n“属性”，在网络属性窗口中双击 “Internet 协议版本4 (TCP / IPv4)”。\r\n将 DNS 服务器手动设置为“8.8.8.8” 和 “8.8.4.4”，确定后重试。\r\n\r\n","categories":["教程","错误解决"],"tags":["教程","错误解决","使用知识"]},{"title":"关于常用六大分布的一些内容","url":"/posts/48358.html","content":"哪六大分布\r\n离散型分布\r\n\r\n两点分布 X ∼ B(1, p)\r\n二项分布 X ∼ B(n, p)\r\n泊松分布 X ∼ P(λ)\r\n\r\n连续型分布\r\n\r\n均匀分布 X ∼ U(a, b)\r\n指数分布 X ∼ E(λ)\r\n正态分布 X ∼ N(μ, σ2)\r\n\r\n之后搞一个每个分布都单开一个文章把里面所有需要搞的东西，全搞了\r\n一些公式备忘\r\n期望公式\r\n离散型随机变量的期望\r\n若随机变量 X 取值为 x1, x2, …, xn，对应概率为\r\nP(X = xi) = pi，则期望为\r\n$$\r\nE(X) = \\sum_{i=1}^{n} x_i \\cdot p_i\r\n$$\r\n连续型随机变量的期望\r\n若随机变量 X\r\n的概率密度函数为 f(x)，则期望为： E(X) = ∫−∞+∞x ⋅ f(x) dx\r\n方差公式\r\n基于期望的定义式\r\n随机变量 X\r\n的方差表示为D(X)，定义为： D(X) = E[(X − E(X))2]\r\n展开计算式\r\nD(X) = E(X2) − [E(X)]2\r\n离散型随机变量的方差\r\n$$\r\nD(X) = \\sum_{i=1}^{n} (x_i - E(X))^2 \\cdot p_i\r\n$$\r\n连续型随机变量的方差\r\nD(X) = ∫−∞+∞(x − E(X))2 ⋅ f(x) dx\r\n标准差\r\n方差的平方根为标准差，记为 σ $$\r\n\\sigma = \\sqrt{D(X)}\r\n$$\r\n两点分布\r\n定义，分布列和表示\r\n独立试验：某试验 E 重复\r\nn 次，概率上互不影响，称为\r\nn 重独立试验\r\n伯努利试验：若 n\r\n重独立试验其中一次试验只有两种结果，称为伯努利试验\r\n两点分布（Bernoulli\r\nDistribution）是描述单次伯努利试验结果的离散概率分布，其随机变量\r\nX 只有两种可能的取值：\r\n\r\nX = 1（表示”成功”），概率为 p\r\nX = 0（表示”失败”），概率为 1 − p\r\n\r\n分布列为\r\n\r\n\r\n\r\nX\r\n0\r\n1\r\n\r\n\r\n\r\n\r\nP\r\n1 − p\r\np\r\n\r\n\r\n\r\n两点分布的概率质量函数为： $$\r\nP(X = k) = \\begin{cases}\r\np &amp; \\text{如果 } k = 1 \\\\\r\n1 - p &amp; \\text{如果 } k = 0\r\n\\end{cases}\r\n$$ 或者 P(X = k) = pk(1 − p)1 − k,  k ∈ {0, 1}\r\n分布函数\r\n分布函数为： $$\r\nF(X) = \\begin{cases}\r\n0 &amp;  X &lt; 0 \\\\\r\n1 - p &amp; 0 \\leq X &lt; 1 \\\\\r\n1 &amp; x \\geq 1\r\n\\end{cases}\r\n$$ 累积分布函数为： $$\r\nF(k; n, p) = P(X \\leq k) = \\sum_{i=0}^k \\binom{n}{i} p^i (1-p)^{n-i}\r\n$$\r\n性质\r\n数字特征\r\n期望 E(X)\r\nE[X] = 1 ⋅ p + 0 ⋅ (1 − p) = p\r\n方差D(X)\r\nD(X) = E[X2] − (E[X])2 = p − p2 = p(1 − p)\r\n特征函数\r\nφ(t) = E[eitX] = 1 − p + peit\r\n二项分布\r\n定义，分布列和表示\r\n二项分布（Binomial\r\nDistribution）是描述n重伯努利试验中成功次数的离散概率分布，其随机变量\r\nX 表示在 n 次独立试验中成功的次数，取值范围为\r\nX ∈ {0, 1, 2, …, n}，则称 X\r\n服从参数 n，p 的二项分布，记为 X ∼ B(n, p)\r\n概率质量函数（PMF）： P(X = k) = Cnk pk (1 − p)n − k,  k = 0, 1, …, n\r\n其中： - n 为试验次数 - p 为每次试验的成功概率，0 ≤ p &lt; 1 - $\\binom{n}{k} = \\frac{n!}{k!(n-k)!}$\r\n是组合数\r\n当 n = 1的时候，P(X = k) = Cnk pk (1 − p)n − k  k = 0, 1，此时为两点分布，所以，二项分布为两点分布的特例。\r\n分布列：\r\n\r\n\r\n\r\nX\r\n0\r\n1\r\n⋯\r\nn\r\n\r\n\r\n\r\n\r\nP\r\n(1 − p)n\r\nnp(1 − p)n − 1\r\n⋯\r\npn\r\n\r\n\r\n\r\n分布函数\r\n累积分布函数（CDF）： $$\r\nF(k; n, p) = P(X \\leq k) = \\sum_{i=0}^k \\binom{n}{i} p^i (1-p)^{n-i}\r\n$$\r\n分步表示： $$\r\nF(x) =\r\n\\begin{cases}\r\n0 &amp; x &lt; 0 \\\\\r\n\\sum_{i=0}^{\\lfloor x \\rfloor} \\binom{n}{i} p^i (1-p)^{n-i} &amp; 0 \\leq\r\nx &lt; n \\\\\r\n1 &amp; x \\geq n\r\n\\end{cases}\r\n$$\r\n性质\r\n\r\n可加性：若 X ∼ B(n, p)，Y ∼ B(m, p)\r\n且独立，则 X + Y ∼ B(n + m, p)\r\n极限性质：当 n → ∞ 且 np\r\n固定时，二项分布近似泊松分布\r\n对称性：当 p = 0.5 时，分布关于 $\\frac{n}{2}$ 对称\r\n\r\n数字特征\r\n期望 E(X)\r\nE[X] = np\r\n方差 D(X)\r\nD(X) = np(1 − p)\r\n矩母函数\r\nM(t) = (1 − p + pet)n\r\n特征函数\r\nφ(t) = (1 − p + peit)n\r\n与其他分布的关系\r\n\r\n两点分布：当 n = 1\r\n时，二项分布退化为两点分布\r\n泊松分布：当 n → ∞，np = λ 时，B(n, p) ≈ Poisson(λ)\r\n正态分布：当 n 较大时，B(n, p) ≈ N(np, np(1 − p))（中心极限定理）\r\n\r\n应用示例\r\n案例1：抛硬币10次，正面朝上的次数 X ∼ B(10, 0.5) $$\r\nP(X=5) = \\binom{10}{5} (0.5)^5 (0.5)^5 \\approx 0.246\r\n$$\r\n案例2：生产线不良品检测，每件不良概率0.01，检测100件：\r\n$$\r\nE[X] = 100 \\times 0.01 = 1 \\\\\r\nD(X) = 100 \\times 0.01 \\times 0.99 = 0.99\r\n$$\r\nR/Python代码示例\r\n# R 语言dbinom(5, size=10, prob=0.5)  # 计算P(X=5)pbinom(5, 10, 0.5)  # 计算P(X≤5)\r\nfrom scipy.stats import binombinom.pmf(5, n=10, p=0.5)  # 计算P(X=5)binom.cdf(5, 10, 0.5)  # 计算P(X≤5)\r\n泊松分布\r\n泊松定理\r\n设 Xn ∼ B(n, pn)\r\n为服从二项分布的随机变量，其中 n 为试验次数，pn\r\n为每次试验中事件 A\r\n发生的概率。若满足： limn → ∞npn = λ  (λ &gt; 0为常数)\r\n则对任意固定的非负整数 k，有：\r\n$$\r\n\\lim_{n \\to \\infty} P(X_n = k) = \\frac{\\lambda^k}{k!} e^{-\\lambda},\\quad\r\nk = 0,1,2,\\dots\r\n$$\r\n定义，分布列和表示\r\n泊松分布（Poisson\r\nDistribution）是描述单位时间或空间内稀有事件发生次数的离散概率分布，其随机变量\r\nX\r\n表示在给定区间内事件发生的次数，取值范围为 X ∈ {0, 1, 2, …}。\r\n概率质量函数（PMF）： $$\r\nP(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}, \\quad k = 0,1,2,\\dots\r\n$$ 其中： - λ\r\n为事件的平均发生率（λ &gt; 0）\r\n- e\r\n是自然对数的底（约2.71828）\r\n用组合数表示（当作为二项分布的极限时）： $$\r\nP(X = k) = \\lim_{n \\to \\infty} C_n^k p^k (1-p)^{n-k} = \\lim_{n \\to\r\n\\infty} C_n^k \\left(\\frac{\\lambda}{n}\\right)^k\r\n\\left(1-\\frac{\\lambda}{n}\\right)^{n-k}\r\n$$\r\n分布函数\r\n分布函数（CDF）： $$\r\nF(k; \\lambda) = P(X \\leq k) = e^{-\\lambda}\\sum_{i=0}^k\r\n\\frac{\\lambda^i}{i!}\r\n$$\r\n分步表示： $$\r\nF(x) =\r\n\\begin{cases}\r\ne^{-\\lambda}\\sum_{i=0}^{\\lfloor x \\rfloor} \\frac{\\lambda^i}{i!} &amp; x\r\n\\geq 0 \\\\\r\n0 &amp; x &lt; 0\r\n\\end{cases}\r\n$$\r\n性质\r\n\r\n可加性：若 X ∼ P(λ1)，Y ∼ P(λ2)\r\n且独立，则 X + Y ∼ P(λ1 + λ2)\r\n分解性：泊松过程在子区间上的计数仍服从泊松分布\r\n稀有性：适用于发生概率小但试验次数多的事件\r\n\r\n数字特征\r\n期望 E(X)\r\nE[X] = λ\r\n方差 D(X)\r\nD(X) = λ\r\n矩母函数\r\nM(t) = eλ(et − 1)\r\n特征函数\r\nφ(t) = eλ(eit − 1)\r\n与其他分布的关系\r\n\r\n二项分布：当 n → ∞，np = λ 时，B(n, p) ≈ P(λ)\r\n正态分布：当 λ 较大时，P(λ) ≈ N(λ, λ)\r\n指数分布：泊松过程的事件间隔时间服从指数分布\r\n\r\n应用示例\r\n案例1：某路口每小时平均通过3辆车： $$\r\nP(X=5) = \\frac{3^5}{5!}e^{-3} \\approx 0.1008\r\n$$\r\n案例2：DNA序列变异检测，每1000bp平均0.1个突变：\r\n$$\r\n\\lambda = 0.1 \\\\\r\nP(X \\geq 1) = 1 - P(X=0) = 1 - e^{-0.1} \\approx 0.0952\r\n$$\r\nR/Python代码示例\r\n# R 语言dpois(5, lambda=3)  # 计算P(X=5)ppois(5, 3)  # 计算P(X≤5)\r\n# Pythonfrom scipy.stats import poissonpoisson.pmf(5, mu=3)  # 计算P(X=5)poisson.cdf(5, 3)  # 计算P(X≤5)\r\n均匀分布\r\n定义和表示\r\n均匀分布是最简单的连续型概率分布，分为离散均匀分布和连续均匀分布两种主要形式。\r\n离散型的只给出定义相关，不讨论，主要讨论连续\r\n离散均匀分布\r\n定义： 若随机变量 X 有有限个取值 {x1, x2, …, xn}，且每个取值概率相等，则称\r\nX 服从离散均匀分布，记作：\r\nX ∼ U{x1, x2, …, xn}\r\n概率质量函数（PMF）： $$\r\nP(X=x_k) = \\frac{1}{n}, \\quad k=1,2,\\dots,n\r\n$$\r\n连续均匀分布\r\n定义： 若随机变量 X 在区间 [a, b]\r\n上有恒定的概率密度，则称 X\r\n服从[a, b]上的连续均匀分布，记作：\r\nX ∼ U(a, b)\r\n概率密度函数（PDF）： $$\r\nf(x) =\r\n\\begin{cases}\r\n\\frac{1}{b-a} &amp; a \\leq x \\leq b \\\\\r\n0 &amp; \\text{其他}\r\n\\end{cases}\r\n$$\r\n标准均匀分布\r\n当 a = 0, b = 1\r\n时称为标准均匀分布 U(0, 1)，它表示在区间 [0, 1] 内每个点的取值概率 “均匀”\r\n分布，即不存在任何一个子区间的概率高于其他等长的子区间。\r\n若随机变量 (X U(0,1))，其概率密度函数为： $$\r\nf(x) =    \\begin{cases}    1, &amp; 0 \\leq x \\leq 1, \\\\   0, &amp;\r\n\\text{其他}.   \\end{cases}\r\n$$ 图像为一条在 [0, 1]\r\n区间内高度为 1、其他区间为 0 的水平线，总面积（即概率总和）为 1 × 1 = 1，符合概率公理。\r\n累积分布函数 F(x)\r\n表示 X ≤ x\r\n的概率，定义为： $$\r\nF(x) =    \\begin{cases}    0, &amp; x &lt; 0, \\\\   x, &amp; 0 \\leq x\r\n\\leq 1, \\\\   1, &amp; x &gt; 1.   \\end{cases}\r\n$$ 数学期望：$E(X) =\r\n\\int_{-\\infty}^{+\\infty} x \\cdot f(x) \\, dx = \\int_{0}^{1} x \\cdot 1 \\,\r\ndx = \\left. \\frac{x^2}{2} \\right|_0^1 = \\frac{1}{2}$\r\n方差：先计算 E(X2)：$E(X^2) = \\int_{0}^{1} x^2 \\cdot 1 \\, dx = \\left.\r\n\\frac{x^3}{3} \\right|_0^1 = \\frac{1}{3}$，再由方差公式 D(X) = E(X2) − [E(X)]2\r\n得：$D(X) = \\frac{1}{3} -\r\n\\left(\\frac{1}{2}\\right)^2 = \\frac{1}{3} - \\frac{1}{4} =\r\n\\frac{1}{12}$\r\n分布函数\r\n离散情形\r\n分布函数（CDF）： $$\r\nF(x) = \\frac{|\\{x_i \\leq x\\}|}{n}, \\quad x \\in \\mathbb{R}\r\n$$\r\n连续情形\r\n累积分布函数（CDF）： $$\r\nF(x) =\r\n\\begin{cases}\r\n0 &amp; x &lt; a \\\\\r\n\\frac{x-a}{b-a} &amp; a \\leq x &lt; b \\\\\r\n1 &amp; x \\geq b\r\n\\end{cases}\r\n$$\r\n数字特征\r\n期望 E(X)\r\n\r\n离散情形： $$\r\nE[X] = \\frac{1}{n}\\sum_{i=1}^n x_i\r\n$$\r\n连续情形： $$\r\nE[X] = \\frac{a+b}{2}\r\n$$\r\n\r\n方差 D(X)\r\n\r\n离散情形： $$\r\nD(X) = \\frac{1}{n}\\sum_{i=1}^n (x_i - \\bar{x})^2\r\n$$\r\n连续情形： $$\r\nD(X) = \\frac{(b-a)^2}{12}\r\n$$\r\n\r\n特征函数\r\n\r\n离散情形： $$\r\n\\varphi(t) = \\frac{1}{n}\\sum_{k=1}^n e^{itx_k}\r\n$$\r\n连续情形： $$\r\n\\varphi(t) = \\frac{e^{itb} - e^{ita}}{it(b-a)}\r\n$$\r\n\r\n重要性质\r\n\r\n线性变换不变性： 若 X ∼ U(a, b)，则\r\nY = cX + d ∼ U(ca + d, cb + d)（c &gt; 0）\r\n概率计算： 对于 [c, d] ⊆ [a, b]：\r\n$$\r\nP(c \\leq X \\leq d) = \\frac{d-c}{b-a}\r\n$$\r\n顺序统计量： 若 X1, …, Xn ∼ U(0, 1)，则第\r\nk 个顺序统计量 X(k) 服从 Beta\r\n分布： X(k) ∼ Beta(k, n − k + 1)\r\n\r\n应用场景\r\n\r\n随机数生成：计算机生成的伪随机数通常基于 U(0, 1)\r\n几何概率：在几何图形中随机取点的坐标分布\r\n舍入误差：测量中的舍入误差常服从均匀分布\r\n等概率抽样：问卷调查中的随机抽样\r\n\r\n与其他分布的关系\r\n\r\n与三角分布的关系： 两个独立同分布的 U(a, b)\r\n随机变量之和服从三角分布\r\n与指数分布的关系： 若 U ∼ U(0, 1)，则 $X = -\\frac{\\ln U}{\\lambda}$ 服从 Exp(λ)\r\n与正态分布的关系：\r\n通过Box-Muller变换可将两个独立的 U(0, 1) 转换为标准正态分布\r\n\r\nR/Python代码示例\r\n# R 语言示例runif(10, min=0, max=1)  # 生成10个U(0,1)随机数punif(0.3, min=0, max=1) # 计算P(X≤0.3)\r\nimport numpy as npfrom scipy.stats import uniform# 生成随机数np.random.uniform(0, 1, 10)# 计算概率uniform.cdf(0.3, loc=0, scale=1)  # P(X≤0.3)uniform.pdf(0.5, loc=0, scale=1)  # f(0.5)\r\n指数分布\r\n定义与表示\r\n指数分布是描述泊松过程中事件间隔时间的连续概率分布，其随机变量\r\nX\r\n表示独立事件发生的间隔时间，取值范围为 X ∈ [0, ∞)。\r\n概率密度函数（PDF）： $$\r\nf(x) =\r\n\\begin{cases}\r\n\\lambda e^{-\\lambda x} &amp; x \\geq 0 \\\\\r\n0 &amp; x &lt; 0\r\n\\end{cases}\r\n$$ 其中： - λ &gt; 0\r\n为率参数（单位时间事件发生次数），常数 - 期望值 $E[X] = \\frac{1}{\\lambda}$\r\n则称 X 服从参数为 λ 的指数分布，记为 X ∼ E(λ)\r\n标准形式（当 λ = 1 时）： f(x) = e−x,  x ≥ 0\r\n分布函数\r\n累积分布函数（CDF）： $$\r\nF(x;\\lambda) =\r\n\\begin{cases}\r\n1 - e^{-\\lambda x} &amp; x \\geq 0 \\\\\r\n0 &amp; x &lt; 0\r\n\\end{cases}\r\n$$\r\n生存函数： S(x) = 1 − F(x) = e−λx,  x ≥ 0\r\n数字特征\r\n期望 E(X)\r\n$$\r\nE[X] = \\frac{1}{\\lambda}\r\n$$\r\n方差 D(X)\r\n$$\r\nD(X) = \\frac{1}{\\lambda^2}\r\n$$\r\n偏度\r\nSkewness = 2\r\n峰度\r\nKurtosis = 6\r\n矩母函数\r\n$$\r\nM(t) = \\frac{\\lambda}{\\lambda - t}, \\quad t &lt; \\lambda\r\n$$\r\n特征函数\r\n$$\r\n\\varphi(t) = \\frac{\\lambda}{\\lambda - it}\r\n$$\r\n重要性质\r\n\r\n无记忆性（Memoryless Property）： P(X &gt; s + t ∣ X &gt; s) = P(X &gt; t),  ∀s, t &gt; 0\r\n这是指数分布的标志性特征\r\n与泊松分布的关系：\r\n\r\n若单位时间内事件发生次数 N ∼ Poisson(λ)\r\n则事件间隔时间 X ∼ Exp(λ)\r\n\r\n几何分布的连续类比：\r\n指数分布是连续情形下的”几何分布”\r\n\r\n应用场景\r\n\r\n生存分析：设备寿命建模\r\n排队论：顾客到达间隔时间\r\n可靠性工程：电子元件失效时间\r\n金融：极端事件发生间隔\r\n\r\n与其他分布的关系\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n关系\r\n说明\r\n\r\n\r\n\r\n\r\n泊松过程\r\n间隔时间 ∼ 指数分布 ⇔ 计数 ∼\r\n泊松分布\r\n\r\n\r\nGamma分布\r\nn 个独立指数分布的和 ∼ Gamma(n, λ)\r\n\r\n\r\n几何分布\r\n离散时间的指数分布类比\r\n\r\n\r\nWeibull分布\r\n指数分布是 Weibull 分布 (k = 1) 的特例\r\n\r\n\r\n\r\nR/Python代码示例\r\n# R 语言示例rexp(10, rate=0.5)  # 生成10个Exp(0.5)随机数pexp(2, rate=0.5)   # 计算P(X≤2)\r\n# Python 示例import numpy as npfrom scipy.stats import expon# 生成随机数np.random.exponential(scale=1/0.5, size=10)  # scale=1/λ# 计算概率expon.cdf(2, scale=1/0.5)  # P(X≤2)expon.pdf(1, scale=1/0.5)   # f(1)\r\n参数估计\r\n给定样本 x1, ..., xn：\r\n极大似然估计： $$\r\n\\hat{\\lambda} = \\frac{n}{\\sum_{i=1}^{n} x_i} = \\frac{1}{\\bar{x}}\r\n$$ 矩估计： $$\r\n\\hat{\\lambda} = \\frac{1}{\\bar{x}}\r\n$$\r\n正态分布（Normal\r\nDistribution）\r\n定义与表示\r\n正态分布（又称高斯分布）是连续概率分布中最重要的分布，其随机变量\r\nX 取值范围为 X ∈ (−∞, +∞)。\r\n概率密度函数（PDF）： $$\r\n\\Large f(x) =\r\n\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\r\n$$ 其中： - μ\r\n为位置参数（均值） - σ &gt; 0 为尺度参数（标准差）\r\n标准正态分布\r\n标准正态分布（μ = 0, σ = 1）：\r\n$$\r\n\\Large \\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\r\n$$\r\n如何将一个正态分布标准化：\r\n将一个普通正态分布 X ∼ N(μ, σ2)\r\n转换为标准正态分布 Z ∼ N(0, 1)\r\n的过程称为标准化。\r\n标准化公式 $$\r\nZ = \\frac {X - \\mu}{\\sigma}\r\n$$ 其中：\r\n\r\nμ 是原分布的均值\r\nσ 是原分布的标准差（σ &gt; 0）\r\n\r\n标准化的性质\r\n均值 E[Z] = 0\r\n方差 Var(Z) = 1\r\n概率密度函数 $$\r\n\\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\r\n$$\r\n为什么要将一个正态分布标准化\r\n统计推断基础\r\n\r\n假设检验：Z检验/t检验都依赖标准化统计量 $$\r\nZ = \\frac{\\bar{X}-\\mu_0}{\\sigma/\\sqrt{n}}\r\n$$\r\n置信区间：95%置信区间构建基于标准正态分位数\r\n$$\r\n\\bar{X} \\pm 1.96\\frac{\\sigma}{\\sqrt{n}}\r\n$$\r\n\r\n中心极限定理：证明样本均值标准化后收敛于N(0, 1)\r\n​\r\n实际例子\r\n案例：某考试分数 X ∼ N(75, 102)，求分数高于90分的概率。\r\n解法：\r\n\r\n标准化：\r\n$Z = \\frac{90 - 75}{10} =\r\n1.5$\r\n查标准正态分布表：\r\nP(X &gt; 90) = P(Z &gt; 1.5) = 1 − Φ(1.5) ≈ 0.0668\r\n\r\n分布函数\r\n累积分布函数（CDF）： $$\r\n\\Phi(x;\\mu,\\sigma) = \\frac{1}{2}\\left[1 +\r\n\\text{erf}\\left(\\frac{x-\\mu}{\\sigma\\sqrt{2}}\\right)\\right]\r\n$$ 其中 erf 为误差函数： $$\r\n\\text{erf}(x) = \\frac{2}{\\sqrt{\\pi}}\\int_0^x e^{-t^2}dt\r\n$$\r\n分位函数： Φ−1(p; μ, σ) = μ + σΦ−1(p; 0, 1)\r\n数字特征\r\n期望 E(X)\r\nE[X] = μ\r\n方差 D(X)\r\nD(X) = σ2\r\n偏度\r\nSkewness = 0\r\n峰度\r\nKurtosis = 3\r\n矩母函数\r\n$$\r\nM(t) = e^{\\mu t + \\frac{\\sigma^2 t^2}{2}}\r\n$$\r\n特征函数\r\n$$\r\n\\varphi(t) = e^{i\\mu t - \\frac{\\sigma^2 t^2}{2}}\r\n$$\r\n重要性质\r\n\r\n线性变换不变性： 若 X ∼ N(μ, σ2)，设\r\nY = aX + b，则$\r\nY $依旧满足正态分布\r\n则Y ∼ N(aμ + b, a2σ2)\r\n曲线性质：\r\nμ决定曲线的对称轴的位置\r\nσ 决定曲线的陡峭程度（σ\r\n越小，数据越集中，曲线越陡峭，σ\r\n越大，数据越分散，曲线越平缓）\r\n可加性： 独立正态变量的和仍服从正态分布： X ∼ N(μ1, σ12), Y ∼ N(μ2, σ22) ⇒ X + Y ∼ N(μ1 + μ2, σ12 + σ22)\r\n中心极限定理：\r\n独立同分布随机变量和的标准化形式依分布收敛于标准正态分布\r\n3σ准则： $$\r\nP(|X-\\mu| \\leq \\sigma) \\approx 0.6827 \\\\\r\nP(|X-\\mu| \\leq 2\\sigma) \\approx 0.9545 \\\\\r\nP(|X-\\mu| \\leq 3\\sigma) \\approx 0.9973\r\n$$\r\n\r\n参数估计\r\n极大似然估计（MLE）\r\n给定样本 x1, ..., xn：\r\n\r\n均值估计： $$\r\n\\hat{\\mu} = \\bar{x} = \\frac{1}{n}\\sum_{i=1}^n x_i\r\n$$\r\n方差估计： $$\r\n\\hat{\\sigma}^2 = \\frac{1}{n}\\sum_{i=1}^n (x_i - \\bar{x})^2\r\n$$\r\n\r\n性质： - μ̂\r\n是无偏估计\r\n\r\nσ̂2\r\n是有偏估计（修正为 $s^2 =\r\n\\frac{n}{n-1}\\hat{\\sigma}^2$ 后无偏）\r\n\r\n矩估计\r\n\r\n一阶矩： μ̂ = x̄\r\n二阶中心矩： $$\r\n\\hat{\\sigma}^2 = \\frac{1}{n}\\sum_{i=1}^n (x_i - \\bar{x})^2\r\n$$\r\n\r\n贝叶斯估计\r\n假设先验分布： - μ ∼ N(μ0, τ2)\r\n- σ2 ∼ Inv-Gamma(α, β)\r\n后验分布： p(μ, σ2|x) ∝ p(x|μ, σ2)p(μ)p(σ2)\r\n假设检验\r\n均值检验\r\n\r\n单样本Z检验（σ已知）： $$\r\nZ = \\frac{\\bar{x}-\\mu_0}{\\sigma/\\sqrt{n}} \\sim N(0,1)\r\n$$\r\n单样本t检验（σ未知）： $$\r\nt = \\frac{\\bar{x}-\\mu_0}{s/\\sqrt{n}} \\sim t_{n-1}\r\n$$\r\n\r\n方差检验\r\n卡方检验： $$\r\n\\chi^2 = \\frac{(n-1)s^2}{\\sigma_0^2} \\sim \\chi_{n-1}^2\r\n$$\r\nR/Python代码示例\r\n```r # R 语言示例 rnorm(10, mean=0, sd=1) # 生成10个N(0,1)随机数\r\npnorm(1.96) # 计算Φ(1.96) qnorm(0.975) # 计算Φ^{-1}(0.975)\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","知识总结","概率论与数理统计"]},{"title":"无偏估计性与估计有效程度比较的例题解析","url":"/posts/20606.html","content":"\r\n问题重述\r\n我们需要证明样本方差 $S^2 = \\frac{1}{n-1}\r\n\\sum_{i=1}^{n} (X_i - \\overline{X})^2$ 是总体方差 σ2 = D(X)\r\n的无偏估计量。即证明 E[S2] = σ2。\r\n证明步骤\r\n\r\n设定和已知条件：\r\n\r\n总体 X 的均值 E(X) = μ，方差\r\nD(X) = σ2 &lt; ∞。\r\n样本 X1, X2, …, Xn\r\n是独立同分布（i.i.d.）的，与 X\r\n同分布。\r\n样本均值 $\\overline{X} = \\frac{1}{n}\r\n\\sum_{i=1}^{n} X_i$。\r\n\r\n展开样本方差：\r\n$$\r\nS^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline{X})^2\r\n$$\r\n我们首先将 $(X_i - \\overline{X})$\r\n表示为 $(X_i - \\mu) - (\\overline{X} -\r\n\\mu)$：\r\n$$\r\n(X_i - \\overline{X}) = (X_i - \\mu) - (\\overline{X} - \\mu)\r\n$$\r\n然后平方：\r\n$$\r\n(X_i - \\overline{X})^2 = (X_i - \\mu)^2 - 2(X_i - \\mu)(\\overline{X} -\r\n\\mu) + (\\overline{X} - \\mu)^2\r\n$$\r\n求和并取期望：\r\n$$\r\n\\sum_{i=1}^{n} (X_i - \\overline{X})^2 = \\sum_{i=1}^{n} (X_i - \\mu)^2 -\r\n2\\sum_{i=1}^{n} (X_i - \\mu)(\\overline{X} - \\mu) + n(\\overline{X} -\r\n\\mu)^2\r\n$$\r\n现在对两边取期望：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} (X_i - \\overline{X})^2 \\right] = \\sum_{i=1}^{n}\r\nE\\left[ (X_i - \\mu)^2 \\right] - 2E\\left[ \\sum_{i=1}^{n} (X_i -\r\n\\mu)(\\overline{X} - \\mu) \\right] + nE\\left[ (\\overline{X} - \\mu)^2\r\n\\right]\r\n$$\r\n计算各项期望：\r\n\r\n第一项：\r\nE[(Xi − μ)2] = D(Xi) = σ2  对所有\r\ni\r\n所以：\r\n$$\r\n\\sum_{i=1}^{n} E\\left[ (X_i - \\mu)^2 \\right] = n\\sigma^2\r\n$$\r\n第二项： 注意到 $\\overline{X} - \\mu =\r\n\\frac{1}{n} \\sum_{j=1}^{n} (X_j - \\mu)$，所以：\r\n$$\r\n\\sum_{i=1}^{n} (X_i - \\mu)(\\overline{X} - \\mu) = \\sum_{i=1}^{n} (X_i -\r\n\\mu) \\cdot \\frac{1}{n} \\sum_{j=1}^{n} (X_j - \\mu) = \\frac{1}{n} \\left(\r\n\\sum_{i=1}^{n} (X_i - \\mu) \\right)^2\r\n$$\r\n因此：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} (X_i - \\mu)(\\overline{X} - \\mu) \\right] =\r\n\\frac{1}{n} E\\left[ \\left( \\sum_{i=1}^{n} (X_i - \\mu) \\right)^2 \\right]\r\n= \\frac{1}{n} \\cdot n\\sigma^2 = \\sigma^2\r\n$$\r\n（因为 $\\sum_{i=1}^{n} (X_i - \\mu)$\r\n的方差是 nσ2）\r\n第三项：\r\n$$\r\nE\\left[ (\\overline{X} - \\mu)^2 \\right] = D(\\overline{X}) =\r\n\\frac{\\sigma^2}{n}\r\n$$\r\n\r\n代入期望值：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} (X_i - \\overline{X})^2 \\right] = n\\sigma^2 -\r\n2\\sigma^2 + n \\cdot \\frac{\\sigma^2}{n} = n\\sigma^2 - 2\\sigma^2 +\r\n\\sigma^2 = (n-1)\\sigma^2\r\n$$\r\n因此：\r\n$$\r\nE[S^2] = E\\left[ \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline{X})^2\r\n\\right] = \\frac{1}{n-1} \\cdot (n-1)\\sigma^2 = \\sigma^2\r\n$$\r\n这表明 S2 是\r\nσ2\r\n的无偏估计。\r\n\r\n矩估计 Ŝ2 的有偏性\r\n矩估计 $\\hat{S}^2 = \\frac{1}{n}\r\n\\sum_{i=1}^{n} (X_i - \\overline{X})^2$ 的期望：\r\n$$\r\nE[\\hat{S}^2] = E\\left[ \\frac{n-1}{n} S^2 \\right] = \\frac{n-1}{n} E[S^2]\r\n= \\frac{n-1}{n} \\sigma^2\r\n$$\r\n因此，Ŝ2\r\n是有偏的，偏差为 $-\\frac{\\sigma^2}{n}$。但当 n → ∞，E[Ŝ2] → σ2，所以它是渐近无偏的。\r\n无偏估计的多样性\r\n对于总体均值 μ\r\n的无偏估计，任何形如 $\\sum_{i=1}^{n} c_i\r\nX_i$ 且 $\\sum_{i=1}^{n} c_i = 1$\r\n的估计量都是无偏的：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} c_i X_i \\right] = \\sum_{i=1}^{n} c_i E[X_i] = \\mu\r\n\\sum_{i=1}^{n} c_i = \\mu\r\n$$\r\n这表明无偏估计不唯一，样本均值 $\\overline{X}$ 是其中一种特例（$c_i = \\frac{1}{n}$）。\r\n结论\r\n\r\n样本方差 S2\r\n是总体方差 σ2\r\n的无偏估计。\r\n矩估计 Ŝ2\r\n是有偏的，但渐近无偏。\r\n无偏估计不唯一，可以通过不同方式构造。\r\n\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计","定理证明"]},{"title":"参数估计之区间估计","url":"/posts/9946.html","content":"区间估计\r\n什么是区间估计\r\n上一篇文章中我们理解了什么是点估计，这次就是参数估计的另一种估计方式，区间估计。\r\n由于点估计忽略了抽样波动性，为了更全面地反映参数估计的可靠性，我们引入区间估计\r\n和理解点估计一样，区间估计就是估计未知参数θ的可能取值范围和这个范围包含该未知参数θ的可信程度，这个范围就是区间估计的估计内容\r\n区间估计不仅给出一个中心点，还给出了一个上下界，使得该区间在一定的置信水平下包含真实参数值。例如，当我们计算出某总体均值的95%置信区间为[a, b]时，可以理解为在相同抽样条件下重复实验，约有95%的构造出的区间会包含总体均值。\r\n具体说，区间估计是统计学中用来估计未知参数（比如均值、比例等）的一种方法。它不像点估计那样只给出一个具体的数值（比如“平均身高是170cm”），而是给出一个范围（比如“平均身高在168cm到172cm之间”），并说明这个范围的可信程度（比如“有95%的把握”）。\r\n构造步骤\r\n以单个正态总体均值的区间估计为例，构造置信区间通常包括以下步骤：\r\n\r\n若总体服从正态分布，则样本均值 $\\overline x$\r\n的抽样分布为正态分布；当总体方差未知且样本量较小时，则服从 $t\r\n$分布。\r\n然后确定置信水平，\r\n例如设定置信水平为 95%，对应的显著性水平 α = 0.05\r\n查找临界值\r\n当总体方差已知时，根据标准正态分布查找 zα/2，若未知，则根据\r\nt 分布查找，tn − 1; α/2\r\n构造区间\r\n总体均值（已知总体方差）的双侧置信区间： $$\r\n\\left( \\bar{x} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}},\\bar{x} +\r\nz_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\right)\r\n$$ 总体均值（未知总体方差）的双侧置信区间：\r\n\r\n$$\r\n\\left( \\bar{x} - t_{n - 1;\\alpha/2} \\frac{s}{\\sqrt{n}},\\bar{x} + t_{n -\r\n1;\\alpha/2} \\frac{s}{\\sqrt{n}} \\right)\r\n$$\r\n其中 $s$ 为样本标准差，$n$ 为样本容量\r\n置信区间与置信水平的定义\r\n设总体 X 的分布函数为 F(x; θ)，其中\r\nθ 是未知参数，(X1, X2, ⋯, Xn)\r\n为 X 的样本。给定 α（0 &lt; α &lt; 1），若统计量 $\\underline{\\theta} = \\underline{\\theta}(X_1,\r\nX_2,  \\cdots, X_n)$ 和 $\\overline{\\theta} = \\overline{\\theta}(X_1, X_2,\r\n\\cdots, X_n)$ 满足 $$\r\nP(\\underline{\\theta} &lt; \\theta &lt; \\overline{\\theta}) = 1 - \\alpha\r\n$$ 则称区间 $(\\underline{\\theta},\r\n\\overline{\\theta})$ 是 θ 的置信水平为 1 − α\r\n的置信区间，$\\underline{\\theta}$ 和 $\\overline{\\theta}$\r\n分别称为置信下限和置信上限，1 − α\r\n称为置信水平。\r\n如何理解置信区间\r\n值得注意的是，区间 $(\\underline{\\theta},\r\n\\overline{\\theta})$ 的上、下限都是统计量，故称 $(\\underline{\\theta}, \\overline{\\theta})$\r\n为随机区间。随着样本观测值的不同，随机区间 $(\\underline{\\theta}, \\overline{\\theta})$\r\n会产生不同的具体区间。\r\n上式$P(\\underline{\\theta} &lt; \\theta &lt;\r\n\\overline{\\theta}) = 1 - \\alpha$的意义是：\r\n\r\n随机区间 $(\\underline{\\theta}, \\overline{\\theta})$\r\n包含 θ 真值的概率为 1 − α，而不是 θ 的真值落在区间 $(\\underline{\\theta},  \\overline{\\theta})$\r\n内的概率为 1 − α\r\n换句话说，如果反复抽样多次（每次样本容量均为 n），每个样本观测值都会确定一个区间\r\n$(\\underline{\\theta},\r\n\\overline{\\theta})$，其中有的区间包含 θ 的真值，有的不包含。\r\n根据伯努利大数定律，在大量重复抽样下，大约有 100(1 − α) 的区间会包含 θ 的真值，而 100α 的区间不会包含。\r\n\r\n举例说明：\r\n\r\n若 α = 0.05，反复抽样\r\n1000 次，则大约有 950 个区间包含 θ 的真值，50 个区间不包含。\r\n但对于某一个具体的区间（如某次抽样得到的 [a, b]），我们不能说“θ 有 95 的概率落在这个区间内”，因为 θ\r\n是固定值，只能说“这个区间属于那些有 95\r\n置信度包含 θ\r\n的区间之一”。\r\n\r\n感觉说的依旧不太清晰，我重新说一下\r\n什么是随机区间？\r\n\r\n$\\underline{\\theta}$ 和 $\\overline{\\theta}$\r\n是由样本计算得到的统计量（如样本均值X̄、样本标准差S等），因此 $(\\underline{\\theta}, \\overline{\\theta})$\r\n是一个随机区间（每次抽样结果不同）。\r\n举例： 假设我们估计全校学生的平均身高μ，每次随机抽100人计算：\r\n\r\n第1次抽样：X̄1 = 168，得到区间(165, 171)\r\n第2次抽样：X̄2 = 170，得到区间(167, 173)\r\n… 这些区间会因样本不同而变化，但大约95的区间会包含真实μ（假设置信水平1 − α = 95）。\r\n\r\n\r\n置信水平1 − α的含义\r\n\r\n正确理解：\r\n$P(\\underline{\\theta} &lt; \\theta &lt;\r\n\\overline{\\theta}) = 1-\\alpha$ 表示：\r\n在无数次重复抽样中，100(1 − α)的区间会覆盖真实参数θ，而不是θ有1 − α的概率落在当前区间内（因为θ是固定值，不是随机变量）。\r\n类比：\r\n想象你用渔网（置信区间）捞鱼（真实参数θ）：\r\n\r\n如果渔网有95的捕获率（1 − α = 0.95），意味着长期来看，撒网100次大约有95次能捞到鱼。\r\n但某一次撒网后，鱼要么在网里（100%），要么不在（0%），不能说“鱼有95%的概率在网里”。\r\n\r\n\r\n举例说明（α = 0.05）\r\n\r\n重复抽样100次：\r\n理论上，大约95次计算出的区间会包含真实θ，5次不包含。\r\n\r\n例如：估计某药品的有效率θ，100次实验得到95个区间包含真实值（如(0.6, 0.8)），5个区间不包含（如(0.4, 0.6)）。\r\n\r\n单次区间的解释： 如果你得到一个具体区间(0.65, 0.75)，只能说：\r\n\r\n“这个区间是通过一个方法生成的，而该方法有95的可靠性覆盖真实值”， 而不是“θ有95的概率在(0.65, 0.75)内”。\r\n\r\n\r\n为什么不能对单个区间谈概率？\r\n\r\nθ是固定参数（如全校平均身高μ = 169cm），而区间是随机的。\r\n类比： 你测量一块石头的重量θ，用天平测10次得到10个区间。\r\n\r\n石头重量θ是固定的，但测量区间会波动。\r\n只能说“我的测量方法有95的置信度包含真实重量”，而不是“θ有95的概率在某个区间内”。\r\n\r\n\r\n单个正态总体的区间估计\r\n我们主要介绍枢轴量法，统计量法懒得写了\r\n单个正态总体均值的区间估计\r\n设已给定置信水平为 1 − α,\r\n并设 (X1, X2, ⋯, Xn)\r\n是总体 N(μ, σ2)\r\n的样本. X̄ 和 S2\r\n分别是样本均值和样本方差. 对总体均值作区间估计, 分总体方差 σ2\r\n已知和未知两种情况.\r\nσ2\r\n已知\r\n推导步骤\r\n首先构建统计量\r\n样本均值$\\bar{X} = \\frac{1}{n}\\sum_{i=1}^n\r\nX_i$服从正态分布，所以随机变量 $$\r\n\\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{n}\\right)\r\n$$\r\n将其标准化得到U统计量：\r\n$$\r\nU = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\sim N(0,1)\r\n$$\r\n对于给定的显著性水平α，查标准正态分布表得到uα/2，满足：\r\n$$\r\nP\\left( |U| \\geq u_{\\frac{\\alpha}{2}} \\right) = P\\left( \\left|\r\n\\frac{\\bar{X} - \\mu}{\\sigma} \\sqrt{n} \\right| \\geq u_{\\frac{\\alpha}{2}}\r\n\\right) = \\alpha \\tag{7.9}\r\n$$\r\n\r\n\r\nimage-20250626094043358\r\n\r\n等价于： P(−uα/2 ≤ U ≤ uα/2) = 1 − α\r\n将U的表达式代入： $$\r\nP\\left(-u_{\\alpha/2} \\leq \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\leq\r\nu_{\\alpha/2}\\right) = 1 - \\alpha\r\n$$\r\n解这个不等式：\r\n\r\n两边乘以$\\sigma/\\sqrt{n}$：\r\n$$\r\nP\\left(-\\frac{\\sigma}{\\sqrt{n}}u_{\\alpha/2} \\leq \\bar{X} - \\mu \\leq\r\n\\frac{\\sigma}{\\sqrt{n}}u_{\\alpha/2}\\right) = 1 - \\alpha\r\n$$\r\n移项得到μ的范围： $$\r\nP\\left(\\bar{X} - \\frac{\\sigma}{\\sqrt{n}}u_{\\alpha/2} \\leq \\mu \\leq\r\n\\bar{X} + \\frac{\\sigma}{\\sqrt{n}}u_{\\alpha/2}\\right) = 1 - \\alpha\r\n$$\r\n\r\n所以，(7.9) 式等价于 $$\r\nP\\left( \\bar{X} - \\frac{\\sigma}{\\sqrt{n}} u_{\\alpha/2} &lt; \\mu &lt;\r\n\\bar{X} + \\frac{\\sigma}{\\sqrt{n}} u_{\\alpha/2} \\right) = 1 - \\alpha,\r\n$$ 由此得到 μ\r\n的置信水平为 1 − α (简称 1 − α) 的置信区间为 $$\r\n\\left( \\bar{X} - \\frac{\\sigma}{\\sqrt{n}} u_{\\alpha/2},\\ \\bar{X} +\r\n\\frac{\\sigma}{\\sqrt{n}} u_{\\alpha/2} \\right). \\tag{7.10}\r\n$$\r\n实际计算步骤\r\n\r\n计算样本均值： $$\r\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^n x_i\r\n$$\r\n查表得到uα/2值（例如α = 0.05时，u0.025 = 1.96）\r\n代入公式计算上下限：\r\n\r\n下限：$\\bar{x} -\r\n\\frac{\\sigma}{\\sqrt{n}}u_{\\alpha/2}$\r\n上限：$\\bar{x} +\r\n\\frac{\\sigma}{\\sqrt{n}}u_{\\alpha/2}$\r\n\r\n\r\nσ2\r\n未知\r\n推导过程\r\n此时不能采用上面的式子给出的区间，因为其中含未知参数 σ。\r\n由于 S2 是 σ2的无偏估计，当总体方差σ2未知时，无法直接使用Z统计量： $$\r\nZ = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\sim N(0,1)\r\n$$ 因为公式中含未知参数σ。\r\n所以，用样本标准差S替代σ，构造t统计量： $$\r\nt = \\frac{\\bar{X} - \\mu}{S/\\sqrt{n}} \\sim t(n-1)\r\n$$ 其中： - $S^2 =\r\n\\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\bar{X})^2$是样本方差 - t(n − 1)表示自由度为n − 1的t分布\r\n确定临界值\r\n对给定 α(0 &lt; α &lt; 1), 查\r\nt 分布表, 可得 t(n − 1) 分布的双侧分位数\r\ntα/2(n − 1),\r\n使得 P(|t| ≥ tα/2(n − 1)) = α\r\n即： P(|t| &lt; tα/2(n − 1)) = 1 − α\r\nP(−tα/2(n − 1) &lt; t &lt; tα/2(n − 1)) = 1 − α\r\n\r\n\r\nimage-20250626100334605\r\n\r\n现在就可以开始具体的置信区间的推导了\r\n将t统计量表达式代入： $$\r\nP\\left(-t_{\\alpha/2}(n-1) &lt; \\frac{\\bar{X} - \\mu}{S/\\sqrt{n}} &lt;\r\nt_{\\alpha/2}(n-1)\\right) = 1 - \\alpha\r\n$$\r\n逐步解这个不等式： 1. 乘以$S/\\sqrt{n}$： $$\r\n   P\\left(-\\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1) &lt; \\bar{X} - \\mu &lt;\r\n\\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1)\\right) = 1 - \\alpha\r\n   $$\r\n\r\n移项得到μ的范围： $$\r\nP\\left(\\bar{X} - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1) &lt; \\mu &lt;\r\n\\bar{X} + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1)\\right) = 1 - \\alpha\r\n$$\r\n\r\n最终，μ的置信水平为1 − α的置信区间为： $$\r\n\\left( \\bar{X} - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1),\\ \\bar{X} +\r\n\\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1) \\right)\r\n$$\r\n实际上计算步骤\r\n\r\n计算样本统计量： $$\r\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^n x_i,\\quad s =\r\n\\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (x_i - \\bar{x})^2}\r\n$$\r\n查t分布表得临界值tα/2(n − 1)\r\n计算置信区间：\r\n\r\n下限：$\\bar{x} -\r\n\\frac{s}{\\sqrt{n}}t_{\\alpha/2}(n-1)$\r\n上限：$\\bar{x} +\r\n\\frac{s}{\\sqrt{n}}t_{\\alpha/2}(n-1)$\r\n\r\n\r\n单个正态总体方差的区间估计\r\nμ 未知\r\n设总体 X ∼ N(μ, σ2)，(X1, X2, ⋯, Xn)\r\n是 X 的样本。对总体方差 σ2 作区间估计，同样分成\r\nμ 已知和未知两种情形。\r\n此处，根据实际情况的需要，只讨论 μ 未知的情况。\r\n设总体X ∼ N(μ, σ2)，样本为(X1, X2, ⋯, Xn)，置信水平为1 − α。\r\n为什么根据实际情况的需要这里只讨论μ 未知的情况\r\n\r\n因为在绝大多数实际问题中，总体均值μ和方差σ2同时未知才是常态。例如：\r\n\r\n测量某零件的尺寸误差（μ和σ2均需估计）\r\n分析某地区居民收入分布（均值和方差都需要从样本推断）\r\n\r\nμ已知的情况在现实中非常罕见（除非进行仿真实验或理论推导）\r\nμ已知的情况可通过替换X̄→μ直接推导\r\n\r\n推导过程\r\n首先先构造统计量\r\n由样本方差$S^2 = \\frac{1}{n-1}\\sum_{i=1}^n\r\n(X_i - \\bar{X})^2$，构造卡方统计量： $$\r\n\\chi^2 = \\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)\r\n$$\r\n确定临界值\r\n对于给定的α，查χ2分布表得： -\r\n下侧分位数χ1 − α/22(n − 1)\r\n- 上侧分位数χα/22(n − 1)\r\n满足： $$\r\nP\\left(\\chi^2_{1-\\alpha/2}(n-1) &lt; \\frac{(n-1)S^2}{\\sigma^2} &lt;\r\n\\chi^2_{\\alpha/2}(n-1)\\right) = 1-\\alpha\r\n$$\r\n\r\n\r\nimage-20250626101211666\r\n\r\n推导置信区间\r\n解不等式： 1. 不等式变形： $$\r\n   \\chi^2_{1-\\alpha/2}(n-1) &lt; \\frac{(n-1)S^2}{\\sigma^2} &lt;\r\n\\chi^2_{\\alpha/2}(n-1)\r\n   $$\r\n\r\n取倒数（注意不等号方向变化）： $$\r\n\\frac{1}{\\chi^2_{1-\\alpha/2}(n-1)} &gt; \\frac{\\sigma^2}{(n-1)S^2} &gt;\r\n\\frac{1}{\\chi^2_{\\alpha/2}(n-1)}\r\n$$\r\n乘以(n − 1)S2：\r\n$$\r\n\\frac{(n-1)S^2}{\\chi^2_{1-\\alpha/2}(n-1)} &gt; \\sigma^2 &gt;\r\n\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)}\r\n$$\r\n\r\n而且χα/22(n − 1)和χ1 − α/22(n − 1)的值都可以通过查χ2(n − 1)的分布表得到\r\n所以有 $$\r\nP\\left( \\frac{(n - 1)S^2}{\\chi^2_{\\alpha/2}(n - 1)} &lt; \\sigma^2 &lt;\r\n\\frac{(n - 1)S^2}{\\chi^2_{1 - \\alpha/2}(n - 1)} \\right) = 1 - \\alpha.\r\n$$ 因此方差σ2的一个置信水平为1 − α的置信区间为： $$\r\n\\left( \\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)},\\\r\n\\frac{(n-1)S^2}{\\chi^2_{1-\\alpha/2}(n-1)} \\right)\r\n$$\r\n对σ2区间取平方根，可以得到标准差σ的一个置信水平为1 − α的置信区间 $$\r\n\\left( \\frac{\\sqrt{n-1}S}{\\sqrt{\\chi^2_{\\alpha/2}(n-1)}},\\\r\n\\frac{\\sqrt{n-1}S}{\\sqrt{\\chi^2_{1-\\alpha/2}(n-1)}} \\right)\r\n$$\r\n实际计算步骤\r\n\r\n计算样本方差： $$\r\ns^2 = \\frac{1}{n-1}\\sum_{i=1}^n (x_i - \\bar{x})^2\r\n$$\r\n查χ2分布表：\r\n\r\nχα/22(n − 1)（右侧临界值）\r\nχ1 − α/22(n − 1)（左侧临界值）\r\n\r\n计算置信区间：\r\n\r\n方差区间： $$\r\n\\left( \\frac{(n-1)s^2}{\\chi^2_{\\alpha/2}(n-1)},\\\r\n\\frac{(n-1)s^2}{\\chi^2_{1-\\alpha/2}(n-1)} \\right)\r\n$$\r\n标准差区间： $$\r\n\\left( \\sqrt{\\frac{(n-1)s^2}{\\chi^2_{\\alpha/2}(n-1)}},\\\r\n\\sqrt{\\frac{(n-1)s^2}{\\chi^2_{1-\\alpha/2}(n-1)}} \\right)\r\n$$\r\n\r\n\r\nμ 已知\r\n想了一下μ已知的情况，也算一下得了，要不然总感觉怪怪的\r\n设总体X ∼ N(μ, σ2)，其中μ已知，(X1, X2, ⋯, Xn)为样本，置信水平为1 − α。\r\n推导过程\r\n构建统计量\r\n定义真实离差平方和： $$\r\nQ = \\sum_{i=1}^n (X_i - \\mu)^2\r\n$$\r\n由于Xi ∼ N(μ, σ2)，标准化后有：\r\n$$\r\n\\frac{X_i - \\mu}{\\sigma} \\sim N(0,1) \\quad \\Rightarrow \\quad\r\n\\left(\\frac{X_i - \\mu}{\\sigma}\\right)^2 \\sim \\chi^2(1)\r\n$$\r\n根据卡方分布的可加性： $$\r\n\\chi^2 = \\frac{Q}{\\sigma^2} = \\sum_{i=1}^n \\left(\\frac{X_i -\r\n\\mu}{\\sigma}\\right)^2 \\sim \\chi^2(n)\r\n$$\r\n确定临界值\r\n对于给定的α，查χ2分布表得：\r\n\r\n下侧分位数χ1 − α/22(n)\r\n上侧分位数χα/22(n)\r\n\r\n满足概率等式： $$\r\nP\\left(\\chi^2_{1-\\alpha/2}(n) &lt; \\frac{Q}{\\sigma^2} &lt;\r\n\\chi^2_{\\alpha/2}(n)\\right) = 1-\\alpha\r\n$$\r\n推导置信区间 解关于σ2的不等式：\r\n\r\n原始不等式： $$\r\n\\chi^2_{1-\\alpha/2}(n) &lt; \\frac{\\sum (X_i - \\mu)^2}{\\sigma^2} &lt;\r\n\\chi^2_{\\alpha/2}(n)\r\n$$\r\n取倒数（注意不等号方向变化）： $$\r\n\\frac{1}{\\chi^2_{1-\\alpha/2}(n)} &gt; \\frac{\\sigma^2}{\\sum (X_i -\r\n\\mu)^2} &gt; \\frac{1}{\\chi^2_{\\alpha/2}(n)}\r\n$$\r\n乘以∑(Xi − μ)2：\r\n$$\r\n\\frac{\\sum (X_i - \\mu)^2}{\\chi^2_{1-\\alpha/2}(n)} &gt; \\sigma^2 &gt;\r\n\\frac{\\sum (X_i - \\mu)^2}{\\chi^2_{\\alpha/2}(n)}\r\n$$\r\n\r\n因此σ2的置信区间为： $$\r\n\\left( \\frac{\\sum_{i=1}^n (X_i - \\mu)^2}{\\chi^2_{\\alpha/2}(n)},\\\r\n\\frac{\\sum_{i=1}^n (X_i - \\mu)^2}{\\chi^2_{1-\\alpha/2}(n)} \\right)\r\n$$\r\n对σ2区间取平方根，就可以得到标准差σ的置信区间： $$\r\n\\left( \\sqrt{\\frac{\\sum (X_i - \\mu)^2}{\\chi^2_{\\alpha/2}(n)}},\\\r\n\\sqrt{\\frac{\\sum (X_i - \\mu)^2}{\\chi^2_{1-\\alpha/2}(n)}} \\right)\r\n$$\r\n实际计算步骤\r\n设μ = 5，样本观测值(4.8, 5.1, 4.9, 5.2, 5.0)，α = 0.05：\r\n\r\n计算离差平方和： ∑(xi − 5)2 = 0.10\r\n查χ2分布表（n = 5）：\r\n\r\nχ0.0252(5) = 12.833\r\nχ0.9752(5) = 0.831\r\n\r\n方差置信区间： $$\r\n\\left( \\frac{0.10}{12.833},\\ \\frac{0.10}{0.831} \\right) = (0.0078,\\\r\n0.1203)\r\n$$\r\n标准差置信区间： $$\r\n\\left( \\sqrt{0.0078},\\ \\sqrt{0.1203} \\right) = (0.088,\\ 0.347)\r\n$$\r\n\r\n两个正态总体均值差的区间估计\r\n设已给定置信水平为 1 − α，并设 (X1, X2, ⋯, Xn1)\r\n是总体 X ∼ N(μ1, σ12)\r\n的样本，(Y1, Y2, ⋯, Yn2)\r\n是总体 Y ∼ N(μ2, σ22)\r\n的样本，且这两个样本相互独立。\r\n记 X̄, Ȳ 分别是总体\r\nX 和 Y 的样本均值，S12, S22\r\n分别是总体 X 和 Y 的样本方差。对总体均值差 μ1 − μ2\r\n作区间估计，分如下三种情况讨论。\r\nσ12和σ22均已知\r\n推导过程\r\n无偏估计量的构造\r\n由于： - X̄是μ1的无偏估计：E(X̄) = μ1\r\n- Ȳ是μ2的无偏估计：E(Ȳ) = μ2\r\n因此： D = X̄ − Ȳ  是  δ = μ1 − μ2  的无偏估计\r\n由正态分布性质： $$\r\n\\begin{aligned}\r\n\\bar{X} &amp;\\sim N\\left(\\mu_1, \\frac{\\sigma_1^2}{n_1}\\right) \\\\\r\n\\bar{Y} &amp;\\sim N\\left(\\mu_2, \\frac{\\sigma_2^2}{n_2}\\right)\r\n\\end{aligned}\r\n$$\r\n由于X̄与Ȳ相互独立，其线性组合服从： $$\r\n\\bar{X} - \\bar{Y} \\sim N\\left(\\mu_1 - \\mu_2, \\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}\\right)\r\n$$\r\n标准化统计量，构造标准正态统计量：\r\n$$\r\nU = \\frac{(\\bar{X} - \\bar{Y}) - (\\mu_1 -\r\n\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2}}} \\sim\r\nN(0,1)\r\n$$\r\n置信区间推导\r\n对于给定α，查标准正态分布得uα/2满足： P(−uα/2 &lt; U &lt; uα/2) = 1 − α\r\n将U表达式代入： $$\r\nP\\left(-u_{\\alpha/2} &lt; \\frac{D - \\delta}{\\sqrt{\\frac{\\sigma_1^2}{n_1}\r\n+ \\frac{\\sigma_2^2}{n_2}}} &lt; u_{\\alpha/2}\\right) = 1 - \\alpha\r\n$$\r\n解不等式： 1. 乘以标准差： $$\r\n   P\\left(-u_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}} &lt; D - \\delta &lt;\r\nu_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}}\\right) = 1 - \\alpha\r\n   $$\r\n\r\n移项得： $$\r\nP\\left(D - u_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}} &lt; \\delta &lt; D +\r\nu_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}}\\right) = 1 - \\alpha\r\n$$\r\n\r\n最终置信区间\r\nμ1 − μ2的1 − α置信区间为： $$\r\n\\left( \\bar{X} - \\bar{Y} - u_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}},\\ \\bar{X} - \\bar{Y} +\r\nu_{\\alpha/2}\\sqrt{\\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2}}\r\n\\right)\r\n$$\r\n实际计算步骤\r\n\r\n计算样本均值： $$\r\n\\bar{x} = \\frac{1}{n_1}\\sum x_i,\\quad \\bar{y} = \\frac{1}{n_2}\\sum y_i\r\n$$\r\n查标准正态分布表得uα/2值：\r\n\r\nα = 0.05时，u0.025 = 1.96\r\n\r\n计算合并标准误： $$\r\nSE = \\sqrt{\\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2}}\r\n$$\r\n计算置信区间： CI = (x̄ − ȳ) ± 1.96 × SE\r\n\r\n示例：\r\n设n1 = 30, σ12 = 4, x̄ = 10.2\r\nn2 = 40, σ22 = 9, ȳ = 8.5, α = 0.05\r\n\r\n计算标准误： $$\r\nSE = \\sqrt{\\frac{4}{30} + \\frac{9}{40}} = \\sqrt{0.1333 + 0.225} = 0.598\r\n$$\r\n置信区间： (10.2 − 8.5) ± 1.96 × 0.598 = 1.7 ± 1.172 = (0.528, 2.872)\r\n\r\nσ12和σ22均未知，但是σ12 = σ22 = σ2\r\n推导过程\r\n合并方差估计\r\n构造合并方差估计量： $$\r\nS_w^2 = \\frac{(n_1-1)S_1^2 + (n_2-1)S_2^2}{n_1+n_2-2}\r\n$$\r\n\r\n分子：两样本离差平方和的加权组合\r\n分母：总自由度df = n1 + n2 − 2\r\n\r\n构建t统计量\r\n标准化均值差： $$\r\nT = \\frac{(\\bar{X} - \\bar{Y}) - (\\mu_1 - \\mu_2)}{S_w \\sqrt{\\frac{1}{n_1}\r\n+ \\frac{1}{n_2}}} \\sim t(n_1+n_2-2)\r\n$$\r\n而其中，Sw为 $$\r\nS_w^2 = \\frac{(n_1-1)S_1^2 + (n_2-1)S_2^2}{n_1+n_2-2}\r\n$$ 置信区间推导\r\n对于给定α，查t分布表得tα/2(df)满足：\r\nP(−tα/2(df) &lt; T &lt; tα/2(df)) = 1 − α\r\n展开后得到： $$\r\nP\\left(\\bar{X}-\\bar{Y} - t_{\\alpha/2} S_w \\sqrt{\\frac{1}{n_1} +\r\n\\frac{1}{n_2}} &lt; \\mu_1 - \\mu_2 &lt; \\bar{X}-\\bar{Y} + t_{\\alpha/2}\r\nS_w \\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}\\right) = 1 - \\alpha\r\n$$\r\n整理得到置信区间公式\r\nμ1 − μ2的一个置信水平为1 − α的置信区间： $$\r\n\\left(\\bar{X} - \\bar{Y} - t_{\\alpha/2}(n_1+n_2-2) \\cdot S_w\r\n\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}, \\bar{X} - \\bar{Y} +\r\nt_{\\alpha/2}(n_1+n_2-2) \\cdot S_w \\sqrt{\\frac{1}{n_1} +\r\n\\frac{1}{n_2}}\\right)\r\n$$\r\n实际计算步骤\r\n\r\n计算样本统计量： $$\r\n\\bar{x} = \\frac{1}{n_1}\\sum x_i,\\quad s_1^2 =\r\n\\frac{1}{n_1-1}\\sum(x_i-\\bar{x})^2 \\\\\r\n\\bar{y} = \\frac{1}{n_2}\\sum y_i,\\quad s_2^2 =\r\n\\frac{1}{n_2-1}\\sum(y_i-\\bar{y})^2\r\n$$\r\n计算合并方差： $$\r\ns_w^2 = \\frac{(n_1-1)s_1^2 + (n_2-1)s_2^2}{n_1+n_2-2}\r\n$$\r\n查t分布表得临界值tα/2(n1 + n2 − 2)\r\n计算置信区间： $$\r\n\\text{CI} = (\\bar{x} - \\bar{y}) \\pm t_{\\alpha/2} \\cdot s_w\r\n\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}\r\n$$\r\n\r\n示例计算\r\n设n1 = 15, x̄ = 50.2, s12 = 16\r\nn2 = 20, ȳ = 48.5, s22 = 12.5,\r\nα = 0.05\r\n\r\n计算合并方差： $$\r\ns_w^2 = \\frac{14\\times16 + 19\\times12.5}{33} = \\frac{224 + 237.5}{33}\r\n\\approx 14.0\r\n$$\r\n查t分布表：\r\nt0.025(33) ≈ 2.0345\r\n计算置信区间： $$\r\n1.7 \\pm 2.0345 \\times \\sqrt{14} \\times \\sqrt{\\frac{1}{15} +\r\n\\frac{1}{20}} \\\\\r\n= 1.7 \\pm 2.0345 \\times 3.7417 \\times 0.3416 \\\\\r\n= 1.7 \\pm 2.60 \\\\\r\n= (-0.90, 4.30)\r\n$$\r\n结论：区间包含0，不能认为μ1与μ2有显著差异\r\n\r\nσ12和σ22均未知，但是关系不确定\r\n推导过程\r\n设两独立总体： - X ∼ N(μ1, σ12)，样本(X1, ..., Xn1)，样本均值X̄，样本方差S12 - Y ∼ N(μ2, σ22)，样本(Y1, ..., Yn2)，样本均值Ȳ，样本方差S22\r\n构建统计量\r\n考虑均值差δ = μ1 − μ2的估计量：\r\n$$\r\nD = \\bar{X} - \\bar{Y} \\sim N\\left(\\delta, \\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}\\right)\r\n$$\r\n标准化后： $$\r\nT = \\frac{D - \\delta}{\\sqrt{\\frac{S_1^2}{n_1} + \\frac{S_2^2}{n_2}}} \\sim\r\nt(\\nu)\r\n$$ 其中自由度ν由Welch-Satterthwaite方程确定：\r\n自由度计算\r\n$$\r\n\\nu = \\frac{\\left(\\frac{S_1^2}{n_1} +\r\n\\frac{S_2^2}{n_2}\\right)^2}{\\frac{(S_1^2/n_1)^2}{n_1-1} +\r\n\\frac{(S_2^2/n_2)^2}{n_2-1}}\r\n$$\r\n置信区间推导\r\n对于给定α，查t分布表得tα/2(ν)，满足：\r\n$$\r\nP\\left(-t_{\\alpha/2}(\\nu) &lt; \\frac{(\\bar{X}-\\bar{Y}) -\r\n(\\mu_1-\\mu_2)}{\\sqrt{\\frac{S_1^2}{n_1} + \\frac{S_2^2}{n_2}}} &lt;\r\nt_{\\alpha/2}(\\nu)\\right) = 1-\\alpha\r\n$$\r\n解不等式得δ的置信区间：\r\n$$\r\n(\\bar{X}-\\bar{Y}) \\pm t_{\\alpha/2}(\\nu)\\sqrt{\\frac{S_1^2}{n_1} +\r\n\\frac{S_2^2}{n_2}}\r\n$$\r\n计算步骤\r\n\r\n计算样本统计量： $$\r\n\\bar{x} = \\frac{1}{n_1}\\sum x_i,\\quad s_1^2 =\r\n\\frac{1}{n_1-1}\\sum(x_i-\\bar{x})^2 \\\\\r\n\\bar{y} = \\frac{1}{n_2}\\sum y_i,\\quad s_2^2 =\r\n\\frac{1}{n_2-1}\\sum(y_i-\\bar{y})^2\r\n$$\r\n计算自由度ν（结果四舍五入取整）： $$\r\n\\nu = \\frac{\\left(\\frac{s_1^2}{n_1} +\r\n\\frac{s_2^2}{n_2}\\right)^2}{\\frac{(s_1^2/n_1)^2}{n_1-1} +\r\n\\frac{(s_2^2/n_2)^2}{n_2-1}}\r\n$$\r\n查t分布表得临界值tα/2(ν)\r\n计算置信区间： $$\r\n\\text{CI} = (\\bar{x}-\\bar{y}) \\pm\r\nt_{\\alpha/2}(\\nu)\\sqrt{\\frac{s_1^2}{n_1} + \\frac{s_2^2}{n_2}}\r\n$$\r\n\r\n实际计算步骤\r\n设n1 = 10, x̄ = 5.2, s12 = 1.5\r\n，n2 = 15, ȳ = 4.8, s22 = 2.0,\r\nα = 0.05\r\n\r\n计算自由度： $$\r\n\\nu = \\frac{(0.15+0.1333)^2}{0.0225/9 + 0.0178/14} \\approx 21.3 \\approx\r\n21\r\n$$\r\n查t0.025(21) = 2.080\r\n置信区间： $$\r\n0.4 \\pm 2.080\\sqrt{0.15+0.1333} = 0.4 \\pm 2.080\\times0.532 = (-0.706,\r\n1.506)\r\n$$\r\n\r\n两个正态总体方差比的区间估计\r\n设 (X1, X2, ⋯, Xn1)\r\n是总体 X ∼ N(μ1, σ12)\r\n的样本，(Y1, Y2, ⋯, Yn2)\r\n是总体 Y ∼ N(μ2, σ22)\r\n的样本，且两个样本相互独立，要求两总体方差比 σ12/σ22\r\n的置信水平为 (1 − α)\r\n的置信区间。\r\nμ1,μ2均未知的情况\r\n推导过程\r\n构建F统计量\r\n由抽样分布理论： $$\r\nF = \\frac{S_1^2/\\sigma_1^2}{S_2^2/\\sigma_2^2} \\sim F(n_1-1, n_2-1)\r\n$$\r\n且分布 F(n1 − 1, n2 − 1)\r\n不依赖任何参数. 由 F\r\n分布的上侧分位数的定义知\r\n\r\n\r\nimage-20250626104603082\r\n\r\n确定临界值\r\n对于给定α，查F分布表得： -\r\n上侧分位数Fα/2(n1 − 1, n2 − 1)\r\n- 下侧分位数F1 − α/2(n1 − 1, n2 − 1)\r\n满足概率等式： $$\r\nP\\left(F_{1-\\alpha/2} &lt; \\frac{S_1^2/\\sigma_1^2}{S_2^2/\\sigma_2^2}\r\n&lt; F_{\\alpha/2}\\right) = 1-\\alpha\r\n$$\r\n推导置信区间\r\n解关于σ12/σ22的不等式：\r\n\r\n原始不等式： $$\r\nF_{1-\\alpha/2} &lt; \\frac{S_1^2}{S_2^2} \\cdot\r\n\\frac{\\sigma_2^2}{\\sigma_1^2} &lt; F_{\\alpha/2}\r\n$$\r\n取倒数（注意不等号方向变化）： $$\r\n\\frac{1}{F_{1-\\alpha/2}} &gt; \\frac{S_2^2}{S_1^2} \\cdot\r\n\\frac{\\sigma_1^2}{\\sigma_2^2} &gt; \\frac{1}{F_{\\alpha/2}}\r\n$$\r\n乘以$\\frac{S_1^2}{S_2^2}$：\r\n$$\r\n\\frac{S_1^2}{S_2^2} \\cdot \\frac{1}{F_{\\alpha/2}} &lt;\r\n\\frac{\\sigma_1^2}{\\sigma_2^2} &lt; \\frac{S_1^2}{S_2^2} \\cdot\r\n\\frac{1}{F_{1-\\alpha/2}}\r\n$$\r\n\r\n最终置信区间\r\nσ12/σ22的1 − α置信区间： $$\r\n\\left( \\frac{S_1^2}{S_2^2} \\cdot \\frac{1}{F_{\\alpha/2}(n_1-1,n_2-1)},\\\r\n\\frac{S_1^2}{S_2^2} \\cdot \\frac{1}{F_{1-\\alpha/2}(n_1-1,n_2-1)} \\right)\r\n$$\r\n实际计算步骤\r\n\r\n计算样本方差： $$\r\ns_1^2 = \\frac{1}{n_1-1}\\sum(x_i-\\bar{x})^2,\\quad s_2^2 =\r\n\\frac{1}{n_2-1}\\sum(y_i-\\bar{y})^2\r\n$$\r\n计算方差比： $$\r\n\\frac{s_1^2}{s_2^2}\r\n$$\r\n查F分布表：\r\n\r\nFα/2(df1, df2)\r\n$F_{1-\\alpha/2}(df_1,df_2) =\r\n\\frac{1}{F_{\\alpha/2}(df_2,df_1)}$\r\n\r\n计算置信区间：\r\n\r\n下限：$\\frac{s_1^2}{s_2^2} \\cdot\r\n\\frac{1}{F_{\\alpha/2}(n_1-1,n_2-1)}$\r\n上限：$\\frac{s_1^2}{s_2^2} \\cdot\r\n\\frac{1}{F_{1-\\alpha/2}(n_1-1,n_2-1)}$\r\n\r\n\r\n示例\r\n设n1 = 10, s12 = 4.5\r\nn2 = 15, s22 = 2.8,\r\nα = 0.05\r\n\r\n计算方差比： $$\r\n\\frac{4.5}{2.8} \\approx 1.607\r\n$$\r\n查F分布表：\r\n\r\nF0.025(9, 14) = 3.209\r\n$F_{0.975}(9,14) =\r\n\\frac{1}{F_{0.025}(14,9)} = \\frac{1}{3.798} \\approx 0.263$\r\n\r\n置信区间：\r\n\r\n下限：$1.607 \\times \\frac{1}{3.209}\r\n\\approx 0.501$\r\n上限：$1.607 \\times \\frac{1}{0.263}\r\n\\approx 6.110$ (0.501, 6.110)\r\n\r\n\r\nμ1已知，μ2未知\r\n推导过程\r\n\r\n构建统计量： 当μ1已知时，使用真实离差构造样本方差：\r\n$$\r\nS_1^{*2} = \\frac{1}{n_1}\\sum_{i=1}^{n_1}(X_i - \\mu_1)^2 \\sim\r\n\\frac{\\sigma_1^2}{n_1}\\chi^2(n_1)\r\n$$ 而S22仍为常规样本方差：\r\n$$\r\nS_2^2 = \\frac{1}{n_2-1}\\sum_{i=1}^{n_2}(Y_i - \\bar{Y})^2 \\sim\r\n\\frac{\\sigma_2^2}{n_2-1}\\chi^2(n_2-1)\r\n$$\r\n构造F统计量： $$\r\nF = \\frac{S_1^{*2}/\\sigma_1^2}{S_2^2/\\sigma_2^2} \\sim F(n_1, n_2-1)\r\n$$\r\n确定临界值： 查F分布表得Fα/2(n1, n2 − 1)和F1 − α/2(n1, n2 − 1)\r\n推导置信区间： $$\r\n\\left( \\frac{S_1^{*2}}{S_2^2} \\cdot \\frac{1}{F_{\\alpha/2}(n_1,n_2-1)},\\\r\n\\frac{S_1^{*2}}{S_2^2} \\cdot \\frac{1}{F_{1-\\alpha/2}(n_1,n_2-1)} \\right)\r\n$$\r\n\r\n示例计算\r\n设μ1 = 5, n1 = 10, ∑(xi − 5)2 = 40\r\nn2 = 15, s22 = 3.2,\r\nα = 0.05\r\n\r\n计算S1*2 = 40/10 = 4\r\n方差比：4/3.2 = 1.25\r\n查F分布表：\r\n\r\nF0.025(10, 14) = 3.15\r\nF0.975(10, 14) = 1/F0.025(14, 10) ≈ 1/3.35 ≈ 0.299\r\n\r\n置信区间：\r\n\r\n下限：1.25 × 1/3.15 ≈ 0.397\r\n上限：1.25 × 1/0.299 ≈ 4.181\r\n\r\n\r\nμ1,μ2均已知\r\n推导过程\r\n\r\n构建统计量： 使用真实离差构造方差估计： $$\r\nS_1^{*2} = \\frac{1}{n_1}\\sum(X_i - \\mu_1)^2 \\sim\r\n\\frac{\\sigma_1^2}{n_1}\\chi^2(n_1) \\\\\r\nS_2^{*2} = \\frac{1}{n_2}\\sum(Y_i - \\mu_2)^2 \\sim\r\n\\frac{\\sigma_2^2}{n_2}\\chi^2(n_2)\r\n$$\r\n构造F统计量： $$\r\nF = \\frac{S_1^{*2}/\\sigma_1^2}{S_2^{*2}/\\sigma_2^2} \\sim F(n_1, n_2)\r\n$$\r\n确定临界值：\r\n查F分布表得Fα/2(n1, n2)和F1 − α/2(n1, n2)\r\n推导置信区间： $$\r\n\\left( \\frac{S_1^{*2}}{S_2^{*2}} \\cdot \\frac{1}{F_{\\alpha/2}(n_1,n_2)},\\\r\n\\frac{S_1^{*2}}{S_2^{*2}} \\cdot \\frac{1}{F_{1-\\alpha/2}(n_1,n_2)}\r\n\\right)\r\n$$\r\n\r\n示例计算\r\n设μ1 = 5, μ2 = 6, n1 = 8, ∑(xi − 5)2 = 24\r\nn2 = 12, ∑(yi − 6)2 = 42,\r\nα = 0.1\r\n\r\n计算方差估计：\r\n\r\nS1*2 = 24/8 = 3\r\nS2*2 = 42/12 = 3.5\r\n\r\n方差比：3/3.5 ≈ 0.857\r\n查F分布表：\r\n\r\nF0.05(8, 12) = 2.85\r\nF0.95(8, 12) = 1/F0.05(12, 8) ≈ 1/3.28 ≈ 0.305\r\n\r\n置信区间：\r\n\r\n下限：0.857 × 1/2.85 ≈ 0.301\r\n上限：0.857 × 1/0.305 ≈ 2.810\r\n\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"冬暮川滚滚-在百合、斩首与轮回中，思考传承的意义","url":"/posts/26393.html","content":"冬暮川滚滚-在百合、斩首与轮回中，思考传承的意义\r\n==该文章具有大量剧透，而且我不推荐任何没有玩过某款galgame的玩家直接跑过去去看它的测评。==\r\n攻略\r\n老规矩还是上来就贴攻略，防止误入\r\n该游戏选项很少，而且没有让人难以理解和接受的结局，因此攻略部分可有可无\r\n开始\r\n\r\n才没忍耐…\r\n\r\n不,不对…\r\n\r\n没什么好恶心的\r\n\r\nTE\r\n\r\n\r\n那我除了…\r\n\r\nBE2\r\n\r\n\r\n不,不用忍耐…\r\n\r\nBE1\r\n\r\n\r\ngraph TD\n    A[开始] --&gt; B&#123;才没忍耐...&#125;\n    B --&gt; C&#123;不,不对...&#125;\n    C --&gt; D[没什么好恶心的]\n    D --&gt; E[TE]\n    B --&gt; F&#123;那我除了...&#125;\n    F --&gt; G[BE2]\n    A --&gt; H&#123;不,不用忍耐...&#125;\n    H --&gt; I[BE1]\r\n==那个，如果你没打完，看到这里就得了==\r\n前言\r\n《冬暮川滚滚》是一件争议点很明显，但是却有着独特魅力的游戏，游戏拥有着剧本和画风反差明显的特性，也是把我吸引住了，画风这作我觉得还是挺不错的，而且剧本打完之后想法很多，也是从头到尾让我对其改观很大的作品，近期很久没有遇到好玩的galgame了，所以打算三言两语，细碎调侃一番。\r\n总之概括一下，就是一部用SF独特的惊悚与科幻色彩包裹着生殖崇拜，以H场景构建人物关系，最终在宇宙尺度下探讨牺牲与繁衍的“非典型神作”。（好抽象）\r\n在这里我不会去探讨太多游戏中那些很癫的思辨和推理内容，就究其游戏本身和我的各种破烂点子，将会构成文章的主要内容。因为这部作品感觉这些主角说话都怪怪的，前期实在没有什么吸引人的地方，中期剧情中推理部分观感还可以但是也架不住较真，虽然我不抗拒先do再讲故事，但是故事本身的内容还是挺有争议性的，所以不会过度meta化。\r\n游戏简介\r\n《冬暮川滚滚》（原名：ふゆから、くるる。别名《冬旅\r\n方冥冥》）是由剧本家渡边辽一创作、シルキーズプラス（Silky’s\r\nPlus）于2021年9月24日发行的一款科幻悬疑百合ADV游戏。作为“SF四季系列”的最终作，本作以封闭的女子学园为舞台，结合不死轮回、斩首悬案、哲学思辨等元素，讲述了一段关于生命、记忆与进化的深刻故事。\r\n玩家将扮演主角空丘夕阳，在挚友霜雪しほん被斩首且头颅失踪后，化身“名侦探”展开调查，揭开学园背后的残酷真相。游戏融合了悬疑推理、百合情感、科幻设定，并通过独特的叙事诡计和伏笔回收，形成独特的体验。\r\n脚本是渡辺僚一，也是老人物了，这货擅长在世界观里超展开，剧本相对比较有质量，最代表的就是苍之彼方的四重奏了，他写过戏画最独特的作品之一\r\nFossette - Cafe au Le Ciel Bleu\r\n-，而且隙间樱花与谎言都市也是他写的，很好玩。\r\n开发是 シルキーズプラス，也就是SILKY’S\r\nPLUS，整过一堆狠活和抽象东西，当然也不乏佳作，这社的大部分东西都属于慢热流，开始感觉无聊中期开始发力那种，质量都还不错。因为ELF倒闭后很多人都跑过来了，质量当然要高很多。我只能说希望别被罐头砸了这品牌。\r\n游戏类型: 学園ＳＦミステリーＡＤＶ\r\n发行日期: 2021年9月24日\r\n关键词：\r\n科幻悬疑 | 电波 | 汉化 | 永生轮回 | 牺牲与繁衍 | 剧情向 | 传承 |\r\n宇宙级浪漫 | 设定系（部分）| 百合/扶她百合 | 哲学思辨 | 画风精美 |\r\n争议作品 | 氛围感（存疑）\r\n除去众所周知的百合性转扶她要素，这个剧本还是以悬疑和科幻为卖点的。\r\n正文\r\n首先来简单说一下世界观，SF的四季的四个作品分别拥有单独的世界观，前后无联系。\r\n故事发生在一所全封闭的女子学园，这里的少女们拥有“不死”的特性——即使被斩首，只要在48小时内找回头部并接回，就能复活。因为学园默许一名“杀人鬼”存在，其杀人行为被视为激发学生潜力的手段，但必须保留死者头部以确保复活。她们的生长方式异常。而且，她们的生长方式异常，从0岁成长至18岁，再逆向退化回婴儿状态，如此循环往复。当某位少女被外部观察者判定为“天才”时，她将从学园消失（即“毕业”），但毕业后的去向是一个谜团。\r\n然而，某天主角的挚友霜雪しほん被杀害，头颅被藏匿，导致她面临真正的“死亡”，主角夕阳必须找出凶手并找回头颅。\r\n随着剧情推进，玩家将发现学园的本质：学园实为虚拟培养皿，目的是通过“永生轮回”筛选出能适应宇宙环境的“天才”，而“毕业”意味着被投放至现实世界，而少女们并非人类，而是“针”的化身（如毛毡针、缝纫针等），象征着某种人造生命体的进化实验，是一切的诱因。\r\n介绍就到这里，\r\n\r\n\r\nimg\r\n\r\n二狗测评\r\n牢yui评价\r\n结束\r\n总之，《冬暮川滚滚》不是一件没有问题的作品，它有着让人不能忽视的严重瑕疵，但是，瑕不能完全掩瑜，就究其渡辺僚一展现的独特想象力、提出的追问以及在冰冷的康乃馨世界中绽放的情感光辉，足以让它成为一部具有冲击力和独特气质的科幻galgame佳作。虽然内核充满悲剧，但是和众多悲剧色彩的galgame一样，拥有着欣赏在悲剧中寻找微光的浪漫。不知道有多少慕名而来的寻求独特性的玩家，准备好并踏入这片雪原，见证“针群”的宿命，并为那些消逝于星海、只为传递“希望”的少女们，献上独特的敬意——“愿你的旅途常伴幸福”。\r\n","categories":["杂谈","galagme杂谈"]},{"title":"参数估计之点估计—矩估计法和最大似然估计法","url":"/posts/5644.html","content":"参数估计之点估计\r\n什么是参数估计\r\n首先，什么是参数估计呢？\r\n之前我们其实已经了解到很多种分布类型了，比如正态分布、均匀分布、泊松分布等。拿正态分布举例，决定正态分布的有两个参数：均值和方差。\r\n因此，参数就是决定分布的关键性数据。知道了参数，也就是知道了分布的详细内容。\r\n总体的分布类别如果我们知道了，是不是只要知道分布的参数，就能知道总体的分布详情？\r\n所以说，用样本的数据来构造函数（即统计量），来估计总体参数，这就是参数估计。\r\n估计量\r\n定义\r\n估计量是样本的统计量，用于估计总体未知参数。它是一个随机变量，因为其值依赖于随机样本。\r\n若总体参数为 θ，表示总体X的待估计参数，其中 X1, X2, …, Xn\r\n是来自总体的样本，则其中的一个估计量记作 θ̂ = θ̂(X1, X2, …, Xn)来估计θ，则称 θ̂ 为 θ 的估计量\r\n理解\r\n用于估计总体参数的 随机变量\r\n，是基于样本构造的、对总体参数进行估计的 “规则 / 公式” 。\r\n它本身是一种统计量（由样本数据计算得到），因样本具有随机性，所以估计量是随机变量，会随样本不同而变化。\r\n比如：用 “样本均值 $\\bar{X} =\r\n\\frac{1}{n}\\sum_{i = 1}^{n}X_i$” 估计 “总体均值 μ” ，这里的 X̄ 就是总体均值 μ\r\n的一个估计量；同理，样本方差、样本比例等也可作为对应总体参数的估计量。\r\n估计值\r\n定义\r\n而继续上述估计量的说法\r\n若总体参数为 θ，表示总体X的待估计参数，其中 X1, X2, …, Xn\r\n是来自总体的样本，则其中的一个估计量记作 θ̂ = θ̂(X1, X2, …, Xn)来估计\r\nθ，则称 θ̂ 为 θ 的估计量，对应于样本(X1, X2, …, Xn)的一次观测值，估计量\r\nθ̂ 的值 θ̂(X1, X2, …, Xn)\r\n称为 θ\r\n的估计值，并且仍然简记为 θ̂\r\n简单说法：对于样本观测值 x1, x2, …, xn，估计值为\r\nθ̂ = T(x1, x2, …, xn)。\r\n理解\r\n估计量是函数形式（如样本均值 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^n\r\nX_i$），而估计值是函数代入样本后的具体数值（如\r\nx̄ = 5.2）。\r\n所以估计值是基于某一次抽样的样本，把数据代入估计量的公式，算出的具体值。由于样本确定，估计值是固定数。\r\n比如：抽取一组样本，计算得样本均值 x̄ = 80（这里用小写 x̄ 表示具体数值 ），那么 80\r\n就是总体均值 μ\r\n的估计值；若换一组样本，计算出 x̄ = 82，则此时估计值就是 82 。\r\n何为点估计\r\n点估计就是用一个数值对总体参数给出估计；\r\n利用样本数据计算一个数值，来直接估计总体未知参数的具体值。\r\n用样本的 “某个特征值” 作为总体对应参数的\r\n“最佳猜测”，结果是一个确定的数值（点），而非区间。\r\n此时，总体与样本的关系如下\r\n\r\n总体参数（如 μ, σ2, p）通常未知，需通过抽样获取样本（如\r\nX1, X2, …, Xn）。\r\n点估计的目标：用样本构造一个统计量（如 X̄, S2, P̂），将其计算值作为总体参数的近似。\r\n\r\n点估计的方法基本如下\r\n\r\n根据问题选矩估计、极大似然估计等构造估计量；\r\n用样本数据计算估计值\r\n用无偏性、有效性等标准评估估计的可靠性。\r\n\r\n矩估计法\r\n什么是矩估计呢\r\n矩估计比较好理解，就是用样本矩直接匹配总体矩，从而估计未知参数。\r\n- 样本矩：从实际数据计算出的统计量（如样本均值、方差）。\r\n- 总体矩：理论分布的数字特征（如期望、方差）。\r\n- 尽量选取低阶矩 - 总体矩必须含有未知参数。\r\n啥意思呢？就是我们将样本的矩计算出来，直接作为总体的矩即可。\r\n例如：\r\n\r\n总体均值 μ\r\n的矩估计量是样本均值 X̄；总体方差 σ2 的矩估计量是 $\\frac{1}{n}\\sum(X_i -\r\n\\bar{X})^2$（注意：与无偏估计的样本方差 $S^2 = \\frac{1}{n-1}\\sum(X_i - \\bar{X})^2$\r\n不同）。\r\n\r\n矩法估计的重点就在于“矩”字，我们知道矩是概率分布的一种数字特征，可以分为原点矩和中心矩两种。对于随机变量X而言，其 k 阶原点矩和 k 阶中心矩为\r\n离散的 k 阶原点矩： E[Xk] = ∑ixik ⋅ P(X = xi)\r\n离散的 k 阶中心矩： $$\r\n\\mu_k = \\sum_{i=1}^{n} (x_i - EX)^k p_i\r\n$$ 连续的 k 阶原点矩 E[Xk] = ∫−∞∞xkf(x) dx\r\n连续的 k 阶中心距 μk = ∫−∞+∞(x − EX)kf(x) dx\r\n特别地，一阶原点矩就是随机变量的期望，二阶中心矩就是随机变量的方差，由于E(X − E(X)) = 0，所以我们不定义一阶中心矩。\r\n具体求法\r\n设总体 X 的分布函数为 F(x : θ1, θ2, …, θn)，其中θ1, θ2, …, θn，是\r\nk 个待估参数，(X1, X2, ⋯, Xn)是取自X的样本。假设总体X的k阶原点矩E(Xk)存在，则总体X的j阶原点矩 aj(θ1, θ2, ⋯, θk) = E(Xj),  1 ≤ j ≤ k\r\n样本(X1, X2, ⋯, Xn)的\r\n$j $ 阶原点矩为 $$\r\nA_j = \\frac{1}{n} \\sum_{i = 1}^n X_i^j,\\quad 1 \\leq j \\leq k\r\n$$ 令样本矩等于对应的总体矩，可得 k 个方程 aj(θ1, θ2, ⋯, θk) = Aj,  1 ≤ j ≤ k  (7.1)\r\n求解上述方程组，得到一组解θ̂1, θ̂2, ⋯, θ̂k，以此作为待估参数θ1, θ2, ⋯, θk的矩估计量。\r\n完全可以拆分成如下形式，好理解一些\r\n\r\n计算样本矩：根据样本数据计算前 k 阶矩（通常只需低阶矩）。\r\n\r\n例如：样本均值 $\\bar{X} =\r\n\\frac{1}{n}\\sum_{i=1}^n X_i$（一阶原点矩），样本方差 $S^2 = \\frac{1}{n}\\sum_{i=1}^n (X_i -\r\n\\bar{X})^2$（二阶中心矩）。\r\n\r\n设定总体矩方程：将总体矩表示为待估参数 θ 的函数。\r\n\r\n例如：若总体服从 N(μ, σ2)，则一阶总体矩\r\nE(X) = μ，二阶中心矩\r\n$ D(X) = ^2$。\r\n\r\n联立方程求解：令样本矩 = 总体矩，解出参数 θ。\r\n\r\n例如：\r\n\r\nμ̂ = X̄（用样本均值估计总体均值）\r\n\r\n$\\hat{\\sigma}^2 = \\frac{1}{n}\\sum_{i=1}^n\r\n(X_i - \\bar{X})^2$（用样本二阶中心矩估计总体方差）\r\n\r\n\r\n\r\n示例\r\n泊松分布的矩估计\r\n设 X ∼ Poisson(λ)，参数 λ 未知， λ &gt; 0，X1, X2, …, Xn为取自X的样本，求待估参数λ的矩估计：\r\n因为只有一个待估计参数，所以只要列出总体一阶原点矩等于样本一阶原点矩的方程就行，\r\n\r\n总体一阶矩：$E(X) =\r\n\\int_{-\\infty}^{\\infty} x f(x; \\lambda) \\, dx =\r\n\\frac{1}{\\lambda}$。\r\n\r\n样本一阶矩：$\\bar{X} = \\frac{1}{n}\\sum\r\nX_i$。\r\n\r\n矩估计：$\\frac{1}{\\lambda} = \\frac{1}{n}\r\n\\sum_{i=1}^{n} X_i = \\overline{X}$（用样本均值估计 λ）。\r\n\r\n解得 λ 的矩估计为$ = $\r\n试求总体均值和方差的矩估计\r\n设总体均值为μ，方差为σ2，(X1, X2, ⋯, Xn)为取自总体X的样本。因为待估参数为μ, σ2两个，故由矩估计法得方程组\r\n$$\r\n\\begin{cases}\r\na_1 = A_1, \\\\\r\na_2 = A_2,\r\n\\end{cases}\r\n$$ 即 $$\r\n\\begin{cases}\r\n\\mu = \\frac{1}{n} \\sum_{i = 1}^{n} X_i = \\overline{X}, \\\\\r\n\\mu^2 + \\sigma^2 = \\frac{1}{n} \\sum_{i = 1}^{n} X_i^2,\r\n\\end{cases}\r\n$$ 解得 $$\r\n\\begin{cases}\r\n\\hat{\\mu} = \\overline{X}, \\\\\r\n\\hat{\\sigma}^2 = \\frac{1}{n} \\sum_{i = 1}^{n} X_i^2 - \\overline{X}^2 =\r\n\\frac{1}{n} \\sum_{i = 1}^{n} (X_i - \\overline{X})^2 \\stackrel{记为}{=}\r\n\\widetilde{S}^2\r\n\\end{cases}\r\n$$ 由于总体的k阶中心矩 μk = E(X − EX)k\r\n总可以通过展开的方法化为阶数不超过 k 的总体原点矩的函数，而样本的 k 阶中心矩 $B_k = \\frac{1}{n} \\sum_{i = 1}^{n} (X_i -\r\n\\overline{X})^k$ 同样也可展开为阶数不超过 k 的样本原点矩的函数\r\n上述推导得出两个核心结论： 1. 总体均值 μ 的矩估计 $$\r\n   \\hat{\\mu} = \\overline{X} = \\frac{1}{n}\\sum_{i=1}^n X_i\r\n   $$ 直接用样本均值估计总体均值\r\n\r\n总体方差 σ2 的矩估计\r\n$$\r\n\\hat{\\sigma}^2 = \\frac{1}{n}\\sum_{i=1}^n (X_i - \\overline{X})^2\r\n\\triangleq \\widetilde{S}^2\r\n$$\r\n用样本二阶中心矩估计总体方差，注意这是有偏估计，（真实方差需用无偏估计\r\n$S^2 = \\frac{1}{n-1}\\sum (X_i -\r\n\\overline{X})^2$）。\r\n但是当样本量 n → ∞\r\n时，S̃2\r\n会趋近真实方差。\r\n\r\n因此上述例子的结论可作为矩估计法推广到一般情形，即可以用样本的 k\r\n阶中心矩作为总体的 k\r\n阶中心矩的矩估计量。此结论很有用，在实际中很方便。\r\n均匀分布的矩估计\r\n设总体 X 服从 [a, b] 上的均匀分布， a, b 为待估参数，(X1, X2, ⋯, Xn)\r\n为取自 X 的样本，求 a, b 的矩估计量 。\r\n利用矩估计法原理：需列出总体一、二阶中心矩等于样本一、二阶中心矩的方程。\r\n已知均匀分布 $XU[a,b] $ 的期望 $EX = $，方差 $DX=\\frac{1}{12}(b - a)^2$ （方差是二阶中心矩\r\n）。\r\n样本一阶中心矩对应样本均值 $=_{i = 1}^{n}X_i $\r\n样本二阶中心矩为 $^2=_{i = 1}^{n}(X_i - )^2 $。\r\n\r\n联立矩方程：\r\n令总体一阶原点矩（期望）等于样本一阶原点矩（样本均值），总体二阶中心矩（方差）等于样本二阶中心矩，得到方程组：\r\n$$\r\n\\begin{cases}\r\n\\frac{1}{2}(a + b)=\\overline{X} \\\\\r\n\\frac{1}{12}(b - a)^2=\\frac{1}{n}\\sum_{i = 1}^{n}(X_i -\r\n\\overline{X})^2=\\widetilde{S}^2\r\n\\end{cases}\r\n$$\r\n通过解上述方程组，得到待估参数 $ a,b $ 的矩估计量 $$\r\n\\hat{a}=\\overline{X}-\\sqrt{3}\\widetilde{S}, \\quad\r\n\\hat{b}=\\overline{X}+\\sqrt{3}\\widetilde{S}\r\n$$ 其中 $ =$ ，是样本二阶中心矩的开方形式 。\r\n\r\n最大似然估计法\r\n什么是最大似然估计法\r\n最大似然估计（极大似然估计），是另一种点估计方法，也是机器学习等学科中经常使用到的方法。简直就是重中之重。\r\n简单来说，就是使样本事件发生概率最大的参数值，作为总体参数的估计值，就是极大似然估计。\r\n怎么理解呢？举个例子。\r\n比如箱子中有100个球，共两种颜色白和黑。已知白球和黑球的比例是1:99（但不知道谁是1）。目标是估计箱子中什么颜色是99个。随机抽取一个球，发现是白球。那么从直观上讲，是不是大概率箱子中是99个白球？当然也有可能箱子中是99个黑球，正好有1个白球还正好被抽到了。但是明显这种情况概率较小。\r\n上面这个例子，就是极大似然估计的过程。选择的是概率最大的参数。\r\n极大似然估计的应用过程如下，也比较简单，通常遵循以下步骤\r\n\r\n写出总体的概率/密度函数\r\n当总体是离散型变量时，写的是概率函数；当总体是连续型函数时，写的是密度函数\r\n写出似然函数\r\n构造似然函数如下： $$\r\nL(\\theta) = L(x_1, x_2, \\cdots, x_n ; \\theta) = \\prod_{i = 1}^{n} f(x_i\r\n; \\theta)\r\n$$\r\n从上面的公式中，其实就是将每个样本观测值带入总体概率函数中，求所有样本的概率连乘。这个连乘，就是关于总体参数的一个似然函数。\r\n似然函数有了，下面，我们的目标就是求使得该函数取最大值时的参数值，这个参数值就将作为一个总体参数的极大似然估计。\r\n两边取ln\r\n由于通常似然函数都是连乘的形式，不容易取到最值，因此采用取ln的方式，将连乘变形为加法。\r\n两边求导，令导数=0，求参数\r\n通常情况下，最值都是在导数为0的地方取到，这里令导数=0，求参数。即此时的参数值，使得导数为0，取得整体似然函数的最大值。即，此时的参数值是整体参数的极大似然估计。\r\n当然，如果是多个参数的情况下，这里则分别对每个参数求偏导数，令偏导数为0，分别求各个参数的极大似然估计。\r\n\r\n具体求法\r\n设总体X的概率密度为f(x; θ)（当X为离散型时，f(x; θ)为概率），θ = (θ1, θ2, ⋯, θk)为待估的未知参数，(x1, x2, ⋯, xn)为样本(X1, X2, ⋯, Xn)的一组观测值，称\r\n$$\r\nL(\\theta) = L(x_1, x_2, \\cdots, x_n ; \\theta) = \\prod_{i = 1}^{n} f(x_i\r\n; \\theta)\r\n$$ 为样本的似然函数，若存在某个θ̂ = (θ̂1, θ̂2, ⋯, θ̂k)，使得\r\nL(x1, x2, ⋯, xn; θ̂) = maxθ ∈ ΘL(x1, x2, ⋯, xn; θ)\r\n成立（其中 Θ 为 θ 的所有可能取值范围），则称 $$\r\n\\begin{align*}\r\n\\hat{\\theta} &amp;= \\hat{\\theta}(x_1, x_2, \\cdots, x_n) \\\\\r\n&amp;= \\big( \\hat{\\theta}_1(x_1, \\cdots, x_n), \\cdots,\r\n\\hat{\\theta}_k(x_1, \\cdots, x_n) \\big)\r\n\\end{align*}\r\n$$ 为θ的最大似然估计值，而称 $$\r\n\\begin{align*}\r\n\\hat{\\theta} &amp;= \\hat{\\theta}(X_1, X_2, \\cdots, X_n) \\\\\r\n&amp;= \\big( \\hat{\\theta}_1(X_1, \\cdots, X_n), \\cdots,\r\n\\hat{\\theta}_k(X_1, \\cdots, X_n) \\big)\r\n\\end{align*}\r\n$$ 为θ的最大似然估计量。\r\n由定义知，求总体参数 θ\r\n的最大似然估计 θ̂\r\n的问题，就是求似然函数 $L() $\r\n的最大值问题。当然，该最大值问题解的存在性也值得关注。由微积分学知，若似然函数L(θ)关于θ（也即关于θ1, θ2, ⋯, θk）有连续偏导数，则最大似然估计θ̂ = (θ̂1, θ̂2, ⋯, θ̂k)一般可从方程组：\r\n$$\r\n\\boxed{(7.4) \\quad \\frac{\\partial L(\\theta)}{\\partial \\theta_j} = 0,\r\n\\quad j = 1, 2, \\cdots, k}\r\n$$ 解得.又由于ln L(θ)与L(θ)同时取得最大值，故等价地可由方程组\r\n$$\r\n\\boxed{(7.5) \\quad \\frac{\\partial \\ln L(\\theta)}{\\partial \\theta_j} = 0,\r\n\\quad j = 1, 2, \\cdots, k}\r\n$$\r\n求得θ̂\r\n(7.4)式或(7.5)式称为似然方程.通常，(7.5)式的求解较为简单.于是求解最大似然估计的一般步骤为：\r\n\r\n由总体的分布写出样本的似然函数L(θ)；\r\n建立似然方程(7.4)式或(7.5)式；\r\n解上述似然方程得参数θ的最大似然估计θ̂ = (θ̂1, θ̂2, ⋯, θ̂k)\r\n\r\n例题\r\n均匀分布的最大似然估计\r\n设总体 X ∼ U(a, b)（均匀分布），(X1, X2, …, Xn)\r\n为来自该总体的样本。试求参数 a\r\n和 b\r\n的最大似然估计（MLE）。\r\n写出概率密度函数\r\n均匀分布的PDF为： $$\r\nf(x) =\r\n\\begin{cases}\r\n\\frac{1}{b-a} &amp; \\text{若 } a \\leq x \\leq b \\\\\r\n0 &amp; \\text{其他}\r\n\\end{cases}\r\n$$ 构建似然函数\r\n对于样本 (X1, X2, …, Xn)，似然函数为：\r\n$$\r\nL(a, b) = \\prod_{i=1}^n f(X_i) =\r\n\\begin{cases}\r\n\\left(\\frac{1}{b-a}\\right)^n &amp; \\text{若所有 } X_i \\in [a, b] \\\\\r\n0 &amp; \\text{否则}\r\n\\end{cases}\r\n$$\r\n取对数得对数似然函数 ln L(a, b) = −nln (b − a)  （仅当\r\na ≤ Xi ≤ b 对所有\r\ni 成立时）\r\n最大化似然函数\r\n由于 ln L(a, b) 关于\r\nb − a\r\n单调递减，因此需要 最小化 b − a，同时满足约束： $$\r\n\\begin{cases}\r\na \\leq \\min(X_1, X_2, \\dots, X_n), \\\\\r\nb \\geq \\max(X_1, X_2, \\dots, X_n).\r\n\\end{cases}\r\n$$ 因此，MLE为： â = min (X1, X2, …, Xn),  b̂ = max (X1, X2, …, Xn)\r\n一道实际例题\r\n某电子管的使用寿命 X\r\n服从指数分布，其概率密度函数为\r\n$$\r\nf(x;\\theta) =  \\begin{cases}  \\dfrac{1}{\\theta} \\mathrm{e}^{-x/\\theta},\r\n&amp; x &gt; 0, \\theta &gt; 0, \\\\ 0, &amp; \\text{其他}, \\end{cases}\r\n$$ 今测得一组样本观测值，其具体数据如下（单位：h）：\r\n16, 29, 50, 68, 100, 130, 140, 270, 280, 340, 410, 450, 520, 620, 190, 210, 800, 1100\r\n试求参数 θ\r\n的最大似然估计.\r\n由题意，似然函数为 $$\r\nL(x_1, x_2, \\cdots, x_n ; \\theta) = \\prod_{i=1}^{n} \\left(\r\n\\dfrac{1}{\\theta} \\mathrm{e}^{-x_i/\\theta} \\right) = \\dfrac{1}{\\theta^n}\r\n\\exp \\left\\{ -\\dfrac{1}{\\theta} \\left( \\sum_{i=1}^{n} x_i \\right)\r\n\\right\\}\r\n$$ 将上式取对数得 $$\r\n\\ln L(x_1, x_2, \\cdots, x_n ; \\theta) = -n \\ln \\theta -\r\n\\dfrac{1}{\\theta} \\sum_{i=1}^{n} x_i\r\n$$ 对 θ 求导得似然方程\r\n$$\r\n-\\dfrac{n}{\\theta} + \\dfrac{1}{\\theta^2} \\sum_{i=1}^{n} x_i = 0\r\n$$ 解方程得 θ\r\n的最大似然估计值为 $$\r\n\\hat{\\theta} = \\dfrac{1}{n} \\sum_{i=1}^{n} x_i = \\bar{x}.\r\n$$ 将观测数据代入 θ̂\r\n中，得 θ 的最大似然估计值为\r\n$$\r\n\\begin{align*} \\hat{\\theta} &amp;= \\bar{x} = \\dfrac{1}{n} \\sum_{i=1}^{n}\r\nx_i \\\\ &amp;= \\dfrac{1}{18} (16 + 29 + \\cdots + 800 + 1100) = 318 \\,\r\n(\\text{h}). \\end{align*}\r\n$$ 答，参数 θ\r\n的最大似然估计的估计值为 318\r\n双参指数分布的最大似然估计\r\n设总体 X 的概率密度函数为：\r\n$$\r\nf(x; \\theta, \\lambda) = \\begin{cases}\r\n\\lambda e^{-\\lambda(x-\\theta)}, &amp; x \\geq \\theta \\\\\r\n0, &amp; x &lt; \\theta\r\n\\end{cases}\r\n$$ 其中 θ ∈ ℝ 和 λ &gt; 0 是未知参数。给定样本 X1, X2, …, Xn，求\r\nθ 和 λ 的最大似然估计量 θ̂MLE 和 λ̂MLE。\r\n解题步骤\r\n构造似然函数\r\n由于样本独立同分布，似然函数为： $$\r\nL(\\theta, \\lambda; x_1, x_2, \\dots, x_n) = \\prod_{i=1}^n \\lambda\r\ne^{-\\lambda(x_i - \\theta)} \\cdot I(x_i \\geq \\theta)\r\n$$ 其中 I(⋅)\r\n是示性函数，确保所有样本点 xi ≥ θ。\r\n当所有 xi ≥ θ\r\n时，似然函数可简化为： $$\r\nL(\\theta, \\lambda) = \\lambda^n e^{-\\lambda \\sum_{i=1}^n (x_i - \\theta)}\r\n= \\lambda^n e^{-\\lambda \\left(\\sum_{i=1}^n x_i - n\\theta\\right)}\r\n$$\r\n取 ln $$\r\n\\ln L(\\theta, \\lambda) = n \\ln \\lambda - \\lambda \\left(\\sum_{i=1}^n x_i\r\n- n\\theta\\right)\r\n$$ 注意：对数似然函数仅在 θ ≤ min (x1, x2, …, xn)\r\n时有定义。\r\n最大化关于 θ 的对数似然\r\nln L 中与 θ 相关的项为 nλθ，且 λ &gt; 0。为使 ln L 最大，需让 θ 尽可能大，但必须满足 θ ≤ min (x1, x2, …, xn)。\r\n因此，θ 的最大似然估计为：\r\nθ̂MLE = min (X1, X2, …, Xn)\r\n最大化关于 λ 的对数似然\r\n固定 θ = θ̂MLE，对\r\nln L 求导并令导数为零： $$\r\n\\frac{\\partial \\ln L}{\\partial \\lambda} = \\frac{n}{\\lambda} -\r\n\\left(\\sum_{i=1}^n x_i - n\\theta\\right) = 0\r\n$$ 解得： $$\r\n\\lambda = \\frac{n}{\\sum_{i=1}^n x_i - n\\theta}\r\n$$ 代入 θ̂MLE，得到： $$\r\n\\hat{\\lambda}_{\\text{MLE}} = \\frac{n}{\\sum_{i=1}^n X_i - n \\cdot\r\n\\min(X_1, X_2, \\dots, X_n)}\r\n$$\r\n最终答案 参数 θ 和 λ 的最大似然估计分别为： $$\r\n\\boxed{\\hat{\\theta}_{\\text{MLE}} = \\min(X_1, X_2, \\dots, X_n)}\r\n$$ $$\r\n\\boxed{\\hat{\\lambda}_{\\text{MLE}} = \\frac{n}{\\sum_{i=1}^n X_i - n \\cdot\r\n\\min(X_1, X_2, \\dots, X_n)}}\r\n$$\r\n估计量的评选原则\r\n无偏性\r\n如何理解无偏性\r\n点估计方法判断一个点是好还是坏，涉及到的其中原则之一就是无偏性。\r\n无偏性的含义是：用样本估计的参数值的期望，等于真实值。\r\n通俗简单来讲，意思就是，用这个估计方法 “猜”\r\n参数的值时，既不会系统性地高估，也不会系统性地低估，长期来看是准确的。\r\n\r\n例子：假设你有一个电子秤，每次称同一块巧克力的重量时：\r\n\r\n无偏的秤：有时称得重一点，有时轻一点，但\r\n长期平均 刚好是真实重量。\r\n有偏的秤：总是比真实重量多 5\r\n克（系统性地高估）。\r\n\r\n\r\n这个其实很好理解。我们进行参数估计不就是为了尽可能“猜”出总体参数的数值嘛，如果连期望都不相等，那岂不是基本就估计错了么……\r\n在统计学中，“无偏估计量”\r\n就像那个无偏的秤——用它估计参数时，虽然单次结果可能有误差，但\r\n反复多次估计后的平均值会等于真实参数值。所以无偏估计量长期来看是准确的，避免系统性误差。\r\n样本均值 vs 总体均值\r\n\r\n用样本均值 $\\bar{X} = \\frac{1}{n}\\sum\r\nX_i$ 估计总体均值 μ\r\n时，X̄ 是无偏的，因为 E(X̄) = μ。\r\n推断：从总体中随机抽样，样本均值会围绕真实均值波动，但不会系统性偏离。\r\n\r\n样本方差的有偏与无偏版本\r\n\r\n有偏估计：$\\widetilde{S}^2 = \\frac{1}{n}\\sum (X_i -\r\n\\bar{X})^2$，它的期望 $E(\\widetilde{S}^2) = \\frac{n-1}{n} \\sigma^2 &lt;\r\n\\sigma^2$（低估方差）。\r\n无偏估计：$S^2 =\r\n\\frac{1}{n-1}\\sum (X_i - \\bar{X})^2$，修正后 E(S2) = σ2。\r\n推断：因为 X̄ 本身是用样本数据算的，导致 S̃2 低估真实方差，需要除以\r\nn − 1 而不是 n 来修正。\r\n\r\n无偏性的定义\r\n定义 7.2 设 θ̂ = θ̂(X1, X2, ⋯, Xn)\r\n是参数 θ 的估计量，若对任意\r\nθ ∈ Θ，有 Eθ̂ = θ 则称 θ̂ 是 θ 的无偏估计量（或称估计量 θ̂ 是无偏的）。记 bn = Eθ̂ − θ\r\n称 bn\r\n为估计量 θ̂ 的偏差，当 bn ≠ 0 时，称\r\nθ̂ 是 θ 的有偏估计。若 limn → ∞bn = 0\r\n则称 θ̂ 是 θ 的渐近无偏估计。\r\n如何证明无偏性，来俩例题\r\n证明样本均值$\\overline X$总是总体均值EX的无偏估计量\r\n设总体 $ X $ 的 $ k $ 阶矩 $ a_k = E(X^k) （ k ）存在， (X_1, X_2, , X_n)\r\n$ 是 $ X $ 的样本。试证明样本 $ k $ 阶矩 $ A_k = _{i = 1}^n X_i^k $ 是 $\r\na_k $ 的无偏估计。\r\n由样本的定义知 ( X_1, X_2, , X_n ) 与 ( X ) 同分布，因此\r\nE(Xik) = E(Xk) = ak, k ≥ 1,  i = 1, 2, ⋯, n\r\n故 $$\r\nEA_k = \\frac{1}{n} \\sum_{i = 1}^n E(X_i^k) = a_k\r\n$$\r\n证明$S^2 = \\frac{1}{n-1}\\sum (X_i -\r\n\\bar{X})^2$是σ2的无偏估计量\r\n设总体方差 $ DX = ^2 &lt; $，试证样本方差 $ S^2 = _{i = 1}^n (X_i -\r\n{X})^2 $ 是 $ ^2 $ 的无偏估计量。\r\n设总体均值 $ EX = $，由于 $ DX = ^2 &lt; $，故 $ $ 存在且有限。 $$\r\n\\begin{align*}\r\nES^2 &amp;= E\\left[ \\frac{1}{n - 1} \\sum_{i = 1}^n (X_i - \\bar{X})^2\r\n\\right] \\\\\r\n&amp;= E\\left\\{ \\frac{1}{n - 1} \\sum_{i = 1}^n \\left[ (X_i - \\mu) -\r\n(\\bar{X} - \\mu) \\right]^2 \\right\\} \\\\\r\n&amp;= \\frac{1}{n - 1} E\\left\\{ \\sum_{i = 1}^n \\left[ (X_i - \\mu)^2 -\r\n2(X_i - \\mu)(\\bar{X} - \\mu) + (\\bar{X} - \\mu)^2 \\right] \\right\\} \\\\\r\n&amp;= \\frac{1}{n - 1} \\left[ \\sum_{i = 1}^n E(X_i - \\mu)^2 - 2E \\sum_{i\r\n= 1}^n (X_i - \\mu)(\\bar{X} - \\mu) + nE(\\bar{X} - \\mu)^2 \\right] \\\\\r\n&amp;= \\frac{1}{n - 1} \\sum_{i = 1}^n E(X_i - \\mu)^2 - \\frac{2}{n - 1} E\r\n\\sum_{i = 1}^n (X_i - \\mu)(\\bar{X} - \\mu) + \\frac{n}{n - 1} E(\\bar{X} -\r\n\\mu)^2 \\\\\r\n&amp;= \\frac{n}{n - 1} \\sigma^2 - \\frac{n}{n - 1} \\cdot\r\n\\frac{\\sigma^2}{n} \\\\\r\n&amp;= \\sigma^2.\r\n\\end{align*}\r\n$$ 即样本方差是总体方差的无偏估计量。\r\n我们知道，总体方差 $ ^2 $ 的矩估计 $ ^2 = _{i = 1}^n (X_i - {X})^2 $\r\n是有偏估计，这是因为 $$\r\nE\\widetilde{S}^2 = E\\left( \\frac{n - 1}{n} S^2 \\right) = \\frac{n - 1}{n}\r\nES^2 = \\frac{n - 1}{n} \\sigma^2\r\n$$ 可见 $ ^2 $ 为 $ ^2 $ 的渐近无偏估计，故当 n 比较大时，取 $ S^2 $ 和 $ ^2 $\r\n作为 $ ^2 $ 的估计皆可。\r\n显然，对于同一未知参数，可以构造许多无偏估计。例如，若 $ (X_1, X_2, ,\r\nX_n) $ 是总体 $ X $ 的一个样本，$ c_i （ 1 i n $）是满足 $ _{i = 1}^n c_i = 1 $\r\n的任意常数，则估计量 $$\r\n\\sum_{i = 1}^n c_i X_i\r\n$$ 都是总体期望 EX 的无偏估计。\r\n有效性\r\n如何理解有效性\r\n其实可以这么理解，有效性 衡量的是\r\n估计量的“精度”：\r\n\r\n如果两个估计量都是无偏的（长期来看都猜得准），但其中一个的估计结果\r\n波动更小、更稳定，我们就说它\r\n更有效。\r\n类比：\r\n\r\n无偏但 低效 的估计量 →\r\n一个总是瞄准靶心但手抖的弓箭手（箭落点分散）。\r\n无偏且 高效 的估计量 →\r\n一个既瞄准靶心又手稳的弓箭手（箭密集命中靶心）。\r\n\r\n\r\n\r\n\r\nimage-20250625205230364\r\n\r\n所以有效性的含义是：用样本估计的参数值的方差，如果越小，就越有效。\r\n两个估计都是无偏的，但是第二个估计明显更集中，方差更小，因此效果也就更好。因为更加容易和真实值（即总体参数）相近。\r\n有效性的定义\r\n设 $\\hat{\\theta_1}=\\hat{\\theta_1}\\left(X_{1}, X_{2},\r\n\\cdots, X_{n}\\right)$ 和 $\\hat{\\theta_2}=\\hat{\\theta_2}\\left(X_{1}, X_{2},\r\n\\cdots, X_{n}\\right)$ 都是待估计参数参数 θ 的两个\r\n无偏估计量，若： D(θ̂1) &lt; D(θ̂2)\r\n则称 θ̂1 比 θ̂2\r\n更有效。\r\n\r\n在无偏估计中，方差越小越好\r\n方差越小 → 估计量的波动越小 →\r\n更可能接近真实值。\r\n\r\n有效性证明的例题\r\n例题1：设总体服从区间 [0, θ] 上的均匀分布，(X1, X2, ⋯, Xn)\r\n为取自该总体的容量为 n\r\n的样本，对未知参数 θ\r\n的两个估计量： $$\r\n\\hat{\\theta}_1 = 2\\bar{X}, \\quad \\hat{\\theta}_2 = \\frac{n + 1}{n}\r\n\\max_{1 \\leq i \\leq n} \\{X_i\\}.\r\n$$\r\n\r\n试验证 θ̂1 和\r\nθ̂2 均为 θ 的无偏估计；\r\n指出哪一个更有效。\r\n\r\n解答： $$\r\nE(\\hat{\\theta}_1) = 2E(\\bar{X}) = 2 \\times \\frac{\\theta}{2} = \\theta\r\n$$\r\n$$\r\nE(X_{(n)}) = \\int_0^\\theta x \\cdot \\frac{n x^{n - 1}}{\\theta^n} \\, dx =\r\n\\frac{n}{n + 1} \\theta\r\n$$\r\n$$\r\nE(\\hat{\\theta}_2) = \\frac{n + 1}{n} E(X_{(n)}) = \\theta\r\n$$\r\n故 θ̂1 和 θ̂2 均为 θ 的无偏估计. $$\r\nD(\\hat{\\theta}_1) = 4D(\\bar{X}) = \\frac{4}{n^2} \\sum_{i = 1}^n D(X_i) =\r\n\\frac{4}{n^2} \\times n \\cdot \\frac{\\theta^2}{12} = \\frac{\\theta^2}{3n}\r\n$$\r\n$$\r\nE(X_{(n)}^2) = \\int_0^\\theta x^2 \\cdot \\frac{n x^{n - 1}}{\\theta^n} \\,\r\ndx = \\frac{n}{n + 2} \\theta^2\r\n$$\r\n$$\r\n\\begin{align*}\r\nD(X_{(n)}) &amp;= E(X_{(n)}^2) - E^2(X_{(n)}) \\\\\r\n&amp;= \\frac{n}{n + 2} \\theta^2 - \\left( \\frac{n}{n + 1} \\theta\r\n\\right)^2 \\\\\r\n&amp;= \\frac{n}{(n + 2)(n + 1)^2} \\theta^2,\r\n\\end{align*}\r\n$$\r\n$$\r\nD(\\hat{\\theta}_2) = \\left( \\frac{n + 1}{n} \\right)^2 D(X_{(n)}) =\r\n\\frac{\\theta^2}{(n + 2)n}\r\n$$\r\n显然当 n &gt; 1 时，$\\frac{1}{n(n + 2)} &lt; \\frac{1}{3n}$，故\r\nθ̂2 比 θ̂1 有效\r\n例题2：设总体 X ∼ B(1, p)\r\n有容量为 n 的样本 (X1, X2, ⋯, Xn)，其中\r\np ∈ (0, 1) 未知. 求 p 的无偏估计量的方差下界.\r\n由 X 的概率分布列 f(x; p) = px(1 − p)1 − x,  x = 0, 1\r\n有 $$\r\n\\frac{\\partial}{\\partial p} \\ln f(x; p) = \\frac{\\partial}{\\partial p}\r\n\\left[ x \\ln p + (1 - x) \\ln (1 - p) \\right] = \\frac{x}{p} - \\frac{1 -\r\nx}{1 - p} = \\frac{x - p}{p(1 - p)}\r\n$$ 从而 $$\r\n\\begin{align*}\r\nI(p) &amp;= E\\left( \\frac{X - p}{p(1 - p)} \\right)^2 \\\\\r\n&amp;= \\frac{1}{p^2(1 - p)^2} E(X - p)^2 \\\\\r\n&amp;= \\frac{1}{p^2(1 - p)^2} D(X) \\\\\r\n&amp;= \\frac{1}{p(1 - p)},\r\n\\end{align*}\r\n$$ 此即，p\r\n的无偏估计量方差下界为 $\\frac{p(1 -\r\np)}{n}$\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"君と彼女と彼女の恋全周目攻略指南","url":"/posts/52250.html","content":"游戏重要注意事项\r\n\r\n存档备份提示：2 周目终点时会删除存档，需提前备份。\r\n\r\nXP\r\n系统存档位置：C:\\Documents and Settings (UserName)\\Application Data\\Nitroplus\\ 君と彼女と彼女の恋\r\nVista、Win7\r\n及以上系统存档位置：C:\\Users (UserName)\\AppData\\Roaming\\Nitroplus\\ 君と彼女と彼女の恋\r\n\r\n3 周目解锁条件：需要游戏包装中附带的 8 位序列号（如\r\n34302111）。\r\n谜题解答要点：3\r\n周目循环路线中的谜题答案需记录美雪对话内容，答案因 PC 环境而异。\r\n1 周目特殊操作：在手机中输入 080 9184 6920\r\n可解锁所有 CG、音乐、场景，但会导致无法继续游戏。\r\n\r\n一周目：美雪路线\r\n关键选择分支\r\nflowchart TD\n    A[&quot;查看通话记录&quot;] --&gt; B[&quot;哔哩哔哩&quot;]\n    B --&gt; C[&quot;做朋友&quot;]\n    C --&gt; D[&quot;给美雪&quot;]\n    D --&gt; E[&quot;Save01存档点&quot;]\n    E --&gt; F[&quot;阻止葵→Normal END&quot;] &amp; G[&quot;不阻止葵→继续剧情&quot;]\n    G --&gt; H[&quot;哔哩哔哩→Save02存档点&quot;]\n    H --&gt; I[&quot;无法相信→BAD END&quot;] &amp; J[&quot;我相信→轻轻点头→1周目END&quot;]\r\n二周目：葵路线\r\n流程与关键选择\r\n\r\n初始选择：寻找历史记录→哔哩哔哩→做朋友→给葵\r\n关键选项\r\n\r\n不放弃 ×2→手机游戏→玩游戏→闯入校舍→寻找浪漫→追随艾尔→做人工呼吸\r\n坐下交谈→葵的事情→发誓→有种不详的预感→告诉我葵的真实想法→葵在撒谎\r\n\r\n存档提示：此时需备份存档，之后选择「最喜欢美雪」触发\r\n2 周目 END。\r\n\r\n三周目启动标志\r\n\r\n游戏途中强制结束后再次启动，出现特殊文字说明 3 周目开始。\r\n\r\n三周目：循环路线\r\n循环机制说明\r\ngraph TD\n    A[循环开始] --&gt; B[美雪问候]\n    B --&gt; C[随机事件]\n    C --&gt; D[睡觉结束一次循环]\n    D --&gt; E&#123;是否记录答案?&#125;\n    E -- 是 --&gt; A\n    E -- 否 --&gt; F[无法解锁结局]\r\n美雪问候选项指南\r\n\r\n\r\n\r\n序号\r\n问候场景\r\n推荐选择\r\n\r\n\r\n\r\n\r\n1\r\n与美雪 / 葵的选择\r\n○和美雪在一起\r\n\r\n\r\n2\r\n记忆保存 / 读取选择\r\n○将与美雪在一起的记忆保存\r\n\r\n\r\n3\r\n房间内外选择\r\n○就在房间里面\r\n\r\n\r\n4\r\n守护 / 战斗选择\r\n○守护美雪\r\n\r\n\r\n5\r\n爱意确认对象选择\r\n○确认与美雪之间的爱意\r\n\r\n\r\n6\r\n对葵的情感选择\r\n○忘记葵\r\n\r\n\r\n7\r\n亲密场景选择\r\n○和美雪一起 S**\r\n\r\n\r\n8\r\n世界认知选择\r\n○努力习惯这个世界\r\n\r\n\r\n9\r\n路线选择\r\n○继续美雪路线\r\n\r\n\r\n10\r\n好感度提升选择\r\n○提高美雪的好感度\r\n\r\n\r\n\r\n循环事件与问题集\r\n序章屋顶上（问题 01、02）\r\n\r\n问题 01：我为什么扔掉了手机？\r\n\r\n因为沾着令人讨厌的回忆\r\n\r\n问题 02：我们同居了多久了？\r\n\r\n随机选项（1 周 / 2 周 / 3 周，需记录）\r\n\r\n\r\n在去学校路上的手牵手（问题\r\n22、18）\r\n\r\n问题 22：上学放学路上会和心一顺便去的地方是？\r\n\r\n有猫的神社\r\n\r\n问题 18：大庭广众下不想牵手的理由是？\r\n\r\n因为觉得别人不愿意看到\r\n\r\n\r\n在屋顶上一起吃便当（问题\r\n10、16、03）\r\n\r\n问题 10：我最擅长的料理是？\r\n\r\n生姜烧肉\r\n\r\n问题 16：下列食物中我最喜欢吃的是？\r\n\r\n布丁\r\n\r\n问题 03：下列食物中我最讨厌的是？\r\n\r\n西柚\r\n\r\n\r\n表演的排练（问题 19、25）\r\n\r\n问题 19：我写过的一个脚本的题目是？\r\n\r\n修罗场！！！\r\n\r\n问题 25：在我写的脚本里，主人公的名字是？\r\n\r\n缜一\r\n\r\n\r\n脱出循环关键事件\r\n\r\n触发条件：循环到一定程度后，出现「剪头发去学校」和「葵从世界消失」事件。\r\n脱出步骤\r\n\r\n在 Memory 中选择「要准备晚饭了」\r\n选择「让美雪去一边休息」触发问题 21\r\n问题 21：心一曾为我做过的料理是？\r\n\r\n汉堡牛肉饼\r\n\r\n按流程打开小袋→拿手机→打开通讯录→回答安全问题（10 题 2 次容错）\r\n\r\n\r\n最终结局分支\r\n结局选择流程\r\nflowchart TD\n    A[&quot;拨打神的电话&quot;] --&gt; B[&quot;不阻止葵→喜欢→拿手机&quot;]\n    B --&gt; C[&quot;去猫身边→拍照→看猫&quot;]\n    C --&gt; D[&quot;对话选择→艾尔相关选项&quot;]\n    D --&gt; E[&quot;分析世界机制→记录号码&quot;]\n    E --&gt; F&#123;&quot;选择美雪/葵&quot;&#125;\n    F -- 美雪 --&gt; G[&quot;美雪END&quot;]\n    F -- 葵 --&gt; H[&quot;葵END&quot;]\n\n    style A color:#FFD600\n\r\n分歧结局详情\r\n选择美雪的场合\r\n\r\n关键对话：「我爱你」→「能相信我吗？」→「一起回去吧」\r\n结局场景：美雪重置世界，两人回到约定的世界，手机掉地触发强制结束。\r\n最终画面：寻找历史记录→美雪\r\nEND，显示「曾根美雪」。\r\n\r\n选择葵的场合\r\n\r\n关键对话：「不会消失的」→「还有很多想要做的事」\r\n结局场景：葵按下按钮，两人进入世界夹缝，最终约定在另一个世界相见。\r\n最终画面：游戏重启→葵 END，显示「葵」。\r\n\r\n全事件收集指南\r\n特殊场景触发条件\r\n\r\n循环 1 个月纪念\r\nScene：触发时选择「内」或「外」。\r\n女仆装\r\nScene：特定循环阶段触发，选择「内」或「外」。\r\n屋顶\r\nScene：观看棒球练习后触发，选择「愿意」或「不愿意」。\r\n\r\n关键问题速查表\r\n\r\n\r\n\r\n问题编号\r\n问题内容\r\n正确答案\r\n\r\n\r\n\r\n\r\n04\r\n叫外卖时会选择的食物\r\n◇中华料理\r\n\r\n\r\n05\r\n幼稚园时的梦想\r\n◇成为魔法少女\r\n\r\n\r\n06\r\n决胜一球的类型\r\n◇叉式球\r\n\r\n\r\n08\r\n最想要的物品\r\n◇试映会的票\r\n\r\n\r\n12\r\n喜欢猫的理由\r\n◇肉球很可爱\r\n\r\n\r\n27\r\n薛定谔实验选猫的理由\r\n◇猫有一种不可思议的力量\r\n\r\n\r\n29\r\n喜欢这条街区的理由\r\n◇因为有心一在\r\n\r\n\r\n30\r\n不擅长的科目\r\n◇物理\r\n\r\n\r\n\r\n重要机制补充说明\r\n电话号码计算规则\r\n\r\n神的电话号码：需通过美雪对话记录「神明大人的电话号码」\r\n计算公式：神的电话号码 - 游戏 keycode (34302111) +\r\n美雪的变数\r\n注意事项：美雪会动态更改号码，需实时记录对话中的变数信息。\r\n\r\n存档与读档策略\r\n\r\n2\r\n周目存档：必须在「最喜欢美雪」选择前备份，否则无法进入 3\r\n周目。\r\n3\r\n周目循环：建议每次循环后记录问题答案，避免重复游玩。\r\n结局回收：分歧结局需恢复对应存档重新选择，问题答案固定但美雪变数会更新。\r\n\r\n","categories":["其他","galgame相关","攻略"],"tags":["其他","galgame","攻略","杂项","galgame相关"]},{"title":"命令行的艺术-个人整理版","url":"/posts/39685.html","content":"前言\r\n这是我根据我的日常使用和学习过程中对命令行的常见使用基于 命令行的艺术\r\n进行了整理\r\n我将强化作者所说的，本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及\r\n可能并没有那么简洁，因为我不打算写的过于粗糙））））））\r\n该文章不仅是命令行的常用命令，而且涉及到常用的技巧\r\n文章大部分内容是为 Linux 系统编写的，主要关注于交互式\r\nBash，包括基础命令、日常使用技巧、文件及数据处理、系统调试等方面，这些技巧在\r\nLinux 系统的交互式 Bash 环境中均可使用，但也涵盖了部分 OS X 系统和\r\nWindows 系统的相关内容\r\n遇到问题时，记得多用 man 或 --help\r\n查看文档\r\n只要我活着并且使用命令行并且不忘了），我就会尝试更新这篇文章\r\n\r\n基础\r\nls 和 ls -l\r\n\r\n作用：列出目录内容。\r\n常用选项：\r\n\r\n-l：显示详细信息（权限、所有者、大小、修改时间）。\r\n-a：显示隐藏文件。\r\n-h：以易读格式显示文件大小（如 1K、2M）。\r\n\r\n示例：\r\nls -lah  # 列出所有文件（含隐藏文件），显示详细信息并以易读格式展示大小\r\n\r\ngrep\r\n\r\n作用：文本搜索工具，支持正则表达式。\r\n常用选项：\r\n\r\n-i：忽略大小写。\r\n-v：反向匹配（显示不包含关键字的行）。\r\n-r：递归搜索目录中的文件。\r\n\r\n示例：\r\ngrep -ri &quot;error&quot; /var/log  # 在 /var/log 目录中递归搜索包含 &quot;error&quot; 的行（忽略大小写）\r\n\r\nman\r\n\r\n作用：查看命令的手册页。\r\n示例\r\nman ls  # 查看 ls 命令的详细用法\r\n\r\n日常使用\r\nCtrl+R\r\n\r\n作用：反向搜索命令历史记录，输入关键字可快速定位并执行历史命令。\r\n示例： 按 Ctrl+R，输入\r\nssh，可快速找到最近执行的 SSH 命令。\r\n\r\nhistory\r\n\r\n作用：显示命令历史记录。\r\n常用技巧：\r\n\r\n!n：执行历史记录中第 n 条命令。\r\n!!：重复上一条命令。\r\n!$：引用上一条命令的最后一个参数。\r\n\r\n示例\r\n!100  # 执行历史记录中第 100 条命令\r\n\r\nalias\r\n\r\n作用：创建命令别名，简化复杂操作。\r\n示例：\r\nalias ll=&#x27;ls -alh&#x27;  # 输入 ll 即可执行 ls -alh\r\n\r\n文件及数据处理\r\nfind\r\n\r\n作用：查找文件或目录。\r\n常用选项：\r\n\r\n-name：按名称匹配。\r\n-type：按类型过滤（如 f\r\n表示文件，d 表示目录）。\r\n\r\n示例：\r\nfind ~ -name &quot;*.txt&quot; -type f  # 在主目录查找所有 .txt 文件\r\n\r\nawk\r\n\r\n作用：处理文本数据，按列提取或计算。\r\n示例：\r\nawk &#x27;&#123;sum += $1&#125; END &#123;print sum&#125;&#x27; data.txt  # 计算第一列的总和\r\n\r\nsed\r\n\r\n作用：流编辑器，用于文本替换或删除。\r\n示例：\r\nsed &#x27;s/foo/bar/g&#x27; file.txt  # 将文件中所有 &quot;foo&quot; 替换为 &quot;bar&quot;\r\n\r\n系统调试\r\ntop / htop\r\n\r\n作用：实时监控系统进程和资源占用。\r\n区别：htop\r\n更直观，支持鼠标操作和颜色高亮。\r\n示例：\r\nhtop  # 查看 CPU、内存使用情况，并支持排序和进程管理\r\n\r\nnetstat / ss\r\n\r\n作用：查看网络连接和端口状态。\r\n常用选项：\r\n\r\n-t：显示 TCP 连接。\r\n-l：仅显示监听中的端口。\r\n\r\n示例：\r\nnetstat -tuln  # 列出所有 TCP/UDP 监听端口\r\n\r\ndmesg\r\n\r\n作用：查看内核日志，常用于排查硬件或驱动问题。\r\n示例：\r\ndmesg | grep &quot;error&quot;  # 筛选内核日志中的错误信息\r\n\r\n单行脚本\r\n统计文件行数\r\nwc -l file.txt  # 直接统计\r\n快速备份文件\r\ncp file.txt&#123;,.bak&#125;  # 生成 file.txt.bak\r\n批量重命名文件\r\nfor f in *.log; do mv &quot;$f&quot; &quot;$&#123;f%.log&#125;.txt&quot;; done  # 将所有 .log 后缀改为 .txt\r\n冷门但是有用\r\nnc (Netcat)\r\n\r\n作用：网络调试工具，支持 TCP/UDP 数据传输。\r\n示例： nc -zv example.com 80  # 检查 example.com 的 80 端口是否开放\r\n\r\ndd\r\n\r\n作用：复制文件或设备，常用于创建镜像或测试\r\nI/O。\r\n示例： dd if=/dev/zero of=testfile bs=1M count=100  # 生成一个 100MB 的空文件\r\n\r\n仅限 OS X\r\nbrew\r\n\r\n作用：包管理器，用于安装 Unix 工具。\r\n示例：\r\nbrew install wget  # 安装 wget\r\n\r\npbcopy / pbpaste\r\n\r\n作用：与剪贴板交互。\r\n示例：\r\ncat file.txt | pbcopy  # 将文件内容复制到剪贴板\r\n\r\n仅限 Windows\r\nCygwin\r\n\r\n作用：在 Windows 中提供类 Unix 环境。\r\n示例： 安装后可直接使用\r\ngrep、ssh 等命令。\r\n\r\nwmic\r\n\r\n作用：执行系统管理任务，如查看进程信息。\r\n示例：\r\nwmic process list brief  # 列出正在运行的进程\r\n\r\n","categories":["学习类","命令"],"tags":["学习类","实用知识","常用知识","配置相关","知识总结","Linux","Git","命令行"]},{"title":"大数定律部分定理详解","url":"/posts/19945.html","content":"切比雪夫不等式\r\n定理内容\r\n设随机变量X的期望和方差均存在，则对任意ε &gt; 0，有 $$\r\nP(\\vert X - EX\\vert\\geq\\varepsilon)\\leq\\frac{DX}{\\varepsilon^{2}}\r\n$$ 等价形式为 $$\r\nP(\\vert X - EX\\vert&lt;\\varepsilon)\\geq1 - \\frac{DX}{\\varepsilon^{2}}\r\n$$\r\n定理内容解释\r\n切比雪夫不等式告诉我们主要就一件事，对于一个随机变量 X，，如果它的平均值（期望 EX）和波动程度（方差 DX）都知道，那么 X\r\n的值偏离平均值太远的概率是有限的。\r\n\r\n表示即使分布未知，随机变量的取值落在期望左右的一定范围内的概率是有界的，该界限和方差有关。DX\r\n越小，落在某范围内的概率就越大，表示 X\r\n取值的概率分布越集中。也就是说，方差 DX 可以表示随机变量 X\r\n取值的离散程度。\r\n描述了任意随机变量的取值偏离其期望值的概率上限，不依赖于具体分布，仅需要方差存在.\r\n\r\n具体来说：\r\n\r\n偏离的概率：X 的值与平均值的差距超过某个阈值\r\nϵ（比如比平均值高或低超过\r\n10）的概率 P( ∣ X − EX ∣  ≥ ϵ)，最多不超过\r\n$\\frac{DX}{\\varepsilon^{2}}$。\r\n\r\n方差 DX\r\n越大，数据波动越大，偏离的概率也可能越大。\r\n阈值 ϵ\r\n越大，允许的偏离范围越宽松，概率的上限$\\frac{DX}{\\varepsilon^{2}}$ 会越小。\r\n\r\n集中在平均值的概率：反过来，X 的值落在平均值附近 ϵ 范围内的概率 P( ∣ X − EX ∣  &lt; ϵ)，至少是\r\n$1 - \\frac{DX}{\\varepsilon^{2}}$。\r\n\r\n这说明数据集中在平均值附近的概率是有保障的。\r\n\r\n\r\n切比雪夫不等式不需要知道随机变量的具体分布（比如是不是正态分布），只要知道平均值和方差，就能给出概率的界限。它是一种非常通用的工具，适用于任何方差存在的随机变量。\r\n不知道随机变量的分布的原因，其实会在大数定律部分有严谨的体现。\r\n证明\r\n\r\n方差的定义： 随机变量 X 的方差 DX 定义为： DX = E[(X − EX)2]\r\n概率的积分表示： 对于事件 A，其概率 P(A) 可以表示为： P(A) = ∫AdP\r\n\r\n设 X 是一个随机变量，期望\r\nEX 和方差 DX 均存在。对任意 ε &gt; 0，定义事件： A = {|X − EX| ≥ ε}\r\n我们需要证明： $$\r\nP(|X - EX| \\geq \\varepsilon) \\leq \\frac{DX}{\\varepsilon^2}\r\n$$ 从方差的定义出发：\r\n$$\r\n\\begin{aligned}\r\nDX &amp;= E\\left[(X - EX)^2\\right] \\\\\r\n&amp;= \\int_{-\\infty}^{\\infty} (x - EX)^2 \\, dP(x) \\\\\r\n&amp;\\geq \\int_A (x - EX)^2 \\, dP(x) \\quad \\text{(因为积分区域缩小到\r\n$A$)}\r\n\\end{aligned}\r\n$$\r\n事件 A 上的估计\r\n在事件 A 上，|X − EX| ≥ ε，因此\r\n(X − EX)2 ≥ ε2。于是：\r\n∫A(x − EX)2 dP(x) ≥ ∫Aε2 dP(x) = ε2P(A)\r\n将步骤 1 和步骤 2 的结果结合：\r\nDX ≥ ε2P(A)\r\n整理后得到： $$\r\nP(A) \\leq \\frac{DX}{\\varepsilon^2}\r\n$$ 即： $$\r\nP(|X - EX| \\geq \\varepsilon) \\leq \\frac{DX}{\\varepsilon^2}\r\n$$ 由概率的补集性质：\r\n$$\r\nP(|X - EX| &lt; \\varepsilon) = 1 - P(|X - EX| \\geq \\varepsilon) \\geq 1 -\r\n\\frac{DX}{\\varepsilon^2}\r\n$$ 得证\r\n极限定理\r\n定理内容\r\n大数定理：\r\n\r\n定义内容：设 X1, X2, ⋯\r\n是一列随机变量，令$ n={i = 1}^{n}X_i，n = 1, 2, $ 。若存在常数列 a1, a2, ⋯，对于任意的\r\nε &gt; 0，有 $$\r\n\\lim_{n\\rightarrow\\infty}P(|\\overline{X}_n - a_n|&lt;\\varepsilon)=1\r\n$$ 则称序列 X1, X2, ⋯\r\n服从大数定律 ；其等价形式是对任意 ε &gt; 0，有 $$\r\n\\lim_{n\\rightarrow\\infty}P(|\\overline{X}_n - a_n|\\geq\\varepsilon)=0\r\n$$\r\n\r\n依概率收敛定义\r\n\r\n定义内容：设 X1, X2, ⋯, Xn, ⋯\r\n为一列随机变量，对常数 a\r\n及任意$ &gt;0，有$\r\n{n}P(|X_n - a|&lt;)=1 $$ 则称序列 $X_1, X_2, , X_n, 依概率收敛于\r\na$ ，简记为 $X_n\\stackrel{p}{\\longrightarrow}a$ 或\r\n${n}X_n = a (p) $。\r\n\r\n解释\r\n其实单去理解这个东西不太好理解，但是你结合具体的大数定律的内容去看，然后回来再看估计一眼就丁真了\r\n大数定理部分的直观内容解释一下就是，当 n → ∞ 时，事件 ${|_n - a_n|&lt;}\r\n的概率趋于1，即对任意&gt;0$，当\r\nn 充分大时，不等式$ _n -\r\na_n&lt;$以任意接近于 1 的概率成立 。\r\n而依概率收敛定义部分的内容直观解释一下，当$ n 足够大时，随机变量\r\nX_n$ 落在以 $a 为中心、$\r\n为半径的邻域内的概率趋近于 1\r\n，反映了随机变量序列在概率意义下趋近于某个常数的规律 。\r\n证明\r\n只证明基于切比雪夫不等式的\r\n假设 Xn\r\n满足： 1. 两两不相关：Cov(Xi, Xj) = 0 (i ≠ j)\r\n2. 方差一致有界：supiVar(Xi) ≤ C &lt; ∞\r\n3. 设 Xn\r\ni.i.d. 且 E[X1] = μ，取\r\n$X_n = \\overline{X}_n$, a = μ\r\n证明大数定理：\r\n\r\n期望计算： $$\r\nE[\\overline{X}_n] = \\frac{1}{n}\\sum_{i=1}^n E[X_i] := \\mu_n\r\n$$\r\n方差计算： $$\r\n\\text{Var}(\\overline{X}_n) = \\frac{1}{n^2}\\sum_{i=1}^n \\text{Var}(X_i)\r\n\\leq \\frac{nC}{n^2} = \\frac{C}{n}\r\n$$\r\n取常数列 an = μn，应用切比雪夫不等式：\r\n$$\r\nP(|\\overline{X}_n - \\mu_n| \\geq \\varepsilon) \\leq\r\n\\frac{\\text{Var}(\\overline{X}_n)}{\\varepsilon^2} \\leq\r\n\\frac{C}{n\\varepsilon^2}\r\n$$\r\n取极限： $$\r\n\\lim_{n\\to\\infty} P(|\\overline{X}_n - \\mu_n| \\geq \\varepsilon) \\leq\r\n\\lim_{n\\to\\infty} \\frac{C}{n\\varepsilon^2} = 0\r\n$$\r\n等价形式转换： $$\r\n\\lim_{n\\to\\infty} P(|\\overline{X}_n - \\mu_n| &lt; \\varepsilon) = 1 -\r\n\\lim_{n\\to\\infty} P(|\\overline{X}_n - \\mu_n| \\geq \\varepsilon) = 1\r\n$$\r\n\r\n证明依概率收敛\r\n\r\n切比雪夫不等式直接应用： $$\r\nP(|\\overline{X}_n - \\mu| \\geq \\varepsilon) \\leq\r\n\\frac{\\text{Var}(\\overline{X}_n)}{\\varepsilon^2} =\r\n\\frac{\\sigma^2}{n\\varepsilon^2}\r\n$$\r\n取概率补集： $$\r\nP(|\\overline{X}_n - \\mu| &lt; \\varepsilon) \\geq 1 -\r\n\\frac{\\sigma^2}{n\\varepsilon^2}\r\n$$\r\n极限操作： $$\r\n\\lim_{n\\to\\infty} P(|\\overline{X}_n - \\mu| &lt; \\varepsilon) \\geq\r\n\\lim_{n\\to\\infty} \\left(1 - \\frac{\\sigma^2}{n\\varepsilon^2}\\right) = 1\r\n$$ 又因概率不超过1，故得： $$\r\n\\lim_{n\\to\\infty} P(|\\overline{X}_n - \\mu| &lt; \\varepsilon) = 1\r\n$$\r\n\r\n切比雪夫大数定律（Chebyshev’s\r\nLaw of Large Numbers）\r\n定理内容\r\n设 X1, X2, …, Xn\r\n为两两不相关的随机变量序列，且满足： 1.\r\n期望存在：E[Xi] = μi（允许不同期望）\r\n2. 方差存在且具有公共上界：存在常数 C &gt; 0，使得 D(Xi) ≤ C\r\n对所有 i 成立\r\n则对任意 ε &gt; 0，有：\r\n$$\r\n\\lim_{n \\to \\infty} P\\left( \\left| \\frac{1}{n} \\sum_{i=1}^n X_i -\r\n\\frac{1}{n} \\sum_{i=1}^n \\mu_i \\right| \\geq \\varepsilon \\right) = 0\r\n$$\r\n特别地，若 μ1 = μ2 = … = μ（同期望），则简化为：\r\n$$\r\n\\lim_{n \\to \\infty} P\\left( \\left| \\frac{1}{n} \\sum_{i=1}^n X_i - \\mu\r\n\\right| \\geq \\varepsilon \\right) = 0\r\n$$\r\n上述为原型定理描述，下述为切比雪夫大数定律的等价概率收敛形式\r\n$$\r\n\\lim_{n \\to \\infty} P\\left( \\left| \\frac{1}{n} \\sum_{i=1}^n X_i -\r\n\\frac{1}{n}E \\sum_{i=1}^n \\mu_i \\right| &lt; \\varepsilon \\right) = 1\r\n$$ 特别地，当随机变量序列Xn两两独立或者两两不相关，且有相同的有限期望和方差时(记为\r\nEXn = μ，DXn = σ2，n = 1, 2, ...)，则对任意 ϵ &gt; 0，有 $$\r\n\\lim_{n \\to \\infty} P\\left( \\left| \\frac{1}{n} \\sum_{i=1}^n X_i - \\mu\r\n\\right| &lt; \\varepsilon \\right) = 1\r\n$$ 这个内容描述了样本均值与期望均值的渐近一致性。当 n → ∞\r\n时，样本均值与期望均值的差距小于任意正数 ε 的概率趋近于 1。\r\n定理内容解释\r\n我习惯使用切比雪夫大数定律的等价概率收敛形式，而这个形式与原形式完全等价且更容易理解\r\n大数定理简单来说，指得是某个随机事件在单次试验中可能发生也可能不发生，但在大量重复实验中往往呈现出明显的规律性\r\n即该随机事件发生的频率会向某个常数值收敛，该常数值即为该事件发生的概率。\r\n所以切比雪夫大数定律也是一样，等价概率收敛形式就是描述了当样本数据无限大时，样本均值趋于总体均值\r\n这相当于告诉我们，能用频率近似代替概率；能用样本均值近似代替总体均值。使得现实问题被很好解决，而切比雪夫大数定律的等价概率收敛形式是一种弱大数定理，他揭示的内容就是样本均值和真实期望的关系\r\n即样本均值会随着n的不断增大，依概率收敛（简称i.p.收敛 converge in\r\nprobability,）到真正的总体平均值。\r\n而依概率收敛的意思是，当n越来越大时，随机变量X落在 (c − ε, c + ε)\r\n外的概率趋近于0，不过还是有可能落在外面的，只不过可能是很小，且会随着n的增大，这种可能越来越小。\r\n想象一次抛硬币实验：\r\n\r\n设Xi表示第i次抛硬币的结果（正面=1，反面=0）\r\n期望μ = 0.5（公平硬币）\r\n当我们抛n次后，计算正面的比例$\\frac{1}{n}\\sum X_i$\r\n\r\n当抛硬币次数n越来越大时：\r\n\r\n正面的比例几乎必定会非常接近0.5\r\n想要这个比例与0.5的差距超过 ε（对任意 ε &gt; 0，可以取任意大于0的常数）的概率会趋近于0\r\n或者说，比例落在(0.5 − ε, 0.5 + ε)内的概率趋近于100%\r\n\r\n证明\r\n只给出基于切比雪夫不等式推导切比雪夫大数定律的等价概率收敛形式证明\r\n令样本均值为： $$\r\n\\overline{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i\r\n$$\r\n由期望的线性性得到均值： $$\r\nE[\\overline{X}_n] = \\frac{1}{n} \\sum_{i=1}^n E[X_i] = \\frac{1}{n} \\cdot\r\nn \\mu = \\mu\r\n$$\r\n计算方差\r\n由于两两不相关： $$\r\n\\begin{aligned}\r\n\\text{Var}(\\overline{X}_n) &amp;= \\text{Var}\\left( \\frac{1}{n}\r\n\\sum_{i=1}^n X_i \\right) \\\\\r\n&amp;= \\frac{1}{n^2} \\text{Var}\\left( \\sum_{i=1}^n X_i \\right) \\\\\r\n&amp;= \\frac{1}{n^2} \\sum_{i=1}^n \\text{Var}(X_i) \\quad\r\n(\\text{协方差项为0}) \\\\\r\n&amp;= \\frac{1}{n^2} \\cdot n \\sigma^2 = \\frac{\\sigma^2}{n}\r\n\\end{aligned}\r\n$$\r\n应用切比雪夫不等式\r\n对随机变量 $\\overline{X}_n$\r\n应用切比雪夫不等式： $$\r\nP(|\\overline{X}_n - E[\\overline{X}_n]| \\geq \\varepsilon) \\leq\r\n\\frac{\\text{Var}(\\overline{X}_n)}{\\varepsilon^2}\r\n$$ 代入已求得的期望和方差： $$\r\nP(|\\overline{X}_n - \\mu| \\geq \\varepsilon) \\leq \\frac{\\sigma^2}{n\r\n\\varepsilon^2}\r\n$$\r\n取概率补集 $$\r\n\\begin{aligned}\r\nP(|\\overline{X}_n - \\mu| &lt; \\varepsilon) &amp;= 1 - P(|\\overline{X}_n\r\n- \\mu| \\geq \\varepsilon) \\\\\r\n&amp;\\geq 1 - \\frac{\\sigma^2}{n \\varepsilon^2}\r\n\\end{aligned}\r\n$$\r\n取极限，当 n → ∞ 时： $$\r\n\\lim_{n \\to \\infty} \\left( 1 - \\frac{\\sigma^2}{n \\varepsilon^2} \\right)\r\n= 1\r\n$$ 由于概率不超过1，由夹逼定理得： $$\r\n\\lim_{n \\to \\infty} P(|\\overline{X}_n - \\mu| &lt; \\varepsilon) = 1\r\n$$\r\n一些证明细节补充\r\n\r\n不相关条件的必要性 证明中关键步骤： Var(∑Xi) = ∑Var(Xi)\r\n这要求协方差 Cov(Xi, Xj) = 0 (i ≠ j)。若存在相关性，需修正为：\r\nVar(∑Xi) = ∑Var(Xi) + 2∑i &lt; jCov(Xi, Xj)\r\n方差有限的关键作用\r\n若 σ2 无限大：\r\n$$\r\n\\frac{\\sigma^2}{n \\varepsilon^2} \\to \\infty\r\n$$ 导致切比雪夫不等式失效。\r\n收敛速度估计\r\n概率下界： $$\r\nP(|\\overline{X}_n - \\mu| &lt; \\varepsilon) \\geq 1 - \\frac{\\sigma^2}{n\r\n\\varepsilon^2}\r\n$$ 要达到置信水平 1 − α，所需样本量： $$\r\nn &gt; \\frac{\\sigma^2}{\\alpha \\varepsilon^2}\r\n$$\r\n\r\n林德伯格-莱维中心极限定理\r\n定理内容\r\n以下简述为独立同分布的中心极限定理\r\n设随机变量列{Xn}，n = 1, 2, ⋯独立同分布，具有有限的期望和方差，EXn = μ，DXn = σ2 ≠ 0，n = 1, 2, ⋯。\r\n则随机变量： $$\r\nY_n = \\frac{\\sum_{i = 1}^{n}X_i - n\\mu}{\\sqrt{n}\\sigma}\r\n$$ 其分布函数Fn(x)，对任意实数x，有：\r\n$$\r\n\\lim_{n\\rightarrow\\infty}F_n(x)=\\lim_{n\\rightarrow\\infty}P\\left(\\frac{\\sum_{i\r\n= 1}^{n}X_i - n\\mu}{\\sqrt{n}\\sigma}\\leq\r\nx\\right)=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{x}e^{-\\frac{t^2}{2}}dt\r\n$$ 也可等价表示为（标准化形式变形），令 $$\r\nY_n = \\frac{\\frac{1}{n}\\sum_{i = 1}^{n}X_i -\r\n\\mu}{\\frac{\\sigma}{\\sqrt{n}}}\r\n$$\r\n则该定理描述在独立同分布且期望、方差有限的条件下，标准化后的随机变量列Yn的分布以标准正态分布N(0, 1)为极限分布 ，即当n充分大时，Yn近似服从标准正态分布，$_{i\r\n= 1}{n}X_i近似服从正态分布N(n,n2) $。\r\n描述如下 $$\r\n\\begin{align*}\r\nY_n &amp;= \\dfrac{\\dfrac{1}{n}\\sum_{i=1}^{n}X_i -\r\n\\mu}{\\dfrac{\\sigma}{\\sqrt{n}}} \\\\\r\n&amp;= \\dfrac{\\sum_{i=1}^{n}X_i - n\\mu}{\\sigma\\sqrt{n}} \\\\\r\n&amp;\\xrightarrow{n\\to\\infty} \\mathcal{N}(0,1)\r\n\\end{align*}\r\n$$\r\n解释\r\n就是一件事\r\n无论原始数据是什么分布，只要满足一定条件，当样本量足够大时，样本均值的分布都会变成”钟形曲线”（正态分布）。\r\n我们上面提到的大数定理的内容，样本的平均值约等于总体的平均值，其实跟这个有很大联系，如果你满足了这个条件，那么就很容易能知道，不管总体是什么分布，任意一个总体的样本平均值都会围绕在总体的整体平均值周围，并且呈正态分布，而且还是标准正态分布。\r\n所以我们看到中心极限定理其实是包含了大数定理的，也就是样本的平均值约定于或者说依概率收敛于总体的平均值。但是自己本身又描述了当样本量足够大时，样本均值的分布都会趋于正态分布这件事。\r\n下述找到的一个描述定理内容的内容，这也就是说上面这件事\r\n设 Xn\r\n是独立同分布(i.i.d.)的随机变量序列，且： 1. E[Xi] = μ\r\n2. Var(Xi) = σ2 &lt; ∞\r\n则当 n → ∞\r\n时，标准化样本均值的分布收敛到标准正态分布： $$\r\n\\frac{\\overline{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1)\r\n$$ 其中 $\\overline{X}_n =\r\n\\frac{1}{n}\\sum_{i=1}^n X_i$\r\n标准化的过程如下 $$\r\nZ_n = \\frac{\\overline{X}_n - \\mu}{\\sigma/\\sqrt{n}} =\r\n\\frac{\\text{样本均值} - \\text{理论均值}}{\\text{标准误}}\r\n$$ - 分子：中心化（消除均值影响） - 分母：按波动幅度缩放\r\n还是以抛硬币为例子\r\n\r\n抛硬币n次，记正面为1，反面为0\r\n设Xi表示第i次结果，则μ = 0.5，σ2 = 0.25\r\n\r\n假设一个下述表格啊\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n实验次数n\r\n总正面数Sn\r\n标准化形式 $\\frac{S_n -\r\nn\\mu}{\\sigma\\sqrt{n}}$\r\n分布形状\r\n\r\n\r\n\r\n\r\n10\r\n5\r\n0\r\n离散\r\n\r\n\r\n100\r\n55\r\n1.0\r\n接近钟形\r\n\r\n\r\n10,000\r\n5,050\r\n1.0\r\n完美正态\r\n\r\n\r\n\r\n至于为什么要独立同分布，因为若Xi分布不同，可能需要更复杂的林德伯格条件，会爆炸\r\n证明\r\n这个证明扫码了\r\n\r\n前置知识\r\n特征函数定义 ϕY(t) = E[eitY]\r\n- N(0, 1) 的特征函数：ϕ(t) = e−t2/2\r\n- 独立随机变量和的特征函数：ϕX + Y(t) = ϕX(t)ϕY(t)\r\n- 标准化：ϕaY(t) = ϕY(at)\r\n\r\n标准化先\r\n令 $Y_i = \\frac{X_i -\r\n\\mu}{\\sigma}$，则： - E[Yi] = 0\r\n- Var(Yi) = 1 -\r\n$Z_n = \\frac{1}{\\sqrt{n}}\\sum_{i=1}^n\r\nY_i$\r\n计算 Zn\r\n的特征函数 $$\r\n\\begin{aligned}\r\n\\phi_{Z_n}(t) &amp;= E\\left[ \\exp\\left( it \\cdot\r\n\\frac{1}{\\sqrt{n}}\\sum_{k=1}^n Y_k \\right) \\right] \\\\\r\n&amp;= \\prod_{k=1}^n E\\left[ \\exp\\left( \\frac{it}{\\sqrt{n}} Y_k \\right)\r\n\\right] \\quad (\\text{独立性}) \\\\\r\n&amp;= \\left[ \\phi_Y\\left( \\frac{t}{\\sqrt{n}} \\right) \\right]^n \\quad\r\n(\\text{同分布})\r\n\\end{aligned}\r\n$$\r\nTaylor 展开 ϕY(t)\r\n在 t = 0 处展开特征函数：\r\n$$\r\n\\phi_Y(t) = 1 + itE[Y] - \\frac{t^2}{2}E[Y^2] + o(t^2)\r\n$$ 代入 E[Y] = 0 和 E[Y2] = 1 得：\r\n$$\r\n\\phi_Y(t) = 1 - \\frac{t^2}{2} + o(t^2)\r\n$$\r\n近似 $\\phi_Y(t/\\sqrt{n})$\r\n对于固定 t，当 n → ∞ 时： $$\r\n\\phi_Y\\left( \\frac{t}{\\sqrt{n}} \\right) = 1 - \\frac{t^2}{2n} + o\\left(\r\n\\frac{t^2}{n} \\right)\r\n$$\r\n取对数展开 $$\r\n\\begin{aligned}\r\n\\ln \\phi_{Z_n}(t) &amp;= n \\ln \\left[ 1 - \\frac{t^2}{2n} + o\\left(\r\n\\frac{1}{n} \\right) \\right] \\\\\r\n&amp;= n \\left[ -\\frac{t^2}{2n} + o\\left( \\frac{1}{n} \\right) \\right]\r\n\\quad (\\text{利用} \\ln(1+x) \\approx x) \\\\\r\n&amp;= -\\frac{t^2}{2} + o(1)\r\n\\end{aligned}\r\n$$\r\n指数化取极限 $$\r\n\\lim_{n \\to \\infty} \\phi_{Z_n}(t) = \\lim_{n \\to \\infty} \\exp\\left(\r\n-\\frac{t^2}{2} + o(1) \\right) = e^{-t^2/2}\r\n$$\r\n由特征函数逐点收敛： ϕZn(t) → e−t2/2  ∀t ∈ ℝ\r\n根据 Levy 连续性定理，即得 $Z_n\r\n\\xrightarrow{d} N(0,1)$。\r\n\r\n补充说明\r\n需要验证： $$\r\nn \\cdot o\\left( \\frac{t^2}{n} \\right) \\to 0\r\n$$ 这由特征函数在 0\r\n处的二阶可导性保证。 而且 正态分布的特征函数 e−t2/2\r\n是唯一的，确保收敛目标明确。\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"如何在GitHub中的开源项目中做出贡献","url":"/posts/9517.html","content":"前言\r\n由于近期主包看中了一个项目，所以搞了一些 svg\r\n作为贡献提了上去，发现很多人想做贡献但是不会）\r\n\r\n前提\r\n贴一下 Git 基础配置\r\n# 配置用户名和邮箱git config --global user.name &quot;您的用户名&quot;git config --global user.email &quot;您的邮箱@example.com&quot;# 配置SSH密钥（推荐）ssh-keygen -t ed25519 -C &quot;您的邮箱@example.com&quot;# 将生成的公钥添加到GitHub账号设置中\r\n你得找好项目，评估一下项目现在处于什么水平，然后去做什么样的贡献。\r\n通过 GitHub\r\n的stars、forks、issues活跃度和最近更新时间筛选，优先选择近\r\n3 个月有提交的项目。要不然你的 PR 很有可能就会放置很久。\r\n练习提交第一个PR，这对于开源新手来说会是一个很好的开始，GitHub\r\n官方也知道这件事，一般新手可从good first issue标签的任务入手（许多项目会用该标签标记适合新手的任务）。\r\n练习仓地址：https://github.com/TinaSprunt/How-to-contribute-code-to-the-open-source-community\r\n在练习仓库可以轻松的提交任何东西，不必担心产生错误，这只是一个练习git的流程。无论提交啥反正我都会通过的。\r\n一般在进行贡献之前，可以看看项目是否有这种文档，如果有，按照规范去做可以避免很多PR被拒绝的情况\r\n\r\nCONTRIBUTING.md: 贡献指南和规范\r\nCODE_OF_CONDUCT.md: 行为准则\r\n\r\nfork 社区仓库\r\n打开你想参与贡献的社区的仓库的 github 页面，并且\r\nfork(复刻) 这个仓库到你的 GitHub 账号\r\n\r\n\r\nimage-20250603200720297\r\n\r\n打开你自己的 github 页面，此时应该会多一个仓与你刚\r\nfork 的仓库同名的复刻仓库\r\n同步上游仓库\r\n首先先把 fork 的仓库克隆到本地，在这个本地仓库进行修改\r\n添加的上游仓库名叫 upstream 开头的\r\n# 克隆个人仓库到本地git clone https://github.com/你的用户名/项目名.gitcd 项目名# 添加上游仓库（原项目地址）git remote add upstream https://github.com/原项目作者/项目名.git# 查看远程仓库git remote -v\r\n如果你的项目如果是已经 fork\r\n了一段时间的，官方可能已经进行了很多修改，与你 fork\r\n下来的时候不一样了，就需要 fetch upstream\r\n查看官方更新，点击 fetch and merge 按钮进行同步\r\n或者拉取上游仓库文件，进行同步\r\ngit fetch upstream\r\n或者\r\n# 1. 同步最新代码git checkout maingit pull upstream maingit push origin main\r\n创建修改分支\r\n基于main或develop分支创建新分支，注意部分仓库这里是需要有命名规范的：\r\n# 拉取上游最新代码git fetch upstream# 2. 创建新分支git checkout -b feature/您的功能名称# 或git checkout -b fix/修复的bug名称\r\n之后进行开发需要注意\r\n\r\n遵循项目的代码风格\r\n编写清晰的代码注释\r\n添加必要的测试\r\n确保所有测试通过\r\n\r\n提交更改\r\n规范提交信息，遵循Header: Body格式：\r\n# 1. 查看更改git statusgit diff# 2. 添加更改到暂存区git add .# 或选择性添加git add 文件名# 3. 提交更改git commit -m &quot;类型: 简洁描述\r\n\r\nHeader 类型说明\r\n\r\nfix：修复 bug\r\nfeat：新增功能\r\ndocs：文档更新\r\nrefactor：代码重构\r\ntest：测试用例添加\r\n\r\n\r\n推送分支并创建 PR\r\n推送到个人仓库\r\n# 推送分支到您的Forkgit push origin feature/您的功能名称\r\n在 GitHub 上进入你的仓库，点击\r\nCompare &amp; pull request按钮，选择正确的目标分支（通常是main或master），填写\r\nPR 模板：\r\n\r\n标题：简明描述变更（如Fix NPE in login interface）\r\n正文：说明变更原因、影响范围、测试结果\r\n关联 Issue：如果修复某个\r\nIssue，添加Closes #123\r\n\r\n\r\n\r\nimg\r\n\r\n之后就是等待上游仓库的所有者合并了\r\n\r\n\r\nimg\r\n\r\n如果长时间无响应，礼貌提醒维护者（如Hi, just checking if there's any update on this PR）\r\n处理修改请求\r\n上游仓库的所有者可能提出修改建议，需要你处理，这时候需要更改\r\n# 1. 在原分支上进行修改git checkout feature/您的功能名称# 2. 进行必要的修改# 3. 提交修改git add .git commit -m &quot;根据审查反馈进行修改&quot;# 4. 推送更新git push origin feature/您的功能名称\r\n如果PR 与上游代码冲突，需要合并冲突\r\n# 拉取上游最新代码git fetch upstream# 切换到本地分支git checkout feature/修复登录接口# 合并上游main分支git merge upstream/main# 解决冲突后提交git commit -am &quot;fix: 解决合并冲突&quot;git push origin feature/修复登录接口\r\n维护者合并 PR 后，同步到本地：\r\ngit checkout maingit fetch upstreamgit merge upstream/main# 删除本地已合并分支git branch -d feature/修复登录接口\r\n","categories":["实用","教程"],"tags":["教程","学习类","实用知识","攻略","Git"]},{"title":"对书上证明样本方差是总体方差的无偏估计量的解析","url":"/posts/6458.html","content":"问题描述\r\n设总体服从区间 [0, θ]\r\n上的均匀分布，(X1, X2, ⋯, Xn)\r\n为取自该总体的容量为 n\r\n的样本。对未知参数 θ\r\n的两个估计量：\r\n$$\r\n\\hat{\\theta}_1 = 2\\bar{X}, \\quad \\hat{\\theta}_2 = \\frac{n+1}{n} \\max_{1\r\n\\leq i \\leq n} \\{ X_i \\}.\r\n$$\r\n\r\n验证 θ̂1 和\r\nθ̂2 均为 θ 的无偏估计；\r\n\r\n指出哪个更有效。\r\n\r\n\r\n(1) 验证无偏性\r\n1.1 验证 θ̂1 = 2X̄\r\n的无偏性\r\n\r\n步骤 1：计算总体均值\r\n\r\n总体 $ X U[0, ] ，其期望为：$\r\nE(X) = = $$\r\n所以对于总体 X ∼ U[0, θ]，有\r\n$E(X) = \\frac{\\theta}{2}$。\r\n\r\n步骤 2：计算样本均值的期望\r\n\r\n样本均值 $\\bar{X} = \\frac{1}{n}\r\n\\sum_{i=1}^{n} X_i$，其期望为：\r\n\r\n\r\n$$\r\nE(\\bar{X}) = \\frac{1}{n} \\sum_{i=1}^{n} E(X_i) = \\frac{1}{n} \\cdot n\r\n\\cdot \\frac{\\theta}{2} = \\frac{\\theta}{2}.\r\n$$\r\n\r\n步骤 3：计算 θ̂1 的期望：\r\n\r\n由题意，θ̂1 = 2X̄，因此\r\n\r\n$$\r\nE(\\hat{\\theta}_1) = 2E(\\bar{X}) = 2 \\cdot \\frac{\\theta}{2} = \\theta.\r\n$$\r\n\r\n这表明 θ̂1 是\r\nθ 的无偏估计。\r\n\r\n\r\n1.2 验证 $\\hat{\\theta}_2 = \\frac{n+1}{n} X_{(n)}$\r\n的无偏性\r\n\r\n可知，X(n) = max1 ≤ i ≤ n{Xi}\r\n是样本的最大次序统计量。\r\n\r\n背景知识：\r\n\r\n次序统计量：对于样本 X1, X2, …, XnX1, X2, …, Xn，将其按从小到大排列为\r\nX(1) ≤ X(2) ≤ … ≤ X(n)X(1) ≤ X(2) ≤ … ≤ X(n)，其中\r\nX(n) = max⁡XiX(n) = maxXi。\r\n均匀分布性质：Xi ∼ U[0, θ]Xi ∼ U[0, θ]，其累积分布函数（CDF）为\r\n$F_{X}(x)= \\frac xθ$ （当$\r\n0≤x≤θ$）。\r\n\r\n\r\n步骤 1：推导最大次序统计量 X(n)\r\n的密度函数\r\n\r\n每个样本Xi\r\n的累积分布函数（CDF）为：\r\n\r\n$$\r\nF_X(x) = \\begin{cases}\r\n    0, &amp; x &lt; 0, \\\\\r\n    \\frac{x}{\\theta}, &amp; 0 \\leq x \\leq \\theta, \\\\\r\n    1, &amp; x &gt; \\theta.\r\n  \\end{cases}\r\n$$\r\n\r\n最大值 X(n) = maxX1, X2, …, Xn\r\n的 CDF 为：\r\n\r\n$$\r\nF_{X_{(n)}}(x) = P(X_{(n)} \\leq x) = [F_X(x)]^n =\r\n\\left(\\frac{x}{\\theta}\\right)^n \\quad (0 \\leq x \\leq \\theta).\r\n$$\r\n\r\n对 CDF 求导得到概率密度函数（PDF）：\r\n\r\n$$\r\nf_{X_{(n)}}(x) = \\frac{d}{dx} F_{X_{(n)}}(x) = \\frac{n\r\nx^{n-1}}{\\theta^n} \\quad (0 \\leq x \\leq \\theta).\r\n$$\r\n\r\n所以，X(n)\r\n的概率密度函数（PDF）为：\r\n\r\n$$\r\nf_{X_{(n)}}(x) = \\frac{n x^{n-1}}{\\theta^n}, \\quad 0 \\leq x \\leq \\theta.\r\n$$\r\n步骤 2：计算 E(X(n))\r\n$$\r\n\\begin{aligned}\r\nE(X_{(n)}) &amp;= \\int_{0}^{\\theta} x \\cdot \\frac{n x^{n-1}}{\\theta^n}\r\n\\, dx \\\\\r\n&amp;= \\frac{n}{\\theta^n} \\int_{0}^{\\theta} x^n \\, dx \\\\\r\n&amp;= \\frac{n}{\\theta^n} \\left[ \\frac{x^{n+1}}{n+1} \\bigg|_{0}^{\\theta}\r\n\\right] \\\\\r\n&amp;= \\frac{n}{\\theta^n} \\cdot \\frac{\\theta^{n+1}}{n+1} \\\\\r\n&amp;= \\frac{n}{n+1} \\theta.\r\n\\end{aligned}\r\n$$\r\n步骤 3：计算 θ̂2 的期望\r\n由题意可知$\\quad \\hat{\\theta}_2 =\r\n\\frac{n+1}{n} \\max_{1 \\leq i \\leq n} \\{ X_i \\}.$ $$\r\nE(\\hat{\\theta}_2) = \\frac{n+1}{n} E(X_{(n)}) = \\frac{n+1}{n} \\cdot\r\n\\frac{n}{n+1} \\theta = \\theta.\r\n$$ 这表明 θ̂2\r\n也是 θ 的无偏估计。\r\n\r\n\r\n(2) 比较有效性\r\n估计量的有效性通过方差衡量：方差越小，估计量越有效。\r\n2.1 计算θ̂1的方差 D(θ̂1)\r\n\r\n步骤 1：总体方差\r\n均匀分布的方差为：(均匀分布的性质) $$\r\nD(X) = \\frac{(\\theta - 0)^2}{12} = \\frac{\\theta^2}{12}.\r\n$$\r\n步骤 2：样本均值的方差\r\n\r\n$$\r\nD(\\bar{X}) = \\frac{D(X)}{n} = \\frac{\\theta^2}{12n}.\r\n$$\r\n\r\n步骤 3：θ̂1 的方差：\r\n$$\r\nD(\\hat{\\theta}_1) = 4 D(\\bar{X}) = 4 \\cdot \\frac{\\theta^2}{12n} =\r\n\\frac{\\theta^2}{3n}.\r\n$$\r\n\r\n2.2 计算 D(θ̂2)\r\n方差的定义\r\n对于任何随机变量 Y，其方差为： D(Y) = E(Y2) − [E(Y)]2\r\n因此，计算 D(X(n))\r\n需要：\r\n\r\n计算 E(X(n))\r\n一阶矩）。\r\n计算 E(X(n)2)\r\n（二阶矩）。\r\n\r\n\r\n首先计算 E(X(n)2)：\r\n$$\r\n\\begin{aligned}E(X_{(n)}^2) &amp;= \\int_{0}^{\\theta} x^2 \\cdot \\frac{n\r\nx^{n-1}}{\\theta^n} \\, dx \\\\&amp;= \\frac{n}{\\theta^n} \\int_{0}^{\\theta}\r\nx^{n+1} \\, dx \\\\&amp;= \\frac{n}{\\theta^n} \\left[ \\frac{x^{n+2}}{n+2}\r\n\\bigg|_{0}^{\\theta} \\right] \\\\&amp;= \\frac{n}{\\theta^n} \\cdot\r\n\\frac{\\theta^{n+2}}{n+2} \\\\&amp;= \\frac{n}{n+2} \\theta^2.\\end{aligned}\r\n$$ 详细的过程\r\n利用 PDF fX(n)(x)：\r\n$$\r\nE(X_{(n)}) = \\int_{0}^{\\theta} x \\cdot f_{X_{(n)}}(x) \\, dx =\r\n\\int_{0}^{\\theta} x \\cdot \\frac{n x^{n-1}}{\\theta^n} \\, dx =\r\n\\frac{n}{\\theta^n} \\int_{0}^{\\theta} x^n \\, dx.\r\n$$ 积分结果： $$\r\nE(X_{(n)}) = \\frac{n}{\\theta^n} \\cdot \\left. \\frac{x^{n+1}}{n+1}\r\n\\right|_{0}^{\\theta} = \\frac{n}{n+1} \\theta.\r\n$$ 类似地 $$\r\nE(X_{(n)}^2) = \\int_{0}^{\\theta} x^2 \\cdot f_{X_{(n)}}(x) \\, dx =\r\n\\int_{0}^{\\theta} x^2 \\cdot \\frac{n x^{n-1}}{\\theta^n} \\, dx =\r\n\\frac{n}{\\theta^n} \\int_{0}^{\\theta} x^{n+1} \\, dx.\r\n$$ 积分结果 $$\r\nE(X_{(n)}^2) = \\frac{n}{\\theta^n} \\cdot \\left. \\frac{x^{n+2}}{n+2}\r\n\\right|_{0}^{\\theta} = \\frac{n}{n+2} \\theta^2.\r\n$$\r\n然后计算方差 D(X(n))：\r\n$$\r\n\\begin{aligned}D(X_{(n)}) &amp;= E(X_{(n)}^2) - [E(X_{(n)})]^2 \\\\&amp;=\r\n\\frac{n}{n+2} \\theta^2 - \\left( \\frac{n}{n+1} \\theta \\right)^2 \\\\&amp;=\r\n\\theta^2 \\left( \\frac{n}{n+2} - \\frac{n^2}{(n+1)^2} \\right) \\\\&amp;=\r\n\\theta^2 \\cdot \\frac{n(n+1)^2 - n^2(n+2)}{(n+2)(n+1)^2} \\\\&amp;=\r\n\\theta^2 \\cdot \\frac{n(n^2 + 2n + 1) - n^3 - 2n^2}{(n+2)(n+1)^2}\r\n\\\\&amp;= \\theta^2 \\cdot \\frac{n^3 + 2n^2 + n - n^3 - 2n^2}{(n+2)(n+1)^2}\r\n\\\\&amp;= \\theta^2 \\cdot \\frac{n}{(n+2)(n+1)^2}.\\end{aligned}\r\n$$\r\n因此： $$\r\nD(\\hat{\\theta}_2) = \\left( \\frac{n+1}{n} \\right)^2 D(X_{(n)}) =\r\n\\frac{(n+1)^2}{n^2} \\cdot \\frac{n \\theta^2}{(n+2)(n+1)^2} =\r\n\\frac{\\theta^2}{n(n+2)}.\r\n$$\r\n其中\r\n\r\n最大值的分布需要考虑所有样本不超过某个值的联合概率，因此 CDF 是单个\r\nCDF 的 n 次方。\r\n最大值的 PDF：因为所有样本必须小于等于 x，且其中一个样本“支撑”在 x 附近\r\nPDF 是 CDF 的导数，直接反映了概率密度的变化率。\r\n\r\n\r\n2.3 比较 D(θ̂1) 和 D(θ̂2)\r\n\r\nθ̂1方差 $$\r\nD(\\hat{\\theta}_1) = \\frac{\\theta^2}{3n}\r\n$$\r\nθ̂2方差 $$\r\nD(\\hat{\\theta}_2) = \\frac{\\theta^2}{n(n+2)}\r\n$$\r\n对于 n ≥ 2，有 n(n + 2) &gt; 3n\r\n\r\n因为 n2 + 2n &gt; 3n\r\n即 n2 − n &gt; 0 对\r\nn ≥ 2 成立，且 n = 1 时 1 ⋅ 3 = 3 等于 3 ⋅ 1 = 3。\r\n\r\n因此： $$\r\n\\frac{\\theta^2}{n(n+2)} &lt; \\frac{\\theta^2}{3n}, \\quad \\text{当} \\ n\r\n\\geq 2.\r\n$$ 对于 n = 1，两者方差相等： $$\r\nD(\\hat{\\theta}_1) = \\frac{\\theta^2}{3}, \\quad D(\\hat{\\theta}_2) =\r\n\\frac{\\theta^2}{3}.\r\n$$\r\n\r\n结论\r\n\r\n当 n ≥ 2 时，D(θ̂2) &lt; D(θ̂1)，因此\r\nθ̂2 更有效。\r\n当 n = 1\r\n时，两者方差相同，有效性相同。\r\n\r\n\r\n补充说明\r\n\r\n无偏性：两个估计量都无偏，但 θ̂2\r\n利用了样本的最大值信息，更直接反映了 θ 的上界。\r\n有效性：θ̂2 的方差更小，因为 max {Xi} 是\r\nθ 的充分统计量，包含了更多关于\r\nθ 的信息。\r\n直观理解：θ̂1\r\n基于样本均值，而均匀分布的均值对 θ 的估计不够敏感；θ̂2\r\n直接修正了最大值的偏差，更精确。\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计","定理证明"]},{"title":"把Hexo博客配置到Github Pages下","url":"/posts/53748.html","content":"使用 Hexo+GitHub 搭建个人博客\r\n前情提要\r\n你需要自己去安装nodejs和git的环境，因为Hexo 基于\r\nNode.js，搭建过程中还需要使用 npm（Node.js 已带） 和\r\ngit，因此先搭建本地操作环境，安装 Node.js 和 Git。\r\n这种教程csdn一搜一大堆啊，基本照着做都是下一步和最后的配置环境变量\r\n\r\nNode.js：https://nodejs.org/zh-cn\r\nGit：https://git-scm.com/downloads\r\n\r\n安装完成后，Win+R 输入 cmd 并打开，依次输入\r\nnode -v、npm -v 和 git --version\r\n并回车，出现程序版本号即可。\r\n然后你需要自己去注册一个GitHub账号，这里强烈建议设置SSH密钥\r\n安装Hexo\r\n新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog\r\n安装Hexo\r\n使用 npm 一键安装 Hexo 博客程序：\r\n注意：建议之后所有使用命令行安装操作都使用 管理员模式下的cmd\r\nnpm install -g hexo-cli\r\n比较难绷的是安装时候界面没有任何反应，而且时间还不短\r\n初始化Hexo\r\n初始化并安装所需组件\r\nhexo init      # 初始化npm install    # 安装组件\r\n完成后依次输入下面命令，启动本地服务器进行预览：\r\nhexo g   # 生成页面hexo s   # 启动预览\r\n访问\r\nhttp://localhost:4000，出现 Hexo\r\n默认页面，本地博客安装成功！\r\n\r\n\r\nimage-20250413155631935\r\n\r\n如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行\r\nhexo server -p 5000 更改端口号后重试。\r\n博客文件目录结构\r\n\r\n\r\nimg\r\n\r\n创建一个Github仓库来存放你的静态页面\r\nGitHub 主页右上角加号 -&gt; New repository：\r\n​ 注意，这里的仓库名字是 用户名.github.io 最好选上 “Initialize this\r\nrepository with a README”\r\n此时如果你在这个仓库上配置博客的话，博客地址为：https://用户名.github.io\r\n部署到Github Pages\r\n本地博客测试成功后，就是上传到 GitHub\r\n进行部署，使其能够在网络上访问。\r\n首先安装 hexo-deployer-git：\r\nnpm install hexo-deployer-git --save\r\n然后**修改博客根目录下的 _config.yml** 文件末尾的 Deployment\r\n部分，修改成如下：\r\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: main\r\n这里说一下yml文件的格式，yml缩进有严格的格式要求，而且每个字段后的冒号之后必须有空格才能输入有效\r\n完成后运行 hexo d 将网站上传部署到 GitHub Pages。\r\n完成！这时访问我们的 GitHub 域名\r\nhttps://用户名.github.io 就可以看到 Hexo 网站了。\r\n绑定域名\r\n博客搭建完成使用的是 GitHub 的子域名（用户名.http://github.io），我们可以为\r\nHexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于\r\nSEO。\r\n建议这里使用免实名的域名，实名一个域名比较麻烦，而且要等\r\n域名注册和解析\r\n\r\n域名注册和解析教程：Namesilo\r\n域名购买及使用教程\r\n\r\n按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加\r\nCNAME 记录将 www 域名解析指向 用户名.github.io。\r\n\r\n\r\nimg\r\n\r\n绑定域名到 Hexo 博客\r\n进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如\r\nhttp://www.example.com，保存名称为 “CNAME”，格式为 “所有文件”（无 .txt\r\n后缀）。\r\n清除缓存等文件并重新发布网站：\r\nhexo clean   # 清除缓存文件等hexo g       # 生成页面hexo s       # 启动预览\r\n现在就可以使用自己的域名访问 Hexo 博客了。\r\n开启HTTPS\r\n配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub\r\n仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce\r\nHTTPS。\r\n\r\n\r\nimg\r\n\r\nHTTPS\r\n证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS\r\n配置完成！\r\n关于使用\r\n发布文章\r\n进入博客所在目录，右键打开 Git Bash Here，创建博文：\r\nhexo new &quot;My New Post&quot;\r\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用\r\nMarkdown 编辑器在该文件中撰写文章了。\r\n写完后运行下面代码将文章渲染并部署到 GitHub Pages\r\n上完成发布。以后每次发布文章都是这两条命令。\r\nhexo g   # 生成页面hexo d   # 部署发布\r\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式\r\nFront-matter 即可，写完后运行 hexo g 和 hexo d\r\n发布。\r\n---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文\r\n常用命令\r\nhexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助\r\n我的另一篇博客也提到了hexo命令的基本用法，可以看看\r\nHexo命令的基本用法\r\n","categories":["教程","配置教程"],"tags":["Hexo","教程","部署"]},{"title":"快速上手H2数据库进行开发","url":"/posts/11052.html","content":"前言\r\nH2 是一个用 Java\r\n编写的开源关系数据库，特别适合作为嵌入式数据库和内存数据库使用。\r\n针对其特性，我不会太深入讲解什么其他跟原理和很细节方面的东西，本文旨在让大家快速理解什么是内存数据库以及如何使用内存数据库快速进行开发。\r\n什么是内存数据库\r\n内存数据库（In-Memory\r\nDatabase，IMDB）是一种将数据完全存储在计算机内存中的数据库系统。与传统磁盘数据库不同，它跳过了磁盘\r\nI/O\r\n操作，直接通过内存读写数据，因此具备毫秒级响应速度和高并发处理能力。其核心优势在于：\r\n\r\n速度优势：内存访问速度（纳秒级）比磁盘（毫秒级）快\r\n3-4 个数量级，适合实时分析、高频交易等场景。\r\n架构简化：无需复杂的磁盘缓存机制，数据结构设计更贴近内存特性（如哈希表、索引树）。\r\n内存计算融合：数据与计算逻辑在内存中直接交互，减少数据搬运开销。\r\n数据存储与持久化\r\n\r\n主要存储在内存：数据加载到内存中运行，减少 I/O\r\n操作。\r\n持久化机制：通过日志（Redo\r\nLog）、定期快照（Snapshot）或异步写入磁盘等方式，避免断电等故障导致数据丢失（例如\r\nRedis 的 RDB 和 AOF 机制）。\r\n\r\n\r\n但内存数据库也存在数据易失性（断电数据丢失）、内存容量限制等挑战，因此常与持久化机制结合使用。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n维度\r\n内存数据库\r\n传统磁盘数据库（如 MySQL）\r\n\r\n\r\n\r\n\r\n数据存储位置\r\n主要在内存\r\n主要在磁盘\r\n\r\n\r\n性能瓶颈\r\n受内存容量限制\r\n受磁盘 I/O 速度限制\r\n\r\n\r\n适用场景\r\n实时性、高并发、低延迟场景\r\n海量数据存储、事务强一致性场景\r\n\r\n\r\n成本\r\n硬件成本高（需大量内存）\r\n硬件成本较低\r\n\r\n\r\n数据一致性\r\n部分支持最终一致性，事务能力较弱\r\n强一致性（ACID）\r\n\r\n\r\n\r\nH2 是一个用 Java\r\n开发的嵌入式关系型数据库，它既支持传统磁盘存储，也提供纯内存模式。\r\nH2 数据库介绍\r\nH2是一个采用java语言编写的嵌入式数据库引擎，只是一个类库（即只有一个\r\njar\r\n文件），可以直接嵌入到应用项目中，不受平台的限制，而且比较重要的是，Spring\r\nBoot、Hibernate 等框架默认集成 H2，用于快速搭建测试数据库，这样就是\r\nspring 框架不依赖真实数据库进行测试的场景。\r\nH2 的独特之处在于完全兼容 SQL 标准，支持\r\nJOIN、子查询等复杂关系操作，这是 Redis 等 NoSQL\r\n内存数据库无法替代的。例如，在需要实时分析多张关联表数据时，H2\r\n内存模式可直接执行 SQL，而且H2\r\n通过轻量级架构和灵活的内存 -\r\n磁盘混合模式，展现了内存数据库的核心优势：既满足了 “极速响应”\r\n的性能需求，又通过持久化机制弥补了数据易失性的缺陷。\r\n应用场景：\r\n\r\n可以同应用程序打包在一起发布，可以非常方便地存储少量结构化数据\r\n可用于单元测试\r\n可以用作缓存，即当做内存数据库\r\n\r\nH2的产品优势：\r\n\r\n纯Java编写，不受平台的限制；\r\n只有一个jar文件，适合作为嵌入式数据库使用；\r\nh2提供了一个十分方便的web控制台用于操作和管理数据库内容；\r\n功能完整，支持标准SQL和JDBC。麻雀虽小五脏俱全；\r\n支持内嵌模式、服务器模式和集群。\r\n\r\nH2数据库安装，这是它的官网，可以看到\r\nH2 数据库非常小\r\nH2 数据库也是和 Mysql 一样要配环境的。\r\nH2 数据库的安装和简易部署\r\n下载安装\r\n如果你去官网解压下载包，内容就是这样\r\n\r\n\r\nimage-20250614201758813\r\n\r\n下载安装程序后也是一样，只不过没有 Uninstall.exe\r\n目录说明\r\nh2-1.4.200.jar   H2数据库的jar包h2.bat           Windows控制台启动脚本h2.sh            Linux控制台启动脚本h2w.bat          Windows控制台启动脚本 build.bat        windows构建脚本build.sh         linux构建脚本docs             H2数据库的帮助文档（内有H2数据库的使用手册）service          通过wrapper包装成服务。src              H2数据库的源代码\r\n数据库启动——Windows环境下\r\n那么如何启动\r\n下载H2后，你会看到几个关键的启动文件：\r\nh2-1.4.200.jar   # 核心jar包，可直接运行h2.bat           # Windows图形界面启动脚本h2w.bat          # Windows后台静默启动脚本  h2.sh            # Linux启动脚本\r\n启动方式对比：\r\n\r\nh2.bat：前台运行，会显示控制台窗口，关闭窗口就停止服务\r\nh2w.bat：后台运行，没有控制台窗口，适合生产环境\r\n直接运行jar：java -jar h2-1.4.200.jar，等同于h2.bat\r\n\r\n进入bin目录下，执行h2.bat，h2w.bat，h2-1.4.200.jar都可以。启动后会自动打开浏览器控制台，可以选择语言为中文\r\n启动命令说明如下\r\n# Windows环境cd h2安装目录/binh2.bat# 或者后台启动h2w.bat# Linux环境./h2.sh\r\n系统会进入H2\r\n数据库的Web Console，http://&lt;你的ip&gt;:8082，注意占用的是\r\n8082 端口，你 Spring 或者 Servlet\r\n改过prot的就非常容易重复。\r\n默认会创建一个数据库Generic H2，用户名为sa，空密码\r\n\r\n\r\nimage-20250614201932713\r\n\r\n其中的字段的含义如下\r\n\r\n保存的连接设置\r\n这是一个下拉选项，作用是快速选择之前保存过的一组完整连接配置\r\n。比如图里选的 “Generic H2 (Embedded)”，选中后，驱动类、JDBC\r\nURL、用户名等相关连接参数会自动填充，不用每次手动输入，方便下次直接用相同配置连数据库，避免重复设置参数。是快捷选择历史配置的入口\r\n连接设置名称\r\n是给当前这组连接配置起的标识名 ，像 “Generic H2\r\n(Embedded)”\r\n。主要用途：是配置的标识，用来存、取、管理连接参数，让连数据库更高效\r\n\r\n保存配置：填好驱动类、JDBC URL 等信息后，点\r\n“保存”，H2 控制台会把这组配置以该名称存起来，之后就能在 “保存的连接设置”\r\n下拉里选，直接复用。\r\n管理配置：方便区分不同连接配置（比如有多个 H2\r\n库，或同库不同模式、用户的连接），看到名称就知道对应哪套参数，也能通过\r\n“删除” 按钮，移除不用的配置。\r\n\r\n驱动类（Driver Class）\r\n指定用于连接 H2 数据库的 JDBC 驱动程序类。\r\norg.h2.Driver 是 H2 数据库官方提供的、实现了 JDBC\r\n规范的驱动类，Java 程序通过加载这个类，才能建立和 H2 数据库的连接，让\r\nJava 代码借助 JDBC API 操作 H2 数据库（执行 SQL 语句、管理数据等 ）。在\r\nJava 代码里，通常会用 Class.forName(\"org.h2.Driver\")\r\n加载该驱动（不过现在部分框架能自动加载\r\n），然后基于此驱动去获取数据库连接。\r\nJDBC URL\r\n定义连接 H2\r\n数据库的具体路径、模式及相关配置参数，告诉程序该如何找到并连接到 H2\r\n数据库\r\n它是符合 JDBC 规范的连接字符串，H2\r\n支持多种连接模式（嵌入式、服务器模式等\r\n），不同模式对应不同格式这个后面细嗦\r\n用户名和密码和mysql的都一样，H2\r\n里用户名不区分大小写，但密码区分，创建数据库的用户默认成为该数据库管理员，拥有对应管理权限，而且\r\nH2 可以把可把密码字段留空\r\n\r\n在Web控制台中，你需要配置连接参数\r\n驱动类: org.h2.DriverJDBC URL: 根据使用模式选择用户名: sa (默认)密码: (默认为空)\r\n例如，jdbc:h2:D:/software/h2/data/test，会在指定路径下创建一个名为\r\ntest.mv.db 的数据库，你可能还会看到一个\r\ntest.trace.db\r\n的文件，这个是h2的错误信息，可以直接打开看。有没有跟我一样好奇为啥名称里面有个mv，这是因为高版本的H2存储引擎默默认为mvStore,文档最后面有讲这个存储引擎的。\r\n设置好配置好，点击”连接”就可以连接上服务器，页面就是这样的\r\n\r\n\r\nimage-20250614202120911\r\n\r\n与外部数据库工具连接\r\n这里我以 DataGrip 进行演示，其实这些工具都一样\r\n连接数据源时候选择 H2\r\n\r\n\r\nimage-20250614204419214\r\n\r\n填写基本信息\r\n\r\n\r\nimage-20250614204613619\r\n\r\n创建表进行测试\r\n正如上述所说，H2数据库支持原生的sql，这个也支持别的，包括非关系型，跟你在创建数据库时候的配置有关\r\n以常见的 “用户信息表” 和 “订单表” 为例，演示关系型数据的创建：\r\nCREATE TABLE users (    user_id INT PRIMARY KEY AUTO_INCREMENT,  -- 自增主键    username VARCHAR(50) NOT NULL UNIQUE,   -- 用户名（非空且唯一）    email VARCHAR(100) NOT NULL,            -- 邮箱    password VARCHAR(100) NOT NULL,         -- 密码    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- 创建时间    last_login TIMESTAMP                    -- 最后登录时间);\r\n执行后看到左边出现了USERS表\r\n\r\n冷知识，H2数据库的控制台UI界面是用纯 Swing 写的\r\n\r\n\r\n\r\nimage-20250614204141685\r\n\r\nCREATE TABLE orders (    order_id INT PRIMARY KEY AUTO_INCREMENT,    user_id INT,    order_amount DECIMAL(10, 2) NOT NULL,   -- 订单金额（最多10位，2位小数）    order_status VARCHAR(20) DEFAULT &#x27;pending&#x27;,  -- 订单状态（默认待处理）    order_time TIMESTAMP NOT NULL,    FOREIGN KEY (user_id) REFERENCES users(user_id)  -- 关联用户表外键);\r\n执行方式：将 SQL 语句复制到控制台输入框，点击\r\n执行 按钮（或按 F9），成功后会显示\r\n更新: 0（创建表不涉及数据行更新）\r\n注意 H2 不支持 InnoDB 索引\r\n插入数据测试\r\n向用户表插入数据\r\nINSERT INTO users (username, email, password) VALUES(&#x27;alice&#x27;, &#x27;alice@example.com&#x27;, &#x27;pass123&#x27;),(&#x27;bob&#x27;, &#x27;bob@example.com&#x27;, &#x27;pass456&#x27;),(&#x27;charlie&#x27;, &#x27;charlie@example.com&#x27;, &#x27;pass789&#x27;);\r\n\r\n\r\nimage-20250614204254411\r\n\r\n向订单表插入数据\r\nINSERT INTO orders (user_id, order_amount, order_status, order_time) VALUES(1, 199.99, &#x27;completed&#x27;, &#x27;2025-06-10 10:30:00&#x27;),(1, 59.50, &#x27;pending&#x27;, &#x27;2025-06-12 14:20:00&#x27;),(2, 399.00, &#x27;completed&#x27;, &#x27;2025-06-11 09:15:00&#x27;),(3, 89.99, &#x27;cancelled&#x27;, &#x27;2025-06-09 16:45:00&#x27;);\r\n\r\n\r\nimage-20250619194032621\r\n\r\n查找测试\r\n简单查询\r\n-- 通过 user_id 关联 users 表和 orders 表，查询 alice（user_id=1）的所有订单SELECT orders.order_id, orders.order_amount, orders.order_status, orders.order_timeFROM usersJOIN orders ON users.user_id = orders.user_idWHERE users.username = &#x27;alice&#x27;;\r\n\r\n\r\nimage-20250619194112767\r\n\r\n复杂查询\r\n-- 先通过子查询算出每个用户的平均订单金额，再关联查询出金额大于自身平均的订单WITH UserAvgAmount AS (    SELECT         user_id,        AVG(order_amount) AS avg_amount  -- 计算每个用户的平均订单金额    FROM orders    GROUP BY user_id)SELECT     orders.order_id,    orders.user_id,    orders.order_amount,    UserAvgAmount.avg_amountFROM ordersJOIN UserAvgAmount ON orders.user_id = UserAvgAmount.user_idWHERE orders.order_amount &gt; UserAvgAmount.avg_amount;\r\n\r\n\r\nimage-20250619194052838\r\n\r\n关闭数据库\r\n点击 [Disconnect]:\r\n\r\n\r\nimage-20250619211225660\r\n\r\n来断开连接\r\n在JAVA应用内部，也可以通过代码来实现TCP服务的启动和停止，例子代码如下\r\nimport org.h2.tools.Server;...// 启动 TCP ServerServer server = Server.createTcpServer(args).start();...// 关闭 TCP Serverserver.stop();\r\n可以从另外的程序关闭 TCP 服务器，使用下面命令行：\r\njava org.h2.tools.Server -tcpShutdown tcp://localhost:9092\r\n在用户应用中关闭服务器，使用\r\norg.h2.tools.Server.shutdownTcpServer(&quot;tcp://localhost:9094&quot;);\r\n这个功能将仅仅关闭 TCP\r\n服务器。如果相同的程序有其他服务器，他们不会被关闭，而是继续执行。为了避免覆盖在数据库下次打开时，在调用这个方法时，所有的到数据库的连接将会关闭。要实现远程关闭服务器，需启用远程连接。关闭一个\r\nTCP 服务器可以通过选项 -tcpPassword 来保护 (启动和关闭 TCP\r\n服务器也要用这个密码)\r\nH2数据库的运行模式与运行方式介绍\r\n运行模式\r\nH2有三种运行模式。\r\n\r\n内嵌模式（Embedded\r\nMode）：内嵌模式下，应用和数据库同在一个JVM中，通过JDBC进行连接。可持久化，但同时只能一个客户端连接。内嵌模式性能会比较好。\r\n服务器模式（Server\r\nMode）：使用服务器模式和内嵌模式一样，只不过它可以跑在另一个进程里。\r\n混合模式：第一个应用以内嵌模式启动它，对于后面的应用来说它是服务器模式跑着的。混合模式是内嵌模式和服务器模式的组合。第一个应用通过内嵌模式与数据库建立连接，同时也作为一个服务器启动，于是另外的应用（运行在不同的进程或是虚拟机上）可以同时访问同样的数据。第一个应用的本地连接与嵌入式模式的连接性能一样的快，而其它连接理论上会略慢。\r\n\r\n连接方式\r\n\r\n以嵌入式模式（本地文件）连接方式连接H2数据库\r\n这种连接方式默认情况下只允许有一个客户端连接到H2数据库，有客户端连接到H2数据库之后，此时数据库文件就会被锁定，那么其他客户端就无法再连接了。\r\n连接语法：jdbc:h2:[file:][]&lt;databaseName&gt;\r\nJDBC URL: jdbc:h2:~/test# 或指定完整路径JDBC URL: jdbc:h2:file:D:/data/mydb\r\n例如：\r\n\r\njdbc:h2:~/test    //\r\n连接位于用户目录下的test数据库\r\njdbc:h2:file:/data/sample\r\njdbc:h2:file:E:/H2/gacl // Windows only\r\n\r\n特点：\r\n\r\n数据持久化到磁盘文件\r\n只允许一个连接\r\n性能较好\r\n会生成.mv.db文件\r\n\r\n使用TCP/IP的服务器模式(远程连接)方式连接H2数据库(推荐)\r\n这种连接方式就和其他数据库类似了，是基于Service的形式进行连接的，因此允许多个客户端同时连接到H2数据库。\r\n连接语法：jdbc:h2:tcp://&lt;server&gt;[:&lt;port&gt;]/[&lt;path&gt;]&lt;databaseName&gt;\r\n举例：jdbc:h2:tcp://localhost/~/test\r\n特点：\r\n\r\n支持多客户端同时连接\r\n需要先启动H2服务器\r\n通过TCP/IP通信\r\n适合多用户环境\r\n\r\nH2数据库的内存模式，纯内存数据库\r\n连接语法：jdbc:h2:mem:&lt;databaseName&gt;\r\n\r\nH2数据库被称为内存数据库，因为它支持在内存中创建数据库和表。\r\n注意：如果使用H2数据库的内存模式，那么我们创建的数据库和表都只是保存在内存中，一旦服务器重启，那么内存中的数据库和表就不存在了。所以\r\nH2 数据库的持久化是个很关键的问题\r\n\r\n\r\n可选配置\r\n在用户目录下新建 .h2.server.properties，支持如下属性配置：\r\n\r\nwebAllowOthers: 是否允许远程连接，默认 false。\r\nwebPort: h2 端口，默认为 8082。\r\nwebSSL: 是否启用 SSL 加密连接，默认 false。\r\nwebAdminPassword: 超级管理员密码。\r\n\r\n如果没有手动配置此文件，以 web-server方式首次启动 H2\r\n后，点击打开的浏览器页面的 Save 按钮后就会自动创建一个。\r\n端口配置\r\n如果8082端口冲突，可以修改启动参数：\r\njava -jar h2-1.4.200.jar -webPort 8083\r\n允许远程访问\r\n默认只允许本地访问，开启远程访问：\r\njava -jar h2-1.4.200.jar -webAllowOthers\r\n配置文件方式\r\n在用户目录创建.h2.server.properties：\r\nwebAllowOthers=truewebPort=8083webSSL=falsewebAdminPassword=admin123\r\n在你的 Spring 项目中使用 H2\r\n数据库\r\n这一次经过 H2 的基本了解之后，我们就需要在实际项目中使用 H2\r\n这种小巧的数据库方便我们的开发测试了\r\n在 Spring Boot 项目里使用 H2\r\n数据库，能让我们便捷地进行开发、测试，特别是在需要轻量级数据库支持，或者想快速验证数据操作逻辑时，H2\r\n是个很不错的选择。使用一个项目来了解如何使用\r\n而且，H2 数据库支持 Hibernate 3.1及以上的版本。 你能够使用 HSQLDB\r\n方言，或是 H2 自己的方言。注意的是，在 Hibernate 中包含的 H2\r\n方言有BUG，针对这些 BUG\r\n的补丁已经被发布和修复,见https://hibernate.atlassian.net/browse/HHH-3401。你能够将它改名为H2Dialect.java，直接把它包含在你的应用中即可使用，或者使用\r\n已经修复了这个问题的 Hibernate 的版本。\r\n当使用 Hibernate,尝试使用 H2Dialect\r\n如果可能的话。当使用H2Dialect,兼容性模式比如MODE=MySQL是不支持的。当使用兼容模式时,使用\r\nHibernate 相应的数据库的方言，而不是 H2Dialect;但请注意 H2\r\n不支持所有数据库的所有功能。\r\n我们在 Spring Boot 项目中（Servlet的Web应用也大差不差）使用 H2\r\n数据库的思路如下，最简单（目前）的方法就是将数据库内嵌到应用中，这样就意味着应用启动的时候就打开了一个连接，数据库能被多个\r\nsession 和应用访问，他们跟应用运行在一个进程内，大部分的 Servlet\r\n容器只适用一个进程（如Tomcat），这些容器都是没有问题的，Tomcat\r\n使用多线程和多类加载器。如果多个应用同时访问同一个数据库，你需要将数据库的\r\njar\r\n文件放在shared/lib或是server/lib目录。好的方案是\r\nWeb 应用启动时打开数据库，Web\r\n应用停止时关闭数据库。如果是多个应用，只需要一个应用来处理启动和关闭。好的方案是一个\r\nSession\r\n一个连接，或者是一个请求（action）一个连接，连接使用完后尽可能的关闭它，当然不关闭并不会引起可怕的后果。服务器模式是差不多的，但是它可以运行在其他的进程中。\r\n添加依赖\r\n在 pom.xml 文件中添加 H2 数据库和 Spring Boot\r\n数据访问相关依赖\r\n&lt;!-- Spring Boot 数据访问基础依赖，用于简化数据库操作 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- H2 数据库依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\r\nspring-boot-starter-data-jpa 是 Spring Boot\r\n提供的用于简化 JPA（Java Persistence API，Java 持久化 API ）操作的\r\nstarter 依赖，它能帮我们快速实现对数据库的各种操作；h2\r\n依赖则引入了 H2 数据库的相关类和功能。\r\n配置 application.properties\r\n# 配置 H2 数据库的 JDBC 连接 URL，这里用嵌入式模式，数据存储在项目根目录下的 test.mv.db 文件中spring.datasource.url=jdbc:h2:~/test# 数据库驱动类，H2 数据库对应的驱动spring.datasource.driver-class-name=org.h2.Driver# 数据库用户名和密码spring.datasource.username=ccbspring.datasource.password=# 配置 Hibernate 相关属性，Hibernate 是实现 JPA 规范的框架spring.jpa.hibernate.ddl-auto=update# 配置数据库方言，让 Hibernate 能正确生成适合 H2 数据库的 SQL 语句spring.jpa.database-platform=org.hibernate.dialect.H2Dialectspring.jpa.show-sql=truespring.h2.console.enabled=true# 控制台访问路径，通过这个路径可以在浏览器中访问 H2 控制台，比如 http://localhost:8080/h2-consolespring.h2.console.path=/h2-consolespring.h2.console.settings.web-allow-others=true\r\n如果是yml，如下\r\nspring:  datasource:    # 配置 H2 数据库的 JDBC 连接 URL，这里用嵌入式模式，数据存储在项目根目录下的 test.mv.db 文件中    url: jdbc:h2:~/test    # 数据库驱动类，H2 数据库对应的驱动    driver-class-name: org.h2.Driver    # 数据库用户名    username: ccb    # 数据库密码    password:   jpa:    # 配置 Hibernate 相关属性，Hibernate 是实现 JPA 规范的框架    hibernate:      # 自动根据实体类创建、更新数据库表结构，创建表时会依据实体类字段和注解生成对应的表和列      ddl-auto: update    # 配置数据库方言，让 Hibernate 能正确生成适合 H2 数据库的 SQL 语句    database-platform: org.hibernate.dialect.H2Dialect    # 显示执行的 SQL 语句，方便开发调试时查看具体执行的 SQL 内容    show-sql: true  # 配置 H2 数据库控制台相关参数  h2:    console:      # 启用 H2 数据库控制台      enabled: true      # 控制台访问路径，通过这个路径可以在浏览器中访问 H2 控制台，比如 http://localhost:8080/h2-console      path: /h2-console      # 允许从远程访问控制台，开发时若需要在本地以外的机器访问控制台可开启（注意生产环境谨慎开启）      settings:        web-allow-others: true\r\n创建实体类\r\n比如针对前面的 users 表和 orders\r\n表，创建对应的实体类\r\nUser 实体类\r\npackage edu.software.ergoutree.h2andspringboottest.entity;import java.sql.Timestamp;import jakarta.persistence.Column;import jakarta.persistence.Entity;import jakarta.persistence.GeneratedValue;import jakarta.persistence.GenerationType;import jakarta.persistence.Id;@Entitypublic class Users &#123;    // 主键，自增    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = &quot;user_id&quot;)    private Integer userId;    // 用户名，非空且唯一    private String username;    // 邮箱，非空    private String email;    // 密码，非空    private String password;    // 创建时间，默认当前时间戳    @Column(name = &quot;create_time&quot;)    private Timestamp createTime;    // 最后登录时间    @Column(name = &quot;last_login&quot;)    private Timestamp lastLogin;    // 省略 getter 和 setter 方法    public Integer getUserId() &#123;        return userId;    &#125;    public void setUserId(Integer userId) &#123;        this.userId = userId;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public Timestamp getCreateTime() &#123;        return createTime;    &#125;    public void setCreateTime(Timestamp createTime) &#123;        this.createTime = createTime;    &#125;    public Timestamp getLastLogin() &#123;        return lastLogin;    &#125;    public void setLastLogin(Timestamp lastLogin) &#123;        this.lastLogin = lastLogin;    &#125;&#125;\r\nOrder 实体类\r\npackage edu.software.ergoutree.h2andspringboottest.entity;import java.math.BigDecimal;import java.sql.Timestamp;import jakarta.persistence.Column;import jakarta.persistence.Entity;import jakarta.persistence.GeneratedValue;import jakarta.persistence.GenerationType;import jakarta.persistence.Id;import jakarta.persistence.JoinColumn;import jakarta.persistence.ManyToOne;@Entitypublic class Orders &#123;    // 主键，自增    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = &quot;order_id&quot;)    private Integer orderId;    // 关联用户表，多对一关系，一个用户可以有多个订单    @ManyToOne    @JoinColumn(name = &quot;user_id&quot;)    private Users user;    // 订单金额，精度 10 位，小数 2 位    @Column(name = &quot;order_amount&quot;)    private BigDecimal orderAmount;    // 订单状态，默认 pending    @Column(name = &quot;order_status&quot;)    private String orderStatus;    // 订单时间，非空    @Column(name = &quot;order_time&quot;)    private Timestamp orderTime;    // 省略 getter 和 setter 方法    public Integer getOrderId() &#123;        return orderId;    &#125;    public void setOrderId(Integer orderId) &#123;        this.orderId = orderId;    &#125;    public Users getUser() &#123;        return user;    &#125;    public void setUser(Users user) &#123;        this.user = user;    &#125;    public BigDecimal getOrderAmount() &#123;        return orderAmount;    &#125;    public void setOrderAmount(BigDecimal orderAmount) &#123;        this.orderAmount = orderAmount;    &#125;    public String getOrderStatus() &#123;        return orderStatus;    &#125;    public void setOrderStatus(String orderStatus) &#123;        this.orderStatus = orderStatus;    &#125;    public Timestamp getOrderTime() &#123;        return orderTime;    &#125;    public void setOrderTime(Timestamp orderTime) &#123;        this.orderTime = orderTime;    &#125;&#125;\r\n创建 Repository 接口（JPA\r\nRepository）\r\n通过继承 JpaRepository\r\n来实现对数据库的基本操作，无需手动编写 SQL 语句（当然也支持自定义 SQL\r\n）。\r\nUsersRepository：\r\npackage edu.software.ergoutree.h2andspringboottest.repository;import edu.software.ergoutree.h2andspringboottest.entity.Users;import org.springframework.data.jpa.repository.JpaRepository;public interface UsersRepository extends JpaRepository&lt;Users, Integer&gt; &#123;    // 可以自定义查询方法，比如根据用户名查询用户，遵循 JPA 方法命名规则    Users findByUsername(String username);&#125;\r\nOrdersRepository\r\nimport edu.software.ergoutree.h2andspringboottest.entity.Orders;import edu.software.ergoutree.h2andspringboottest.entity.Users;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;public interface OrdersRepository extends JpaRepository&lt;Orders, Integer&gt; &#123;    // 自定义查询方法，比如根据用户和订单状态查询订单    List&lt;Orders&gt; findByUserAndOrderStatus(Users user, String status);&#125;\r\nJpaRepository 提供了诸如 save（保存实体\r\n）、findAll（查询所有实体 ）、delete（删除实体\r\n）等基础方法；自定义方法像 findByUsername 是按照 JPA\r\n的方法命名规则来定义的，框架会自动生成对应的 SQL 语句执行查询操作。\r\n编写业务逻辑和控制器（Service\r\n和 Controller）\r\nUsersService\r\npackage edu.software.ergoutree.h2andspringboottest.service;import java.util.List;import java.util.Optional;import org.springframework.stereotype.Service;import edu.software.ergoutree.h2andspringboottest.entity.Users;import edu.software.ergoutree.h2andspringboottest.repository.UsersRepository;@Servicepublic class UsersService &#123;    private final UsersRepository usersRepository;    public UsersService(UsersRepository usersRepository) &#123;        this.usersRepository = usersRepository;    &#125;    // 保存用户信息    public Users saveUser(Users user) &#123;        return usersRepository.save(user);    &#125;    // 根据用户ID查询用户    public Optional&lt;Users&gt; findUserById(Integer id) &#123;        return usersRepository.findById(id);    &#125;    // 根据用户名查询用户    public Users findUserByUsername(String username) &#123;        return usersRepository.findByUsername(username);    &#125;    // 查询所有用户    public List&lt;Users&gt; findAllUsers() &#123;        return usersRepository.findAll();    &#125;&#125;\r\nOrdersService\r\npackage edu.software.ergoutree.h2andspringboottest.service;import java.util.List;import java.util.Optional;import org.springframework.stereotype.Service;import edu.software.ergoutree.h2andspringboottest.entity.Orders;import edu.software.ergoutree.h2andspringboottest.entity.Users;import edu.software.ergoutree.h2andspringboottest.repository.OrdersRepository;@Servicepublic class OrdersService &#123;    private final OrdersRepository ordersRepository;    public OrdersService(OrdersRepository ordersRepository) &#123;        this.ordersRepository = ordersRepository;    &#125;    // 保存订单信息    public Orders saveOrder(Orders order) &#123;        return ordersRepository.save(order);    &#125;    // 根据订单 ID 查询订单    public Optional&lt;Orders&gt; findOrderById(Integer id) &#123;        return ordersRepository.findById(id);    &#125;    // 根据用户和订单状态查询订单列表    public List&lt;Orders&gt; findOrdersByUserAndStatus(Users user, String status) &#123;        return ordersRepository.findByUserAndOrderStatus(user, status);    &#125;        // 查询所有订单    public List&lt;Orders&gt; findAllOrders() &#123;        return ordersRepository.findAll();    &#125;&#125;\r\nUsersController\r\npackage edu.software.ergoutree.h2andspringboottest.controller;import java.util.List;import java.util.Optional;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import edu.software.ergoutree.h2andspringboottest.entity.Users;import edu.software.ergoutree.h2andspringboottest.service.UsersService;@RestController@RequestMapping(&quot;/api/users&quot;)public class UsersController &#123;    private final UsersService usersService;    public UsersController(UsersService usersService) &#123;        this.usersService = usersService;    &#125;    // 创建用户    @PostMapping    public ResponseEntity&lt;Users&gt; createUser(@RequestBody Users user) &#123;        Users savedUser = usersService.saveUser(user);        return ResponseEntity.ok(savedUser);    &#125;    // 根据用户ID查询用户    @GetMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Users&gt; getUserById(@PathVariable Integer id) &#123;        Optional&lt;Users&gt; user = usersService.findUserById(id);        return user.map(ResponseEntity::ok)                .orElseGet(() -&gt; ResponseEntity.notFound().build());    &#125;    // 根据用户名查询用户    @GetMapping(&quot;/username/&#123;username&#125;&quot;)    public ResponseEntity&lt;Users&gt; getUserByUsername(@PathVariable String username) &#123;        Users user = usersService.findUserByUsername(username);        if (user == null) &#123;            return ResponseEntity.notFound().build();        &#125;        return ResponseEntity.ok(user);    &#125;    // 获取所有用户    @GetMapping    public ResponseEntity&lt;List&lt;Users&gt;&gt; getAllUsers() &#123;        List&lt;Users&gt; users = usersService.findAllUsers();        return ResponseEntity.ok(users);    &#125;&#125;\r\nOrdersController\r\npackage edu.software.ergoutree.h2andspringboottest.controller;import edu.software.ergoutree.h2andspringboottest.entity.Orders;import edu.software.ergoutree.h2andspringboottest.entity.Users;import edu.software.ergoutree.h2andspringboottest.service.OrdersService;import edu.software.ergoutree.h2andspringboottest.service.UsersService;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import java.util.List;import java.util.Optional;@RestController@RequestMapping(&quot;/api/orders&quot;)public class OrdersController &#123;    private final OrdersService ordersService;    private final UsersService usersService;    public OrdersController(OrdersService ordersService, UsersService usersService) &#123;        this.ordersService = ordersService;        this.usersService = usersService;    &#125;    // 创建订单    @PostMapping    public ResponseEntity&lt;Orders&gt; createOrder(@RequestBody Orders order) &#123;        Orders savedOrder = ordersService.saveOrder(order);        return ResponseEntity.ok(savedOrder);    &#125;    // 根据订单ID查询订单    @GetMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Orders&gt; getOrderById(@PathVariable Integer id) &#123;        Optional&lt;Orders&gt; order = ordersService.findOrderById(id);        return order.map(ResponseEntity::ok)                .orElseGet(() -&gt; ResponseEntity.notFound().build());    &#125;    // 根据用户ID和订单状态查询订单    @GetMapping(&quot;/user/&#123;userId&#125;/status/&#123;status&#125;&quot;)    public ResponseEntity&lt;List&lt;Orders&gt;&gt; getOrdersByUserAndStatus(            @PathVariable Integer userId,            @PathVariable String status) &#123;                Optional&lt;Users&gt; user = usersService.findUserById(userId);                if (user.isEmpty()) &#123;            return ResponseEntity.notFound().build();        &#125;                List&lt;Orders&gt; orders = ordersService.findOrdersByUserAndStatus(user.get(), status);        return ResponseEntity.ok(orders);    &#125;    // 获取所有订单    @GetMapping    public ResponseEntity&lt;List&lt;Orders&gt;&gt; getAllOrders() &#123;        List&lt;Orders&gt; orders = ordersService.findAllOrders();        return ResponseEntity.ok(orders);    &#125;&#125;\r\nH2 数据库控制台的使用\r\nH2 控制台是一个包含在 web 服务中的独立的应用\r\n前面在配置里启用了 H2 控制台，启动 Spring Boot 项目后，在浏览器中访问\r\nhttp://localhost:8080/h2-console（具体路径根据配置的\r\nspring.h2.console.path 而定 ），会出现登录页面，填写对应的\r\nJDBC URL、用户名、密码（就是配置文件里 spring.datasource\r\n相关的配置 ），登录后就能看到数据库的表结构、执行 SQL\r\n语句、查看数据等。比如可以在控制台里执行\r\nSELECT * FROM users;\r\n来查询用户表数据，方便开发过程中调试和检查数据。\r\n\r\n冷知识，H2支持原生的CSV\r\n\r\nCSV（逗号分隔文件）文件在数据库系统中支持CSVREAD和CSVWRITE方法，也可以把它作为数据库之外的一个工具来使用。\r\n将数据库查询结果写成CSV文件\r\n\r\n\r\n\r\n\r\nimage-20250619211909855\r\n\r\n可以看到访问网址就来到了如上控制台页面，和上面的都是一样的，输入你配置文件中的密码，就可以进入了，进入后发现\r\nHibernate 为我们的实体类已经自动创建表\r\n重新写一个Home定向页面，来看看各个该Spring程序的各个功能进行测试\r\n可以看到是没有任何问题的\r\n\r\n\r\nimage-20250619212554001\r\n\r\n\r\n\r\nimage-20250619212624133\r\n\r\n在 Spring Boot 与 H2\r\n的搭配中使用连接池\r\nH2\r\n数据库的连接池机制通过复用数据库连接，避免了频繁创建和关闭连接的开销。H2\r\n内置连接池基于Mini Connection Pool\r\nManager，相比直接使用DriverManager.getConnection()有以下优势：\r\n\r\n性能提升：连接池管理的连接获取速度比原生方式快 2\r\n倍以上\r\n资源复用：维护一定数量的活跃连接，避免重复握手开销\r\n连接管理：自动处理连接超时、异常回收等场景\r\n\r\n在 Spring Boot 中配置 H2\r\n内置连接池只需在数据源配置中添加连接池参数：\r\nspring:  datasource:    url: jdbc:h2:file:~/test;DB_CLOSE_DELAY=-1;POOL_SIZE=10;AUTO_COMMIT=true    driver-class-name: org.h2.Driver    username: sa    password:   h2:    console:      enabled: true\r\n关键参数说明：\r\n\r\nPOOL_SIZE：连接池最大连接数（默认 10）\r\nAUTO_COMMIT：是否自动提交事务（默认 true）\r\nMAX_IDLE_TIME：连接最大空闲时间（毫秒，默认\r\n60000）\r\nCONNECTION_TIMEOUT：获取连接超时时间（毫秒，默认\r\n30000）\r\n\r\n若需更强大的连接池功能，可集成 Apache Commons DBCP\r\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;&lt;/dependency&gt;\r\n我使用 Spring Boot 默认的 Hikari 数据池添加如下控制器和服务层\r\npackage edu.software.ergoutree.h2andspringboottest.controller;import java.util.Map;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import edu.software.ergoutree.h2andspringboottest.service.DataSourceMonitorService;/** * 数据源监控控制器 * 提供API接口用于监控和测试数据库连接池 */@RestController@RequestMapping(&quot;/api/datasource&quot;)public class DataSourceMonitorController &#123;    private final DataSourceMonitorService monitorService;    public DataSourceMonitorController(DataSourceMonitorService monitorService) &#123;        this.monitorService = monitorService;    &#125;    /**     * 获取连接池状态     *      * @return 连接池统计信息     */    @GetMapping(&quot;/stats&quot;)    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getPoolStats() &#123;        return ResponseEntity.ok(monitorService.getPoolStats());    &#125;    /**     * 测试数据库连接     *      * @return 连接测试结果     */    @GetMapping(&quot;/test-connection&quot;)    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; testConnection() &#123;        return ResponseEntity.ok(monitorService.testConnection());    &#125;    /**     * 测试连接池性能     *      * @param count 要创建的连接数量     * @return 性能测试结果     */    @GetMapping(&quot;/test-performance&quot;)    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; testPerformance(            @RequestParam(defaultValue = &quot;10&quot;) int count) &#123;        return ResponseEntity.ok(monitorService.createMultipleConnections(count));    &#125;&#125; \r\npackage edu.software.ergoutree.h2andspringboottest.service;import java.sql.Connection;import java.sql.SQLException;import java.util.HashMap;import java.util.Map;import javax.sql.DataSource;import org.springframework.stereotype.Service;import com.zaxxer.hikari.HikariDataSource;import com.zaxxer.hikari.HikariPoolMXBean;/** * 数据源监控服务 * 用于监控和测试数据库连接池的状态 */@Servicepublic class DataSourceMonitorService &#123;    private final DataSource dataSource;    public DataSourceMonitorService(DataSource dataSource) &#123;        this.dataSource = dataSource;    &#125;    /**     * 获取连接池状态信息     *      * @return 包含连接池统计信息的Map     */    public Map&lt;String, Object&gt; getPoolStats() &#123;        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();                if (dataSource instanceof HikariDataSource) &#123;            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;            HikariPoolMXBean poolMXBean = hikariDataSource.getHikariPoolMXBean();                        stats.put(&quot;poolName&quot;, hikariDataSource.getPoolName());            stats.put(&quot;activeConnections&quot;, poolMXBean.getActiveConnections());            stats.put(&quot;idleConnections&quot;, poolMXBean.getIdleConnections());            stats.put(&quot;totalConnections&quot;, poolMXBean.getTotalConnections());            stats.put(&quot;threadsAwaitingConnection&quot;, poolMXBean.getThreadsAwaitingConnection());            stats.put(&quot;maxPoolSize&quot;, hikariDataSource.getMaximumPoolSize());        &#125; else &#123;            stats.put(&quot;message&quot;, &quot;Not a HikariCP datasource&quot;);            stats.put(&quot;dataSourceClass&quot;, dataSource.getClass().getName());        &#125;                return stats;    &#125;    /**     * 测试数据库连接     *      * @return 测试结果     */    public Map&lt;String, Object&gt; testConnection() &#123;        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();                long startTime = System.currentTimeMillis();        try (Connection connection = dataSource.getConnection()) &#123;            long endTime = System.currentTimeMillis();                        result.put(&quot;status&quot;, &quot;success&quot;);            result.put(&quot;connectionValid&quot;, connection.isValid(5));            result.put(&quot;connectionTime&quot;, (endTime - startTime) + &quot;ms&quot;);            result.put(&quot;connectionClass&quot;, connection.getClass().getName());            result.put(&quot;autoCommit&quot;, connection.getAutoCommit());                    &#125; catch (SQLException e) &#123;            result.put(&quot;status&quot;, &quot;error&quot;);            result.put(&quot;errorMessage&quot;, e.getMessage());            result.put(&quot;sqlState&quot;, e.getSQLState());            result.put(&quot;errorCode&quot;, e.getErrorCode());        &#125;                return result;    &#125;        /**     * 创建多个连接以测试连接池性能     *      * @param count 要创建的连接数量     * @return 测试结果     */    public Map&lt;String, Object&gt; createMultipleConnections(int count) &#123;        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();        long startTime = System.currentTimeMillis();        int successCount = 0;        int failureCount = 0;                for (int i = 0; i &lt; count; i++) &#123;            try (Connection connection = dataSource.getConnection()) &#123;                if (connection.isValid(1)) &#123;                    successCount++;                &#125; else &#123;                    failureCount++;                &#125;                // 执行一个简单的查询以模拟真实使用                connection.createStatement().execute(&quot;SELECT 1&quot;);            &#125; catch (SQLException e) &#123;                failureCount++;            &#125;        &#125;                long endTime = System.currentTimeMillis();        result.put(&quot;totalConnections&quot;, count);        result.put(&quot;successCount&quot;, successCount);        result.put(&quot;failureCount&quot;, failureCount);        result.put(&quot;totalTime&quot;, (endTime - startTime) + &quot;ms&quot;);        result.put(&quot;averageTime&quot;, (double)(endTime - startTime) / count + &quot;ms&quot;);        result.put(&quot;poolStats&quot;, getPoolStats());                return result;    &#125;&#125; \r\n可以发现 H2 数据库成功连接到连接池，并且进行了数据访问\r\n\r\n\r\nimage-20250620113120874\r\n\r\n\r\n\r\nimage-20250620113133393\r\n\r\n测试\r\n可以编写单元测试或集成测试来验证数据库操作是否正确。比如使用\r\nSpringBootTest 注解进行集成测试\r\n测试才是在 Spring Boot 中使用内存数据库的精髓之处，因为H2\r\n数据库作为轻量级内存数据库，在 Spring Boot\r\n测试体系中具备不可替代的优势：\r\n\r\n隔离性测试环境：每次测试启动时创建独立数据库实例，测试结束后自动销毁，避免真实数据库的数据污染\r\n提升测试效率：内存中运行速度极快，相比传统数据库可减少\r\n70% 以上的测试启动时间\r\n简化测试配置：无需部署独立数据库服务，通过纯 Java\r\n驱动即可完成测试环境搭建\r\n精准测试验证：支持 SQL\r\n标准语法，能准确模拟生产环境的数据库操作逻辑\r\n\r\n在 Spring Boot 测试体系中，H2 内存数据库的应用不仅仅是\r\n“替代真实数据库”，其核心价值体现在内存数据库的轻量级特性大幅缩短 CI/CD\r\n流水线时间，而且无需维护独立数据库实例，测试脚本可随代码一同版本管理。\r\n这时候，可以在测试专用的配置文件下写一个如下配置项来保持测试时候数据库表的隔离性\r\nspring.jpa.hibernate.ddl-auto=create-drop  # 测试时自动创建/删除表结构\r\n可以进行的测试如下，当然，数据库的CURD测试可以做到，那么控制器层，接口测试和集成测试也就相对应的可以完美实现。\r\n基于 @DataJpaTest 的单元测试（Repository\r\n层）\r\n\r\nUsersRepositoryTest - 测试用户仓库的CRUD操作\r\npackage edu.software.ergoutree.h2andspringboottest.repository;import java.sql.Timestamp;import java.time.Instant;import java.util.List;import java.util.Optional;import static org.assertj.core.api.Assertions.assertThat;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;import org.springframework.test.annotation.DirtiesContext;import edu.software.ergoutree.h2andspringboottest.entity.Users;@DataJpaTest@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)public class UsersRepositoryTest &#123;    @Autowired    private UsersRepository usersRepository;    @BeforeEach    public void setup() &#123;        // 清空用户表        usersRepository.deleteAll();    &#125;    @Test    public void testSaveUser() &#123;        // 准备测试数据        Users user = new Users();        user.setUsername(&quot;testuser&quot;);        user.setEmail(&quot;test@example.com&quot;);        user.setPassword(&quot;password123&quot;);        user.setCreateTime(Timestamp.from(Instant.now()));        // 保存用户        Users savedUser = usersRepository.save(user);        // 验证结果        assertThat(savedUser.getUserId()).isNotNull();        assertThat(savedUser.getUsername()).isEqualTo(&quot;testuser&quot;);        assertThat(savedUser.getEmail()).isEqualTo(&quot;test@example.com&quot;);    &#125;    @Test    public void testFindByUsername() &#123;        // 准备测试数据        Users user1 = new Users();        user1.setUsername(&quot;user1&quot;);        user1.setEmail(&quot;user1@example.com&quot;);        user1.setPassword(&quot;password1&quot;);        user1.setCreateTime(Timestamp.from(Instant.now()));        usersRepository.save(user1);        Users user2 = new Users();        user2.setUsername(&quot;user2&quot;);        user2.setEmail(&quot;user2@example.com&quot;);        user2.setPassword(&quot;password2&quot;);        user2.setCreateTime(Timestamp.from(Instant.now()));        usersRepository.save(user2);        // 测试根据用户名查找        Users foundUser = usersRepository.findByUsername(&quot;user1&quot;);                // 验证结果        assertThat(foundUser).isNotNull();        assertThat(foundUser.getEmail()).isEqualTo(&quot;user1@example.com&quot;);    &#125;    @Test    public void testFindAll() &#123;        // 准备测试数据        Users user1 = new Users();        user1.setUsername(&quot;user1&quot;);        user1.setEmail(&quot;user1@example.com&quot;);        user1.setPassword(&quot;password1&quot;);        user1.setCreateTime(Timestamp.from(Instant.now()));        usersRepository.save(user1);        Users user2 = new Users();        user2.setUsername(&quot;user2&quot;);        user2.setEmail(&quot;user2@example.com&quot;);        user2.setPassword(&quot;password2&quot;);        user2.setCreateTime(Timestamp.from(Instant.now()));        usersRepository.save(user2);        // 测试查找所有用户        List&lt;Users&gt; allUsers = usersRepository.findAll();                // 验证结果        assertThat(allUsers).hasSize(2);        assertThat(allUsers).extracting(Users::getUsername).containsExactlyInAnyOrder(&quot;user1&quot;, &quot;user2&quot;);    &#125;    @Test    public void testDeleteUser() &#123;        // 准备测试数据        Users user = new Users();        user.setUsername(&quot;userToDelete&quot;);        user.setEmail(&quot;delete@example.com&quot;);        user.setPassword(&quot;password&quot;);        user.setCreateTime(Timestamp.from(Instant.now()));        Users savedUser = usersRepository.save(user);        // 删除用户        usersRepository.deleteById(savedUser.getUserId());        // 验证结果        Optional&lt;Users&gt; deletedUser = usersRepository.findById(savedUser.getUserId());        assertThat(deletedUser).isEmpty();    &#125;&#125; \r\nOrdersRepositoryTest - 测试订单仓库的api可用性\r\npackage edu.software.ergoutree.h2andspringboottest.controller;import java.math.BigDecimal;import java.sql.Timestamp;import java.time.Instant;import static org.hamcrest.Matchers.containsInAnyOrder;import static org.hamcrest.Matchers.everyItem;import static org.hamcrest.Matchers.hasSize;import static org.hamcrest.Matchers.is;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.test.annotation.DirtiesContext;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import com.fasterxml.jackson.databind.ObjectMapper;import edu.software.ergoutree.h2andspringboottest.entity.Orders;import edu.software.ergoutree.h2andspringboottest.entity.Users;import edu.software.ergoutree.h2andspringboottest.service.OrdersService;import edu.software.ergoutree.h2andspringboottest.service.UsersService;@SpringBootTest@AutoConfigureMockMvc@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)public class OrdersControllerTest &#123;    @Autowired    private MockMvc mockMvc;    @Autowired    private OrdersService ordersService;    @Autowired    private UsersService usersService;    @Autowired    private ObjectMapper objectMapper;    private Users testUser;    @BeforeEach    public void setup() &#123;        // 创建测试用户        testUser = new Users();        testUser.setUsername(&quot;orderControllerTestUser&quot;);        testUser.setEmail(&quot;ordercontroller@example.com&quot;);        testUser.setPassword(&quot;password&quot;);        testUser.setCreateTime(Timestamp.from(Instant.now()));        testUser = usersService.saveUser(testUser);    &#125;    @Test    public void testGetOrderById() throws Exception &#123;        // 准备测试数据        Orders order = new Orders();        order.setUser(testUser);        order.setOrderAmount(new BigDecimal(&quot;123.45&quot;));        order.setOrderStatus(&quot;processing&quot;);        order.setOrderTime(Timestamp.from(Instant.now()));        Orders savedOrder = ordersService.saveOrder(order);        // 执行GET请求并验证结果        mockMvc.perform(get(&quot;/api/orders/&#123;id&#125;&quot;, savedOrder.getOrderId()))                .andExpect(status().isOk())                .andExpect(content().contentType(MediaType.APPLICATION_JSON))                .andExpect(jsonPath(&quot;$.orderAmount&quot;, is(123.45)))                .andExpect(jsonPath(&quot;$.orderStatus&quot;, is(&quot;processing&quot;)));    &#125;    @Test    public void testGetOrdersByUserIdAndStatus() throws Exception &#123;        // 准备测试数据        Orders order1 = new Orders();        order1.setUser(testUser);        order1.setOrderAmount(new BigDecimal(&quot;100.00&quot;));        order1.setOrderStatus(&quot;pending&quot;);        order1.setOrderTime(Timestamp.from(Instant.now()));        ordersService.saveOrder(order1);        Orders order2 = new Orders();        order2.setUser(testUser);        order2.setOrderAmount(new BigDecimal(&quot;200.00&quot;));        order2.setOrderStatus(&quot;pending&quot;);        order2.setOrderTime(Timestamp.from(Instant.now()));        ordersService.saveOrder(order2);        Orders order3 = new Orders();        order3.setUser(testUser);        order3.setOrderAmount(new BigDecimal(&quot;300.00&quot;));        order3.setOrderStatus(&quot;completed&quot;);        order3.setOrderTime(Timestamp.from(Instant.now()));        ordersService.saveOrder(order3);        // 执行GET请求并验证结果        mockMvc.perform(get(&quot;/api/orders/user/&#123;userId&#125;/status/&#123;status&#125;&quot;, testUser.getUserId(), &quot;pending&quot;))                .andExpect(status().isOk())                .andExpect(content().contentType(MediaType.APPLICATION_JSON))                .andExpect(jsonPath(&quot;$&quot;, hasSize(2)))                .andExpect(jsonPath(&quot;$[*].orderAmount&quot;, containsInAnyOrder(100.00, 200.00)))                .andExpect(jsonPath(&quot;$[*].orderStatus&quot;, everyItem(is(&quot;pending&quot;))));    &#125;    @Test    public void testCreateOrder() throws Exception &#123;        // 准备测试数据        Orders order = new Orders();        order.setUser(testUser);        order.setOrderAmount(new BigDecimal(&quot;999.99&quot;));        order.setOrderStatus(&quot;new&quot;);        order.setOrderTime(Timestamp.from(Instant.now()));        // 执行POST请求并验证结果        mockMvc.perform(post(&quot;/api/orders&quot;)                .contentType(MediaType.APPLICATION_JSON)                .content(objectMapper.writeValueAsString(order)))                .andExpect(status().isOk())                .andExpect(jsonPath(&quot;$.orderAmount&quot;, is(999.99)))                .andExpect(jsonPath(&quot;$.orderStatus&quot;, is(&quot;new&quot;)));    &#125;    @Test    public void testGetNonExistentOrder() throws Exception &#123;        // 执行GET请求并验证结果 - 应该返回404        mockMvc.perform(get(&quot;/api/orders/999&quot;))                .andExpect(status().isNotFound());    &#125;&#125;\r\n\r\n\r\nimage-20250620114801513\r\n\r\n\r\n​ 可以发现 H2 数据库做测试是很方便而且环境高度隔离的\r\n基于 @SpringBootTest\r\n的集成测试（全流程验证）\r\npackage edu.software.ergoutree.h2andspringboottest.integration;@SpringBootTest@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)@Transactionalpublic class UserOrderIntegrationTest &#123;    @Autowired    private UsersService usersService;    @Autowired    private OrdersService ordersService;    @Autowired    private JdbcTemplate jdbcTemplate;    @Test    public void testCreateUserAndOrder() &#123;        // 创建用户        Users user = new Users();        user.setUsername(&quot;integrationTestUser&quot;);        user.setEmail(&quot;integration@example.com&quot;);        user.setPassword(&quot;password&quot;);        user.setCreateTime(Timestamp.from(Instant.now()));        Users savedUser = usersService.saveUser(user);        // 创建订单        Orders order = new Orders();        order.setUser(savedUser);        order.setOrderAmount(new BigDecimal(&quot;999.99&quot;));        order.setOrderStatus(&quot;processing&quot;);        order.setOrderTime(Timestamp.from(Instant.now()));        Orders savedOrder = ordersService.saveOrder(order);        // 验证用户和订单关联关系        List&lt;Orders&gt; userOrders = ordersService.findOrdersByUserAndStatus(savedUser, &quot;processing&quot;);        assertThat(userOrders).hasSize(1);        assertThat(userOrders.get(0).getOrderId()).isEqualTo(savedOrder.getOrderId());        assertThat(userOrders.get(0).getUser().getUserId()).isEqualTo(savedUser.getUserId());    &#125;    @Test    @Sql(&quot;/test-data.sql&quot;)    public void testWithSqlScript() &#123;        // 这个测试方法会在执行前运行 test-data.sql 脚本，预先填充测试数据                // 验证脚本创建的用户数据        Users user = usersService.findUserByUsername(&quot;scriptUser&quot;);        assertThat(user).isNotNull();        assertThat(user.getEmail()).isEqualTo(&quot;script@example.com&quot;);        // 验证脚本创建的订单数据        List&lt;Orders&gt; orders = ordersService.findOrdersByUserAndStatus(user, &quot;completed&quot;);        assertThat(orders).hasSize(1);        assertThat(orders.get(0).getOrderAmount()).isEqualTo(new BigDecimal(&quot;888.88&quot;));    &#125;    @Test    public void testDirectJdbcAccess() &#123;        // 创建用户        Users user = new Users();        user.setUsername(&quot;jdbcTestUser&quot;);        user.setEmail(&quot;jdbc@example.com&quot;);        user.setPassword(&quot;password&quot;);        user.setCreateTime(Timestamp.from(Instant.now()));        Users savedUser = usersService.saveUser(user);        // 创建订单        Orders order = new Orders();        order.setUser(savedUser);        order.setOrderAmount(new BigDecimal(&quot;123.45&quot;));        order.setOrderStatus(&quot;pending&quot;);        order.setOrderTime(Timestamp.from(Instant.now()));        ordersService.saveOrder(order);        // 使用原生SQL查询验证数据        String sql = &quot;SELECT u.username, u.email, o.order_amount, o.order_status &quot; +                     &quot;FROM users u JOIN orders o ON u.user_id = o.user_id &quot; +                     &quot;WHERE u.username = ?&quot;;                List&lt;Map&lt;String, Object&gt;&gt; results = jdbcTemplate.queryForList(sql, &quot;jdbcTestUser&quot;);                assertThat(results).hasSize(1);        assertThat(results.get(0).get(&quot;USERNAME&quot;).toString()).isEqualTo(&quot;jdbcTestUser&quot;);        assertThat(results.get(0).get(&quot;EMAIL&quot;).toString()).isEqualTo(&quot;jdbc@example.com&quot;);        assertThat(results.get(0).get(&quot;ORDER_STATUS&quot;).toString()).isEqualTo(&quot;pending&quot;);    &#125;&#125; \r\n\r\n\r\nimage-20250620114851241\r\n\r\n可以从上述测试过程中看出，从仓库到控制器到项目集成测试的各个层次，充分展示了H2数据库在Spring\r\nBoot项目中的测试优势。\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["数据库技术","框架知识","学习","数据库","MySql","Spring Boot","测试","使用知识"]},{"title":"推导theta=0纵剖面上的抽水降落曲线公式","url":"/posts/47136.html","content":"推导 θ = 0\r\n纵剖面上的抽水降落曲线公式\r\n根据辐射井的抽水降落曲面模型论文内容，θ = 0\r\n纵剖面是沿着辐射管方向的剖面。推导分为两个区域：辐射管范围内的垂直渗流区（0 ≤ ρ ≤ l + r）和辐射管范围外的水平渗流区（l + r ≤ ρ ≤ R）。以下是详细推导过程：\r\n\r\n1. 垂直渗流区 (0 ≤ ρ ≤ l + r)\r\n基本假设：\r\n在垂直渗流区（辐射管范围内），地下水运动以垂向渗流为主，其核心特征是：\r\n\r\n近井处水力坡度平缓（水位变化小）\r\n远离井处水力坡度陡峭（水位变化大）\r\n水位差变化率与当前位置水位差成正比\r\n\r\n数学表述为： ΔT(ρ, 0) = ω ⋅ T(ρ, 0) ⋅ ΔρΔT(ρ, 0) = ω ⋅ T(ρ, 0) ⋅ Δρ\r\n其中：\r\n\r\nT(ρ, 0) = H(ρ, 0) − Hs（点(ρ, 0)与竖井水位差）\r\nω：垂直渗流区特征参数（常数）\r\nΔρ：径向距离增量\r\n\r\n在垂直渗流区，水位高度 T(ρ, 0) 的增长率为常数\r\nω。这意味着单位距离 Δρ 内，T(ρ, 0) 的增量与 T(ρ, 0) 本身成正比。\r\n数学表达：\r\nΔT(ρ, 0) = T(ρ + Δρ, 0) − T(ρ, 0) = ω ⋅ T(ρ, 0) ⋅ Δρ\r\n推导步骤：\r\n\r\n建立微分方程：\r\n当Δρ → 0时，差分方程转化为微分方程：\r\n$$\r\n\\frac{dT}{d\\rho} = \\lim_{\\Delta\\rho \\to 0} \\frac{T(\\rho+\\Delta\\rho,0) -\r\nT(\\rho,0)}{\\Delta\\rho} = \\omega T(\\rho,0)\r\n$$ 得到： $$\r\n\\frac{dT}{d\\rho} = \\omega T(\\rho,0) \\quad (1)\r\n$$\r\n物理意义：水位差的变化率与当前位置水位差成正比，比例系数为ω。\r\n分离变量并积分：\r\n将方程(1)改写为： $$\r\n\\frac{1}{T(\\rho,0)} dT = \\omega  d\\rho \\quad (2)\r\n$$ 两边积分： $$\r\n\\int \\frac{1}{T(\\rho,0)}  \\mathrm{d}T = \\int \\omega  \\mathrm{d}\\rho\r\n$$ 解得： ln |T(ρ, 0)| = ωρ + C  (3)\r\n其中 C 为积分常数。\r\n指数化：\r\n对(3)式取指数： T(ρ, 0) = eωρ + C = eC ⋅ eωρ\r\n令 A = eC，则：\r\nT(ρ, 0) = A ⋅ eωρ  (4)\r\n应用边界条件：\r\n在辐射管端点 ρ = l + r 处：\r\nT(l + r, 0) = Te = He − Hs  (5)\r\n将(5)代入(4)： Te = A ⋅ eω(l + r)\r\n解得： A = Te ⋅ e−ω(l + r)  (6)\r\n其中，常数A包含端点信息，将局部解与整体系统连接。\r\n最终方程：\r\n将(6)代回(4)，代入 A：\r\nT(ρ, 0) = Te ⋅ e−ω(l + r) ⋅ eωρ = Te ⋅ eω(ρ − l − r)\r\n还原水位高度 T(ρ, 0) = H(ρ, 0) − Hs\r\n和 Te = He − Hs：\r\nH(ρ, 0) − Hs = (He − Hs) ⋅ eω(ρ − l − r)\r\n整理得到垂直渗流区方程： $$\r\n\\boxed{H(\\rho,0) = (H_e - H_s) \\cdot e^{\\omega (\\rho - l - r)} + H_s}\r\n$$\r\n\r\n参数ω的物理意义与确定\r\n物理意义：\r\n\r\nω &gt; 0：水位随ρ增加而指数增长\r\nω值越大：曲线越陡峭（水位变化剧烈）\r\nω值越小：曲线越平缓（水位变化缓慢）\r\n\r\n确定方法： 选取两个观测点ρ1, ρ2\r\n(ρ2 &gt; ρ1)：\r\n$$\r\n\\omega = \\frac{1}{\\rho_2 - \\rho_1} \\ln \\left( \\frac{H(\\rho_2,0) -\r\nH_s}{H(\\rho_1,0) - H_s} \\right)\r\n$$ 推导说明： 从方程取两点比值： $$\r\n\\frac{H(\\rho_2,0) - H_s}{H(\\rho_1,0) - H_s} = e^{\\omega [(\\rho_2 - (l +\r\nr)) - (\\rho_1 - (l + r))]} = e^{\\omega (\\rho_2 - \\rho_1)}\r\n$$ 取对数即得ω表达式。\r\n模型特性分析\r\n\r\n指数衰减特性：\r\n\r\n当ρ = l + r时：H = He\r\n当ρ减小时（靠近竖井）：eω[ρ − (l + r)] → 0\r\n⇒ H → Hs\r\n完美描述”近井平缓，远井陡峭”特征\r\n\r\n导数分析（水力坡度）： $$\\frac{dH}{d\\rho} = \\omega (H_e - H_s) e^{\\omega\r\n[\\rho - (l + r)]}$$\r\n\r\nρ增大 ⇒ 导数增大 ⇒\r\n水力坡度增大\r\n解释辐射管末端水位陡降现象\r\n\r\n曲率分析： $$\\frac{d^2H}{d\\rho^2} = \\omega^2 (H_e - H_s)\r\ne^{\\omega [\\rho - (l + r)]} &gt; 0$$ 二阶导恒正 → 曲线下凸 →\r\n符合观测的”下凸曲线”特征\r\n\r\n\r\n水平渗流区完整推导流程\r\n我将以严格的数学物理方法，逐步推导水平渗流区的控制方程和影响半径公式，并阐明每个步骤的物理意义。以下是详细的推导过程：\r\n\r\n1. 基本假设与物理模型\r\n在水平渗流区（ρ ≥ l + r）：\r\n\r\n水流以水平径向流动为主，垂直分量可忽略\r\n满足达西定律：$v = -K\r\n\\frac{dH}{d\\rho}$\r\n（v为渗流速度，K为渗透系数）\r\n单位厚度流量守恒：Q = 2πρ ⋅ v ⋅ h\r\n（h为含水层厚度）\r\n\r\n\r\n2. 微分方程建立\r\n步骤1：流量守恒表达 取半径为ρ的圆柱面，通过该面的流量： $$\r\nQ = -2\\pi \\rho K h \\frac{dH}{d\\rho}\r\n$$ 由于Q为常数（稳态流），整理得： $$\r\n\\frac{dH}{d\\rho} = -\\frac{Q}{2\\pi K h} \\cdot \\frac{1}{\\rho} \\quad (1)\r\n$$\r\n步骤2：引入参数λ 令： $$\r\n\\lambda = \\frac{2\\pi K h}{Q} \\quad \\text{（量纲：$[L^{-1}]$）}\r\n$$ 则(1)式改写为： $$\r\n\\frac{dH}{d\\rho} = -\\frac{1}{\\lambda \\rho} \\quad (2)\r\n$$ 或等价表示为： $$\r\n\\lambda dH = -\\frac{1}{\\rho} d\\rho \\quad (3)\r\n$$\r\n\r\n物理意义：水位梯度与距离成反比，λ综合反映含水层渗透能力与抽水强度的比值。\r\n\r\n\r\n3. 方程求解\r\n步骤3：分离变量积分 对(3)式积分： $$\r\n\\int \\lambda dH = -\\int \\frac{1}{\\rho} d\\rho \\\\\r\n\\lambda H = -\\ln \\rho + C \\quad (4)\r\n$$ （C为积分常数）\r\n步骤4：边界条件应用 在辐射管端点（ρ = l + r）处：\r\nH(l + r, 0) = He\r\n代入(4)式： $$\r\n\\lambda H_e = -\\ln(l+r) + C \\\\\r\n\\Rightarrow C = \\lambda H_e + \\ln(l+r)\r\n$$\r\n步骤5：通解确定 将C代回(4)式： $$\r\n\\lambda H = -\\ln \\rho + \\lambda H_e + \\ln(l+r) \\\\\r\n\\Rightarrow H = \\frac{1}{\\lambda} \\left[\r\n\\ln\\left(\\frac{l+r}{\\rho}\\right) \\right] + H_e\r\n$$ 调整对数项符号，得到最终形式： $$\r\n\\boxed{H(\\rho,0) = H_e - \\frac{1}{\\lambda}\r\n\\ln\\left(\\frac{\\rho}{l+r}\\right)}\r\n$$\r\n\r\n注：此形式与原文符号约定不同，但物理本质一致。若需与原文完全一致，可通过重新定义λ′ = −λ转换。\r\n\r\n\r\n4. 影响半径R的推导\r\n定义：影响半径是水位恢复至初始水位H0的位置： H(R, 0) = H0\r\n步骤6：代入求解 将H(R, 0) = H0代入方程：\r\n$$\r\nH_0 = H_e - \\frac{1}{\\lambda} \\ln\\left(\\frac{R}{l+r}\\right) \\\\\r\n\\Rightarrow \\ln\\left(\\frac{R}{l+r}\\right) = \\lambda (H_e - H_0) \\\\\r\n\\Rightarrow \\frac{R}{l+r} = e^{\\lambda (H_e - H_0)} \\\\\r\n\\Rightarrow \\boxed{R = (l+r) e^{\\lambda (H_e - H_0)}}\r\n$$\r\n\r\n物理意义：\r\n\r\n当抽水降深(H0 − He)增大时，R指数增长\r\nλ越小（渗透性越好或抽水量越小），影响半径增长越慢\r\n\r\n\r\n\r\n5. 参数λ的确定方法\r\n通过两个观测点(ρ3, H3)和(ρ4, H4)计算：\r\n$$\r\n\\lambda = \\frac{\\ln(\\rho_4 / \\rho_3)}{H_e - H_0} \\cdot \\frac{H_e -\r\nH_0}{H_4 - H_3} = \\frac{\\ln(\\rho_4 / \\rho_3)}{H_4 - H_3}\r\n$$\r\n推导验证： 由水平渗流区方程： $$\r\nH_4 - H_3 = -\\frac{1}{\\lambda} \\left[ \\ln\\left(\\frac{\\rho_4}{l+r}\\right)\r\n- \\ln\\left(\\frac{\\rho_3}{l+r}\\right) \\right] = -\\frac{1}{\\lambda}\r\n\\ln\\left(\\frac{\\rho_4}{\\rho_3}\\right) \\\\\r\n\\Rightarrow \\lambda = -\\frac{\\ln(\\rho_4 / \\rho_3)}{H_4 - H_3}\r\n$$ （负号表示水位随距离增加而升高）\r\n\r\n6. 与传统理论的对比\r\n将结果与Theis径向流对比：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n模型\r\n方程形式\r\n参数联系\r\n\r\n\r\n\r\n\r\n本文辐射井模型\r\n$H = H_e - \\frac{1}{\\lambda}\r\n\\ln(\\rho)$\r\nλ = 2πT/Q\r\n\r\n\r\nTheis稳态解\r\n$s = \\frac{Q}{2\\pi T}\r\n\\ln(R/r)$\r\nT = Kh（导水系数）\r\n\r\n\r\n\r\n\r\n可见两者本质相同，λ与导水系数T和抽水量Q直接相关。\r\n\r\n\r\n2. 水平渗流区 (l + r ≤ ρ ≤ R)\r\n基本假设：\r\n在水平渗流区，单位距离 Δρ 内水位变化 ΔH 与距离 ρ 成反比，即 Δρ = λρΔH。\r\n数学表达：\r\nΔρ = λ ⋅ ρ ⋅ ΔH\r\n推导步骤：\r\n\r\n建立微分方程：\r\n当 ΔH → 0 时： dρ = λ ⋅ ρ ⋅ dH\r\n整理为： $$\r\n\\lambda \\cdot \\mathrm{d}H = \\frac{1}{\\rho} \\mathrm{d}\\rho\r\n$$\r\n分离变量并积分：\r\n$$\r\n\\int \\lambda  \\mathrm{d}H = \\int \\frac{1}{\\rho}  \\mathrm{d}\\rho\r\n$$ 解得： λH = ln |ρ|+C\r\n其中 C 为积分常数。\r\n应用边界条件：\r\n在辐射管端点 ρ = l + r 处：\r\nH(l + r, 0) = He\r\n代入得： λHe = ln (l + r) + C\r\n解得： C = λHe − ln (l + r)\r\n最终方程：\r\n代入 C： λH = ln ρ + λHe − ln (l + r)\r\n整理得： $$\r\nH(\\rho,0) = \\frac{1}{\\lambda} \\left[ \\ln\\rho - \\ln(l + r) \\right] + H_e\r\n$$ 即： $$\r\n\\boxed{H(\\rho,0) = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\rho}{l + r}\\right)\r\n+ H_e}\r\n$$\r\n\r\n\r\n3. 综合方程与影响半径 R\r\n\r\n完整剖面方程：\r\n$$\r\nH(\\rho,0) =\r\n\\begin{cases}\r\n(H_e - H_s) e^{\\omega(\\rho - l - r)} + H_s, &amp; 0 \\leq \\rho \\leq l + r\r\n\\\\\r\n\\dfrac{1}{\\lambda} \\ln\\left(\\dfrac{\\rho}{l + r}\\right) + H_e, &amp; l +\r\nr \\leq \\rho \\leq R\r\n\\end{cases}\r\n$$\r\n影响半径 R\r\n的推导：\r\n\r\n在影响半径边界 ρ = R\r\n处，水位恢复至初始高度 H0： H(R, 0) = H0\r\n代入水平渗流区方程： $$\r\n\\frac{1}{\\lambda} \\ln\\left(\\frac{R}{l + r}\\right) + H_e = H_0\r\n$$\r\n解得： $$\r\n\\ln\\left(\\frac{R}{l + r}\\right) = \\lambda (H_0 - H_e)\r\n$$\r\n$$\r\n\\frac{R}{l + r} = e^{\\lambda (H_0 - H_e)}\r\n$$\r\n即： $$\r\n\\boxed{R = (l + r) \\cdot e^{\\lambda (H_0 - H_e)}}\r\n$$\r\n\r\n\r\n\r\n关键参数说明\r\n\r\nω（垂直渗流区参数）：\r\n表征垂直渗流区水位曲线的弯曲程度，由实测数据拟合： $$\r\n\\omega = \\frac{1}{\\rho_2 - \\rho_1} \\ln \\frac{H(\\rho_2,0) -\r\nH_s}{H(\\rho_1,0) - H_s}\r\n$$\r\nλ（水平渗流区参数）：\r\n表征水平渗流区水位曲线的弯曲程度，由实测数据拟合： $$\r\n\\lambda = \\frac{\\ln \\rho_4 - \\ln \\rho_3}{H(\\rho_4,0) - H(\\rho_3,0)}\r\n$$\r\n\r\n\r\n物理意义总结\r\n\r\n垂直渗流区：\r\n水位变化呈指数规律，反映辐射管的强汇流作用，近井处水力坡度平缓，远处陡峭。\r\n水平渗流区：\r\n水位变化呈对数规律，与传统管井的Theis模型一致，体现径向流特征。\r\n影响半径 R：\r\n由初始水位 H0、端点水位 He 和参数 λ 共同决定，其公式融合了井结构参数\r\n(l, r) 和水力参数\r\n(λ)。\r\n\r\n\r\n而模型中参数ω可理解为垂直渗流区降落曲线弯曲程度的大小，对于同一地区，同样井型结构的辐射井，ω的值比较接近；参数λ亦可理解为水平渗流区降落曲线弯曲程度的大小，在同地区同井型结构的辐射井中，λ的值也很接近。故在辐射管的正上方(即θ = 0的纵剖面)无观测资料时，可用任一极角θ剖面上的数据代替。\r\n论证思路从参数 ω 和 λ\r\n的普适性及角度无关性入手，如下。\r\n\r\n核心论点\r\n\r\nω 和 λ 的物理本质\r\n\r\nω\r\n是垂直渗流区降落曲线弯曲程度的度量：\r\n\r\nω\r\n越大，曲线衰减越快（凹形越显著），反映含水层垂向渗透性强或辐射管集水效率高。\r\n公式： $$\r\n\\omega = \\frac{1}{\\rho_2 - \\rho_1}\\ln{\\frac{H(\\rho_2, 0) -\r\nH_s}{H(\\rho_1, 0) - H_s}}\r\n$$\r\n\r\nλ\r\n是水平渗流区降落曲线弯曲程度的度量：\r\n\r\nλ\r\n越大，曲线增长越慢（凸形越平缓），反映含水层水平渗透性弱或影响半径大。\r\n\r\n公式：$ = $\r\n\r\n\r\n普适性依据\r\n\r\n同地区同井型：\r\n\r\n同一黄土地区 → 渗透系数 K、储水率 S 等水文地质参数相同。\r\n\r\n相同辐射井结构（管长 L = 120m、管径 d = 0.12m、管数 n = 8） →\r\n几何边界和汇流模式一致。\r\n\r\n因此 ω 和 λ\r\n作为综合参数，主要取决于含水层性质和井结构，值域稳定。\r\n\r\n\r\n角度独立性：\r\n\r\n辐射井在圆周方向均匀对称（8根管，45°间隔），含水层均质各向同性。\r\n\r\n任意 θ\r\n剖面的水流模式物理等效，故 ω(θ) ≈ ω(0)，λ(θ) ≈ λ(0)。\r\n\r\n\r\n\r\n\r\n论证步骤\r\n1. 验证 ω 和 λ 的稳定性\r\n\r\n方法：用题目表1数据计算不同 θ 的 ω 和 λ，比较其差异。\r\n数据选取（以稳定时刻 4.22.1\r\n为例）：\r\n\r\n\r\n\r\n观测点\r\nθ\r\nρ (m)\r\nH (m)\r\n区域\r\n\r\n\r\n\r\n\r\n井位\r\n-\r\n0\r\n7.13\r\n-\r\n\r\n\r\nN₁\r\n18°\r\n50\r\n7.44\r\n垂直渗流区\r\n\r\n\r\nN₂\r\n18°\r\n110\r\n7.91\r\n垂直渗流区\r\n\r\n\r\nN₃\r\n18°\r\n130\r\n8.31\r\n水平渗流区\r\n\r\n\r\nN₅\r\n18°\r\n259.5\r\n5.99\r\n水平渗流区\r\n\r\n\r\n观测井4\r\n10°\r\n400\r\n3.93\r\n水平渗流区\r\n\r\n\r\n\r\n计算 ω（θ = 18∘）：\r\n$$\r\n\\omega = \\frac{1}{110 - 50} \\ln \\frac{(7.91 - 7.13)}{(7.44 - 7.13)} =\r\n\\frac{1}{60} \\ln \\frac{0.78}{0.31} \\approx 0.0152  \\text{m}^{-1}\r\n$$\r\n计算 λ（θ = 18∘，用 N₃ 和\r\nN₅）：\r\n$$\r\n\\lambda = \\frac{\\ln 259.5 - \\ln 130}{5.99 - 8.31} = \\frac{\\ln\r\n2.0}{-2.32} \\approx \\frac{0.693}{-2.32} \\approx -0.299  \\text{m}^{-1}\r\n$$\r\n\r\n注：负值因 H(ρ) 随 ρ 增大而减小（N₅ 水位低于\r\nN₃），符合辐射管方向集水效应。\r\n\r\n结论：\r\nω ≈ 0.0152 和 λ ≈ −0.299 是 θ = 18∘ 剖面的解。若在\r\nθ = 10∘\r\n重复计算（需更多数据），预期值相近，验证普适性。\r\n\r\n2. 论证角度无关性\r\n\r\n物理对称性分析：\r\n\r\n辐射管均匀分布 → 任意 θ 与\r\nθ + 45k∘\r\n(k ∈ ℤ) 的水力梯度 $i = -\\frac{dH}{d\\rho}$ 相同。\r\n\r\n含水层各向同性 → 渗透性无方向差异，水流运动方程 $ (K H) = 0 $\r\n在旋转下不变。\r\n\r\n因此 ω 和 λ 是旋转不变量。\r\n数学推导验证：\r\n垂直渗流区方程 $ = (H - H_s) $ 无显式 θ 项 → 解 H(ρ, θ) = [He − Hs]eω(ρ − l − r) + Hs\r\n与 θ 无关。\r\n水平渗流区方程 $ dH = $ 同理。\r\n数据佐证：\r\n若在 θ = 0∘ 和\r\nθ = 45∘\r\n有对称点观测值，可证 H(ρ, 0) ≈ H(ρ, 45)\r\n→ ω、λ 一致。\r\n\r\n注：题目中 θ = 10∘ 和 θ = 18∘\r\n非对称点，但因参数普适，仍可互代。\r\n\r\n\r\n3. 无 θ = 0∘\r\n数据时的替代方案\r\n\r\n操作步骤：\r\n\r\n任选一极角 θ 的剖面（如\r\nθ = 18∘），用其观测孔（N₁、N₂）计算\r\nω。\r\n\r\n用同剖面水平渗流区点（N₃、N₅）计算 λ。\r\n\r\n将 ω、λ 代入 θ = 0∘ 的曲线方程：\r\n\r\n垂直区：$ H(, 0) = [H_e - H_s] e^{(- l - r)} + H_s $\r\n\r\n水平区：$ H(, 0) = [- (l + r)] + H_e $\r\n\r\n\r\n误差分析：\r\n\r\n角度偏差 Δθ\r\n引起的相对误差 δω/ω ∝ (Δθ)2（泰勒展开二次项）。\r\n\r\n示例：若 θ = 18∘ 替代 θ = 0∘，Δθ = 18∘，在黄土均质条件下\r\nδω &lt; 5%（工程可接受）。\r\n\r\n\r\n\r\n题目应用指导\r\n\r\nθ = 0∘\r\n曲线的构造：\r\n\r\n直接使用 θ = 18∘ 剖面的 ω = 0.0152 和 λ = −0.299 代入公式 (2) 和\r\n(3)。\r\n边界值 He\r\n取辐射管端点水位（ρ = l + r = 120.5\r\nm），可从 N₃（ρ = 130\r\nm）外推：\r\n$$\r\nH_e = H(130, 18^\\circ) + \\frac{1}{\\lambda} \\ln \\frac{120.5}{130} \\approx\r\n8.31 + (-3.34) \\times (-0.075) \\approx 8.56  \\text{m}\r\n$$\r\n\r\n水量公式的建立：\r\n\r\n出水量 Q\r\n由垂直区汇流和水平区补给组成：\r\n$$\r\nQ = \\underbrace{2\\pi K \\int_0^{l} \\rho \\frac{\\partial H}{\\partial \\rho}\r\nd\\rho}_{\\text{垂直区}} + \\underbrace{2\\pi K \\int_{l}^{\\infty} \\rho\r\n\\frac{\\partial H}{\\partial \\rho} d\\rho}_{\\text{水平区}}\r\n$$\r\n代入 H(ρ, 0)\r\n的表达式 (2)(3)，结合 ω、λ 得：\r\n$$\r\nQ = C_1 K (H_e^2 - H_s^2) + C_2 K \\frac{H_e - H_R}{\\lambda}\r\n$$ 其中 C1, C2\r\n为结构参数，HR\r\n为影响半径处水位。\r\n\r\n\r\n\r\n结论\r\n\r\n参数普适性：ω 和 λ\r\n是黄土含水层性质与辐射井结构的固有属性，同地区同井型下稳定。\r\n\r\n角度无关性：因几何对称和含水层各向同性，任意\r\nθ 剖面可等效替代 θ = 0∘。\r\n\r\n题目操作：直接使用 θ = 18∘ 的观测数据计算\r\nω 和 λ，代入 θ = 0∘\r\n曲线方程，误差可控。\r\n\r\n工程意义：减少对特定角度观测的依赖，降低勘测成本，推广辐射井模型应用。\r\n\r\n","categories":["数学类","数学建模"],"tags":["其他","数学","物理","数学建模","定理证明"]},{"title":"操作系统之处理机的死锁部分概述","url":"/posts/27893.html","content":"死锁概述\r\n死锁（Deadlock）：是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。\r\n资源问题\r\n\r\n可重用性资源和消耗性资源：\r\n\r\n可重用性资源：\r\n\r\n是一种可供用户重复使用多次的资源。每一个可重用性资源只能分配给一个进程使用，不允许多个进程共享。\r\n资源的单元数目是相对固定的，在运行期间既不能创建也不能删除它\r\n\r\n消耗性资源：\r\n\r\n在进程运行期间，由进程动态地创建和消耗。\r\n资源的单元数目在进程运行期间可以不断变化的。进程可以请求若干个可消耗性资源单元。\r\n可消耗性资源通常由生产者创建，消费者消耗。\r\n\r\n\r\n可抢占性资源和不可抢占性资源。\r\n\r\n可抢占性资源：\r\n\r\n某进程获得该资源后，该资源可以再被其他进程或系统抢占。\r\n不会引起死锁。\r\n\r\n不可抢占性资源是指资源一旦被分配给进程，只能在进程用完后自行释放。\r\n\r\n\r\n### 计算机中的死锁\r\n\r\n竞争不可抢占性资源引起死锁。\r\n\r\n两进程分别保持一个临界资源，而又分别因请求对方所保持的资源被阻塞。\r\n\r\n竞争可消耗性资源引起死锁。\r\n\r\n一进程需接受到对方发送的消息a后才能发送消息b，而另一进程需接受到对方发送的消息b后才能发送消息a。\r\n\r\n进程推进顺序不当引起死锁。\r\n\r\n同样是请求和保持原因。\r\n\r\n\r\n死锁的定义：\r\n如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的时间，那么该组进程是死锁的。\r\n产生死锁的必要条件\r\n互斥条件：指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。\r\n请求和保持条件：指进程已经保持了至少一个资源，但又提出了\r\n新的资源请求（该资源又被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放）。\r\n不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放\r\n环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。即进程集合{P0,P1,P2,…,Pn}中的P0正在等待一个P1占用的资源；P1正在等待一个P2占用的资源，……，Pn正在等待一个已被P0占用的资源。\r\n死锁处理方法\r\n预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件的一个或几个，来预防发生死锁。\r\n避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁\r\n检测死锁：通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当的措施，从系统中将已发生的死锁清除掉\r\n解除死锁：当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源\r\n预防死锁\r\n由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏其它三个条件。\r\n破坏“请求和保持”条件\r\n第一种协议：\r\n​\r\n规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。在整个运行期间便不会再提出资源要求，从而破坏了请求条件。\r\n​\r\n在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需的各资源都空闲，也不分配给该进程，即在该进程的等待期间，它并未占有任何资源，因而也破坏了保持条件。\r\n第二种协议：\r\n​ 允许进程只获得运行初期所需的资源后，便开始运行。\r\n​\r\n进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再去请求新的所需资源\r\n破坏不可抢占条件\r\n当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。\r\n这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被抢占了，从而破坏了“不可抢占”条件。\r\n破坏 循环等待条件\r\n系统将所有类型资源进行线性排队，并赋予不同的序号。规定每个进程必须按序号递增的顺序请求资源。\r\n假如某进程已请求到一些序号较高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源\r\n在采用这种策略后不可能再出现环路，因而破坏了“循环等待”条件。\r\n避免死锁\r\n系统安全状态：\r\n系统在进行资源分配之前，应先计算此次资源分配的安全性。\r\n安全状态，是指系统能按某种进程顺序（ P0, P1, P2, …, Pn\r\n）来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态\r\n安全状态下不会产生死锁，但是不安全状态不一定产生死锁\r\n利用银行家算法避免死锁\r\n描述资源的数据结构\r\n在系统中必须设置四种数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。\r\n（设系统中有m类资源，n个进程）\r\n\r\n可利用资源向量 Available：\r\n\r\n这是一个含有 m\r\n个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。\r\n如果 Available[j]=K，则表示系统中现有 R j类资源K 个。\r\n\r\n最大需求矩阵 Max：\r\n\r\n这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m\r\n类资源的最大需求。\r\n\r\n分配矩阵 Allocation：\r\n\r\n这也是一个 n×m\r\n的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。\r\n如果 Allocation[i,j]=K，则表示进程 i 当前已分得 R j类资源的数目为\r\nK。\r\n\r\n需求矩阵 Need。这也是一个 n×m\r\n的矩阵，用以表示每一个进程尚需的各类资源数。\r\n\r\n如果 Need[i,j]=K，则表示进程 i 还需要 R j类资源 K\r\n个，方能完成其任务。\r\n\r\n\r\n上述三个矩阵间存在下述关系：Need[i, j] = Max[i, j] - Allocation[i,\r\nj]\r\n银行家算法：\r\n设 Request[i] 是进程 P i 的请求向量，如果 Request[i][j]=K，表示进程 P\r\ni需要 K 个 R j 类型的资源。当 P\r\ni发出资源请求后，系统按下述步骤进行检查：\r\n\r\n如果\r\nRequest[i][j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值\r\n如果\r\nRequest[i][j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi\r\n须等待。\r\n系统试探着把资源分配给进程 P i，并修改下面数据结构中的数值：\r\n\r\nAvailable[j] = Available[j]-Request[i][j]； 更新可用资源数目\r\nAllocation[i,j] = Allocation[i,j]+Request[i][j]；\r\n更新分配给该进程的资源数\r\nNeed[i,j] = Need[i,j]-Request[i][j]； 更新该进程需要的资源数\r\n\r\n\r\n安全性算法：\r\n\r\n设置两个向量：\r\n\r\n工作向量\r\nWork，它表示系统可提供给进程继续运行所需的各类资源数目，它含有\r\nm个元素，在执行安全算法开始时，Work=Available。\r\nFinish:\r\n含n个元素的一维数组，表示系统是否有足够的资源分配给n个进程，使之运行完成。开始时先令Finish[i]:=false\r\n(i=1..n); 当有足够资源分配给进程i时，再令Finish[i]:=true。\r\n\r\n从进程集合中找到一个能满足下述条件的进程：\r\n\r\nFinish[i]=false;\r\nNeed[i,j]≤Work[j]；\r\n若找到，执行步骤(3)，否则，执行步骤(4)。\r\n\r\n当进程\r\nPi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：\r\n\r\nWork[j] = Work[j]+Allocation[i,j]；\r\nFinish[i] = true；\r\ngo to step 2；\r\n\r\n如果所有进程的 Finish[i]=true\r\n都满足，则表示系统处于安全状态；否则，系统处于不安全状态。\r\n\r\n死锁的检测和解除\r\n\r\n当系统为进程分配资源时，若未采取任何限制性措施，则系统必须提供检测和解除死锁的手段，为此系统必须：\r\n\r\n保存有关资源的请求和分配信息；\r\n提供一种算法，以利用这些信息来检测系统是否已进入死锁状态。\r\n\r\n资源分配图：\r\n\r\n系统死锁可利用资源分配图来描述：\r\n该图由表示进程的圆圈和表示一类资源的方框组成\r\n其中方框中的一个点代表一个该类资源，请求边是由进程指向方框中的rj，而分配边则应始于方框中的一个点。如图所示。\r\n\r\n\r\nimage-20250429200304004\r\n\r\n\r\n死锁定理：\r\n\r\n在资源分配图中找出一个既不阻塞又非独立的进程结点Pi，在顺利的情况下运行完毕，释放其占有的全部资源。\r\n由于释放了资源，这样能使其它被阻塞的进程获得资源继续运行。\r\n在经过一系列简化后若能消去图中的所有的边，使所有进程结点都孤立，则称该图是可完全简化的，反之是不可完全简化的。\r\nS 状态为死锁状态的充分条件是当且仅当 S\r\n状态的资源分配图是不可完全简化的\r\n\r\n死锁的解除：\r\n\r\n剥夺资源：从其他进程剥夺足够数量的资源给死锁进程以解除死锁状态。\r\n撤销进程：最简单的是让全部进程都死掉；温和一点的是按照某种顺序逐个撤销进程，直至有足够的资源可用，使死锁状态消除为止。\r\n死锁避免的处理代码\r\n使用银行家算法，C++\r\n#include &lt;bits/stdc++.h&gt;using namespace std;// 银行家算法// max矩阵，各进程最大资源需求// allocation矩阵，各进程已分配资源// need矩阵，各进程剩余的需求// available矩阵，系统当前可用资源// 安全序列开始逐个查找哪个进程能够被分配，也就是进程i的每个资源j，有need[i][j] &lt; available[j]，才能被分配//      进程执行顺序需满足：每个进程执行时，其 Need ≤ 当前 available，且执行后释放 Allocation 资源，增加 available。// 资源分配过程就是 保证 请求的 &lt;= need 不超最大需求， 请求 ≤ Available，当前有足够资源// 安全满足后， avilable 减少请求量，allocation 增加请求量，need - allocation（需求-新分配的）// 分配后进行安全检查，有安全序列才可以分配const int PROCESS_COUNT = 5;  // 进程数const int RESOURCE_TYPE = 3;  // 资源类型数vector&lt;vector&lt;int&gt;&gt; Max = &#123;        &#123;7, 5, 3&#125;,  // P0        &#123;3, 2, 2&#125;,  // P1        &#123;9, 0, 2&#125;,  // P2        &#123;2, 2, 2&#125;,  // P3        &#123;4, 3, 3&#125;   // P4&#125;;vector&lt;vector&lt;int&gt;&gt; allocation = &#123;        &#123;0, 1, 0&#125;,  // P0已分配资源        &#123;2, 0, 0&#125;,  // P1        &#123;3, 0, 2&#125;,  // P2        &#123;2, 1, 1&#125;,  // P3        &#123;0, 0, 2&#125;   // P4&#125;;vector&lt;int&gt; available = &#123;3, 3, 2&#125;;  // 初始可用资源,p0// 计算need矩阵（max-allocation）vector&lt;vector&lt;int&gt;&gt; need(5, vector&lt;int&gt;(3));void calculate_need() &#123;    for (int i = 0; i &lt; PROCESS_COUNT; i++) &#123;        for (int j = 0; j &lt; RESOURCE_TYPE; j++) &#123;            need[i][j] = Max[i][j] - allocation[i][j];        &#125;    &#125;&#125;// 回溯法寻找所有安全序列vector&lt;vector&lt;int&gt;&gt; safe_sequences;void Safe_Check(vector&lt;int&gt; work, vector&lt;bool&gt; finish, vector&lt;int&gt; path) &#123;    // 完整安全序列被找到    if (path.size() == PROCESS_COUNT) &#123;        safe_sequences.push_back(path);    &#125;    for (int i = 0; i &lt; PROCESS_COUNT; i++) &#123;        // 判断进程i的需求j能否被成功分配，小于等于当前可用资源 work        bool can_execute = true;        for (int j = 0; j &lt; RESOURCE_TYPE; j++) &#123;            if (need[i][j] &gt; work[j]) &#123;                can_execute = false;                break;            &#125;        &#125;        if (!finish[i] &amp;&amp; can_execute) &#123;  // 有进程且需求可满足            // 模拟分配资源并回收（Work += Allocation[i]）            vector&lt;int&gt; new_work = work;            // 完成后释放的是全部已分配资源（Allocation[i]）            for (int j = 0; j &lt; RESOURCE_TYPE; j++) &#123;                new_work[j] += allocation[i][j];            &#125;            // 标记进程完成            vector&lt;bool&gt; new_finish = finish;            new_finish[i] = true;            vector&lt;int&gt; new_path = path;  // 复制旧路径            new_path.push_back(i);       // 添加当前进程i            Safe_Check(new_work, new_finish, new_path);  // 递归搜索        &#125;    &#125;&#125;// 安全状态检测pair&lt;bool, vector&lt;vector&lt;int&gt;&gt;&gt; check_safety() &#123;    safe_sequences.clear();    // 可用的资源分配给    vector&lt;int&gt; work = available;    vector&lt;bool&gt; finish(PROCESS_COUNT, false);    Safe_Check(work, finish, &#123;&#125;);    return &#123;!safe_sequences.empty(), safe_sequences&#125;;&#125;// 资源请求函数bool handle_request(int pid, vector&lt;int&gt; request) &#123;    calculate_need();   // 更新need矩阵    // 步骤1：检查请求是否超过最大需求    for(int j = 0; j &lt; RESOURCE_TYPE; j++)&#123;        if(request[j] &gt; need[pid][j])&#123;            cout &lt;&lt; &quot;错误：P&quot; &lt;&lt; pid &lt;&lt; &quot;请求超过最大需求，出现死锁(&quot;                 &lt;&lt; need[pid][0] &lt;&lt; &quot;,&quot; &lt;&lt; need[pid][1] &lt;&lt; &quot;,&quot; &lt;&lt; need[pid][2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;            return false;        &#125;    &#125;    // 步骤2：检查可用资源是否足够    for (int j = 0; j &lt; RESOURCE_TYPE; j++) &#123;        if(request[j] &gt; available[j])&#123;            cout &lt;&lt; &quot;请求被拒绝：可用资源不足（当前&quot;                 &lt;&lt; available[0] &lt;&lt; &quot;,&quot; &lt;&lt; available[1] &lt;&lt; &quot;,&quot; &lt;&lt; available[2] &lt;&lt; &quot;）&quot; &lt;&lt; endl;            return false;        &#125;    &#125;    // 模拟分配    // 保存原始状态    vector&lt;int&gt; original_available = available;    vector&lt;vector&lt;int&gt;&gt; original_allocation = allocation;    vector&lt;vector&lt;int&gt;&gt; original_need = need;    // 分配临时变量    vector&lt;int&gt; new_available = available;    vector&lt;vector&lt;int&gt;&gt; new_allocation = allocation;    vector&lt;vector&lt;int&gt;&gt; new_need = need;    //分配    for (int j = 0; j &lt; RESOURCE_TYPE; j++) &#123;        new_available[j] -= request[j];     // 系统可用的资源 - 请求量        new_allocation[pid][j] += request[j];   // 该进程已分配的资源 + 请求量        new_need[pid][j] -= request[j];    // 需求资源 - 请求量    &#125;    // 检查新状态安全性    available = new_available;    allocation = new_allocation;    need = new_need;    auto [is_safe, seqs] = check_safety();    // 恢复全局变量    available = original_available;    allocation = original_allocation;    need = original_need;    if (is_safe) &#123;        // 应用分配        available = new_available;        allocation = new_allocation;        need = new_need;        cout &lt;&lt; &quot;请求批准，系统进入安全状态&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;安全序列：&quot;;        for (auto seq : seqs) &#123;            for (int p : seq) cout &lt;&lt; &quot;P&quot; &lt;&lt; p+1 &lt;&lt; &quot; &quot;;            cout &lt;&lt; &quot;| &quot;;        &#125;        cout &lt;&lt; endl;        return true;    &#125; else &#123;        cout &lt;&lt; &quot;请求拒绝：分配后系统不安全&quot; &lt;&lt; endl;        return false;    &#125;&#125;void algorithm_explanation() &#123;    cout &lt;&lt; &quot;\\n=== 银行家算法核心过程可视化 ===&quot; &lt;&lt; endl;    // T0时刻状态    cout &lt;&lt; &quot;\\n1. T0时刻初始状态：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;可用资源 Available: &quot; &lt;&lt; available[0] &lt;&lt; &quot;,&quot; &lt;&lt; available[1] &lt;&lt; &quot;,&quot; &lt;&lt; available[2] &lt;&lt; endl;    cout &lt;&lt; &quot;分配矩阵 Allocation:&quot; &lt;&lt; endl;    for (int i=0; i&lt;5; i++)        cout &lt;&lt; &quot;P&quot; &lt;&lt; i+1 &lt;&lt; &quot;: &quot; &lt;&lt; allocation[i][0] &lt;&lt; &quot;,&quot; &lt;&lt; allocation[i][1] &lt;&lt; &quot;,&quot; &lt;&lt; allocation[i][2] &lt;&lt; endl;    calculate_need();    cout &lt;&lt; &quot;需求矩阵 Need:&quot; &lt;&lt; endl;    for (int i=0; i&lt;5; i++)        cout &lt;&lt; &quot;P&quot; &lt;&lt; i+1 &lt;&lt; &quot;: &quot; &lt;&lt; need[i][0] &lt;&lt; &quot;,&quot; &lt;&lt; need[i][1] &lt;&lt; &quot;,&quot; &lt;&lt; need[i][2] &lt;&lt; endl;    // 安全检查过程    cout &lt;&lt; &quot;\\n2. 安全检查逻辑：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;寻找满足Need[i] &lt;= Work的进程（初始Work=Available）&quot; &lt;&lt; endl;    auto [is_safe, seqs] = check_safety();    cout &lt;&lt; &quot;找到&quot; &lt;&lt; seqs.size() &lt;&lt; &quot;个安全序列，例如：&quot;;    for (int p : seqs[0]) cout &lt;&lt; &quot;P&quot; &lt;&lt; p+1 &lt;&lt; &quot;-&gt;&quot;;    cout &lt;&lt; &quot;\\b （释放资源后Work更新）&quot; &lt;&lt; endl;    // P1请求处理示例    cout &lt;&lt; &quot;\\n3. P1请求(1,0,2)处理流程：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;请求前Available: &quot; &lt;&lt; available[0] &lt;&lt; &quot;,&quot; &lt;&lt; available[1] &lt;&lt; &quot;,&quot; &lt;&lt; available[2] &lt;&lt; endl;    cout &lt;&lt; &quot;Need[P1] before: &quot; &lt;&lt; need[0][0] &lt;&lt; &quot;,&quot; &lt;&lt; need[0][1] &lt;&lt; &quot;,&quot; &lt;&lt; need[0][2] &lt;&lt; endl;    handle_request(0, &#123;1,0,2&#125;);    cout &lt;&lt; &quot;请求后Available: &quot; &lt;&lt; available[0] &lt;&lt; &quot;,&quot; &lt;&lt; available[1] &lt;&lt; &quot;,&quot; &lt;&lt; available[2] &lt;&lt; endl;    cout &lt;&lt; &quot;Allocation[P1] after: &quot; &lt;&lt; allocation[0][0] &lt;&lt; &quot;,&quot; &lt;&lt; allocation[0][1] &lt;&lt; &quot;,&quot; &lt;&lt; allocation[0][2] &lt;&lt; endl;    cout &lt;&lt; &quot;Need[P1] after: &quot; &lt;&lt; need[0][0] &lt;&lt; &quot;,&quot; &lt;&lt; need[0][1] &lt;&lt; &quot;,&quot; &lt;&lt; need[0][2] &lt;&lt; endl;&#125;int main() &#123;    calculate_need();  // 初始化need矩阵    // T0时刻安全检查    cout &lt;&lt; &quot;=== T0时刻系统安全检查 ===&quot; &lt;&lt; endl;    auto [initial_safe, initial_seqs] = check_safety();    if (initial_safe) &#123;        cout &lt;&lt; &quot;系统处于安全状态，安全序列：&quot;;        for (auto seq : initial_seqs) &#123;            for (int p : seq) cout &lt;&lt; &quot;P&quot; &lt;&lt; p+1 &lt;&lt; &quot;-&gt;&quot;;        &#125;        cout &lt;&lt; &quot;\\b （共&quot; &lt;&lt; initial_seqs.size() &lt;&lt; &quot;种）&quot; &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;系统不安全&quot; &lt;&lt; endl;    &#125;    // 处理P1请求    cout &lt;&lt; &quot;\\n=== 处理P1的资源请求(1,0,2) ===&quot; &lt;&lt; endl;    handle_request(0, &#123;1,0,2&#125;);    algorithm_explanation();    return 0;&#125;\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之处理机的调度","url":"/posts/58087.html","content":"处理机调度的层次和调度算法的目标\r\n在多道程序环境下，进程数目往往多于处理机数目。\r\n这就要求系统能够按某种算法，动态的把处理机分配给就绪队列中的一个进程，使之执行\r\n分配处理机的任务是由处理机调度程序完成的\r\n处理机调度的层次\r\n高级调度：\r\n用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后将新创建的进程排在就绪队列上，准备执行\r\n又称长程调度或作业调度。它的调度对象为作业，只适用于多道批处理系统中，不适合实时和分时系统。\r\n低级调度：\r\n用来决定就绪队列中的哪个进程应获得处理机，然后再由分派程序把处理机分配给该进程。为最基本的一种调度\r\n又称进程调度或短程调度。它的调度对象为进程或内核级线程，适用于所有类型的操作系统。\r\n中级调度：\r\n又称内存调度。主要目的是为了提高内存利用率和系统吞吐量。\r\n使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。\r\n进程调度可采用下述两种调度方式：\r\n\r\n非抢占方式（Non-preemptive Mode）\r\n一旦把处理机分配给某进程后，便让该进程一直执行，直至该进程完成或发生某事件而被阻塞时，才把处理机分配给其他进程\r\n抢占方式（Preemptive Mode）\r\n允许调度程序根据某种原则，去暂停某个正在执行的进程，将处理机重新分配给另一进程。\r\n\r\n队列调度模型\r\n仅有进程调度的调度队列模型\r\n在分时系统中，通常仅设置进程调度。系统可以把处于就绪状态的进程组织成栈、树或一个无序链表，形式取决于OS类型和所采用的调度算法。\r\n\r\n\r\nimage-20250506101611187\r\n\r\n具有高级和低级调度的调度队列模型\r\n\r\n\r\nimage-20250506101650937\r\n\r\n同时具有三级调度的调度队列模型\r\n当在OS中引入中级调度后，可以把进程的就绪状态分为内存就绪和外存就绪。也可以把阻塞状态分为内存阻塞和外存阻塞两种状态。\r\n\r\n\r\nimage-20250506101806356\r\n\r\n处理机调度算法的目标\r\n共同目标：\r\n\r\n资源利用率\r\n\r\n\r\nimage-20250506101946057\r\n\r\n公平性\r\n公平性是指应使诸进程都获得合理的CPU\r\n时间，不会发生进程饥饿现象。公平性是相对的。\r\n平衡性\r\n应尽可能保持系统资源使用的平衡性。\r\n策略强制执行\r\n包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。\r\n\r\n批处理系统的目标：\r\n平均周转时间短：所谓周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔\r\n带权周转时间：作业的周转时间 T 与系统为它提供服务的时间 Ts 之比\r\n系统吞吐量高：吞吐量是指在单位时间内系统所完成的作业数。如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。\r\n处理机利用率高：如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行\r\n分时系统的目标：\r\n响应时间快。所谓响应时间，是从用户通过键盘提交一个请求开始，直至屏幕上显示出处理结果为止的一段时间间隔。\r\n均衡性。指系统响应时间的快慢应与用户所请求服务的复杂性相适应。\r\n实时系统的目标\r\n截止时间的保证。是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。\r\n可预测性。 例如在多媒体系统中，可实现第 i 帧的播放和第 i+1\r\n帧的读取并行处理，进而提高其实时性。\r\n作业和作业调度\r\n作业控制块 JCB\r\n是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。\r\n每当一个作业进入系统时，便由“作业注册”程序为该作业建立一个\r\nJCB，再根据作业类型将它插入相应的作业后备队列中等待调度。\r\n在每次执行作业调度时，都须作出两个决定：\r\n\r\n接纳多少作业\r\n接纳哪些作业\r\n\r\n作业运行的三个阶段和三种状态\r\n\r\n收容阶段。\r\n把作业输入到硬盘上，再为作业建立 JCB\r\n并把它放入作业后备队列中。此时作业状态为“后备状态”。\r\n运行阶段。\r\n此时作业状态为“运行状态”。\r\n完成阶段。\r\n此时作业状态为“完成状态”。系统中的“终止作业”程序将会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。\r\n\r\n作业调度算法\r\n先来先服务调度算法 FCFS。\r\n当在作业调度中采用FCFS算法时，每次调度都是从后备作业队列中，选择一个或多个最先进入该队列的作业\r\n优先考虑在系统中最先进入（等待时间最长）的作业。\r\n比较有利于长作业（进程），而不利于短作业（进程）。有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业（进程）\r\n短作业（进程）优先调度算法 SJF\r\nSJF算法是以作业的长短来计算优先级的，作业的长短是以作业所要求的运行时间来衡量的。\r\n从后备队列中选择一个或若干个估计运行时间最短的作业\r\n优点是有效降低作业的平均等待时间，提高系统吞吐量。\r\n缺点是可能使长作业等待时间过长，出现饥饿现象。\r\n高优先权优先调度算法：\r\n优先权调度算法的类型\r\n为照顾紧迫性作业，使之在进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法\r\n分为：\r\n\r\n非抢占式优先权算法\r\n抢占式优先权调度算法\r\n\r\n静态优先权：在创建进程时确定的，在进程的整个运行期间保持不变\r\n动态优先权：在创建进程时所赋予的优先权可以随进程的推进或随其等待时间的增加而改变。\r\n高相应比优先调度算法\r\n高响应比优先调度算法是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长。\r\n为每个作业引入一个动态优先级，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加\r\n\r\n\r\nimage-20250506102556129\r\n\r\n于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先权又相当于响应比\r\nRP。\r\n\r\n\r\nimage-20250506102707862\r\n\r\n例子：\r\n\r\n\r\nimage-20250506104042611\r\n\r\n进程调度\r\n进程调度的任务：\r\n\r\n保存处理机的现场信息。\r\n按某种算法选取进程。\r\n把处理器分配给进程。\r\n\r\n进程调度可采用下述两种调度方式：\r\n\r\n非抢占式\r\n抢占式\r\n抢占的原则：\r\n\r\n优先权原则：优先权高的可以抢占优先级低的进程的处理机。\r\n短作业（进程）优先原则：短作业（进程）可以抢占长作业（进程）的处理机。\r\n时间片原则：各进程按时间片运行，一个时间片用完时，停止该进程执行重新进行调度。\r\n\r\n\r\n轮转调度算法：RR\r\n系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给首进程，并令其执行一个时间片。\r\n进程切换时机：\r\n\r\n若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，并为新进程启动一个新的时间片。\r\n在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。\r\n\r\n例题：\r\n​ \r\n过程：\r\n\r\n(q = 1) 时的调度过程\r\n\r\n0 时刻：进程 A 到达，进入就绪队列，此时就绪队列只有\r\nA，A 开始运行。运行 1 个时间片后（到 1 时刻），A 还需服务时间 (4 - 1=3)\r\n，A 被暂停，放入就绪队列队尾 。\r\n1 时刻：进程 B 到达，加入就绪队列，此时队首是 B，B\r\n开始运行 1 个时间片，B 还需服务时间 (3 - 1 = 2) ，B\r\n被暂停，放入队尾。然后队首是 A，A 运行 1 个时间片，如此循环。\r\n随着时间推进，不断按照每个进程运行 1\r\n个时间片后放入队尾的规则调度，直到所有进程完成。比如 D 进程在 3\r\n时刻到达，加入队尾，按序调度运行。\r\n计算周转时间：周转时间 = 完成时间 - 到达时间，例如 A 的周转时间 (=\r\n12 - 0 = 12) 。\r\n计算带权周转时间：带权周转时间 = 周转时间 / 服务时间，A\r\n的带权周转时间 (=12 / 4 = 3) 。\r\n\r\n(q = 4) 时的调度过程\r\n\r\n原理类似，但时间片变长。0 时刻 A 到达运行，运行 4 个时间片到 4\r\n时刻，A 服务时间 4 刚好完成，离开就绪队列 。\r\n之后按序调度其他进程，每个进程运行 4\r\n个时间片，若未完成则放入队尾等待下次调度。例如 B 进程 1 时刻到达，在 A\r\n完成后开始运行，运行 4 个时间片到 7 时刻，B 还需 (3 - 4=-1) （已完成）\r\n。\r\n同样计算周转时间和带权周转时间，如 A 的周转时间 (= 4 - 0 = 4)\r\n，带权周转时间 (= 4 / 4 = 1) 。\r\n\r\n\r\n优先级调度算法\r\n类型：\r\n\r\n非抢占式优先级调度算法。\r\n抢占式优先级调度算法，实时性高\r\n\r\n多级反馈队列调度算法：\r\n\r\n调度机制：\r\n\r\n设置多个就绪队列：\r\n每个队列赋予不同的优先级，第一个最高，依次逐渐降低；时间片设置也不同，优先级越高，时间片越小。\r\n每个队列都采用FCFS算法：\r\n当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度，依次\r\n按队列优先级调度：\r\n调度程序首先调度最高优先级队列中的诸进程运行，仅当第 1～(i-1)\r\n所有队列均空时，才会调度第 i 队列中的进程运行。\r\n如果处理机正在第i队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程\r\n\r\n\r\n基于公平原则的调度算法\r\n保证调度算法:\r\n针对进程而言，处理机时间分配的公平性。\r\n公平分享调度算法:\r\n针对用户而言，使所有用户能获得相同的处理机时间，或要求的时间比例。\r\n实时调度\r\n实时系统中包含两种任务\r\n硬实时任务指必须满足最后期限的限制，否则会给系统带来不可接受的破坏或者致命错误。\r\n软实时任务也有一个与之关联的最后期限，并希望能满足这个期限的要求，但这并不是强制的，即使超过了最后期限，调度和完成这个任务仍然是有意义的。\r\n实现实时调度的基本条件\r\n提供必要的信息：\r\n\r\n就绪时间\r\n开始截止事件，完成截止时间\r\n处理时间\r\n资源要求\r\n优先级\r\n\r\n系统处理能力强\r\n\r\n\r\nimage-20250506111055024\r\n\r\n采用抢占式调度机制\r\n具有快速切换机制\r\n实时调度算法的分类：\r\n根据实时任务性质的不同，分为硬实时调度算法和软实时调度算法；\r\n按调度方式的不同，分为非抢占调度算法和抢占调度算法；\r\n根据调度程序调度时间的不同，分为静态调度算法和动态调度算法。\r\n多处理机环境下，可分为集中式调度和分布式调度两种算法。\r\n非抢占调度算法\r\n该算法较简单，用于一些小型实时系统或要求不太严格的实时系统中。又可分为两种\r\n\r\n非抢占式轮转调度算法：\r\n要求不高的实时控制系统\r\n非抢占式优先调度算法：\r\n有一定要求的实时控制系统\r\n\r\n\r\n\r\nimage-20250506111216521\r\n\r\n抢占调度算法：\r\n用于要求较严格的实时系统中，（t约为数十ms），采用抢占式优先权调度算法。根据抢占发生时间的不同可分为两种：\r\n基于时钟的抢占式优先权调度算法：\r\n\r\n在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务。\r\n\r\n立即抢占的优先权调度算法：一旦出现外部中断，只要当前任务未处于临界区，就立即抢占处理机。\r\n\r\n\r\nimage-20250506142129979\r\n\r\n最早截止时间EDF算法：\r\n根据任务的截止时间确定任务的优先级，截止时间越早，优先级越高，最早截止时间的排在队首\r\n非抢占式调度方式用于非周期实时任务：\r\n\r\n在非抢占式 EDF\r\n算法中，一旦一个任务开始执行，它就会一直运行直到完成，不会被其他任务中途抢占。\r\n调度器会在每个任务到达时，根据其截止时间来分配优先级，截止时间越早的任务优先级越高。\r\n在任务执行过程中，即使有更高优先级的任务到达，当前正在执行的任务也不会被打断，而是继续执行直到结束。\r\n\r\n\r\n\r\nimage-20250506142736352\r\n\r\n抢占式调度方式用于周期实时任务：\r\n有两个周期任务A和B，周期时间分别为20ms和50ms，每个周期的处理时间分别为10ms和25ms。\r\n首先判断系统的处理能力：10/20 + 25/50 = 1 —–可行\r\n\r\n\r\nimage-20250506142749061\r\n\r\n最低松弛度优先 LLF 算法\r\n任务紧急程度愈高即松弛程度愈低，赋予该任务的优先级就愈高，以使之优先执行。\r\n该算法主要用于可抢占调度方式。\r\n松弛度 = 完成截止时间 - 还需要的执行时间 -\r\n当前时间。\r\n在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在队列最前面。松弛度是动态变化的，所以优先级也是动态的\r\n任务的抢占时机：当某后到任务的松弛度为0时，即获得最高优先级，立即抢占\r\nCPU。其它时间就算发现后到任务的松弛度比之正在执行任务的松弛度要低但不为0，也不进行抢占。\r\n例子\r\n\r\n\r\nimage-20250506142813148\r\n\r\n优先级倒置\r\n“优先级倒置”现象：高优先级进程被低优先级进程延迟或阻塞。\r\n优先级倒置的解决方法。\r\n1）当进程进入临界区后，CPU就不能被剥夺。\r\n2）优先级继承\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之进程同步","url":"/posts/17351.html","content":"进程同步\r\n进程同步机制\r\n进程同步机制：利用他们保证程序执行的可再现性\r\n进程同步的基本概念：某进程未获得合作进程发来的消息之前应该进程等待，消息到来之后方可继续合作关系\r\n进程间两种形式的制约关系\r\n\r\n间接相互制约关系 — 源于资源共享\r\n直接相互制约关系 — 源于进程合作\r\n\r\n临界资源：互斥访问\r\n进程间采取互斥方式，实现对资源的共享\r\n生产者消费者问题：\r\n生产者进程和消费者进程都以异步方式运行，但它们之间必须保持同步。\r\n把一次仅允许一个进程访问的资源叫做临界资源\r\n临界区\r\n每个进程中访问临界资源的那段代码\r\n对欲访问的临界资源进行检查\r\n\r\n若此刻未被访问，设正在访问的标志 ……进入区\r\n访问临界资源 ……临界区\r\n将正在访问的标志恢复为未被访问的标志 ……退出区\r\n其余部分 ……剩余区\r\n\r\n进程互斥：两进程不能同时进入访问同一临界资源的临界区\r\n同步机制应遵循的规则\r\n\r\n空闲让进\r\n忙则等待\r\n有限等待\r\n让权等待\r\n\r\n信号量机制\r\n整型信号量\r\n定义：整型量，除初始化外，仅能通过两个原子操作来访问\r\n\r\nP操作 wait(S):\r\n​ While (S&lt;=0) do no-op;\r\n​ S–;\r\nV操作 signal(S):\r\n​ S++;\r\nP、V操作是原子操作，不可中断。\r\n\r\n\r\n\r\nimage-20250505180943586\r\n\r\n记录型信号量\r\n引入整型变量value(代表资源数目)、进程链表List (链接所有等待进程)\r\n用S.value的初值表示系统中某种资源的数目。\r\n记录型数据结构：\r\ntypedef  struct&#123;\t              int value;\t              struct process_control_block * list;\t       &#125; semaphore;\r\n对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此S.value–，表示资源数减1，当S.value＜0时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞，主动放弃处理机，并插入该类资源的等待队列S.L中。\r\n对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行\r\nS.value++，表示该资源数加1，若加1后仍是\r\nS.value≤0，表示依然有进程在等待该类资源，因此应调用wakeup原语幻想等待队列中的第一个进程。\r\n信号量&gt;0，代表可用资源的数量\r\n信号量&lt;0，代表由于申请信号量，代表的资源而阻塞的进程数量\r\n遵循了“让权等待”原则，不会出现“忙等”现象\r\n\r\n\r\nimage-20250505181419736\r\n\r\nAND型信号量\r\nADN型信号量主要针对的是一个进程需要获取两个或更多的共享资源执行任务时的问题。\r\n基本思想：对若干个临界资源的分配采取原子操作的方式\r\n\r\n要么把它所请求的资源全部分配到进程，要么一个也不分配。为此，在wait中加入了一个“AND”条件，故称为AND同步，或称为同时wait操作，即\r\nSwait\r\n\r\n\r\n\r\nimage-20250505181219188\r\n\r\n信号量集\r\n信号量集主要针对的是执行进程时一次需要N个单位的某类临界资源的问题\r\n对AND型信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源量需求，在一次P、V原语操作中完成申请或释放。\r\n进程对信号量Si的测试值不再是1，而是该资源的分配下限ti，即要求Si&gt;=ti。一旦允许分配，进程对该资源的需求值为di，即表示资源占用量，进行Si:=Si-di的操作，对应的Swait和Ssignal格式为：\r\n\r\nSwait(S1,t1,d1,...,Sn,tn,dn);\r\nSsignal(S1,d1,...,Sn,dn);\r\n\r\nSwait(S,d,d)：此时信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数量少于d时，不予分配。\r\nSwait(S,1,1)：此时信号量集已蜕化为一般的记录型信号量（S&gt;1时）或互斥信号量（S=1）。\r\nSwait(S,1,0)：当S&gt;=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区，相当于一个可控开关。\r\n信号量的应用\r\n\r\n\r\nimage-20250505181502608\r\n\r\n实现进程互斥：\r\n设置mutex为互斥信号量，初值为1，取值范围为（-1,0，1）。\r\n\r\n当mutex = 1 时，表示两个进程皆未进入互斥的临界区\r\n当mutex = 0\r\n时，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列\r\n当mutex = -1\r\n时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。\r\n\r\nwait(mutex)和signal(mutex)操作必须成对出现，缺少P（mutex）将会导致系统混乱，不能保证对临界资源的访问，缺少V（mutex）将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程永远不能被唤醒。\r\n\r\n信号量机制实现前驱关系\r\n每一对前驱关系都是一个进程同步问题\r\n\r\n要为每一对前驱关系各设置一个同步变量\r\n在“前操作”之后对相应的同步变量执行V操作\r\n在“后操作”之前对相应的同步变量执行P操作\r\n\r\n例如：\r\n实现S1执行后执行S2\r\n进程P1：S1； signal（S）； (S为P1,P2共用的信号量)\r\n进行P2：wait(S); S2；\r\n信号量机制实现同步关系：\r\np1，p2两进程因合作完成一项任务而共用一个变量x。进程p2将处理结果送入x；进程p1将x的结果打印。\r\n\r\n\r\nimage-20250505181649390\r\n\r\n经典的进程同步问题\r\n生产者消费者问题\r\n相互合作关系的一种抽象\r\n问题描述：\r\n一组生产者进程和一组消费者进程共享一个初始为空、大小为 n\r\n的缓冲区，只有缓冲区没满时，生产者才把消息放入缓冲区，否则必须等待；\r\n只有缓冲区不空时，消费者才能从中读取消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。\r\n\r\n\r\nimage-20250505181909726\r\n\r\n可利用记录型信号量解决生产者—消费者问题：\r\n\r\n可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用，初值为1；\r\n信号量 full 用于记录当前缓冲池中的“满”缓冲区数，初值为 0；\r\n信号量 empty 用于记录当前缓冲池中“空”的缓冲区数，初值为 n；\r\n\r\n描述如下：\r\n\r\n\r\nimage-20250505181941754\r\n\r\n加锁信号量的顺序不能打乱，否则容易出现死锁，也就是P(mutex)需要跟在P(full);前面\r\n利用AND信号量解决生产者—消费者问题：\r\n使用Swait(empty,mutex)代替wait(empty)，wait(mutex)，Ssignal(empty,mutex)代替signal(empty)，signal(mutex)\r\nfull和mutex也是一样\r\n\r\n\r\nimage-20250505182155964\r\n\r\n\r\n\r\nimage-20250505182159102\r\n\r\n例题：\r\n描述：\r\n桌子上有一个盘子，每次只能向其中放入一个水果。\r\n爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专吃盘子中的橘子，女儿专等吃盘子中的苹果。\r\n只有盘子为空时，爸爸或妈妈才可以向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。\r\n分析：\r\n爸爸和妈妈是互斥关系，爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行。\r\n信号量 plate 表示互斥信号量，用于确定是否可以往盘子中放水果，初值为 1\r\n表示允许放入一个；\r\n信号量 apple 表示盘中是否还有苹果，初值为 0表示没有不许取；orange\r\n表示盘中是否有橘子，初值同样为 0，orange=1 表示盘子中由橘子允许取\r\n\r\n\r\nimage-20250505182232376\r\n\r\n哲学家进餐问题\r\n问题描述：\r\n一张圆桌上坐着5名哲学家，每两名哲学家之间的桌子上摆着一根筷子，两根筷子之间是一碗米饭。\r\n哲学家倾注毕生精力于思考和进餐，哲学家思考时不影响其他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子——一根一根地拿起。\r\n若筷子已在他人手上，则需要等待。饥饿地哲学家只有同时拿到了两根筷子才能开始进餐，进餐完毕，放下筷子继续思考\r\n分析：\r\n5 名哲学家与左右邻座对其中间的筷子的访问时互斥关系。\r\n显而易见，5 个哲学家对应5\r\n个进程，问题解决的关键就是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象\r\n解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。\r\n信号量设置：互斥信号量数组 chopstick[5]={1,1,1,1,1}，用于对 5\r\n个筷子的互斥访问；哲学家编号顺序：0~4，哲学家 I 左边筷子的编号为\r\ni，哲学家右边筷子的编号为(i+1)%5。\r\n使用记录型信号量：\r\n\r\n\r\nimage-20250505182332395\r\n\r\n使用AND信号量\r\n\r\n\r\nimage-20250505182358757\r\n\r\nbasicSwait(chopstick[(i+1) % 5], chopstick[i]);EatSginal(chopstick[(i+1) % 5], chopstick[i]);\r\n读者写者问题\r\n问题描述与分析\r\n一个数据文件或记录可被多个进程共享。\r\n只要求读文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，但不允许一个Writer进程和其他Reader进程或Writer进程同时访问共享对象\r\n“读者——写者问题”是保证一个 Writer\r\n进程必须与其他进程互斥地访问共享对象的同步问题。\r\n\r\n\r\nimage-20250505182701688\r\n\r\n互斥信号量wmutex: 实现 Reader 与 Writer\r\n进程间在读或写时的互斥\r\n整型变量Readcount：表示正在读的进程数目;\r\n以Readcount为例：\r\n由于只要有一个 Reader 进程在读，便不允许 Writer 进程写。\r\n∴仅当Readcount=0，即无 Reader 进程在读时，Reader\r\n才需要执行Wait(wmutex)操作。若Wait(wmutex)操作成功，Reader\r\n进程便可去读，相应地，做Readcount+1操作。\r\n使用记录型信号量解决读者写者问题\r\n\r\n\r\nimage-20250505182748649\r\n\r\n\r\n\r\nimage-20250505182808622\r\n\r\n使用信号量集机制解决读者写者问题\r\n\r\n\r\nimage-20250505182825856\r\n\r\nSwait(mx, 1, 1; L, RN,\r\n0)语句表示仅当既无writer进程在写(mx=1)，又无reader进程在读(L=RN)，writer进程才能进入临界区写。\r\nSwait(mx, 1,\r\n0)语句起着开关的作用。只要无writer进程进入写，mx=1，reader进程就都可以进入读。但只要一旦有writer进程进入写时，mx=0，则任何reader进程就都无法进入读。\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之操作系统引论","url":"/posts/8682.html","content":"操作系统的目标及作用\r\n操作系统OS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口\r\n操作系统定义\r\n操作系统（Operating\r\nSystem，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。\r\nOS\r\n\r\n直接控制和管理计算机硬件，软件资源\r\n合理的对各个作业进行调度\r\n以方便用户使用的程序集合\r\n\r\n操作系统的目标\r\n\r\n方便性：\r\n配置了OS的计算机硬件，系统可以直接使用编译命令将用户采用该机语言书写的程序翻译成机器代码，或者直接通过OS所提供的各种命令操纵计算机，方便用户\r\n有效性：\r\n第一层含义：提高系统资源的利用率\r\n另一层：提高系统的吞吐量\r\n可扩充性：\r\n与OS结构有关\r\n开放性：\r\n系统能遵循世界标准规范，尤其是遵循开放系统互联·OSI标准\r\n\r\n操作系统的作用：\r\n\r\nOS作为用户与计算机硬件系统之间的接口\r\n\r\n\r\n\r\nimage-20250506144546633\r\n\r\n\r\nOS作为计算机系统资源的管理者\r\n\r\n\r\n处理机管理\r\n存储器管理\r\n文件管理\r\n设备管理\r\n\r\n\r\n\r\nimage-20250506144609282\r\n\r\n\r\nOS实现了对计算机资源的抽象\r\n\r\n\r\n为了方便用户使用I/O设备，人们在裸机上覆盖一层I/O设备管理软件，隐藏了I/O的具体细节\r\nI/O设备管理软件实现了对计算机硬件操作的第一个层次的抽象\r\nOS是铺设在计算机硬件上的多层软件的集合，他们不仅增强了系统的功能，还隐藏了对硬件操作的具体细节\r\n\r\n\r\n推动OS发展的主要动力\r\n\r\n\r\n不断提高计算机资源利用率\r\n方便用户\r\n器件的不断更新\r\n计算机体系结构的不断发展\r\n不断提出新的应用需求\r\n\r\n操作系统的发展过程\r\n无OS：\r\n人工操作方式：\r\n用户独占全机\r\nCPU等待人工操作\r\n脱机输入输出方式：\r\n\r\n\r\nimg\r\n\r\n单道批处理系统：\r\n设计目标：提高系统资源的使用效率；提高作业吞吐量\r\n\r\n减少机器的空闲等待时间：保持系统的连续运行，在处理完一个作业后，紧接着处理下一个作业\r\n仍不能充分的利用系统资源\r\n\r\n原理：\r\n要求用户使用系统提供的作业控制语言（JCL）来描述自己对作业运行的控制意图，并将这些控制信息连同自己的程序和数据一起作为一个作业提交给操作员。\r\n操作员启动有关程序将一批作业输入到计算机外存，由OS去控制、调度各作业的运行并输出结果。\r\n由于作业进入系统后用户不再干预，从而提高了效率。\r\n\r\n\r\nimage-20250506144955925\r\n\r\n批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。\r\n在内存中只保持一道作业的批处理系统。\r\n\r\n\r\n单道程序运行情况\r\n\r\n内存中始终只保持一道作业，称为单道批处理系统\r\n多道批处理系统\r\n多道程序设计的基本理念\r\n多道程序设计：多个作业存放在主存中，使它们同时处于运行状态，这些作业共享处理机时间和外围设备等资源\r\n\r\n\r\nimage-20250506145025667\r\n\r\n多道批处理系统的优缺点：\r\n资源利用率高\r\n系统吞吐量大\r\n平均周转时间长\r\n无交互能力\r\n需要解决的问题：\r\n\r\n处理机管理问题。\r\n内存管理问题。\r\nI/O设备管理问题。\r\n文件管理问题。\r\n作业管理问题。\r\n用户与系统的接口问题\r\n\r\n分时系统：\r\n分时系统是为了满足 用户需求所形成的一种新型OS\r\n在操作系统中加入了分时技术：即将处理机的运行时间分为时间片，将时间片轮流分配给各联机作业使用。\r\n目标：对用户的请求及时响应；尽量提高系统资源的利用率\r\n\r\n\r\n\r\n表现\r\n(1) 人—机交互。 (2) 共享主机。 (3) 便于用户上机。\r\n\r\n\r\n\r\n\r\n特征\r\n1.多路性 2.独立性 3.及时性 4.交互性\r\n\r\n\r\n\r\n实时系统：\r\n所谓“实时”，是表示“及时”，而实时系统(RealTime\r\nSystem)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\r\n目标：提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理。\r\n系统类型\r\n\r\n实时控制与处理：工业武器控制、嵌入式系统\r\n实时信息处理： 信息查询系统、多媒体系统\r\n\r\n实时任务类型\r\n按任务执行时是否呈现周期性来划分\r\n(1)周期性实时任务。\r\n(2)非周期性实时任务。\r\n根据对截止时间的要求来划分\r\n\r\n硬实时任务(hard real-time task)\r\n软实时任务(Soft real-time task)\r\n\r\n特征\r\n多路性\r\n独立性\r\n及时性\r\n交互性\r\n可靠性\r\n操作系统的基本特性\r\n并发 共享 虚拟 异步\r\n并行和并发：\r\n并行是指这一个时刻上面有着多个事件在执行，是一个瞬间的状态。\r\n并发是指在某一段时间间隔以内有着多个事件同时进行\r\n在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交\r\n替执行。\r\n进程：程序为静态的，进程为程序的执行\r\n线程：进程的更小的可执行单位，一个进程可以包含若干个线程\r\n共享\r\n指系统中的资源供内存中的多道程序所共同使用\r\n在OS环境下的资源共享称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用\r\n在操作系统环境下，所谓共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。由于资源属性的不同，进程对资源共享的方式也不同，目前主要有\r\n以下两种资源共享方式：\r\n互斥共享方式：\r\n系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源，我们把这种资源共享方式称为互斥式共享\r\n临界资源或独占资源：一段时间内只允许一个进程访问的资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。\r\n同时访问方式\r\n允许在一段时间内由多个进程\r\n“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。\r\n虚拟\r\n操作系统中的所谓“虚拟”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物\r\n在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存、\r\n虚拟外部设备和虚拟信道等。\r\n时分复用技术：\r\n虚拟机处理技术：每个程序建里至少一个进程，让多道程序并发执行，通过时分复用同时为多个用户服务\r\n虚拟设备技术：通过时分复用将一台物理IO设备虚拟为多台逻辑上的IO设备，并允许每\r\n个用户占用一台逻辑上的I/O设备\r\n在操作系统中，虚拟的实现主要是通过分时使用的方法。显然，如果 n\r\n是某物理设备所对应的虚拟的逻辑设备数，则虚\r\n拟设备的平均速度必然是物理设备速度的 1 / n\r\n空分复用技术\r\n虚拟磁盘技术：将硬盘划分为若干个卷，机器上便会有若 干个虚拟盘。\r\n虚拟存储器技术：将一台机器的物理存储器变为虚拟存储\r\n器，以便从逻辑上来扩充存储器的容量。\r\n4、异步\r\n进程是以人们不可预知的速度向前推进，此即进程的异步性\r\n在多道程序环境下，系统允许多个进程并发执行\r\n并发执行的程序走走停停，以不可预知的速度前进\r\n操作系统的主要功能\r\n引入OS的主要目的是：为多道程序的允许提供良好的运行环境，保证多道程序能有条不紊，高效的运行，并最大程度的提高系统中各种资源的利用率，方便用户的使用\r\nOS定义：OS是直接控制和管理计算机硬件、软件资源，合理地对各类作业进行调度，以方便用户使用的程序集合\r\n处理机管理功能\r\n存储器管理功能\r\n设备管理功能\r\n文件管理功能\r\n用户接口\r\n处理机管理功能\r\n进程控制\r\n进程同步\r\n进程通信\r\n调度\r\n存储器管理功能\r\n内存分配\r\n静态分配\r\n动态分配\r\n内存保护\r\n地址映射\r\n内存扩充\r\nOS结构设计\r\n传统的操作系统结构\r\n无结构操作系统\r\n模块化的操作系统\r\n模块独立性\r\n模块接口法\r\n分层次结构OS\r\n客户／服务器模式\r\n面向对象的程序设计\r\n微内核OS结构\r\n微内核的基本概念：将操作系统划分为两大部分：微内核和多个服务器\r\n足够小的内核：微内核并非是一个完整的OS，而只是操作系统中最基本的部分\r\n它通常用于：① 实现与硬件紧密相关的处理；② 实现一些较基本的功能； ③\r\n负责客户和服务器之间的通信\r\n基于客户/服务器模式：\r\n将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现。\r\n客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。\r\n微内核的基本功能\r\n\r\n进程(线程)管理\r\n低级存储器管理\r\n中断和陷入处理\r\n\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"数字特征期望和方差的计算方法","url":"/posts/51854.html","content":"随机变量的数学期望\r\n离散型\r\n一维的\r\n定义\r\n设y = g(x)是连续函数，而Y = g(X)是随机变量X的函数。\r\n\r\n若X是离散型随机变量，分布列为P(X = xi) = pi，i = 1, 2, ⋯，且级数$\\sum_{i = 1}^{\\infty}|g(x_i)|p_i$收敛，则\r\n$$\r\nEY = Eg(X)=\\sum_{i = 1}^{\\infty}g(x_i)p_i\r\n$$\r\n\r\n例题\r\n例 1：有限个取值的离散变量\r\n设随机变量 X 表示掷一枚均匀骰子的点数，可能取值为 1, 2, 3, 4, 5, 6，每个取值的概率均为 $\\frac{1}{6}$。\r\n\r\n列出所有取值 xi 和对应概率\r\npi\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nxi\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n\r\n\r\n\r\n\r\npi\r\n$\\frac{1}{6}$\r\n$\\frac{1}{6}$\r\n$\\frac{1}{6}$\r\n$\\frac{1}{6}$\r\n$\\frac{1}{6}$\r\n$\\frac{1}{6}$\r\n\r\n\r\n\r\n代入公式计算： $$\r\nE(X) = 1 \\times \\frac{1}{6} + 2 \\times \\frac{1}{6} + 3 \\times\r\n\\frac{1}{6} + 4 \\times \\frac{1}{6} + 5 \\times \\frac{1}{6} + 6 \\times\r\n\\frac{1}{6} = \\frac{1+2+3+4+5+6}{6} = 3.5\r\n$$ 虽然骰子无法掷出\r\n(3.5)，但期望反映了长期掷骰子的平均点数。\r\n\r\n例 2：无限个取值的离散变量（几何分布）\r\n设随机变量 X 表示独立重复试验中首次成功的试验次数，成功概率为\r\np（0 &lt; p &lt; 1），则 X\r\n服从几何分布，概率质量函数为：P(X = k) = (1 − p)k − 1p  (k = 1, 2, 3, …)\r\n计算期望 E(X)：\r\n\r\n公式展开：$E(X) = \\sum_{k=1}^{\\infty} k\r\n\\cdot (1-p)^{k-1}p$\r\n利用级数求和公式（令 q = 1 − p）：$\\sum_{k=1}^{\\infty} k q^{k-1} = \\frac{1}{(1-q)^2}\r\n\\quad (\\text{当 } |q| &lt; 1)$\r\n代入得：$E(X) = p \\cdot\r\n\\frac{1}{(1-q)^2} = p \\cdot \\frac{1}{p^2} = \\frac{1}{p}$\r\n解释：例如抛硬币时正面朝上的概率 (p =\r\n0.5)，则首次成功的平均试验次数为 (E(X) = 2)。\r\n\r\n例3：二项分布的期望推导\r\n设随机变量 $X (n, p) ，其概率质量函数为：$\r\nP(X = k) = C_n^k p^k (1-p)^{n-k}, k = 0,1,2,,n 期望的定义为：\r\nE[X] = {k=0}^n k P(X = k) = {k=0}^n k C_n^k p^k (1-p)^{n-k}\r\n$$\r\n注意到当 $ k = 0 $ 时项为 0，因此可以从 $ k = 1 $ 开始求和：\r\n$$ E[X] = {k=1}^n k p^k (1-p)^{n-k} $$\r\n利用组合恒等式 $ k \\cdot C_n^k = n \\cdot C_{n-1}^{k-1} $：\r\n$$ E[X] = {k=1}^n n p^k (1-p)^{n-k} $$\r\n提取 $ n p $ 并重新索引（令 $ j = k-1 $）：\r\n$$ E[X] = n p {j=0}^{n-1} p^j (1-p)^{n-1-j} = n p\r\n{j=0}^{n-1} C_{n-1}^j p^j (1-p)^{n-1-j} $$\r\n求和部分正是二项式定理展开：\r\n$$\r\n\\sum_{j=0}^{n-1} C_{n-1}^j p^j (1-p)^{n-1-j} = (p + (1-p))^{n-1} = 1\r\n$$ 因此得到：\r\nE[X] = np\r\n这个结果直观上表示：在 $ n $ 次独立伯努利试验中，每次成功的概率为 $ p\r\n$，则期望成功次数为 $ n p $。\r\n二维的\r\n定义\r\n设 (X, Y)\r\n是二维离散型随机变量，其联合分布列为 P(X = xi, Y = yj) = pij，i, j = 1, 2, ⋯。若 Z = g(X, Y)\r\n是随机变量的函数，且级数 $\\sum_{i=1}^\\infty\\sum_{j=1}^\\infty\r\n|g(x_i,y_j)|p_{ij}$ 收敛，则 Z 的数学期望定义为：\r\n$$\r\nE[Z] = E[g(X,Y)] = \\sum_{i=1}^\\infty\\sum_{j=1}^\\infty g(x_i,y_j)p_{ij}\r\n$$\r\n特别地\r\n\r\nX 的边际期望： E[X] = ∑i∑jxip(xi, yj) = ∑ixipX(xi)\r\nY 的边际期望： E[Y] = ∑i∑jyjp(xi, yj) = ∑jyjpY(yj)\r\n\r\n解释\r\n这个定理告诉我们如何计算随机变量函数的期望值 EY = Eg(X)，在离散型的情况下，核心思想还是将函数值按概率加权平均。\r\nX\r\n是离散的时候（比如掷骰子的点数），取值都是可以列举出来的，$\r\nx1,x2,…x1,x2,…，存在一一对应的概率为\r\np1,p2,…p1,p2,…$。\r\n那么Eg(X)是什么，如何计算Eg(X)，它代表什么\r\nEg(X)\r\n是随机变量 X 的函数 g(X)\r\n的数学期望（也叫均值）。它表示：当 X 随机变化时，g(X)\r\n的平均取值是多少。\r\n\r\n举例说明：\r\n\r\n设 X\r\n表示“掷骰子的点数”，g(X) = X2，则\r\nEg(X)\r\n就是“骰子点数的平方的平均值”。\r\n设 X\r\n表示“某地区成年人的身高（米）”，g(X) = eX（计算指数增长），则\r\nEg(X)\r\n就是“e身高\r\n的平均值”。\r\n\r\n\r\n那么此时对g(x)的表述可能还是不够清晰，那么g(x)是什么\r\n因为直接研究 X\r\n可能不够，我们常需要分析它的函数 g(X)，而定义里也就是这么提到的\r\ng(X)\r\n是一个随机变量的函数，表示对随机变量 X\r\n进行某种数学变换后得到的新随机变量。\r\n\r\nX\r\n是原始随机变量（如身高、温度、股票价格等）。\r\ng\r\n是一个确定的函数，让你求啥，他就是啥（如平方 g(X) = X2、指数\r\ng(X) = eX、线性变换$\r\ng(X)=2X+3$ 等）。\r\ng(X)\r\n的结果仍然是随机变量，因为它的值依赖于 X 的随机性。\r\n\r\n例题\r\n例题1：已知联合分布列求数学期望\r\n设二维离散型随机变量(X, Y)的联合分布列为：\r\n\r\n\r\nimage-20250625095950767\r\n\r\n计算 X 的边缘分布列： $$\r\nP(X = 0) = P(X = 0, Y = 1) + P(X = 0, Y = 2) + P(X = 0, Y = 3) = 0.1 +\r\n0.2 + 0.1 = 0.4  \\\\\r\nP(X = 1) = P(X = 1, Y = 1) + P(X = 1, Y = 2) + P(X = 1, Y = 3) = 0.1 +\r\n0.3 + 0.2 = 0.6\r\n$$ 计算Y的边缘分布列：\r\n$$\r\nP(Y = 1) = P(X = 0, Y = 1) + P(X = 1, Y = 1) = 0.1 + 0.1 = 0.2  \\\\\r\nP(Y = 2) = P(X = 0, Y = 2) + P(X = 1, Y = 2) = 0.2 + 0.3 = 0.5  \\\\\r\nP(Y = 3) = P(X = 0, Y = 3) + P(X = 1, Y = 3) = 0.1 + 0.2 = 0.3\r\n$$ 计算E(X) 和\r\nE(Y)，根据期望公式\r\nE(X) = ∑ixiP(X = xi) = 0 × 0.4 + 1 × 0.6 = 0.6\r\nE(Y) = ∑jyjP(Y = yj) = 1 × 0.2 + 2 × 0.5 + 3 × 0.3 = 2.1\r\n例题2：求函数的数学期望\r\n设二维离散型随机变量(X, Y)的联合分布列与例 1\r\n相同，计算 Z = X + Y 的期望\r\nE(Z)\r\n确定 g(x) = X + Y\r\n的取值及其对应概率：\r\n\r\n当 (X, Y) = (0, 1) 时：Z = 1，P(Z = 1) = 0.1\r\n当 (X, Y) = (0, 2) 时：Z = 2，P(Z = 2) = 0.2\r\n当 (X, Y) = (0, 3) 时：Z = 3，P(Z = 3) = 0.1\r\n当 (X, Y) = (1, 1) 时：Z = 2，P(Z = 2) = 0.1\r\n当 (X, Y) = (1, 2) 时：Z = 3，P(Z = 3) = 0.3\r\n当 (X, Y) = (1, 3) 时：Z = 4，P(Z = 4) = 0.2\r\n\r\n整理Z的分布列如下：\r\n\r\n\r\n\r\nZ\r\n1\r\n2\r\n3\r\n4\r\n\r\n\r\n\r\n\r\nP\r\n0.1\r\n0.3\r\n0.4\r\n0.2\r\n\r\n\r\n\r\n计算E(Z)，根据数学期望公式，可得\r\n$$\r\n\\begin{align*}\r\nE(Z) &amp;= \\sum z P(Z=z) \\\\\r\n&amp;= 1 \\times 0.1 + 2 \\times (0.2 + 0.1) + 3 \\times (0.1 + 0.3) + 4\r\n\\times 0.2 \\\\\r\n&amp;= 0.1 + 0.6 + 1.2 + 0.8 \\\\\r\n&amp;= 2.7\r\n\\end{align*}\r\n$$ 最后验证期望的线性性质：\r\nE(Z) = E(X + Y) = E(X) + E(Y) = 0.6 + 2.1 = 2.7\r\n例题3：\r\n设二维离散型随机变量(X, Y)的联合分布律如下：\r\n\r\n\r\n\r\nX ∖ Y\r\n1\r\n2\r\n\r\n\r\n\r\n\r\n0\r\n0.2\r\n0.1\r\n\r\n\r\n1\r\n0.3\r\n0.4\r\n\r\n\r\n\r\n计算随机变量Z = 2X + Y的数学期望E(Z)。\r\n解答：\r\n根据二维离散型随机变量函数的数学期望公式 E(Z) = E(g(X, Y)) = ∑i∑jg(xi, yj)pij\r\n其中g(X, Y) = 2X + Y，pij是(X = xi, Y = yj)的联合概率。\r\n我们需要分别计算g(xi, yj)pij在不同(xi, yj)组合下的值，再进行求和：\r\n\r\n当x1 = 0, y1 = 1时：\r\ng(0, 1) = 2 × 0 + 1 = 1，p11 = 0.2，则g(0, 1)p11 = 1 × 0.2 = 0.2。\r\n当x1 = 0, y2 = 2时：\r\ng(0, 2) = 2 × 0 + 2 = 2，p12 = 0.1，则g(0, 2)p12 = 2 × 0.1 = 0.2。\r\n当x2 = 1, y1 = 1时：\r\ng(1, 1) = 2 × 1 + 1 = 3，p21 = 0.3，则g(1, 1)p21 = 3 × 0.3 = 0.9。\r\n当x2 = 1, y2 = 2时：\r\ng(1, 2) = 2 × 1 + 2 = 4，p22 = 0.4，则g(1, 2)p22 = 4 × 0.4 = 1.6。\r\n\r\n将上述结果求和可得： E(Z) = 0.2 + 0.2 + 0.9 + 1.6 = 2.9\r\n答案：E(Z) = 2.9\r\n多维的\r\n连续性\r\n一维的\r\n定义\r\n设y = g(x)是连续函数，而Y = g(X)是随机变量X的函数。\r\n\r\n若X是概率密度为f(x)的连续型随机变量，且积分∫−∞+∞|g(x)|f(x)dx收敛，则\r\nEY = Eg(X) = ∫−∞+∞g(x)f(x)dx\r\n\r\n例题\r\n例题1：推导均匀分布的期望形式\r\n设随机变量 X 服从区间 [a, b]\r\n上的均匀分布，其概率密度函数为：\r\n$$\r\nf(x) = \\begin{cases}\r\n\\frac{1}{b-a}, &amp; a \\leq x \\leq b \\\\\r\n0, &amp; \\text{其他}\r\n\\end{cases}\r\n$$\r\n期望 E[X]\r\n的计算过程如下：\r\n$$\r\n\\begin{align*}\r\nE[X] &amp;= \\int_{-\\infty}^{\\infty} x f(x) dx \\\\\r\n&amp;= \\int_{a}^{b} x \\cdot \\frac{1}{b-a} dx \\\\\r\n&amp;= \\frac{1}{b-a} \\int_{a}^{b} x dx \\\\\r\n&amp;= \\frac{1}{b-a} \\left[ \\frac{x^2}{2} \\right]_{a}^{b} \\\\\r\n&amp;= \\frac{1}{b-a} \\left( \\frac{b^2}{2} - \\frac{a^2}{2} \\right) \\\\\r\n&amp;= \\frac{1}{b-a} \\cdot \\frac{b^2 - a^2}{2} \\\\\r\n&amp;= \\frac{(b-a)(b+a)}{2(b-a)} \\\\\r\n&amp;= \\frac{a + b}{2}\r\n\\end{align*}\r\n$$ 其中关键步骤说明： 1. 积分限从 a 到 b，因为在其他区间 f(x) = 0 2. 计算定积分\r\n$\\int x dx = \\frac{x^2}{2}$ 3.\r\n分子因式分解 b2 − a2 = (b − a)(b + a)\r\n4. 最后约去 (b − a)\r\n项\r\n因此，均匀分布的期望为：\r\n$$\r\nE[X] = \\frac{a + b}{2}\r\n$$\r\n例题2：二次函数情形的期望形式\r\n设连续型随机变量 X 的期望为\r\nμ，方差为 σ2，求 Z = (X − μ)2\r\n的数学期望 E(Z)。\r\n解答：\r\n\r\n直接展开： E(Z) = E[(X − μ)2]\r\n利用方差定义： Var(X) = E[(X − μ)2] − [E(X − μ)]2\r\n注意到： E(X − μ) = E(X) − μ = 0\r\n因此： E[(X − μ)2] = Var(X) + 0 = σ2\r\n结论： E[(X − μ)2] = σ2\r\n\r\n例题3：\r\n设随机变量 X\r\n的概率密度函数为：\r\n$ f_X(x) =\r\n$\r\n计算随机变量 $ Y = X^2$ 的数学期望 $ E(Y)$ 。\r\n解答过程：\r\n根据数学期望公式： E(Y) = E(X2) = ∫−∞∞x2fX(x) dx\r\n由于 fX(x)\r\n在 x &lt; 0\r\n时为零，积分区间简化为 [0, +∞)： E(Y) = ∫0∞x2 ⋅ 2e−2x dx = 2∫0∞x2e−2x dx\r\n使用分部积分法，令 u = x2，dv = e−2xdx，则\r\ndu = 2xdx，$v = -\\frac{1}{2}e^{-2x}$： $$\r\n\\int x^2 e^{-2x} dx = -\\frac{1}{2}x^2 e^{-2x} + \\int x e^{-2x} dx\r\n$$ 对于剩余的积分 ∫xe−2xdx，再次使用分部积分法，令\r\nu = x，dv = e−2xdx，则\r\ndu = dx，$v = -\\frac{1}{2}e^{-2x}$ $$\r\n\\int x e^{-2x} dx = -\\frac{1}{2}x e^{-2x} + \\frac{1}{2} \\int e^{-2x} dx\r\n= -\\frac{1}{2}x e^{-2x} - \\frac{1}{4}e^{-2x} + C\r\n$$ 将结果代回原式： $$\r\n\\int_{0}^{\\infty} x^2 e^{-2x} dx = \\left[ -\\frac{1}{2}x^2 e^{-2x} -\r\n\\frac{1}{2}x e^{-2x} - \\frac{1}{4}e^{-2x} \\right]_{0}^{\\infty}\r\n$$ 当 x → ∞\r\n时，所有项趋近于零；当 x = 0\r\n时，结果为 $0 - (-\\frac{1}{4}) =\r\n\\frac{1}{4}$。因此： $$\r\n2 \\int_{0}^{\\infty} x^2 e^{-2x} dx = 2 \\cdot \\frac{1}{4} = \\frac{1}{2}\r\n$$ 答案：$E(Y) =\r\n\\frac{1}{2}$\r\n二维的\r\n定义\r\n设 (X, Y)\r\n是二维连续型随机变量，其联合概率密度函数为 f(x, y)。若 Z = g(X, Y)\r\n是随机变量的连续函数，且积分 ∫−∞+∞∫−∞+∞|g(x, y)|f(x, y)dxdy\r\n收敛，则 Z\r\n的数学期望定义为：\r\nE[Z] = E[g(X, Y)] = ∫−∞+∞∫−∞+∞g(x, y)f(x, y)dxdy\r\n例题\r\n例题1\r\n设二维连续型随机变量 (X, Y)\r\n的联合概率密度函数为： $$\r\nf(x, y) =  \\begin{cases} \\frac{1}{2}, &amp; 0 \\leq x \\leq 1, \\ 0 \\leq y\r\n\\leq 2 \\\\ 0, &amp; \\text{其他} \\end{cases}\r\n$$ 计算随机变量 Z = X + Y\r\n的数学期望 E(Z)。\r\n解答：\r\n根据二维连续型随机变量函数的数学期望公式： E(Z) = E(g(X, Y)) = ∫−∞∞∫−∞∞g(x, y)f(x, y) dx dy\r\n其中，g(X, Y) = X + Y，代入联合概率密度函数f(x, y)的表达式\r\n$$\r\nE(Z) = \\int_{0}^{1} \\int_{0}^{2} (x + y) \\cdot \\frac{1}{2} \\, dy \\, dx\r\n$$ 将积分拆分为两部分： $$\r\nE(Z) = \\frac{1}{2} \\int_{0}^{1} \\int_{0}^{2} x \\, dy \\, dx + \\frac{1}{2}\r\n\\int_{0}^{1} \\int_{0}^{2} y \\, dy \\, dx\r\n$$ 计算第一个积分 $$\r\n\\frac{1}{2} \\int_{0}^{1} \\int_{0}^{2} x \\, dy \\, dx = \\frac{1}{2}\r\n\\int_{0}^{1} x \\left[ \\int_{0}^{2} 1 \\, dy \\right] dx = \\frac{1}{2}\r\n\\int_{0}^{1} x \\cdot 2 \\, dx = \\int_{0}^{1} x \\, dx = \\left[\r\n\\frac{x^2}{2} \\right]_{0}^{1} = \\frac{1}{2}\r\n$$ 计算第二个积分： $$\r\n\\frac{1}{2} \\int_{0}^{1} \\int_{0}^{2} y \\, dy \\, dx = \\frac{1}{2}\r\n\\int_{0}^{1} \\left[ \\int_{0}^{2} y \\, dy \\right] dx = \\frac{1}{2}\r\n\\int_{0}^{1} \\left[ \\frac{y^2}{2} \\right]_{0}^{2} dx = \\frac{1}{2}\r\n\\int_{0}^{1} 2 \\, dx = \\int_{0}^{1} 1 \\, dx = \\left[ x \\right]_{0}^{1} =\r\n1\r\n$$ 将两部分结果相加： $$\r\nE(Z) = \\frac{1}{2} + 1 = \\frac{3}{2}\r\n$$ 答案：$E(Z) =\r\n\\frac{3}{2}$\r\n例题2：\r\n设二维连续型随机变量 (X, Y)\r\n的联合概率密度函数为： $$\r\nf(x, y) =  \\begin{cases} e^{-(x + y)}, &amp; x \\geq 0, \\ y \\geq 0 \\\\ 0,\r\n&amp; \\text{其他} \\end{cases}\r\n$$ 计算随机变量 Z = XY 的数学期望\r\nE(Z)。\r\n解答：\r\n根据期望公式 E(Z) = E(XY) = ∫−∞∞∫−∞∞xy ⋅ f(x, y) dx dy\r\n由于 f(x, y)\r\n在 x &lt; 0 或 y &lt; 0 时为零，积分区间简化为\r\n[0, +∞) × [0, +∞)： E(Z) = ∫0∞∫0∞xy ⋅ e−(x + y) dx dy\r\n将指数函数拆分为两个独立的指数函数 (E(Z) = (∫0∞xe−x dx)(∫0∞ye−y dy)\r\n注意到两个积分形式相同，均为指数分布的一阶矩。对于指数分布 X ∼ Exp(λ)，其概率密度函数为\r\nf(x) = λe−λx，数学期望为\r\n$E(X) = \\frac{1}{\\lambda}$。当λ = 1时： ∫0∞xe−x dx = 1\r\n因此： E(Z) = 1 × 1 = 1\r\n答案：E(Z) = 1\r\n多维的\r\n随机变量的方差\r\n离散的\r\n公式 D(X) = E(X2) − E(X)2\r\n这部分仅仅列出例题\r\n一维的\r\n题目1\r\n设离散型随机变量 X\r\n的分布律为： $$\r\n\\begin{array}{c|c|c|c} X &amp; 0 &amp; 1 &amp; 2 \\\\ \\hline P(X) &amp;\r\n0.2 &amp; 0.5 &amp; 0.3 \\\\ \\end{array}\r\n$$ 计算随机变量 Y = 3X + 2 的方差 D(Y)。\r\n解答\r\n根据方差的定义D(Y) = E(Y2) − [E(Y)]2​，我们需要计算\r\nE(Y) 和 E(Y2)。\r\n\r\n计算 E(Y)： E(Y) = E(3X + 2) = 3E(X) + 2\r\n其中E(X) E(X) = 0 × 0.2 + 1 × 0.5 + 2 × 0.3 = 0 + 0.5 + 0.6 = 1.1\r\n因此 E(Y) = 3 × 1.1 + 2 = 5.3\r\n计算E(Y2) E(Y2) = E[(3X + 2)2] = E[9X2 + 12X + 4] = 9E(X2) + 12E(X) + 4\r\n其中，$E(X^2) 为$ E(X^2) = 0\r\n^2 + 1^2 + 2^2 = 1.7 所以 E(Y^2) = 9 + 12 + 4 =\r\n15.3 + 13.2 + 4 = 32.5 $$\r\n计算D(Y):\r\nD(Y) = E(Y2) − [E(Y)]2 = 32.5 − (5.3)2 = 32.5 − 28.09 = 4.41\r\n\r\n答案：D(Y) = 4.41\r\n题目2\r\n设离散型随机变量 X 的分布律为： $$\r\n\\begin{array}{c|c|c|c} X &amp; -1 &amp; 0 &amp; 1 \\\\ \\hline P(X) &amp;\r\n0.3 &amp; 0.4 &amp; 0.3 \\\\ \\end{array}\r\n$$ 计算随机变量 Y = X2 的方差\r\nD(Y)。\r\n解答过程：\r\n同样根据方差的定义 D(Y) = E(Y2) − [E(Y)]2，分步计算\r\n\r\n计算E(Y) E(Y) = E(X2) = (−1)2 × 0.3 + 02 × 0.4 + 12 × 0.3 = 0.3 + 0 + 0.3 = 0.6\r\n计算E(Y2)\r\n\r\nE(Y2) = E[(X2)2] = E(X4) = (−1)4 × 0.3 + 04 × 0.4 + 14 × 0.3 = 0.3 + 0 + 0.3 = 0.6\r\n\r\n计算 D(Y)： D(Y) = E(Y2) − [E(Y)]2 = 0.6 − (0.6)2 = 0.6 − 0.36 = 0.24\r\n\r\n答案：D(Y) = 0.24\r\n二维的\r\n题目1\r\n设二维离散型随机变量 (X, Y)\r\n的联合分布律如下：\r\n\r\n\r\n\r\nX ∖ Y\r\n0\r\n1\r\n\r\n\r\n\r\n\r\n0\r\n0.3\r\n0.2\r\n\r\n\r\n1\r\n0.1\r\n0.4\r\n\r\n\r\n\r\n计算随机变量 Z = X + Y 的方差\r\nD(Z)。\r\n解答：\r\n根据方差的定义 D(Z) = E(Z2) − [E(Z)]2，我们需要先计算\r\nE(Z) 和 E(Z2)。 E(Z) = E(X + Y) = E(X) + E(Y)\r\nE(X) = 0 * (0.3 + 0.2) + 1 * (0.1 + 0.4) = 0.5\r\nE(Y) = 0 * (0.3 + 0.1) + 1 * (0.2 + 0.4) = 0.6\r\nE(Z) = 0.5 + 0.6 = 1.1\r\nE(Z2) = E[(X + Y)2] = E(X2 + 2XY + Y2) = E(X2) + 2E(XY) + E(Y2)\r\nE(XY) = ∑i, jxiyjP(X = xi, Y = yj) = 0 × 0 × 0.3 + 0 × 1 × 0.2 + 1 × 0 × 0.1 + 1 × 1 × 0.4 = 0 + 0 + 0 + 0.4 = 0.4\r\nE(X2) = 02 * (0.3 + 0.2) + 12 * (0.1 + 0.4) = 0.5\r\nE(Y2) = 02 × (0.3 + 0.1) + 12 × (0.2 + 0.4) = 0 + 0.6 = 0.6\r\nE(Z2) = 0.5 + 2 × 0.4 + 0.6 = 0.5 + 0.8 + 0.6 = 1.9\r\nE(Z2) = 0.5 + 2 × 0.4 + 0.6 = 0.5 + 0.8 + 0.6 = 1.9\r\n答案：D(Z) = 0.69\r\n例题2\r\n设二维离散型随机变量 (X, Y)\r\n的联合分布律如下：\r\n\r\n\r\n\r\nX ∖ Y\r\n-1\r\n1\r\n\r\n\r\n\r\n\r\n0\r\n0.2\r\n0.3\r\n\r\n\r\n2\r\n0.4\r\n0.1\r\n\r\n\r\n\r\n计算随机变量 Z = XY 的方差\r\nD(Z)。\r\n解答过程：\r\n同样根据方差的定义 D(Z) = E(Z2) − [E(Z)]2，分步计算：\r\nE(Z) = E(XY) = ∑i, jxiyjP(X = xi, Y = yj) = 0 × (−1) × 0.2 + 0 × 1 × 0.3 + 2 × (−1) × 0.4 + 2 × 1 × 0.1 = 0 + 0 − 0.8 + 0.2 = −0.6\r\nE(Z2) = E[(XY)2] = ∑i, j(xiyj)2P(X = xi, Y = yj) = [0 × (−1)]2 × 0.2 + [0 × 1]2 × 0.3 + [2 × (−1)]2 × 0.4 + [2 × 1]2 × 0.1 = 0 × 0.2 + 0 × 0.3 + 4 × 0.4 + 4 × 0.1 = 0 + 0 + 1.6 + 0.4 = 2\r\nD(Z) = E(Z2) − [E(Z)]2 = 2 − (−0.6)2 = 2 − 0.36 = 1.64\r\n答案：D(Z) = 1.64\r\n例题3\r\n连续的\r\n公式上同，这部分也是只给出例题\r\n一维的\r\n例题1\r\n设连续型随机变量 X\r\n的概率密度函数为： $$\r\nf(x) =  \\begin{cases} 2e^{-2x}, &amp; x \\geq 0 \\\\ 0, &amp; x &lt; 0\r\n\\end{cases}\r\n$$ 计算随机变量 Y = e−X\r\n的方差 D(Y)。\r\n解答：\r\n根据方差的定义 D(Y) = E(Y2) − [E(Y)]2，分步计算：\r\n\r\n计算 E(Y)： E(Y) = E(e−X) = ∫0∞e−x ⋅ 2e−2x dx = 2∫0∞e−3x dx\r\n令 u = 3x，则 $dx = \\frac{1}{3} du$，积分变为： $$\r\n2 \\int_{0}^{\\infty} e^{-u} \\cdot \\frac{1}{3} du = \\frac{2}{3}\r\n\\int_{0}^{\\infty} e^{-u} du = \\frac{2}{3} \\cdot 1 = \\frac{2}{3}\r\n$$\r\n计算 E(Y2)：\r\nE(Y2) = E(e−2X) = ∫0∞e−2x ⋅ 2e−2x dx = 2∫0∞e−4x dx\r\n令 u = 4x，则 $dx = \\frac{1}{4} du$，积分变为： $$\r\n2 \\int_{0}^{\\infty} e^{-u} \\cdot \\frac{1}{4} du = \\frac{1}{2}\r\n\\int_{0}^{\\infty} e^{-u} du = \\frac{1}{2} \\cdot 1 = \\frac{1}{2}\r\n$$\r\n计算 D(Y)： $$\r\nD(Y) = E(Y^2) - [E(Y)]^2 = \\frac{1}{2} - \\left( \\frac{2}{3} \\right)^2 =\r\n\\frac{1}{2} - \\frac{4}{9} = \\frac{9}{18} - \\frac{8}{18} = \\frac{1}{18}\r\n$$\r\n\r\n答案：$D(Y) =\r\n\\frac{1}{18}$\r\n例题2\r\n设随机变量 X 服从均匀分布 U(−2, 2)，定义随机变量 Y = X + |X|，求\r\nY 的方差 D(Y)。\r\n解答：\r\n\r\n分析 Y\r\n的表达式\r\n由于随机变量 X 服从均匀分布 U(−2, 2)\r\n均匀分布 (U(-2, 2)) 的概率密度函数为： $$\r\nf_X(x) = \\begin{cases} \\frac{1}{4}, &amp; x \\in (-2, 2) \\\\\r\n0, &amp; \\text{其他}\r\n\\end{cases}\r\n$$ 而其中 $$\r\n|X| = \\begin{cases}\r\n   X, &amp; X \\geq 0 \\\\\r\n   -X, &amp; X &lt; 0\r\n   \\end{cases}\r\n$$ 因此 $$\r\nY = X + |X| = \\begin{cases}\r\n   2X, &amp; X \\geq 0 \\\\\r\n   0, &amp; X &lt; 0\r\n   \\end{cases}\r\n$$\r\n计算E(Y) $$\r\nE(Y) = \\int_{-2}^{0} 0 \\cdot \\frac{1}{4} \\, dx + \\int_{0}^{2} 2x \\cdot\r\n\\frac{1}{4} \\, dx = 0 + \\frac{1}{2} \\int_{0}^{2} x \\, dx\r\n$$ 计算积分 $$\r\n\\int_{0}^{2} x \\, dx = \\left. \\frac{x^2}{2} \\right|_{0}^{2} =\r\n\\frac{4}{2} - 0 = 2\r\n$$\r\n$$\r\nE(Y) = \\frac{1}{2} \\cdot 2 = 1\r\n$$\r\n计算E(Y2)\r\n同样分段积分： $$\r\nE(Y^2) = \\int_{-2}^{0} 0^2 \\cdot \\frac{1}{4} \\, dx + \\int_{0}^{2} (2x)^2\r\n\\cdot \\frac{1}{4} \\, dx = 0 + \\int_{0}^{2} 4x^2 \\cdot \\frac{1}{4} \\, dx\r\n$$ 化简后 $$\r\n(Y^2) = \\int_{0}^{2} x^2 \\, dx = \\left. \\frac{x^3}{3} \\right|_{0}^{2} =\r\n\\frac{8}{3} - 0 = \\frac{8}{3}\r\n$$\r\n计算D(Y) $$\r\n\\frac{8}{3}D(Y) = E(Y^2) - [E(Y)]^2 = \\frac{8}{3} - 1^2 = \\frac{5}{3}\r\n$$\r\n\r\n例题3\r\n已知随机变量 X 的概率密度函数 $$\r\nf(x) =\r\n\\begin{cases}\r\n1 + x, &amp; -1 \\leq x \\leq 0, \\\\\r\n1 - x, &amp; 0 &lt; x \\leq 1, \\\\\r\n0, &amp; \\text{其他}.\r\n\\end{cases}\r\n$$ 求 X 的方差 D(X)\r\n解答：\r\n计算期望 E[X]\r\n由于密度函数关于 x = 0\r\n对称，且 x 是奇函数： E[X] = ∫−11xf(x)dx = 0\r\n计算 E[X2] E[X2] = ∫−11x2f(x)dx = ∫−10x2(1 + x)dx + ∫01x2(1 − x)dx\r\n计算第一个积分： $$\r\n\\int_{-1}^0 x^2(1+x) dx = \\int_{-1}^0 (x^2 + x^3) dx =\r\n\\left[\\frac{x^3}{3} + \\frac{x^4}{4}\\right]_{-1}^0 = 0 -\r\n\\left(-\\frac{1}{3} + \\frac{1}{4}\\right) = \\frac{1}{12}\r\n$$\r\n计算第二个积分： $$\r\n\\int_0^1 x^2(1-x) dx = \\int_0^1 (x^2 - x^3) dx = \\left[\\frac{x^3}{3} -\r\n\\frac{x^4}{4}\\right]_0^1 = \\frac{1}{3} - \\frac{1}{4} = \\frac{1}{12}\r\n$$\r\n因此： $$\r\nE[X^2] = \\frac{1}{12} + \\frac{1}{12} = \\frac{1}{6}\r\n$$\r\n根据方差公式： $$\r\nD(X) = E[X^2] - (E[X])^2 = \\frac{1}{6} - 0 = \\frac{1}{6}\r\n$$\r\n例题4\r\n已知随机变量 $ X$ 的概率密度函数 $$\r\nf(x) =\r\n\\begin{cases}\r\n\\dfrac{2}{\\pi} \\cos^2 x, &amp; |x| \\leq \\dfrac{\\pi}{2}, \\\\\r\n0, &amp; |x| &gt; \\dfrac{\\pi}{2}.\r\n\\end{cases}\r\n$$ 求 $ X$ 的方差 D(X)\r\n解答\r\n\r\n验证 f(x)\r\n满足概率密度函数的两个基本性质：\r\n\r\n非负性：显然 cos2x ≥ 0 且 $\\frac{2}{\\pi} &gt; 0$，故 f(x) ≥ 0\r\n归一性： $$\r\n\\begin{align*}\r\n   \\int_{-\\infty}^{\\infty} f(x) dx &amp;= \\frac{2}{\\pi}\r\n\\int_{-\\pi/2}^{\\pi/2} \\cos^2 x dx \\\\\r\n   &amp;= \\frac{4}{\\pi} \\int_{0}^{\\pi/2} \\cos^2 x dx \\quad\r\n(\\text{利用偶函数性质}) \\\\\r\n   &amp;= \\frac{4}{\\pi} \\left[ \\frac{x}{2} + \\frac{\\sin 2x}{4}\r\n\\right]_0^{\\pi/2} \\\\\r\n   &amp;= \\frac{4}{\\pi} \\left( \\frac{\\pi}{4} + 0 - 0 - 0 \\right) = 1\r\n   \\end{align*}\r\n$$\r\n\r\n计算E(X)\r\n由于 f(x)\r\n是偶函数，x 是奇函数，其乘积\r\nxf(x)\r\n是奇函数： $$\r\nE[X] = \\int_{-\\pi/2}^{\\pi/2} x \\cdot \\frac{2}{\\pi} \\cos^2 x dx = 0\r\n$$\r\n计算 E[X2] $$\r\n\\begin{align*}\r\nE[X^2] &amp;= \\frac{2}{\\pi} \\int_{-\\pi/2}^{\\pi/2} x^2 \\cos^2 x dx \\\\\r\n&amp;= \\frac{4}{\\pi} \\int_{0}^{\\pi/2} x^2 \\cos^2 x dx \\quad\r\n(\\text{偶函数性质})\r\n\\end{align*}\r\n$$ 分部积分，设 u = x2, dv = cos2xdx，则：\r\n$$\r\n\\begin{align*}\r\n\\int x^2 \\cos^2 x dx &amp;= x^2 \\left( \\frac{x}{2} + \\frac{\\sin 2x}{4}\r\n\\right) - \\int \\left( \\frac{x}{2} + \\frac{\\sin 2x}{4} \\right) 2x dx \\\\\r\n&amp;= \\frac{x^3}{2} + \\frac{x^2 \\sin 2x}{4} - \\int x^2 dx - \\frac{1}{2}\r\n\\int x \\sin 2x dx \\\\\r\n&amp;= \\frac{x^3}{2} + \\frac{x^2 \\sin 2x}{4} - \\frac{x^3}{3} -\r\n\\frac{1}{2} \\left( -\\frac{x \\cos 2x}{2} + \\frac{\\sin 2x}{4} \\right) + C\r\n\\end{align*}\r\n$$ 计算定积分 $$\r\n\\begin{align*}\r\n\\int_{0}^{\\pi/2} x^2 \\cos^2 x dx &amp;= \\left[ \\frac{x^3}{6} + \\frac{x^2\r\n\\sin 2x}{4} + \\frac{x \\cos 2x}{4} - \\frac{\\sin 2x}{8} \\right]_0^{\\pi/2}\r\n\\\\\r\n&amp;= \\frac{\\pi^3}{48} + 0 + 0 - \\frac{1}{8} - (0 + 0 + 0 - 0) \\\\\r\n&amp;= \\frac{\\pi^3}{48} - \\frac{1}{8}\r\n\\end{align*}\r\n$$ （$$ \\cos^2 x = \\frac{1 + \\cos\r\n2x}{2} $$）\r\n因此 $$\r\nE[X^2] = \\frac{4}{\\pi} \\left( \\frac{\\pi^3}{48} - \\frac{1}{8} \\right) =\r\n\\frac{\\pi^2}{12} - \\frac{1}{2\\pi}\r\n$$\r\n计算方差 $$\r\nD(X) = E[X^2] - (E[X])^2 = \\left( \\frac{\\pi^2}{12} - \\frac{1}{2\\pi}\r\n\\right) - 0 = \\frac{\\pi^2}{12} - \\frac{1}{2\\pi}\r\n$$\r\n\r\n二维的\r\n例题1\r\n设二维连续型随机变量 (X, Y)\r\n的联合概率密度函数为： $$\r\nf(x, y) =  \\begin{cases} \\frac{1}{2\\pi} e^{-\\frac{x^2 + y^2}{2}}, &amp;\r\n-\\infty &lt; x, y &lt; +\\infty \\\\ 0, &amp; \\text{其他} \\end{cases}\r\n$$ 计算随机变量 Z = X2 + Y2\r\n的方差 D(Z)。\r\n解答\r\n根据方差的定义 D(Z) = E(Z2) − [E(Z)]2，我们需要先计算\r\nE(Z) 和 E(Z2)。 E(Z) = E(X2 + Y2) = E(X2) + E(Y2)\r\n由于 X 和 Y 均服从标准正态分布 N(0, 1)，故 E(X2) = D(X) + [E(X)]2 = 1 + 0 = 1，同理\r\nE(Y2) = 1。因此：E(Z) = 1 + 1 = 2 E(Z2) = E[(X2 + Y2)2] = E(X4) + 2E(X2Y2) + E(Y4)\r\n计算 E(X4)\r\n和 E(Y4)：\r\n对于标准正态分布 N(0, 1)，其四阶矩为 E(X4) = 3，故：\r\nE(X4) = E(Y4) = 3\r\n计算 E(X2Y2)：\r\n由于 X 和 Y 相互独立，故： E(X2Y2) = E(X2) ⋅ E(Y2) = 1 ⋅ 1 = 1\r\n因此： E(Z2) = 3 + 2 ⋅ 1 + 3 = 8\r\n计算 D(Z)： D(Z) = E(Z2) − [E(Z)]2 = 8 − 22 = 8 − 4 = 4\r\n答案：D(Z) = 4\r\n例题2\r\n设二维连续型随机变量 (X, Y) 在单位圆 x2 + y2 ≤ 1\r\n内服从均匀分布，其联合概率密度函数为： $$\r\nf(x, y) =  \\begin{cases} \\frac{1}{\\pi}, &amp; x^2 + y^2 \\leq 1 \\\\ 0,\r\n&amp; \\text{其他} \\end{cases}\r\n$$ 计算随机变量 Z = XY 的方差\r\nD(Z)。\r\n计算：\r\n\r\n计算E(Z) $$\r\nE(Z) = E(XY) = \\iint_{x^2 + y^2 \\leq 1} xy \\cdot \\frac{1}{\\pi} \\, dx \\,\r\ndy\r\n$$ 由于积分区域关于 x\r\n轴和 y 轴对称，且被积函数\r\nxy\r\n是奇函数，故：E(Z) = 0\r\n计算E(Z2) $$\r\nE(Z^2) = E(X^2Y^2) = \\iint_{x^2 + y^2 \\leq 1} x^2 y^2 \\cdot\r\n\\frac{1}{\\pi} \\, dx \\, dy\r\n$$ 转换为极坐标：x = rcos θ，y = rsin θ，dx dy = r dr dθ，积分区域变为\r\n0 ≤ r ≤ 1，0 ≤ θ ≤ 2π： $$\r\nE(Z^2) = \\frac{1}{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1}\r\n(r^2\\cos^2\\theta)(r^2\\sin^2\\theta) r \\, dr \\, d\\theta\r\n$$ 化简被积函数： $$\r\nr^5 \\cos^2\\theta \\sin^2\\theta = \\frac{1}{4}r^5 \\sin^2(2\\theta)\r\n$$ 计算积分： $$\r\nE(Z^2) = \\frac{1}{4\\pi} \\int_{0}^{2\\pi} \\sin^2(2\\theta) \\, d\\theta\r\n\\int_{0}^{1} r^5 \\, dr\r\n$$\r\n\r\n计算 ∫01r5 dr：\r\n$$\r\n\\int_{0}^{1} r^5 \\, dr = \\left[ \\frac{r^6}{6} \\right]_{0}^{1} =\r\n\\frac{1}{6}\r\n$$\r\n计算 ∫02πsin2(2θ) dθ：\r\n令 u = 2θ，则 $d\\theta = \\frac{1}{2} du$，积分变为： $$\r\n\\frac{1}{2} \\int_{0}^{4\\pi} \\sin^2 u \\, du = \\frac{1}{2} \\cdot 2\\pi =\r\n\\pi\r\n$$ 因此： $$\r\nE(Z^2) = \\frac{1}{4\\pi} \\cdot \\pi \\cdot \\frac{1}{6} = \\frac{1}{24}\r\n$$\r\n\r\n所以 $$\r\nD(Z) = E(Z^2) - [E(Z)]^2 = \\frac{1}{24} - 0^2 = \\frac{1}{24}\r\n$$\r\n\r\n题目3\r\n设随机变量 X, Y\r\n独立且均服从 $N\\left(0,\r\n\\frac{1}{2}\\right)$ ，求 E(|X − Y|) （即\r\n|X − Y| 的数学期望\r\n）\r\n解答：\r\n正态分布性质：若 X ∼ N(μ1, σ12)\r\n，$ Y N(_2, _2^2) $ 且独立，则 $X - Y N(_1 - _2, _1^2 + _2^2) $。\r\n代入 μ1 = μ2 = 0\r\n，$ _1^2 = _2^2 = $，得：\r\n$$\r\nX - Y \\sim N\\left( 0, \\frac{1}{2} + \\frac{1}{2} \\right) = N(0, 1)\r\n$$ 设 Z = X − Y ∼ N(0, 1)\r\n，则 $$\r\nE(|Z|) = \\int_{-\\infty}^{+\\infty} |z| \\cdot \\frac{1}{\\sqrt{2\\pi}}\r\ne^{-\\frac{z^2}{2}} dz\r\n$$ 利用对称性（被积函数是偶函数），简化为： $$\r\nE(|Z|) = 2 \\int_{0}^{+\\infty} z \\cdot \\frac{1}{\\sqrt{2\\pi}}\r\ne^{-\\frac{z^2}{2}} \\, dz\r\n$$ 令 $t = \\frac{z^2}{2}$ ，则\r\ndt = z dz\r\n，积分变为： $$\r\nE(|Z|) = 2 \\cdot \\frac{1}{\\sqrt{2\\pi}} \\int_{0}^{+\\infty} e^{-t} \\, dt =\r\n\\frac{2}{\\sqrt{2\\pi}} \\cdot 1 = \\boldsymbol{\\frac{\\sqrt{2}}{\\pi}}\r\n$$\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"操作系统之进程的描述与控制","url":"/posts/35167.html","content":"前驱图和程序执行\r\n前趋图\r\n前趋图(Precedence Graph)\r\n是一个有向无循环图，可记为DAG，用于描述程序/进程之间执行的先后顺序。\r\n\r\n\r\nimage-20250505172730924\r\n\r\n图中每个结点可用来表示一个进程或程序段，结点间的有向边表示两个结点之间存在的偏序或前趋关系\r\n如P1与 P2存在前趋关系，记作P1 -&gt;\r\nP2，表示在P2开始执行之前P1必须完成，此时称P1是P2的直接前趋，P2是P1的直接后继。没有前趋的结点称为初始结点，没有后继的结点称为终止结点，每个结点还有一个重量，用于表示该结点所含有的程序量或程序的执行时间。\r\n注意：前趋图中必须不存在循环\r\n\r\n\r\nimage-20250505172727388\r\n\r\n程序的顺序执行：\r\n在计算机系统中只有一个程序在运行，这个程序独占系统中所有资源，其执行不受外界影响。\r\n一道程序执行完后另一道才能开始\r\n程序顺序执行的特征\r\n\r\n顺序性：处理机的操作严格按照程序所规定的顺序执行。\r\n封闭性：程序一旦开始执行，其计算结果不受外界因素的影响\r\n\r\n-可再现性：程序执行的结果与它的执行速度无关(即与时间无关)，而只与初始条件有关。\r\n程序并发执行的特征\r\n\r\n间断(异步)性：“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；\r\n失去封闭性：共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征。\r\n失去可再现性：失去封闭性 -&gt;\r\n失去可再现性；外界环境在程序的两次执行期间发生变化，失去原有的可重复特征。并发程序执行的结果与其执行的相对速度有关，是不确定的\r\n\r\n进程的描述\r\n进程的定义与特征\r\n进程的引入：为了使多道程序能够并发执行，且为了能对并发执行程序加以描述和控制,以提高资源利用率和系统效率。\r\n进程的定义\r\n\r\n进程是具有独立功能的程序关于某个数据集合在计算机系统中的一次执行过程。是系统进行资源分配和调度的一个单位\r\n系统进行资源分配和调度的、一个可并发执行的独立单位。\r\n进程是程序的一个实例，是程序的一次执行\r\n\r\n进程和程序的比较\r\n\r\n程序是静态的，在外存中，进程是动态的，在内存中\r\n程序可长期保存；而进程是有生命周期的。\r\n程序是指令的有序集合；而进程则是由程序、数据和进程控制块三部分组成。\r\n进程和程序之间不是一一对应的：一个进程可以执行一个或多个程序，一个程序可以同时被多个进程执行。\r\n进程是一个独立运行的单位，也是系统进行资源分配和调度的独立单位，能与其他进程并发执行；而程序不能并发执行。\r\n\r\n进程的特征\r\n\r\n结构特征：由程序段、数据段及进程控制块（PCB）三部分构成，总称“进程映像”。进程控制块(PCB)\r\n+ 程序 + 数据 = 进程实体\r\n动态性：进程的实质是程序的一次执行过程，因而是动态的；进程具有生命周期。\r\n并发性：多个进程可以并发地执行。\r\n独立性：独立运行，独立获得资源。\r\n异步性：间断性。\r\n\r\n进程的基本状态与转换\r\n三种基本状态及其转换\r\n一个进程从创建、运行至消亡的整个生命周期，可以用一组状态加以刻画。\r\n一般来说,进程在执行过程中至少经历三种不同的进程状态：\r\n运行态（running）：占有处理机正在运行。\r\n就绪态（ready）：具备运行条件，等待系统分配处理机以便运行。\r\n阻塞态（blocked）：不具备运行条件，正在等待某个事件的发生\r\n三种基本状态的转换\r\n\r\n\r\nimage-20250505173410831\r\n\r\n创建状态和终止状态\r\n创建状态:\r\n\r\n为一个新进程创建PCB，并填写必要的管理信息；\r\n分配必要的资源，再把该进程转入就绪状态并插入就绪队列\r\n\r\n终止状态：\r\n\r\n等待操作系统进行善后处理；\r\n将其PCB清零，并将PCB空间返回系统\r\n\r\n挂起操作和进程状态的转换\r\n当该操作作用于某个进程时，该进程将被挂起，这意味这此时进程处于静止状态。\r\n挂起操作的引入：\r\n\r\n终端用户的请求\r\n父进程请求\r\n负荷调节的需要\r\n操作系统的需要\r\n\r\n\r\n\r\nimage-20250505173530843\r\n\r\n若原本处于就绪状态，则挂起后不接受调度\r\n阻塞变就绪需要释放资源，反过来就是请求资源\r\n静止变活动需要激活，反之就是挂起\r\n进程管理中的数据结构\r\nOS中用于管理资源和控制进程的数据结构\r\nOS管理的这些控制表一般可以分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，进程表又称为PCB。\r\nPCB的作用\r\nPCB的作用：\r\n​\r\n为了便于系统描述和管理进程的运行，在os的核心位每个进程定义了一个数据结构—PCB作为进程实体的一部分\r\n​\r\nPCB记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息\r\nPCB的作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位\r\n\r\n作为独立运行基本单位的标志。\r\n当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位了，即具有了取得OS服务的权利。\r\n系统是通过PCB来感知进程的存在的。也就是说，PCB已成为进程存在于系统中的唯一标志。\r\n实现间断性运行方式。\r\n系统就可以将CPU现场信息保存在被中断进程的PCB中，供该进程再次被调度运行而须恢复CPU现场信息时使用。\r\n提供进程管理所需要的信息。\r\n在进程的整个生命期中，OS总是根据PCB来实施对进程的控制和管理的\r\n提供进程调度所需要的信息。\r\n实现与其他进程的同步与通信。\r\n\r\nPCB中的信息\r\nPCB中的信息：\r\n\r\n进程标识符PID\r\n进程标识符用于唯一地标志一个进程。一个进程通常有两种标识符。\r\n\r\n\r\n外部标识符。为了方便用户（进程）对进程的访问\r\n内部标识符。为了方便系统对进程的使用\r\n\r\n\r\n处理机状态\r\n处理机状态信息，也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。\r\n\r\n\r\n通用寄存器，可被用户程序访问，用于暂存信息\r\n指令计数器，其中存放了要访问的下一条指令的地址；\r\n程序状态字寄存器，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；\r\n用户栈指针寄存器，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放进程和系统的调用参数及调用地址。\r\n\r\n\r\n进程调度信息\r\nOS在进行进程调度时，必须了解进程的状态以及有关进程调度的信息，这些信息包括：\r\n\r\n\r\n进程状态，指明进程的当前状态，作为进程调度和对换时的依据；\r\n进程优先级，描述进程使用处理机的优先级别（用一个整数表示），优先级高的进程应优先获得处理机；\r\n进程调度所需要的其他信息，如进程已等待CPU的时间总和、进程已执行时间总和等，它们与所采用的进程调度算法有关；\r\n事件，指进程由执行状态转换为阻塞状态所等待发生的事件，即阻塞原因。\r\n\r\n\r\n进程控制信息\r\n进程控制信息是指用于进程控制所必需的信息，包括：\r\n\r\n\r\n程序和数据的地址，即进程中程序和数据的内存或外存起始地址，便于再调度到该进程执行时，能从PCB中快速找到其程序和数据；\r\n进程同步和通信机制，这是实现进程同步和进程通信时所必需的机制，如消息队列指针、信号量等，它们可能会全部或部分放在PCB中；\r\n资源清单，在该清单中列出了进程在运行期间所需的全部资源（除CPU外）；\r\n链接指针，它给出了本进程所在队列中的下一个进程的PCB的始址。\r\n\r\nPCB的组成方式\r\n\r\n线性方式。将系统中所有的PCB都组织在一张线性表中，将该表的起始地址存放在内存的一个专用区域中。该方式实现简单且开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。\r\n链接方式。通过PCB中的链接字，将具有相同状态的进程的PCB分别链接成一个队列。\r\n索引方式。系统根据所有进程状态的不同，建立几张索引表，如就绪索引表、阻塞索引表等，并把各索引表在内存中的起始地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。\r\n\r\n进程控制\r\n进程控制是进程管理中最基本的功能，其负责创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、转换运行中进程的状态等，进程控制就是要实现进程状态转换\r\n进程控制一般是由OS内核中的原语（原子性操作，一旦开始不能停止）实现的\r\nOS内核主要功能\r\nOS内核：\r\n\r\n支撑功能\r\n\r\n中断处理：最基本功能\r\n时钟管理：\r\n原语操作\r\n\r\n资源管理功能\r\n\r\n进程的创建\r\n进程的层次结构：\r\n在OS中，允许一个进程创建另一个进程，子进程可以继续创建其自己的子进程（即父进程的孙进程），由此便形成了进程的层次结构\r\n引起进程创建的事件\r\n\r\n用户登录：在分时系统中，若登录成功，则系统将会为该用户创建一个进程，并把它插入就绪队列中。\r\n作业调度：在多道批处理系统中，当作业调度程序按一定的算法调度到某个（或某些）作业时，便会将它（们）装入内存、为它（们）创建进程，并把它（们）插入就绪队列中。\r\n提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来为用户提供其所需要的服务\r\n应用请求：由用户进程自己创建新进程，以使新进程以同创建进程并发执行的方式完成特定任务。\r\n\r\n操作系统发现要求创建新进程的事件后，调用进程创建原语Creat()创建新进程。\r\n进程的创建过程：\r\n申请空白PCB 为新进程分配资源 初始化进程控制块\r\n将新进程插入就绪队列\r\n进程的终止\r\n引起进程终止的事件\r\n（1）正常结束\r\n（2）异常结束\r\n（3）外界干预\r\n终止过程：\r\n①PCB集合中检索出该进程的PCB：并从该进程的PCB中读出该进程的状态\r\n②若被终止进程正处于执行状态，立即剥夺CPU\r\n③终止其所有子孙进程：以防止它们成为不可控的进程；\r\n④将被终止的进程所拥有的全部资源，或归还给其父进程，或归还给系统；\r\n⑤将被终止进程的PCB从所在队列（或链表）中移出：等待其他程序来搜集信息\r\n进程的阻塞与唤醒\r\n引起进程阻塞与唤醒的事件\r\n\r\n向系统请求共享资源失败\r\n等待某种操作的完成\r\n新数据尚未到达\r\n等待新任务的到达\r\n\r\n阻塞过程：\r\n\r\n调用阻塞原语block阻塞自己；\r\n将PCB中的状态改为阻塞，并加入阻塞队列；\r\n转调度程序进行重新调度\r\n\r\n进程的唤醒：\r\n\r\n调用wakeup原语唤醒等待该事件的进程\r\n阻塞进程从等待该事件的阻塞队列中移出；\r\n置进程状态为就绪态，将PCB插入到就绪队列中\r\n\r\n进程的挂起与激活\r\n进程的挂起过程：\r\n当出现引起进程挂起的事件时，系统利用挂起原语suspend将指定进程或处于阻塞的进程挂起。\r\n先检查被挂起进程的状态：\r\n\r\n若处于活动就绪，则改为静止就绪\r\n若处于活动阻塞，则改为静止阻塞；\r\n若挂起的进程正在执行，则重新进行进程调度\r\n\r\n进程的激活过程：\r\n\r\n当发生激活进程的事件时，系统利用激活原语active将指定进程激活\r\n激活原语先将进程从外存调入内存；\r\n然后检查该进程的状态：\r\n\r\n若为静止就绪，则改为活动就绪；\r\n若处于静止阻塞，则改为活动阻塞\r\n\r\n\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"有关事件独立性内容部分的说明","url":"/posts/16323.html","content":"什么是事件独立性\r\n若事件A，B 满足 P(AB) = P(A)P(B)\r\n则称事件 A 独立于事件 B\r\n这是证明两事件独立的唯一公式\r\n由此定义可知，若A独立于B，则必有B独立于A，从而A，B之间的独立性是相互的。以后就称A，B相互独立，或简称A，B独立。\r\n由此定义，若P(B) =\r\n0，则必有A独立于B。\r\n现将两个事件相互独立的概念推广到n(n ≥ 2)个事件的情形：\r\n设A1, A2, ⋯, An为n(n ≥ 2)个事件，若对其中任意一组事件Ai1, Ai2, ⋯, Aik(2 ≤ k ≤ n)，都有\r\nP(Ai1, Ai2, ⋯, Aik) = P(Ai1)P(Ai2)⋯P(Aik)\r\n再则由此定义即可推出如下定理：\r\n关于事件独立性的一些定理\r\n\r\n设P(B) &gt; 0，则A与B独立的充要条件是P(A|B) = P(A)。同理，若P(A) &gt; 0，则A与B独立的充要条件是 P(B|A) = P(B)\r\n若四对事件{A, B}，$\\{A,\\overline{B}\\}$，$\\{\\overline{A},B\\}$，$\\{\\overline{A},\\overline{B}\\}$中有一对事件相互独立（例如A与B独立），则其余三对事件亦相互独立。\r\n\r\n证明：\r\n设A与B相互独立，下证$\\overline{A}$，B相互独立。由于\r\n$$\r\n\\begin{align*}\r\nP(\\overline{A}B) &amp;= P(B - AB) = P(B) - P(AB)\\\\\r\n&amp;= P(B) - P(B)P(A)\\\\\r\n&amp;= P(B)(1 - P(A)) = P(B)P(\\overline{A})\r\n\\end{align*}\r\n$$ 从而可知$\\overline{A}$与B独立。其余结论即可推知。\r\n\r\n三个事件A，B，C相互独立是指下列等式同时成立：\r\n$$\r\n\\begin{cases}\r\nP(AB) = P(A)P(B)\\\\\r\nP(AC) = P(A)P(C)\\\\\r\nP(BC) = P(B)P(C)\\\\\r\nP(ABC) = P(A)P(B)P(C)\r\n\\end{cases}\r\n$$\r\n可见，三事件两两相互独立，不一定相互独立；反之，若三事件相互独立，则一定两两独立。从而当一组事件的个数超过了两个时，这组事件的相互独立与两两独立不是一个概念\r\n\r\n关于事件独立性的一些理解\r\n公式方面\r\n若事件A，B 满足 P(AB) = P(A)P(B)\r\n则称事件 A 独立于事件 B\r\n这是证明两事件独立的唯一公式，这一公式是两事件独立性的公理化定义，证明两事件独立时，必须且只能验证\r\nP(AB) 与\r\nP(A)P(B)\r\n是否相等\r\n任何关于独立性的证明或判断，必须回归到该公式的验证\r\n也就是说，事件 A 和 B\r\n同时发生的概率，等于各自发生概率的乘积，即 “A 的发生与否不影响\r\nB 的概率，反之亦然”\r\n而P(AB) = P(A)P(B)\r\n是两事件独立的充要条件，若仅知 P(B|A) = P(B)，需结合条件概率公式$P(B|A) = \\frac{P(AB)}{P(A)}$推导至 P(AB) = P(A)P(B)，本质仍依赖原公式；\r\n事件互斥与两事件独立的关系\r\n事件 “互斥”（AB = ⌀，即 P(AB) = 0）与\r\n“独立” 是不同概念：互斥时若 P(A) &gt; 0 且 P(B) &gt; 0，则 P(AB) = 0 ≠ P(A)P(B)，即互斥事件通常不独立（除非至少一个事件概率为\r\n0）。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n性质\r\n独立事件（P(AB) = P(A)P(B)）\r\n互斥事件（AB = ⌀，P(AB) = 0）\r\n\r\n\r\n\r\n\r\n概率关系\r\n允许 P(A) &gt; 0\r\n且 P(B) &gt; 0，此时\r\nP(AB) &gt; 0\r\n若 P(A) &gt; 0 且\r\nP(B) &gt; 0，则 P(AB) = 0\r\n\r\n\r\n事件关联\r\n事件发生概率无影响，可同时发生\r\n事件不能同时发生，概率上相互排斥\r\n\r\n\r\n例子\r\n抛两枚硬币，“第一枚正面” 与 “第二枚正面”\r\n抛一枚硬币，“正面” 与 “反面”\r\n\r\n\r\n\r\n而其中，一般情况下，互斥与独立互斥，很多人认为两个事件互不相容就必然相互独立，而这恰恰相反\r\n设 (Ω, ℱ, P)\r\n是一个概率空间，A, B ∈ ℱ 是两个事件\r\n互斥事件必不独立： $$\r\n\\begin{aligned}\r\n   &amp;P(A) &gt; 0,\\ P(B) &gt; 0\\ \\text{且}\\ A,B\\ \\text{互斥} \\\\\r\n   \\Rightarrow &amp;P(A \\cap B) = 0 \\neq P(A)P(B) &gt; 0 \\\\\r\n   \\Rightarrow &amp;A,B\\ \\text{不独立}\r\n   \\end{aligned}\r\n$$\r\n独立事件必不互斥： $$\r\n\\begin{aligned}\r\n   &amp;P(A) &gt; 0,\\ P(B) &gt; 0\\ \\text{且}\\ A,B\\ \\text{独立} \\\\\r\n   \\Rightarrow &amp;P(A \\cap B) = P(A)P(B) &gt; 0 \\\\\r\n   \\Rightarrow &amp;A \\cap B \\neq \\varnothing \\\\\r\n   \\Rightarrow &amp;A,B\\ \\text{不互斥}\r\n   \\end{aligned}\r\n$$ 特殊情况：当至少一个事件概率为 0 时 （P(A) = 0 或 P(B) = 0）\r\n\r\n若 A 与 B 互斥（P(AB) = 0），此时\r\nP(AB) = 0 = P(A)P(B)（因\r\nP(A) = 0 或 P(B) = 0），故\r\n互斥事件可能独立。\r\n例：设 A 为 “随机选一个数等于 0.5”（连续型随机变量中单点概率为\r\n0），B 为 “随机选一个数大于 0.6”，则 A 与 B 互斥且 P(A) = 0，满足 P(AB) = 0 = P(A)P(B)，即独立。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n情况\r\n条件\r\n互斥性\r\n独立性\r\n关系\r\n\r\n\r\n\r\n\r\n一般\r\nP(A), P(B) &gt; 0\r\nP(A ∩ B) = 0\r\nP(A ∩ B) = P(A)P(B)\r\n互斥 ⇒ 不独立独立 ⇒ 不互斥\r\n\r\n\r\n特殊\r\nP(A) = 0 或 P(B) = 0\r\nP(A ∩ B) = 0\r\nP(A ∩ B) = P(A)P(B)\r\n可能既互斥又独立\r\n\r\n\r\n\r\n不相关和独立性的区别和联系\r\n对于任意两个“不相关”的随机变量 X 和 Y（uncorrelated random\r\nvariables），两个变量的相关系数为0，也就意味着:\r\n\r\nρ(X, Y) = 0，而$_{XY}\r\n= $，所以当两个变量的相关系数为0时，两个变量的协方差也为0。\r\n\r\n而 若随机变量 X 和 Y 的协方差为 0（即 Cov(X, Y) = E[(X − E[X])(Y − E[Y])] = 0\r\n），或等价地，相关系数 ρXY = 0\r\n，则称$ X$ 和 Y 不相关。\r\n本质上，不相关描述的是随机变量间不存在线性关系，但不排除非线性关系的可能。可能X和Y没有线性关系，但是他们有别的形式的函数关系，因此，相关系数仅仅是两个随机变量之间线性相关程度的度量。\r\n而独立性就是 随机变量 X 和\r\nY\r\n的联合概率分布等于边缘概率分布的乘积（即对离散型 P(X = x, Y = y) = P(X = x)P(Y = y)\r\n；对连续型 f(x, y) = fX(x)fY(y)\r\n），则称 X 和 Y\r\n相互独立。独立性要求更严格，意味着随机变量间不存在任何关系（包括线性、非线性关系\r\n），一个变量的取值完全不影响另一个变量的概率分布。\r\n\r\n独立性是\r\n“强约束”：要求联合分布严格拆分，变量间无任何关联（线性、非线性均需独立\r\n）。\r\n不相关是 “弱约束”：仅排除线性关系，允许存在非线性关联（如 Y = X2 ，X 与 Y 不相关但非线性相关 ）。\r\n不相关聚焦线性关系：若 X、Y 不相关，仅说明 “Y 不能由 X 线性表示（如 Y ≠ aX + b\r\n）”，但可能有二次、三次等非线性依赖。\r\n独立性覆盖所有关系：若 X、Y 独立，则 Y 的取值概率与$ X$\r\n完全无关，无论线性还是非线性函数关系都不存在。\r\n\r\n所以，独立必不相关，不相关不一定独立\r\n\r\n独立 ⇒ 不相关（单向推导）\r\n若 X 和 Y 独立，根据期望的性质 E[XY] = E[X]E[Y]\r\n，代入协方差公式：Cov(X, Y) = E[XY] − E[X]E[Y] = 0\r\n因此，独立的随机变量一定不相关。\r\n不相关 () 独立（反例说明）\r\n不相关仅排除线性关系，仍可能存在非线性关联。例如：\r\n\r\n设 X ∼ U(−1, 1)（均匀分布\r\n）Y = X2\r\n。计算得 E[X] = 0，Cov(X, Y) = E[X ⋅ X2] − E[X]E[X2] = E[X3] − 0 = 0（因奇函数在对称区间积分\r\n0 ），故 X 与$ Y$ 不相关；但 Y 是 X 的非线性函数（Y = X2），显然不独立（已知\r\nX 可确定 Y 的分布 ）。\r\n\r\n\r\n因此，仅在二维正态分布中，不相关与独立等价；对其他分布，独立是比不相关更强的条件。\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","实用知识","数学","概率论与数理统计"]},{"title":"数据库相关概念与DBMS特色","url":"/posts/42089.html","content":"\r\n数据库相关概念\r\n数据管理\r\n\r\n\r\nimage-20250512195115041\r\n\r\n数据：能够被记录且具有实际含义的已知事实\r\n大数据\r\n元数据：描述数据的数据\r\n数据库管理系统 DBMS\r\n\r\n\r\nimage-20250512195253000\r\n\r\n数据库与文件系统的对比：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n文件系统\r\n数据库\r\n\r\n\r\n\r\n\r\n定义\r\n管理存储磁盘上数据的存储、访问和管理方式的过程\r\n可以轻松存储、访问、管理和更新的有组织的数据集合\r\n\r\n\r\n数据一致性\r\n数据不一致性高\r\n维护数据一致性\r\n\r\n\r\n结构\r\n简单\r\n复杂\r\n\r\n\r\n数据共享\r\n困难\r\n容易\r\n\r\n\r\n冗余\r\n冗余度高\r\n冗余度低\r\n\r\n\r\n安全性\r\n不是很安全\r\n更加安全\r\n\r\n\r\n备份与恢复\r\n没有备份和恢复过程\r\n有备份恢复过程\r\n\r\n\r\n\r\n数据库系统 DBS\r\n数据库系统是高效组织和管理数据的系统，由数据库、数据库管理系统和应用程序三部分构成。\r\n\r\n应用程序：应用程序提供了用户与数据库系统的交互界面。\r\n数据库管理系统：DBMS\r\n是一种通用的系统软件，可促进各种用户和应用程序之间数据库的组织、存储、控制和维护。\r\n数据库：数据库是一组经过组织、共享和持久化的相关数据。\r\n\r\nDBMS特色\r\nDBMS特色—数据独立性\r\n数据模型：数据模型是完成数据抽象的工具，即，用来描述数据、数据联系、数据语义以及一致性约束的一套概念工具。\r\n\r\n模型：模型是对研究对象进行抽象的工具，抽象的结果通常是可视化的图形。\r\n建模：建模是对研究对象进行抽象的过程。抽象就是对事物进行简化、提取特征或共性，实现模型和事物之间的映射或投影，等操作\r\n\r\n数据库设计过程：概念设计 逻辑设计 物理设计\r\n数据模型分类：\r\n\r\n概念模型：E-R 模型，UML 类模型\r\n逻辑模型：\r\n物理模型：Heap File 模型，ISAM 模型\r\n\r\n模式：模式是数据的定义和描述\r\n实例：实例则是模式在某一时刻的具体数据\r\n\r\n模式是元数据\r\n数据是变化的，模式是不变的\r\n数据库设计，数据库建模，实体 - &gt;模式\r\n数据库使用，创建数据库，模式 -&gt; 元组\r\n模式的层次，属性模式?:关系模式，数据库模式\r\n模式= 类型 + 约束 + 联系\r\n\r\n关系型数据库 ( SQL )\r\n\r\nMySQL , Oracle , SQL Server , SQLite , DB2 , …\r\n关系型数据库以表格形式组织数据，通过行和列存储信息，并且利用外键关联来建立表与表之间的关系。这种结构化的数据存储方式使得数据的查询、更新和管理变得高效且有组织。\r\n常见的关系型数据库有 MySQL、Oracle、SQL Server、SQLite、DB2 等\r\n\r\n非关系型数据库 ( NOSQL ) not only\r\n\r\nRedis , MongoDB , …\r\n非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定\r\n与关系型数据库的对比\r\n\r\n数据模型：关系型数据库采用表格形式，非关系型数据库有键值对、文档、列族、图等多种数据模型。\r\n扩展性：非关系型数据库更容易进行水平扩展，适合处理海量数据和高并发场景。\r\n一致性：关系型数据库强调强一致性，非关系型数据库通常采用最终一致性，以换取更高的性能和可扩展性。\r\n\r\n\r\nDBMS特色——数据库语言\r\n编程语言：SQL\r\n\r\nSQL的分类：\r\n\r\nDDL：数据定义语言 定义了不同的数据库，表，视图，索引等数据库对象\r\n还可以创建修改删除等操作数据库表的结构 CREATE  ALTER  DROP  RENAME\r\n TRUMCATE\r\nDML：数据操作语言 增删改查数据库记录 INSERT  DELETE  UPDATE\r\n SELECT\r\nDCL：数据控制语言 定义数据库，表，字段，用户访问权限和安全级别的\r\nCOMMIT  ROLLBACK  SAVEPOINT\r\nDQL：数据库查询语言 查询数据库中表的记录\r\n\r\n\r\n数学语言：关系代数\r\n\r\n关系的描述称为关系模式。它可以形式化地表示为\r\nR = (A, D, DOM, F)\r\n其中：\r\nR 为关系名\r\nA 为组成该关系的属性名集合\r\nD 为 A 中属性所来自的域\r\nDOM 为属性向域的映像集合\r\nF 为属性间数据的依赖关系集合\r\n关系代数的作用：\r\n\r\n为关系数据模型提供了操作的形式化语言\r\n\r\n能够用来做查询优化\r\n\r\n关系代数的运算和思想已经融入 SQL\r\n关系代数运算是评价 RDBMS 软件是否完备的标准\r\n关系代数明确的给出了查询的执行过程\r\n关系代数通常作为 DBMS 查询的内部实现\r\n\r\n\r\n设计语言：E - R图\r\n关系型数据库模式的评估：数据库的规范性设计需要分析关系中的属性在取值方面有什么依存关系?数据库设计过程中应遵循什么样的原则\r\n数据库设计理论\r\n\r\n数据依赖理论\r\n关系范式理论\r\n模式分解理论\r\n\r\n数据依赖：数据之间存在的各种联系和约束\r\n\r\n\r\nimage-20250512204835354\r\n\r\n\r\n定义：设 R(U) 是属性集 U 上的关系模式，X⊆U, Y⊆U。对于 R(U)\r\n的任意关系实例中的任意两个元组 t1 和 t2，如果由 t1[X] = t2[X] 可 以推出\r\nt1[Y]= t2[Y]，则称 X 函数决定 Y，或 Y 函数依赖于 X，记作 X→Y。\r\n关系模式 SDC(Sno, Sname, Sdept, Sdean, Cno, Grade)\r\n中的函数依赖：\r\n\r\nSno → Sname：一个学号只对应一个学生姓名\r\nSno → Sdept：一名学生只属于一个系\r\nSdept → Sdean：一个系只有一名系主任\r\nSno → Sdean：一名学生只对应一名系主任\r\n(Sno, Cno) → Grade：一名学生学习一门课程只有一个成绩\r\n\r\n函数依赖的关系：\r\n\r\n部分函数依赖：在关系模式 R(U) 中，如果 X → Y，且存在 X’ÌX，使得 X’ →\r\nY，则称 Y 部分函数依赖于 X，记作 X → Y\r\n\r\nØ传递函数依赖：在关系模式 R(U) 中，如果 X → Y，Y → Z，且 Y⊆X，Y →\r\nX，则称 Z 传递函数依赖于 X，记作 X → Z\r\n\r\n关系模式的范式：\r\n\r\n范式：在关系数据库规范化理论中，根据关系模式的规范化程度不同，把关系模式划分为若干类，称作范式（normal\r\nform）\r\n范式的级别：\r\n\r\n\r\nimage-20250512203705344\r\n\r\n在函数依赖的范畴内，我们只讨论 1NF、2NF、3NF\r\n\r\n第一范式：如果关系模式 R 的每个属性都是不可分的，则称 R\r\n为第一范式关系模式，记作R∈1NF\r\n第二范式：如果关系模式 R∈1NF，且 R 的每个非主属性都完全函数依赖于 R\r\n的候选键，则称 R 为第二范式关系模式，记作 R∈2NF\r\n\r\n关系模式出现问题解决方法：消除非主属性对候选键的部分函数依赖\r\n\r\n第三范式：如果关系模式 R∈2NF，且 R 的每个非主属性都不传递函数依赖于\r\nR 的候选键，则称 R 为第三范式关系模式，记作 R∈3NF\r\n\r\n关系模式出现问题解决方法：消除非主属性对候选键的传递函数依赖\r\n\r\n\r\n\r\n设计语言：E - R图\r\nE-R模型：\r\n实体-联系模型中主要有三个概念：实体集，属性，联系集\r\n一个实体集对应数据库中的一个表，一个实体则对应数据库表中的一行，一个属性对应数据表中的一列\r\n实体 - 联系模型（E - R\r\n模型）是一种用于数据库设计的概念模型，主要有三个核心概念：实体集、属性和联系集。\r\n\r\n实体集：对应数据库中的一个表，代表一类具有相同属性的实体。例如，在一个学校管理系统中，“学生”\r\n是一个实体集，它包含了所有学生的信息。\r\n属性：对应数据表中的一列，用于描述实体的特征。对于\r\n“学生” 实体集，“学号”、“姓名”、“年龄” 等都是属性。\r\n联系集：表示实体集之间的关系。例如，“学生”\r\n实体集和 “课程” 实体集之间存在 “选课” 联系。\r\n\r\nE-R图：\r\n\r\n实体-联系模型：是概念数据库设计阶段使用的一种重要模型，用于将现实世界抽象为实体及实体间的联系\r\nE-R 模型提供了数据建模所需的多种概念\r\n\r\n与实体（entity）相关的概念：\r\n\r\n实体 属性 键 实体型 实体集 弱实体型\r\n实体：数据库中表示的现实世界中的具体对象或事物\r\n属性：用于刻画实体的特性\r\n\r\n简单属性：具有原子属性值的属性，其属性值不可再分\r\n复合属性：由多个成分构成的属性\r\n多值属性：一个实体可具有多个值的属性\r\n派生属性：由其他属性派生出来的属性\r\n键属性：同一实体型的任意实体都具有不同值的属性\r\n复合属性和多值属性可以是相互嵌套的\r\n\r\n\r\n与联系（relationship）相关的概念\r\n\r\n联系：一个联系表示多个实体之间有意义的关联关系\r\n联系型：同一类联系共同具有的类型\r\n联系 联系型 联系集 联系型的约束 联系型的属性 多元联系\r\n\r\n\r\n实体型的 E-R 图表示：\r\n\r\n实体型表示为矩形\r\n属性表示为椭圆\r\n\r\n简单属性表示为实线椭圆\r\n多值属性表示为双实线椭圆\r\n派生属性表示为虚线椭圆\r\n键属性的属性名加下划线\r\n\r\n实体型与其属性用线连接起来\r\n\r\n\r\n\r\nimage-20250512201853388\r\n\r\n联系型的 E-R 图表示：\r\n\r\n联系型表示为菱形\r\n\r\n\r\nimage-20250512201842310\r\n\r\n联系型可以具有属性\r\n用直线将联系型与参与到联系型中的实体型连接起来\r\n在 E-R 图中，用直线将联系型与联系型的属性连接起来\r\n\r\n\r\nimage-20250512202121852\r\n\r\n多对一举例：\r\n\r\n\r\nimage-20250512201940249\r\n\r\n多对多举例：\r\n\r\n\r\nimage-20250512201959282\r\n\r\n\r\n实体型的转换：\r\n\r\n转换规则\r\n实体型的名称 → 关系名\r\n实体型的属性集 → 关系的属性集（多值属性除外）\r\n实体型的主键 → 关系的主键\r\n实体 → 元组\r\n\r\n\r\nimage-20250512202417693\r\n\r\nM-N二元联系型的转换：\r\n转换规则：为联系型创建一个新的关系模式\r\n​ 关系模式的属性集包括：与该联系相关的两个实体型的主键（如图中\r\nemployee 的主键 SSN 和 project\r\n的主键 Number ） ，以及联系型本身的属性（图中\r\nworks_on 联系型的属性 Hours ）。\r\n​ 新关系模式的主键由两个实体型的主键组合而成（图中\r\nworks_on 关系模式的主键为 SSN 和\r\nNumber\r\n\r\n\r\nimage-20250512202844414\r\n\r\n\r\n\r\nimg\r\n\r\n1:1 二元联系型的转换\r\n\r\n\r\nimage-20250512203251603\r\n\r\n\r\n\r\nimage-20250512204048887\r\n\r\nN:1 二元联系型的转换\r\n\r\n\r\nimage-20250512203008930\r\n\r\n\r\n\r\nimage-20250512204227234\r\n\r\n\r\n\r\n关系数据模型\r\n关系模型三要素：\r\n\r\n关系数据结构\r\n完整性约束\r\n关系操作\r\n\r\n\r\n\r\nimage-20250512205709773\r\n\r\n\r\n\r\nimage-20250512205715465\r\n\r\n码：关系中某些属性集合具有区分不同元组的作用，称为码\r\n\r\n超码：如果关系的某一组属性的值能唯一标识每个元组，则称该组属性为超码（super\r\nkey）。\r\n候选码：如果一个超码的任意真子集都不是超码，则称该超码为候选码。候选码是极小的超码。\r\n主键：每个关系都有至少一个候选码，人为指定其中一个作为主键\r\n外码：设 F 是关系 R 的属性子集。若 F 与关系 S 的主键 K\r\n相对应，则称 F 是 R 的外键（foreign key）。\r\n\r\nDBMS特色——事务处理\r\n事务是一组操作的组合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销，这些操作要么同时成功要么同时失败\r\n事务四大特性：\r\n\r\n原子性A：事务是不可分割的最小操作单元，要么全成功，要么全失败\r\n一致性C：事务完成时，必须所有数据都保持一致状态\r\n隔离性I：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下进行\r\n持久性D：事务一旦提交或回滚，他对数据库的改变是永久的\r\n\r\n","categories":["计算机理论","数据库理论"],"tags":["学习类","计算机理论技术","数据库","计算机理论知识"]},{"title":"概率密度函数与累积分布函数","url":"/posts/56654.html","content":"这俩函数都是什么\r\n先说点别的\r\n随机变量的本质是？\r\n我下面一条条说\r\n\r\n其实就是一个取值个数 &gt;= 2\r\n的变量，而且这个变量的取值不固定，要不然怎么叫随机\r\n不固定的意思是，每个取值都有可能出现，但具体出现哪个，是不固定的\r\n正因此，随机变量还可以是个函数，由于每个随机结果都有一个唯一的数字与之对应，所以随机变量X就符合了函数的定义\r\n就有了关于随机变量的定义\r\n\r\n设E为随机试验，Ω = ω为其样本空间，若对任意\r\nω ∈ Ω，有唯一实数X(ω)与之对应，则称X(ω)为随机变量\r\n\r\n\r\n那么离散型随机变量的本质就很明显了\r\n\r\n随机变量的每个取值，都可以被列举出来，但是可以有无数个\r\n\r\n连续性随机变量就是\r\n\r\n随机变量的每个取值，根本无法列举出来，因为连续型变量的取值是一个实数区间\r\n\r\n那么概率函数和概率分布这些前缀又如何解释\r\n\r\n概率函数，顾名思义，用函数的形式来表达概率，拥有函数的性质，概率函数一次只能一个取值的概率\r\n概率分布，顾名思义，就是概率的分布，还是讲的”概率”，不过侧重点在于”分布”，如果你的随机变量是离散型的，那么概率分布就可以写成一个分布列，如果你的随机变量是连续型的，那么就会写成概率分布函数\r\n\r\n那么什么是概率密度函数\r\n\r\n离散型的不叫这个名，叫概率质量函数，而连续型随机变量才用概率密度函数（PDF）。其作用是给出随机变量每一个可能取值对应的概率\r\nP(X = xi)，具体的表现就是离散型随机变量函数的分布列，必须满足所有概率之和为1，且对不在定义域内的\r\nx，有 P(X = x) = 0。”\r\n而连续型随机变量才用概率密度函数（PDF），为什么是密度，因为由于连续型变量的取值是一个实数区间，如果把这个区间均分成多少份，则可无限细分下去\r\n而概率密度函数，就是描述连续性随机变量取值情况的一个函数罢了，通过它是求不出概率值的，要求具体的概率值，要通过概率分布函数\r\n概率密度函数是概率分布函数F(X)的导数，F′(X) = f(x)，所以概率分布函数是概率密度函数的积分，F(x) = P(X ≤ x) = ∫−∞xf(t) dt\r\n\r\n什么是概率分布函数\r\n\r\n概率分布函数，也叫概率的累积分布函数，累积分布函数，重点是累积\r\n分布函数F(x) = P(X ≤ x)中，x是自变量，X是随机变量，分布函数求出来的是一个概率值，是0 ≤ F(x) ≤ 1，因此求出来的概率值是：随机变量X\r\n的全部可能取值位于x\r\n左侧的概率和，所以分布函数，也可称为：累积分布函数。\r\n\r\n那么上述都是一个变量的情况，两个或者多个变量的联合分布也是这样吗？\r\n随机变量就是二维或者多维的情况下，本质上，多个随机变量视作为一个整体，那么此时讨论与理解的情况与上述一维的差异就不是很明显了。\r\n这就是为什么，多维的联合随机变量，包括他们涉及到的联合概率分布列，联合概率分布函数，前面为什么都有联合二字了。\r\n概率密度函数与概率分布函数的关系\r\n进入正题。\r\n概率密度函数\r\n概率密度函数的定义\r\n对于连续型随机变量 X，其概率密度函数 f(x)\r\n是一个满足以下两个条件的可测函数：\r\n\r\n非负性条件 f(x) ≥ 0  对所有 x ∈ ℝ\r\n归一化条件 ∫−∞+∞f(x) dx = 1\r\n\r\n根据上述定义，可以反映出概率密度函数的密度意义：f(x) 反映概率在 x 处的”密集程度”，而非直接概率值\r\n以上的一维的情况，下述为二维联合概率密度函数的定义\r\n设连续型随机变量 (X, Y) 的联合分布函数为\r\nF(x, y)，若存在非负可测函数\r\nf(x, y)，使得对任意实数\r\nx, y，满足： F(x, y) = ∫−∞y∫−∞xf(u, v) du dv\r\n则称 f(x, y)\r\n为 (X, Y)\r\n的二维联合概率密度函数，满足以下性质：\r\n\r\n非负性：f(x, y) ≥ 0，对所有\r\n(x, y) ∈ ℝ2；\r\n归一化条件： ∫−∞+∞∫−∞+∞f(x, y) dx dy = 1\r\n\r\n若再扩展涉及到多维的话\r\n若存在 f(x) ≥ 0 使得：\r\nF(x) = ∫−∞x1⋯∫−∞xnf(t1, …, tn) dt1⋯dtn\r\n则称 f 为联合\r\nPDF。此时边缘密度为： $$\r\nf_{X_i}(x_i) = \\int_{\\mathbb{R}^{n-1}} f(\\mathbf{x}) \\prod_{\\substack{j\r\n\\neq i}} dx_j\r\n$$ 以下等价：\r\n\r\n联合 CDF 可分解：$F_{\\mathbf{X}}(\\mathbf{x}) = \\prod_{i=1}^n\r\nF_{X_i}(x_i)$\r\n联合 PDF 可分解：$f_{\\mathbf{X}}(\\mathbf{x}) = \\prod_{i=1}^n\r\nf_{X_i}(x_i)$\r\n对离散型：$P(\\mathbf{X} = \\mathbf{x}) =\r\n\\prod_{i=1}^n P(X_i = x_i)$\r\n\r\n核心作用\r\n通过积分计算概率： P(a ≤ X ≤ b) = ∫abf(x) dx\r\n即：概率等于概率密度函数在该区间上的定积分。\r\n连续型随机变量的定义\r\n所以，可以由上述概率密度函数的定义得到连续型随机变量的定义\r\n对于随机变量X，若存在非负可积函数f(x)（f(x)为X的概率密度函数\r\n），使得对任意实数x，其分布函数 F(x) = ∫−∞xf(t)dt\r\n则称X为连续型随机变量 。f(x)的图形为概率密度曲线\r\n概率密度函数的性质\r\n\r\n非负性（基本性质） f(x) ≥ 0  对所有 x ∈ ℝ\r\n\r\n概率密度不可能为负值\r\n违反此条件的函数不能作为PDF\r\n\r\n规范性（基本性质） ∫−∞+∞f(x) dx = 1\r\n\r\n全空间概率总和必须为1\r\n归一化验证：新构建的PDF必须验证积分是否为1\r\n\r\n概率计算特性\r\n对任意区间[a, b]\r\nP(a ≤ X ≤ b) = ∫abf(x) dx\r\n\r\n单点概率：P(X = c) = 0\r\n开区间与闭区间概率相同： P(a &lt; X &lt; b) = P(a ≤ X ≤ b)\r\n\r\n单点概率 P(X = a) = ∫aaf(x) dx = 0\r\n与概率分布函数的关系\r\n\r\nCDF(分布函数)是PDF(概率密度函数)的积分 F(x) = ∫−∞xf(t) dt\r\nPDF是CDF的导数（几乎处处成立）： $$\r\nf(x) = \\frac{d}{dx} F(x)\r\n$$ 例外点：CDF不可导处（如均匀分布的边界）\r\n\r\n这就是文章本来想要写的初衷（（\r\n相对概率意义： $$\r\n\\frac{f(x_1)}{f(x_2)} \\text{ 反映 } x_1 \\text{ 与 } x_2 \\text{\r\n处的概率密度比}\r\n$$\r\n变换不变性：\r\n若 Y = g(X) 且 g 是严格单调可导函数 $$\r\nf_Y(y) = f_X\\left(g^{-1}(y)\\right) \\cdot \\left| \\frac{d}{dy} g^{-1}(y)\r\n\\right|\r\n$$ 特别地，线性变换 Y = aX + b：\r\n$$\r\nf_Y(y) = \\frac{1}{|a|} f_X\\left( \\frac{y - b}{a} \\right)\r\n$$\r\n独立性依据 fX, Y(x, y) = fX(x)fY(y) ⇔ X, Y独立\r\n边缘密度\r\n一维情况的如下 fX(x) = ∫−∞+∞fX, Y(x, y) dy\r\n而其中，从联合 PDF 中消去另一个变量，可以得到单个变量的概率密度函数\r\n\r\nX 的边缘密度：fX(x) = ∫−∞+∞f(x, y) dy\r\nY 的边缘密度：fY(y) = ∫−∞+∞f(x, y) dx\r\n\r\n矩生成特性\r\n\r\nk 阶原点矩：E[Xk] = ∫−∞+∞xkf(x) dx\r\n方差计算：D(X) = E[X2] − (E[X])2\r\n\r\n条件概率密度函数\r\n\r\n给定 X = x 时，Y 的条件密度：\r\n若 fX(x) &gt; 0，则\r\n$$\r\nf_{Y|X}(y|x) = \\frac{f(x,y)}{f_X(x)}\r\n$$ 解释：在 X 固定为 x 的条件下，Y 的概率密度分布。\r\n给定 Y = y 时，X 的条件密度：\r\n若 fY(y) &gt; 0，则\r\n$$\r\nf_{X|Y}(x|y) = \\frac{f(x,y)}{f_Y(y)}\r\n$$\r\n条件密度函数的性质也遵循两个基本性质\r\n\r\n非负性：fY|X(y|x) ≥ 0；\r\n归一化：∫−∞+∞fY|X(y|x) dy = 1\r\n\r\n\r\n多维随机变量的独立性判定\r\n随机变量 X 和$ Y$\r\n独立的充要条件为：\r\n\r\n联合 PDF 可分解为边缘 PDF 的乘积：f(x, y) = fX(x) ⋅ fY(y)  对所有\r\n(x, y)\r\n联合分布函数可分解为边缘分布函数的乘积：F(x, y) = FX(x) ⋅ FY(y)\r\n条件密度等于边缘密度：fY|X(y|x) = fY(y)  或  fX|Y(x|y) = fX(x)\r\n\r\n二维随机变量的函数变换\r\n\r\n和的分布：Z = X + Y\r\n若 X 和 Y 独立，联合 PDF 为 f(x, y) = fX(x)fY(y)，则\r\nZ 的 PDF 为： fZ(z) = ∫−∞+∞fX(x)fY(z − x) dx  (卷积公式)\r\n离散的情况： PZ(z) = ∑xPX(x) ⋅ PY(z − x)\r\n\r\n求和范围为所有满足 z − x 是 $Y $可能取值的\r\nx。本质上是离散形式的卷积\r\n\r\n商的分布：$Z =\r\n\\frac{X}{Y}$\r\n设 Y ≠ 0，则$ Z 的PDF为：$\r\nf_Z(z) = _{-}^{+} |y| f_X(zy)f_Y(y) , dy $$ 离散的情况：\r\nY ≠ 0，且 Z 的可能取值为 $z = \\frac{x}{y}$（$x $ 为 $ X$ 的取值，y 为 Y 的非零取值），则 Z 的 PMF 为： $$\r\nP_Z(z) = \\sum_{\\substack{y: y \\neq 0 \\\\ x = zy}} P_X(zy) \\cdot P_Y(y)\r\n$$\r\n\r\n求和范围为所有非零 y\r\n且满足 zy 是 X 的可能取值。\r\n\r\n一般变换：U = g(X, Y), V = h(X, Y)\r\n若变换 (g, h)\r\n是一一映射且可微，雅可比行列式为： $$\r\nJ = \\frac{\\partial(x,y)}{\\partial(u,v)} = \\begin{vmatrix} \\frac{\\partial\r\nx}{\\partial u} &amp; \\frac{\\partial x}{\\partial v} \\\\ \\frac{\\partial\r\ny}{\\partial u} &amp; \\frac{\\partial y}{\\partial v} \\end{vmatrix}\r\n$$ 则联合 PDF 为： fU, V(u, v) = fX, Y(x(u, v), y(u, v)) ⋅ |J|\r\n离散的表达情况如下：\r\n\r\n变换 (g, h)\r\n是一一映射（即对每个 (u, v)，存在唯一 (x, y) 满足u = g(x, y), v = h(x, y)，则联合\r\nPMF 为： PU, V(u, v) = PX, Y(x(u, v), y(u, v)\r\n若变换非一一映射（如多个 (x, y) 对应同一 (u, v)），则需累加所有对应\r\n(x, y) 的概率： $$\r\nP_{U,V}(u, v) = \\sum_{\\substack{(x,y): \\\\ g(x,y)=u, \\, h(x,y)=v}}\r\nP_{X,Y}(x, y)\r\n$$\r\n\r\n\r\n二维情况下的矩和协方差\r\n\r\n**$k+l 阶联合原点矩 * *：$\r\nE[X^k Y^l] = {-}^{+} {-}^{+} x^k y^l f(x,y) , dx , dy\r\n$$\r\n数学期望（均值） E[X] = ∫−∞+∞xfX(x) dx = ∫−∞+∞∫−∞+∞xf(x, y) dx dy\r\nE[Y] = ∫−∞+∞yfY(y) dy = ∫−∞+∞∫−∞+∞yf(x, y) dx dy\r\n协方差（Covariance） Cov(X, Y) = E[(X − E[X])(Y − E[Y])] = E[XY] − E[X]E[Y]\r\n性质：\r\n\r\n若 X 和 Y 独立，则 Cov(X, Y) = 0（反之不一定成立）；\r\nD(X + Y) = D(X) + D(Y) + 2Cov(X, Y)。\r\n\r\n相关系数（Correlation Coefficient）： $$\r\n\\rho_{X,Y} = \\frac{\\text{Cov}(X,Y)}{\\sqrt{\\text{Var}(X)\\text{Var}(Y)}}\r\n$$ 性质：ρX, Y ∈ [−1, 1]，反映\r\nX 和 Y 的线性相关程度。\r\n\r\n\r\n概率分布函数（累积分布函数）（CDF）\r\n概率分布函数的定义\r\n概率分布函数（Cumulative Distribution Function,\r\nCDF）是描述随机变量取值不超过某数的概率的函数。对于随机变量 X，其CDF定义为： FX(x) = P(X ≤ x)\r\n以上是一维的情况，涉及到多维的情况如下，以二维为例，二维联合分布函数的定义如下\r\n设 (X, Y)\r\n是二维随机变量，对于任意实数$ x$ 和 y，二元函数 FX, Y(x, y) = P(X ≤ x, Y ≤ y)\r\n称为二维随机变量 (X, Y)\r\n的联合分布函数（也简称分布函数 ）。\r\n其直观意义：表示随机点 (X, Y) 落在平面区域 {(u, v) ∣ u ≤ x, v ≤ y}\r\n内的概率。\r\n核心性质\r\n\r\n单调不减性\r\n若 x1 &lt; x2，则\r\nF(x1) ≤ F(x2)\r\n，也就是F(x)是x的非降函数\r\n即分布函数是单调不减函数，反映随机变量取值越大，“不超过该值”\r\n的概率不会减小。\r\n\r\n推论：P(a &lt; X ≤ b) = F(b) − F(a)\r\n利用分布函数计算随机变量 X\r\n落在区间 (a, b]\r\n内的概率，是通过分布函数在区间端点的函数值之差来实现，是连续型与离散型随机变量通用的概率计算方式（结合分布函数定义推导得出\r\n）。\r\n\r\n二维的情况如下\r\n\r\n对 x 单调不减：若 x1 &lt; x2，则\r\nF(x1, y) ≤ F(x2, y)；\r\n对 y 单调不减：若 y1 &lt; y2，则\r\nF(x, y1) ≤ F(x, y2)。\r\n\r\n右连续性 $$\r\n\\lim_{x \\to x_0^+} F(x) = F(x_0)\\\\\r\n\\textbf{注意：} 对于离散型变量，\\text{CDF} 是右连续的阶梯函数\r\n$$ 分布函数 F(x) 在 x0 处的右极限等于 F(x0)，体现分布函数的右连续性。\r\n二维的情况如下 $$\r\n\\lim_{\\substack{x \\to x_0^+ \\\\ y \\to y_0^+}} F(x,y) = F(x_0,y_0)\r\n$$\r\n即对每个变量均右连续（离散型表现为阶梯函数的右连续跳跃）。\r\n边界极限 $$\r\nF(-\\infty) = \\lim_{x \\to -\\infty} P(X\\le x) = 0  \\\\ F(+\\infty) = \\lim_{x\r\n\\to +\\infty}  P(X\\le x) = 1\r\n$$ 二维的情况如下： $$\r\n\\begin{align*}\r\nF(-\\infty, y) &amp;= 0, \\quad F(x, -\\infty) = 0, \\\\\r\nF(-\\infty, -\\infty) &amp;= 0, \\quad F(+\\infty, +\\infty) = 1.\r\n\\end{align*}\r\n$$\r\n概率计算：\r\n\r\n单侧概率 P(X &gt; x) = 1 − F(x)\r\n区间概率 P(a &lt; X ≤ b) = F(b) − F(a)\r\n\r\n离散型 vs 连续性 CDF\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特征\r\n离散型随机变量\r\n连续型随机变量\r\n\r\n\r\n\r\n\r\n函数图像\r\n阶梯函数\r\n连续曲线\r\n\r\n\r\n跳跃点\r\n在取值点处跳跃\r\n无跳跃（绝对连续）\r\n\r\n\r\n与PMF/PDF关系\r\nF(x) = ∑xi ≤ xpi\r\nF(x) = ∫−∞xf(t) dt\r\n\r\n\r\n单点概率\r\nP(X = x) = F(x) − F(x−)\r\nP(X = x) = 0\r\n\r\n\r\n\r\n对于随机向量(X, Y)的联合分布，其中CDF为\r\nFX, Y(x, y) = P(X ≤ x, Y ≤ y)\r\n\r\n边缘分布 $$\r\nF_X(x) = \\lim_{y \\to \\infty} F_{X,Y}(x, y) = P(X \\le x) \\\\\r\nF_Y(y) = \\lim_{x \\to \\infty} F_{X,Y}(x, y) = P(Y \\le y)\r\n$$\r\n独立性随机变量的联合分布性质（若X，Y独立) FX, Y(x, y) = FX(x)FY(y)\r\n\r\n概率计算定理 P(X ∈ (a, b]) = F(b) − F(a)\r\n特别地，对连续型变量\r\n\r\nP(X ∈ A) = ∫AdF(x)\r\n\r\n矩形不等式（二维）\r\n对任意 a &lt; b, c &lt; d，有：\r\nP(a &lt; X ≤ b, c &lt; Y ≤ d) = F(b, d) − F(b, c) − F(a, d) + F(a, c) ≥ 0\r\n该式确保概率非负，是联合 CDF 存在的必要条件。\r\n二维情况下的独立性判定\r\n随机变量 X 和 Y 独立的充要条件为\r\n\r\n联合 CDF 分解为边缘 CDF 的乘积： FX, Y(x, y) = FX(x) ⋅ FY(y)  对所有\r\n(x, y)\r\n等价条件（与 PDF 关联）：\r\n\r\n若 (X, Y)\r\n是连续型，则 f(x, y) = fX(x)fY(y)；\r\n若 (X, Y)\r\n是离散型，则 P(X = x, Y = y) = P(X = x)P(Y = y)。\r\n\r\n\r\n二维 CDF 的概率计算\r\n\r\n矩形区域概率 P(a &lt; X ≤ b, c &lt; Y ≤ d) = F(b, d) − F(b, c) − F(a, d) + F(a, c)\r\n单侧概率 P(X &gt; x, Y &gt; y) = 1 − F(x, +∞) − F(+∞, y) + F(x, y)\r\nP(X ≤ x, Y &gt; y) = F(x, +∞) − F(x, y)\r\n连续型与 PDF 的关系 若联合 PDF 存在，则： $$\r\nf_{X,Y}(x,y) = \\frac{\\partial^2 F_{X,Y}(x,y)}{\\partial x \\partial y}\r\n$$ （在二阶偏导数存在的点成立）。\r\n\r\n二维 CDF 的函数分布（通过 CDF 求解）\r\n\r\n和的分布：(Z = X + Y) FZ(z) = P(X + Y ≤ z) = ∬x + y ≤ zfX, Y(x, y) dx dy\r\n若 (X,Y) 独立，则： FZ(z) = ∫−∞+∞FX(z − y)fY(y) dy  (卷积形式)\r\n离散情况下：\r\n若 X 和 Y 独立，联合 PMF 为 p(x, y) = pX(x)pY(y)，则\r\nZ 的 PMF 为： $$\r\np_Z(z) = \\sum_{x=-\\infty}^{+\\infty} p_X(x)p_Y(z-x) \\quad\r\n(\\text{离散卷积公式})\r\n$$ 那么可以推导出其CDF： $$\r\nF_Z(z) = P(X + Y \\leq z) = \\sum_{k=-\\infty}^z p_Z(k) =\r\n\\sum_{x=-\\infty}^{+\\infty} \\sum_{y=-\\infty}^{z-x} p_X(x)p_Y(y)\r\n$$ 若 X, Y\r\n独立，可简化为：$F_Z(z) =\r\n\\sum_{y=-\\infty}^{+\\infty} F_X(z - y)p_Y(y)$\r\n商的分布（$Z =\r\n\\frac{X}{Y}$（需考虑 Y = 0 时概率为\r\n0，其实就不应该存在）\r\n连续情况下：\r\n\r\n当 Y &gt; 0 时，$\\frac{X}{Y} \\leq z \\iff X \\leq\r\nzY$；\r\n当 Y &lt; 0 时，$\\frac{X}{Y} \\leq z \\iff X \\geq\r\nzY$（不等式变号）。\r\n因此，FZ(z)\r\n可表示为： $$\r\nF_Z(z) = \\iint_{\\substack{x \\leq zy \\\\ y &gt; 0}} f(x,y) \\, dx dy +\r\n\\iint_{\\substack{x \\geq zy \\\\ y &lt; 0}} f(x,y) \\, dx dy\r\n$$\r\n转换为累次积分 FZ(z) = ∫0+∞[∫−∞zyf(x, y) dx]dy + ∫−∞0[∫zy+∞f(x, y) dx]dy\r\n对 z 求导得到密度函数 fZ(z)：\r\n利用积分上限函数求导法则，得： fZ(z) = ∫0+∞yf(zy, y) dy + ∫−∞0(−y)f(zy, y) dy = ∫−∞+∞|y|f(zy, y) dy\r\n若 X 和 Y 独立，联合密度 f(x, y) = fX(x)fY(y)，则商的\r\nCDF 可写为 FZ(z) = ∫0+∞FX(zy)fY(y) dy + ∫−∞0[1 − FX(zy)]fY(y) dy\r\n\r\n离散情况下：\r\n对 Y 的所有非零取值 y，若 x = z ⋅ y 为 X 的可能取值，则累加 p(zy, y)，即：\r\n$$\r\np_Z(z) = \\sum_{\\substack{y: y \\neq 0 \\\\ zy \\in X\\text{的取值}}} p(zy, y)\r\n$$\r\n最大值 / 最小值分布\r\n连续情况下\r\n\r\n最大值：Z = max (X, Y)\r\nFZ(z) = P(X ≤ z, Y ≤ z) = FX, Y(z, z)\r\n最小值：Z = min (X, Y)（若\r\n(X, Y) 独立）FZ(z) = 1 − [1 − FX(z)][1 − FY(z)]\r\n\r\n离散情况下：\r\n\r\n最大值：Z = max (X, Y)：\r\nFZ(z) = P(max (X, Y) ≤ z) = P(X ≤ z, Y ≤ z) = FX, Y(z, z)\r\n若 X, Y\r\n独立，则：FZ(z) = FX(z)FY(z)\r\n最小值：（若 (X, Y) 独立） FZ(z) = P(min (X, Y) ≤ z) = 1 − P(min (X, Y) &gt; z) = 1 − [1 − FX(z)][1 − FY(z)]\r\n\r\n\r\n一维与二维 CDF 关键差异对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n一维 CDF\r\n二维 CDF\r\n\r\n\r\n\r\n\r\n概率区域\r\n区间 ((-, x])\r\n矩形区域 ((-, x] (-, y])\r\n\r\n\r\n独立性判定\r\n无（单变量）\r\n(F(x,y)=F_X(x)F_Y(y))\r\n\r\n\r\n概率计算\r\n(F(b)-F(a))\r\n矩形不等式组合\r\n\r\n\r\n\r\n\r\n典型分布\r\n\r\n标准正态分布 $$\r\n\\Phi(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} e^{-t^2/2} dt\r\n$$ 性质：Φ(−x) = 1 − Φ(x)\r\n指数分布 Exp(λ)\r\nF(x) = 1 − e−λx  (x ≥ 0)\r\n无记忆性性质：P(X &gt; s + t|X &gt; s) = P(X &gt; t)\r\n离散均匀分布 $$\r\nF(k) = \\frac{\\lfloor k \\rfloor}{n} \\quad (k = 1, 2, ..., n)\r\n$$\r\n二维均匀分布\r\n设 (X, Y) 在区域\r\nD ⊆ ℝ2\r\n上均匀分布，面积为 SD，则： $$\r\nF(x,y) = \\frac{1}{S_D} \\times \\text{区域 } D \\cap \\{u \\leq x, v \\leq y\\}\r\n\\text{ 的面积}\r\n$$\r\n二维正态分布\r\n若 (X, Y) ∼ N(μX, μY, σX2, σY2, ρ)，有\r\n$$\r\nf(x, y) = \\frac{1}{2\\pi\\sigma_X\\sigma_Y\\sqrt{1-\\rho^2}} \\exp\\left\\{\r\n-\\frac{1}{2(1-\\rho^2)} \\left[ \\left( \\frac{x-\\mu_X}{\\sigma_X} \\right)^2\r\n- 2\\rho\\left( \\frac{x-\\mu_X}{\\sigma_X} \\right)\\left(\r\n\\frac{y-\\mu_Y}{\\sigma_Y} \\right) + \\left( \\frac{y-\\mu_Y}{\\sigma_Y}\r\n\\right)^2 \\right] \\right\\}\r\n$$ 其中\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数\r\n符号\r\n取值范围\r\n物理意义\r\n\r\n\r\n\r\n\r\nX的均值\r\nμX\r\n(−∞, +∞)\r\n随机变量X的数学期望，决定分布在x轴上的中心位置。\r\n\r\n\r\nY的均值\r\nμY\r\n(−∞, +∞)\r\n随机变量Y的数学期望，决定分布在y轴上的中心位置。\r\n\r\n\r\nX的标准差\r\nσX\r\n(0, +∞)\r\n随机变量X的离散程度，σX越大，X的取值越分散。\r\n\r\n\r\nY的标准差\r\nσY\r\n(0, +∞)\r\n随机变量Y的离散程度，σY越大，Y的取值越分散。\r\n\r\n\r\n相关系数\r\nρ\r\n[−1, 1]\r\n衡量X和Y的线性相关程度： ρ = 0表示独立； ρ &gt; 0表示正相关； ρ &lt; 0表示负相关。\r\n\r\n\r\n\r\n独立情况ρ = 0 $$\r\nf(x, y) = \\frac{1}{2\\pi\\sigma_X\\sigma_Y} \\exp\\left\\{ -\\frac{1}{2} \\left[\r\n\\left( \\frac{x-\\mu_X}{\\sigma_X} \\right)^2 + \\left(\r\n\\frac{y-\\mu_Y}{\\sigma_Y} \\right)^2 \\right] \\right\\}\r\n$$ 满足：\r\n\r\n边缘分布：X ∼ N(μX, σX2)，Y ∼ N(μY, σY2)；\r\n独立性：当且仅当 ρ = 0\r\n时，F(x, y) = FX(x)FY(y)。\r\n\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","实用知识","数学","概率论与数理统计"]},{"title":"概率论与数理统计部分习题选做","url":"/posts/4240.html","content":"随机事件和概率部分\r\n题目1：古典概型\r\n一个箱子里装有8个不同编号的红球、6个不同编号的白球和4个不同编号的黑球。现从中无放回地抽取4个球，求满足以下条件的概率：\r\n\r\n抽取的4个球中，红球、白球、黑球至少各有1个。\r\n已知抽取的4个球中至少有2个红球，求恰好有2个红球的概率。\r\n\r\n解答：\r\n\r\n设 抽取的4个球中，红球、白球、黑球至少各有1个 为事件 X\r\n而，从8 + 6 + 4 = 18个球中无放回抽取4个球的组合数，根据组合数公式$C(n,k)=\\frac{n!}{k!(n -\r\nk)!}$，可得总样本数为 $$\r\nC(18,4)=\\frac{18!}{4!(18 -\r\n4)!}=\\frac{18\\times17\\times16\\times15}{4\\times3\\times2\\times1}=3060\r\n$$ 而事件 X 可以分成如下三种情况讨论\r\n\r\n“2红1白1黑” 的组合数为 $$\r\nC(8,2)\\times C(6,1)\\times C(4,1)=\\frac{8!}{2!(8 -\r\n2)!}\\times\\frac{6!}{1!(6 - 1)!}\\times\\frac{4!}{1!(4 -\r\n1)!}=28\\times6\\times4 = 672\r\n$$\r\n“1红2白1黑” 的组合数为 $$\r\nC(8,1)\\times C(6,2)\\times C(4,1)=\\frac{8!}{1!(8 -\r\n1)!}\\times\\frac{6!}{2!(6 - 2)!}\\times\\frac{4!}{1!(4 -\r\n1)!}=8\\times15\\times4 = 480\r\n$$\r\n“1红1白2黑” 的组合数为 $$\r\nC(8,1)\\times C(6,1)\\times C(4,2)=\\frac{8!}{1!(8 -\r\n1)!}\\times\\frac{6!}{1!(6 - 1)!}\\times\\frac{4!}{2!(4 -\r\n2)!}=8\\times6\\times6 = 288\r\n$$\r\n\r\n所以，事件 X 发生的概率为 $P(X) =\r\n\\frac{1440}{3060} = \\frac{8}{17}$\r\n而设 已知抽取的4个球中至少有2个红球，求恰好有2个红球 为事件Z\r\n而设 抽取的4个球中恰好有2个红球 为事件C\r\n事件 C 可分为如下三种情况讨论\r\n\r\n2红2白” 的组合数为 $$\r\nC(8,2)\\times C(6,2)=\\frac{8!}{2!(8 - 2)!}\\times\\frac{6!}{2!(6 -\r\n2)!}=28\\times15 = 420\r\n$$\r\n“2红2黑” 的组合数为 $$\r\nC(8,2)\\times C(4,2)=\\frac{8!}{2!(8 - 2)!}\\times\\frac{4!}{2!(4 -\r\n2)!}=28\\times6 = 168\r\n$$\r\n由 1. 中计算可知 “2红1白1黑” 的组合数为672，所以 $$\r\nP(C)=\\frac{420 + 168+672}{3060}=\\frac{1260}{3060}=\\frac{7}{17}\r\n$$\r\n\r\n而设 抽取的4个球中至少有2个红球 为事件V\r\n事件V可以分为如下三种情况讨论\r\n\r\n3个红球” 的组合数为 $$\r\nC(8,3)\\times[C(6,1)+C(4,1)+C(6,0)\\times C(4,0)]=\\frac{8!}{3!(8 -\r\n3)!}\\times(6 + 4+1)=56\\times11 = 616\r\n$$\r\n“4个红球” 的组合数为 $$\r\nC(8,4)=\\frac{8!}{4!(8 - 4)!}=70\r\n$$\r\n而两个红球的组合数在上述已知得到为 1260\r\n\r\n所以 $$\r\nP(V) = \\frac{1260+616 + 70}{3060}=\\frac{1946}{3060}=\\frac{973}{1530}\r\n$$ 根据条件概率公式，因为A ⊆ B，所以A ∩ B = A，则\r\n$$\r\nP(A|B)=\\frac{P(A)}{P(B)}=\\frac{\\frac{7}{17}}{\\frac{973}{1530}}=\\frac{7\\times1530}{17\\times973}=\\frac{10710}{16541}\\approx0.647\r\n$$\r\n\r\n题目2：条件概率与独立性\r\n设事件 A 和 B 满足：$P(A|B) = \\frac{2}{3},\r\n\\quad P(B|A) = \\frac{3}{4}, \\quad P(A \\cup B) =\r\n\\frac{11}{12}$\r\n\r\n求 P(A) 和 P(B)；\r\n计算 $P(\\overline{A} |\r\n\\overline{B})$，其中 $\\overline{A}$ 表示 A 的补事件；\r\n证明：若 P(A|B) = P(B|A)，则\r\nP(A) = P(B)\r\n或 P(A ∩ B) = 1 − P(A) − P(B)（当\r\nP(A) + P(B) ≠ 1\r\n时）。\r\n\r\n解答\r\n\r\n计算条件概率 $$\r\nP(A|B) = \\frac{P(A \\cap B)}{P(B)} = \\frac{2}{3} \\quad \\Rightarrow \\quad\r\nP(A \\cap B) = \\frac{2}{3}P(B) \\tag{1}\r\n$$\r\n$$\r\nP(B|A) = \\frac{P(A \\cap B)}{P(A)} = \\frac{3}{4} \\quad \\Rightarrow \\quad\r\nP(A \\cap B) = \\frac{3}{4}P(A) \\tag{2}\r\n$$\r\n联立(1)和(2)式子，得到 $$\r\n\\frac{2}{3}P(B) = \\frac{3}{4}P(A) \\quad \\Rightarrow \\quad P(A) =\r\n\\frac{8}{9}P(B) \\tag{3}\r\n$$ 由加法公式可得 $$\r\nP(A \\cup B) = P(A) + P(B) - P(A \\cap B) = \\frac{11}{12}\r\n$$ 代入 (1)(3)： $$\r\n\\frac{8}{9}P(B) + P(B) - \\frac{2}{3}P(B) = \\frac{11}{12}\r\n$$ 解得 $$\r\n\\left(\\frac{8}{9} + 1 - \\frac{2}{3}\\right)P(B) = \\frac{11}{12} \\quad\r\n\\Rightarrow \\quad \\frac{11}{9}P(B) = \\frac{11}{12} \\quad \\Rightarrow\r\n\\quad P(B) = \\frac{3}{4}\r\n$$\r\n$$\r\nP(A) = \\frac{8}{9}P(B) = \\frac{2}{3}\r\n$$\r\n计算 $P(\\overline{A} |\r\n\\overline{B})$ 先求 $P(\\overline{A} \\cap \\overline{B})$ $$\r\nP(\\overline{A} \\cap \\overline{B}) = 1 - P(A \\cup B) = 1 - \\frac{11}{12}\r\n= \\frac{1}{12}\r\n$$ 在求$P(\\overline B)$ $$\r\nP(\\overline{B}) = 1 - P(B) = 1 - \\frac{3}{4} = \\frac{1}{4}\r\n$$ 由条件概率公式 $$\r\nP(\\overline{A} | \\overline{B}) = \\frac{P(\\overline{A} \\cap\r\n\\overline{B})}{P(\\overline{B})} = \\frac{1/12}{1/4} = \\frac{1}{3}\r\n$$\r\n对称性证明\r\n若P(A|B) = P(B|A)，则\r\n$$\r\n\\frac{P(A \\cap B)}{P(B)} = \\frac{P(A \\cap B)}{P(A)}\r\n$$ 题目中，P(A) + P(B) ≠ 1，所以P(A ∩ B) = 0 = 1 − P(A) − P(B)，不成立，这种情况不能成立\r\n若 P(A ∩ B) ≠ 0，两边同除以\r\nP(A ∩ B) 得:\r\n$$\r\n\\frac{1}{P(B)} = \\frac{1}{P(A)} \\quad \\Rightarrow \\quad P(A) = P(B)\r\n$$ 综上，当 P(A) + P(B) ≠ 1\r\n时，必有 P(A) = P(B)，得证\r\n\r\n题目三：独立性证明\r\n设事件 A 和 B 满足 0 &lt; P(A) &lt; 1，0 &lt; P(B) &lt; 1，且：\r\n$$\r\nP(A|B) = 1 - P(\\overline{A}|\\overline{B}), \\quad P(B) = 2P(A) - P(A)^2\r\n$$\r\n\r\n证明 A 和 B 独立；\r\n若 $P(A \\cup B) = \\frac{7}{9}$，求\r\nP(A)；\r\n构造反例说明：若去掉 0 &lt; P(A) &lt; 1 和 0 &lt; P(B) &lt; 1\r\n的条件，独立性结论不成立。\r\n\r\n解答\r\n\r\n独立性证明\r\n先化简 $P(\\overline{A}|\\overline{B})$： $$\r\nP(\\overline{A}|\\overline{B}) = \\frac{P(\\overline{A} \\cap\r\n\\overline{B})}{P(\\overline{B})} = \\frac{1 - P(A \\cup B)}{1 - P(B)}\r\n$$ 而题设 $P(A|B) = 1 -\r\nP(\\overline{A}|\\overline{B})$，所以有 $$\r\n\\frac{P(A \\cap B)}{P(B)} = 1 - \\frac{1 - P(A \\cup B)}{1 - P(B)}\r\n$$ 通分右边： $$\r\n1 - \\frac{1 - P(A) - P(B) + P(A \\cap B)}{1 - P(B)} = \\frac{(1 - P(B)) -\r\n(1 - P(A) - P(B) + P(A \\cap B))}{1 - P(B)} = \\frac{P(A) - P(A \\cap B)}{1\r\n- P(B)}\r\n$$ 等式变为： $$\r\n\\frac{P(A \\cap B)}{P(B)} = \\frac{P(A) - P(A \\cap B)}{1 - P(B)}\r\n$$ 交叉相乘，展开，然后消去同类项，可得 P(A ∩ B) = P(A)P(B)\r\n得证，故 A 和 B 独立\r\n求P(A)\r\n由加法公式可得 P(A ∪ B) = P(A) + P(B) − P(A)P(B)\r\n代入P(B) = 2P(A) − P(A)2：\r\n$$\r\n\\frac{7}{9} = P(A) + (2P(A) - P(A)^2) - P(A)(2P(A) - P(A)^2)\r\n$$ 设P(A)为x，多项式分可解为：$(x - \\frac{1}{3})(9x^2 - 24x + 21) = 0$\r\n二次方程判定式 Δ = 242 − 4 × 9 × 21 = 576 − 756 = −180 &lt; 0\r\n故唯一实根为 $x = \\frac{1}{3}$，即$\r\nP(A) = $。\r\n构造反例反证\r\n设 P(A) = 0，P(B) = 0，则：\r\n\r\nP(A|B)\r\n无定义（分母为 0），但形式上若规定 0|0\r\n为任意值，此时 P(A ∩ B) = 0 = P(A)P(B)，看似独立，但是实际上没有意义。\r\n设 P(A) = 1，P(B) = 1，则 P(A|B) = 1，$P(\\overline{A}|\\overline{B}) =\r\nP(\\varnothing|\\varnothing)$ 无定义，且 P(A ∩ B) = 1 = P(A)P(B)，仍看似独立；\r\n但严格来说，当 P(B) = 0 或 1\r\n时，条件概率定义不成立，且独立性定义要求 0 &lt; P(B) &lt; 1，故去掉条件后结论可能因边界情况失效。\r\n\r\n\r\n题目四：全概率公式和贝叶斯公式\r\n某工厂有三条生产线 A、B、C，分别占总产量的 30%、50% 和\r\n20%。已知各生产线的次品率如下：\r\n\r\n生产线 A 的次品率为 2%，\r\n生产线 B 的次品率为 1%，\r\n生产线 C 的次品率为 3%。\r\n\r\n现在进行以下两步操作：\r\n\r\n从总产品中随机抽取一件进行检测，发现是次品。\r\n将该次品放回后，再从总产品中随机抽取一件。\r\n\r\n问题：\r\n\r\n求第一次抽到次品的概率。（全概率公式的应用）\r\n在第一次抽到次品的条件下，求第二次抽到的产品是合格品的概率。（贝叶斯公式与全概率公式的组合）\r\n\r\n解答\r\n\r\n先求第一次抽到是次品的概率\r\n设事件：\r\n\r\nD1：第一次抽到次品，\r\nD2：第二次抽到次品，\r\nA：产品来自生产线 A，\r\nB：产品来自生产线 B，\r\nC：产品来自生产线 C。\r\n\r\n根据全概率公式 P(D1) = P(D1|A)P(A) + P(D1|B)P(B) + P(D1|C)P(C) = 0.02 × 0.3 + 0.01 × 0.5 + 0.03 × 0.2 = 0.006 + 0.005 + 0.006 = 0.017\r\n在第一次抽到次品的条件下，求第二次抽到合格品的概率\r\n我们需要计算 P(合格 ∣ D1)，即第二次抽到合格品的概率，已知第一次抽到次品。由于第一次抽到的次品被放回，生产线的比例不变\r\n首先，用贝叶斯公式计算在第一次抽到次品的条件下，产品来自各生产线的概率：\r\n\r\n$$\r\nP(A | D_1) = \\frac{P(D_1 | A) P(A)}{P(D_1)} = \\frac{0.02 \\times\r\n0.3}{0.017} \\approx \\frac{0.006}{0.017} \\approx 0.3529\\\\\r\nP(B | D_1) = \\frac{P(D_1 | B) P(B)}{P(D_1)} = \\frac{0.01 \\times\r\n0.5}{0.017} \\approx \\frac{0.005}{0.017} \\approx 0.2941\\\\\r\nP(C | D_1) = \\frac{P(D_1 | C) P(C)}{P(D_1)} = \\frac{0.03 \\times\r\n0.2}{0.017} \\approx \\frac{0.006}{0.017} \\approx 0.3529\r\n$$\r\n接下来，第二次抽到合格品的概率是在本次情况下的全概率\r\n\r\n根据全概率公式\r\nP(合格|D1) = P(合格|A)P(A|D1) + P(合格|B)P(B|D1) + P(合格|C)P(C|D1)\r\n其中 P(合格|A) = 1 − 0.02 = 0.98,  P(合格|B) = 1 − 0.01 = 0.99,  P(合格|C) = 1 − 0.03 = 0.97\r\n因此\r\nP(合格|D1) ≈ 0.98 × 0.3529 + 0.99 × 0.2941 + 0.97 × 0.3529 ≈ 0.3458 + 0.2912 + 0.3423 ≈ 0.9793\r\n多维随机变量及其分布\r\n题目1\r\n已知二维随机变量(X, Y)的联合概率密度为\r\n$$ { }\r\nf(x,y) = \\begin{cases} 4xy &amp; 0 \\le x \\le 1, 0 \\le y \\le 1 \\\\0 &amp;\r\n其他\\end{cases}\r\n$$ 求(X, Y)的联合分布函数\r\n解答\r\n二维随机变量 (X, Y)\r\n的联合分布函数定义为： F(x, y) = P(X ≤ x, Y ≤ y) = ∫−∞x∫−∞yf(u, v) dv du\r\n需根据 x 和 y 的取值范围分段讨论，共分为以下\r\n5 种情况\r\n\r\n当 x &lt; 0 或 y &lt; 0 时\r\n\r\n若 x &lt; 0，则积分下限\r\nu 超出 f(u, v)\r\n的非零区域（u ≥ 0），此时：\r\nF(x, y) = ∫−∞x &lt; 0∫−∞y0 dv du = 0\r\n若 y &lt; 0，同理，v 超出非零区域，结果仍为：\r\nF(x, y) = 0\r\n结论：\r\nF(x, y) = 0,  x &lt; 0 或 y &lt; 0\r\n\r\n当 0 ≤ x &lt; 1 且\r\n0 ≤ y &lt; 1 时\r\n\r\n此时 u 和 v 均在 f(u, v)\r\n的非零区域内，积分范围为：\r\nu ∈ [0, x],  v ∈ [0, y]\r\n计算二重积分：\r\nF(x, y) = ∫0x∫0y4uv dv du\r\n\r\n先对 v 积分：\r\n$$\r\n\\int_{0}^{y} 4uv \\, dv = 4u \\int_{0}^{y} v \\, dv = 4u \\cdot\r\n\\frac{v^2}{2} \\bigg|_{0}^{y} = 4u \\cdot \\frac{y^2}{2} = 2uy^2\r\n$$\r\n再对 (u) 积分：\r\n$$\r\n\\int_{0}^{x} 2uy^2 \\, du = 2y^2 \\int_{0}^{x} u \\, du = 2y^2 \\cdot\r\n\\frac{u^2}{2} \\bigg|_{0}^{x} = 2y^2 \\cdot \\frac{x^2}{2} = x^2y^2\r\n$$ 结论： F(x, y) = x2y2,  0 ≤ x &lt; 1, 0 ≤ y &lt; 1\r\n\r\n\r\n当 x ≥ 1 且 0 ≤ y &lt; 1 时\r\n\r\nu\r\n超出非零区域的上限（u ≤ 1），故 u 的积分范围为 [0, 1]，v 仍为 [0, y]：\r\nF(x, y) = ∫01∫0y4uv dv du\r\n\r\n对 (v) 积分（同情况 2）： ∫0y4uv dv = 2uy2\r\n对 (u) 积分： $$\r\n\\int_{0}^{1} 2uy^2 \\, du = 2y^2 \\cdot \\frac{u^2}{2} \\bigg|_{0}^{1} =\r\n2y^2 \\cdot \\frac{1}{2} = y^2\r\n$$ 结论： F(x, y) = y2,  x ≥ 1, 0 ≤ y &lt; 1\r\n\r\n\r\n当 0 ≤ x &lt; 1 且\r\ny ≥ 1 时\r\n\r\nv\r\n超出非零区域的上限（v ≤ 1），故 v 的积分范围为 [0, 1]，u 为 [0, x]：\r\nF(x, y) = ∫0x∫014uv dv du\r\n\r\n对 v 积分：\r\n$$\r\n\\int_{0}^{1} 4uv \\, dv = 4u \\cdot \\frac{v^2}{2} \\bigg|_{0}^{1} = 4u\r\n\\cdot \\frac{1}{2} = 2u\r\n$$\r\n对 u 积分：\r\n$$\r\n\\int_{0}^{x} 2u \\, du = 2 \\cdot \\frac{u^2}{2} \\bigg|_{0}^{x} = x^2\r\n$$ 结论：\r\nF(x, y) = x2,  0 ≤ x &lt; 1, y ≥ 1\r\n\r\n\r\n当 x ≥ 1 且 y ≥ 1 时\r\n\r\nu 和 v\r\n均覆盖整个非零区域，积分范围为：\r\nu ∈ [0, 1],  v ∈ [0, 1]\r\n计算二重积分：\r\nF(x, y) = ∫01∫014uv dv du\r\n\r\n对 (v) 积分：\r\n∫014uv dv = 2u\r\n对 (u) 积分：\r\n∫012u du = 1\r\n结论：\r\nF(x, y) = 1,  x ≥ 1, y ≥ 1\r\n\r\n\r\n\r\n最终联合分布函数\r\n综合以上 5 种情况，(X, Y)\r\n的联合分布函数为：\r\n$$\r\nF(x,y) = \\begin{cases}\r\n0, &amp; x &lt; 0 \\ 或 \\ y &lt; 0 \\\\\r\nx^2y^2, &amp; 0 \\leq x &lt; 1, \\ 0 \\leq y &lt; 1 \\\\\r\ny^2, &amp; x \\geq 1, \\ 0 \\leq y &lt; 1 \\\\\r\nx^2, &amp; 0 \\leq x &lt; 1, \\ y \\geq 1 \\\\\r\n1, &amp; x \\geq 1, \\ y \\geq 1\r\n\\end{cases}\r\n$$\r\n题目2\r\n设二维随机变量 (X, Y)\r\n的联合概率密度函数为： $$\r\nf(x, y) = \\begin{cases}  6e^{-2x - 3y}, &amp; x \\geq 0, y \\geq 0 \\\\ 0,\r\n&amp; \\text{其他}  \\end{cases}\r\n$$\r\n\r\n求边缘概率密度函数 fX(x)\r\n和 fY(y)。\r\n判断 X 和 Y 是否独立，并说明理由。\r\n\r\n解答：\r\n\r\n求边缘密度函数\r\nfX(x)\r\n：对 y 积分，区间 0 到 +∞\r\nfX(x) = ∫0∞6e−2x − 3y dy = 6e−2x∫0∞e−3y dy\r\n令 u = −3y，则 du = −3dy，积分变为：\r\n$$\r\n6e^{-2x} \\left[ -\\frac{1}{3}e^{-3y} \\right]_{0}^{\\infty} = 6e^{-2x}\r\n\\cdot \\frac{1}{3} = 2e^{-2x} \\quad (x \\geq 0)\r\n$$ 因此 $$\r\nf_X(x) = \\begin{cases} 2e^{-2x}, &amp; x \\geq 0 \\\\ 0, &amp; \\text{其他}\r\n\\end{cases}\r\n$$ fY(y)\r\n：对 x 积分，区间 0 到 +∞\r\n\r\nfY(y) = ∫0∞6e−2x − 3y dx = 6e−3y∫0∞e−2x dx\r\n   令 $u = -2x$，则 $du = -2dx$，积分变为：\r\n$$\r\n6e^{-3y} \\left[ -\\frac{1}{2}e^{-2x} \\right]_{0}^{\\infty} = 6e^{-3y}\r\n\\cdot \\frac{1}{2} = 3e^{-3y} \\quad (y \\geq 0)\r\n$$ 因此 $$\r\nf_Y(y) = \\begin{cases} 3e^{-3y}, &amp; y \\geq 0 \\\\ 0, &amp; \\text{其他}\r\n\\end{cases}\r\n$$\r\n\r\n独立性判断\r\n若 X 和 Y 独立，则需满足 f(x, y) = fX(x) ⋅ fY(y)。\r\n计算乘积 fX(x) ⋅ fY(y) = (2e−2x) ⋅ (3e−3y) = 6e−2x − 3y = f(x, y)\r\n因此，X和Y独立\r\n\r\n题目3：\r\n设二维随机变量 (X, Y)\r\n的联合分布律如下：\r\n\r\n\r\n\r\nX ∖ Y\r\n0\r\n1\r\n\r\n\r\n\r\n\r\n0\r\n0.2\r\n0.3\r\n\r\n\r\n1\r\n0.4\r\n0.1\r\n\r\n\r\n\r\n\r\n求 X 和 Y 的边缘分布律。\r\n判断 X 和 Y 是否独立，并说明理由。\r\n\r\n解答\r\n\r\nP(X = 0) = 0.2 + 0.3 = 0.5\r\nP(X = 1) = 0.4 + 0.1 = 0.5\r\n即$X \\sim \\begin{pmatrix} 0 &amp; 1 \\\\ 0.5\r\n&amp; 0.5 \\end{pmatrix}$\r\nP(Y = 0) = 0.2 + 0.4 = 0.6,  P(Y = 1) = 0.3 + 0.1 = 0.4\r\n即 $Y \\sim \\begin{pmatrix} 0 &amp; 1 \\\\ 0.6\r\n&amp; 0.4 \\end{pmatrix}$\r\n独立性判断\r\n若 X 和 Y 独立，则对所有 x, y 需满足 P(X = x, Y = y) = P(X = x) ⋅ P(Y = y)。\r\n然而其中 P(X = 0, Y = 0) = 0.2  但  P(X = 0) ⋅ P(Y = 0) = 0.5 ⋅ 0.6 = 0.3 ≠ 0.2\r\n因此，X 和 Y 不独立\r\n\r\n题目4\r\n设 X 和 Y\r\n是相互独立的随机变量，且均服从标准正态分布 N(0, 1)。定义 Z = X + Y，求 Z\r\n的概率密度函数 fZ(z)。\r\n解答：\r\n属于是和的分布\r\n\r\n卷积公式\r\n由于 X 和 Y 独立，Z = X + Y\r\n的概率密度函数为卷积： fZ(z) = ∫−∞∞fX(x) ⋅ fY(z − x) dx\r\n其中 $f_X(x) =\r\n\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$，$f_Y(y) =\r\n\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{y^2}{2}}$。\r\n代入并化简\r\n代入 y = z − x： $$\r\nf_Z(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\r\n\\cdot \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{(z - x)^2}{2}} \\, dx\r\n$$ 合并指数项： $$\r\nf_Z(z) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-\\frac{x^2 + (z -\r\nx)^2}{2}} \\, dx\r\n$$ 展开并整理指数部分： $$\r\nx^2 + (z - x)^2 = 2x^2 - 2zx + z^2 = 2\\left(x - \\frac{z}{2}\\right)^2 +\r\n\\frac{z^2}{2}\r\n$$ 因此： $$\r\nf_Z(z) = \\frac{1}{2\\pi} e^{-\\frac{z^2}{4}} \\int_{-\\infty}^{\\infty}\r\ne^{-\\left(x - \\frac{z}{2}\\right)^2} \\, dx\r\n$$\r\n高斯积分\r\n令 $u = x -\r\n\\frac{z}{2}$，则积分变为标准高斯积分：\r\n$$\r\n\\int_{-\\infty}^{\\infty} e^{-u^2} \\, du = \\sqrt{\\pi}\r\n$$ 代入得： $$\r\nf_Z(z) = \\frac{1}{2\\pi} e^{-\\frac{z^2}{4}} \\cdot \\sqrt{\\pi} =\r\n\\frac{1}{\\sqrt{4\\pi}} e^{-\\frac{z^2}{4}}\r\n$$ 即 Z ∼ N(0, 2)。\r\n\r\n抽样分布与样本统计量部分\r\n题目1\r\n设总体 $ X B(1,p) $，其中 $ p $ 是未知参数，$ (X_1,X_2,,X_5) $ 是总体\r\n$ X $ 的样本， 1. 写出样本空间和样本的联合概率分布； 2. 指出 $ X_1 +\r\nX_3,{X_1,X_2,,X_5},,(X_5 - X_1)^2 $ 中哪些是统计量，哪些不是统计量； 3.\r\n若样本观测值为 $ 0,1,0,1,1 $，求样本均值与样本方差。\r\n解答：\r\n\r\n由于每个Xi只能取0或1，样本空间为所有可能的5维0-1向量：\r\nS = {(x1, x2, x3, x4, x5)|xi ∈ {0, 1}, i = 1, ⋯, 5}\r\n共有25 = 32个样本点。\r\n由于样本独立同分布，联合概率分布为： $$\r\nP(X_1=x_1,\\cdots,X_5=x_5) = \\prod_{i=1}^5 P(X_i=x_i) = p^{\\sum_{i=1}^5\r\nx_i}(1-p)^{5-\\sum_{i=1}^5 x_i}\r\n$$ 其中xi ∈ {0, 1}。\r\n统计量都是已知量，不能包含未知量\r\n\r\nX1 + X3：\r\n\r\n\r\n仅依赖样本值，不依赖p\r\n是统计量\r\n\r\n\r\nmin {X1, ⋯, X5}：\r\n\r\n\r\n只与样本值有关\r\n是统计量\r\n\r\n\r\n$\\frac{X_1}{p}$：\r\n\r\n\r\n含有未知参数p\r\n不是统计量\r\n\r\n\r\n(X5 − X1)2：\r\n\r\n\r\n仅依赖样本值\r\n是统计量\r\n\r\n样本观测值为(0, 1, 0, 1, 1)，样本的均值为 $$\r\n\\bar{x} = \\frac{1}{5}\\sum_{i=1}^5 x_i = \\frac{0+1+0+1+1}{5} =\r\n\\frac{3}{5} = 0.6\r\n$$ 样本的方差为 $$\r\ns^2 = \\frac{1}{5-1}\\left(\\sum x_i^2 - 5\\bar{x}^2\\right) =\r\n\\frac{1}{4}\\left(3 - 5 \\times 0.36\\right) = \\frac{1.2}{4} = 0.3\r\n$$\r\n\r\n问题2：\r\n设总体 X ∼ N(μ, σ2)，从中抽取样本\r\nX1, X2。\r\n\r\n写出 (X1, X2)\r\n的联合概率密度函数；\r\n求样本均值 $\\overline{X} = \\frac{X_1 +\r\nX_2}{2}$ 的分布；\r\n计算 $E(\\overline{X})$ 和 $D(\\overline{X})$；\r\n若 μ = 1, σ2 = 4，求 $P(\\overline{X} &gt; 1.5)$。\r\n\r\n解答：\r\n\r\n联合概率密度函数为 $$\r\nf(x_1,x_2) = \\prod_{i=1}^2 \\frac{1}{\\sqrt{2\\pi}\\sigma}\r\ne^{-\\frac{(x_i-\\mu)^2}{2\\sigma^2}}\r\n$$\r\n样本均值的分布为 $$\r\n\\overline{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{2}\\right)\r\n$$\r\n$E(\\overline{X})$为 $$\r\nE(\\overline{X}) = E(\\frac{1}{n} \\sum_{i = 1}^n X_i) = \\frac{1}{n}EX_i =\r\nEX = \\mu\r\n$$ $D(\\overline{X})$为 $$\r\nD(\\overline{X}) = D(\\frac{1}{n} \\sum_{i = 1}^n X_i) =\r\n\\frac{1}{n^2}D(\\sum_{i = 1}^n X_i) = \\frac{1}{n^2}\\sum_{i = 1}^n DX_i =\r\n\\frac{1}{n^2} .n\\sigma^2 = \\frac{\\sigma^2}{n}\r\n$$\r\n当 μ = 1, σ2 = 4 时： $$\r\nP(\\overline{X} &gt; 1.5) = 1 - \\Phi\\left(\\frac{1.5-1}{\\sqrt{2}}\\right)\r\n\\approx 1 - \\Phi(0.3535) \\approx 0.3618\r\n$$\r\n\r\n问题3：\r\n设总体 X ∼ P(λ)，从中抽取样本\r\nX1, X2, X3。\r\n\r\n求样本总和 T = X1 + X2 + X3\r\n的分布；\r\n证明 $\\overline{X}$ 是 λ 的无偏估计；\r\n计算 $D(\\overline{X})$；\r\n当 λ = 2 时，求 $P(\\overline{X} \\leq 1.5)$。\r\n\r\n解答：\r\n\r\n因为 X ∼ P(λ)，所以有\r\n$$\r\nP(X = k) = \\frac{\\lambda ^k e^{- \\lambda}}{k!}\r\n$$ 容易得到，样本的总和分布为 T ∼ P(3λ)\r\n无偏性证明 $$\r\nE(\\overline X) = E\\left(\\frac{T}{3}\\right) = \\frac{3\\lambda}{3} =\r\n\\lambda\r\n$$\r\n方差计算 $$\r\nD(\\overline{X}) = \\frac{D(X)}{n} = \\frac{\\lambda}{3}\r\n$$\r\n当 λ = 2 时，T ∼ P(6)： $$\r\nP(\\overline{X} \\leq 1.5) = P(T \\leq 4.5) = P(T \\leq 4) \\approx 0.2851\r\n$$\r\n\r\n大数定律\r\n题目1：\r\n设 X1, X2, …, Xn\r\n为独立同分布的随机变量序列，E(Xi) = μ，D(Xi) = σ2 &lt; ∞。则下列叙述正确的是：\r\nA. $\\lim_{n \\to \\infty}\r\nP\\left(\\left|\\frac{1}{n}\\sum_{i=1}^n X_i - \\mu\\right| \\geq\r\n\\epsilon\\right) = 1$\r\nB. $\\lim_{n \\to \\infty}\r\nP\\left(\\left|\\frac{1}{n}\\sum_{i=1}^n X_i - \\mu\\right| &lt;\r\n\\epsilon\\right) = 0$\r\nC. $\\lim_{n \\to \\infty}\r\nP\\left(\\left|\\frac{1}{n}\\sum_{i=1}^n X_i - \\mu\\right| \\geq\r\n\\epsilon\\right) = 0$\r\nD. $\\lim_{n \\to \\infty}\r\n\\frac{1}{n}\\sum_{i=1}^n X_i = \\mu$ 几乎必然成立\r\n正确答案：C\r\n详细解析：\r\n\r\n切比雪夫大数定律的数学表述： $$\r\n\\lim_{n \\to \\infty} P\\left(\\left|\\frac{1}{n}\\sum_{i=1}^n X_i -\r\n\\mu\\right| \\geq \\epsilon\\right) = 0\r\n$$ 这称为依概率收敛，对应选项C。\r\n错误选项分析：\r\n\r\nA：与定律结论相反\r\nB：概率收敛到0应为收敛到1\r\nD：描述的是强大数定律，需要更强条件\r\n\r\n\r\n题目2：\r\n设 X1, X2, …, X100\r\n为独立同分布的泊松随机变量，Xi ∼ P(λ)，则\r\n$\\sum_{i=1}^{100} X_i$\r\n的近似分布是：A\r\nA. N(100λ, 100λ)\r\nB. N(λ, λ)\r\nC. P(100λ)\r\nD. N(λ, λ/100)\r\n\r\n泊松分布性质：\r\n\r\nE(Xi) = λ,\r\nD(Xi) = λ\r\n具有可加性：∑Xi ∼ P(nλ)\r\n\r\n中心极限定理应用： 当 n = 100 较大时： $$\r\n\\sum_{i=1}^{100} X_i \\approx N(n\\lambda, n\\lambda) = N(100\\lambda,\r\n100\\lambda)\r\n$$\r\n错误选项分析：\r\n\r\nB：描述的是单个Xi的近似\r\nC：精确分布非近似结果\r\nD：混淆了样本均值的分布\r\n\r\n\r\n问题3\r\n设 X1, …, Xn\r\n独立同分布，E(Xi) = 1,\r\nD(Xi) = 4。当\r\nn 充分大时，P(X̄ ≤ 1.2) 的近似值为：\r\nA. $\\Phi(0.1\\sqrt{n})$\r\nB. $\\Phi(0.2\\sqrt{n})$\r\nC. $1 - \\Phi(0.1\\sqrt{n})$\r\nD. $\\Phi(0.4\\sqrt{n})$\r\n详细解析：\r\n\r\n标准化样本均值： $$\r\n\\bar{X} \\approx N\\left(1, \\frac{4}{n}\\right) \\Rightarrow\r\n\\frac{\\bar{X}-1}{2/\\sqrt{n}} \\sim N(0,1)\r\n$$\r\n概率计算： $$\r\nP(\\bar{X} \\leq 1.2) = P\\left(\\frac{\\bar{X}-1}{2/\\sqrt{n}} \\leq\r\n\\frac{0.2}{2/\\sqrt{n}}\\right) \\approx \\Phi(0.1\\sqrt{n})\r\n$$\r\n错误选项分析：\r\n\r\nB：系数错误（应为0.1）\r\nC：方向反了\r\nD：方差系数错误\r\n\r\n\r\n参数估计部分\r\n点估计\r\n问题1\r\ntag：矩估计，最大似然估计，无偏性，有效性\r\n设 X1, X2, …, Xn\r\n是来自总体 X\r\n的简单随机样本，总体概率密度函数为： $$\r\nf(x;\\theta) = \\begin{cases}\r\n\\theta x^{\\theta-1}, &amp; 0 &lt; x &lt; 1 \\\\\r\n0, &amp; \\text{其他}\r\n\\end{cases}\r\n$$ 其中 θ &gt; 0\r\n为未知参数。\r\n\r\n求 θ 的矩估计量 θ̂1；\r\n求 θ 的最大似然估计量\r\nθ̂2；\r\n验证 θ̂1 和\r\nθ̂2\r\n的无偏性，并比较它们的有效性。\r\n\r\n解答\r\n\r\n矩估计：\r\n\r\n计算总体矩 $$\r\n\\begin{align*}\r\nE(X) &amp; = \\int_0^1 x \\cdot \\theta x^{\\theta-1} \\, dx \\\\\r\n&amp; = \\int_0^1 \\theta x^{\\theta} \\, dx \\\\\r\n&amp; = \\theta \\int_0^1 x^{\\theta} \\, dx \\\\\r\n&amp; = \\theta \\cdot \\left. \\frac{x^{\\theta + 1}}{\\theta + 1}\r\n\\right|_0^1 \\\\\r\n&amp; = \\theta \\cdot \\left( \\frac{1^{\\theta + 1}}{\\theta + 1} -\r\n\\frac{0^{\\theta + 1}}{\\theta + 1} \\right) \\\\\r\n&amp; = \\theta \\cdot \\frac{1}{\\theta + 1} \\\\\r\n&amp; = \\frac{\\theta}{\\theta + 1}\r\n\\end{align*}\r\n$$\r\n令样本矩等于总体矩： $$\r\n\\bar{X} = \\frac{\\theta}{\\theta+1}\r\n$$\r\n解得 $$\r\n\\hat{\\theta}_1 = \\frac{\\bar{X}}{1-\\bar{X}}\r\n$$\r\n\r\n最大似然估计量\r\n\r\n似然函数 $$\r\nL(\\theta) = \\prod_{i=1}^n \\theta X_i^{\\theta-1} = \\theta^n\r\n\\left(\\prod_{i=1}^n X_i\\right)^{\\theta-1}\r\n$$\r\n取对数 $$\r\n\\ln L(\\theta) = n\\ln\\theta + (\\theta-1)\\sum_{i=1}^n \\ln X_i\r\n$$\r\n两边求导得到 $$\r\n\\frac{d}{d\\theta}\\ln L(\\theta) = \\frac{n}{\\theta} + \\sum_{i=1}^n \\ln X_i\r\n= 0\r\n$$\r\n解得最大似然估计量θ̂2为 $$\r\n\\hat{\\theta}_2 = -\\frac{n}{\\sum_{i=1}^n \\ln X_i}\r\n$$\r\n\r\n无偏性与有效性\r\n\r\n矩估计量的无偏性\r\n\r\n计算$E(\\hat{\\theta}_1) =\r\nE\\left(\\frac{\\bar{X}}{1-\\bar{X}}\\right)$\r\n由于 $\\bar{X} = \\frac{1}{n}\\sum\r\nX_i$，且 Xi ∼ f(x; θ)\r\n通过泰勒展开或直接计算可得 $E(\\hat{\\theta}_1) \\approx \\theta +\r\n\\frac{\\theta+1}{n}$（当 n 较大时）\r\n结论：θ̂1\r\n是渐近无偏的，但对有限样本是有偏的\r\n\r\n最大似然估计的无偏性：\r\n\r\n令 Yi = −ln Xi，则\r\nYi\r\n服从指数分布 Exp(θ)\r\nθ̂2 = n/∑Yi\r\n是倒指数分布参数的估计\r\n已知 $E(\\hat{\\theta}_2) =\r\n\\frac{n}{n-1}\\theta \\neq \\theta$（当 n &gt; 1）\r\n结论：θ̂2\r\n是有偏估计\r\n\r\n有效性比较：\r\n\r\n\r\n问题2：\r\n设 X1, X2, …, Xn\r\n是来自泊松分布 P(λ)\r\n的简单随机样本，其中 λ &gt; 0\r\n为未知参数。\r\n\r\n(矩估计) 求 λ 的矩估计量 λ̂1；\r\n(最大似然估计) 求 λ 的最大似然估计量 λ̂2；\r\n(无偏性与有效性) 设 $T =\r\n\\frac{1}{n}\\sum_{i=1}^n X_i^2 - \\bar{X}$，证明 T 是 λ2\r\n的无偏估计，并讨论其有效性。\r\n\r\n解答：\r\n\r\n矩估计：\r\n\r\nX ∼ P(λ)，所以\r\n$X =\r\n\\frac{e^{-\\lambda}\\lambda^{X}}{X!}$\r\n由于是泊松分布，所以 E(X) = λ，直接得\r\nλ̂1 = X̄\r\n\r\n最大似然估计：\r\n\r\n似然函数：$L(\\lambda) = \\prod_{i=1}^n\r\n\\frac{e^{-\\lambda}\\lambda^{X_i}}{X_i!}$\r\n对数似然函数：$\\ln L(\\lambda) = -n\\lambda\r\n+ \\ln\\lambda \\sum_{i=1}^n X_i - \\sum_{i=1}^n \\ln(X_i!)$\r\n求导得：$\\frac{d}{d\\lambda}\\ln L(\\lambda)\r\n= -n + \\frac{1}{\\lambda}\\sum_{i=1}^n X_i = 0$\r\n解得：λ̂2 = X̄\r\n\r\n无偏性与有效性：\r\n\r\n无偏性证明：\r\n\r\n已知泊松分布 E(Xi) = λ,\r\nVar(Xi) = λ\r\nE(Xi2) = Var(Xi) + [E(Xi)]2 = λ + λ2\r\n$E(T) = \\frac{1}{n}\\sum E(X_i^2) -\r\nE(\\bar{X}) = (\\lambda + \\lambda^2) - \\lambda = \\lambda^2$\r\n结论：T 是 λ2 的无偏估计\r\n\r\n有效性分析：\r\n\r\n计算 $\\text{Var}(T) =\r\n\\text{Var}\\left(\\frac{1}{n}\\sum X_i^2 - \\bar{X}\\right)$\r\n展开得 $\\text{Var}(T) =\r\n\\frac{1}{n^2}\\sum\\text{Var}(X_i^2) + \\text{Var}(\\bar{X}) -\r\n\\frac{2}{n}\\text{Cov}(\\sum X_i^2, \\bar{X})$\r\n对于泊松分布，Var(Xi2) = E(Xi4) − [E(Xi2)]2 = λ + 7λ2 + 6λ3 + λ4 − (λ + λ2)2\r\n计算得 $\\text{Var}(T) = \\frac{4\\lambda^3 +\r\n6\\lambda^2 + \\lambda}{n} + O(\\frac{1}{n^2})$\r\n与 C-R 下界比较（需先求 λ2 的 Fisher 信息）\r\n结论：T 是 λ2 的有效估计（达到 C-R\r\n下界）\r\n\r\n\r\n\r\n问题3\r\n设 X1, X2, …, Xn\r\n是来自总体 X\r\n的简单随机样本，总体服从参数为 θ 的指数分布，其概率密度函数为：\r\n$$\r\nf(x;\\theta) = \\begin{cases}\r\n\\theta e^{-\\theta x}, &amp; x &gt; 0 \\\\\r\n0, &amp; x \\leq 0\r\n\\end{cases}\r\n$$ 其中 θ &gt; 0\r\n为未知参数。\r\n考虑以下两个估计量： 1. $\\hat{\\theta}_1 =\r\n\\frac{1}{\\bar{X}}$，其中 $\\bar{X} =\r\n\\frac{1}{n}\\sum_{i=1}^n X_i$ 2. $\\hat{\\theta}_2 = \\frac{n-1}{\\sum_{i=1}^n\r\nX_i}$\r\n请完成： 1. 验证 θ̂1 和 θ̂2 的无偏性； 2.\r\n比较两个估计量的有效性； 3. 讨论哪个估计量更优，并说明理由。\r\n解答：\r\n\r\n无偏性验证\r\n对于θ̂1：\r\n\r\n已知$\\sum_{i=1}^n X_i \\sim Gamma(n,\r\n\\theta)$，其概率密度函数为： $$\r\nf_Y(y) = \\frac{\\theta^n y^{n-1} e^{-\\theta y}}{\\Gamma(n)}, \\quad y &gt;\r\n0\r\n$$\r\n计算 $E\\left[\\frac{1}{\\bar{X}}\\right] =\r\nE\\left[\\frac{n}{\\sum X_i}\\right] = n\r\nE\\left[\\frac{1}{Y}\\right]$，其中 Y = ∑Xi\r\n计算积分 $$\r\nE\\left[\\frac{1}{Y}\\right] = \\int_0^\\infty \\frac{1}{y} \\cdot\r\n\\frac{\\theta^n y^{n-1} e^{-\\theta y}}{\\Gamma(n)} dy =\r\n\\frac{\\theta^n}{\\Gamma(n)} \\int_0^\\infty y^{n-2} e^{-\\theta y} dy\r\n$$\r\n利用 Gamma 积分： $$\r\n\\int_0^\\infty y^{n-2} e^{-\\theta y} dy =\r\n\\frac{\\Gamma(n-1)}{\\theta^{n-1}} \\quad (n &gt; 1)\r\n$$\r\n因此： $$\r\nE\\left[\\frac{1}{Y}\\right] = \\frac{\\theta^n}{\\Gamma(n)} \\cdot\r\n\\frac{\\Gamma(n-1)}{\\theta^{n-1}} = \\frac{\\theta}{n-1}\r\n$$\r\n最终： $$\r\nE[\\hat{\\theta}_1] = n \\cdot \\frac{\\theta}{n-1} = \\frac{n}{n-1}\\theta\r\n\\neq \\theta\r\n$$\r\n结论：θ̂1 是有偏估计。\r\n\r\n对于θ2:\r\n\r\n类似地计算： $$\r\nE[\\hat{\\theta}_2] = (n-1) E\\left[\\frac{1}{Y}\\right] = (n-1) \\cdot\r\n\\frac{\\theta}{n-1} = \\theta\r\n$$\r\n结论：θ̂2 是无偏估计。\r\n\r\n有效性比较\r\n计算方差：\r\n\r\n对于 θ̂1： - 计算\r\n$E\\left[\\frac{1}{Y^2}\\right]$： $$\r\n  E\\left[\\frac{1}{Y^2}\\right] = \\int_0^\\infty \\frac{1}{y^2} \\cdot\r\n\\frac{\\theta^n y^{n-1} e^{-\\theta y}}{\\Gamma(n)} dy =\r\n\\frac{\\theta^n}{\\Gamma(n)} \\int_0^\\infty y^{n-3} e^{-\\theta y} dy =\r\n\\frac{\\theta^n}{\\Gamma(n)} \\cdot \\frac{\\Gamma(n-2)}{\\theta^{n-2}} =\r\n\\frac{\\theta^2}{(n-1)(n-2)} \\quad (n &gt; 2)\r\n  $$ - 因此： $$\r\n  \\text{Var}\\left(\\frac{1}{Y}\\right) = E\\left[\\frac{1}{Y^2}\\right] -\r\n\\left(E\\left[\\frac{1}{Y}\\right]\\right)^2 = \\frac{\\theta^2}{(n-1)(n-2)} -\r\n\\frac{\\theta^2}{(n-1)^2} = \\frac{\\theta^2}{(n-1)^2(n-2)}\r\n  $$ - 最终： $$\\text{Var}(\\hat{\\theta}_1) = n^2 \\cdot\r\n\\text{Var}\\left(\\frac{1}{Y}\\right) = \\frac{n^2\r\n\\theta^2}{(n-1)^2(n-2)}$$\r\n对于 θ̂2：\r\n$$\r\n\\text{Var}(\\hat{\\theta}_2) = (n-1)^2 \\cdot\r\n\\text{Var}\\left(\\frac{1}{Y}\\right) = \\frac{(n-1)^2\r\n\\theta^2}{(n-1)^2(n-2)} = \\frac{\\theta^2}{n-2}\r\n$$\r\n比较方差：\r\n\r\n当 n &gt; 2 时： $$\r\n\\text{Var}(\\hat{\\theta}_2) = (n-1)^2 \\cdot\r\n\\text{Var}\\left(\\frac{1}{Y}\\right) = \\frac{(n-1)^2\r\n\\theta^2}{(n-1)^2(n-2)} = \\frac{\\theta^2}{n-2}\r\n$$\r\n\r\n\r\n结论\r\n\r\n无偏性：θ̂2 是无偏估计，θ̂1 是有偏估计；\r\n有效性：θ̂2 的方差更小；\r\n最优估计：θ̂2\r\n在无偏性和有效性两方面都优于 θ̂1，因此是更优的估计量。\r\n补充说明：\r\n\r\n虽然 θ̂1\r\n是有偏的，但当 n → ∞ 时，E[θ̂1] → θ，称为渐近无偏；\r\nθ̂2 达到了\r\nCramer-Rao 下界，是最小方差无偏估计 (UMVUE)。\r\n\r\n\r\n\r\n区间估计\r\n题目1\r\n设某厂生产的零件长度服从正态分布 N(μ, σ2)，其中\r\nσ2\r\n未知。现随机抽取16个零件，测得样本均值 x̄ = 20.5 cm，样本标准差 s = 1.2 cm。求：\r\n\r\n总体均值 μ\r\n的95%置信区间；\r\n总体方差 σ2\r\n的90%置信区间。\r\n\r\n解答：\r\n\r\n总体均值 μ\r\n的95%置信区间\r\n\r\n确定统计量\r\n当总体方差未知的时候，使用t统计量 $$\r\nT = \\frac{\\bar{X} - \\mu}{S/\\sqrt{n}} \\sim t(n-1)\r\n$$\r\n确定置信水平\r\n置信水平 1 − α = 95%，故\r\nα = 0.05\r\n查表\r\n自由度 df = n − 1 = 15，查\r\nt 分布表得： tα/2(15) = t0.025(15) = 2.131\r\n计算置信区间\r\n置信区间公式 $$\r\n\\left[ \\bar{x} - t_{\\alpha/2}(n-1) \\cdot \\frac{s}{\\sqrt{n}}, \\bar{x} +\r\nt_{\\alpha/2}(n-1) \\cdot \\frac{s}{\\sqrt{n}} \\right]\r\n$$\r\n代入数值 $$\r\n\\left[ 20.5 - 2.131 \\times \\frac{1.2}{\\sqrt{16}}, 20.5 + 2.131 \\times\r\n\\frac{1.2}{\\sqrt{16}} \\right] = [19.86, 21.14]\r\n$$\r\n结论\r\nσ2\r\n的90%置信区间为 [0.864, 2.975] cm2\r\n\r\n总体方差 σ2\r\n的90%置信区间\r\n\r\n确定统计量\r\n总体均值已知，估计总体方差 $$\r\n\\chi^2 = \\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)\r\n$$\r\n确定置信水平\r\n置信水平 1 − α = 90%，故\r\nα = 0.10\r\n\r\n查表 自由度 df = n − 1 = 15，查\r\nχ2 分布表得： $$\r\n\\chi^2_{1-\\alpha/2}(15) = \\chi^2_{0.95}(15) = 7.261 \\\\\r\n\\chi^2_{\\alpha/2}(15) = \\chi^2_{0.05}(15) = 24.996\r\n$$\r\n\r\n计算置信区间 $$\r\n\\left[ \\frac{(n-1)s^2}{\\chi^2_{\\alpha/2}(n-1)},\r\n\\frac{(n-1)s^2}{\\chi^2_{1-\\alpha/2}(n-1)} \\right]\r\n$$\r\n估计总体方差，总体均值已知未知都是这个式子\r\n代入数值： $$\r\n\\left[ \\frac{15 \\times 1.2^2}{24.996}, \\frac{15 \\times 1.2^2}{7.261}\r\n\\right] = \\left[ \\frac{21.6}{24.996}, \\frac{21.6}{7.261} \\right] =\r\n[0.864, 2.975]\r\n$$\r\n结论\r\nσ2\r\n的90%置信区间为 [0.864, 2.975] cm2\r\n\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"概率论常见公式的详细推导和概率公理化的内容描述","url":"/posts/58802.html","content":"关于概率的公理化的一些说明\r\n概率的公理化定义\r\n设有随机试验E，E的样本空间为Ω，记包括Ω在内的E的所有时间组成的集合族为ℱ，若ℱ对中的任意一个事件A都能赋予一个实数P(A)，且P(A)满足条件：\r\n\r\n非负性：0 ≤ P(A) ≤ 1；\r\n规范性：P(Ω) = 1；\r\n可列可加性：对两两互不相容的事件A1, A2, ⋯，有\r\n$$\r\nP\\left(\\sum_{i = 1}^{\\infty}A_i\\right)=\\sum_{i = 1}^{\\infty}P(A_i)\r\n$$\r\n\r\n则称P(A)为事件A的概率\r\n关于概率的公理化定义一些额外内容\r\n其中，设ℱ是由Ω中的子集组成的子集类，若具有\r\n\r\nΩ ∈ ℱ\r\n若$\\overline{A} \\in\r\n\\mathscr{F}$，则$\\overline{A} = \\Omega\r\n- A \\in \\mathscr{F}$\r\n若An ∈ ℱ（对一切n ≥ 1），则$\\bigcup_{n = 1}^{\\infty} A_n \\in\r\n\\mathscr{F}$，即称ℱ为Ω中的σ域（或称为σ代数）。\r\n\r\n可以证明，当ℱ是Ω中的σ域时，有如下结论成立：\r\n\r\n若Ai ∈ ℱ(i = 1, ⋯, n)，则$\\bigcup_{i = 1}^{n} A_i \\in \\mathscr{F}$ 且\r\n$\\bigcap_{i = 1}^{n} A_i \\in\r\n\\mathscr{F}$；\r\n若Ai ∈ ℱ(i = 1, 2, ⋯)，则$\\bigcap_{i = 1}^{\\infty} A_i \\in\r\n\\mathscr{F}$；\r\n若A ∈ ℱ，B ∈ ℱ，则A − B ∈ ℱ。\r\n\r\n显然σ域的定义是在保证这样的事件子集类在事件的基本运算具有某些封闭性的要求下建立的。\r\n上述三条结论是如何证明的呢\r\nσ域与概率公理化的关系：“事件子集类的封闭规则”\r\n这里是一些关于σ域的说明\r\n设ℱ是由 Ω 中的子集组成的子集类，若满足 3\r\n条规则，就称 ℱ 是 Ω 中的 σ 域 。\r\n这 3\r\n条规则，本质是“事件子集类对运算的封闭性”（即：对这些运算，子集类不会\r\n“跑出去”），对应概率公理化里的逻辑：\r\n\r\nΩ ∈ ℱ\r\n样本空间本身要包含在里\r\n概率公理化中，样本空间 Ω\r\n是“必然事件”，概率 P(Ω) = 1（规范性）。σ 域 先把 Ω\r\n包含进来，保证“必然事件”是讨论的基础。\r\n若$\\overline{A} \\in\r\n\\mathscr{F}$，则$\\overline{A} = \\Omega\r\n- A \\in \\mathscr{F}$\r\n对“取补集”封闭\r\n概率里有“对立事件”（比如 “A\r\n发生” 和 “A不发生”），公理化定义也要求概率满足\r\n$P(\\overline{A}) = 1 -\r\nP(A)$（后续可推导的性质）。σ\r\n域通过“补集封闭”，保证对立事件也在讨论范围内。\r\n若An ∈ ℱ（对一切n ≥ 1），则$\\bigcup_{n = 1}^{\\infty} A_n \\in\r\n\\mathscr{F}$，即称ℱ为Ω中的σ域（或称为σ代数）。\r\n对“可列并”封闭\r\n概率公理化里有“可列可加性”（3\r\n条核心条件之一），需要“无穷多个互斥事件的并”也是一个“合法事件”。σ\r\n域通过“可列并封闭”，为可列可加性铺路——先保证这类“无穷并事件”存在，才能给它定义概率。\r\n\r\n这三条结论都是能够直接从从σ−代数的定义推出的，这里不再提σ−代数的相关内容了\r\n回到概率公理化：σ\r\n域是“事件的合法范围”\r\n概率公理化定义里，有个关键前提： “包括 Ω 在内的 E 的所有事件组成的集合族为ℱ ” ——这里的ℱ ，必须是一个σ 域！换句话说：\r\n\r\n不是随便选一些子集就能当“事件”，得满足 σ 域的封闭性（补、可列并、包含 Ω 等）。\r\n只有这样，概率 P(A) 才能用公理化的 3\r\n条条件（非负、规范、可列可加）“合理定义”到这些事件上。\r\n\r\n打个比方：σ\r\n域像一个“合法事件的容器”，先规定好哪些子集能当“事件”（满足封闭性），概率公理化再给这些“合法事件”赋予概率值，保证运算不出错。\r\n那么，概率为0的事件是否一定不可能？\r\n其实就不一定了。在连续空间中，单点概率为0（如均匀分布下 P(0.5) = 0），但“概率为0”不等价于“不可能发生”（不可能事件仅指\r\n∅）。\r\n总结：σ\r\n域与概率公理化的关系\r\n简单说：σ\r\n域负责“事件合法”，概率公理化负责“给合法事件赋值”，缺一不可\r\n\r\nσ\r\n域是“事件的规则边界”：限定哪些子集能被称为“事件”，保证事件在补、并（有限/可列）、交（有限/可列）、差运算下“不超界”。\r\n概率公理化是“事件的数值规则”：给这些“合法事件”赋予概率值，且要求概率满足非负、规范、可列可加。\r\n\r\n二者配合，才能严格定义“概率”——σ\r\n域先圈定“能讨论的事件”，概率公理化再给这些事件“赋值规则”。\r\n接下来是对内容里三条结论的证明\r\n\r\n若Ai ∈ ℱ(i = 1, ⋯, n)，则$\\bigcup_{i = 1}^{n}A_i\\in\\mathcal{F}$且$\\bigcap_{i = 1}^{n}A_i\\in\\mathcal{F}$\r\n本质上就是在证明σ−代数对有限并和有限交的封闭性\r\n\r\n证明$\\boldsymbol{\\bigcup_{i =\r\n1}^{n}A_i\\in\\mathcal{F}}$：\r\n利用 σ\r\n域对可列并的封闭性，构造可列个事件：令An + 1 = An + 2 = ⋯ = ⌀（空集，根据后续易证⌀ ∈ ℱ），且由σ域定义，若A ∈ ℱ，$\\overline{A}\\in\\mathcal{F}$，又Ω ∈ ℱ，则$\\varnothing=\\overline{\\Omega}\\in\\mathcal{F}$。\r\n此时$\\bigcup_{i = 1}^{n}A_i=\\bigcup_{i =\r\n1}^{\\infty}A_i$（因为后面添加的空集不影响并集结果 ），由于ℱ是 σ 域，对可列并封闭，即若Ai ∈ ℱ(i ≥ 1)，则$\\bigcup_{i =\r\n1}^{\\infty}A_i\\in\\mathcal{F}$，所以$\\bigcup_{i = 1}^{n}A_i\\in\\mathcal{F}$\r\n。\r\n证明$\\boldsymbol{\\bigcap_{i =\r\n1}^{n}A_i\\in\\mathcal{F}}$：\r\n根据德摩根律$\\bigcap_{i =\r\n1}^{n}A_i=\\overline{\\bigcup_{i = 1}^{n}\\overline{A_i}}$ 。\r\n已知Ai ∈ ℱ，由σ域对补集的封闭性（若A ∈ ℱ，则$\\overline{A}\\in\\mathcal{F}$），可得$\\overline{A_i}\\in\\mathcal{F}(i =\r\n1,\\cdots,n)$ 。\r\n再由前面已证的 “有限个事件并集属于ℱ”，可知$\\bigcup_{i\r\n= 1}^{n}\\overline{A_i}\\in\\mathcal{F}$。\r\n最后，再次利用补集封闭性，对$\\bigcup_{i =\r\n1}^{n}\\overline{A_i}$取补集，即$\\overline{\\bigcup_{i =\r\n1}^{n}\\overline{A_i}}\\in\\mathcal{F}$，也就是$\\bigcap_{i = 1}^{n}A_i\\in\\mathcal{F}$\r\n。\r\n\r\n若Ai ∈ ℱ(i = 1, 2, ⋯)，则$\\bigcap_{i =\r\n1}^{\\infty}A_i\\in\\mathcal{F}$\r\n根据德摩根律，$\\bigcap_{i =\r\n1}^{\\infty}A_i=\\overline{\\bigcup_{i =\r\n1}^{\\infty}\\overline{A_i}}$。\r\n\r\n因为Ai ∈ ℱ，由σ域对补集的封闭性，$\\overline{A_i}\\in\\mathcal{F}(i =\r\n1,2,\\cdots)$。\r\n又因为ℱ是σ域，对可列并封闭，所以$\\bigcup_{i =\r\n1}^{\\infty}\\overline{A_i}\\in\\mathcal{F}$ 。\r\n最后依据补集封闭性，对$\\bigcup_{i =\r\n1}^{\\infty}\\overline{A_i}$取补集，可得$\\overline{\\bigcup_{i =\r\n1}^{\\infty}\\overline{A_i}}\\in\\mathcal{F}$，即$\\bigcap_{i =\r\n1}^{\\infty}A_i\\in\\mathcal{F}$。\r\n\r\n若A ∈ ℱ，B ∈ ℱ，则A − B ∈ ℱ\r\n根据集合运算关系，$A - B =\r\nA\\cap\\overline{B}$ 。\r\n\r\n已知B ∈ ℱ，由σ域对补集的封闭性，$\\overline{B}\\in\\mathcal{F}$ 。\r\n又A ∈ ℱ，再根据前面已证的\r\n“两个事件交集属于ℱ”（n = 2时的结论 ），(A)，也就是A − B ∈ ℱ 。\r\n\r\n\r\n由此，可推导出概率的一些重要性质\r\n\r\n不可能事件的概率为0，即 P(⌀) = 0\r\n\r\n证明：\r\n\r\n(有限可加性) 若事件Ai(i = 1, ⋯, n)中两两互不相容，则\r\n$$\r\nP\\left(\\sum_{i = 1}^{\\infty}A_i\\right)=\\sum_{i = 1}^{\\infty}P(A_i)\r\n$$\r\n\r\n证明：\r\n\r\n(逆事件概率的计算) $P(\\overline A) = 1\r\n- P(A)$\r\n\r\n证明：\r\n\r\n(差事件概率的计算和概率的单调性) 若 B ⊂ A，则 P(A − B) = P(A) − P(B)，若A ⊆ B，则P(B) ≤ P(A)\r\n\r\n证明\r\n\r\n(加法公式) 对于任意两个事件A 和 B，有：P(A⋃B) = P(A) + P(B) − P(A ∩ B)\r\n上述为两个加法公式的内容，可以扩展到多个\r\n对于任意 n 个事件 A1, A2, …, An，有：\r\n$$\r\n\\begin{align*} P\\left( \\bigcup_{i = 1}^{n} A_i \\right) &amp;= \\sum_{i =\r\n1}^{n} P(A_i) - \\sum_{1 \\leq i &lt; j \\leq n} P(A_i \\cap A_j) + \\sum_{1\r\n\\leq i &lt; j &lt; k \\leq n} P(A_i \\cap A_j \\cap A_k) - \\dots \\\\\r\n&amp;\\quad + (-1)^{n - 1} P(A_1 \\cap A_2 \\cap \\dots \\cap A_n)\r\n\\end{align*}\r\n$$\r\n\r\n证明：下面证\r\n\r\n\r\n公式推导\r\n加法公式\r\n\r\n两个加法公式的推导过程\r\n\r\n含义：“$A $或 $B $发生” 的概率，等于 A 发生概率加 B 发生概率，减去 “A 且 B 同时发生”\r\n的概率（避免重复计算交集部分 ）。\r\n证明：\r\n利用集合分解：将 A ∪ B\r\n拆分为互不相交的三个部分（基于集合运算）：\r\nA ∪ B = A ∪ (B − A ∩ B)\r\n其中 A 与 B − A ∩ B\r\n是互不相容事件（即 A ∩ (B − A ∩ B) = ⌀，因为\r\nB − A ∩ B 是\r\nB 中去掉与 A 重叠的部分）。\r\n根据概率的有限可加性（由”可列可加性”推导而来：若 A1, A2, …, An\r\n两两互不相容，令 An + 1 = An + 2 = … = ⌀\r\n结合可列可加性 $P\\left(\\bigcup_{i =\r\n1}^{\\infty} A_i\\right) = \\sum_{i = 1}^{\\infty}\r\nP(A_i)$，可推出有限可加性 $P\\left(\\bigcup_{i = 1}^{n} A_i\\right) = \\sum_{i =\r\n1}^{n} P(A_i)$），有：\r\nP(A ∪ B) = P(A) + P(B − A ∩ B)\r\n再看 B − A ∩ B，它等于\r\n$B \\cap \\overline{A \\cap\r\nB}$（差集定义），而根据概率的单调性与差事件公式\r\n若 C ⊆ D，则 P(D − C) = P(D) − P(C)\r\n可由”若 A, B ∈ ℱ，则 A − B ∈ ℱ“结合有限可加性推导：因为\r\nD = C ∪ (D − C)\r\n且 C 与 D − C 互不相容\r\n所以 P(D) = P(C) + P(D − C)，即\r\nP(D − C) = P(D) − P(C)）\r\n由于 A ∩ B ⊆ B，因此：\r\nP(B − A ∩ B) = P(B) − P(A ∩ B)\r\n将上式代入 P(A ∪ B) = P(A) + P(B − A ∩ B)，就得到：\r\nP(A ∪ B) = P(A) + P(B) − P(A ∩ B)\r\n\r\n多个加法公式的推导过程\r\n\r\n含义：“至少一个事件发生”\r\n的概率，通过容斥原理，交替加减\r\n“单个事件概率”“两个事件交集概率”“三个事件交集概率”…… 最后加上（或减去\r\n）“所有事件交集概率”，消除重复 / 遗漏计数。\r\n证明：\r\n数学归纳法秒了（）））））\r\n归纳假设： 假设对 n = k 个事件 A1, A2, …, Ak，加法公式成立，即：\r\nP( {i = 1}^{k} A_i ) = {i =\r\n1}^{k} P(A_i) - {1 i &lt; j k} P(A_i A_j) + + (-1)^{k - 1} P(A_1\r\nA_k) $$\r\n**归纳步骤（$n = k + 1$）**：\r\n把 $\\bigcup_{i = 1}^{k + 1} A_i$ 看作 $\\left( \\bigcup_{i = 1}^{k} A_i\r\n\\right) \\cup A_{k + 1}$，利用两个事件的加法公式：\r\n$$ P( {i = 1}^{k + 1} A_i ) = P( {i = 1}^{k} A_i ) +\r\nP(A{k + 1}) - P( ( {i = 1}^{k} A_i ) A{k + 1} ) $$\r\n其中，$\\left( \\bigcup_{i = 1}^{k} A_i \\right)\r\n\\cap A_{k + 1} = \\bigcup_{i = 1}^{k} (A_i \\cap A_{k +\r\n1})$（分配律：(A ∪ B) ∩ C = (A ∩ C) ∪ (B ∩ C)\r\n推广到 k 个集合）。\r\n再对 $\\bigcup_{i = 1}^{k} (A_i \\cap A_{k +\r\n1})$ 用归纳假设（把 Ai ∩ Ak + 1\r\n看作新的”单个事件”），可得：\r\n$$\r\n\\begin{aligned}\r\nP\\left( \\bigcup_{i = 1}^{k} (A_i \\cap A_{k + 1}) \\right) &amp;= \\sum_{i\r\n= 1}^{k} P(A_i \\cap A_{k + 1}) \\\\\r\n&amp;\\quad - \\sum_{1 \\leq i &lt; j \\leq k} P((A_i \\cap A_{k + 1}) \\cap\r\n(A_j \\cap A_{k + 1})) \\\\\r\n&amp;\\quad + \\dots \\\\\r\n&amp;\\quad + (-1)^{k - 1} P(A_1 \\cap \\dots \\cap A_k \\cap A_{k + 1})\r\n\\end{aligned}\r\n$$ 注意到 (Ai ∩ Ak + 1) ∩ (Aj ∩ Ak + 1) = Ai ∩ Aj ∩ Ak + 1，以此类推，将各项代入并整理后，可验证\r\nn = k + 1\r\n时公式也成立。\r\n结合基例与归纳步骤，由数学归纳法可知，n 个事件的加法公式对任意正整数 n 成立。\r\n可以看出这其实就是概率公理化定义中 “可列可加性”\r\n的直接体现，也可看作加法公式在 “可列无穷、互不相容”\r\n场景下的特殊形式。\r\n\r\n\r\n条件概率公式\r\n设 (Ω, ℱ, P)\r\n是一个概率空间，A, B ∈ ℱ 是两个事件，且\r\nP(B) &gt; 0。事件\r\nA 在给定 B 发生的条件下的条件概率定义为：\r\n$$\r\nP(A|B) = \\frac{P(A \\cap B)}{P(B)}\r\n$$\r\n条件概率公式的推导过程\r\n推导思路： 条件概率的本质是在已知事件 B\r\n发生的情况下，重新定义概率测度。推导可以从以下两个角度理解：\r\n\r\n几何直观法（面积比例）：\r\n\r\n将样本空间 Ω\r\n看作单位面积\r\nP(B) 表示事件\r\nB 的面积\r\nP(A ∩ B)\r\n表示 A 和 B 同时发生的面积\r\n在 B\r\n发生的条件下，新的样本空间缩小为 B\r\nA 发生的”相对面积”就是\r\n$\\frac{P(A \\cap B)}{P(B)}$\r\n\r\n公理化推导： 条件概率 P(⋅|B)\r\n必须满足概率的三条公理：\r\n\r\n非负性：显然 P(A|B) ≥ 0\r\n规范性：$P(\\Omega|B) =\r\n\\frac{P(\\Omega \\cap B)}{P(B)} = 1$\r\n可列可加性：对于互不相容的事件序列 {Ai}： P({i=1}^A_i | B) = = {i=1}^ =\r\n_{i=1}^P(A_i|B) $$\r\n\r\n\r\n严格推导步骤：\r\n\r\n定义新的测度： 对于固定的事件 B 满足 P(B) &gt; 0，定义： $$\r\nP_B(A) = \\frac{P(A \\cap B)}{P(B)}\r\n$$\r\n验证概率公理：\r\n\r\n非负性：由于 P(A ∩ B) ≥ 0 且\r\nP(B) &gt; 0，故 PB(A) ≥ 0\r\n规范性： $$\r\nP_B(\\Omega) = \\frac{P(\\Omega \\cap B)}{P(B)} = \\frac{P(B)}{P(B)} = 1\r\n$$\r\n可列可加性： 设 {Ai}\r\n是互不相容的事件序列，则： $$\r\n\\begin{aligned}\r\nP_B\\left(\\bigcup_{i=1}^\\infty A_i\\right) &amp;=\r\n\\frac{P\\left(\\bigcup_{i=1}^\\infty (A_i \\cap B)\\right)}{P(B)} \\\\\r\n&amp;= \\frac{\\sum_{i=1}^\\infty P(A_i \\cap B)}{P(B)} \\\\\r\n&amp;= \\sum_{i=1}^\\infty \\frac{P(A_i \\cap B)}{P(B)} \\\\\r\n&amp;= \\sum_{i=1}^\\infty P_B(A_i)\r\n\\end{aligned}\r\n$$\r\n\r\n结论： 因此，PB(⋅)\r\n是一个合法的概率测度，我们将其记作 P(⋅|B)，即： $$\r\nP(A|B) = \\frac{P(A \\cap B)}{P(B)}\r\n$$\r\n\r\n直观理解：\r\n\r\n分子 P(A ∩ B)：A 和 B 同时发生的概率\r\n分母 P(B)：对概率进行”归一化”，使得在新的条件下\r\nP(B|B) = 1\r\n比值反映了在 B\r\n发生的”世界”中，A\r\n发生的相对概率\r\n\r\n条件概率公式也满足概率公理化的性质：非负，规范，可列可加\r\n乘法概率公式\r\n设 (Ω, ℱ, P)\r\n是一个概率空间，A1, A2, …, An ∈ ℱ\r\n是事件，且满足 $P\\left(\\bigcap_{i=1}^{k}\r\nA_i\\right) &gt; 0$ 对所有 k &lt; n\r\n成立。则乘法公式为：\r\n$$\r\nP\\left(\\bigcap_{i=1}^n A_i\\right) = P(A_1) \\cdot P(A_2|A_1) \\cdot\r\nP(A_3|A_1 \\cap A_2) \\cdots P(A_n|A_1 \\cap \\cdots \\cap A_{n-1})\r\n$$\r\n乘法公式的推导过程\r\n推导思路：\r\n乘法公式可以通过反复应用条件概率的定义得到。换一下的事\r\n基础情形（n=2）： 由条件概率定义直接可得： P(A1 ∩ A2) = P(A1) ⋅ P(A2|A1)\r\n归纳步骤： 假设公式对 n = k 成立，证明对 n = k + 1 也成立： $$\r\n\\begin{aligned}\r\nP\\left(\\bigcap_{i=1}^{k+1} A_i\\right) &amp;=\r\nP\\left(\\left(\\bigcap_{i=1}^k A_i\\right) \\cap A_{k+1}\\right) \\\\\r\n&amp;= P\\left(\\bigcap_{i=1}^k A_i\\right) \\cdot\r\nP\\left(A_{k+1}\\bigg|\\bigcap_{i=1}^k A_i\\right) \\\\\r\n&amp;= \\left[ \\prod_{i=1}^k P\\left(A_i \\bigg| \\bigcap_{j=1}^{i-1} A_j\r\n\\right) \\right] \\cdot P\\left(A_{k+1}\\bigg|\\bigcap_{i=1}^k A_i\\right) \\\\\r\n&amp;= \\prod_{i=1}^{k+1} P\\left(A_i \\bigg| \\bigcap_{j=1}^{i-1} A_j\r\n\\right)\r\n\\end{aligned}\r\n$$ 完整推导：\r\n数学归纳秒了）））\r\n\r\n初始步骤： 对于两个事件 A1 和 A2，由条件概率定义：\r\n$$\r\nP(A_2|A_1) = \\frac{P(A_1 \\cap A_2)}{P(A_1)}\r\n$$ 变形即得：\r\nP(A1 ∩ A2) = P(A1) ⋅ P(A2|A1)\r\n三个事件的情形： 对于三个事件 A1, A2, A3：\r\n$$\r\n\\begin{aligned}\r\nP(A_1 \\cap A_2 \\cap A_3) &amp;= P((A_1 \\cap A_2) \\cap A_3) \\\\\r\n&amp;= P(A_1 \\cap A_2) \\cdot P(A_3|A_1 \\cap A_2) \\\\\r\n&amp;= P(A_1) \\cdot P(A_2|A_1) \\cdot P(A_3|A_1 \\cap A_2)\r\n\\end{aligned}\r\n$$\r\n一般情形（数学归纳法）：\r\n\r\n基例：n = 2 时已证明成立\r\n归纳假设：假设对 n = k 成立\r\n归纳步骤：对 n = k + 1，有：\r\n$$\r\n\\begin{aligned}\r\nP\\left(\\bigcap_{i=1}^{k+1} A_i\\right) &amp;=\r\nP\\left(\\left(\\bigcap_{i=1}^k A_i\\right) \\cap A_{k+1}\\right) \\\\\r\n&amp;= P\\left(\\bigcap_{i=1}^k A_i\\right) \\cdot\r\nP\\left(A_{k+1}\\bigg|\\bigcap_{i=1}^k A_i\\right) \\\\\r\n&amp;= \\left[ \\prod_{i=1}^k P\\left(A_i \\bigg| \\bigcap_{j=1}^{i-1} A_j\r\n\\right) \\right] \\cdot P\\left(A_{k+1}\\bigg|\\bigcap_{i=1}^k A_i\\right) \\\\\r\n&amp;= \\prod_{i=1}^{k+1} P\\left(A_i \\bigg| \\bigcap_{j=1}^{i-1} A_j\r\n\\right)\r\n\\end{aligned}\r\n$$\r\n\r\n\r\n直观解释：\r\n乘法公式描述的是多个事件同时发生的概率，可以理解为： 1.\r\n第一个事件发生的概率 P(A1) 2.\r\n在第一个事件发生的条件下，第二个事件发生的概率 P(A2|A1)\r\n3. 在前两个事件都发生的条件下，第三个事件发生的概率 P(A3|A1 ∩ A2)\r\n… n. 在前 n − 1\r\n个事件都发生的条件下，第 n\r\n个事件发生的概率 P(An|A1 ∩ ⋯ ∩ An − 1)\r\n这些概率的乘积就是所有事件同时发生的概率。\r\n应用示例：\r\n从一副52张的扑克牌中不放回地抽取3张牌，求都是A的概率： $$\r\n\\begin{aligned}\r\nP(A_1 \\cap A_2 \\cap A_3) &amp;= P(A_1) \\cdot P(A_2|A_1) \\cdot P(A_3|A_1\r\n\\cap A_2) \\\\\r\n&amp;= \\frac{4}{52} \\cdot \\frac{3}{51} \\cdot \\frac{2}{50}\r\n\\end{aligned}\r\n$$\r\n全概率公式\r\n常用形式： $$\r\nP(A) = P(A | B)  P(B) + P(A | \\overline B)  P(\\overline B)\r\n$$ 设 (Ω, ℱ, P)\r\n是一个概率空间，{Bi}i = 1n\r\n是样本空间 Ω\r\n的一个划分\r\n\r\n即满足：Bi ∩ Bj = ⌀\r\n对任意 i ≠ j，且\r\n$\\bigcup_{i=1}^n B_i = \\Omega$\r\n\r\n且 P(Bi) &gt; 0\r\n对所有 i 成立。则对任意事件\r\nA ∈ ℱ，有： $$\r\nP(A) = \\sum_{i=1}^n P(A \\cap B_i) = \\sum_{i=1}^n P(B_i) \\cdot P(A|B_i)\r\n$$\r\n全概率公式的推导过程\r\n推导思路： 全概率公式的核心思想是将复杂事件 A 分解到各个划分 Bi\r\n上，通过”分而治之”的方式计算其概率。\r\nB在Ω上划分的几何直观：\r\n\r\n将样本空间 Ω\r\n划分为若干互不重叠的区域 B1, B2, …, Bn\r\n事件 A 与每个 Bi 的交 A ∩ Bi\r\n互不相容\r\nA 的总面积等于它在各个\r\nBi\r\n区域上面积的和\r\n\r\n严格推导：\r\n\r\n利用划分性质： 由于 {Bi} 是 Ω 的划分，可将 A 表示为： $$\r\nA = A \\cap \\Omega = A \\cap \\left(\\bigcup_{i=1}^n B_i\\right) =\r\n\\bigcup_{i=1}^n (A \\cap B_i)\r\n$$\r\n概率的可加性： 由于 Bi 互不相容，故\r\nA ∩ Bi\r\n也互不相容。由概率的可列可加性： $$\r\nP(A) = P\\left(\\bigcup_{i=1}^n (A \\cap B_i)\\right) = \\sum_{i=1}^n P(A\r\n\\cap B_i)\r\n$$\r\n引入条件概率： 根据条件概率定义 $P(A|B_i) = \\frac{P(A \\cap\r\nB_i)}{P(B_i)}$，可得： P(A ∩ Bi) = P(Bi) ⋅ P(A|Bi)\r\n综合得到公式： 将步骤3代入步骤2： $$\r\nP(A) = \\sum_{i=1}^n P(B_i) \\cdot P(A|B_i)\r\n$$\r\n\r\n贝叶斯公式\r\n设 (Ω, ℱ, P)\r\n是一个概率空间，{Bi}i = 1n\r\n是样本空间 Ω\r\n的一个划分\r\n\r\n即满足：Bi ∩ Bj = ⌀\r\n对任意 i ≠ j，且\r\n$\\bigcup_{i=1}^n B_i = \\Omega$\r\n\r\n且 P(Bi) &gt; 0\r\n对所有 i 成立。则对任意事件\r\nA ∈ ℱ 且 P(A) &gt; 0，有： $$\r\nP(B_i|A) = \\frac{P(B_i) \\cdot P(A|B_i)}{\\sum_{j=1}^n P(B_j) \\cdot\r\nP(A|B_j)} = \\frac{P(B_i) \\cdot P(A|B_i)}{P(A)}\r\n$$\r\n上面是乘法公式，下面是全概率公式的全划分，也就是P(A)，0秒记住公式性质)))\r\n贝叶斯公式的推导过程\r\n推导思路：\r\n贝叶斯公式本质上是条件概率定义与全概率公式的结合。\r\n几何直观： - 已知各个”原因” Bi\r\n及其导致”结果” A 的概率 -\r\n当观察到结果 A\r\n发生时，反推各个原因 Bi\r\n的贡献比例\r\n严格推导：\r\n\r\n从条件概率定义出发： 由条件概率的定义： $$\r\nP(B_i|A) = \\frac{P(B_i \\cap A)}{P(A)}\r\n$$\r\n分子处理： 利用乘法公式： P(Bi ∩ A) = P(Bi) ⋅ P(A|Bi)\r\n分母处理： 应用全概率公式： $$\r\nP(A) = \\sum_{j=1}^n P(B_j) \\cdot P(A|B_j)\r\n$$\r\n综合得到公式： 将步骤2和步骤3代入步骤1： $$\r\nP(B_i|A) = \\frac{P(B_i) \\cdot P(A|B_i)}{\\sum_{j=1}^n P(B_j) \\cdot\r\nP(A|B_j)}\r\n$$\r\n\r\n关键理解： - 先验概率 P(Bi)：在观测\r\nA 之前对 Bi 的初始信念 -\r\n似然 P(A|Bi)：在\r\nBi\r\n成立的条件下 A 发生的概率 -\r\n证据 P(A)：标准化常数，确保概率总和为1\r\n- 后验概率 P(Bi|A)：观测到\r\nA 后对 Bi\r\n的更新信念\r\n推广形式： 对连续随机变量，贝叶斯公式表现为： $$\r\n\\pi(\\theta|x) = \\frac{f(x|\\theta)\\pi(\\theta)}{\\int\r\nf(x|\\theta)\\pi(\\theta)d\\theta}\r\n$$ 其中 π(θ)\r\n是先验分布，f(x|θ)\r\n是似然函数，π(θ|x)\r\n是后验分布。\r\n","categories":["数学类","概率论与数理统计"],"tags":["算法","学习类","数学","数学建模","概率论与数理统计","定理证明"]},{"title":"正确使用Markdown语法进行排版的示例","url":"/posts/1878.html","content":"教程\r\n这是一篇讲解如何正确使用 Markdown\r\n的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。\r\n\r\n引用文本：Markdown is a text formatting syntax.\r\n\r\n语法指导\r\n普通内容\r\n这段内容展示了在内容里面一些排版格式，比如：\r\n\r\n加粗 - **加粗**\r\n倾斜 - *倾斜*\r\n删除线 - ~~删除线~~\r\nCode 标记 - `Code 标记`\r\n超级链接 -\r\n[超级链接](https://lddgo.net)\r\nusername@gmail.com -\r\n[username@gmail.com](mailto:username@gmail.com)\r\n\r\n大标题 - Heading 3\r\n你可以选择使用 H1 至 H6，使用 ##(N) 打头。\r\n\r\nNOTE: 别忘了 # 后面需要有空格！\r\n\r\nHeading 4\r\nHeading 5\r\nHeading 6\r\n图片\r\n![alt 文本](http://image-path.png)![alt 文本](http://image-path.png &quot;图片 Title 值&quot;)\r\n代码块\r\n普通\r\n*emphasize*    **strong**_emphasize_    __strong__var a = 1\r\n语法高亮支持\r\n如果在 ``` 后面跟随语言名称，可以有语法高亮的效果哦，比如:\r\n演示 Go 代码高亮\r\npackage mainimport &quot;fmt&quot;func main() &#123;\tfmt.Println(&quot;Hello, 世界&quot;)&#125;\r\n演示 Java 高亮\r\npublic class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;\r\n\r\nTip: 语言名称支持下面这些: ruby, python,\r\njs, html, erb, css,\r\ncoffee, bash, json,\r\nyml, xml …\r\n\r\n有序、无序、任务列表\r\n无序列表\r\n\r\nJava\r\n\r\nSpring\r\n\r\nIoC\r\nAOP\r\n\r\n\r\nGo\r\n\r\ngofmt\r\nWide\r\n\r\nNode.js\r\n\r\nKoa\r\nExpress\r\n\r\n\r\n有序列表\r\n\r\nNode.js\r\n\r\nExpress\r\nKoa\r\nSails\r\n\r\nGo\r\n\r\ngofmt\r\nWide\r\n\r\nJava\r\n\r\nLatke\r\nIDEA\r\n\r\n\r\n任务列表\r\n\r\n发布 Sym\r\n发布 Solo\r\n预约牙医\r\n\r\n表格\r\n如果需要展示数据什么的，可以选择使用表格。\r\n\r\n\r\n\r\nheader 1\r\nheader 2\r\n\r\n\r\n\r\n\r\ncell 1\r\ncell 2\r\n\r\n\r\ncell 3\r\ncell 4\r\n\r\n\r\ncell 5\r\ncell 6\r\n\r\n\r\n\r\n隐藏细节\r\n\r\n\r\n这里是摘要部分。\r\n\r\n这里是细节部分。\r\n\r\n段落\r\n空行可以将内容进行分段，便于阅读。（这是第一段）\r\n使用空行在 Markdown 排版中相当重要。（这是第二段）\r\n链接引用\r\n链接文本\r\nLDDGO.NET\r\n[链接文本](链接地址)\r\n数学公式\r\n多行公式块：\r\n$$\r\n\\frac{1}{\r\n  \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\r\n  \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {\r\n    1+\\frac{e^{-6\\pi}}\r\n    {1+\\frac{e^{-8\\pi}}{1+\\cdots}}\r\n  }\r\n}\r\n$$\r\n行内公式：\r\n公式 a2 + b2 = colorredc2\r\n是行内。\r\n脑图\r\n- 教程- 语法指导  - 普通内容  - 大标题 - Heading 3    - Heading 4      - Heading 5        - Heading 6  - 图片  - 代码块    - 普通    - 语法高亮支持      - 演示 Go 代码高亮      - 演示 Java 高亮  - 有序、无序、任务列表    - 无序列表    - 有序列表    - 任务列表  - 表格  - 隐藏细节  - 段落  - 链接引用  - 数学公式  - 脑图  - 流程图  - 时序图  - 甘特图  - 图表  - 五线谱  - Graphviz  - 脚注\r\n流程图\r\n\n    graph TB\n    c1--&gt;a2\n    subgraph one\n    a1--&gt;a2\n    end\n    subgraph two\n    b1--&gt;b2\n    end\n    subgraph three\n    c1--&gt;c2\n    end\n  \r\ngraph TB\n    c1--&gt;a2\n    subgraph one\n    a1--&gt;a2\n    end\n    subgraph two\n    b1--&gt;b2\n    end\n    subgraph three\n    c1--&gt;c2\n    end\r\n时序图\r\nsequenceDiagram\n    Alice-&gt;&gt;John: Hello John, how are you?\n    loop Every minute\n        John--&gt;&gt;Alice: Great!\n    end\r\n甘特图\r\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2019-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2019-01-12  , 12d\n    another task      : 24d\r\n状态图\r\n\n    stateDiagram\n    [*] --&gt; s1\n    s1 --&gt; [*]\n  \r\nstateDiagram\n    [*] --&gt; s1\n    s1 --&gt; [*]\r\n类图\r\n语法解释：&lt;|-- 表示继承，+ 表示\r\npublic，- 表示 private，学过 Java\r\n的应该都知道。\r\nclassDiagram\n      Animal &lt;|-- Duck\n      Animal &lt;|-- Fish\n      Animal &lt;|-- Zebra\n      Animal : +int age\n      Animal : +String gender\n      Animal: +isMammal()\n      Animal: +mate()\n      class Duck&#123;\n          +String beakColor\n          +swim()\n          +quack()\n      &#125;\n      class Fish&#123;\n          -int sizeInFeet\n          -canEat()\n      &#125;\n      class Zebra&#123;\n          +bool is_wild\n          +run()\n      &#125;\r\n饼图\r\n饼图使用 pie\r\n表示，标题下面分别是区域名称及其百分比。\r\npie\n    title Key elements in Product X\n    &quot;Calcium&quot; : 42.96\n    &quot;Potassium&quot; : 50.05\n    &quot;Magnesium&quot; : 10.01\n    &quot;Iron&quot; :  5\r\n\r\n以下的需要特定方法才能解析，typora和大部分markdown编辑器不能解析\r\n图表\r\n&#123;  &quot;title&quot;: &#123; &quot;text&quot;: &quot;最近 30 天&quot; &#125;,  &quot;tooltip&quot;: &#123; &quot;trigger&quot;: &quot;axis&quot;, &quot;axisPointer&quot;: &#123; &quot;lineStyle&quot;: &#123; &quot;width&quot;: 0 &#125; &#125; &#125;,  &quot;legend&quot;: &#123; &quot;data&quot;: [&quot;帖子&quot;, &quot;用户&quot;, &quot;回帖&quot;] &#125;,  &quot;xAxis&quot;: [&#123;      &quot;type&quot;: &quot;category&quot;,      &quot;boundaryGap&quot;: false,      &quot;data&quot;: [&quot;2019-05-08&quot;,&quot;2019-05-09&quot;,&quot;2019-05-10&quot;,&quot;2019-05-11&quot;,&quot;2019-05-12&quot;,&quot;2019-05-13&quot;,&quot;2019-05-14&quot;,&quot;2019-05-15&quot;,&quot;2019-05-16&quot;,&quot;2019-05-17&quot;,&quot;2019-05-18&quot;,&quot;2019-05-19&quot;,&quot;2019-05-20&quot;,&quot;2019-05-21&quot;,&quot;2019-05-22&quot;,&quot;2019-05-23&quot;,&quot;2019-05-24&quot;,&quot;2019-05-25&quot;,&quot;2019-05-26&quot;,&quot;2019-05-27&quot;,&quot;2019-05-28&quot;,&quot;2019-05-29&quot;,&quot;2019-05-30&quot;,&quot;2019-05-31&quot;,&quot;2019-06-01&quot;,&quot;2019-06-02&quot;,&quot;2019-06-03&quot;,&quot;2019-06-04&quot;,&quot;2019-06-05&quot;,&quot;2019-06-06&quot;,&quot;2019-06-07&quot;],      &quot;axisTick&quot;: &#123; &quot;show&quot;: false &#125;,      &quot;axisLine&quot;: &#123; &quot;show&quot;: false &#125;  &#125;],  &quot;yAxis&quot;: [&#123; &quot;type&quot;: &quot;value&quot;, &quot;axisTick&quot;: &#123; &quot;show&quot;: false &#125;, &quot;axisLine&quot;: &#123; &quot;show&quot;: false &#125;, &quot;splitLine&quot;: &#123; &quot;lineStyle&quot;: &#123; &quot;color&quot;: &quot;rgba(0, 0, 0, .38)&quot;, &quot;type&quot;: &quot;dashed&quot; &#125; &#125; &#125;],  &quot;series&quot;: [    &#123;      &quot;name&quot;: &quot;帖子&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#d23f31&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 3,      &quot;data&quot;: [&quot;18&quot;,&quot;14&quot;,&quot;22&quot;,&quot;9&quot;,&quot;7&quot;,&quot;18&quot;,&quot;10&quot;,&quot;12&quot;,&quot;13&quot;,&quot;16&quot;,&quot;6&quot;,&quot;9&quot;,&quot;15&quot;,&quot;15&quot;,&quot;12&quot;,&quot;15&quot;,&quot;8&quot;,&quot;14&quot;,&quot;9&quot;,&quot;10&quot;,&quot;29&quot;,&quot;22&quot;,&quot;14&quot;,&quot;22&quot;,&quot;9&quot;,&quot;10&quot;,&quot;15&quot;,&quot;9&quot;,&quot;9&quot;,&quot;15&quot;,&quot;0&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;用户&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#f1e05a&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 2,      &quot;data&quot;: [&quot;31&quot;,&quot;33&quot;,&quot;30&quot;,&quot;23&quot;,&quot;16&quot;,&quot;29&quot;,&quot;23&quot;,&quot;37&quot;,&quot;41&quot;,&quot;29&quot;,&quot;16&quot;,&quot;13&quot;,&quot;39&quot;,&quot;23&quot;,&quot;38&quot;,&quot;136&quot;,&quot;89&quot;,&quot;35&quot;,&quot;22&quot;,&quot;50&quot;,&quot;57&quot;,&quot;47&quot;,&quot;36&quot;,&quot;59&quot;,&quot;14&quot;,&quot;23&quot;,&quot;46&quot;,&quot;44&quot;,&quot;51&quot;,&quot;43&quot;,&quot;0&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;回帖&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#4285f4&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 1,      &quot;data&quot;: [&quot;35&quot;,&quot;42&quot;,&quot;73&quot;,&quot;15&quot;,&quot;43&quot;,&quot;58&quot;,&quot;55&quot;,&quot;35&quot;,&quot;46&quot;,&quot;87&quot;,&quot;36&quot;,&quot;15&quot;,&quot;44&quot;,&quot;76&quot;,&quot;130&quot;,&quot;73&quot;,&quot;50&quot;,&quot;20&quot;,&quot;21&quot;,&quot;54&quot;,&quot;48&quot;,&quot;73&quot;,&quot;60&quot;,&quot;89&quot;,&quot;26&quot;,&quot;27&quot;,&quot;70&quot;,&quot;63&quot;,&quot;55&quot;,&quot;37&quot;,&quot;0&quot;]    &#125;  ]&#125;\r\n五线谱\r\nX: 24T: Clouds ThickenC: Paul RosenS: Copyright 2005, Paul RosenM: 6/8L: 1/8Q: 3/8=116R: Creepy JigK: Em|:&quot;Em&quot;EEE E2G|&quot;C7&quot;_B2A G2F|&quot;Em&quot;EEE E2G|\\&quot;C7&quot;_B2A &quot;B7&quot;=B3|&quot;Em&quot;EEE E2G|&quot;C7&quot;_B2A G2F|&quot;Em&quot;GFE &quot;D (Bm7)&quot;F2D|\\1&quot;Em&quot;E3-E3:|2&quot;Em&quot;E3-E2B|:&quot;Em&quot;e2e gfe|&quot;G&quot;g2ab3|&quot;Em&quot;gfeg2e|&quot;D&quot;fedB2A|&quot;Em&quot;e2e gfe|\\&quot;G&quot;g2ab3|&quot;Em&quot;gfe&quot;D&quot;f2d|&quot;Em&quot;e3-e3:|\r\nGraphviz关系图\r\ngraph TD\n    S([S])\n    qi(( ))\n    \n    qi --&gt; S\n    S --&gt; q1[a]\n    S --&gt; S[a]\n    q1 --&gt; S[a]\n    q1 --&gt; q2[ddb]\n    q2 --&gt; q1[b]\n    q2 --&gt; q2[b]\r\n\n    graph TD\n    S([S])\n    qi(( ))\n    qi --&gt; S\n    S --&gt; q1[a]\n    S --&gt; S[a]\n    q1 --&gt; S[a]\n    q1 --&gt; q2[ddb]\n    q2 --&gt; q1[b]\n    q2 --&gt; q2[b]\n  \r\ngraph TD    S([S])    qi(( ))        qi --&gt; S    S --&gt; q1[a]    S --&gt; S[a]    q1 --&gt; S[a]    q1 --&gt; q2[ddb]    q2 --&gt; q1[b]    q2 --&gt; q2[b]\r\nFlowchart流程图\r\nst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\r\n脚注\r\n这里是一个脚注引用1，这里是另一个脚注引用2。\r\n缩进对齐的段落包含在这个脚注定义内。\r\n可以使用代码块。\r\n还有其他行级排版语法，比如加粗和链接。\r\n这里是一个脚注引用[^1]，这里是另一个脚注引用[^bignote]。[^1]: 第一个脚注定义。[^bignote]: 脚注定义可使用多段内容。    缩进对齐的段落包含在这个脚注定义内。\r\n可以使用代码块。\r\n还有其他行级排版语法，比如**加粗**和[链接](https://lddgo.net)。\r\n```\r\n\r\n\r\n\r\n第一个脚注定义。↩︎\r\n脚注定义可使用多段内容。↩︎\r\n\r\n\r\n","categories":["实用","语言方面"],"tags":["markdown","实用知识","常用知识","语法知识","语言基础","实用类"]},{"title":"没错，这是我的单词本-写作向","url":"/posts/32178.html","content":"没什么，就是整理一下我遇到的单词，无排序，纯纯随机\r\n因为我个人英语实在不好，就这样记录一下吧，只要我没想起来的都会记录进去\r\n这个是偏向于阅读的，之后会出一个写作的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n原词\r\n释义\r\n相近的词\r\n\r\n\r\n\r\n\r\nreckless\r\na. 鲁莽的，粗心的，不计后果的\r\nrude，impertinent\r\n\r\n\r\ndisabled\r\nadj.残疾的，丧失能力的\r\n\r\n\r\n\r\ndisable\r\nvt.使残废，使无能力，使无资格\r\ncripple，deactivate，incapacitate，disqualify\r\n\r\n\r\nassert\r\nv.坚称，断言，生效\r\ndeclare，state，affirm，insist\r\n\r\n\r\noutstanding\r\na. 杰出的，突出的\r\nexcellent，splendid\r\n\r\n\r\nindividual\r\na. 个别的，单独的；n. 个人\r\npersonal，single，private\r\n\r\n\r\ntriumph\r\nn.胜利；巨大的成就，典范；vi.获胜，打败，克服，战胜\r\nvictory，success，achievement，overcome\r\n\r\n\r\nchronic\r\na.慢性的，长期的\r\nstanding，long-term\r\n\r\n\r\nrigorous\r\na.严密的，缜密的，严格的，严厉的\r\nstrict\r\n\r\n\r\nimpose\r\nv.强制推行，强制实行，强加于\r\nforce，enforce\r\n\r\n\r\nindispensable\r\nadj.n.不可缺少的（事物）\r\nessential，vital，necessary，crucial\r\n\r\n\r\nexclude\r\nvt.排除，不包括；排斥；驱除，赶出\r\nexcept，eliminate\r\n\r\n\r\nsufficient\r\na.足够的；充足的；充分的；\r\nenough，abundant，adeuqate\r\n\r\n\r\nabundant\r\na.大量的，充足的，丰富的\r\nample，plentiful，rich\r\n\r\n\r\ngrief\r\nn.悲伤；悲痛；悲伤的事；\r\nsorrow，sadness\r\n\r\n\r\nconvey\r\nv.表达，传达，传输\r\ndeliver，express，communicate，transmit，relay，impart\r\n\r\n\r\nexternal\r\na.外部的，外面的\r\nouter，outside，foregin，external\r\n\r\n\r\nextent\r\nn.程度，范围，长度\r\nrange，degree，scope，measure\r\n\r\n\r\nvertical\r\na.垂直的\r\nupright，plumb，standing，erect\r\n\r\n\r\ncargo\r\nn.货物\r\ngoods，freight\r\n\r\n\r\nalter\r\nv. 改变，改动\r\nchange, modify\r\n\r\n\r\nexplode\r\nvi. 爆炸，激增，急剧扩大\r\nburst，blow up，blast\r\n\r\n\r\nbacteria\r\nn. 细菌\r\ngerm, microbe\r\n\r\n\r\nenthusiastic\r\na.热情的，热心的\r\npassionate，eager，excited\r\n\r\n\r\nfundamental\r\na.基础的，基本的 n.基本原则\r\nbasic，essential，primary，radical\r\n\r\n\r\ndeny\r\nv.否认\r\nnegate\r\n\r\n\r\nconsecutive\r\na.连续的，不断的\r\ncontinuous，consistent，uninterrupted\r\n\r\n\r\nguarantee\r\nn.保证 v.担保\r\nensure，assure\r\n\r\n\r\nstartle\r\nvt.使震惊 vi.惊吓 n.惊愕，震惊\r\nastonish，amaze，jumpstart\r\n\r\n\r\ncherish\r\nv. 珍视；怀有\r\ntreasure, hold\r\n\r\n\r\nblast\r\nn.爆炸，冲击波，气流\r\nexplosion，burst，airflow\r\n\r\n\r\nconstraint\r\nn.强制，限制，约束\r\nrestriction，limitation，restraint，boundary，shackle，check\r\n\r\n\r\nvictim\r\nn. 牺牲品，受害者\r\nvictim, sufferer\r\n\r\n\r\nexport\r\nn. 出口（物）；v. 出口，输出\r\nexit(?), send out\r\n\r\n\r\nimport\r\nn. 进口（物）；v. 进口，输入\r\nentrance, bring in\r\n\r\n\r\noptimistic\r\na. 乐观\r\npositive，hopeful，upbeat\r\n\r\n\r\noptional\r\na. 可以任选的，非强制的\r\noptional, elective\r\n\r\n\r\naccommodate\r\nvt.容纳，供应\r\nsupply，fit，hold\r\n\r\n\r\nabsurd\r\na.愚蠢的，荒谬的\r\nstupid，foolish，ridiculous\r\n\r\n\r\nadverse\r\na.有害的，相反的，不利的\r\nunfavorable, harmful，oppostie，reverse\r\n\r\n\r\nalternate\r\na.交替的，轮流的 v.交替\r\nalternative，switch，rotate\r\n\r\n\r\nanonymous\r\na. 匿名的\r\nnameless, unidentified\r\n\r\n\r\napt\r\na. 易于….的，恰当的\r\nprone, likely\r\n\r\n\r\nproper\r\na.适当的，应该的，本来的\r\nappropriate，correct，suitable，right，\r\n\r\n\r\nsymptom\r\nn.症状，征兆，迹象\r\nsign，clue，trace\r\n\r\n\r\nunderlying\r\nadj.根本的，潜在的\r\nbasic，fundamental，hidden，root\r\n\r\n\r\nformula\r\nn.计划，方案，配方，公式\r\nplan，project，equation，method，blueprint\r\n\r\n\r\nascend\r\nv.上升，攀登\r\nrise，climb\r\n\r\n\r\nconfines\r\nn.范围，界限 vt.限制，禁闭\r\nlimits，boundaries，walls\r\n\r\n\r\noridinary\r\na.普通的，平常的 n.常见的人或事\r\nusual，general，common，average\r\n\r\n\r\nengage\r\nv.雇用，聘请，从事\r\nattract\r\n\r\n\r\nboost\r\nv.使增长，推动\r\nincrease，grow，promote\r\n\r\n\r\ntwilight\r\nn.黄昏，暮色\r\ndusk，nightfall\r\n\r\n\r\nreinforce\r\nv.加强，强化，巩固\r\nstrengthen，enhance，consolidation\r\n\r\n\r\naspect\r\nn.方面，特色，外表，方位\r\nphase，dimension，perspective\r\n\r\n\r\nmetaphor\r\nn.隐喻，象征\r\n\r\n\r\n\r\nrational\r\nadj.合理的\r\nlogical，reasonable，sensible\r\n\r\n\r\nrefrain\r\nv.克制，避免\r\navoid，resist，abstain，forbear，desist\r\n\r\n\r\nworth\r\nadj.价值….的，值得的\r\nprice，value，property\r\n\r\n\r\nprivilege\r\nn.特权，优惠，光荣\r\nadvantage，benefit\r\n\r\n\r\nsatellium\r\nn.卫星\r\n\r\n\r\n\r\nreference\r\nn.提及，提到，参考\r\nsource，mention，consult\r\n\r\n\r\ntouchstone\r\nn.试金石，检验标准\r\ncheckout\r\n\r\n\r\nsecurity\r\nn.安全，保护措施\r\nsafety\r\n\r\n\r\ndisaster\r\nn.灾难\r\n\r\n\r\n\r\naffirm\r\nv.确认，断言，证实\r\nconfirm，notarize，assert，claim\r\n\r\n\r\nnavigation\r\nn.导航，航行，航运\r\n\r\n\r\n\r\nobsessive\r\nadj.着迷的，迷恋的\r\naddicted，crazy，fanatical\r\n\r\n\r\nconform\r\nv.遵守，顺从，符合\r\nobserve，comply，\r\n\r\n\r\naudience\r\nn.观众，听众，读者\r\nviewers，\r\n\r\n\r\nalien\r\nadj.陌生的，外国的\r\nforegin，external，exotic\r\n\r\n\r\nevaluation\r\nn.评估，评价\r\nassessment\r\n\r\n\r\nreject\r\nv.拒绝，否认\r\ndeny，refuse，decline\r\n\r\n\r\ndisrupt\r\nv.中断，扰乱\r\ninterrupt，suspend，pause，disturb\r\n\r\n\r\nadvocate\r\nv.拥护，提倡\r\nsupport，defend\r\n\r\n\r\nmutual\r\nadj.相互的，彼此的，共同的\r\neach other，common\r\n\r\n\r\ninconsistent\r\nadj.不一致的，矛盾的\r\ndiverse，incompatible\r\n\r\n\r\ndiversity\r\nadj.多样化的\r\nvariety，difference\r\n\r\n\r\naccurate\r\nadj.精准的\r\nprecise，exact\r\n\r\n\r\nindifferent\r\nadj.漠不关心的\r\nuninterested\r\n\r\n\r\nexternal\r\nadj.外部的，外面的\r\nouter，outside\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","categories":["其他","英语方面"],"tags":["学习类","其他"]},{"title":"洛谷P1631序列合并Java题解","url":"/posts/48002.html","content":"\r\n\r\nimage-20250420181227707\r\n\r\n\r\n\r\nimage-20250420181227707\r\n\r\n题目分析\r\n给定两个长度为 N 的有序数组\r\n$A = \\\\{a_1, a_2, \\ldots, a_N\\\\}$ 和\r\n$B = \\\\{b_1, b_2, \\ldots,\r\nb_N\\\\}$，求所有 ai + bj\r\n组合中的前 N 个最小和。\r\n思路\r\n开个 N^2 大小的数组，直接计算所有 N2\r\n个和并排序的时间复杂度为 O(N2log N)，这在\r\nN ≤ 105\r\n时显然不可行。\r\n有序数组存在特性：数组 A 和\r\nB\r\n已分别按升序排列，因此对于固定的 ai，ai + bj\r\n的值随 j 增大而单调递增。\r\n考虑使用堆，观察题中的两个数组： [ a 1 , a 2 , … , a N ] ， [ b 1 , b\r\n2 , … , b N\r\n]，对这两个数组分别从小到大排序，变成两个有序队列。这样，从A和B中各任取一个数相加得到N^2个和，可以把这些和看成形成了n个有序表/队列：\r\n考虑多路归并：\r\n将每个 ai\r\n与 B\r\n数组相加得到的序列视为一个有序队列，则总共有 N 个有序队列： $$\r\n\\begin{aligned}\r\n   Q_1 &amp;: a_1 + b_1,\\ a_1 + b_2,\\ \\ldots,\\ a_1 + b_N \\\\\r\n   Q_2 &amp;: a_2 + b_1,\\ a_2 + b_2,\\ \\ldots,\\ a_2 + b_N \\\\\r\n   &amp;\\vdots \\\\\r\n   Q_N &amp;: a_N + b_1,\\ a_N + b_2,\\ \\ldots,\\ a_N + b_N \\\\\r\n   \\end{aligned}\r\n$$ 我们的目标是合并这些队列，找到前 N 小的元素。\r\n由所有的 a i + b j 便可以组成以下 N 个偏序集:\r\n\r\n\r\nimage-20250420181754818\r\n\r\n\r\n\r\nimage-20250420181754818\r\n\r\n显然，在这 N 个偏序集中，都能够保证是有序的（单调递增）\r\n因此，对每个单独的偏序集而言，其始终满足：ai + bj &lt;= ai +\r\nb(j+1)\r\n同时，可断言 a 1 + b 1 为所有 a i + b j 组合中的最小值； a N + b N\r\n为所有 a i + b j 组合中的最大值；\r\n所以，我们就能在 O(1)\r\n的时间复杂度内，从构建好的偏序集中取出当前最小值\r\n使用最小堆维护当前所有队列的队首元素。每次取出堆顶元素（当前最小值），并将该元素所在队列的下一个元素加入堆中。\r\n建堆和取值策略如下：\r\n\r\n把每个偏序集中的最小元素加入到小根堆 heap 中，即 heap =\r\n{a1+b1,a2+b1,…,aN+b1} ；\r\n从小根堆 h e a p heap heap\r\n中取出根元素（即当前堆里的最小值），假设取出的元素为 a i + b j，记弹出数\r\n+1；\r\n从取出元素所在的偏序集中，取出仅比此小的元素，ai + b\r\n(j+1)，将其插入到小根堆 heap 中\r\n若弹出数不为 N，则继续执行 2；否则结束取值\r\n\r\n\r\n初始化堆\r\n将每个队列的第一个元素（即 ai + b1）加入堆，记录对应的\r\ni 和当前 b 的索引 j = 1。\r\n迭代取最小值\r\n重复 N 次：\r\n\r\n取出堆顶元素 ai + bj，加入结果集。\r\n若 j + 1 ≤ N，将\r\nai + bj + 1\r\n加入堆中，并更新索引为 j + 1。\r\n\r\n去重与边界处理\r\n使用三元组 (sum, i, j)\r\n存储堆元素，确保同一队列中不同位置的元素能被正确追踪。\r\n\r\n复杂度分析 - 时间复杂度：O(Nlog N)，每次堆操作的时间为\r\nO(log N)，共进行\r\nO(N) 次。 -\r\n空间复杂度：O(N)，堆中最多存储 N 个元素。\r\nimport java.util.Arrays;import java.util.PriorityQueue;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n];        int[] b = new int[n];        // 读取输入数据        for (int i = 0; i &lt; n; i++) &#123;            a[i] = sc.nextInt();        &#125;        for (int i = 0; i &lt; n; i++) &#123;            b[i] = sc.nextInt();        &#125;        sc.close();        // 对数组排序        Arrays.sort(a);        Arrays.sort(b);        // 使用优先队列（小根堆）        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((x, y) -&gt; x[0] - y[0]);        // 初始化堆：将每个a[i]与b[0]的和加入堆        for (int i = 0; i &lt; n; i++) &#123;            pq.offer(new int[]&#123;a[i] + b[0], i, 0&#125;);        &#125;        // 查找前 n 小的值        StringBuilder sb = new StringBuilder();        while(n-- &gt; 0)&#123;            int[] curr = pq.poll();            int sum = curr[0];            int aIdx = curr[1];            int bIdx = curr[2];            sb.append(sum).append(&quot; &quot;);            // 如果当前b索引+1有效，则将下一个和加入堆            if (bIdx + 1 &lt; b.length) &#123;                pq.offer(new int[]&#123;a[aIdx] + b[bIdx + 1], aIdx, bIdx + 1&#125;);            &#125;        &#125;        System.out.println(sb.toString().trim());    &#125;&#125;\r\nAC:\r\n\r\n\r\nimage-20250420194347442\r\n\r\n\r\n\r\nimage-20250420194347442\r\n\r\n","categories":["算法类","题解"],"tags":["算法","题解","洛谷","数据结构"]},{"title":"理解JavaLambda表达式的使用","url":"/posts/58992.html","content":"Lambda表达式概述\r\nLambda表达式是 Java8\r\n正式引入的一种语法，它的本质上是一个匿名函数，是对匿名函数的简写形式，它可以被传递给方法或存储在变量中，提供了一种清晰简洁的方式来表示一个接口的单个方法。\r\n我们可以把\r\nLambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递），因为Lambda\r\n表达式支持函数式编程范式，它允许开发人员传递行为而不是具体的值，这简化了代码结构和流程控制。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升；\r\n而且它极大地增强了 Java\r\n的编程模型，尤其在处理集合和流时，我们接下来在学习 Stream Api 和在\r\nSpring 中异常处理与响应构建，Bean定义与条件配置等时候都需要用到\r\nLambda表达式\r\n让我们通过一个具体例子看Lambda表达式如何简化代码：\r\n传统匿名内部类写法：\r\nComparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() &#123;    @Override    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;;\r\nLambda表达式写法：\r\nComparator&lt;String&gt; comparator = (s1, s2) -&gt; s1.compareTo(s2);\r\n通过上面的对比，发现Lambda表达式式书写起来更为简洁；\r\nlambda 表达式与\r\n正则表达式（Regex）的区别\r\n首先，这俩是两种完全不同的技术，用途和语法截然不同。\r\n\r\n处理对象不同\r\n\r\nLambda：处理行为逻辑（将代码作为数据传递，如函数作为参数）；\r\n正则：处理文本数据（定义字符串匹配规则）。\r\n\r\n语法核心差异\r\n\r\nLambda：依赖函数式接口，语法围绕 “参数→逻辑” 展开；\r\n正则：依赖元字符组合，语法围绕 “字符模式”\r\n展开（如\\w匹配字母数字，*表示零或多次重复）。\r\n\r\n\r\n这俩的共同点也就在于均用于简化代码了，但解决的问题域却完全不同。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\nLambda 表达式\r\n正则表达式（Regex）\r\n\r\n\r\n\r\n\r\n本质\r\nJava 语言特性（函数式编程）\r\n字符串匹配工具（文本模式）\r\n\r\n\r\n主要用途\r\n简化匿名内部类，实现函数式接口\r\n文本搜索、替换、验证（如邮箱、手机号格式）\r\n\r\n\r\n语法\r\n(参数) -&gt; &#123; 代码块 &#125;\r\n由普通字符和特殊元字符（如\\d、*、+）组成的模式字符串\r\n\r\n\r\n应用场景\r\n集合操作、多线程、事件回调等\r\n字符串处理、数据清洗、表单验证等\r\n\r\n\r\n\r\n虽然二者用途不同，但可以配合使用，例如：\r\nList&lt;String&gt; emails = Arrays.asList(    &quot;user@example.com&quot;, &quot;invalid-email&quot;, &quot;admin@test.org&quot;);// 使用Lambda + Regex过滤有效邮箱List&lt;String&gt; validEmails = emails.stream()    .filter(email -&gt; email.matches(&quot;^[\\\\w.-]+@[\\\\w.-]+\\\\.[a-z]&#123;2,6&#125;$&quot;))    .toList();\r\n\r\nLambda：处理集合流（stream().filter()）。\r\nRegex：验证字符串格式（邮箱正则）。\r\n\r\n二增\r\n这个其实是不少初学者容易混淆的，因为Lambda\r\n的-&gt;和正则的某些转义符（如\\\\）可能让初学者产生视觉混淆，而且两者都常用于简化代码，但本质作用完全不同；\r\nLambda表达式语法\r\n基本语法\r\nLambda\r\n表达式可以用来表示匿名函数，即一段没有声明的方法或者没有名字的代码片段。\r\n基本的 Lambda 表达式语法如下：\r\n(参数列表) -&gt; &#123; 方法体 &#125;\r\n\r\n参数列表：可以有零个或多个参数\r\n\r\n无参数：()\r\n单个参数：x 或 (x)\r\n多个参数：(x, y, z)\r\n参数类型可省略（Java 编译器通过上下文推断类型，如\r\n(int x, int y) 可简写为 (x, y)）\r\n\r\n箭头操作符 -&gt; 分隔参数列表和方法体\r\n方法体：可以是一个表达式或代码块\r\n\r\n单行表达式：直接返回结果，无需 return 关键字\r\n代码块：使用 &#123;&#125; 包裹多行代码，需要显式\r\nreturn 返回值\r\n\r\n\r\n左边写的是实现的这个接口中的抽象方法中的形参列表，右边就是对抽象方法的处理；\r\n实现的这个接口中的抽象方法中的形参列表 -&gt; 抽象方法的处理\r\n例如，对于一个简单的求和操作，可以这样表示：\r\n(int a, int b) -&gt; a + b\r\n各种Lambda语法形式\r\n无参数：\r\n() -&gt; System.out.println(&quot;Hello World&quot;);// 应用场景示例：实现Runnable接口Runnable task = () -&gt; &#123;    System.out.println(&quot;Task executed&quot;);&#125;;new Thread(task).start();\r\n单个参数（可省略括号）：\r\nx -&gt; x * 2;  // 等价于 (x) -&gt; x * 2;// 应用场景示例：集合遍历List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3);numbers.forEach(x -&gt; System.out.println(x));// 类型显式声明示例Predicate&lt;String&gt; isLong = (String s) -&gt; s.length() &gt; 10;\r\n多个参数：\r\n(x, y) -&gt; x + y;// 应用场景示例：Comparator接口List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;);names.sort((a, b) -&gt; a.length() - b.length());\r\n复杂方法体（需要大括号和return语句）：\r\n(x, y) -&gt; &#123;    int sum = x + y;    int product = x * y;    return sum + product;&#125;;// 应用场景示例：自定义处理逻辑Function&lt;String, Integer&gt; stringProcessor = (str) -&gt; &#123;    if (str == null || str.isEmpty()) &#123;        return 0;    &#125;    return str.chars().filter(c -&gt; Character.isLetter(c)).count();&#125;;// 检查型异常需要在方法体中显式处理Supplier&lt;File&gt; fileReader = () -&gt; &#123;    try &#123;        return new File(&quot;data.txt&quot;);    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;;\r\n无返回值有形参的抽象方法：\r\npublic class MyTest1 &#123;    public static void main(String[] args) &#123;        MyInterface myInterface = new MyInterface() &#123;            @Override            public void show(int a, int b) &#123;                System.out.println(a + b);            &#125;        &#125;;        myInterface.show(20, 30);//50        //简写1：方法名可以自己推断出来        MyInterface myInterface1 = (int a, int b) -&gt; &#123;            System.out.println(a + b);        &#125;;        myInterface1.show(20, 40);//60        //简写2：可以省略形参列表中的形参类型        MyInterface myInterface2 = (a, b) -&gt; &#123;            System.out.println(a + b);//70        &#125;;        myInterface2.show(20, 50);        //简写3：如果抽象方法中只有一行代码，可以省略方法体的大括号，当然，如果不止一行，就不能省略        MyInterface myInterface3 = (a, b) -&gt; System.out.println(a + b);        myInterface3.show(20, 60);//80    &#125;&#125;\r\n\r\n可以省略方法名，IDEA会帮你自动检测方法名；\r\n可以省略方法中的形参类型；\r\n如果对抽象方法的实现逻辑只有一行，可以省略方法体的大括号，当然如果不止一行，就不能省略了；\r\n\r\n有返回值的抽象方法:\r\npublic class MyTest2 &#123;    public static void main(String[] args) &#123;        MyInterface1 test1 = new MyInterface1() &#123;            @Override            public int test(int a, int b) &#123;                return a - b;            &#125;        &#125;;        System.out.println(test1.test(90, 8));//82        //简写1：        MyInterface1 test2 = (int a, int b) -&gt; &#123;            return a - b;        &#125;;        System.out.println(test2.test(20, 10));//10        //简写2：        MyInterface1 test3 = (a, b) -&gt; &#123;return a - b;&#125;;        System.out.println(test3.test(30, 10));//20        //简写3：这个有返回值的方法，不能直接去掉大括号，还需要去掉return关键字        MyInterface1 test4 = (a, b) -&gt; a - b;        System.out.println(test4.test(40, 10));//30    &#125;&#125;\r\n\r\n有返回值的方法，如果要去掉大括号，还需要去掉return关键字；\r\n形参列表中只有一个参数，可以去掉形参的括号；\r\n\r\n基本用法\r\n假设我们有一个函数接口 Calculator：\r\n@FunctionalInterfaceinterface Calculator &#123;    int calculate(int a, int b);&#125;\r\n我们可以使用 Lambda 表达式为这个接口定义行为：\r\npublic class LambdaBasic &#123;    public static void main(String[] args) &#123;        // 1. 完整写法：指定参数类型，方法体用 &#123;&#125; 包裹        Calculator addition1 = (int a, int b) -&gt; &#123; return a + b; &#125;;                // 2. 简化1：省略参数类型（编译器自动推断为 int）        Calculator addition2 = (a, b) -&gt; &#123; return a + b; &#125;;                // 3. 简化2：方法体只有一行代码时，省略 &#123;&#125; 和 return        Calculator addition3 = (a, b) -&gt; a + b;                // 4. 减法示例：同样支持简化        Calculator subtraction = (a, b) -&gt; a - b;                // 调用测试        System.out.println(&quot;10 + 5 = &quot; + addition3.calculate(10, 5)); // 输出：15        System.out.println(&quot;10 - 5 = &quot; + subtraction.calculate(10, 5)); // 输出：5    &#125;&#125;\r\nLambda\r\n表达式必须与函数式接口配合使用，且表达式的参数列表和返回值必须与接口中抽象方法的签名一致。例如：\r\n// 函数式接口：接收 String，返回 int@FunctionalInterfaceinterface StringProcessor &#123;    int process(String str);&#125;public class LambdaBinding &#123;    public static void main(String[] args) &#123;        // 实现：返回字符串长度        StringProcessor lengthProcessor = str -&gt; str.length();        System.out.println(lengthProcessor.process(&quot;Lambda&quot;)); // 输出：6                // 实现：返回字符串中大写字母的数量        StringProcessor upperCountProcessor = str -&gt; &#123;            int count = 0;            for (char c : str.toCharArray()) &#123;                if (Character.isUpperCase(c)) &#123;                    count++;                &#125;            &#125;            return count;        &#125;;        System.out.println(upperCountProcessor.process(&quot;Hello Lambda&quot;)); // 输出：2（H 和 L）    &#125;&#125;\r\nLambda 表达式可以访问外部变量，但有严格的限制：\r\n\r\n访问局部变量：局部变量必须是最终的（final）或事实上的最终变量（即赋值后不再修改）。\r\nint factor = 2; // 事实上的最终变量（未显式声明 final，但未修改）Calculator multiply = (a, b) -&gt; (a + b) * factor;System.out.println(multiply.calculate(3, 4)); // 输出：14（(3+4)*2）// 错误示例：修改局部变量会导致编译失败factor = 3; // 编译报错：Lambda 表达式中引用的局部变量必须是最终的或事实上的最终变量\r\n访问成员变量和静态变量：无限制，可修改。\r\npublic class LambdaScope &#123;    private int instanceVar = 10;    private static int staticVar = 100;        public void test() &#123;        // 访问实例变量并修改        Calculator accessInstance = (a, b) -&gt; &#123;            instanceVar = 20;            return a + b + instanceVar;        &#125;;                // 访问静态变量并修改        Calculator accessStatic = (a, b) -&gt; &#123;            staticVar = 200;            return a + b + staticVar;        &#125;;    &#125;&#125;\r\n\r\n而且Lambda表达式可以作为参数进行传递\r\nimport java.util.Arrays;public class MyTest4 &#123;    public static void main(String[] args) &#123;        Integer[] ints = &#123;89, 67, 23&#125;;        Arrays.sort(ints, (o1, o2) -&gt; o1-o2);        System.out.println(Arrays.toString(ints));        //[23, 67, 89]    &#125;&#125;\r\n而且Lambda 表达式在集合操作、多线程等场景中应用广泛，例如：\r\n\r\n集合遍历（替代匿名内部类）\r\n\r\nList&lt;String&gt; fruits = Arrays.asList(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;);// 传统方式：使用匿名内部类fruits.forEach(new Consumer&lt;String&gt;() &#123;    @Override    public void accept(String fruit) &#123;        System.out.println(fruit);    &#125;&#125;);// Lambda 简化fruits.forEach(fruit -&gt; System.out.println(fruit));\r\n\r\n线程创建\r\n// 传统方式：匿名 RunnableThread thread1 = new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Thread 1 running&quot;);    &#125;&#125;);// Lambda 简化Thread thread2 = new Thread(() -&gt; System.out.println(&quot;Thread 2 running&quot;));\r\n\r\nLambda表达式并非万能\r\nLambda表达式不是万能的，他需要函数式接口的支持；\r\n什么是函数式接口\r\n函数式接口的核心定义是：只包含一个抽象方法的接口（可以包含默认方法、静态方法或从Object继承的方法）。\r\n函数式接口存在如下关键特征：\r\n\r\n抽象方法数量严格为\r\n1（若接口中声明的抽象方法与Object类的方法重名，该方法不计入\r\n“抽象方法数量”，因为所有类都继承自Object，本质上不算接口新增的抽象方法）。\r\n// 合法的函数式接口：抽象方法仅1个（toString()来自Object，不计入）@FunctionalInterfaceinterface MyInterface &#123;    void doSomething(); // 唯一抽象方法    String toString();  // 继承自Object，不算新增抽象方法&#125;\r\n可通过@FunctionalInterface注解显式标记，编译器会自动验证接口是否符合函数式接口规范（若不符合则报错），自定义函数式接口也需要如上注解\r\n// 错误示例：包含2个抽象方法，编译报错@FunctionalInterfaceinterface InvalidInterface &#123;    void method1();    void method2(); // 编译器报错：函数式接口只能有一个抽象方法&#125;\r\n此外，函数式接口可以继承其他接口，但需保证最终抽象方法数量仍为\r\n1：\r\n// 父接口（函数式接口）@FunctionalInterfaceinterface Parent &#123;    void parentMethod();&#125;// 子接口：继承父接口，且不新增抽象方法（仍为函数式接口）@FunctionalInterfaceinterface Child extends Parent &#123;    default void childMethod() &#123; ... &#125; // 默认方法，不影响抽象方法数量&#125;\r\n\r\nLambda\r\n表达式的本质是函数式接口抽象方法的匿名实现，二者必须满足\r\n“方法签名兼容”：\r\n\r\nLambda 的参数列表类型、数量、顺序需与接口抽象方法一致；\r\nLambda 的返回值类型需与接口抽象方法兼容（若接口方法有返回值，Lambda\r\n的返回值需可赋值给该类型）。\r\n\r\n// 函数式接口@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123;    T convert(F from);&#125;// Lambda与接口方法签名兼容Converter&lt;String, Integer&gt; strToInt = s -&gt; Integer.parseInt(s);Converter&lt;Integer, String&gt; intToStr = i -&gt; &quot;Number: &quot; + i;// 错误示例：参数数量不匹配Converter&lt;String, Integer&gt; error = (s1, s2) -&gt; Integer.parseInt(s1); // 编译报错：Lambda表达式的参数数量与接口方法不匹配\r\n为避免重复定义通用的函数式接口，JDK 1.8\r\n在java.util.function包中提供了一系列内置函数式接口，覆盖大多数常见场景。掌握这些接口可以显著减少代码量\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n接口名称\r\n抽象方法\r\n功能描述\r\n示例场景\r\n\r\n\r\n\r\n\r\nConsumer&lt;T&gt;\r\nvoid accept(T t)\r\n接收一个参数，无返回值\r\n集合遍历（forEach）\r\n\r\n\r\nSupplier&lt;T&gt;\r\nT get()\r\n无参数，返回一个值\r\n数据生成（如工厂方法）\r\n\r\n\r\nFunction&lt;T, R&gt;\r\nR apply(T t)\r\n接收 T 类型参数，返回 R 类型值\r\n数据转换（如类型转换）\r\n\r\n\r\nPredicate&lt;T&gt;\r\nboolean test(T t)\r\n接收参数，返回布尔值\r\n条件判断（如过滤集合）\r\n\r\n\r\nBiFunction&lt;T,U,R&gt;\r\nR apply(T t, U u)\r\n接收两个参数，返回一个值\r\n多参数转换（如计算）\r\n\r\n\r\n\r\n那么什么时候不适用 Lambda 表达式\r\n若接口包含多个抽象方法（非函数式接口），Lambda\r\n无法使用，此时必须通过匿名内部类或显式实现类\r\n// 非函数式接口（2个抽象方法）interface MultiMethodInterface &#123;    void method1();    void method2();&#125;// 错误：Lambda无法实现多抽象方法接口MultiMethodInterface obj = () -&gt; System.out.println(&quot;test&quot;); // 编译报错：目标类型 MultiMethodInterface 不是函数式接口// 正确方式：使用匿名内部类MultiMethodInterface obj = new MultiMethodInterface() &#123;    @Override    public void method1() &#123; ... &#125;    @Override    public void method2() &#123; ... &#125;&#125;;\r\nLambda 表达式本质是\r\n“匿名函数”，无法像普通类一样通过成员变量保留状态，也无法直接复用（需通过变量引用间接复用）。若需频繁复用复杂逻辑，建议定义普通类或枚举。\r\n方法引用\r\n方法引用与 Lambda 表达式\r\n什么是方法引用，他和 Lambda 表达式什么关系\r\n方法引用是 Java 8 中与 Lambda 表达式紧密关联的特性，它可以看作是\r\nLambda 表达式的 “语法糖”—— 当 Lambda\r\n表达式的逻辑只是调用一个已存在的方法时，方法引用能以更简洁的方式表达这种逻辑。\r\n方法引用的核心思想是：如果 Lambda\r\n表达式的实现仅仅是调用一个已有的方法（无需额外逻辑），则可以直接通过方法名引用该方法，替代\r\nLambda 表达式。\r\n\r\n方法引用是 Lambda 表达式的简化形式。例如，Lambda 表达式\r\n(a, b) -&gt; Math.max(a, b) 可以简化为方法引用\r\nMath::max。\r\n二者本质上是一致的，都会被编译为函数式接口的实现，但方法引用的语法更简洁，可读性更强。\r\n方法引用不会创建新方法：它只是对已有方法的\r\n“引用”，不会改变原方法的行为。\r\n\r\n方法引用通过 ::\r\n运算符连接类名（或对象名）与方法名，语法分为以下 4 种常见形式：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法引用类型\r\n语法格式\r\n示例\r\n对应的 Lambda 表达式\r\n\r\n\r\n\r\n\r\n静态方法引用\r\n类名：：静态方法名\r\nMath::max\r\n(a, b) -&gt; Math.max(a, b)\r\n\r\n\r\n实例方法引用（对象）\r\n对象名：：实例方法名\r\nstr::length\r\n() -&gt; str.length()\r\n\r\n\r\n实例方法引用（类）\r\n类名：：实例方法名\r\nString::compareTo\r\n(s1, s2) -&gt; s1.compareTo(s2)\r\n\r\n\r\n构造方法引用\r\n类名::new\r\nArrayList::new\r\n() -&gt; new ArrayList&lt;&gt;()\r\n\r\n\r\n\r\n\r\n静态方法引用通过 “类名：：方法名” 调用，不依赖实例；\r\n实例方法引用（对象名：：方法名）依赖具体实例，若实例为\r\nnull，调用时会抛出 NullPointerException。\r\n构造方法引用中，当类有多个构造方法时，JVM\r\n会根据函数式接口的抽象方法签名自动匹配最合适的构造方法。若匹配失败，会编译报错。\r\n\r\n静态方法引用（类名：：静态方法名）\r\n当 Lambda 表达式调用的是某个类的静态方法时，可使用静态方法引用。\r\nimport java.util.function.BiFunction;public class StaticMethodRef &#123;    public static void main(String[] args) &#123;        // Lambda 表达式：调用 Math 类的静态方法 max        BiFunction&lt;Integer, Integer, Integer&gt; maxLambda = (a, b) -&gt; Math.max(a, b);                // 方法引用：简化为 Math::max        BiFunction&lt;Integer, Integer, Integer&gt; maxRef = Math::max;                System.out.println(maxRef.apply(10, 20)); // 输出：20    &#125;&#125;\r\n实例方法引用（对象名：：实例方法名）\r\n当 Lambda\r\n表达式调用的是某个对象的实例方法时，可使用实例方法引用（需先创建对象）。\r\nimport java.util.function.Supplier;public class InstanceObjMethodRef &#123;    public static void main(String[] args) &#123;        String str = &quot;Hello, Method Reference&quot;;                // Lambda 表达式：调用 str 对象的 length() 方法        Supplier&lt;Integer&gt; lengthLambda = () -&gt; str.length();                // 方法引用：简化为 str::length        Supplier&lt;Integer&gt; lengthRef = str::length;                System.out.println(lengthRef.get()); // 输出：21（字符串长度）    &#125;&#125;\r\n实例方法引用（类名：：实例方法名）\r\n当 Lambda\r\n表达式的第一个参数是方法的调用者，后续参数是方法的参数时，可使用类名引用实例方法。\r\n此时方法的调用者是 Lambda\r\n表达式的第一个参数，因此可以省略参数名，直接通过类名引用方法。\r\nimport java.util.function.BiFunction;public class InstanceClassMethodRef &#123;    public static void main(String[] args) &#123;        // Lambda 表达式：调用 s1 的 compareTo 方法，参数为 s2        BiFunction&lt;String, String, Integer&gt; compareLambda = (s1, s2) -&gt; s1.compareTo(s2);                // 方法引用：简化为 String::compareTo        BiFunction&lt;String, String, Integer&gt; compareRef = String::compareTo;                System.out.println(compareRef.apply(&quot;apple&quot;, &quot;banana&quot;)); // 输出：-1（&quot;apple&quot; 在 &quot;banana&quot; 之前）    &#125;&#125;\r\n构造方法引用（类名::new）\r\n当 Lambda\r\n表达式的逻辑是创建一个对象（即调用构造方法）时，可使用构造方法引用\r\n构造方法引用会根据函数式接口的抽象方法签名，自动匹配对应的构造方法（如无参、单参、多参）。\r\nimport java.util.function.Supplier;import java.util.function.Function;import java.util.List;import java.util.ArrayList;public class ConstructorRef &#123;    public static void main(String[] args) &#123;        // 1. 无参构造方法引用        // Lambda 表达式：创建 ArrayList 对象        Supplier&lt;List&lt;String&gt;&gt; listSupplierLambda = () -&gt; new ArrayList&lt;&gt;();        // 方法引用：简化为 ArrayList::new        Supplier&lt;List&lt;String&gt;&gt; listSupplierRef = ArrayList::new;        List&lt;String&gt; list = listSupplierRef.get();                // 2. 有参构造方法引用        // Lambda 表达式：调用 String 的有参构造方法（String(char[] value)）        Function&lt;char[], String&gt; stringFunctionLambda = chars -&gt; new String(chars);        // 方法引用：简化为 String::new        Function&lt;char[], String&gt; stringFunctionRef = String::new;        String str = stringFunctionRef.apply(new char[]&#123;&#x27;h&#x27;, &#x27;i&#x27;&#125;);        System.out.println(str); // 输出：hi    &#125;&#125;\r\n方法引用并非在所有场景下都能替代 Lambda\r\n表达式，它需要满足以下条件：\r\n\r\n方法参数与返回值匹配：被引用的方法的参数列表和返回值类型，必须与函数式接口中抽象方法的参数列表和返回值类型完全一致。\r\n例如，Math.max(int a, int b) 的参数是两个\r\nint，返回 int，因此可匹配\r\nBiFunction&lt;Integer, Integer, Integer&gt;\r\n接口（参数为两个 Integer，返回\r\nInteger）。\r\nLambda 逻辑仅为方法调用：若 Lambda\r\n表达式中除了调用方法还有其他逻辑（如条件判断、循环），则不能使用方法引用。\r\n// 错误：Lambda 包含额外逻辑，无法用方法引用替代Function&lt;Integer, Integer&gt; invalidRef = num -&gt; &#123;    System.out.println(&quot;处理中...&quot;); // 额外逻辑    return Math.abs(num);&#125;;\r\n\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","常用知识","语法知识","学习","JavaSE","语言方面"]},{"title":"深入探索C#事件机制","url":"/posts/12758.html","content":"什么是事件\r\n在软件开发中，事件是一种用于在对象之间传递信息的机制。当一个对象的状态发生变化时，它可以通过触发事件来通知其他对象。事件机制广泛应用于GUI编程、游戏开发、网络编程等领域。\r\n事件的基本概念和语法\r\n委托与事件的关系\r\n在C#中，事件是基于委托实现的。委托是一种类型安全的函数指针，用于引用具有特定签名的方法。事件通过委托来管理其订阅者，并在事件触发时调用这些订阅者的方法。\r\n事件的声明与使用\r\n声明事件的语法如下：\r\npublic class Publisher&#123;    public delegate void NotifyEventHandler(object sender, EventArgs e);    public event NotifyEventHandler Notify;    public void RaiseEvent()    &#123;        if (Notify != null)        &#123;            Notify(this, EventArgs.Empty);        &#125;    &#125;&#125;\r\n在这个例子中，我们声明了一个NotifyEventHandler委托，并基于该委托声明了一个事件Notify。通过调用RaiseEvent方法，我们可以触发Notify事件。\r\n以下是一个订阅和处理事件的例子：\r\npublic class Subscriber&#123;    public void OnNotify(object sender, EventArgs e)    &#123;        Console.WriteLine(&quot;Event received.&quot;);    &#125;&#125;public class Program&#123;    public static void Main(string[] args)    &#123;        Publisher publisher = new Publisher();        Subscriber subscriber = new Subscriber();        publisher.Notify += subscriber.OnNotify;        publisher.RaiseEvent();    &#125;&#125;\r\n在这个例子中，我们创建了一个Subscriber类的实例，并将其OnNotify方法订阅到Publisher类的Notify事件。当RaiseEvent方法被调用时，OnNotify方法将被执行。\r\n事件的实现原理\r\n事件的底层实现\r\nC#中的事件实际上是对委托的封装。每个事件都有一个对应的委托实例，当事件触发时，该委托实例将调用所有已订阅的方法。在编译时，C#编译器会为事件生成add和remove方法，用于管理事件的订阅和取消订阅。\r\n以下是一个事件的底层实现示例：\r\npublic class Publisher&#123;    private NotifyEventHandler _notify;    public event NotifyEventHandler Notify    &#123;        add        &#123;            _notify += value;        &#125;        remove        &#123;            _notify -= value;        &#125;    &#125;    public void RaiseEvent()    &#123;        _notify?.Invoke(this, EventArgs.Empty);    &#125;&#125;\r\n在这个例子中，我们手动实现了事件的add和remove方法，用于管理委托实例_notify的订阅和取消订阅。\r\n事件的多播机制\r\nC#中的事件支持多播机制，即一个事件可以有多个订阅者。当事件触发时，所有订阅该事件的方法将被依次调用。事件的多播机制是通过委托链实现的，委托链是委托的一个特殊特性，允许将多个委托实例链接在一起。\r\n以下是一个多播委托的示例：\r\npublic class Program&#123;    public static void Main(string[] args)    &#123;        Publisher publisher = new Publisher();        publisher.Notify += (sender, e) =&gt; Console.WriteLine(&quot;Subscriber 1 received event.&quot;);        publisher.Notify += (sender, e) =&gt; Console.WriteLine(&quot;Subscriber 2 received event.&quot;);        publisher.RaiseEvent();    &#125;&#125;\r\n在这个例子中，我们向Notify事件添加了两个订阅者。当RaiseEvent方法被调用时，这两个订阅者的方法将被依次执行。\r\n事件的线程安全\r\n在多线程环境中，事件的订阅和取消订阅操作可能导致竞争条件，进而引发不确定行为。为了确保事件的线程安全，通常需要使用锁（lock）语句或其他同步机制。\r\n以下是一个线程安全的事件实现示例：\r\npublic class Publisher&#123;    private readonly object _lock = new object();    private NotifyEventHandler _notify;    public event NotifyEventHandler Notify    &#123;        add        &#123;            lock (_lock)            &#123;                _notify += value;            &#125;        &#125;        remove        &#123;            lock (_lock)            &#123;                _notify -= value;            &#125;        &#125;    &#125;    public void RaiseEvent()    &#123;        NotifyEventHandler handler;        lock (_lock)        &#123;            handler = _notify;        &#125;        handler?.Invoke(this, EventArgs.Empty);    &#125;&#125;\r\n在这个例子中，我们使用一个锁对象_lock来同步对委托实例_notify的访问，从而确保事件的订阅和取消订阅操作是线程安全的。\r\n事件的高级用法\r\n自定义事件参数\r\n在实际开发中，事件通常需要传递一些附加信息。为了实现这一点，我们可以定义自定义事件参数类，并在事件处理方法中使用这些参数。\r\n以下是一个自定义事件参数的示例：\r\npublic class CustomEventArgs : EventArgs&#123;    public string Message &#123; get; &#125;    public CustomEventArgs(string message)    &#123;        Message = message;    &#125;&#125;public class Publisher&#123;    public delegate void NotifyEventHandler(object sender, CustomEventArgs e);    public event NotifyEventHandler Notify;    public void RaiseEvent(string message)    &#123;        Notify?.Invoke(this, new CustomEventArgs(message));    &#125;&#125;public class Subscriber&#123;    public void OnNotify(object sender, CustomEventArgs e)    &#123;        Console.WriteLine(&quot;Received message: &quot; + e.Message);    &#125;&#125;public class Program&#123;    public static void Main(string[] args)    &#123;        Publisher publisher = new Publisher();        Subscriber subscriber = new Subscriber();        publisher.Notify += subscriber.OnNotify;        publisher.RaiseEvent(&quot;Hello, World!&quot;);    &#125;&#125;\r\n在这个例子中，我们定义了一个CustomEventArgs类，用于封装事件参数。然后，我们在NotifyEventHandler委托和事件处理方法中使用该类，以传递自定义消息。\r\n事件的链式调用\r\n链式调用是一种设计模式，允许多个方法通过链式调用的方式进行调用。事件的链式调用可以通过事件订阅机制实现，使得事件处理方法可以按顺序调用。\r\n以下是一个链式调用的示例：\r\npublic class Publisher&#123;    public event Action&lt;string&gt; Notify;    public void RaiseEvent(string message)    &#123;        Notify?.Invoke(message);    &#125;&#125;public class Subscriber&#123;    public Subscriber(Publisher publisher)    &#123;        publisher.Notify += OnNotify1;        publisher.Notify += OnNotify2;    &#125;    private void OnNotify1(string message)    &#123;        Console.WriteLine(&quot;Subscriber 1: &quot; + message);    &#125;    private void OnNotify2(string message)    &#123;        Console.WriteLine(&quot;Subscriber 2: &quot; + message);    &#125;&#125;public class Program&#123;    public static void Main(string[] args)    &#123;        Publisher publisher = new Publisher();        Subscriber subscriber = new Subscriber(publisher);        publisher.RaiseEvent(&quot;Hello, World!&quot;);    &#125;&#125;\r\n在这个例子中，我们通过事件订阅机制实现了链式调用，当事件被触发时，OnNotify1和OnNotify2方法将按顺序被调用。\r\n异步事件处理\r\n在某些情况下，事件处理方法可能需要执行耗时操作。为了避免阻塞主线程，可以使用异步事件处理机制。\r\n以下是一个异步事件处理的示例：\r\npublic class Publisher&#123;    public event Func&lt;string, Task&gt; Notify;    public async Task RaiseEventAsync(string message)    &#123;        if (Notify != null)        &#123;            Delegate[] invocationList = Notify.GetInvocationList();            Task[] tasks = new Task[invocationList.Length];            for (int i = 0; i &lt; invocationList.Length; i++)            &#123;                tasks[i] = ((Func&lt;string, Task&gt;)invocationList[i])(message);            &#125; await Task.WhenAll(tasks);        &#125;    &#125;&#125;public class Subscriber&#123;    public Subscriber(Publisher publisher)    &#123;        publisher.Notify += OnNotifyAsync;    &#125;    private async Task OnNotifyAsync(string message)    &#123;        await Task.Delay(1000);        Console.WriteLine(&quot;Received message: &quot; + message);    &#125;&#125;public class Program&#123;    public static async Task Main(string[] args)    &#123;        Publisher publisher = new Publisher();        Subscriber subscriber = new Subscriber(publisher);        await publisher.RaiseEventAsync(&quot;Hello, World!&quot;);    &#125;&#125;\r\n在这个例子中，我们使用Func委托定义了一个异步事件，并在事件处理方法中执行异步操作。\r\n事件在实际开发中的应用\r\n基于事件的设计模式\r\n事件在设计模式中有广泛应用，尤其是在观察者模式（Observer\r\nPattern）中。观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会收到通知。\r\n以下是一个基于事件实现的观察者模式示例：\r\npublic class Subject&#123;    public event Action&lt;string&gt; Notify;    public void ChangeState(string newState)    &#123;        Notify?.Invoke(newState);    &#125;&#125;public class Observer&#123;    public Observer(Subject subject)    &#123;        subject.Notify += Update;    &#125;    private void Update(string state)    &#123;        Console.WriteLine(&quot;State changed to: &quot; + state);    &#125;&#125;public class Program&#123;    public static void Main(string[] args)    &#123;        Subject subject = new Subject();        Observer observer = new Observer(subject);        subject.ChangeState(&quot;State1&quot;);        subject.ChangeState(&quot;State2&quot;);    &#125;&#125;\r\n在这个例子中，Subject类通过事件机制通知Observer类其状态的变化。\r\n事件在UI编程中的应用\r\n在GUI编程中，事件是处理用户交互的基础。Windows\r\nForms和WPF等框架广泛使用事件机制来处理按钮点击、鼠标移动、键盘输入等操作。\r\n以下是一个Windows Forms中使用事件的示例：\r\npublic class MainForm : Form&#123;    private Button button;    public MainForm()    &#123;        button = new Button();        button.Text = &quot;Click Me&quot;;        button.Click += OnButtonClick;        Controls.Add(button);    &#125;    private void OnButtonClick(object sender, EventArgs e)    &#123;        MessageBox.Show(&quot;Button clicked!&quot;);    &#125;    [STAThread]    public static void Main()    &#123;        Application.EnableVisualStyles();        Application.Run(new MainForm());    &#125;&#125;\r\n在这个例子中，我们创建了一个按钮，并订阅了其Click事件。当按钮被点击时，将显示一个消息框。\r\n事件在异步编程中的应用\r\n事件在异步编程中也有重要应用。例如，在网络编程中，可以使用事件处理网络请求的完成通知。\r\n以下是一个使用事件处理异步操作的示例：\r\npublic class NetworkRequest&#123;    public event Action&lt;string&gt; RequestCompleted;    public async Task SendRequestAsync(string url)    &#123;        // 模拟异步网络请求        await Task.Delay(2000);        RequestCompleted?.Invoke($&quot;Response from &#123;url&#125;&quot;);    &#125;&#125;public class Program&#123;    public static async Task Main(string[] args)    &#123;        NetworkRequest request = new NetworkRequest();        request.RequestCompleted += OnRequestCompleted;        await request.SendRequestAsync(&quot;https://example.com&quot;);    &#125;    private static void OnRequestCompleted(string response)    &#123;        Console.WriteLine(response);    &#125;&#125;\r\n在这个例子中，我们通过事件处理网络请求的完成通知，并在请求完成后输出响应结果。\r\n小结\r\nC#中的事件机制是一个强大且灵活的工具，为对象之间的通信提供了有效的解决方案。通过本文的深入探讨，我们了解了事件的基本概念、实现原理和高级用法，并通过实际例子展示了事件在各种场景中的应用。\r\n掌握事件机制不仅能够提高代码的可读性和可维护性，还能够在复杂应用程序中发挥重要作用。希望本文能帮助读者更好地理解和应用C#中的事件，在实际开发中充分利用这一强大的编程工具。\r\n","categories":["学习类","C#"],"tags":["学习类","语法知识","语言方面","C#"]},{"title":"第十五届蓝桥杯Java国赛B组D题-园丁题解","url":"/posts/12811.html","content":"\r\n\r\nimage-20250424201815331\r\n\r\n题目大意\r\n题目的核心是要处理一棵树上每个节点的权值，对于拥有两个及以上儿子节点的父节点，要保证所有儿子节点的权值两两相乘不能是完全平方数，目标是求出最少需要修改多少个节点的权值，才能让整棵树满足这个条件。\r\n思路\r\n完全平方数的判定\r\n首先什么是完美平方数，如果一个正整数 a 是某一个整数 b 的平方，那么这个正整数 a\r\n叫做完全平方数。零也可称为完全平方数。\r\n两个数 x 和 y 的乘积是完全平方数，当且仅当 x 与 y\r\n的乘积中，所有质因子的幂次都是偶数。\r\n例如 4 * 9 = 36 是完全平方数，因为\r\n4 = 22，9 = 32\r\n，他们的质因子的幂次都是偶数。\r\n进一步推导，这个条件等价于 x 和 y 的 “平方因子化简后”\r\n的形式相同。所谓 “平方因子化简”，就是对每个数 a\r\n分解质因数后，只保留每个质因数的奇数次幂（即 ai\r\n的“平方自由部分”），这部分记作 f(ai)。\r\n若 f(ai) = f(aj)\r\n，那么 ai * aj\r\n必然是完全平方数。\r\n代码处理\r\n使用邻接表存树，如果存在两个儿子节点的 f(aj)\r\n相等，那么这两个儿子节点权值的乘积就是完全平方数，不满足题目要求。\r\n贪心处理：\r\n对每个有 k ≥ 2 个儿子的结点\r\ni，统计其所有儿子的 f(aj)，对于重复的\r\nf(aj)，需要修改其中\r\ncnt − 1\r\n个结点的权值（cnt 为该 f(aj)\r\n出现次数）。 对每个结点，累加需要修改的次数。\r\n关于squareFree(int x) — 求平方自由部分:\r\n我们需要只保留不能被2整除的幂次部分，所以按照如下形式解耦出平方自由部分\r\nprivate int squareFree(int x) &#123;    int res = 1;    for (int i = 2; i * i &lt;= x; i++) &#123; // 枚举所有可能的质因数        int cnt = 0;        while (x % i == 0) &#123; // 统计i作为质因子的次数            x /= i;            cnt++;        &#125;        if ((cnt &amp; 1) == 1) res *= i; // 只保留奇数次的质因数    &#125;    if (x &gt; 1) res *= x; // x本身是大于1的质数    return res;&#125;\r\n完整代码如下\r\n//package 数学.subject.P12255_蓝桥杯2024国JavaB_园丁;import java.util.*;import java.io.*;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        new Solutions2();    &#125;&#125;class Solutions2&#123;    private int n;    private int[] a;    private int[] f;    private List&lt;Integer&gt;[] tree;    private int ans = 0;    private int squareFree(int x) &#123;        int res = 1;        for (int i = 2; i * i &lt;= x; i++) &#123;            if (x % i == 0) &#123;                int cnt = 0;                while (x % i == 0) &#123;                    x /= i;                    cnt++;                &#125;                if (cnt % 2 != 0) &#123;                    res *= i;                &#125;            &#125;        &#125;        if (x &gt; 1) &#123;            res *= x;        &#125;        return res;    &#125;    public Solutions2()&#123;        FastReader sc = new FastReader();        n = sc.nextInt();        a = new int[n + 1];        f = new int[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = sc.nextInt();            f[i] = squareFree(a[i]);        &#125;        tree = new ArrayList[n + 1];        for (int i = 1; i &lt;= n; i++) tree[i] = new ArrayList&lt;&gt;();        for (int i = 1; i &lt; n; i++) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            tree[u].add(v);            tree[v].add(u);        &#125;        // 使用迭代的后序遍历来替代递归DFS        Deque&lt;Object[]&gt; stack = new ArrayDeque&lt;&gt;();        stack.push(new Object[]&#123;1, 0, false&#125;);        while (!stack.isEmpty()) &#123;            Object[] node = stack.pop();            int u = (Integer) node[0];            int fa = (Integer) node[1];            boolean visited = (Boolean) node[2];            if (!visited) &#123;                stack.push(new Object[]&#123;u, fa, true&#125;);                List&lt;Integer&gt; children = new ArrayList&lt;&gt;();                for (int v : tree[u]) &#123;                    if (v != fa) &#123;                        children.add(v);                    &#125;                &#125;                // 逆序压入，以保持原来的处理顺序                for (int i = children.size() - 1; i &gt;= 0; i--) &#123;                    int v = children.get(i);                    stack.push(new Object[]&#123;v, u, false&#125;);                &#125;            &#125; else &#123;                List&lt;Integer&gt; children = new ArrayList&lt;&gt;();                for (int v : tree[u]) &#123;                    if (v != fa) &#123;                        children.add(v);                    &#125;                &#125;                if (children.size() &gt;= 2) &#123;                    Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();                    for (int v : children) &#123;                        int sf = f[v];                        cnt.put(sf, cnt.getOrDefault(sf, 0) + 1);                    &#125;                    for (int c : cnt.values()) &#123;                        if (c &gt; 1) &#123;                            ans += c - 1;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(ans);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreElements()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\n\r\n\r\nimage-20250425001434729\r\n\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"简明的XML初步知识的教程","url":"/posts/28372.html","content":"1. XML简介\r\n什么是XML？\r\nXML（可扩展标记语言）是一种标记语言，与HTML非常相似。XML被设计用来传输和存储数据，而HTML被设计用来显示数据。\r\nXML与HTML的区别：\r\n\r\nXML的设计宗旨是传输数据，焦点是数据的内容\r\nHTML被设计用来显示数据，焦点是数据的外观\r\n\r\nXML基本示例\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;site&gt;  &lt;name&gt;RUNOOB&lt;/name&gt;  &lt;url&gt;https://www.runoob.com&lt;/url&gt;  &lt;logo&gt;runoob-logo.png&lt;/logo&gt;  &lt;desc&gt;编程学习网站&lt;/desc&gt;&lt;/site&gt;\r\nXML便签示例\r\n&lt;note&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt;\r\nXML的特点\r\n\r\nXML不会做任何事情：XML仅仅是包装在XML标签中的纯粹的信息，需要编写软件或程序来传送、接收和显示文档\r\n没有预定义标签：HTML中使用的标签都是预定义的，而XML允许创作者定义自己的标签和文档结构\r\n数据分离：通过XML，数据能够存储在独立的XML文件中，可以专注于使用HTML/CSS进行显示和布局\r\n\r\n2. XML树结构\r\n树形结构概念\r\nXML文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。\r\nXML声明和根元素\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt;\r\n\r\n第一行是XML声明，定义XML的版本（1.0）和所使用的编码（UTF-8）\r\n``描述文档的根元素\r\n接下来4行描述根的4个子元素（to, from, heading, body）\r\n最后一行``定义根元素的结尾\r\n\r\n书店示例\r\n&lt;bookstore&gt;    &lt;book category=&quot;COOKING&quot;&gt;        &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;        &lt;author&gt;Giada De Laurentiis&lt;/author&gt;        &lt;year&gt;2005&lt;/year&gt;        &lt;price&gt;30.00&lt;/price&gt;    &lt;/book&gt;    &lt;book category=&quot;CHILDREN&quot;&gt;        &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;        &lt;author&gt;J K. Rowling&lt;/author&gt;        &lt;year&gt;2005&lt;/year&gt;        &lt;price&gt;29.99&lt;/price&gt;    &lt;/book&gt;    &lt;book category=&quot;WEB&quot;&gt;        &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;        &lt;author&gt;Erik T. Ray&lt;/author&gt;        &lt;year&gt;2003&lt;/year&gt;        &lt;price&gt;39.95&lt;/price&gt;    &lt;/book&gt;&lt;/bookstore&gt;\r\nDOM概念\r\nXML将数据组织成为一棵树，DOM通过解析XML文档，为XML文档在逻辑上建立一个树模型。树的节点是一个个的对象，通过操作这棵树和这些对象就可以完成对XML文档的操作。\r\n3. XML语法规则\r\nXML声明\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\r\nXML声明是文档的可选部分，如果存在需要放在文档的第一行。\r\n根元素\r\nXML文档必须有根元素，它是所有其他元素的父元素：\r\n&lt;root&gt;  &lt;child&gt;    &lt;subchild&gt;.....&lt;/subchild&gt;  &lt;/child&gt;&lt;/root&gt;\r\n属性\r\n元素可以包含属性，属性提供有关元素的附加信息：\r\n&lt;person age=&quot;30&quot; gender=&quot;male&quot;&gt;John Doe&lt;/person&gt;\r\n单标签\r\nXML允许使用单标签：\r\n&lt;elementName attribute=&quot;value&quot; /&gt;&lt;!-- 或者 --&gt;&lt;elementName&gt;&lt;/elementName&gt;\r\n标签大小写敏感\r\nXML标签对大小写敏感：\r\n&lt;!-- 错误 --&gt;&lt;Message&gt;这是错误的&lt;/message&gt;&lt;!-- 正确 --&gt;&lt;message&gt;这是正确的&lt;/message&gt;\r\n正确嵌套\r\nXML元素必须正确嵌套：\r\n&lt;!-- 正确 --&gt;&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;&lt;!-- 错误 --&gt;&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;\r\n属性值加引号\r\nXML的属性值必须加引号：\r\n&lt;note date=&quot;12/11/2007&quot;&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;&lt;/note&gt;\r\n实体引用\r\n在XML中，一些字符拥有特殊的意义，需要使用实体引用：\r\n&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;\r\n5个预定义的实体引用：\r\n\r\n&lt; → &lt; (less than)\r\n&gt; → &gt; (greater than)\r\n&amp; → &amp; (ampersand)\r\n' → ' (apostrophe)\r\n\" → \" (quotation mark)\r\n\r\n空格保留\r\n在XML中，空格会被保留（不像HTML会合并多个连续空格）：\r\n&lt;bookstore&gt;    &lt;book&gt;        &lt;title&gt;xx       xxx&lt;/title&gt;        &lt;author&gt;John Doe&lt;/author&gt;        &lt;price&gt;29.99&lt;/price&gt;    &lt;/book&gt;&lt;/bookstore&gt;\r\n4. XML元素\r\n元素的组成\r\nXML元素指的是从开始标签直到结束标签的部分。一个元素可以包含：\r\n\r\n其他元素\r\n文本\r\n属性\r\n或以上所有的混合\r\n\r\n元素示例\r\n&lt;bookstore&gt;    &lt;book category=&quot;CHILDREN&quot;&gt;        &lt;title&gt;Harry Potter&lt;/title&gt;        &lt;author&gt;J K. Rowling&lt;/author&gt;        &lt;year&gt;2005&lt;/year&gt;        &lt;price&gt;29.99&lt;/price&gt;    &lt;/book&gt;    &lt;book category=&quot;WEB&quot;&gt;        &lt;title&gt;Learning XML&lt;/title&gt;        &lt;author&gt;Erik T. Ray&lt;/author&gt;        &lt;year&gt;2003&lt;/year&gt;        &lt;price&gt;39.95&lt;/price&gt;    &lt;/book&gt;&lt;/bookstore&gt;\r\nXML命名规则\r\nXML元素必须遵循以下命名规则：\r\n\r\n名称可以包含字母、数字以及其他字符\r\n名称不能以数字或标点符号开始\r\n名称不能以字母xml（或者XML、Xml等等）开始\r\n名称不能包含空格\r\n\r\n命名习惯\r\n\r\n使名称具有描述性\r\n名称应简短和简单\r\n避免使用”-“、”.”、“:”字符\r\n\r\nXML的可扩展性\r\n&lt;note&gt;    &lt;to&gt;Tove&lt;/to&gt;    &lt;from&gt;Jani&lt;/from&gt;    &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt;\r\nXML的优势之一，就是可以在不中断应用程序的情况下进行扩展。\r\n5. XML属性\r\n属性的作用\r\nXML元素具有属性，类似HTML。属性提供有关元素的额外信息，通常提供不属于数据组成部分的信息。\r\n属性必须加引号\r\n属性值必须被引号包围，单引号和双引号均可使用：\r\n&lt;person sex=&quot;female&quot;&gt;&lt;!-- 或者 --&gt;&lt;person sex=&#x27;female&#x27;&gt;&lt;!-- 如果属性值包含双引号，可以使用单引号 --&gt;&lt;gangster name=&#x27;George &quot;Shotgun&quot; Ziegler&#x27;&gt;&lt;!-- 或者使用字符实体 --&gt;&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt;\r\n元素vs属性\r\n&lt;!-- 使用属性 --&gt;&lt;person sex=&quot;female&quot;&gt;  &lt;firstname&gt;Anna&lt;/firstname&gt;  &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt;&lt;!-- 使用元素 --&gt;&lt;person&gt;  &lt;sex&gt;female&lt;/sex&gt;  &lt;firstname&gt;Anna&lt;/firstname&gt;  &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt;\r\n为什么要避免使用属性\r\n使用属性会引起一些问题：\r\n\r\n属性不能包含多个值（元素可以）\r\n属性不能包含树结构（元素可以）\r\n属性不容易扩展（为未来的变化）\r\n属性难以阅读和维护\r\n\r\n建议：\r\n尽量使用元素来描述数据，仅仅使用属性来提供与数据无关的信息。\r\n针对元数据的XML属性\r\n&lt;messages&gt;  &lt;note id=&quot;501&quot;&gt;    &lt;to&gt;Tove&lt;/to&gt;    &lt;from&gt;Jani&lt;/from&gt;    &lt;heading&gt;Reminder&lt;/heading&gt;    &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;  &lt;/note&gt;  &lt;note id=&quot;502&quot;&gt;    &lt;to&gt;Jani&lt;/to&gt;    &lt;from&gt;Tove&lt;/from&gt;    &lt;heading&gt;Re: Reminder&lt;/heading&gt;    &lt;body&gt;I will not&lt;/body&gt;  &lt;/note&gt;&lt;/messages&gt;\r\n原则：\r\n元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。\r\n6. XML验证\r\n形式良好的XML\r\n“形式良好”的XML文档拥有正确的语法，必须遵循以下规则：\r\n\r\nXML文档必须有一个根元素\r\nXML元素都必须有一个关闭标签\r\nXML标签对大小写敏感\r\nXML元素必须被正确的嵌套\r\nXML属性值必须加引号\r\n\r\nDTD验证\r\n&lt;!DOCTYPE note SYSTEM &quot;Note.dtd&quot;&gt;\r\n\r\nDOCTYPE声明是对外部DTD文件的引用\r\nDTD的目的是定义XML文档的结构\r\n通过DTD验证的XML是”合法”的XML\r\nW3C支持一种基于XML的DTD代替者，叫做XML Schema\r\n\r\nXML验证的重要性\r\nXML文档中的错误会终止XML应用程序。W3C的XML规范声明：如果XML文档存在错误，那么程序就不应当继续处理这个文档。\r\n7. XML查看和显示\r\n浏览器查看\r\n在所有主流的浏览器中，均能够查看原始的XML文件。但不要指望XML文件会直接显示为HTML页面。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;note&gt;  &lt;to&gt;Tove&lt;/to&gt;  &lt;from&gt;Jani&lt;/from&gt;  &lt;heading&gt;Reminder&lt;/heading&gt;  &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt;\r\n使用CSS格式化XML\r\n通过使用CSS，您可以添加显示信息到XML文档中，但这不是常用的方法。\r\n使用XSLT转换\r\nXSLT是首选的XML样式表语言，可以把XML文档转换成HTML格式。\r\nXML数据示例：\r\n&lt;books&gt;    &lt;book&gt;        &lt;title&gt;Effective Java&lt;/title&gt;        &lt;author&gt;Joshua Bloch&lt;/author&gt;        &lt;price&gt;59.99&lt;/price&gt;    &lt;/book&gt;    &lt;book&gt;        &lt;title&gt;Clean Code&lt;/title&gt;        &lt;author&gt;Robert C. Martin&lt;/author&gt;        &lt;price&gt;49.99&lt;/price&gt;    &lt;/book&gt;&lt;/books&gt;\r\nXSLT样式表示例：\r\n&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;    &lt;!-- 定义模板匹配根元素 --&gt;    &lt;xsl:template match=&quot;/&quot;&gt;        &lt;html&gt;            &lt;body&gt;                &lt;h2&gt;My Book List&lt;/h2&gt;                &lt;table border=&quot;1&quot;&gt;                    &lt;tr bgcolor=&quot;#9acd32&quot;&gt;                        &lt;th&gt;Title&lt;/th&gt;                        &lt;th&gt;Author&lt;/th&gt;                        &lt;th&gt;Price&lt;/th&gt;                    &lt;/tr&gt;                    &lt;!-- 应用模板匹配每个 book 元素 --&gt;                    &lt;xsl:apply-templates select=&quot;books/book&quot;/&gt;                &lt;/table&gt;            &lt;/body&gt;        &lt;/html&gt;    &lt;/xsl:template&gt;    &lt;!-- 定义模板匹配每个 book 元素 --&gt;    &lt;xsl:template match=&quot;books/book&quot;&gt;        &lt;tr&gt;            &lt;td&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/td&gt;            &lt;td&gt;&lt;xsl:value-of select=&quot;author&quot;/&gt;&lt;/td&gt;            &lt;td&gt;&lt;xsl:value-of select=&quot;price&quot;/&gt;&lt;/td&gt;        &lt;/tr&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;\r\nXSLT元素说明：\r\n\r\nxsl:stylesheet：XSLT文件的根元素，指定XSLT的版本和命名空间\r\nxsl:template：定义模板，match属性指定模板匹配的XML元素\r\nxsl:apply-templates：调用其他模板，处理指定的XML元素\r\nxsl:value-of：提取XML元素中的文本内容并插入到输出中\r\n\r\n总结\r\nXML是一种强大的数据存储和传输格式，具有以下特点：\r\n\r\n结构化：采用树形结构，层次清晰\r\n可扩展：可以自定义标签和结构\r\n平台无关：跨平台数据交换标准\r\n严格语法：必须遵循严格的语法规则\r\n可验证：可以通过DTD或Schema验证文档结构\r\n可转换：可以通过XSLT转换为其他格式\r\n\r\nXML在Web开发、数据交换、配置文件等领域都有广泛应用，是现代信息系统中不可或缺的技术标准。\r\n","categories":["语言学习","XML"],"tags":["语法知识","学习","语言方面","配置相关","配置文件","知识总结","实用类"]},{"title":"结构化查询语言SQL","url":"/posts/7844.html","content":"结构化查询语言SQL\r\n关系数据模型\r\n关系模型三要素：\r\n\r\n关系数据结构\r\n完整性约束\r\n关系操作\r\n\r\n\r\n\r\nimage-20250512205709773\r\n\r\n\r\n\r\nimage-20250512205715465\r\n\r\n码：关系中某些属性集合具有区分不同元组的作用，称为码\r\n\r\n超码：如果关系的某一组属性的值能唯一标识每个元组，则称该组属性为超码（super\r\nkey）。\r\n候选码：如果一个超码的任意真子集都不是超码，则称该超码为候选码。候选码是极小的超码。\r\n主键：每个关系都有至少一个候选码，人为指定其中一个作为主键\r\n外码：设 F 是关系 R 的属性子集。若 F 与关系 S 的主键 K 相对应，则称\r\nF 是 R 的外键（foreign key）。\r\n\r\nSQL分类\r\nDDL：数据定义语言 定义了不同的数据库，表，视图，索引等数据库对象\r\n还可以创建修改删除等操作数据库表的结构 CREATE  ALTER  DROP  RENAME\r\n TRUMCATE\r\nDML：数据操作语言 增删改查数据库记录 INSERT  DELETE  UPDATE\r\n SELECT\r\nDCL：数据控制语言 定义数据库，表，字段，用户访问权限和安全级别的\r\nCOMMIT  ROLLBACK  SAVEPOINT\r\nDQL：数据库查询语言 查询数据库中表的记录\r\nDTL：数据库事务语言\r\n\r\n\r\nimg\r\n\r\nSQL基本语法\r\nSQL以分号结尾，可以用空格和缩进，windows不区分大小写，linux下大小写敏感，建议关键字大写\r\n注释 –单行注释– # 单行注释\r\n/* 多行注释*/\r\n字符串类型和日期类型的数据可以用 ’’ 表示\r\n列的别名，使用双引号 ”“ 不建议省略as\r\n书写规范：\r\n数据库名，表名，表别名，字段名，字段别名等小写\r\nSQL关键字，函数名，绑定变量等大写\r\n不能以SQL关键字来命名，如果要用，需要加上‘’着重号标记\r\nDDL-数据定义语言\r\n数据定义语言 定义了不同的数据库，表，视图，索引等数据库对象\r\n还可以创建修改删除等操作数据库表的结构\r\nDDL-数据库操作\r\n\r\n查询\r\nSHOW DATABASES;\r\n查询当前数据库\r\nSELECT DATABASE&#123;&#125;；\r\n创建\r\nCREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 指定使用的字符集] [COLLATE 指定排序规则]；\r\n删除\r\nDROP DATABASE [IF EXISTS] 数据库名;\r\n使用\r\nUSE 数据库名； \r\n修改数据库\r\nALTER DATABASE 数据库名 修改部分;\r\n\r\n表操作\r\nDDL-表操作-查询\r\n\r\n查询当前数据库所有表\r\nSHOW TABLES\r\n查询表结构\r\nDESCRIBE 表名; 简写如下\r\nDESC 表名;\r\nSHOW CREATE TABLE 语句会返回创建表时所用的 SQL\r\n语句\r\n查询指定表的建表语句\r\nSHOW CREATE TABLE 表名；\r\n\r\nDDL-表操作-创建\r\nCREATE TABLE 表名&#123;\t字段1  字段1类型[COMMENT 字段1注释],\t字段2  字段5类型[COMMENT 字段2注释],\t字段3  字段3类型[COMMENT 字段3注释],\t......  &#125;[COMMENT 表注释];\r\n快速复制表结构\r\n-- 只复制结构不复制数据CREATE TABLE new_employee LIKE employee;-- 复制结构及数据CREATE TABLE new_employee AS SELECT * FROM employee;-- 复制部分数据CREATE TABLE high_salary_emp AS SELECT * FROM employee WHERE salary &gt; 10000;\r\nDDL-表操作-修改\r\nALTER TABLE 表名 ADD|DROP|MODIFY|CHANGE 字段名 类型 (长度) [COMMENT 注释] [约束];\r\n\r\n添加字段\r\nALTER TABLE 表名 ADD 字段名 类型 (长度) [COMMENT 注释] [约束];\r\n案例：\r\nemp表添加一个新的字段 昵称为 nickname 类型 varchar(20)\r\nALTER TABLE emp ADD nickname VARCHAR(20) COMMENT &quot;昵称&quot;;\r\n修改数据类型\r\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\r\n修改字段名和字段类型\r\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];\r\n删除字段\r\nALTER TABLE 表名 DROP 字段名;\r\n修改表名\r\nALTER TABLE 表名 RENAME TO 新表名;\r\n\r\nDDL-表操作-删除\r\n\r\n删除表\r\nDROP TABLE [IF EXIST] 表名；\r\n删除指定表，并重新创建\r\nTRUNCATE TABLE 表名；\r\n\r\nDML-数据操作语言\r\n数据操作语言 增删改查数据库记录\r\n\r\n添加数据 INSERT\r\n修改数据 UPDATE\r\n删除数据 DELETE\r\n\r\nDML-插入\r\n\r\n给指定的字段添加数据\r\nINSERT INTO (字段名1，字段名2)  VALUES (值1，值2。。)\r\n给全部字段添加数据\r\nINSERT INTO 表名 VALUES (值1，值2。。)\r\n批量添加数据\r\nINSERT INTO 表名 (字段名1，字段名2。。。) VALUES (值1，值2...) (值1，值2...) (值1，值2...);INSERT INTO 表名 VALUES (值1，值2...) (值1，值2...) (值1，值2...);\r\n\r\n注意：\r\n\r\n插入数据时，指定的字段顺序需要与值的顺序一一对应\r\n字符串和日期的数据类型都应该包含在引号中\r\n插入的数据大小，应该在这个字段的范围内\r\n\r\nDML-修改\r\n修改数据表中的字段值：\r\nUPDATE 表名 SET 字段名1=值1，字段名2=值2..... [WHERE 条件]；\r\n\r\n修改语句的条件可以有，如果没有就是针对整张表\r\n\r\nDML-删除\r\n删除数据表中的数据\r\nDELETE FROM 表名 [WHERE 条件]；\r\n\r\nDELETE的条件可以有，如果没有，就是删除整张表的数据\r\nDELETE不能删除某一个字段的值，可以用UPDATE\r\n\r\nDQL-数据查询语言\r\n数据查询语言，查询数据库中表的记录\r\n\r\n关键字 SELECT\r\n\r\nDQL 语法\r\nSELECT \t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后条件列表ORDER BY\t排序字段列表LIMIT\t分页参数\r\nDQL-基础查询\r\nSELECT \t字段列表FROM\t表名列表\r\n查询多个字段\r\nSELECT 字段1，子段2。。。 FROM 表名；\r\n整表查询\r\nSELECT * FROM 表名;\r\n设置别名\r\nSELECT 字段1 [AS 别名1]，字段2 [AS 别名2] ... FROM 表名；\r\n\r\nas 列的别名可以用一对“”引起来\r\n\r\n去除重复记录\r\nSELECT DISTINCT 字段列表 FROM 表名；\r\n查询常数\r\n查询常数指的是在查询结果里返回固定值，而非从表字段获取数据\r\nSELECT &#x27;这是一个常数&#x27; AS constant_value;\r\n假定有一个 employees 表，包含 id 和\r\nname 字段，你能够在查询结果里既显示表数据，又显示常数。\r\nSELECT id, name, &#x27;固定部门&#x27; AS department FROM employeses;\r\n此查询会返回 employees 表中的 id 和\r\nname 字段，同时为每一行添加一个名为 department\r\n的列，其值均为 固定部门。\r\nDQL-条件查询\r\n基本语句\r\nSELECT 字段列表 FROM 表名 WHERE 条件列表;\r\n比较运算符\r\n等于（=）\r\n不等于（&lt;&gt; 或！=）\r\n大于（&gt;）\r\n小于（&lt;）\r\n大于等于（&gt;=）\r\n小于等于（&lt;=）\r\nBETWEEN…AND某个范围内 （BETWEEN之后跟最小值\r\nAND之后跟着最大值）\r\nIN 在IN之后的列表中的值，多选一\r\nLIKE 模糊匹配（_匹配单个字符，%匹配多个字符）\r\n-- 查询名字包含&quot;张&quot;的员工SELECT * FROM employee WHERE name LIKE &#x27;%张%&#x27;;-- 查询名字以&quot;张&quot;开头且长度为3的员工SELECT * FROM employee WHERE name LIKE &#x27;张__&#x27;;-- 查询手机号第二位是5的员工SELECT * FROM employee WHERE phone LIKE &#x27;_5%&#x27;;\r\nIS NULL （NULL）\r\n-- 查询奖金为NULL的员工SELECT * FROM employee WHERE bonus IS NULL;-- 查询奖金不为NULL的员工SELECT * FROM employee WHERE bonus IS NOT NULL;-- 使用IFNULL处理NULL值SELECT name, salary, IFNULL(bonus, 0) AS total_income FROM employee;\r\n逻辑运算符\r\nAND 或 &amp;&amp; 与\r\nOR 或 || 或\r\nNOT 或 ! 非\r\n-- 查询年龄SELECT name FROM employee WHERE age = 55;SELECT * FROM employee WHERE age = 55;-- 查询有身份证号的员工信息SELECT * FROM employee WHERE idcard is not null;-- 查询年龄不为55的员工SELECT * FROM employee WHERE age != 55;-- 模糊查询名字为两个字的员工信息SELECT * FROM employee WHERE name LIKE &#x27;__&#x27;;-- 查询身份证号最后一位为8的SELECT * FROM employee WHERE idcard LIKE &#x27;%8&#x27;\r\nDQL-聚合函数\r\n聚合函数：一列数据作为一个整体，纵向计算\r\n常见聚合函数：\r\ncount 统计数量\r\nmax 最大值\r\nmin 最小值\r\navg 平均值\r\nsum 求和\r\n聚合函数都是作用与表的某一列\r\nSELECT 聚合函数(字段列表) FROM 表名；\r\nnull不参与聚合函数的计算\r\n空值参与运算，结果一定为空\r\n-- 查询总数据SELECT COUNT(*) FROM employee;-- 统计id字段的总数量SELECT COUNT(id) FROM employee;-- 统计企业员工的平均年龄SELECT avg(age) FROM employee;-- 统计企业员工的年龄和SELECT SUM(age) FROM employee;\r\nDQL-分组查询\r\n关键字：GROUP BY\r\n语句：\r\nSELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\r\nwhere与having区别\r\n执行实际不同：where是分组前进行过滤，不满足where条件不参与分组；HAVING是分组后对结果过滤\r\n判断条件不同：WHERE不能对聚合函数判断，HAVING可以\r\n执行顺序 where &gt; 聚合函数 &gt; having\r\n分组之后，查询的字段一般为聚合函数和分组字段，其他字段无意义\r\nSELECT name,gender,COUNT(*) FROM employee GROUP BY gender;\r\n-- 根据性别分组统计男女员工数量SELECT gender, COUNT(*) FROM employee GROUP BY gender;-- 根据性别分组统计男女员工的平均年龄SELECT employee.gender,AVG(employee.age) FROM itcast.employee GROUP BY gender;-- 查询年龄小于45岁的员工，并根据WOKRNO分组SELECT workno,COUNT(*) FROM employee WHERE age &lt; 45 GROUP BY workno;SELECT workno,COUNT(*) FROM employee WHERE age &lt; 45 GROUP BY workno HAVING COUNT(*) &gt;= 1;SELECT workno,COUNT(*) worknum FROM employee WHERE age &lt; 45 GROUP BY workno HAVING worknum &gt;= 1;\r\nDQL-排序查询\r\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2...;\r\n支持多字段排序\r\n​ 如果是多字段排序，当第一个字段值相同时候会按照第二个这样依次\r\n排序方式\r\n\r\nASC 升序 默认\r\nDESC 降序\r\n\r\n-- 排序查询-- 根据年龄对公司的员工进行升序排序SELECT * FROM employee ORDER BY age ASC;-- 根据入职时间，对员工进行降序排序SELECT name FROM employee ORDER BY employee.entrydate DESC;-- 根据年龄对公司的员工进行升序排序，年龄相同，再根据入职时间排序SELECT * FROM employee ORDER BY employee.entrydate DESC, entrydate ASC;\r\nDQL-分页查询\r\nSELECT 字段列表 FROM 表名 LIMIT 起始索引, 每页记录数;\r\n注意：\r\n\r\n起始索引从0开始，起始索引 =\r\n（查询页码-1）*每页显示记录数\r\n分页查询是数据库的方言，不同的数据库之间不同，mysql中是LIMIT\r\n如果查询的第一页数据，起始索引可以省略，直接简写\r\n\r\nDQL-执行顺序\r\n编写顺序\r\nSELECT \t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后条件列表ORDER BY\t排序字段列表LIMIT\t分页参数\r\n执行顺序\r\n\r\nFROM 决定我要查询那一张表\r\nWHERE 指定查询的条件\r\nGROUP BY 和 HAVING 指定分组\r\nSELECT 字段列表\r\nORDER BY 指定排序\r\nLIMIT 指定分页\r\n\r\nDCL-数据控制语言\r\n主要用来管理数据库的用户，控制数据库的访问权限\r\nDCL–管理用户\r\n本质上是对user表的修改\r\n主机名可以用%通配\r\n查询用户\r\nUSE mysql；SELECT * FROM user;\r\n\r\n主机地址和用户名才能定位一个用户，本质上是查询user表\r\n\r\n创建用户\r\nCREATE USER ‘用户名’@‘主机名’ IDENTIFIED BY &#x27;密码&#x27;;\r\nCREATE USER ‘用户名’@‘主机名’ IDENTIFIED BY ‘密码’;\r\n修改用户密码\r\nALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;\r\n删除用户\r\nDROP USER ‘用户名’@‘主机名’;\r\nDCL-权限控制\r\nMySQL中定义了多种权限，常用的就这些\r\nALL, ALL PRIVILEGES 所有权限\r\nSELECT 查询数据\r\nINSERT 插入数据\r\nUPDATE 修改数据\r\nDELETE 删除数据\r\nALTER 修改表\r\nDROP 删除数据库/表/视图\r\nCREATE 创建数据库/表\r\n查询权限\r\nSHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;\r\n授予权限\r\nGRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;\r\n撤销权限\r\nREVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;\r\n注意：\r\n\r\n多个权限之间，使用逗号分隔\r\n授权时，数据库名和表名可以使用*进行通配，代表所有\r\n\r\n多表查询\r\n多表关系\r\n一对多（多对一） 多的一方建立外键，指向一的一方的主键\r\n多对多 建立第三张表，中间表至少包含两个外键，分别关联两方主键\r\n一对一 拆分表\r\n在任意一方加入外键，管理另外一方的主键，并且设置为UNIQUE\r\n内连接\r\n查询表1，表2 交集部分数据\r\n\r\n\r\nimg\r\n\r\n这种场景下得到的是满足某一条件的A，B内部的数据；正因为得到的是内部共有数据，所以连接方式称为内连接。\r\n隐式内连接\r\nSELECT 字段列表 FROM 表1，表2 WHERE 筛选条件;\r\n显式内连接\r\nSELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 连接条件;\r\n示例：\r\n-- 题目 1：查询每个用户的角色ID列表-- 实际场景：管理员需要查看每个用户关联的角色ID。SELECT user.user_id, user_role.role_id FROM userINNER JOIN user_role ON user.user_id = user_role.user_id;-- 题目 2：查询每个角色的权限ID列表-- 实际场景：系统需要列出每个角色关联的权限ID。SELECT role.role_id, role_permission.permission_id FROM roleINNER JOIN role_permission ON role.role_id = role_permission.role_id;\r\n外连接\r\n\r\n左右外连接\r\n左外连接\r\n左外连接查询左表所有数据，以及两张表交集部分数据\r\n左外连接相当于查询表A(左表)的所有数据和中间绿色的交集部分的数据。\r\n表1的位置为左表，表2的位置为右表\r\nSELECT 字段列表FROM 表1LEFT [OUTER] JOIN 表2ON 条件;\r\n右外连接\r\n右外连接查询左表所有数据，以及两张表交集部分数据\r\n右外连接相当于查询表B(右表)的所有数据和中间绿色的交集部分的数据。\r\n表1的位置为左表，表2的位置为右表\r\nSELECT 字段列表FROM 表1RIGHT [OUTER] JOIN 表2ON 条件;\r\n自连接\r\n自连接是指将一张表与自身进行连接操作。通常用于处理表中存在层级关系或递归关系的数据。\r\n在自连接中，我们需要为同一张表创建两个别名（如 p1 和\r\np2），然后通过某种条件将这两个别名关联起来。\r\n自连接表一定要起别名\r\n对于自连接查询，可以是内连接查询，也可以是外连接查询。\r\n连接条件通常是父子关系字段\r\nSELECT 字段列表FROM 表A 别名AJOIN 表B 别名BON 条件;\r\n示例：\r\n-- permission_id：权限的唯一标识。   parent_permission_id：当前权限的父权限 ID。-- 找到每个权限的直接子权限SELECT     p1.permission_id AS parent_permission_id,     p1.permission_name AS parent_permission_name,     p2.permission_id AS child_permission_id,     p2.permission_name AS child_permission_nameFROM     permission p1LEFT JOIN   -- 确保即使某个权限没有子权限，父权限的信息仍然会被显示出来。    permission p2 ON p1.permission_id = p2.parent_permission_id;\r\n连接条件：对于 p1 中的每个权限（父权限），查找\r\np2 中所有 parent_permission_id 等于该权限 ID\r\n的记录（子权限）\r\n\r\n使用 INNER JOIN 时，只会返回有子权限的父权限。\r\n使用 LEFT JOIN\r\n时，会返回所有父权限，即使它们没有子权限。\r\n\r\n-- 查询员工及其直接上级SELECT e1.name AS employee, e2.name AS managerFROM employee e1LEFT JOIN employee e2 ON e1.manager_id = e2.emp_id;-- 查询同一部门的员工对SELECT a.name AS employee1, b.name AS employee2FROM employee aJOIN employee b ON a.dept_id = b.dept_id AND a.emp_id &lt; b.emp_id;\r\n联合查询\r\nunion查询，就是把多次查询的结果合并，形成一个新的查询结果\r\nSELECT 字段列表 FROM 表AUNION [ALL]SELECT 字段列表 FROM 表B\r\n\r\n联合查询的多张表列数必须保持一致，字段类型也需要保持一致\r\nunion all\r\n会将全部的数据合并，union会对合并后的数据去重\r\n\r\n子查询\r\n子查询是指嵌套在另一个 SQL 语句中的 SELECT\r\n查询。\r\n它可以出现在 WHERE、FROM、SELECT\r\n等子句中，用于提供额外的数据过滤或计算条件。\r\n子查询必须用括号 () 包裹\r\nNULL 值处理：子查询返回 NULL 可能导致意外结果，需用\r\nIS NULL 或 COALESCE 处理\r\nSELECT * FROM 表1 WHERE 字段列表1 = （SELECT 字段列表 FROM 表2）\r\n\r\n子查询外部的语句可以是INSERT UPDATE DELETE SELECT中的任意一个\r\n标量子查询：子查询结果为单个值\r\n列字查询：子查询结果为一列\r\n行子查询：子查询结果为一行\r\n表子查询：子查询结果为多行多列\r\n\r\n根据子查询位置，分为WHRER之后，FROM之后，SELECT之后\r\n标量子查询\r\n\r\n特点：返回单个值（一行一列）\r\n常见场景：作为条件判断、赋值或计算的一部分\r\n\r\n示例：查询工资高于平均工资的员工\r\nSELECT emp_name, salaryFROM employeesWHERE salary &gt; (SELECT AVG(salary) FROM employees);\r\n\r\n子查询 (SELECT AVG(salary) FROM employees)\r\n返回一个标量值（平均工资）\r\n主查询通过 &gt; 比较每个员工的工资与平均值\r\n\r\n列子查询（Column\r\nSubquery）\r\n\r\n特点：返回一列多行的数据\r\n常用操作符：IN, NOT IN,\r\nANY, ALL\r\n\r\n示例：查询所有部门经理的员工信息\r\nSELECT * FROM employeesWHERE emp_id IN (SELECT manager_id FROM departments);\r\n行子查询（Row\r\nSubquery）\r\n\r\n特点：返回一行多列的数据\r\n常用操作符：=, &lt;&gt;,\r\nALL\r\n\r\n示例：查询与某个员工（ID=1001）部门和职位都相同的其他员工\r\nSELECT * FROM employeesWHERE (department_id, position) =       (SELECT department_id, position FROM employees WHERE emp_id = 1001)  AND emp_id != 1001;\r\n\r\n子查询返回 emp_id=1001 的员工的部门和职位信息\r\n主查询使用行比较 (col1, col2) = (val1, val2)\r\n匹配条件\r\n\r\n表子查询（Table\r\nSubquery）\r\n\r\n特点：返回多行多列的数据（类似临时表）\r\n常用位置：FROM 子句中，需使用别名\r\n\r\n示例：查询每个部门的平均工资，并按降序排列\r\nSELECT dept_name, avg_salaryFROM (    SELECT department_id, AVG(salary) AS avg_salary    FROM employees    GROUP BY department_id) AS tJOIN departments d ON t.department_id = d.department_idORDER BY avg_salary DESC;\r\n\r\n子查询计算每个部门的平均工资\r\n主查询将子查询结果（临时表\r\nt）与部门表连接，获取部门名称\r\n\r\n子查询中 EXISTS\r\nEXISTS：子查询是否返回任何行。如果子查询返回至少一行，则EXISTS条件为真，外层查询将根据这个结果进行相应的操作。\r\nEXISTS只关心子查询是否有结果返回，而不关心返回的具体内容\r\nSELECT columnsFROM table_nameWHERE EXISTS (subquery);\r\n-- 查询有下属的员工SELECT name FROM employee e1WHERE EXISTS (SELECT 1 FROM employee e2 WHERE e2.manager_id = e1.emp_id);-- 查询没有订单的客户SELECT name FROM customers cWHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);\r\n子查询与连接（JOIN）的对比\r\n子查询和连接都可以实现多表数据关联，但适用场景不同：\r\n\r\n\r\n\r\n子查询\r\n连接（JOIN）\r\n\r\n\r\n\r\n\r\n适合单值条件过滤\r\n适合多表数据关联展示\r\n\r\n\r\n逻辑上更直观（分步处理）\r\n性能通常更高（优化器优化）\r\n\r\n\r\n可能导致多次执行子查询\r\n通常一次性扫描所有表\r\n\r\n\r\n\r\n示例对比：查询每个部门的经理姓名（子查询 vs\r\nJOIN）\r\n-- 子查询SELECT     dept_name,    (SELECT emp_name FROM employees WHERE emp_id = departments.manager_id) AS managerFROM departments;-- JOIN 方式SELECT     d.dept_name,    e.emp_name AS managerFROM departments dJOIN employees e ON d.manager_id = e.emp_id;\r\n","categories":["学习类","数据库","MySql","MySql基础"],"tags":["实用知识","常用知识","数据库","MySql","语言基础"]},{"title":"蓝桥杯2025Python省BF题园艺题解","url":"/posts/20727.html","content":"洛谷上的题目markdown\r\nP12175 [蓝桥杯 2025 省 Python B] 园艺\r\n题目描述\r\n小蓝从左到右种了 n\r\n棵小树，第 i 棵树的高度为\r\nhi，相邻树的间隔相同。小蓝想挪走一些树使得剩下的树等间隔分布，且从左到右高度逐渐上升（相邻两棵树高度满足右边的比左边的高），小蓝想知道最多能留下多少棵树。\r\n输入格式\r\n输入的第一行包含一个正整数 n。\r\n第二行包含 n 个正整数 h1, h2, ⋯, hn，相邻整数之间使用一个空格分隔。\r\n输出格式\r\n输出一行包含一个整数表示答案。\r\n输入输出样例\r\n输入 #1\r\n63 5 4 7 6 7\r\n输出 #1\r\n3\r\n说明/提示\r\n样例说明\r\n留下第 1、3、5 棵树，它们等间隔且从左到右高度逐渐上升。\r\n评测用例规模与约定\r\n\r\n对于 30% 的评测用例，1 ≤ n ≤ 500；\r\n对于 60% 的评测用例，1 ≤ n ≤ 3000；\r\n对于所有评测用例，1 ≤ n ≤ 5000，0 &lt; hi &lt; 106。\r\n\r\n\r\n问题概述\r\n题目要求我们在一排树中选出尽可能多的树，满足两个条件：\r\n\r\n选出的树必须是等间隔分布的\r\n选出的树的高度必须严格递增\r\n\r\n思路\r\n可以发现类似 最长下降子序列 的问题\r\n考虑 dp ，对于每棵树 i ，检查它前面所有的树 j ，如果树 j 的高度小于树\r\ni 的高度，计算它们之间的间隔 diff\r\ndp[i][d]表示以第 i 棵树结尾，间隔为 d\r\n的最长子序列长度\r\n记录以树 i 结尾、间隔为 diff 的最长子序列长度\r\n代码\r\npackage 动态规划.subject.线性dp.P12175_蓝桥杯2025_省_PythonB_园艺;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // 初始化输入        Scanner sc = new Scanner(System.in);        int n = sc.nextInt(); // 读取树的总数        int[] tree = new int[n]; // 存储每棵树的高度                // 读取每棵树的高度        for (int i = 0; i &lt; n; i++) &#123;            tree[i] = sc.nextInt();        &#125;        // 动态规划数组        // dp[i][d]表示以第i棵树结尾，间隔为d的最长子序列长度        int[][] dp = new int[n][n];                // 初始最大值设为1，因为至少可以选择一棵树        int max = 1;        // 初始化：每棵树可以单独形成一个子序列        // dp[i][0]表示间隔为0的情况（即只选这一棵树）        for (int i = 0; i &lt; n; i++) &#123;            dp[i][0] = 1;        &#125;        // 动态规划主过程        for (int i = 0; i &lt; n; i++) &#123; // 遍历每棵树作为结尾            for (int j = 0; j &lt; i; j++) &#123; // 检查前面的所有树                // 只有当当前树比前面的树高时才考虑                if (tree[j] &lt; tree[i]) &#123;                    // 计算两棵树之间的间隔                    int diff = i - j;                                        // 获取以树j结尾、间隔为diff的最长子序列长度                    int prev = dp[j][diff];                                        // 如果prev为0，说明树j是单独存在的                    // 此时可以形成一个长度为2的子序列（树j和树i）                    if (prev == 0) &#123;                        prev = 1;                    &#125;                                        // 如果发现更长的子序列，就更新                    if (dp[i][diff] &lt; prev + 1) &#123;                        dp[i][diff] = prev + 1;                                                // 更新全局最大值                        if (dp[i][diff] &gt; max) &#123;                            max = dp[i][diff];                        &#125;                    &#125;                &#125;            &#125;        &#125;        // 输出结果        System.out.println(max);                // 关闭Scanner        sc.close();    &#125;&#125;\r\n因为是 python 组的题目，所以这里放一下python的代码\r\ndef main():    import sys    input = sys.stdin.read        # 读取输入数据    data = input().split()    n = int(data[0])    tree = list(map(int, data[1:n+1]))        # 初始化动态规划数组    # dp[i][d] 表示以第i棵树结尾，间隔为d的最长子序列长度    dp = [[0] * n for _ in range(n)]    max_len = 1  # 至少可以选一棵树        # 初始化：每棵树可以单独形成一个子序列    for i in range(n):        dp[i][0] = 1        # 动态规划主过程    for i in range(n):  # 遍历每棵树作为结尾        for j in range(i):  # 检查前面的所有树            if tree[j] &lt; tree[i]:  # 只有当前树比前面的树高时才考虑                diff = i - j  # 计算间隔                                # 获取以树j结尾、间隔为diff的最长子序列长度                prev = dp[j][diff]                                # 如果prev为0，说明树j是单独存在的                # 此时可以形成一个长度为2的子序列（树j和树i）                if prev == 0:                    prev = 1                                # 如果发现更长的子序列，就更新                if dp[i][diff] &lt; prev + 1:                    dp[i][diff] = prev + 1                                        # 更新全局最大值                    if dp[i][diff] &gt; max_len:                        max_len = dp[i][diff]        # 输出结果    print(max_len)if __name__ == &quot;__main__&quot;:    main()\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"Java注解之自定义注解","url":"/posts/13512.html","content":"注解的基本结构\r\n以重写为例子了解基本结构\r\npackage java.lang;import java.lang.annotation.*;/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: *  * &lt;ul&gt;&lt;li&gt; * The method does override or implement a method declared in a * supertype. * &lt;/li&gt;&lt;li&gt; * The method has a signature that is override-equivalent to that of * any public method declared in &#123;@linkplain Object&#125;. * &lt;/li&gt;&lt;/ul&gt; *  * @author  Peter von der Ah&amp;eacute; * @author  Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\r\n注解的名称：\r\npublic @interface Override &#123;&#125;\r\n注解的元注解\r\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)\r\n这两个注解是注解中用到最多的元注解\r\n总结：\r\n注解分为两部分 :\r\n\r\n元注解 ;\r\npublic @interface 注解名称 ;\r\n\r\n注解的本质\r\n按照 public @interface 注解名称 格式 , 写出一个注解 ,\r\n编译该注解代码生成 Annotation.class 字节码文件 ;\r\npublic @interface Annotation &#123;&#125;\r\n使用 javap 命令反编译 Annotation.class 字节码文件 ,\r\n查看该注解的实际代码 ;\r\n发现输出\r\npublic interface Annotation extends java.lang.annotation.Annotation &#123;&#125;\r\n所以说，注解的本质是一个 interface 接口 , 注解接口默认继承了\r\njava.lang.annotation.Annotation 接口 ;\r\n有如下关键特性：\r\n\r\n注解接口隐式继承Annotation接口\r\n不能显式实现其他接口\r\n不能包含泛型参数\r\n不能抛出异常\r\n\r\n注解的属性\r\n注解的属性\r\n注解的本质是接口 , 接口中可以定义 常量 和 方法 ;\r\n在注解中定义 接口方法 , 就是 注解的属性 ;\r\n为注解添加属性 : 接口中的方法都是抽象方法 , 其中 public abstract\r\n可以省略 ;\r\npublic @interface Annotation &#123;    public abstract String path();   // Annotation接口 实现的接口 Annotation 中定义的注解属性(抽象方法)&#125;\r\n使用\r\n@注解名称(属性名称 = 属性值)\r\n@Annotation(path = &quot;&quot;)Student(String name, int age)&#123;&#125;\r\n属性定义规则\r\npublic @interface RequestMapping &#123;    String path();                // 必需属性    String method() default &quot;GET&quot;;// 可选属性    String[] params() default &#123;&#125;; // 数组属性&#125;\r\n注解的属性类型\r\n注解中定义了属性 , 在使用注解时 , 需要 给 注解属性 赋值 ;\r\n定义 注解属性 时 , 可以 使用 default 关键字 指定属性默认值\r\nint intValue() default 666;   // 制定 注解属性 intValue 值类型为 int 整型 , 默认值 666 \r\n\r\n如果 注解属性 指定了默认值 , 在使用注解时 , 可以选择\r\n不为该属性赋值 ( 此时使用默认属性值 ) , 也可以进行赋值 (\r\n指定一个新的属性值 ) ;\r\n如果 注解属性 没有指定默认值 , 则使用 注解 时 ,\r\n必须为其指定一个默认值 , 否则编译时报错 ;\r\n\r\n注解属性 ( 接口方法 ) 返回值类型要求 :\r\n\r\n基本数据类型 : byte , short , int , long , float , double , char ,\r\nboolean ;\r\n字符串类型 : String ;\r\n枚举类型 : enum ;\r\n注解类型 ;\r\n其他注解类型\r\n以上类型的数组形式 ，不允许多维数组\r\n\r\n禁止的类型：\r\n\r\n自定义对象类型\r\n泛型类型（如List）\r\nnull值（默认值不能为null）\r\n\r\n注解属性返回值必须是以上的类型 , 不能设置其它类型返回值 , 否则会报错\r\n;\r\n赋值简化操作：\r\n如果 注解属性 名称是 value , 并且 注解中只有 1 个属性 , 那么在使用\r\n注解 为 注解属性 赋值时 , 可以省略注解名称 , 直接传入 注解属性值 ;\r\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;// 使用 SuppressWarnings 注解时 , 直接传入 “all” 参数 , 省略了注解属性名称 ;    @SuppressWarnings(&quot;all&quot;)    @Override    public String toString() &#123;        return super.toString();    &#125;// 注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\r\n注解属性 名称是 value , 并且 注解中只有 1 个属性,\r\n才能使用上述简化方式\r\n自定义一个注解\r\n\r\n使用@interface来申明一个自定义注解时，他会自动继承ava.lang.annotation.Annotation接口。\r\n格式public @interface\r\nxxx(注解名称){定义注解参数内容}。\r\n\r\n// 1. 定义带参数的注解@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ApiVersion &#123;    String group() default &quot;default&quot;;    int[] versions();  // 必须显式赋值&#125;// 2. 使用注解@ApiVersion(group = &quot;user&quot;, versions = &#123;1, 2&#125;)public class UserController &#123;    @ApiVersion(versions = &#123;2&#125;) // 使用默认group    public void updateUser() &#123;...&#125;&#125;// 3. 通过反射处理注解Class&lt;UserController&gt; clazz = UserController.class;ApiVersion classAnnotation = clazz.getAnnotation(ApiVersion.class);if (classAnnotation != null) &#123;    System.out.println(&quot;Supported versions: &quot; +         Arrays.toString(classAnnotation.versions()));&#125;\r\n如果是注解有参数，需要在注解里面添加参数类型\r\n参数格式： 类型 + 名称();\r\n加了参数后，使用注解如果不添加参数的话会报错，除非添加默认值\r\n参数设计建议\r\n\r\n当只有一个参数时，建议命名为value\r\n数组参数建议提供空数组默认值（default &#123;&#125;）\r\n复杂参数使用注解嵌套：\r\n\r\n\r\n\r\n111\r\n\r\n如果只有一个参数可以直接使用value命名，这样在使用注解的时候可以省略’名称=“xx”’直接赋值\r\n注解的使用\r\n自定义注解的使用需要用到反射的原理\r\n//作用于类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface ClassAnno&#123;    String value();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoName&#123;    String name();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoAge&#123;    int age();&#125;public class CustomAnnotationExample &#123;    public static void main(String[] args) &#123;        // 获取类的注解信息        Class&lt;Person&gt; personClass = Person.class;   // 反射获取        if (personClass.isAnnotationPresent(ClassAnno.class)) &#123;            // 取出Annotation注解信息            ClassAnno classAnno = personClass.getAnnotation(ClassAnno.class);            System.out.println(&quot;类注解信息: &quot; + classAnno.value());        &#125;        // 获取属性的注解信息        // 需要注意的是，类是默认缺省的，是有访问权限的。而name和age是私有private的，无法直接获取到Filed对象，需要使用getDeclaredField以及getDeclaredAnnotation获取        Field[] fields = personClass.getDeclaredFields();  // getDeclaredFields()反射获取        for (Field field : fields) &#123;            if (field.isAnnotationPresent(FiledAnnoName.class)) &#123;                // 使用反射获取Student注解信息annotations 可以获取到注解里面的值是多少                FiledAnnoName filedAnnoName = field.getAnnotation(FiledAnnoName.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoName.name());            &#125;            if (field.isAnnotationPresent(FiledAnnoAge.class)) &#123;                FiledAnnoAge filedAnnoAge = field.getAnnotation(FiledAnnoAge.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoAge.age());            &#125;        &#125;    &#125;\r\n引用\r\n【Java\r\n注解】自定义注解 ( 注解属性定义与赋值 )\r\njava如何优雅的自定义一个注解？\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","学习","JavaSE","语言方面"]},{"title":"三大自动注入相关注解的分析和对比","url":"/posts/2780.html","content":"自动注入相关注解\r\n@Autowired\r\n在使用Spring进行项目开发的时候，会大量使用到自动装配，那自动装配是什么呢？简单来说：Spring\r\n利用依赖注入（DI）功能，完成SpringIOC容器中各个组件之间的依赖关系赋值管理。\r\n@Autowired\r\n是一个Spring框架的原生注解，它可以对类成员变量、方法及构造函数进行标注，让\r\nspring 完成 bean 自动装配的工作，是 Spring\r\n框架中用于实现依赖注入（Dependency Injection, DI）\r\n的关键注解\r\n\r\n自动将容器中已创建的 Bean 注入到当前 Bean 的字段、构造方法或\r\nsetter 方法中\r\n避免手动创建对象，实现松耦合的组件协作\r\n遵循 “控制反转（IoC）” 原则，让容器管理对象生命周期\r\n\r\n使用@Autowired 时候，容器启动的扫描流程如下：\r\n\r\nSpring容器在启动时会自动扫描并管理所有带有\r\n@Component、@Service、@Repository\r\n和 @Controller 等注解的类\r\n@Autowired\r\n通过类型匹配（byType）在容器中查找对应的\r\nBean，自动将匹配的bean注入到指定的位置。\r\n\r\n默认情况下，Spring 按类型解析 @Autowired\r\n依赖。如果容器中存在多个相同类型的\r\nBean，框架将抛出异常。要解决这一冲突，需要明确告诉 Spring 要注入哪个\r\nBean。\r\npublic interface PaymentService &#123; ... &#125;@Service(&quot;alipayService&quot;)public class AlipayServiceImpl implements PaymentService &#123; ... &#125;@Service(&quot;wechatPayService&quot;)public class WechatPayServiceImpl implements PaymentService &#123; ... &#125;@Servicepublic class OrderService &#123;    @Autowired    private PaymentService paymentService; // 报错：存在两个 PaymentService Bean&#125;\r\n此时可以通过@Qualifier进行指定名称去装配\r\nbean，它会检查容器，并查找与要自动装配的属性名称完全相同的 Bean\r\n来进行装配，但是也可通过 @Service(\"自定义名称\")\r\n指定）。\r\n@Servicepublic class OrderService &#123;    @Autowired    @Qualifier(&quot;alipayService&quot;) // 明确指定注入名为 &quot;alipayService&quot; 的 Bean    private PaymentService paymentService;&#125;\r\n而且还可以给 Bean 添加 @Primary\r\n注解，标记其中一个作为默认首选。但是在@Qualifier存在情况下会强制指定特定\r\nBean，优先级高于 @Primary。\r\n@Service@Primarypublic class AlipayServiceImpl implements PaymentService &#123; ... &#125;@Servicepublic class WechatPayServiceImpl implements PaymentService &#123; ... &#125;@Servicepublic class OrderService &#123;    @Autowired    @Qualifier(&quot;wechatPayService&quot;) // 即使 AlipayServiceImpl 被 @Primary 标记，仍注入 wechatPayService    private PaymentService paymentService;&#125;\r\n注意与@Primary 和\r\n@Profile的区别\r\n@Service@Primary@Profile(&quot;prod&quot;) // 生产环境默认使用支付宝public class AlipayServiceImpl implements PaymentService &#123; ... &#125;@Service@Primary@Profile(&quot;dev&quot;) // 开发环境默认使用微信支付public class WechatPayServiceImpl implements PaymentService &#123; ... &#125;\r\n@Autowired 包含两个重要参数：\r\n\r\nrequired（默认\r\ntrue）：\r\n指定依赖是否必须存在。若为 false，当容器中没有匹配的\r\nBean 时，注入 null 而不抛出异常\r\n@Autowired(required = false)private UserRepository userRepository; // 允许为 null\r\n与 @Qualifier 配合使用：\r\n当存在多个同类型 Bean 时，通过 @Qualifier 指定要注入的 Bean\r\n的名称。\r\n\r\n@Autowired\r\n可以标注在三个位置，功能等价但使用场景不同：\r\n\r\n字段注入\r\n在 Bean 实例化后立即注入\r\n使用 @Autowired\r\n对属性进行注解。这样就不需要使用Getter和\r\nSetter 了\r\n@Servicepublic class UserService &#123;    @Autowired    private UserRepository userRepository; // 自动注入Repository    // ...业务逻辑&#125;\r\n构造方法注入\r\n在 Bean 创建时注入（推荐用于必填依赖）\r\n@Servicepublic class OrderService &#123;    private final OrderRepository orderRepository;        @Autowired    public OrderService(OrderRepository orderRepository) &#123;        this.orderRepository = orderRepository;    &#125;    // ...&#125;\r\nSpring 4.3 + 后，若构造方法唯一，@Autowired 可省略\r\nSetter 方法注入（支持可选依赖）\r\n在 Bean 初始化阶段注入\r\n@Servicepublic class LogService &#123;    private LogRepository logRepository;        @Autowired(required = false) // 设置为可选依赖    public void setLogRepository(LogRepository logRepository) &#123;        this.logRepository = logRepository;    &#125;    // ...&#125;\r\n\r\n在构建 Bean 时，@Autowired 依赖应该可用。否则，如果\r\nSpring 无法解析用于装配的 Bean，它就会阻止 Spring 容器成功启动，并抛出\r\nNoSuchBeanDefinitionException 异常\r\n@Resource\r\n@Resource 是 Java EE（现 Jakarta\r\nEE）标准中的依赖注入注解（JSR-250 规范），从 Java 6\r\n开始引入。它的主要作用是将一个资源（Resource）注入到目标对象中，用于描述依赖注入（Dependency\r\nInjection, DI）需求，支持\r\n按名称（byName）和按类型（byType）两种注入方式，属于 Java\r\n标准注解，不依赖于 Spring 框架。\r\n它的设计初衷是让 Java 应用能够以统一的方式声明对外部资源（如\r\nBean、JNDI 资源、数据源、EJB、Web\r\n服务等）的依赖，而不依赖于具体的实现框架（如 Spring、EJB 容器等）。\r\n@Resource用法与@Autowired用法\r\n用法相似，也是做依赖注入的，从容器中自动获取bean。\r\n@Resource\r\n注解有两个核心参数：\r\n\r\nname：指定要注入的 Bean 名称（byName 方式）\r\n@Resource(name = &quot;orderRepository&quot;)private OrderRepository orderRepo;\r\ntype：指定要注入的 Bean 类型（byType 方式）\r\n@Resource(type =  CommentService.class)private CommentService commentService;\r\n对于泛型 Bean，需指定具体的泛型参数化类型：\r\n@Servicepublic class UserCommentService implements CommentService&lt;UserComment&gt; &#123; ... &#125;@Servicepublic class ProductCommentService implements CommentService&lt;ProductComment&gt; &#123; ... &#125;@Servicepublic class CommentConsumer &#123;    @Resource(type = UserCommentService.class) // 指定具体实现类    private CommentService&lt;UserComment&gt; userCommentService;&#125;\r\n\r\n注意:\r\n\r\n当type 和 name\r\n不能同时用于精确匹配，否则会优先按 name 查找\r\n\r\n@Resource(name = &quot;commentService&quot;, type = AuditCommentServiceImpl.class) // 可能导致冲突private CommentService commentService;\r\n\r\n若容器中存在多个相同类型的 Bean，会抛出\r\nNoUniqueBeanDefinitionException。\r\n此时应改用 @Qualifier 或 name 参数明确指定\r\nBean 名称。\r\n当不指定任何参数时，默认采用byName方式，且名称为字段名或方法参数名。若字段类型本身已唯一（如具体实现类），无需额外指定\r\ntype\r\n@Resource 不支持\r\nrequired=false，不能注入可选依赖。\r\n\r\n所以说@Resource是基于名称（byName）注入\r\nBean，若名称不存在则尝试按类型注入。是J2EE的JSR-250规范的注解。\r\n注入原理与优先级\r\n\r\n优先按 name 匹配：如果 name 属性有值，则直接按 name 查找\r\nBean。\r\nname 为空时，按字段名/方法名查找：如果 name\r\n没有指定，则用字段名或 setter 方法名作为 Bean 名称查找。\r\nname 匹配不到时，按 type 匹配：如果按 name 没找到，再按 type\r\n匹配（但 type 匹配如果有多个同类型 Bean，会报错）。\r\n都找不到则报错：@Resource\r\n默认是必须注入的，找不到会抛出异常。\r\n\r\n@Resource注解的工作流程如下：\r\n\r\n在启动spring的时候，首先要启动容器；\r\n启动spring容器时，会默认寻找容器扫描范围内的可加载bean，然后查找哪些bean上的属性和方法上有@Resource注解；\r\n找到@Resource注解后，判断@Resource注解括号中的\r\nname 属性是否为空，如果为空：看spring容器中的bean的 id\r\n与@Resource\r\n要注解的那个变量属性名是否相同，如相同，匹配成功；如果不相同，看 spring\r\n容器中 bean 的 id\r\n对应的类型是否与@Resource要注解的那个变量属性对应的类型是否相等，若相等，匹配成功，若不相等，匹配失败。\r\n如果@Resource注解括号中的name属性不为空，看name的属性值和容器中的bean的id名是否相等，如相等，则匹配成功；如不相等，则匹配失败。\r\n\r\n\r\n小知识：JSR 是 Java Specification Requests 的缩写，意思是“Java\r\n规范提案”。任何人都可以提交 JSR 给 Java 官方，但只有最终确定的\r\nJSR，才会以 JSR-XXX 的格式发布，如 JSR-250，而被发布的 JSR 就可以看作是\r\nJava 语言的规范或标准。\r\n\r\n@Resource 的三种使用场景\r\n\r\n字段注入\r\n@Servicepublic class UserService &#123;    @Resource // 默认按字段名 &quot;userRepository&quot; 查找Bean    private UserRepository userRepository;        @Resource(name = &quot;orderRepository&quot;) // 显式指定Bean名称    private OrderRepository orderRepo;&#125;\r\nSetter注入\r\n@Servicepublic class LogService &#123;    private LogRepository logRepository;        @Resource // 默认按方法参数名 &quot;logRepository&quot; 查找Bean    public void setLogRepository(LogRepository logRepository) &#123;        this.logRepository = logRepository;    &#125;&#125;\r\n构造方法注入（较少使用）\r\n@Servicepublic class ProductService &#123;    private final ProductRepository productRepository;        @Resource // 按参数名 &quot;productRepository&quot; 查找Bean    public ProductService(ProductRepository productRepository) &#123;        this.productRepository = productRepository;    &#125;&#125;\r\n\r\n一般情况下，在同时使用 Spring 和 Java EE 标准的项目中，优先使用\r\n@Resource 保持兼容性，避免与 @Autowired\r\n混用，要注意由于 @Resource\r\n不支持required=false，对于可选依赖可使用\r\n@Autowired\r\n@Resourceprivate EntityManager entityManager; // JPA标准资源注入\r\n@Inject\r\n@Inject 是 Java EE（现 Jakarta\r\nEE）标准中的依赖注入注解（JSR-330 规范），从 Java 6 开始引入。它是 Java\r\n官方提供的依赖注入标准，旨在提供一种与具体框架无关的注入机制，使代码具有更好的可移植性。\r\n所以，当项目需要同时兼容 Spring、CDI（Java\r\nEE）等多个依赖注入框架时，项目中有跨框架的情况下，优先使用\r\n@Inject保持可移植性\r\n基于类型的注入：@Inject\r\n默认通过类型（byType）查找并注入依赖，与 Spring 的\r\n@Autowired 类似。而且@Inject\r\n默认要求依赖必须存在，相当于\r\n@Autowired (required = true)。若需要可选依赖，需配合其他机制（如\r\nOptional）。\r\n@Inject\r\n本身只支持按类型注入，当存在多个同类型 Bean 时，需配合 @Named 注解（JSR-330\r\n规范）指定名称：\r\n\r\n使用 @Named 标记\r\nBean 名称\r\n@Service@Named(&quot;alipayService&quot;) // 等同于Spring的@Service(&quot;alipayService&quot;)public class AlipayServiceImpl implements PaymentService &#123; ... &#125;@Service@Named(&quot;wechatPayService&quot;)public class WechatPayServiceImpl implements PaymentService &#123; ... &#125;\r\n然后使用 @Named\r\n指定注入的 Bean\r\n@Servicepublic class OrderService &#123;    @Inject    @Named(&quot;alipayService&quot;) // 等同于@Autowired + @Qualifier(&quot;alipayService&quot;)    private PaymentService paymentService;&#125;\r\n\r\n@Inject\r\n的三种使用场景:\r\n\r\n构造方法注入\r\n在构造方法上使用 @Inject\r\n时，其参数在运行时由配置好的IoC容器提供，规范中规定向构造方法注入的参数数量是0个或多个，所以在不含参数的构造方法上使用\r\n@Inject\r\n注解也是合法的。\r\n@Servicepublic class UserService &#123;    private final UserRepository userRepository;        @Inject // Spring 4.3+ 后可省略 @Inject    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;&#125;\r\n字段注入\r\n@Servicepublic class OrderService &#123;    @Inject    private OrderRepository orderRepository;&#125;\r\n方法注入\r\n@Servicepublic class LogService &#123;    private LogRepository logRepository;        @Inject    public void setLogRepository(LogRepository logRepository) &#123;        this.logRepository = logRepository;    &#125;&#125;\r\n\r\n@ConfigurationProperties\r\n那么他们之间的区别是什么\r\n在Spring中依赖注入可以使用@Autowired、@Resource和@Inject来完成，并且在一般的使用中是可以相互替换的（注意是一般），不过三者还是有区别\r\n@Autowired注解：\r\n\r\n是Spring本身替换的注解（org.springframework.beans.factory.annotation.Autowired），需要导入Spring相应的jar包才能使用\r\n可以标注的位置：构造器、方法、方法参数、变量域和注解上面\r\n在Spring容器解析@Autowired注解时，使用的后置处理器为AutowiredAnnotationBeanPostProcessor，在这个后置处理的注释中有这么一段：\r\n&#123;@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor&#125;* implementation that autowires annotated fields, setter methods, and arbitrary* config methods. Such members to be injected are detected through annotations:* by default, Spring&#x27;s &#123;@link Autowired @Autowired&#125; and &#123;@link Value @Value&#125;* annotations.** &lt;p&gt;Also supports JSR-330&#x27;s &#123;@link javax.inject.Inject @Inject&#125; annotation,* if available, as a direct alternative to Spring&#x27;s own &#123;@code @Autowired&#125;.\r\n大约意思就是，AutowiredAnnotationBeanPostProcessor\r\n是一个 BeanPostProcessor\r\n实现，其主要职责是：\r\n\r\n自动装配（注入）被注解标记的\r\n字段（fields）、Setter 方法 和\r\n任意配置方法。\r\n这些需要被注入的成员（members）通过注解来识别，默认支持：\r\n\r\nSpring 原生的 @Autowired 和 @Value\r\n注解。\r\nJSR-330 标准的 @Inject\r\n注解（如果项目中存在该依赖）。如果项目中引入了 JSR-330（Jakarta\r\nInject） 的依赖（如\r\njavax.inject:javax.inject:1），该处理器也会支持\r\n@Inject 注解，其功能与\r\n@Autowired 基本相同\r\n\r\n在 Bean 实例化后、初始化前，该处理器会扫描 Bean\r\n的字段、方法，识别带有 @Autowired、@Inject 或\r\n@Value 的成员。然后从 Spring 容器中查找匹配的 Bean\r\n并完成注入。\r\n\r\n@Autowired注解有一个required属性，当指定required属性为false时，意味着在容器中找相应类型的bean，如果找不到则忽略，而不报错（这一条是两个注解所没有的功能）。\r\n默认优先按照类型去容器中找对应的组件，找到就赋值，如果找到多个相同类型的组件，再将属性的名称作为组件的\r\nid 去容器中查找，如果组件 id\r\n对象的bean不存在，而且required属性为true，就报错。\r\n支持@Primary注解，让Spring进行自动装配的时候，默认使用首选的bean\r\n\r\n@Resource\r\n注解\r\n\r\nJSR250规范提供的注解（javax.annotation.Resource），不需要导入格外的包，这个注解在JDK的rt.jar包中\r\n可以标注的位置：TYPE(表示可以标注在接口、类、枚举)，FIELD(变量域)和METHOD(方法)上面。\r\n在Spring容器解析@Resource注解时，使用的后置处理器为CommonAnnotationBeanPostProcessor，在这个后置处理的注释中有这么一段：\r\n* &#123;@link org.springframework.beans.factory.config.BeanPostProcessor&#125; implementation* that supports common Java annotations out of the box, in particular the JSR-250* annotations in the &#123;@code javax.annotation&#125; package. These common Java* annotations are supported in many Java EE 5 technologies (e.g. JSF 1.2),* as well as in Java 6&#x27;s JAX-WS.** &lt;p&gt;This post-processor includes support for the &#123;@link javax.annotation.PostConstruct&#125;* and &#123;@link javax.annotation.PreDestroy&#125; annotations - as init annotation* and destroy annotation, respectively - through inheriting from* &#123;@link InitDestroyAnnotationBeanPostProcessor&#125; with pre-configured annotation types.** &lt;p&gt;The central element is the &#123;@link javax.annotation.Resource&#125; annotation* for annotation-driven injection of named beans, by default from the containing* Spring BeanFactory, with only &#123;@code mappedName&#125; references resolved in JNDI.* The &#123;@link #setAlwaysUseJndiLookup &quot;alwaysUseJndiLookup&quot; flag&#125; enforces JNDI lookups* equivalent to standard Java EE 5 resource injection for &#123;@code name&#125; references* and default names as well. The target beans can be simple POJOs, with no special* requirements other than the type having to match.\r\n大约意思就是CommonAnnotationBeanPostProcessor 是一个\r\nBeanPostProcessor 实现，其主要职责是：\r\n\r\n支持 Java 标准注解（无需额外配置），特别是 JSR-250\r\n规范中的 javax.annotation 包注解。\r\n这些注解广泛应用于 Java EE 5 技术（如 JSF 1.2）和 Java 6 的 JAX-WS\r\n中。\r\n具体支持注解\r\n\r\n@PostConstruct：标记 Bean\r\n初始化后执行的方法（等价于 Spring 的\r\n@PostConstruct）。\r\n@PreDestroy：标记 Bean\r\n销毁前执行的方法（等价于 Spring 的 @PreDestroy）。\r\n\r\n若同时使用@Resource和@Autowired，Spring\r\n会按以下顺序处理：\r\n\r\n@Resource（由\r\nCommonAnnotationBeanPostProcessor 处理）\r\n@Autowired（由\r\nAutowiredAnnotationBeanPostProcessor 处理）\r\n\r\n\r\nCommonAnnotationBeanPostProcessor 是 Spring 框架中支持\r\nJava 标准注解 的核心组件，它通过 @Resource\r\n实现按名称注入，并提供对 @PostConstruct 和\r\n@PreDestroy 的支持，使 Spring 应用能够无缝集成 Java EE\r\n标准注解，提高代码的可移植性和兼容性。\r\n默认是按照组件名称进行装配的，@Autowired是根据类型，@Resource是根据组件名称\r\n支持@Primary注解，不过首先按照会按照名称进行注入bean，先不执行@Primary注解标注的优先的依赖注入，如果Spring\r\nIOC容器中没有该Bean，此时再按照@Primary注解标注的bean进行装配\r\n\r\n@Inject 注解\r\n\r\nJSR330规范提供的注解（javax.inject.Inject），主要导入javax.inject包才能使用\r\n可以标注的位置：方法、构造器和变量域中\r\n在Spring容器解析@Inject注解时，使用的后置处理器和@Autowired是一样的，都是AutowiredAnnotationBeanPostProcessor。\r\n由于@Inject注解没有属性，在加载所需bean失败时，会报错\r\n除了上面的不同点之后，@Inject和@Autowired完全等价。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\n@Resource\r\n(JSR-250)\r\n@Inject\r\n(JSR-330)\r\n@Autowired\r\n(Spring)\r\n\r\n\r\n\r\n\r\n所属规范\r\nJava 标准（Jakarta EE, JSR-250）\r\nJava 标准（Jakarta EE, JSR-330）\r\nSpring 框架原生注解\r\n\r\n\r\n默认查找方式\r\n按名称（byName），字段名或方法参数名\r\n按类型（byType）\r\n按类型（byType）\r\n\r\n\r\n支持参数\r\nname, type, mappedName\r\n- (配合 @Named\r\n使用)\r\nrequired, value（Spring 4.3+ 支持）\r\n\r\n\r\n多 Bean 处理\r\n显式指定 name 或 type\r\n配合 @Named\r\n或自定义限定符\r\n配合 @Qualifier\r\n或 @Primary\r\n\r\n\r\n依赖强制性\r\n必须存在（无 required 参数）\r\n必须存在（无等效 required=false）\r\n支持 required=false（允许 null）\r\n\r\n\r\n可选依赖支持\r\n不支持，需结合 @Autowired (required=false)\r\n需配合 Optional&lt;&gt;, Provider或 @Nullable\r\n直接通过 required=false 支持\r\n\r\n\r\n注入方式支持\r\n字段、Setter 方法、构造方法（较少用）\r\n字段、Setter 方法、构造方法\r\n字段、Setter 方法、构造方法、任意方法\r\n\r\n\r\n优先级处理\r\nname 参数 &gt; type 参数 &gt; 字段名\r\n@Named 指定名称\r\n&gt; 类型匹配\r\n@Qualifier &gt;\r\n@Primary &gt;\r\n类型匹配\r\n\r\n\r\n容器查找顺序\r\n1. 按 name 查找 2. 按 type 查找\r\n1. 按类型查找 2. 按 @Named 名称查找\r\n1. 按类型查找 2. 按 @Qualifier 名称查找 3. 按 @Primary\r\n\r\n\r\n与其他注解配合\r\n@PostConstruct, @PreDestroy\r\n@Named, @Scope\r\n@Qualifier,\r\n@Primary, @Lazy\r\n\r\n\r\n常见场景\r\nJava EE 兼容项目、JNDI 资源注入\r\n跨框架项目、Java 标准依赖注入\r\nSpring 项目的首选注入方式\r\n\r\n\r\n历史兼容性\r\nJava 6+\r\nJava 6+\r\nSpring 2.5+\r\n\r\n\r\n框架集成性\r\n支持 JSF、EJB 等 Java EE 技术\r\n支持 CDI、Spring 等依赖注入框架\r\n纯 Spring 生态系统\r\n\r\n\r\n依赖包需求\r\n无需额外依赖（Java EE 环境内置）\r\n需要 javax.inject 包（Java 9 + 为 jakarta.inject）\r\n内置在 Spring 框架中\r\n\r\n\r\n循环依赖处理\r\n与 @Autowired\r\n类似，构造器注入可能触发循环依赖\r\n与 @Autowired\r\n类似，需通过 @Lazy\r\n等方式解决\r\n支持通过三级缓存解决部分循环依赖\r\n\r\n\r\nJNDI 支持\r\n原生支持，通过 mappedName 参数\r\n不直接支持，需手动配置\r\n不直接支持，需通过 JNDI 服务实现\r\n\r\n\r\n标准化程度\r\nJava 官方标准，跨容器移植性高\r\nJava 官方标准，适合标准化开发\r\nSpring 特定实现，与框架深度耦合\r\n\r\n\r\n错误处理机制\r\n注入失败时抛出 NoSuchBeanDefinitionException\r\n注入失败时抛出异常，需手动处理\r\n提供更详细的异常类型（如 NoUniqueBeanDefinitionException）\r\n\r\n\r\n最佳实践建议\r\n1. 明确指定 name 参数 2. 处理 JNDI 资源\r\n1. 配合 @Named 使用\r\n2. 使用 Provider 处理可选依赖\r\n1. 构造器注入优先 2. 配合 @Qualifier 处理多实现\r\n\r\n\r\n\r\n总结：\r\n核心差异解析\r\n\r\n查找方式本质区别：\r\n\r\n@Resource 以名称为核心，适合明确知道 Bean\r\n名称的场景\r\n@Inject 和 @Autowired\r\n以类型为核心，适合面向接口编程\r\n\r\n依赖强制性处理：\r\n\r\nSpring\r\n的@Autowired提供更灵活的依赖控制，可通过required=false实现可选依赖\r\nJava\r\n标准注解需通过额外机制（如Provider）处理可选依赖\r\n\r\n多实现场景处理：\r\n\r\n@Resource通过name/type参数直接指定\r\n@Inject配合@Named实现名称匹配\r\n@Autowired通过@Qualifier或@Primary解决歧义\r\n\r\n\r\n适用场景建议\r\n\r\nJava EE\r\n兼容项目：优先使用@Resource和@Inject，确保跨容器移植性\r\n纯 Spring\r\n项目：推荐使用@Autowired，充分利用 Spring\r\n特性（如required参数、@Primary）\r\n跨框架开发：使用@Inject+@Named，保证代码在\r\nSpring、CDI 等不同容器中的兼容性\r\n\r\n高级特性对比\r\n\r\n@Resource的mappedName参数提供 JNDI\r\n资源注入能力，适合企业级 Java EE 环境\r\n@Inject配合Provider实现延迟依赖获取，是处理可选依赖的标准方式\r\n@Autowired的@Primary机制提供更简洁的默认实现选择方式\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性分类\r\nCommonAnnotationBeanPostProcessor\r\nAutowiredAnnotationBeanPostProcessor\r\n\r\n\r\n\r\n\r\n核心职责\r\n处理 Java 标准注解（JSR-250），如 @Resource、生命周期注解\r\n处理 Spring 原生注解及 JSR-330 注解，如 @Autowired、@Inject\r\n\r\n\r\n支持的注解\r\n@Resource, @PostConstruct, @PreDestroy, @Resource, @WebServiceRef\r\n@Autowired,\r\n@Inject, @Value, @Lookup\r\n\r\n\r\n注入方式\r\n按名称（byName）优先，字段名 / 参数名作为默认名称\r\n按类型（byType）优先，类型匹配后通过 @Qualifier 细化名称\r\n\r\n\r\n注入目标\r\n字段、Setter 方法、构造方法（需显式标记）\r\n字段、Setter 方法、构造方法、任意方法（@Autowired 标记）\r\n\r\n\r\nJNDI 支持\r\n原生支持，通过 mappedName 参数指定 JNDI 名称，支持\r\nalwaysUseJndiLookup 配置\r\n不直接支持 JNDI 注入，需通过 JndiTemplate 等工具类手动实现\r\n\r\n\r\n生命周期注解处理\r\n处理 @PostConstruct（初始化）和 @PreDestroy（销毁）注解\r\n需通过 InitDestroyAnnotationBeanPostProcessor 单独处理\r\n\r\n\r\nJava EE 兼容性\r\n高（完全遵循 JSR-250 规范，支持 Java EE 容器如 GlassFish）\r\n低（Spring 专有注解，需框架适配才能在 Java EE 中使用）\r\n\r\n\r\n多 Bean 处理机制\r\n注入时若存在多个同类型 Bean，必须通过 name/type 参数明确指定\r\n优先通过 @Qualifier 指定名称，或通过 @Primary 标记默认实现\r\n\r\n\r\n依赖强制性\r\n注入失败时直接抛出异常，无 required 参数\r\n支持 @Autowired\r\n(required=false) 实现可选依赖\r\n\r\n\r\n处理阶段\r\nBean 初始化阶段（postProcessAfterInitialization）\r\nBean 实例化后、初始化前（postProcessProperties）\r\n\r\n\r\n循环依赖处理\r\n与 @Resource\r\n配合时，构造器注入可能触发循环依赖问题\r\n支持通过三级缓存解决部分循环依赖场景（字段注入 / Setter 注入）\r\n\r\n\r\n配置参数\r\nalwaysUseJndiLookup（强制 JNDI 查找）、jndiEnvironment 等\r\nrequired（依赖强制性）、annotationType（自定义注解类型）\r\n\r\n\r\n框架集成性\r\n可与 JSF、EJB 等 Java EE 组件无缝集成\r\n深度集成 Spring 生态，支持 AOP、事务等特性\r\n\r\n\r\n依赖包需求\r\n无需额外依赖（Java EE 环境内置 javax.annotation 包）\r\n内置在 Spring 框架中，JSR-330 支持需引入 javax.inject 包\r\n\r\n\r\n注解优先级\r\n@Resource 的\r\nname 参数 &gt; type 参数 &gt; 字段名\r\n@Qualifier &gt;\r\n@Primary &gt;\r\n类型匹配\r\n\r\n\r\n适用场景\r\n1. Java EE 标准项目 2. 需要 JNDI 资源注入 3. 跨容器移植场景\r\n1. 纯 Spring 项目 2. 面向接口编程 3. 复杂依赖关系管理\r\n\r\n\r\n最佳实践\r\n1. 明确指定 @Resource 的 name 参数 2. 配合 Java EE\r\n规范使用\r\n1. 构造器注入优先 2. 用 @Qualifier 处理多实现 3. @Value 注入配置\r\n\r\n\r\n与其他处理器关系\r\n可与 AutowiredAnnotationBeanPostProcessor 共存，处理不同注解\r\n需要配合 CommonAnnotationBeanPostProcessor 实现完整功能\r\n\r\n\r\n错误处理机制\r\n注入失败时抛出 NoSuchBeanDefinitionException 等标准异常\r\n提供更细化的异常类型（如 NoUniqueBeanDefinitionException）\r\n\r\n\r\nSpring Boot 自动配置\r\nSpring Boot 自动配置中默认启用，支持 @Resource 注解\r\nSpring Boot 默认启用，是依赖注入的核心处理器\r\n\r\n\r\n\r\n职责与注解支持的本质区别\r\n\r\nCommonAnnotationBeanPostProcessor 以Java\r\n标准注解为核心，目标是兼容 Java EE\r\n规范，适合需要跨容器移植的项目\r\nCommonAnnotationBeanPostProcessor\r\n直接支持@PostConstruct和@PreDestroy，无需额外配置\r\nAutowiredAnnotationBeanPostProcessor 以Spring\r\n特性为核心，提供更灵活的依赖注入控制，适合深度使用 Spring\r\n框架的项目\r\nAutowiredAnnotationBeanPostProcessor\r\n不直接处理生命周期注解，需配合InitDestroyAnnotationBeanPostProcessor使用\r\n\r\n注入逻辑的核心差异\r\ngraph TD\n    %% @Resource 注入流程\n    A[CommonAnnotationBeanPostProcessor] --&gt;|注入流程| B[按name查找Bean]\n    B --&gt; C&#123;name存在?&#125;\n    C -- 是 --&gt; D[注入对应Bean]\n    C -- 否 --&gt; E[按type查找Bean]\n    E --&gt; F&#123;唯一type?&#125;\n    F -- 是 --&gt; D\n    F -- 否 --&gt; G[抛出异常]\n\n    %% @Autowired 注入流程\n    X[AutowiredAnnotationBeanPostProcessor] --&gt;|注入流程| Y[按type查找Bean]\n    Y --&gt; Z&#123;唯一type?&#125;\n    Z -- 是 --&gt; D\n    Z -- 否 --&gt; W[按Qualifier或Primary筛选]\n    W --&gt; H&#123;有唯一Bean?&#125;\n    H -- 是 --&gt; D[注入对应Bean]\n    H -- 否 --&gt; G[抛出异常]\r\n最后我们来看看这些注解的源码\r\n@Autowired\r\npackage org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** *支持多种注入点，分别是构造方法注入，字段注入，方法注入（包括 Setter 方法），参数注入（如配置方法的参数），支持自定义注解组合 */@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)// 注解信息在运行时保留，允许反射获取@Retention(RetentionPolicy.RUNTIME)// 注解信息会被包含在 JavaDoc 中@Documentedpublic @interface Autowired &#123;    /**     * 指示该依赖是否为必需项。     * 默认为true，表示容器必须能解析该依赖。此时容器必须找到匹配的 Bean，否则抛出 NoSuchBeanDefinitionException     * 如果设置为false，当容器中不存在匹配的Bean时，将注入null值（对于对象类型）。集合类型可以为空集合     *      * 对于集合或数组类型的依赖，即使required为true，     * 只要容器中存在至少一个匹配类型的Bean，就不会抛出异常。     * 若容器中没有匹配的Bean，则会根据required的值决定是否抛出异常。     */    boolean required() default true;&#125;\r\n@Resource\r\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package jakarta.annotation;  // Java EE 8+ 及 Jakarta EE 版本包路径// Java EE 7 及以下版本使用 javax.annotation 包import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;// 可用于类、接口或枚举，声明类级资源，允许字段注入，方法注入（通常是 Setter 方法）@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)// 注解信息在运行时保留，允许反射获取@Retention(RetentionPolicy.RUNTIME)// 支持在同一元素上重复使用 @Resource 注解（Java 8+ 特性）@Repeatable(Resources.class)public @interface Resource &#123;    /**     * 指定要注入的资源名称。     * 若指定此值，容器将按名称查找资源（byName）。     * 示例：     *   @Resource(name = &quot;userService&quot;)     *        * 若未指定此值：     *   - 对于字段注入，默认为字段名     *   - 对于方法注入，默认为方法名（去除 set 前缀并小写首字母）     */    String name() default &quot;&quot;;       /**     * 指定 JNDI 查找名称，用于直接从 JNDI 目录中获取资源。     * 此属性优先级高于 name，若指定则直接进行 JNDI 查找。     * 示例：     *   @Resource(lookup = &quot;java:comp/env/jdbc/myDataSource&quot;)     */    String name() default &quot;&quot;;    /**     * 指定要注入的资源类型。     * 当按名称查找失败时，容器将按此类型查找资源（byType）。     * 默认值为 Object.class，表示使用字段或方法的声明类型。     */    Class&lt;?&gt; type() default Object.class;        /**     * 指定资源的认证类型，仅适用于连接工厂类资源（如 DataSource）。     * 可选值：     *   - CONTAINER：容器管理认证（默认）     *   - APPLICATION：应用程序管理认证     */    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;        /**     * 指定资源是否可共享。     * 仅适用于支持共享的资源类型，如 JMS 连接工厂。     * 默认值为 true，表示资源可被多个组件共享。     */    boolean shareable() default true;        /**     * 指定资源的映射名称，用于与外部命名环境（如 CORBA）集成。     * 此属性通常由应用服务器使用，用于将资源映射到外部 JNDI 名称。     */    String mappedName() default &quot;&quot;;        /**     * 资源的描述信息，用于文档目的。     * 此信息通常存储在应用服务器的管理控制台中。     */    String description() default &quot;&quot;;        /**     * 定义资源认证类型的枚举。     */    public static enum AuthenticationType &#123;        CONTAINER,  // 容器管理认证（推荐）        APPLICATION // 应用程序管理认证    &#125;&#125;\r\n@Inject\r\npackage jakarta.inject; // Java EE 8+ 及 Jakarta EE 版本包路径// Java EE 7 及以下版本使用 javax.inject 包import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;// 支持支持方法注入（包括传统的 Setter 方法），支持构造方法注入，支持字段注入@Target(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.FIELD&#125;)// 注解信息在运行时保留，允许反射获取，确保容器能够在运行时处理注入逻辑@Retention(RetentionPolicy.RUNTIME)// 注解信息会被包含在 JavaDoc 中，提高代码可读性@Documentedpublic @interface Inject &#123;    // 无参数，依赖注入行为由规范定义&#125;\r\n","categories":["Java相关","框架相关小知识","Spring相关"],"tags":["JavaWeb","框架知识","常用知识","学习","JavaEE","Web","Spring系列","Spring Boot","Java框架","源码分析"]},{"title":"蓝桥杯2025Python省赛B组题解","url":"/posts/5125.html","content":"A. 攻击次数\r\n\r\n\r\nimage-20250420152350082\r\n\r\n\r\n\r\nimage-20250420152350082\r\n\r\n这题有歧义，如果考虑三个英雄一起上，就是103，考虑一回合只能上一个伤害高的，就是181\r\n// 一起上的情况public class Main &#123;    public static void main(String[] args) &#123;        // 能一起上就一起上，不能一起上，就上攻击力高的        int hp = 2025;        int cnt = 0;        while(hp &gt; 0)&#123;            cnt++;            int hero1 = 5;   // 英雄 1 的固定伤害            int hero2 = (cnt % 2 == 1) ? 15 : 2;   // 英雄 2 的回合机制伤害            int hero3 = 0;            if(cnt % 3 == 1)&#123;                hero3 = 2;            &#125;else if(cnt % 3 == 2)&#123;                hero3 = 10;            &#125;else if(cnt % 3 == 0)&#123;                hero3 = 7;            &#125;            hp -= hero1 + hero2 + hero3;        &#125;        System.out.println(cnt);    &#125;&#125;\r\n# 不一起上的情况# 挑攻击力大的技能使用即可# 可见：奇数一定使用第二个英雄的技能，然后偶数情况的话模3余1用第一个英雄技能，其他情况用第三个英雄的技能。n = 0i = 1while n &lt; 2025:    if i &amp; 1:        n += 15    else:        if i % 3 == 2:            n += 10        elif i % 3 == 0:            n += 7        else:            n += 5    i += 1print(i - 1)\r\n\r\nB. 最长字符串\r\n\r\n\r\nimage-20250420152634843\r\n\r\n\r\n\r\nimage-20250420152634843\r\n\r\n下载附件 words.txt\r\n优美字符串的定义是：字符串本身存在于给定的单词列表中，并且可以通过调整顺序后由另一个更短的优美字符串扩展而来。\r\n考的主要是文件读写，默认把 txt 附件存在和代码同级别的目录下\r\npackage 基础算法和其他.IO读写流.P12171_蓝桥杯_2025_省_Python_B_最长字符串;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        //  读取 words.txt 文件中的单词        List&lt;String&gt; words = new ArrayList&lt;&gt;();        try(BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\\\WorkSpace\\\\JavaDemo\\\\IDEA\\\\Algorithm\\\\src\\\\字符串\\\\subject\\\\P12171_蓝桥杯2025省PythonB最长字符串\\\\words.txt&quot;)))&#123;            String line;            while ((line = br.readLine()) != null) &#123;                words.add(line.trim());            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;        // 按长度升序、字典序升序排序（确保处理顺序正确）        words.sort(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()));        Set&lt;String&gt; bs = new HashSet&lt;&gt;();        // 动态规划：判断每个单词是否是优美字符串        for(String word : words)&#123;            if(word.length() == 1)&#123;                bs.add(word);            &#125;else&#123;                // 如果 前n-1 位的长度的字符串，我们把其和要对比的字符串按一定规律重组，那么两者就是一样的了                String pre = sortString(word.substring(0, word.length() - 1));                for(String sbs: bs)&#123;                    if(sortString(sbs).equals(pre))&#123;                        bs.add(word);                        break;                    &#125;                &#125;            &#125;        &#125;        // 找到最长的优美字符串        int maxLength = 0;        for (String word : bs) &#123;            maxLength = Math.max(maxLength, word.length());        &#125;        List&lt;String&gt; ls = new ArrayList&lt;&gt;();        for (String word : bs) &#123;            if (word.length() == maxLength) &#123;                ls.add(word);            &#125;        &#125;        // 输出字典序最小的结果        ls.sort(Comparator.naturalOrder());        System.out.println(ls.get(0));        // System.out.println(&quot;afplcu&quot;);    &#125;    // 字符串按字母字典序重组    private static String sortString(String s) &#123;        char[] charArray = s.toCharArray();        Arrays.sort(charArray);        return new String(charArray);    &#125;&#125;\r\n# 读取 words.txt 文件中的单词with open(&quot;words.txt&quot;, &quot;r&quot;) as f:    ws = [line.strip() for line in f]# 按长度和字典序排序ws.sort(key=lambda x: (len(x), x))# 初始化优美字符串集合bs = set()# 动态规划：判断每个单词是否是优美字符串for w in ws:    if len(w) == 1:        bs.add(w)    else:        pre = &#x27;&#x27;.join(sorted(w[:-1]))        if any(&#x27;&#x27;.join(sorted(s)) == pre for s in bs):            bs.add(w)# 找到最长的优美字符串ml = max(len(w) for w in bs)lbs = [w for w in bs if len(w) == ml]# 输出字典序最小的结果print(min(lbs))\r\n\r\nC. LQ图形\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n观察可发现，可以将L分为上下两个部分，上面列数少的为h行，下面列数多的为w行，上下宽度分别为w和v+w。时间复杂度O(h\r\n+ w)\r\n//package 基础算法和其他.模拟.P12172_蓝桥杯2025省PythonB_LQ图形;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int w = sc.nextInt();        int h = sc.nextInt();        int v = sc.nextInt();        // 先是h高w宽的Q，然后是w高v+w宽        StringBuilder sb1 = new StringBuilder();        StringBuilder sb2 = new StringBuilder();        for(int i = 1; i &lt;= w; i++) sb1.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= v + w; i++) sb2.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= h; i++) System.out.println(sb1);        for(int i = 1; i &lt;= w; i++) System.out.println(sb2);    &#125;&#125;\r\nw,h,v = MII()t = hb = wfor i in range(t):    print(&#x27;Q&#x27; * w)for i in range(b):    print(&#x27;Q&#x27; * (v + w))\r\n\r\nD. 最多次数\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n贪心，遇到连续的三个某个顺序的 l,q,b, 就把他拿掉。时间复杂度O(n)\r\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // lqb lbq qbl qlb blq bql 可以发现题目给出的是全排列        // 遇到连续的 lqb 三个字母拿掉就行        Scanner sc = new Scanner(System.in);        String str = sc.nextLine();        String[] strs = &#123;&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;&#125;;        int res = 0, index = 0;        for(int i = 0; i &lt; str.length() - 2; i++)&#123;   // 注意防止越界            String sub = str.substring(i, i + 3);            for(int j = 0; j &lt; 6; j++)&#123;                if(sub.equals(strs[j]))&#123;                    i += 2;   // 不判断中间的内容了                    res++;                    break;                &#125;            &#125;        &#125;        System.out.println(res);        sc.close();    &#125;&#125;\r\nstr_input = input()strs = [&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;]res = 0i = 0while i &lt; len(str_input) - 2:    sub = str_input[i:i + 3]    for j in range(6):        if sub == strs[j]:            i += 2            res += 1            break    i += 1print(res)\r\n\r\nE. A*B Problem\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n给定 n，求四元组 (a,b,c,d) 个数，满足 a×b+c×d≤n，且 a,b,c,d\r\n都是正整数。\r\n我们需要枚举所有可能的向量 A 和 B，使得它们的内积不超过 L。\r\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int L = scanner.nextInt();        int count = 0;        // 枚举所有可能的 (XA, YA) 和 (XB, YB)        for (int XA = 1; XA &lt;= L; XA++) &#123;            for (int YA = 1; YA &lt;= L; YA++) &#123;                for (int XB = 1; XB &lt;= L / XA + 1; XB++) &#123;                    for (int YB = 1; YB &lt;= (L - XA * XB) / YA + 1; YB++) &#123;                        if (XA * XB + YA * YB &lt;= L) &#123;                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(count);    &#125;&#125;\r\n不行，只有80分，考虑优化\r\n将四元组 (a,b,c,d) 的问题转化为两个部分：x=a×b和 y=c×d，使得\r\nx+y≤n。\r\n这样，问题转化为统计所有满足 x+y≤n 的正整数对 (x,y) 的数量，其中 x 和\r\ny 都可以表示为两个正整数的乘积。\r\n这样对于满足 x+y=k 的四元组个数就是 tx×ty。\r\n考虑每个数 i，预处理其能表示为两个正整数乘积的方式数 t[i]（即 i\r\n的因数对数）。把 x 打表打出来\r\n使用线性筛法预处理每个数的因数个数，计算 t[i]。\r\n计算 t[i] 的前缀和数组 s[i]，用于快速查询 y≤n−x 时的 t[y]\r\n的总和。\r\n对于每个 x，其贡献为 t[x]×s[n−x]\r\n为什么求 t[y] 要使用前缀和数组，对于每个固定的\r\nx，我们需要找到所有满足 y≤n−x 的 y 的数量，也就是 ∑y=1n−x​t[y]\r\npackage 数学.subject.P12174_蓝桥杯2025省Python_B_AxBProblem;import java.util.Arrays;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int l = sc.nextInt();        int[] t = new int[l + 1];        Arrays.fill(t, 0);        // 枚举所有可能的 (a,b)组合，并统计每个乘积的出现次数，打表出四元组的前两部分乘积        for (int a = 1; a &lt;= l; a++) &#123;            for(int b = 1; a * b &lt;= l; b++)&#123;                t[a * b]++;            &#125;        &#125;        // 前缀和        int[] s = new int[l + 1];        s[0] = 0;        for (int i = 1; i &lt;= l; i++) &#123;            s[i] = s[i - 1] + t[i];        &#125;        long total = 0;        // 对于每个 x        for(int x = 1; x &lt; l; x++)&#123;            // 计算其对应的 y 的最大值 l - x            int y = l - x;            total += (long)t[x] * s[y];   // 前缀和计算        &#125;        System.out.println(total);    &#125;&#125;\r\n\r\nF. 园艺\r\n讲过了，在\r\n\r\nG. 书架还原\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\npackage 基础算法和其他.贪心.subject.P12176_蓝桥杯2025省PythonB_书架还原;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n + 1];   // 书架        int[] p = new int[n + 1];   // p[x]表示书本编号现在所处的位置        int res = 0;        for(int i = 1; i &lt;= n; i++)&#123;            a[i] = sc.nextInt();            p[a[i]] = i;    // 桶记录书本a[i]的正确位置，p[a[i]] 是书本应该去的位置        &#125;        // 从第一个位置开始检查，如果当前数字不在正确位置，就找到它应该去的位置，把这两个位置的数字交换。        for(int i = 1; i &lt;= n; i++)&#123;            if(a[i] != i)&#123;   // 不在正确位置，需要调整位置                p[a[i]] = p[i];   // 把书本放到应该去的位置                ++res;                // 把正确位置p[i]上的书本和当前书本位置交换                int temp = a[p[i]];                a[p[i]] = a[i];                a[i] = temp;            &#125;        &#125;        System.out.println(res);    &#125;&#125;\r\nn = II()a = [0] + LII()p = [0] * (n + 1)res = 0for i in range(1,n + 1):    p[a[i]] = ifor i in range(1,n + 1):    if a[i] != i:        p[a[i]] = p[i]        a[i],a[p[i]] = a[p[i]],a[i]        res += 1print(res)\r\n\r\nH. 异或和\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n考虑位运算，把每个数拆成二进制然后进行统计\r\n由于异或运算本身就是建立在位的基础上的，所以我们只需要用一层循环枚举位\r\n只有两个数当前位不同才能产生贡献。也就是说，如果这一位是\r\n0，那他得跟这一位为 1 的数异或才能有贡献，所以加上这一位为 1\r\n的数的个数再乘以这一位的权值\r\n如果先不考虑公式后面的 j−i，那么只有用两个变量统计每位 0 和 1\r\n的个数。\r\n现在还得乘上 j−i，这个值是不断变化的，可以发现其中 i 是不变的，j\r\n每次只加1，开两个变量存储每位 0 和 1 的权值\r\nimport java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        BigInteger[] arr = new BigInteger[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            arr[i] = sc.nextBigInteger();        &#125;        BigInteger res = BigInteger.ZERO;        // 只有两个数当前位不同才能产生贡献。        for (int dig = 0; dig &lt;= 20; dig++) &#123;            int[] cnt = &#123;0, 0&#125;;   // 记录当前已处理过的数中，二进制位 k 为 0 或 1 的数的个数。            BigInteger[] sum = &#123;BigInteger.ZERO, BigInteger.ZERO&#125;;   // 下标差的动态和            for (int i = 1; i &lt;= n; i++) &#123;                // 提取arr[i]的二进制中第 dig 位的值                int bit = arr[i].shiftRight(dig).and(BigInteger.ONE).intValue();                // 取出相反位的值，这样的才可以产生贡献                BigInteger multiplier = BigInteger.valueOf(1L &lt;&lt; dig);                res = res.add(sum[bit ^ 1].multiply(multiplier));                cnt[bit]++;                // 每次处理一个数时，所有之前记录的数的下标差会自然增加                sum[0] = sum[0].add(BigInteger.valueOf(cnt[0]));                sum[1] = sum[1].add(BigInteger.valueOf(cnt[1]));            &#125;        &#125;        System.out.println(res);    &#125;&#125;    \r\nn = int(input())  # 输入数组长度a = list(map(int, input().split()))  # 输入数组res = 0  # 最终结果for b in range(31):  # 遍历每一位（0到30位）    m = 1 &lt;&lt; b  # 当前位的掩码，用于提取该位的值    c = [0, 0]  # 用于统计当前位为0和1的数量    s = [0, 0]  # 用于记录当前位为0和1的索引和    cur = 0  # 当前位的贡献值    for i in range(n):  # 遍历数组中的每个元素        bit = (a[i] &gt;&gt; b) &amp; 1  # 提取当前元素在当前位的值（0或1）        cur += c[1 - bit] * i - s[1 - bit]  # 计算当前位的贡献值        c[bit] += 1  # 更新当前位的计数        s[bit] += i  # 更新当前位的索引和    res += cur * m  # 将当前位的贡献值乘以掩码，累加到最终结果print(res)  # 输出最终结果\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯3月月赛F题题解","url":"/posts/46832.html","content":"「蓝桥·算法双周赛」第二十七场蓝桥月赛最后一题题解\r\n(可能是首发？？nm，真比第三题简单吧)\r\n(求你们看看吧我对我的码风很自信)\r\n问题描述\r\n二分枚举时间m，然后剩下的就是根据题意纯模拟\r\n注意备份和等待能不能跨天进行，这是个坑点\r\n细节在注释里有\r\npackage 蓝桥月赛第27场;import java.util.Scanner;public class F &#123;\t\tprivate static int calculateDays(int m, int[] a, int[] b) &#123;\t\t// 如果没有电脑需要备份，返回 0 天    \tif(a.length == 0) return 0;    \t    \t// 如果 M 小于第一台电脑的备份时间    \tif(m &lt; a[0]) return Integer.MAX_VALUE;    \t    \t// 第一天    \tint days = 1;    \t// 备份第一台开始算剩余时间    \tint currentRemaining = m - a[0];    \t// 第一台都备份不上？？        if (currentRemaining &lt; 0) &#123;            return Integer.MAX_VALUE;        &#125;                for (int i = 1; i &lt;= a.length; i++) &#123;        \tint wait = b[i];   // 获取前一台电脑的等待时间        \t        \t// 处理等待时间        \t// 时间足够，直接减去        \tif(currentRemaining &gt;= wait) &#123;        \t\tcurrentRemaining -= wait;        \t// 不够只能过天了，计算剩余的等待时间        \t&#125;else &#123;        \t\t// 把当天能等的给等了        \t\twait -= currentRemaining;        \t\tdays++;        \t\tcurrentRemaining = m;   // 重置剩余时间        \t\t        \t\tint fullDays = wait / m;   // 计算等几天        \t\tdays += fullDays;        \t\twait -= fullDays * m;        \t\t        \t\tif(wait &gt; 0) &#123;        \t\t\t// 减去零头        \t\t\tcurrentRemaining = m - wait;        \t\t&#125;else &#123;        \t\t\tcurrentRemaining = m;  // 重置        \t\t&#125;        \t&#125;        \t        \t        \t// 处理备份时间        \t// 今天够备份        \tif(currentRemaining &gt;= a[i]) &#123;        \t\tcurrentRemaining -= a[i];        \t&#125;else &#123;        \t\t// 今天备份不完，备份不能留到第二天        \t\tdays++;        \t\tcurrentRemaining = m - a[i];        \t\t// 不行，时间太短，备份不完        \t\tif (currentRemaining &lt; 0) &#123;        \t\t\treturn Integer.MAX_VALUE;        \t\t&#125;        \t&#125;        \t        &#125;        return days;    &#125;\t\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\t\t\t// N 台电脑        int n = scanner.nextInt();        // 最多允许的天数T        int t = scanner.nextInt();        // 表示每台电脑的备份时间。        int[] a = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = scanner.nextInt();        &#125;                // 每台电脑备份完成后需要等待的时间。        int[] b = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            b[i] = scanner.nextInt();        &#125;        scanner.close();                // 最长备份时间        int maxA = 0;        for(int ai: a) &#123;        \tif (ai &gt; maxA) &#123;                maxA = ai;            &#125;        &#125;                if (maxA &gt; 3600) &#123;            System.out.println(-1);            return;        &#125;                // 开始二分 枚举m        int left = maxA;        int right = 3600;        int result = -1;                while(left &lt;= right) &#123;        \tint mid = (left + right) / 2;        \tint days = calculateDays(mid, a, b);        \tif (days &lt;= t) &#123;                result = mid;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;                System.out.println(result != -1 ? result : -1);\t&#125;&#125;\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"转载:命令行的艺术","url":"/posts/21323.html","content":"个人觉得很牛逼的文章，转载一下，并且进行了整理和其中clone下来会出现的显示错误，方便我以后看\r\nhttps://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md\r\n\r\n命令行的艺术\r\n\r\n\r\n前言\r\n基础\r\n日常使用\r\n文件及数据处理\r\n系统调试\r\n单行脚本\r\n冷门但有用\r\n仅限 OS X 系统\r\n仅限 Windows 系统\r\n更多资源\r\n免责声明\r\n\r\n\r\n\r\ncowsay.png\r\n\r\n熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在\r\nLinux\r\n上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。\r\n这篇文章是许多作者和译者共同的成果。这里的部分内容 首次出现\r\n于 Quora，但已经迁移到了\r\nGitHub，并由众多高手做出了许多改进。\r\n如果你在本文中发现了错误或者存在可以改善的地方，请贡献你的一份力量。\r\n前言\r\n涵盖范围：\r\n\r\n这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及简洁（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。\r\n本文主要为 Linux 所写，但在仅限 OS X\r\n系统章节和仅限 Windows\r\n系统章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类\r\nUnix 系统或 OS X，甚至 Cygwin 中得到应用。\r\n本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和\r\nBash 脚本当中。\r\n除去“标准的”Unix\r\n命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。\r\n\r\n注意事项：\r\n\r\n为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用\r\nGoogle 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用\r\napt-get，yum，dnf，pacman，\r\npip 或\r\nbrew（以及其它合适的包管理器）来安装依赖的程序。\r\n遇到问题的话，请尝试使用 Explainshell\r\n去获取相关命令、参数、管道等内容的解释。\r\n\r\n基础\r\n\r\n学习 Bash 的基础知识。具体地，在命令行中输入\r\nman bash 并至少全文浏览一遍;\r\n它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash\r\n的功能已经足够强大并且到几乎总是可用的（ 如果你只学习 zsh，fish\r\n或其他的 shell\r\n的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。\r\n熟悉至少一个基于文本的编辑器。通常而言 Vim （vi）\r\n会是你最好的选择，毕竟在终端中编辑文本时 Vim\r\n是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE\r\n或是炫酷的编辑器更好用）。\r\n学会如何使用 man 命令去阅读文档。学会使用\r\napropos 去查找文档。知道有些命令并不对应可执行文件，而是在\r\nBash 内置好的，此时可以使用 help 和 help -d\r\n命令获取帮助信息。你可以用 type 命令\r\n来判断这个命令到底是可执行文件、shell 内置命令还是别名。\r\n学会使用 &gt; 和 &lt;\r\n来重定向输出和输入，学会使用 | 来重定向管道。明白\r\n&gt; 会覆盖了输出文件而 &gt;&gt;\r\n是在文件末添加。了解标准输出 stdout 和标准错误 stderr。\r\n学会使用通配符 * （或许再算上 ? 和\r\n[…]） 和引用以及引用中 ' 和\r\n\" 的区别（后文中有一些具体的例子）。\r\n熟悉 Bash\r\n中的任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill\r\n等。\r\n学会使用 ssh 进行远程命令行登录，最好知道如何使用\r\nssh-agent，ssh-add\r\n等命令来实现基础的无密码认证登录。\r\n学会基本的文件管理工具：ls 和 ls -l\r\n（了解 ls -l\r\n中每一列代表的意义），less，head，tail\r\n和 tail -f （甚至 less +F），ln\r\n和 ln -s\r\n（了解硬链接与软链接的区别），chown，chmod，du\r\n（硬盘使用情况概述：du -hs *）。 关于文件系统的管理，学习\r\ndf，mount，fdisk，mkfs，lsblk。知道\r\ninode 是什么（与 ls -i 和 df -i\r\n等命令相关）。\r\n学习基本的网络管理工具：ip 或\r\nifconfig，dig。\r\n学习并使用一种版本控制管理系统，例如 git。\r\n熟悉正则表达式，学会使用\r\ngrep／egrep，它们的参数中\r\n-i，-o，-v，-A，-B\r\n和 -C 这些是很常用并值得认真学习的。\r\n学会使用 apt-get，yum，dnf\r\n或 pacman （具体使用哪个取决于你使用的 Linux\r\n发行版）来查找和安装软件包。并确保你的环境中有 pip\r\n来安装基于 Python 的命令行工具 （接下来提到的部分程序使用\r\npip 来安装会很方便）。\r\n\r\n日常使用\r\n\r\n在 Bash 中，可以通过按 Tab\r\n键实现自动补全参数，使用 ctrl-r\r\n搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下\r\nctrl-r 会向后查找匹配项，按下 Enter\r\n键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。\r\n在 Bash 中，可以按下 ctrl-w\r\n删除你键入的最后一个单词，ctrl-u\r\n可以删除行内光标所在位置之前的内容，alt-b 和\r\nalt-f 可以以单词为单位移动光标，ctrl-a\r\n可以将光标移至行首，ctrl-e\r\n可以将光标移至行尾，ctrl-k\r\n可以删除光标至行尾的所有内容，ctrl-l 可以清屏。键入\r\nman readline 可以查看 Bash 中的默认快捷键。内容有很多，例如\r\nalt-. 循环地移向前一个参数，而 alt-*\r\n可以展开通配符。\r\n你喜欢的话，可以执行 set -o vi 来使用 vi\r\n风格的快捷键，而执行 set -o emacs 可以把它改回来。\r\n为了便于编辑长命令，在设置你的默认编辑器后（例如\r\nexport EDITOR=vim），ctrl-x\r\nctrl-e 会打开一个编辑器来编辑当前输入的命令。在 vi\r\n风格下快捷键则是 escape-v。\r\n键入 history 查看命令行历史记录，再用\r\n!n（n\r\n是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是\r\n!$， 它用于指代上次键入的参数，而 !!\r\n可以指代上次键入的命令了（参考 man 页面中的“HISTORY\r\nEXPANSION”）。不过这些功能，你也可以通过快捷键 ctrl-r\r\n和 alt-. 来实现。\r\ncd 命令可以切换工作路径，输入 cd ~\r\n可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀\r\n~（例如 ~/.bashrc）。在 sh\r\n脚本里则用环境变量 $HOME 指代 home 目录的路径。\r\n回到前一个工作路径：cd -。\r\n如果你输入命令的时候中途改了主意，按下 alt-#\r\n在行首添加 # 把它当做注释再按下回车执行（或者依次按下\r\nctrl-a， #，\r\nenter）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。\r\n使用 xargs （ 或\r\nparallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用\r\nxargs echo 查看一下。此外，使用 -I&#123;&#125;\r\n会很方便。例如：\r\n\r\nfind . -name &#x27;*.py&#x27; | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname\r\n\r\npstree -p 以一种优雅的方式展示进程树。\r\n使用 pgrep 和 pkill\r\n根据名字查找进程或发送信号（-f 参数通常有用）。\r\n了解你可以发往进程的信号的种类。比如，使用\r\nkill -STOP [pid] 停止一个进程。使用\r\nman 7 signal 查看详细列表。\r\n使用 nohup 或 disown\r\n使一个后台进程持续运行。\r\n使用 netstat -lntp 或 ss -plat\r\n检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u\r\n则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n\r\n(这也可以在 OS X 上运行)。\r\nlsof 来查看开启的套接字和文件。\r\n使用 uptime 或 w\r\n来查看系统已经运行多长时间。\r\n使用 alias\r\n来创建常用命令的快捷形式。例如：alias ll='ls -latr'\r\n创建了一个新的命令别名 ll。\r\n可以把别名、shell 选项和常用函数保存在\r\n~/.bashrc，具体看下这篇文章。这样做的话你就可以在所有\r\nshell 会话中使用你的设定。\r\n把环境变量的设定以及登陆时要执行的命令保存在\r\n~/.bash_profile。而对于从图形界面启动的 shell 和\r\ncron 启动的 shell，则需要单独配置文件。\r\n要想在几台电脑中同步你的配置文件（例如 .bashrc 和\r\n.bash_profile），可以借助 Git。\r\n当变量和文件名中包含空格的时候要格外小心。Bash\r\n变量要用引号括起来，比如 \"$FOO\"。尽量使用 -0\r\n或 -print0 选项以便用 NULL 来分隔文件名，例如\r\nlocate -0 pattern | xargs -0 ls -al 或\r\nfind / -print0 -type d | xargs -0 ls -al。如果 for\r\n循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用\r\nIFS=$'\\n' 把内部字段分隔符设为换行符。\r\n在 Bash 脚本中，使用 set -x\r\n去调试输出（或者使用它的变体\r\nset -v，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用\r\nset -e 令脚本在发生错误时退出而不是继续运行；使用\r\nset -u 来检查是否使用了未赋值的变量；试试\r\nset -o pipefail，它可以监测管道中的错误。当牵扯到很多脚本时，使用\r\ntrap 来检测 ERR 和\r\nEXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：\r\n\r\nset -euo pipefailtrap &quot;echo &#x27;error: Script failed: see failed command above&#x27;&quot; ERR\r\n\r\n在 Bash 脚本中，子 shell（使用括号\r\n(...)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：\r\n\r\n# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir\r\n\r\n在 Bash\r\n中，变量有许多的扩展方式。$&#123;name:?error message&#125;\r\n用于检查变量是否存在。此外，当 Bash\r\n脚本只需要一个参数时，可以使用这样的代码\r\ninput_file=$&#123;1:?usage: $0 input_file&#125;。在变量为空时使用默认值：$&#123;name:-default&#125;。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码\r\noutput_file=$&#123;2:-logfile&#125;，如果省略了\r\n$2，它的值就为空，于是 output_file 就会被设为\r\nlogfile。数学表达式：i=$(( (i + 1) % 5 ))。序列：&#123;1..10&#125;。截断字符串：$&#123;var%suffix&#125;\r\n和 $&#123;var#prefix&#125;。例如，假设 var=foo.pdf，那么\r\necho $&#123;var%.pdf&#125;.txt 将输出 foo.txt。\r\n使用括号扩展（&#123;…&#125;）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如\r\nmv foo.&#123;txt,pdf&#125; some-dir（同时移动两个文件），cp somefile&#123;,.bak&#125;（会被扩展成\r\ncp somefile somefile.bak）或者\r\nmkdir -p test-&#123;a,b,c&#125;/subtest-&#123;1,2,3&#125;（会被扩展成所有可能的组合，并创建一个目录树）。\r\n通过使用 &lt;(some command)\r\n可以将输出视为文件。例如，对比本地文件 /etc/hosts\r\n和一个远程文件：\r\n\r\ndiff /etc/hosts &lt;(ssh somehost cat /etc/hosts)\r\n\r\n编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。\r\n\r\n&#123;      # 在这里写代码&#125;\r\n\r\n了解 Bash 中的“here documents”，例如\r\ncat &lt;&lt;EOF ...。\r\n在 Bash\r\n中，同时重定向标准输出和标准错误：some-command &gt;logfile 2&gt;&amp;1\r\n或者\r\nsome-command &amp;&gt;logfile。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加\r\n&lt;/dev/null 是一个好习惯。\r\n使用 man ascii\r\n查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及\r\nman latin1 有助于你去了解通用的编码信息。\r\n使用 screen 或 tmux\r\n来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而\r\nbyobu\r\n可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session\r\n持久化解决方案是 dtach。\r\nssh 中，了解如何使用 -L 或\r\n-D（偶尔需要用\r\n-R）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问\r\nweb 页面。\r\n对 ssh 设置做一些小优化可能是很有用的，例如这个\r\n~/.ssh/config\r\n文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：\r\n\r\nTCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes\r\n\r\n一些其他的关于 ssh\r\n的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用\r\nStrictHostKeyChecking=no，ForwardAgent=yes。\r\n考虑使用 mosh 作为\r\nssh 的替代品，它使用 UDP\r\n协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。\r\n获取八进制形式的文件访问权限（修改系统设置时通常需要，但\r\nls\r\n的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：\r\n\r\nstat -c &#x27;%A %a %n&#x27; /etc/timezone\r\n\r\n使用 percol 或者 fzf\r\n可以交互式地从另一个命令输出中选取值。\r\n使用 fpp（PathPicker）可以与基于另一个命令(例如\r\ngit）输出的文件交互。\r\n将 web\r\n服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：\r\npython -m SimpleHTTPServer 7777 （使用端口 7777 和 Python\r\n2）或python -m http.server 7777 （使用端口 7777 和 Python\r\n3）。\r\n以其他用户的身份执行命令，使用 sudo。默认以 root\r\n用户的身份执行；使用 -u 来指定其他用户。使用\r\n-i 来以该用户登录（需要输入_你自己的_密码）。\r\n将 shell 切换为其他用户，使用 su username 或者\r\nsu - username。加入 -\r\n会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为\r\nroot。切换到哪个用户，就需要输入_哪个用户的_密码。\r\n了解命令行的 128K\r\n限制。使用通配符匹配大量文件名时，常会遇到“Argument list too\r\nlong”的错误信息。（这种情况下换用 find 或\r\nxargs 通常可以解决。）\r\n当你需要一个基本的计算器时，可以使用 python\r\n解释器（当然你要用 python 的时候也是这样）。例如：\r\n\r\n&gt;&gt;&gt; 2+35\r\n文件及数据处理\r\n\r\n在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname '*something*'。在所有路径下通过文件名查找文件，使用\r\nlocate something （但注意到 updatedb\r\n可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。\r\n使用 ag\r\n在源代码或数据文件里检索（grep -r 同样可以做到，但相比之下\r\nag 更加先进）。\r\n将 HTML 转为文本：lynx -dump -stdin。\r\nMarkdown，HTML，以及所有文档格式之间的转换，试试 pandoc。\r\n当你要处理棘手的 XML 时候，xmlstarlet\r\n算是上古时代流传下来的神器。\r\n使用 jq\r\n处理 JSON。\r\n使用 shyaml 处理\r\nYAML。\r\n要处理 Excel 或 CSV 文件的话，csvkit 提供了\r\nin2csv，csvcut，csvjoin，csvgrep\r\n等方便易用的工具。\r\n当你要处理 Amazon S3 相关的工作的时候，s3cmd\r\n是一个很方便的工具而 s4cmd\r\n的效率更高。Amazon 官方提供的 aws 以及 saws 是其他\r\nAWS 相关工作的基础，值得学习。\r\n了解如何使用 sort 和 uniq，包括 uniq 的\r\n-u 参数和 -d\r\n参数，具体内容在后文单行脚本节中。另外可以了解一下\r\ncomm。\r\n了解如何使用 cut，paste 和\r\njoin 来更改文件。很多人都会使用 cut，但遗忘了\r\njoin。\r\n了解如何运用 wc\r\n去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。\r\n了解如何使用 tee\r\n将标准输入复制到文件甚至标准输出，例如\r\nls -al | tee file.txt。\r\n要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用\r\ndatamash。\r\n注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数\r\nLinux 的安装过程会将 LANG\r\n或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使\r\nsort\r\n或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用\r\nexport LC_ALL=C\r\n来忽略掉国际化并按照字节来判断顺序。\r\n你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如\r\nTZ=Pacific/Fiji date 可以获取斐济的时间。\r\n了解如何使用 awk 和 sed\r\n来进行简单的数据处理。 参阅 One-liners\r\n获取示例。\r\n替换一个或多个文件中出现的字符串：\r\n\r\nperl -pi.bak -e &#x27;s/old-string/new-string/g&#x27; my-files-*.txt\r\n\r\n使用 repren\r\n来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候\r\nrename 命令也可以批量重命名，但要注意，它在不同 Linux\r\n发行版中的功能并不完全一样。）\r\n\r\n# 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from &#x27;(.*)\\.bak&#x27; --to &#x27;\\1&#x27; *.bak# 用 rename 实现上述功能（若可用）:rename &#x27;s/\\.bak$//&#x27; *.bak\r\n\r\n根据 man 页面的描述，rsync\r\n是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用\r\nrsync 代替 scp\r\n可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的最快方法之一：\r\n\r\nmkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir\r\n\r\n若要在复制文件时获取当前进度，可使用 pv，pycp，progress，rsync --progress。若所执行的复制为block块拷贝，可以使用\r\ndd status=progress。\r\n使用 shuf\r\n可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。\r\n了解 sort 的参数。显示数字时，使用 -n\r\n或者 -h 来显示更易读的数（例如 du -h\r\n的输出）。明白排序时关键字的工作原理（-t 和\r\n-k）。例如，注意到你需要 -k1，1\r\n来仅按第一个域来排序，而 -k1\r\n意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用\r\nsort -k1，1 | sort -s -k2，2。\r\n如果你想在 Bash 命令行中写 tab 制表符，按下\r\nctrl-v [Tab] 或键入 $'\\t'\r\n（后者可能更好，因为你可以复制粘贴它）。\r\n标准的源代码对比及合并工具是 diff 和\r\npatch。使用 diffstat 查看变更总览数据。注意到\r\ndiff -r 对整个文件夹有效。使用\r\ndiff -r tree1 tree2 | diffstat\r\n查看变更的统计数据。vimdiff 用于比对并编辑文件。\r\n对于二进制文件，使用 hd，hexdump 或者\r\nxxd 使其以十六进制显示，使用\r\nbvi，hexedit 或者 biew\r\n来进行二进制编辑。\r\n同样对于二进制文件，strings（包括 grep\r\n等工具）可以帮助在二进制文件中查找特定比特。\r\n制作二进制差分文件（Delta 压缩），使用\r\nxdelta3。\r\n使用 iconv 更改文本编码。需要更高级的功能，可以使用\r\nuconv，它支持一些高级的 Unicode\r\n功能。例如，这条命令移除了所有重音符号：\r\n\r\nuconv -f utf-8 -t utf-8 -x &#x27;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#x27; &lt; input.txt &gt; output.txt\r\n\r\n拆分文件可以使用 split（按大小拆分）和\r\ncsplit（按模式拆分）。\r\n操作日期和时间表达式，可以用 dateutils 中的\r\ndateadd、datediff、strptime\r\n等工具。\r\n使用 zless、zmore、zcat 和\r\nzgrep 对压缩过的文件进行操作。\r\n文件属性可以通过 chattr\r\n进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：sudo chattr +i /critical/directory/or/file\r\n使用 getfacl 和 setfacl\r\n以保存和恢复文件权限。例如：\r\n\r\ngetfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt\r\n\r\n为了高效地创建空文件，请使用 truncate（创建稀疏文件），fallocate（用于\r\next4，xfs，btrf 和 ocfs2\r\n文件系统），xfs_mkfile（适用于几乎所有的文件系统，包含在\r\nxfsprogs 包中），mkfile（用于类 Unix 操作系统，比如 Solaris\r\n和 Mac OS）。\r\n\r\n系统调试\r\n\r\ncurl 和 curl -I 可以被轻松地应用于 web\r\n调试中，它们的好兄弟 wget 也是如此，或者也可以试试更潮的 httpie。\r\n获取 CPU 和硬盘的使用状态，通常使用使用\r\ntop（htop 更佳），iostat 和\r\niotop。而 iostat -mxz 15 可以让你获悉 CPU\r\n和每个硬盘分区的基本信息和性能表现。\r\n使用 netstat 和 ss\r\n查看网络连接的细节。\r\ndstat\r\n在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用\r\nglances，它会在一个终端窗口中向你提供一些系统级的数据。\r\n若要了解内存状态，运行并理解 free 和\r\nvmstat 的输出。值得留意的是“cached”的值，它指的是 Linux\r\n内核用来作为文件缓存的内存大小，而与空闲内存无关。\r\nJava 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM\r\n或其他 JVM 上的调试的技巧是你可以运行 kill -3 &lt;pid&gt;\r\n同时一个完整的栈轨迹和堆概述（包括 GC\r\n的细节）会被保存到标准错误或是日志文件。JDK 中的\r\njps，jstat，jstack，jmap\r\n很有用。SJK tools\r\n更高级。\r\n使用 mtr\r\n去跟踪路由，用于确定网络问题。\r\n用 ncdu\r\n来查看磁盘使用情况，它比寻常的命令，如\r\ndu -sh *，更节省时间。\r\n查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。\r\nab 工具（Apache 中自带）可以简单粗暴地检查 web\r\n服务器的性能。对于更复杂的负载测试，使用 siege。\r\nwireshark，tshark\r\n和 ngrep\r\n可用于复杂的网络调试。\r\n了解 strace 和\r\nltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意\r\nprofile 参数（-c）和附加到一个运行的进程参数\r\n（-p）。\r\n了解使用 ldd 来检查共享库。但是永远不要在不信任的文件上运行。\r\n了解如何运用 gdb\r\n连接到一个运行着的进程并获取它的堆栈轨迹。\r\n学会使用\r\n/proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的\r\nxxx 表示进程的 id 或 pid）。\r\n当调试一些之前出现的问题的时候，sar\r\n非常有用。它展示了 cpu、内存以及网络等的历史数据。\r\n关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf，以及sysdig。\r\n查看你当前使用的系统，使用\r\nuname，uname -a（Unix／kernel 信息）或者\r\nlsb_release -a（Linux 发行版信息）。\r\n无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试\r\ndmesg。\r\n如果你删除了一个文件，但通过 du\r\n发现没有释放预期的磁盘空间，请检查文件是否被进程占用：\r\nlsof | grep deleted | grep \"filename-of-my-big-file\"\r\n\r\n单行脚本\r\n一些命令组合的例子：\r\n\r\n当你需要对文本文件做集合交、并、差运算时，sort 和\r\nuniq 会是你的好帮手。具体例子请参照代码后面的，此处假设\r\na 与 b\r\n是两内容不同的文件。这种方式效率很高，并且在小文件和上 G\r\n的文件上都能运用（注意尽管在 /tmp\r\n在一个小的根分区上时你可能需要 -T 参数，但是实际上\r\nsort 并不被内存大小约束），参阅前文中关于\r\nLC_ALL 和 sort 的 -u\r\n参数的部分。\r\n\r\nsort a b | uniq &gt; c   # c 是 a 并 bsort a b | uniq -d &gt; c   # c 是 a 交 bsort a b b | uniq -u &gt; c   # c 是 a - b\r\n\r\n使用 grep . *（每行都会附上文件名）或者\r\nhead -100 *（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如\r\n/sys、/proc、/etc）时特别好用。\r\n计算文本文件第三列中所有数的和（可能比同等作用的 Python\r\n代码快三倍且代码量少三倍）：\r\n\r\nawk &#x27;&#123; x += $3 &#125; END &#123; print x &#125;&#x27; myfile\r\n\r\n如果你想在文件树上查看大小/日期，这可能看起来像递归版的\r\nls -l 但比 ls -lR 更易于理解：\r\n\r\nfind . -type f -ls\r\n\r\n假设你有一个类似于 web\r\n服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个\r\nacct_id 参数在 URI 中。如果你想计算出每个\r\nacct_id 值有多少次请求，使用如下代码：\r\n\r\negrep -o &#x27;acct_id=[0-9]+&#x27; access.log | cut -d= -f2 | sort | uniq -c | sort -rn\r\n\r\n要持续监测文件改动，可以使用\r\nwatch，例如检查某个文件夹中文件的改变，可以用\r\nwatch -d -n 2 'ls -rtlh | tail'；或者在排查 WiFi\r\n设置故障时要监测网络设置的更改，可以用\r\nwatch -d -n 2 ifconfig。\r\n运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown\r\n文件并抽取项目）：\r\n\r\nfunction taocl() &#123;  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|    pandoc -f markdown -t html |    iconv -f &#x27;utf-8&#x27; -t &#x27;unicode&#x27; |    xmlstarlet fo --html --dropdtd |    xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; |    xmlstarlet unesc | fmt -80&#125;\r\n冷门但有用\r\n\r\nexpr：计算表达式或正则匹配\r\nm4：简单的宏处理器\r\nyes：多次打印字符串\r\ncal：漂亮的日历\r\nenv：执行一个命令（脚本文件中很有用）\r\nprintenv：打印环境变量（调试时或在写脚本文件时很有用）\r\nlook：查找以特定字符串开头的单词或行\r\ncut，paste 和\r\njoin：数据修改\r\nfmt：格式化文本段落\r\npr：将文本格式化成页／列形式\r\nfold：包裹文本中的几行\r\ncolumn：将文本格式化成多个对齐、定宽的列或表格\r\nexpand 和\r\nunexpand：制表符与空格之间转换\r\nnl：添加行号\r\nseq：打印数字\r\nbc：计算器\r\nfactor：分解因数\r\ngpg：加密并签名文件\r\ntoe：terminfo 入口列表\r\nnc：网络调试及数据传输\r\nsocat：套接字代理，与 netcat\r\n类似\r\nslurm：网络流量可视化\r\ndd：文件或设备间传输数据\r\nfile：确定文件类型\r\ntree：以树的形式显示路径和文件，类似于递归的\r\nls\r\nstat：文件信息\r\ntime：执行命令，并计算执行时间\r\ntimeout：在指定时长范围内执行命令，并在规定时间结束后停止进程\r\nlockfile：使文件只能通过 rm -f\r\n移除\r\nlogrotate： 切换、压缩以及发送日志文件\r\nwatch：重复运行同一个命令，展示结果并／或高亮有更改的部分\r\nwhen-changed：当检测到文件更改时执行指定命令。参阅\r\ninotifywait 和 entr。\r\ntac：反向输出文件\r\nshuf：文件中随机选取几行\r\ncomm：一行一行的比较排序过的文件\r\nstrings：从二进制文件中抽取文本\r\ntr：转换字母\r\niconv 或 uconv：文本编码转换\r\nsplit 和 csplit：分割文件\r\nsponge：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如\r\ngrep -v something some-file | sponge some-file\r\nunits：将一种计量单位转换为另一种等效的计量单位（参阅\r\n/usr/share/units/definitions.units）\r\napg：随机生成密码\r\nxz：高比例的文件压缩\r\nldd：动态库信息\r\nnm：提取 obj 文件中的符号\r\nab 或 wrk：web\r\n服务器性能分析\r\nstrace：调试系统调用\r\nmtr：更好的网络调试跟踪工具\r\ncssh：可视化的并发 shell\r\nrsync：通过 ssh\r\n或本地文件系统同步文件和文件夹\r\nwireshark 和 tshark：抓包和网络调试工具\r\nngrep：网络层的\r\ngrep\r\nhost 和 dig：DNS 查找\r\nlsof：列出当前系统打开文件的工具以及查看端口信息\r\ndstat：系统状态查看\r\nglances：高层次的多子系统总览\r\niostat：硬盘使用状态\r\nmpstat： CPU 使用状态\r\nvmstat： 内存使用状态\r\nhtop：top 的加强版\r\nlast：登入记录\r\nw：查看处于登录状态的用户\r\nid：用户/组 ID 信息\r\nsar：系统历史数据\r\niftop 或 nethogs：套接字及进程的网络利用情况\r\nss：套接字数据\r\ndmesg：引导及系统错误信息\r\nsysctl：\r\n在内核运行时动态地查看和修改内核的运行参数\r\nhdparm：SATA/ATA 磁盘更改及性能分析\r\nlsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息\r\nlshw，lscpu，lspci，lsusb\r\n和 dmidecode：查看硬件信息，包括\r\nCPU、BIOS、RAID、显卡、USB设备等\r\nlsmod 和\r\nmodinfo：列出内核模块，并显示其细节\r\nfortune，ddate 和\r\nsl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”\r\n\r\n仅限 OS X 系统\r\n以下是仅限于 OS X 系统的技巧。\r\n\r\n用 brew （Homebrew）或者 port\r\n（MacPorts）进行包管理。这些可以用来在 OS X\r\n系统上安装以上的大多数命令。\r\n用 pbcopy 复制任何命令的输出到桌面应用，用\r\npbpaste 粘贴输入。\r\n若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的\r\nalt-b、alt-f 等命令中用到），打开\r\n偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta\r\n键”。\r\n用 open 或者\r\nopen -a /Applications/Whatever.app\r\n使用桌面应用打开文件。\r\nSpotlight：用 mdfind 搜索文件，用 mdls\r\n列出元数据（例如照片的 EXIF 信息）。\r\n注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如\r\nps，ls，tail，awk，sed）都和\r\nLinux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU\r\n工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man\r\n页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如\r\ngawk 和 gsed 对应 GNU 中的 awk 和 sed\r\n）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者\r\nperl ）或者经过仔细的测试。\r\n用 sw_vers 获取 OS X 的版本信息。\r\n\r\n仅限 Windows 系统\r\n以下是仅限于 Windows 系统的技巧。\r\n在 Windows 下获取 Unix 工具\r\n\r\n可以安装 Cygwin 允许你在\r\nMicrosoft Windows 中体验 Unix shell\r\n的威力。这样的话，本文中介绍的大多数内容都将适用。\r\n在 Windows 10 上，你可以使用 Bash on Ubuntu\r\non Windows，它提供了一个熟悉的 Bash 环境，包含了不少 Unix\r\n命令行工具。好处是它允许 Linux 上编写的程序在 Windows\r\n上运行，而另一方面，Windows 上编写的程序却无法在 Bash\r\n命令行中运行。\r\n如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑\r\nMinGW 以及它的 MSYS 包，这个包提供了例如\r\nbash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin\r\n媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW\r\n将特别地有用。\r\n另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 Cash。注意在此环境下只有很少的\r\nUnix 命令和命令行可用。\r\n\r\n实用 Windows 命令行工具\r\n\r\n可以使用 wmic 在命令行环境下给大部分 Windows\r\n系统管理任务编写脚本以及执行这些任务。\r\nWindows 实用的原生命令行网络工具包括\r\nping，ipconfig，tracert，和\r\nnetstat。\r\n可以使用 Rundll32 命令来实现许多有用的\r\nWindows 任务 。\r\n\r\nCygwin 技巧\r\n\r\n通过 Cygwin 的包管理器来安装额外的 Unix 程序。\r\n使用 mintty 作为你的命令行窗口。\r\n要访问 Windows 剪贴板，可以通过\r\n/dev/clipboard。\r\n运行 cygstart 以通过默认程序打开一个文件。\r\n要访问 Windows 注册表，可以使用 regtool。\r\n注意 Windows 驱动器路径 C:\\ 在 Cygwin 中用\r\n/cygdrive/c 代表，而 Cygwin 的 / 代表 Windows\r\n中的 C:\\cygwin。要转换 Cygwin 和 Windows 风格的路径可以用\r\ncygpath。这在需要调用 Windows 程序的脚本里很有用。\r\n学会使用 wmic，你就可以从命令行执行大多数 Windows\r\n系统管理任务，并编成脚本。\r\n要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 Cash。需要注意的是，这个环境支持的\r\nUnix 命令和命令行参数非常少。\r\n要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用\r\nMinGW 以及它的 MSYS 软件包，该软件包提供了\r\nbash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin\r\n完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。\r\n\r\n更多资源\r\n\r\nawesome-shell：一份精心组织的命令行工具及资源的列表。\r\nawesome-osx-command-line：一份针对\r\nOS X 命令行的更深入的指南。\r\nStrict\r\nmode：为了编写更好的脚本文件。\r\nshellcheck：一个静态\r\nshell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。\r\nFilenames\r\nand Pathnames in Shell：有关如何在 shell\r\n脚本里正确处理文件名的细枝末节。\r\nData Science\r\nat the Command\r\nLine：用于数据科学的一些命令和工具，摘自同名书籍。\r\n\r\n免责声明\r\n除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你\r\n有能力 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)\r\n授权条款\r\n\r\n本文使用授权协议 Creative Commons\r\nAttribution-ShareAlike 4.0 International License。\r\n","categories":["学习类","命令"],"tags":["学习类","实用知识","常用知识","配置相关","Git","命令行","转载文章"]},{"title":"随机变量的矩","url":"/posts/46508.html","content":"原点矩\r\n定义\r\n设 X 是随机变量，k 为正整数，则 k 阶原点矩 定义为：\r\n离散型原点矩 $$\r\nv_k = \\sum_{i = 1}^{n} x_i^k p_i\r\n$$\r\n连续型原点矩： vk = ∫−∞+∞xikf(x) dx\r\n解释\r\n物理上，我们习惯把矩看作一杆能够取得两侧平衡的秤\r\n在概率论中，有一杆无处不在的“秤”。因为这把“秤”的存在，所以我们有了“矩”。\r\n这个矩可以理解为距离的意思，原点矩就是与原点，也就是与X轴上0点的距离。中心距，中心指的是变量的均值，那中心距就是与X轴上均值处的距离。\r\n类比一下，将概率分布看作质量分布： - E[X1]（一阶矩）：系统的质心位置（均值），在概率论中直接反映随机变量的集中趋势（期望）\r\n- E[X2]（二阶矩）：质量分布的「转动惯量」，反映数据相对于原点的分散程度\r\n- 。。。。。。。更高阶有更高阶的用途了\r\n首先，E[Xk]是什么意思呢\r\n对于离散型随机变量 X，其\r\nk 阶原点矩 E[Xk]\r\n的计算公式为： E[Xk] = ∑ixik ⋅ P(X = xi)\r\n其中： - xi 是 X 的所有可能取值 - P(X = xi)\r\n是对应的概率\r\n那么很明显了，就是随机变量$ X^k$的期望\r\n例子：掷骰子的结果 X（取值 1~6，等概率 1/6）\r\n二阶矩计算： $$\r\nE[X^2] = \\sum_{i=1}^6 i^2 \\cdot \\frac{1}{6} = \\frac{1+4+9+16+25+36}{6} =\r\n\\frac{91}{6} \\approx 15.17\r\n$$ 离散型的我们理解了，那么连续型的也是一样，对于连续型随机变量\r\nX 的概率密度函数 f(x)，其 k 阶原点矩为： E[Xk] = ∫−∞∞xkf(x) dx\r\nk 阶原点矩是 Xk 以概率密度\r\nf(x) 为权重的\r\n“加权积分”\r\n例子：X ∼ Uniform(0, 1)\r\n二阶矩计算： $$\r\nE[X^2] = \\int_0^1 x^2 \\cdot 1 \\, dx = \\left. \\frac{x^3}{3} \\right|_0^1 =\r\n\\frac{1}{3}\r\n$$\r\n性质\r\n\r\n各阶原点矩的含义\r\n\r\n一阶原点矩：m1 = E[X] = ∫−∞∞xf(x)，易知就是期望\r\n二阶原点矩：μ2 = E[X2]，易知就是X2的期望，是计算方差的基础\r\n三阶原点矩：一样，X3的期望\r\n\r\n低阶矩对存在性的推导\r\n\r\n若随机变量 X 的 k 阶原点矩存在（即 E[|Xk|] &lt; +∞\r\n），则对于任意 0 &lt; m &lt; k，$m $\r\n阶原点矩也一定存在。这是因为 |Xm| ≤ 1 + |Xk|（当\r\n|X| ≥ 1 时，|Xm| ≤ |Xk|；当\r\n|X| &lt; 1 时，|Xm| &lt; 1\r\n），由期望的单调性可推出低阶矩存在，但反之不成立（高阶矩存在不能保证低阶矩存在，不过实际应用中通常先看低阶矩\r\n）。\r\n\r\n\r\n中心距\r\n定义\r\n设X为随机变量，k为正整数，则称 E[(X − EX)k]\r\n为随机变量X的k阶中心矩，记为 ，k = 1, 2...\r\n显而易见：一阶中心矩等于0，二阶中心矩就是方差DX。\r\n离散型中心矩： $$\r\n\\mu_k = \\sum_{i=1}^{n} (x_i - EX)^k p_i\r\n$$ 连续型中心矩： μk = ∫−∞+∞(x − EX)kf(x) dx\r\n解释\r\n基于上面的原点矩的解释，我们可以知道原点矩是与X轴上原点的距离。\r\n那么中心距，中心指的是变量的均值，那中心距就是与X轴上均值处的距离。\r\n可能这个东西计算上会一些抽象，我找一道例题做一下\r\n离散型三阶中心距的计算\r\n设离散型随机变量 X\r\n的概率分布如下：\r\n\r\n\r\n\r\nX\r\nP(X)\r\n\r\n\r\n\r\n\r\n-1\r\n0.2\r\n\r\n\r\n0\r\n0.5\r\n\r\n\r\n1\r\n0.3\r\n\r\n\r\n\r\n求 X 的三阶中心矩\r\nμ3 = E[(X − E[X])3]\r\n先计算期望 E[X]\r\n$$\r\n\\begin{aligned}\r\nE[X] &amp;= \\sum x_i P(X=x_i) \\\\\r\n&amp;= (-1) \\times 0.2 + 0 \\times 0.5 + 1 \\times 0.3 \\\\\r\n&amp;= -0.2 + 0 + 0.3 \\\\\r\n&amp;= 0.1\r\n\\end{aligned}\r\n$$ 然后计算 Y = X − E[X]\r\n的分布\r\n定义 Y = X − 0.1，其分布为：\r\n\r\n\r\n\r\nY\r\nP(Y)\r\n\r\n\r\n\r\n\r\n-1 - 0.1 = -1.1\r\n0.2\r\n\r\n\r\n0 - 0.1 = -0.1\r\n0.5\r\n\r\n\r\n1 - 0.1 = 0.9\r\n0.3\r\n\r\n\r\n\r\n然后计算 E[Y3] $$\r\n\\begin{aligned}\r\n\\mu_3 &amp;= E[Y^3] = \\sum y_i^3 P(Y=y_i) \\\\\r\n&amp;= (-1.1)^3 \\times 0.2 + (-0.1)^3 \\times 0.5 + (0.9)^3 \\times 0.3 \\\\\r\n&amp;= -1.331 \\times 0.2 + (-0.001) \\times 0.5 + 0.729 \\times 0.3 \\\\\r\n&amp;= -0.2662 - 0.0005 + 0.2187 \\\\\r\n&amp;= -0.048\r\n\\end{aligned}\r\n$$ 通过中心矩与原点矩的关系验证： μ3 = E[X3] − 3E[X]E[X2] + 2(E[X])3\r\n\r\n计算 E[X2]: E[X2] = (−1)2 × 0.2 + 02 × 0.5 + 12 × 0.3 = 0.5\r\n计算 E[X3]: E[X3] = (−1)3 × 0.2 + 03 × 0.5 + 13 × 0.3 = 0.1\r\n代入公式： μ3 = 0.1 − 3 × 0.1 × 0.5 + 2 × (0.1)3 = 0.1 − 0.15 + 0.002 = −0.048\r\n\r\n验证结果一致。\r\n连续型二阶中心距的计算\r\n设连续型随机变量 X\r\n服从指数分布，其概率密度函数为： $$\r\nf(x) = \\begin{cases}\r\n\\lambda e^{-\\lambda x}, &amp; x \\geq 0 \\\\\r\n0, &amp; x &lt; 0\r\n\\end{cases}\r\n$$ 其中参数 λ &gt; 0。\r\n求 X 的二阶中心矩\r\nμ2 = Var(X) = E[(X − E[X])2]\r\n还是先计算期望E(X)\r\n$$\r\n\\begin{aligned}\r\nE[X] &amp;= \\int_{-\\infty}^{\\infty} x f(x) dx \\\\\r\n&amp;= \\int_0^{\\infty} x \\cdot \\lambda e^{-\\lambda x} dx \\\\\r\n&amp;= \\lambda \\left[ \\left. -x \\cdot \\frac{e^{-\\lambda x}}{\\lambda}\r\n\\right|_0^{\\infty} + \\int_0^{\\infty} \\frac{e^{-\\lambda x}}{\\lambda} dx\r\n\\right] \\quad \\text{(分部积分)} \\\\\r\n&amp;= \\lambda \\left[ 0 + \\frac{1}{\\lambda} \\cdot \\frac{1}{\\lambda}\r\n\\right] \\\\\r\n&amp;= \\frac{1}{\\lambda}\r\n\\end{aligned}\r\n$$ 然后计算E(X2) $$\r\n\\begin{aligned}\r\nE[X^2] &amp;= \\int_0^{\\infty} x^2 \\cdot \\lambda e^{-\\lambda x} dx \\\\\r\n&amp;= \\lambda \\left[ \\left. -x^2 \\cdot \\frac{e^{-\\lambda x}}{\\lambda}\r\n\\right|_0^{\\infty} + \\int_0^{\\infty} \\frac{2x e^{-\\lambda x}}{\\lambda}\r\ndx \\right] \\quad \\text{(分部积分)} \\\\\r\n&amp;= \\lambda \\left[ 0 + \\frac{2}{\\lambda} E[X] \\right] \\\\\r\n&amp;= \\frac{2}{\\lambda} \\cdot \\frac{1}{\\lambda} \\\\\r\n&amp;= \\frac{2}{\\lambda^2}\r\n\\end{aligned}\r\n$$ 分部积分的公式我总忘，贴一下 ∫u dv = uv − ∫v du,  u = xn, 在这里dv = e−λx dx\r\n计算二阶中心矩 μ2\r\n$$\r\n\\begin{aligned}\r\n\\mu_2 &amp;= \\text{Var}(X) = E[X^2] - (E[X])^2 \\\\\r\n&amp;= \\frac{2}{\\lambda^2} - \\left( \\frac{1}{\\lambda} \\right)^2 \\\\\r\n&amp;= \\frac{1}{\\lambda^2}\r\n\\end{aligned}\r\n$$ 直接积分验证\r\n也可直接计算 $E[(X-\\frac{1}{\\lambda})^2]$： $$\r\n\\begin{aligned}\r\n\\mu_2 &amp;= \\int_0^{\\infty} \\left(x - \\frac{1}{\\lambda}\\right)^2\r\n\\lambda e^{-\\lambda x} dx \\\\\r\n&amp;= \\lambda \\int_0^{\\infty} \\left(x^2 - \\frac{2x}{\\lambda} +\r\n\\frac{1}{\\lambda^2}\\right) e^{-\\lambda x} dx \\\\\r\n&amp;= \\lambda E[X^2] - 2 E[X] + \\frac{1}{\\lambda} \\\\\r\n&amp;= \\lambda \\cdot \\frac{2}{\\lambda^2} - 2 \\cdot \\frac{1}{\\lambda} +\r\n\\frac{1}{\\lambda} \\\\\r\n&amp;= \\frac{1}{\\lambda^2} \\quad \\text{(结果一致)}\r\n\\end{aligned}\r\n$$\r\n$$\r\n$$\r\n性质\r\n\r\n显而易见：一阶中心矩等于0，二阶中心矩就是方差DX。（在概率论与数理统计中常用的低阶矩，高于4阶的极少使用。）\r\n\r\n\r\n\r\n中心矩\r\n计算公式\r\n统计意义\r\n\r\n\r\n\r\n\r\nμ1\r\nE[X − E[X]] = 0\r\n均值偏差恒为零\r\n\r\n\r\nμ2\r\nE[(X − E[X])2] = D(X)\r\n方差\r\n\r\n\r\nμ3\r\nE[(X − E[X])3]\r\n标准化后得偏度\r\n\r\n\r\nμ4\r\nE[(X − E[X])4]\r\n标准化后得峰度\r\n\r\n\r\n\r\n\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"随机变量的假设检验","url":"/posts/59825.html","content":"假设检验\r\n什么是参数的假设检验\r\n参数的假设检验通常是指，根据样本来判断总体分布的数字特征是否是某一个指定的数。\r\n例如，已知样本来着正态总体N(μ, σ2)，要判断它是否来自均值μ = μ0，方差σ2 = σ02的正态总体，这里μ0和σ02是已知数。\r\n所以，假设检验就像一场“辩论”，目的是用数据判断某个关于总体参数的假设（比如“平均值等于5”）是否成立。所以假设检验的逻辑是我先做一个假设，然后看数据结果是足够反驳它还是足够接受他，如果数据非常不支持，就拒绝这个假设。\r\n所以做假设检验时会设置两个假设：\r\n\r\n原假设（H₀）(零假设)：默认的、保守的假设（比如“均值=5”或“新药=旧药”）。\r\n备择假设（H₁）：你想证明的结论（比如“均值≠5”或“新药&gt;旧药”）。\r\n\r\n然后，根据数据类型（均值、比例等）选一个公式计算统计量（比如t值、z值），用来衡量数据与原假设的差距。之后确定显著性水平，通常选α = 0.05，表示“如果H0成立，只有5%的概率会误判拒绝它”（即容忍的犯错风险）。最后根据结果判断结论\r\n这样，问题转化为检验假设H0是否为真（成立），当H0为真，则接受假设，否则不接受\r\n具体一个例子说明：\r\n味精厂用一台包装机自动包装味精，包得的袋装味精质量服从 N(μ, σ2)。当机器正常时,其均值\r\nμ0 = 0.5 kg,标准差\r\nσ0 = 0.015 kg.某日开工后随机地抽取\r\n9 袋味精，称得质量(单位:kg)为：0.497, 0.506, 0.518, 0.524, 0.498, 0.511, 0.520, 0.515, 0.512,问这台包装机是否正常?\r\n根据实际问题，若 X\r\n表示袋装味精的质量,则包装机正常是指 X 应服从正态分布 N(0.5, 0.0152)。若 X\r\n不是服从这个正态分布，则包装机就不正常了.\r\n现在的问题是，如何根据样本观测值(9 袋味精的质量)来判断总体均值 μ 是否为 μ0 = 0.5 kg(这里暂不考虑\r\nσ\r\n可能也改变的情形)。为此，我们提出假设 H0 : μ = μ0 = 0.5\r\n称它为原假设或零假设.与这个假设相对应的假设是 H1 : μ ≠ μ0\r\n称它为备择假设.\r\n于是问题转化为检验假设 H0 是否为真(成立).当\r\nH0\r\n为真,则认为机器正常.否则,认为机器不正常.\r\n检验方法\r\n我们的任务就是要根据样本对假设作出判断。\r\n由于样本均值 $\\bar{X} = \\frac{1}{n}\\sum_{i\r\n= 1}^n X_i$ 是总体均值 EX = μ\r\n的无偏估计，故当 H0\r\n为真时,X̄ 的观测值 x̄ 应落在 μ0 的附近，偏差 |x̄ − μ0|\r\n应很小.当 |x̄ − μ0|\r\n过分大时，我们就应当怀疑 H0 不正确而拒绝 H0。但是如何给出一个明确的数量界限，以便确认偏差\r\n|x̄ − μ0|\r\n是否过大的问题？\r\n当 H0\r\n为真时,$\\bar{X} \\sim N\\left( \\mu_0,\r\n\\frac{\\sigma^2}{n} \\right)$,其中 μ0, σ2\r\n都是已知常数,所以统计量\r\n$$\r\nU = \\frac{(\\bar{X} - \\mu_0)\\sqrt{n}}{\\sigma} \\sim N(0, 1).\r\n$$ 给定实数 α(0 &lt; α &lt; 1),令 uα\r\n为标准正态分布上侧 α\r\n分位数，则\r\n$$\r\nP\\left( \\left| \\frac{(\\bar{X} - \\mu_0)\\sqrt{n}}{\\sigma} \\right| &gt;\r\nu_{\\alpha/2} \\right) = \\alpha, \\tag{8.1}\r\n$$\r\n由于 α\r\n通常是一个较小的数，所以事件\r\n$$\r\n\\left\\{ \\left| \\frac{(\\bar{X} - \\mu_0)\\sqrt{n}}{\\sigma} \\right| &gt;\r\nu_{\\alpha/2} \\right\\}\r\n$$\r\n是一个由样本 (X1, X2, ⋯, Xn)\r\n构成的小概率事件，uα/2\r\n就是根据样本观测值确认小概率事件是否已发生的数量界限.\r\n查 N(0, 1) 分布表可得 uα/2\r\n的值，将统计量 U 的观测值\r\n$u = \\frac{(\\bar{x} -\r\n\\mu_0)\\sqrt{n}}{\\sigma}$ 与 uα/2 相比较，当\r\n|u| &gt; uα/2\r\n时，说明小概率事件在一次试验中发生了，这就与小概率事件在一次试验中不太可能发生的原理相矛盾，因而认为\r\nH0 不真而拒绝 H0；若 |u| ≤ uα/2，则一次试验的结果与\r\nH0\r\n为真并无矛盾，因此没有理由拒绝 H0，于是接受 H0。\r\n对于上面的例子，x̄ = 0.511,取 α = 0.05，查 N(0, 1) 分布表得 uα/2 = u0.025 = 1.96，又\r\nn = 9,σ = 0.015,因而\r\n$$\r\n|u| = \\left| \\frac{(\\bar{x} - \\mu_0)\\sqrt{n}}{\\sigma} \\right| = \\left|\r\n\\frac{0.511 - 0.5}{0.015} \\sqrt{9} \\right| = 2.2 &gt; 1.96 =\r\nu_{\\alpha/2}.\r\n$$ 小概率事件居然发生了，这与实际推断原理相矛盾，故拒绝 H0，即认为 x̄ 与 μ0\r\n已有了显著差异，从而抽取的 9 袋味精不是来自正态总体 N(0.5, 0.0152)，而是来自一个均值\r\nμ ≠ 0.5\r\n的正态总体。换句话说，这天包装机工作不正常。\r\n构造小概率事件作用的统计量称为检验统计量。当统计量的观测值取某个区域\r\nW 中的值时，我们拒绝 H0，则称区域 W\r\n为拒绝域，拒绝域的边界点称为临界点\r\n\r\n\r\nimage-20250626171255837\r\n\r\n例如，在上面的例子中，检验统计量是 $\\frac{(\\bar{X} -\r\n\\mu_0)\\sqrt{n}}{\\sigma}$，拒绝域 W = (−∞, −1.96) ∪ (1.96, +∞),−1.96 与 1.96 都是临界点\r\n在检验中确立小概率事件的数 α，称为显著性水平或简称为水平，α 通常取 0.1,0.05 或\r\n0.01。值得注意的是 α\r\n取不同的值，检验结果可能不同，统计推断的可靠程度也不同。\r\n例如,在例子 中取 α = 0.01，则 uα/2 = u0.005 = 2.57，因此，|u| = 2.2 ≤ 2.57，依检验法则应接受\r\nH0。\r\n检验是在假设 H0\r\n与 H1\r\n之间做选择，拒绝 H0,意味着接受 H1；接受 H0,表示拒绝 H1。所以,像例子这样一类的检验问题，通常称为在显著性水平\r\nα 下的假设检验\r\nH0 : μ = μ0;  H1 : μ ≠ μ0,\r\n简称为 H0 对\r\nH1\r\n的显著性检验.\r\n总结一下：\r\n我们希望通过样本数据判断总体参数（例如均值μ）是否属于某个假设，比如μ = μ0\r\n这就涉及到一个关键问题：样本均值$\\overline\r\nX$和假设值μ0的偏差$|\\overline X -\r\n\\mu_0|$多大才算“过分大”？需要给出一个明确的数学界限。\r\n\r\n为什么用样本均值？\r\n\r\n样本均值 $\\overline X$\r\n是总体均值μ的无偏估计（即长期来看$\\overline X = \\mu$），所以如果H0(μ = μ0)为真，\r\n$\\overline X$ 应该集中在 μ0 附近。\r\n如果 $\\overline X$ 离 μ0 太远，我们怀疑 H0 不成立。\r\n\r\n如何量化“偏差是否过大”\r\n\r\n直接比较 |X̄ − μ0|\r\n不够，因为数据波动大小（方差 σ2）和样本量 n 会影响结果。\r\n解决方案：将偏差标准化，消除量纲和样本量影响，构造检验统计量：\r\n$$\r\nU = \\frac{(\\bar{X} - \\mu_0)\\sqrt{n}}{\\sigma}\r\n$$ 当 H0\r\n为真时，U ∼ N(0, 1)（标准正态分布）。\r\n\r\n如何确定拒绝界限？\r\n\r\n选定显著性水平 α（如 0.05），表示容忍的误判概率（即 H0\r\n为真但被拒绝的概率）。\r\n\r\n查标准正态分布表，找到临界值 uα/2（如 α = 0.05 时，u0.025 = 1.96）。\r\n\r\n拒绝域：如果 |U| &gt; uα/2，认为偏差“过大”，拒绝\r\nH0。\r\n\r\n\r\n两类错误\r\n在假设检验中，由于样本的随机性，我们可能会犯以下两类错误：\r\n第一类错误（弃真错误）\r\n\r\n定义：当原假设H0实际上为真时，我们却拒绝了它。\r\n表示： P(拒绝H0|H0为真) = α\r\n特点：\r\n\r\nα是显著性水平，即检验中设定的阈值（通常取0.05,\r\n0.01等）\r\n好比”冤枉好人”的概率\r\n\r\n\r\n第二类错误（存伪错误）\r\n\r\n定义：当H0实际上不成立时，我们却接受了它。\r\n表示： P(接受H0|H0不成立) = β\r\n特点：\r\n\r\n相当于”放过坏人”的概率\r\n计算β需要知道备择假设H1的具体分布\r\n\r\n\r\n两类错误的关系\r\n\r\n此消彼长：当样本量n固定时，α减小会导致β增大，反之亦然\r\n\r\n解决方案：增加样本量可以同时减小α和β\r\n\r\n实际应用原则\r\n\r\n原假设选择：\r\n\r\n把希望验证的结论放在备择假设H1\r\n将历史结论或保守判断设为H0\r\n\r\n显著性水平选择：\r\n\r\n医学等严格领域：取α = 0.01\r\n一般社会科学：常用α = 0.05\r\n\r\n检验效能：1 − β表示正确拒绝H0的能力，好的检验应保证较高效能\r\n\r\n\r\n\r\n\r\n错误类型\r\n通俗比喻\r\n概率表示\r\n控制方法\r\n\r\n\r\n\r\n\r\n第一类\r\n冤枉好人\r\nα\r\n直接设定\r\n\r\n\r\n第二类\r\n放过坏人\r\nβ\r\n增大样本量\r\n\r\n\r\n\r\n简单总结一下\r\n\r\n\r\n\r\n错误类型\r\n概率\r\n本例表现\r\n\r\n\r\n\r\n\r\n第一类错误（弃真）\r\nα\r\n机器正常却判为异常\r\n\r\n\r\n第二类错误（取伪）\r\nβ\r\n机器异常却判为正常\r\n\r\n\r\n\r\n假设检验的基本步骤\r\n假设检验的本质是基于样本数据对总体参数做出概率性判断。其核心逻辑可分为三步：\r\n\r\n设立对立假设：\r\n\r\nH0 : μ = μ0（原假设，默认成立）\r\nH1 : μ ≠ μ0（备择假设）\r\n\r\n构造判断工具：\r\n\r\n建立检验统计量 $U = \\frac{(\\bar{X} -\r\n\\mu_0)\\sqrt{n}}{\\sigma}$\r\n确定其分布 U ∼ N(0, 1)（当H0为真时）\r\n\r\n制定决策规则：\r\n\r\n设定显著性水平 α（通常取0.05），确定拒绝域 W\r\n的形式\r\n计算临界值 uα/2\r\n比较统计量观测值|u|与临界值\r\n\r\n根据统计量的观测值决定是拒绝还是接受H0\r\n\r\n如何确定拒绝域：\r\n对于双侧检验 拒绝域 = (−∞, −uα/2) ∪ (uα/2, +∞)\r\n其中临界值uα/2通过查表获得：\r\n\r\nα = 0.05 ⇒ u0.025 = 1.96\r\nα = 0.01 ⇒ u0.005 = 2.58\r\n\r\n而基于小概率事件原理 P(|U| &gt; uα/2) = α\r\n当α = 0.05时，意味着在H0成立的假设下：\r\n\r\n有95%的概率U会落在(−1.96, 1.96)之间\r\n只有5%的概率会落入拒绝域\r\n\r\n正态总体均值的假设检验\r\n单个正态总体均值的检验\r\n设总体 $ X $ 服从正态分布 $ N(, ^2) ， (X_1, X_2, , X_n) $ 为总体 $ X $\r\n的一个样本，欲检验假设：\r\nH0 : μ = μ0;  H1 : μ ≠ μ0\r\n其中 $ _0 $ 为已知常数.\r\n根据总体方差 $ ^2 $ 是否已知，分为两种情形：\r\n$ ^2$已知\r\n结论\r\n已求出统计量\r\n$$\r\nU = \\frac{(\\bar{X} - \\mu_0)\\sqrt{n}}{\\sigma}\r\n$$ 在假设 $ H_0$ 成立时，服从 $ N(0, 1) $，拒绝域 $ W = (-,\r\n-u_{/2}) (u_{/2}, +) $\r\n此检验法称为U检验法\r\n推导过程\r\n\r\n样本均值性质： 由正态分布的性质可知，样本均值\r\n$$\r\n\\bar{X} = \\frac{1}{n}\\sum_{i=1}^n X_i\r\n$$ 服从： $$\r\n\\bar{X} \\sim N(\\mu, \\frac{\\sigma^2}{n})\r\n$$\r\n标准化变换： 当H0成立时（μ = μ0），构造统计量：\r\n$$\r\nU = \\frac{\\bar{X} - \\mu_0}{\\sigma/\\sqrt{n}} \\sim N(0,1)\r\n$$\r\n拒绝域确定： 对于显著性水平α，查标准正态分布表得临界值uα/2，使得：\r\nP(|U| ≥ uα/2) = α\r\n因此拒绝域为： W = {U ∣ U ≤ −uα/2\r\n或 U ≥ uα/2}\r\n\r\n实际计算示例\r\n例题：已知某生产线灌装重量服从N(μ, 52)，现抽取25瓶测得平均重量x̄ = 498g。检验平均重量是否为500g（α = 0.05）。\r\n解题步骤：\r\n\r\n建立假设： H0 : μ = 500  vs  H1 : μ ≠ 500\r\n计算检验统计量： $$\r\n\\begin{align*}\r\nU &amp;= \\frac{\\bar{X} - \\mu_0}{\\sigma/\\sqrt{n}} \\\\\r\n  &amp;= \\frac{498 - 500}{5/\\sqrt{25}} \\\\\r\n  &amp;= \\frac{-2}{1} = -2.0\r\n\\end{align*}\r\n$$\r\n确定临界值： 查标准正态分布表得u0.025 = 1.96\r\n决策规则：\r\n\r\n拒绝域：(−∞, −1.96] ∪ [1.96, +∞)\r\n由于−2.0 &lt; −1.96，落入拒绝域\r\n\r\n结论： 在α = 0.05水平下拒绝H0，认为平均灌装重量与500g有显著差异。\r\n\r\n$^2 $ 未知\r\n结论\r\n用 $ ^2 $ 的无偏估计 $ S^2 $ 去估计 $ ^2 $，则在假设 $ H_0 $\r\n成立时，统计量 $$\r\nT = \\frac{(\\bar{X} - \\mu_0)\\sqrt{n}}{S} \\sim t(n - 1)\r\n$$ 于是，对给定的水平 $ $，查 $ t $ 分布临界值表可得 $ t_{/2}(n -\r\n1) ，使得$ P(|t| &gt;\r\nt_{/2}(n - 1)) = 从而拒绝域为\r\nW = (-, -t_{/2}(n - 1)) (t_{/2}(n - 1), +) $$ 此检验法称为t检验法\r\n推导过程\r\n\r\n样本方差替代： 当总体方差σ2未知时，用样本方差\r\n$$\r\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\bar{X})^2\r\n$$ 作为估计量。\r\n统计量构造：\r\n在H0成立时（μ = μ0），构造：\r\n$$\r\nT = \\frac{\\bar{X} - \\mu_0}{S/\\sqrt{n}}\r\n$$\r\n分布推导：\r\n\r\n分子：$\\bar{X} - \\mu_0 \\sim N(0,\r\n\\frac{\\sigma^2}{n})$\r\n分母：$\\frac{S}{\\sqrt{n}}$是样本标准差的标准误\r\n由统计学定理可知： $$\r\n\\frac{\\bar{X} - \\mu_0}{S/\\sqrt{n}} \\sim t(n-1)\r\n$$ 其中t(n − 1)表示自由度为n − 1的t分布\r\n\r\n拒绝域确定： 对于显著性水平α，查t分布表得临界值tα/2(n − 1)，使得：\r\nP(|T| ≥ tα/2(n − 1)) = α\r\n因此拒绝域为： W = (−∞, −tα/2(n − 1)] ∪ [tα/2(n − 1), +∞)\r\n\r\n实际计算示例\r\n设某厂生产的螺杆直径服从正态分布 $ N(, ^2) ，现从中抽取5件，测得直径（单位：mm）为$\r\n22.3, 21.5, 22.0, 21.8, 21.4 $$ 若 $ ^2 $ 未知，试在显著性水平 $ = 0.05\r\n$ 下，检验假设 $ H_0:= 21; H_1: $\r\n由于方差 $ ^2 $ 未知，因此用 $ t $ 检验法.由样本观测值计算得 x̄ = 21.8,  s2 = 0.135\r\n$$\r\nt = \\frac{21.8 - 21}{\\sqrt{0.135 / 5}} = 4.87.\r\n$$\r\n查 $ t $ 分布表得 $ t_{/2}(n - 1) = t_{0.025}(4) = 2.776 $.\r\n由于 $ |t| = 4.87 &gt; 2.776 = t_{/2}(n - 1) $，故拒绝 $ H_0\r\n$，即在显著性水平 0.05 下认为螺杆直径不是 21 mm.\r\n两个正态总体均值差的检验\r\n设 X ∼ N(μ1, σ12)，Y ∼ N(μ2, σ22)，(X1, X2, ⋯, Xn1)\r\n和 (Y1, Y2, ⋯, Yn2)\r\n分别是来自 X 和 Y 的样本且相互独立，考虑检验假设：\r\nH0 : μ1 − μ2 = δ;  H1 : μ1 − μ2 ≠ δ\r\n其中 δ 为已知常数，较常见的是\r\nδ = 0，即检验两个正态总体的均值是否相等，取显著性水平为\r\nα。下面分三种情况讨论。\r\n$ _1^2$ 和 σ22 已知\r\n结论\r\n由于统计量 X̄ − Ȳ\r\n是 μ1 − μ2\r\n的无偏估计量，因此在 H0 成立时，统计量 $$\r\nU = \\frac{\\bar{X} - \\bar{Y} - (\\mu_1 -\r\n\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2}}} \\sim\r\nN(0, 1)\r\n$$ 于是，对给定的水平 α，查 N(0, 1) 分布临界值表可得 uα/2，使得 P(|U| &gt; uα/2) = α\r\n从而拒绝域为 W = (−∞, −uα/2) ∪ (uα/2, +∞)\r\n由于检验统计量 U ∼ N(0, 1)，故此检验法仍为\r\nU 检验法。\r\n推导过程\r\n\r\n样本均值性质：\r\n\r\n$\\bar{X} \\sim N\\left(\\mu_1,\r\n\\frac{\\sigma_1^2}{n_1}\\right)$\r\n$\\bar{Y} \\sim N\\left(\\mu_2,\r\n\\frac{\\sigma_2^2}{n_2}\\right)$\r\n\r\n均值差分布： 由独立性可知： $$\r\n\\bar{X} - \\bar{Y} \\sim N\\left(\\mu_1 - \\mu_2, \\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}\\right)\r\n$$\r\n标准化变换： 当H0成立时（μ1 − μ2 = δ）：\r\n$$\r\nU = \\frac{(\\bar{X} - \\bar{Y}) - \\delta}{\\sqrt{\\frac{\\sigma_1^2}{n_1} +\r\n\\frac{\\sigma_2^2}{n_2}}} \\sim N(0,1)\r\n$$\r\n拒绝域确定： 对于显著性水平α，查标准正态分布表得uα/2，使得：\r\nP(|U| ≥ uα/2) = α\r\n因此拒绝域为： W = {U ∣ |U| ≥ uα/2}\r\n\r\n\r\n细节内容说明\r\n\r\n协方差分析： Cov(X̄, Ȳ) = 0  (因样本独立)\r\n方差分解： $$\r\n\\begin{align*}\r\n\\text{Var}(\\bar{X} - \\bar{Y}) &amp;= \\text{Var}(\\bar{X}) +\r\n\\text{Var}(\\bar{Y}) \\\\\r\n&amp;= \\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2}\r\n\\end{align*}\r\n$$ **\r\n正态线性组合性质： 对于独立正态变量X ∼ N(μX, σX2)，Y ∼ N(μY, σY2)，有：\r\naX + bY ∼ N(aμX + bμY, a2σX2 + b2σY2)\r\n此处取a = 1, b = −1即得X̄ − Ȳ的分布\r\n\r\n\r\n实际计算示例\r\n从甲、乙两厂生产的钢丝总体 X, Y 中各取 50 截 1\r\n米长的钢丝作拉力强度试验，得 x̄ = 1208，ȳ = 1282。设钢丝的抗拉强度服从正态分布，且\r\nσx2 = 802，σy2 = 942，问甲、乙两厂钢丝的抗拉强度是否有显著差别（α = 0.05）？\r\n设甲、乙两厂钢丝抗拉强度总体均值分别为 μx 和 μy，考虑检验假设\r\nH0 : μx = μy;  H1 : μx ≠ μy\r\n由题意知 n1 = n2 = 50，σx = 80，σy = 94，α = 0.05，查 N(0, 1) 分布表，得 uα/2 = u0.025 = 1.96。由于\r\n$$\r\n|u| = \\left| \\frac{\\bar{x} - \\bar{y}}{\\sqrt{\\frac{\\sigma_x^2}{n_1} +\r\n\\frac{\\sigma_y^2}{n_2}}} \\right| = \\left| \\frac{1208 -\r\n1282}{\\sqrt{\\frac{80^2}{50} + \\frac{94^2}{50}}} \\right| = 4.24 &gt; 1.96\r\n$$ 故拒绝 H0，即在显著性水平 0.05\r\n下，认为两厂钢丝的抗拉强度有明显差别。\r\n对这类检验问题，当拒绝原假设 H0 时，若想进一步知道是\r\nμx &gt; μy，还是\r\nμx &lt; μy，可作如下判断：若\r\nU 的观测值 u &gt; uα/2，则认为\r\nμx &gt; μy；若\r\nu &lt; −uα/2，则认为\r\nμx &lt; μy。\r\n在例 8.3 中，u = −4.24 &lt; −1.96 = −uα/2，所以甲厂钢丝的抗拉强度明显低于乙厂\r\n$ _1^2$ 和 σ22\r\n都未知，但相等\r\n结论\r\n由于在 H0\r\n成立时，统计量 $$\r\nT = \\frac{\\bar{X} - \\bar{Y} - (\\mu_1 - \\mu_2)}{\\sqrt{\\frac{(n_1 -\r\n1)S_1^2 + (n_2 - 1)S_2^2}{n_1 + n_2 - 2}}} \\cdot \\sqrt{\\frac{n_1 n_2(n_1\r\n+ n_2 - 2)}{n_1 + n_2}} \\sim t(n_1 + n_2 - 2)\r\n$$\r\n于是，对给定的水平 α，查\r\nt 分布临界值表可得 tα/2(n1 + n2 − 2)，使得\r\nP(|T| &gt; tα/2(n1 + n2 − 2)) = α\r\n从而拒绝域为 W = (−∞, −tα/2(n1 + n2 − 2)) ∪ (tα/2(n1 + n2 − 2), +∞)\r\n由于检验统计量 T ∼ t(n1 + n2 − 2)，故此检验法也称\r\nt 检验法\r\n推导过程\r\n\r\n合并方差估计： 构造合并样本方差（Pooled\r\nVariance）： $$\r\nS_p^2 = \\frac{(n_1-1)S_1^2 + (n_2-1)S_2^2}{n_1+n_2-2}\r\n$$ 其中S12和S22分别为两样本的样本方差\r\n统计量构造： 在H0成立时（μ1 − μ2 = δ）：\r\n$$\r\nT = \\frac{(\\bar{X} - \\bar{Y}) - \\delta}{S_p\\sqrt{\\frac{1}{n_1} +\r\n\\frac{1}{n_2}}}\r\n$$\r\n分布推导：\r\n\r\n分子：$\\bar{X} - \\bar{Y} \\sim N\\left(0,\r\n\\sigma^2\\left(\\frac{1}{n_1} + \\frac{1}{n_2}\\right)\\right)$\r\n分母：$\\sqrt{\\frac{S_p^2}{\\sigma^2}} \\sim\r\n\\sqrt{\\frac{\\chi^2(n_1+n_2-2)}{n_1+n_2-2}}$\r\n由t分布定义可得： T ∼ t(n1 + n2 − 2)\r\n\r\n简化形式： 统计量可表示为： $$\r\nT = \\frac{\\bar{X} - \\bar{Y} - \\delta}{\\sqrt{\\frac{(n_1-1)S_1^2 +\r\n(n_2-1)S_2^2}{n_1+n_2-2}} \\cdot \\sqrt{\\frac{n_1n_2}{n_1+n_2}}}\r\n$$\r\n\r\n\r\n细节说明\r\n\r\n方差齐性假设： σ12 = σ22 = σ2\r\n合并方差的无偏性： E(Sp2) = σ2\r\n独立性的运用：\r\n\r\nX̄与S12独立，Ȳ与S22独立\r\n两样本相互独立\r\n\r\nt分布的形成： $$\r\n\\frac{N(0,1)}{\\sqrt{\\chi^2(k)/k}} \\sim t(k)\r\n$$ 此处k = n1 + n2 − 2\r\n\r\n\r\n实际计算示例\r\n在漂白工艺中考查温度对针织品断裂强度的影响，今在 70∘C 和 80∘C 分别作 8 次和 6\r\n次试验，测得各自的断裂强度 X\r\n和 Y 的观测值。经计算得 x̄ = 20.4，ȳ = 19.3167，s12 = 0.886，s22 = 1.0566，根据以往的经验，可以认为\r\nX 和 Y 均服从正态分布，且方差相等，在给定\r\nα = 0.10 时，问 70∘C 与 80∘C 对断裂强度有无显著差异？\r\n由题设，可假定 X ∼ N(μ1, σ2)，Y ∼ N(μ2, σ2)，考虑检验假设\r\n取上式定义的检验统计量 T，由 α = 0.10，查 t 分布表，得 tα/2(n1 + n2 − 2) = t0.05(12) = 1.782。由于\r\nT 的观测值 $$\r\n|t| = \\frac{|\\bar{x} - \\bar{y}|}{\\sqrt{\\frac{(n_1 - 1)s_1^2 + (n_2 -\r\n1)s_2^2}{n_1 + n_2 - 2}}} \\cdot \\sqrt{\\frac{n_1 n_2(n_1 + n_2 - 2)}{n_1\r\n+ n_2}} = 2.0504 &gt; 1.782\r\n$$ 即 t ∈ W，故拒绝 H0。换言之，在显著性水平\r\n0.10 下，认为 70∘C 与 80∘C 的断裂强度有明显差异。\r\nσ12 ≠ σ22\r\n且都未知，但n1 = n2 = n（配对问题）\r\n结论\r\n考虑检验假设 H0 : μ1 = μ2;  H1 : μ1 ≠ μ2\r\n令 Zi = Xi − Yi,  i = 1, 2, ⋯, n\r\n记 $$\r\nEZ_i = E(X_i - Y_i) = \\mu_1 - \\mu_2 = d  \\\\\r\nD(Z_i) = D(X_i - Y_i) = DX_i + DY_i = \\sigma_1^2 + \\sigma_2^2 = \\sigma^2\r\n$$ 则 (Z1, Z2, ⋯, Zn)\r\n是正态总体 Z ∼ N(d, σ2)\r\n的样本。于是检验假设（8.8）就等价于检验假设： H0 : d = 0;  H1 : d ≠ 0\r\n于是用 t 检验法，在 H0 成立时，统计量 $$\r\nT = \\frac{\\bar{Z}}{S} \\sqrt{n} \\sim t(n - 1)\r\n$$ 其中 $\\bar{Z} = \\frac{1}{n}\\sum_{i =\r\n1}^n Z_i$，$S^2 = \\frac{1}{n -\r\n1}\\sum_{i = 1}^n (Z_i - \\bar{Z})^2$，其拒绝域为 W = (−∞, −tα/2(n − 1)) ∪ (tα/2(n − 1), +∞)\r\n详细推导\r\n\r\n配对差值的构造： 定义配对差值： Zi = Xi − Yi,  i = 1, 2, ..., n\r\n由正态分布的性质： Zi ∼ N(d, σ2)\r\n其中： d = μ1 − μ2,  σ2 = σ12 + σ22\r\n样本均值与方差：\r\n\r\n样本均值： $$\r\n\\bar{Z} = \\frac{1}{n}\\sum_{i=1}^n Z_i \\sim N\\left(d,\r\n\\frac{\\sigma^2}{n}\\right)\r\n$$\r\n样本方差： $$\r\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (Z_i - \\bar{Z})^2\r\n$$\r\n\r\n检验统计量的构建： 当H0成立时（d = 0）： $$\r\nT = \\frac{\\bar{Z} - 0}{S/\\sqrt{n}} = \\frac{\\bar{Z}}{S}\\sqrt{n}\r\n$$\r\n分布推导：\r\n\r\n分子标准化： $$\r\n\\frac{\\bar{Z}}{\\sigma/\\sqrt{n}} \\sim N(0,1)\r\n$$\r\n分母调整： $$\r\n\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)\r\n$$\r\n由t分布定义： $$\r\nT = \\frac{N(0,1)}{\\sqrt{\\chi^2(n-1)/(n-1)}} \\sim t(n-1)\r\n$$\r\n\r\n拒绝域确定： 对于显著性水平α，查t分布表得临界值tα/2(n − 1)，拒绝域为：\r\n|T| &gt; tα/2(n − 1)\r\n\r\n实际问题示例\r\n为比较甲、乙两种橡胶轮胎的耐磨性，从两种轮胎中各随机地抽取 8\r\n个，又各取一个组成一对，再随机地选取 8 架飞机，将 8 对轮胎随机地分配给 8\r\n架飞机作耐磨试验，经飞行起落一段时间后，测得轮胎磨损量（单位：mg）数据如下：\r\n\r\n\r\n\r\n甲\r\n4900\r\n5220\r\n5500\r\n6020\r\n6340\r\n7660\r\n8650\r\n4870\r\n\r\n\r\n\r\n\r\n乙\r\n4930\r\n4900\r\n5140\r\n5700\r\n6110\r\n6880\r\n7930\r\n5010\r\n\r\n\r\n\r\n设轮胎磨损量都服从正态分布，问这两种轮胎的耐磨性有无显著差别（$ =\r\n0.05 $）.\r\n因是配对数据，令 $ Z = X - Y $，则由题意得 $ Z $ 的 8 个观测数据为：\r\n−30, 320, 360, 320, 230, 780, 720,  − 140\r\n则原检验问题化为： H0 : d = 0;  H1 : d ≠ 0\r\n经计算求得 $ {z} = 320 ， s^2 = 102200\r\n$。取定义统计量 $ T $，由 $ = 0.05 $，查 $ t $ 分布表，得 $ t_{/2}(n -\r\n1) = t_{0.025}(7) = 2.365 $。由于 $ T $ 的观测值 $$\r\n|t| = \\left| \\frac{\\bar{z}}{s} \\sqrt{8} \\right| \\approx 2.83 &gt; 2.365\r\n$$ 故拒绝 $ H_0 $，即在显著性水平 0.05\r\n下，认为两种轮胎的耐磨性有显著的差异\r\n正态总体方差的假设检验\r\n单个正态总体方差的检验\r\n设总体X服从正态分布N(μ, σ2)，(X1, X2, ⋯, Xn)为总体X的一个样本，欲检验假设： H0 : σ2 = σ02;  H1 : σ2 ≠ σ02\r\n其中σ02为已知常数。\r\nμ已知的情形\r\n结论\r\n构造统计量： $$\r\n\\chi^2 = \\frac{\\sum_{i=1}^n (X_i - \\mu)^2}{\\sigma_0^2}\r\n$$ 在假设H0成立时，服从χ2(n)分布，拒绝域为：\r\nW = (0, χ1 − α/22(n)) ∪ (χα/22(n), +∞)\r\n推导过程\r\n\r\n样本性质： 由于Xi ∼ N(μ, σ2)，有：\r\n$$\r\n\\frac{X_i - \\mu}{\\sigma_0} \\sim N(0,1)\r\n$$\r\n卡方统计量构造： 由卡方分布定义： $$\r\n\\sum_{i=1}^n \\left(\\frac{X_i - \\mu}{\\sigma_0}\\right)^2 \\sim \\chi^2(n)\r\n$$\r\n拒绝域确定： 对于显著性水平α，查卡方分布表得临界值χα/22(n)和χ1 − α/22(n)，使得：\r\n$$\r\nP(\\chi^2 \\leq \\chi^2_{1-\\alpha/2}(n)) = \\frac{\\alpha}{2} \\\\\r\nP(\\chi^2 \\geq \\chi^2_{\\alpha/2}(n)) = \\frac{\\alpha}{2}\r\n$$\r\n\r\nμ未知的情形\r\n结论\r\n构造统计量： $$\r\n\\chi^2 = \\frac{(n-1)S^2}{\\sigma_0^2}\r\n$$ 在假设H0成立时，服从χ2(n − 1)分布，拒绝域为：\r\nW = (0, χ1 − α/22(n − 1)) ∪ (χα/22(n − 1), +∞)\r\n推导过程\r\n\r\n样本方差性质： 样本方差： $$\r\nS^2 = \\frac{1}{n-1}\\sum_{i=1}^n (X_i - \\bar{X})^2\r\n$$\r\n卡方统计量构造： 由统计学定理： $$\r\n\\frac{(n-1)S^2}{\\sigma_0^2} \\sim \\chi^2(n-1)\r\n$$\r\n拒绝域确定： 对于显著性水平α，查卡方分布表得临界值χα/22(n − 1)和χ1 − α/22(n − 1)。\r\n\r\n实际计算示例\r\n例题：某机器生产的零件长度服从N(μ, σ2)，现抽取16个零件测得样本方差s2 = 0.025。检验总体方差是否为0.02（α = 0.05）。\r\n解题步骤：\r\n\r\n建立假设： H0 : σ2 = 0.02  vs  H1 : σ2 ≠ 0.02\r\n计算检验统计量： $$\r\n\\chi^2 = \\frac{(n-1)s^2}{\\sigma_0^2} = \\frac{15 \\times 0.025}{0.02} =\r\n18.75\r\n$$\r\n确定临界值： 查卡方分布表得χ0.0252(15) = 27.488，χ0.9752(15) = 6.262\r\n决策规则：\r\n\r\n拒绝域：(0, 6.262] ∪ [27.488, +∞)\r\n由于6.262 &lt; 18.75 &lt; 27.488，未落入拒绝域\r\n\r\n结论： 在α = 0.05水平下不能拒绝H0，认为总体方差与0.02无显著差异。\r\n\r\n两个正态总体的情况\r\n","categories":["数学类","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计"]},{"title":"魔女恋爱日记攻略","url":"/posts/44212.html","content":"\r\n"},{"title":"魔改过程中为Hexo博客添加自定义css和js","url":"/posts/35058.html","content":"这个问题其实官方文档有提到过，但是很多人可能就是看一眼也忘记了，没有去留意这件事，在这里我再说一下\r\n\r\n文件的存放位置\r\n如果想魔改和美化，添加自定义 css 和 js 文件是不可避免的。\r\n添加css js 和 添加Page 差不多，都是在 博客根目录下 的 source\r\n文件夹中创建新的文件夹然后存放\r\n\r\n\r\nimage-20250519105448777\r\n\r\n我这里 scripts文件夹 就是存放 js 文件的，css文件夹就是存放 css 的\r\n\r\n文件的引入\r\n一般来说，我们都是在主题配置文件（_config.butterfly.yml）里面的inject引入。\r\n主题文档对这个yml标签的说法如下：\r\n\r\n如想添加额外的 js/css/meta 等等东西，可以在 Inject 里添加，支持添加到\r\nhead(\r\n\r\n标签之前)和 bottom(\r\n\r\n标签之前)。\r\n请注意：以标准的 html 格式添加内容\r\n例如\r\ninject:  head:  \t- &lt;link rel=&quot;stylesheet&quot; href=&quot;/self.css&quot;&gt;  bottom:  \t- &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;\r\n留意: 如果你的网站根目录不是’/’,使用本地图片时，需加上你的根目录。\r\n例如：网站是https://yoursite.com/blog,引用css/xx.css，则设置为&lt;link rel=\"stylesheet\" href=\"/blog/css/xx.css\"&gt;\r\n\r\n所以说，css文件一般在head引入，js文件一般在bottom里引入\r\n例如引入css文件夹里面的style.css和js文件夹里面的script.js，可以这样写\r\ninject:  head:    # 自定义css    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css?1&quot;&gt;    # 静态文件后面加个  ?任意内容  可以在每次更新之后用户自动重新请求.    # 例如添加 ?1 ,在修改此文件后改成 ?2 ,用户访问你的网站时,不会使用本地的缓存,而是请求新的内容。没修改的话就不用动。  bottom:    # 自定义js    - &lt;script src=&quot;/js/script.js?1&quot;&gt;&lt;/script&gt;    # 引入多个文件就直接往下复制一行改一下文件名即可，如下：    - &lt;script src=&quot;/js/script1.js?1&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;/js/script2.js?1&quot;&gt;&lt;/script&gt;\r\n注意：路径最前面是斜杠，而不是点斜杠，即/xx/xxx.js，而不是./xx/xxx.js。\r\n\r\n部分引用自 Hexo博客添加自定义css和js文件\r\n\r\n","tags":["Hexo","教程","配置相关","配置文件","教程类","使用知识"]},{"title":"galgame妹妹推荐转自七海妹","url":"/posts/31531.html","content":"有群友希望我转载这个，那我就转载了\r\n更新时间 2021·12·23 更新内容：推妹妹破百，初代表格诞生\r\n前排提醒：仅为群名~“七海妹”个人主观意见，如有与你不和者，就无视我，没必要争吵。本人一年游玩时间，耗时30小时制作而成，难免有失误，还请告知我更改。本人主看重妹妹，不对作品本身评价，所以废萌评分会高一点。\r\n更新时间 2022·7·26晚\r\n更新内容1：重置评分系统，由原来的SS&lt;SS+&lt;SSS-&lt;SSS 更改成\r\nS&lt;SA&lt;SX&lt;SS&lt;=SAAA&lt;=SSA&lt;SSS\r\n更新内容2：增加50位妹妹，其中15名生肉，1名不能攻略\r\n更新内容3：加入鼠标放在妹妹名字上显示立绘功能 更新耗时25小时\r\n更新时间 2023·1·27下午\r\n更新内容1：添加妹妹、兄妹、妹线这三个评价（等级为：稀烂、拉跨、不太行、凑合、一般、还行、良好\r\n、不错、优秀、极好、完美） 更新内容2：增加23名妹妹，其中11名生肉\r\n更新内容3：22年我二刷了不少妹妹，多刷的评价至少上升一个等级\r\n更新内容4：校对了血缘，更改几个不严谨的\r\n提醒：血缘为？？？是防止剧透，\r\n评分的负XX不是差，比如空羽妹妹非常废柴，但粘人讨喜因此是负极好，以此类推\r\n更新时间 2024·9·10晚\r\n更新内容1：总妹妹数突破200位，增加31位妹妹，生肉26名\r\n更新内容2：生肉有汉化的添加在其作品后，部分有AI翻译的也如此\r\n更新内容3：增加提醒一栏在最后，备注一些注意的，以及避雷提醒等等\r\n更新内容4：再次校对血缘加入双胞胎\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n笹浦铃奈\r\n\r\nSSS妹控\r\n妹妹：负极好\r\n兄妹：优秀\r\n妹线：不错\r\n妹妹色诱术\r\n\r\n\r\n\r\n《缘染此叶，化作恋红》\r\n\r\n\r\n小恶魔\r\n灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n争风吃醋\r\n良好\r\n幼时多病\r\n寄宿\r\n\r\n有孩子、猫娘装、黑丝\r\n\r\n\r\n妹控\r\n\r\nS\r\n妹控福音\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n莲乃 咲\r\n\r\nSSS活\r\n妹妹：极好\r\n兄妹：还行\r\n妹线：良好\r\n为哥哥的诞生献上一份兄妹禁断之恋\r\n\r\n\r\n\r\n《幸福噩梦》\r\n\r\n\r\n情人级\r\n黑发\r\n青梅竹马\r\n欧尼桑\r\n剧情作\r\n美少女\r\n82分\r\n娟好静秀\r\n正常\r\n拯救男主\r\n男主独居\r\n\r\n有孩子、黑丝\r\n\r\n\r\n\r\n\r\nA\r\n真假妹三角恋\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n内藤 舞亚\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：良好\r\n爱着你，比爱这个世界还爱你\r\n\r\n\r\n\r\n《幸福噩梦》\r\n\r\n\r\n恶魔级\r\n灰色\r\n亲妹\r\n欧尼酱\r\n剧情作\r\n哥特萝莉\r\n86分\r\n调皮捣蛋\r\n良好\r\n？？？\r\n男主独居\r\n\r\n膝枕\r\n\r\n\r\n\r\n虐\r\nB\r\n防止剧透？？？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n才城花林\r\n\r\nSAAA\r\n妹妹：极好\r\n兄妹：不错\r\n妹线：还行\r\n超级美少女竟是我妹妹？\r\n\r\n\r\n\r\n《爱丽亚的明日盛典》\r\n\r\n\r\n美少女\r\n黑发\r\n亲妹\r\n莲哥\r\n战斗\r\n美少女\r\n90分\r\n贤妻良母\r\n小陌生\r\n6年不见\r\n加表姐共三人\r\n\r\n摸头杀、膝枕、黑丝\r\n\r\n\r\n\r\n\r\nS\r\n没啥违背道德感的亲妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n在原七海\r\n\r\nSSS优\r\n妹妹：完美\r\n兄妹：优秀\r\n妹线：还行\r\n只想和你在一起\r\n\r\n\r\n\r\n《Riddle Joker》\r\n\r\n\r\n妹妹级\r\n金发\r\n义妹\r\n欧尼酱\r\n超能力\r\n美少女\r\n99分\r\n全能妹妹\r\n亲密无间\r\n都被收养\r\n学校住宿\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nS\r\n人设完美\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n花咲樱花\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：凑合\r\n接受失去的感情\r\n\r\n\r\n\r\n《红线物语》\r\n\r\n\r\n粘人级\r\n黑发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n萝莉\r\n100分\r\n相依为命\r\n两小无猜\r\n父母双亡\r\n兄妹同居\r\n\r\n摸头杀、婚纱、裸体围裙\r\n\r\n\r\n兄控\r\n\r\nA\r\n贤妻良母\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大藏里想奈\r\n\r\nSSS陪伴\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：优秀\r\n山重水复疑无路，柳暗花明又一村\r\n\r\n\r\n\r\n《少女理论及周边》\r\n\r\n\r\n童话级\r\n黑发\r\n同父异母\r\n欧尼酱\r\n剧情向\r\n美少女\r\n94分\r\n互相依靠\r\n舍己为人\r\n家族竞争\r\n男主女装独居\r\n\r\n公主抱、里想奈式拥抱\r\n\r\n\r\n兄控\r\n\r\nA\r\n为哥哥愿意放弃所有\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n朝仓由梦\r\n\r\nSSA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：优秀\r\n相守一生的誓言\r\n\r\n\r\n\r\n《初音岛2》\r\n\r\n\r\n情侣级\r\n灰色\r\n义妹\r\n欧尼桑\r\n剧情向\r\n美少女\r\n96分\r\n家熊外乖\r\n正常\r\n？？？\r\n住隔壁\r\n\r\n\r\n\r\n\r\n\r\n感人/催泪\r\nC\r\n先推姐姐会剧透\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新田一歌\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n十年之约，哥哥由我来守护！\r\n\r\n\r\n\r\n《如月金星》\r\n\r\n\r\n初恋级\r\n金发\r\n义妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n98分\r\n讨厌哥哥\r\n偏差\r\n兄被收养\r\n兄妹同居\r\n\r\n婚纱、孩子\r\n\r\n\r\n\r\n2个be\r\nB\r\n妹妹行动让我感动\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n彩迁日和\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n把我的人生奉献给哥哥\r\n\r\n\r\n\r\n《青春期的五月雨》\r\n\r\n\r\n可爱级\r\n金发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n娇小能干\r\n亲密无间\r\n对抗真姐\r\n母儿女三人\r\n\r\n动态摸头杀\r\n\r\n\r\n兄控\r\n\r\nS\r\n2021第一届可爱妹妹排行榜第一名（自荐）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鸣海兔亚\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n共渡未见的难关\r\n\r\n\r\n\r\n《任性highspec》\r\n\r\n\r\n萌兔级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n白发红眼\r\n93分\r\n相依为命\r\n正常\r\n离家出走\r\n兄妹同居\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n妹妹游戏宅，感情线不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n群云空羽\r\n\r\nSSS妹控\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：不错\r\n妹控真神体降临\r\n\r\n\r\n\r\n《星恋twinkle》\r\n\r\n\r\n妹控之神\r\n银发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n100分\r\n相依为命\r\n形影不离\r\n母死父失\r\n寄宿、同居\r\n\r\n裸体围裙、裸体缎带\r\n\r\n\r\n妹控\r\n甜蜜至极\r\nA\r\n妹控究极福音、难找第二个\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n瓜生樱乃\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n真正意义上的兄妹恋\r\n\r\n\r\n\r\n《纯白交响曲》\r\n\r\n\r\n兄妹级\r\n蓝发\r\n？？？\r\n欧尼酱/桑\r\n废萌\r\n美少女\r\n97分\r\n勤劳能干\r\n优秀\r\n？？？\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n兄妹恋\r\nB\r\n兄妹恋过程写的很好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤守由宇\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n好不容易追上你，这次绝对不放手\r\n\r\n\r\n\r\n《恋骑士》\r\n\r\n\r\n表白级\r\n蓝发\r\n亲妹\r\n欧尼桑\r\n打斗\r\n美少女\r\n98分\r\n勤学苦练\r\n优秀\r\n父死妹病\r\n学园住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG美的窒息，比较现实的兄妹恋\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n伏见巴\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：一般\r\n妹线：还行\r\n我对你的爱是没有上限的\r\n\r\n\r\n\r\n《三千心世界，梦终将实现》\r\n\r\n\r\n兄控级\r\n黑发\r\n同父异母\r\n欧尼桑\r\n悬疑\r\n美少女\r\n97分\r\n平近易人\r\n妹好恋差\r\n异性待哥\r\n学校住宿\r\n\r\n\r\n\r\n\r\n恋兄\r\n\r\nB\r\n前期逃妹（有隐藏实妹）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小森江铃\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：一般\r\n妹线：一般\r\n还好再次遇见你\r\n\r\n\r\n\r\n《青春好奇相伴的三角恋爱》\r\n\r\n\r\n贤妻级\r\n浅粉红\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n94分\r\n温柔体贴\r\n良好\r\n兄妹分离\r\n全家6人\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n结局意料之外，情理之中\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小森江七瑠\r\n\r\nSA\r\n妹妹：一般\r\n兄妹：一般\r\n妹线：一般\r\n不动不说话确实是个美女\r\n\r\n\r\n\r\n《青春好奇相伴的三角恋爱》\r\n\r\n\r\n反差萌\r\n蓝发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n颜艺\r\n良好\r\n正常\r\n全家7人\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n小时候挺可爱的，就是颜艺了点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新海天\r\n\r\nSSS活泼\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：良好\r\n兄妹相声\r\n\r\n\r\n\r\n《9-nine-天色天歌天籁音》\r\n\r\n\r\n活泼级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n超能力\r\n美少女\r\n100分\r\n活泼可爱\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n有be\r\nS\r\n除了男主没说喜欢妹妹其他都优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n月社妃\r\n\r\nSSS绝望\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：优秀\r\n无可奈何却又令人神往的爱恋\r\n\r\n\r\n\r\n《纸上魔法使》\r\n\r\n\r\n纸魔级\r\n金发\r\n亲妹\r\n欧尼桑\r\n神作\r\n美少女\r\n88分\r\n成熟稳重\r\n？？？\r\n离家出走\r\n寄宿\r\n\r\n\r\n\r\n\r\n\r\n虐\r\nS\r\n哎，不是亲妹就好了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n皆神沙久耶\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：不错\r\n思念的终点站\r\n\r\n\r\n\r\n《黄昏的禁忌之药》\r\n\r\n\r\n妹药级\r\n黑发\r\n亲妹\r\n欧尼桑\r\n剧情作\r\n美少女\r\n93分\r\n风趣幽默\r\n不分彼此\r\n母死\r\n寄宿\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nB\r\n大名鼎鼎的妹药\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第2批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n上川沙矢\r\n\r\nSAAA颜\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：一般\r\n取回属于我们兄妹的时光\r\n\r\n\r\n\r\n《樱舞恋花恋模样》\r\n\r\n\r\n女主级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n83分\r\n黑长直\r\n恋人\r\n兄妹分离\r\n男主独居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n就只有颜值很顶\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浅叶 小奈美\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n理想中的兄妹关系\r\n\r\n\r\n\r\n《恋花绽放樱飞时》\r\n\r\n\r\n妹妹级\r\n银发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n活泼撒娇\r\n亲密无间\r\n父母双亡\r\n义母三人\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n永不放弃的信念\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n木下卯月\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n只属于我们的恋爱故事\r\n\r\n\r\n\r\n《密语》\r\n\r\n\r\n情人级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n妹单\r\n大姐姐\r\n91分\r\n成熟\r\n寻找\r\n兄妹分离\r\n男主独居\r\n\r\n\r\n\r\n\r\n\r\n现代相遇\r\nA\r\n多结局，全he\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n野野宫蓝\r\n\r\nSSS兄控\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n妹控养成计划\r\n\r\n\r\n\r\n《春季限定》\r\n\r\n\r\n正妻级\r\n浅粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼可爱\r\n妹控兄控\r\n被父抛弃\r\n学校住宿（同居）\r\n\r\n兄控言论\r\n\r\n\r\n兄控\r\n\r\nB\r\n当极致撒娇遇上妹控\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小春\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n再会，与妹同居\r\n\r\n\r\n\r\n《心猫~与再会的妹妹展开全新关系》\r\n\r\n\r\n萝莉级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n妹单\r\n萝莉\r\n100分\r\n娇小可爱\r\n亲密\r\n兄妹分开\r\n兄妹同居\r\n\r\n裸体围裙\r\n\r\n\r\n\r\n\r\nB\r\n可爱的萝莉妹妹还想啥呢\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n成海真莉音\r\n\r\nSS\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：还行\r\n一生只为哥哥而活\r\n\r\n\r\n\r\n《鲸神》\r\n\r\n\r\n兄控级\r\n红发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n92分\r\n重度兄控\r\n甜蜜\r\n被收养\r\n学校住宿\r\n\r\n婚纱\r\n\r\n\r\n重度兄控\r\n\r\nB\r\n甜度十足\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神森樱乃\r\n\r\nSSS催泪\r\n妹妹：负极好\r\n兄妹：优秀\r\n妹线：极好\r\n我们永远在一起吧\r\n\r\n\r\n\r\n《盛开的钢琴之森下》\r\n\r\n\r\n神作级\r\n暗肉色\r\n义妹\r\n兄长大人\r\n泣作\r\n美少女\r\n94分\r\n体弱多病\r\n当世无双\r\n被收养\r\n住隔壁\r\n\r\n44秒定生死\r\n\r\n\r\n兄妹情\r\n催泪\r\nB\r\n妹妹催泪巅峰作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n沢井 夏叶\r\n\r\nSX萝莉\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n牵着手永远不放开哦\r\n\r\n\r\n\r\n《茂神奇谈》\r\n\r\n\r\n女儿级\r\n灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n三形态\r\n98分\r\n病弱\r\n纯粹\r\n父母双亡\r\n寄宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nB\r\n剧情超长\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n优\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：还行\r\n妹线：负极好\r\n赌上自己的一切，这场战斗必须赢！\r\n\r\n\r\n\r\n《VGNEO》有大量ntr，be牛\r\n\r\n\r\n女主级\r\n红发\r\n？？？\r\n欧尼酱\r\n战斗\r\n女仆\r\n90分\r\n坚强不屈\r\n亲密\r\n？？？\r\n同居\r\n\r\n\r\n\r\n\r\n恋兄\r\n氛围打斗\r\nC\r\n打斗超燃，氛围超好（结局算be吧？）→→→\r\n\r\n\r\n\r\n\r\n某种意义上算牛，谨慎推，打斗很优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大泉栞\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n亲妹现实版\r\n\r\n\r\n\r\n《实妹相伴的大泉君》\r\n\r\n\r\n现实级\r\n浅肉色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n知情达理\r\n距离感\r\n与父吵架\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n带点剧情\r\nB\r\n感情线非常不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n麻衣\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\ngal攻略后的妹妹\r\n\r\n\r\n\r\n《实妹相伴的大泉君》\r\n\r\n\r\n想象级\r\n白毛\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n天真可爱\r\n妹主动\r\n？？？\r\n住隔壁\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n人挺好，结局不太好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n北条实里果\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：良好\r\n逃不掉的命运\r\n\r\n\r\n\r\n《逃避行》\r\n\r\n\r\n隐藏级\r\n红发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n89分\r\n天真可爱\r\n隐藏恋兄\r\n正常\r\n家庭生活\r\n\r\n摸头杀\r\n\r\n\r\n隐藏恋兄\r\n\r\nC\r\n两个结局，不同命运，都he\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n泽渡七凪\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n把恋爱化作语言\r\n\r\n\r\n\r\n《硬要无视与你的未来》\r\n\r\n\r\n妹管严\r\n白毛\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n94分\r\n活泼可爱\r\n妻管严\r\n？？？\r\n加母三人\r\n\r\n\r\n\r\n\r\n兄控\r\n甜中带刀\r\nB\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n天宫雫\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：一般\r\n妹线：还行\r\n一起共度明天而努力活下去\r\n\r\n\r\n\r\n《死神之吻乃离别之味》\r\n\r\n\r\n恋兄级\r\n黑发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n89分\r\n傲娇\r\n距离感\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n恋兄\r\n\r\nB\r\n兄妹相互拯救的故事\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长沢 星歌\r\n\r\nSA\r\n妹妹：一般\r\n兄妹：一般\r\n妹线：不太行\r\n游戏风云\r\n\r\n\r\n\r\n《心灵重启》\r\n\r\n\r\n\r\n黑发\r\n亲妹\r\n大哥\r\n废萌\r\n美少女\r\n87分\r\n胆小内向\r\n距离感\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB/S\r\n作品非常新颖，有意思，在游戏中发生故事，颜值都挺高，但作为妹妹却不够格，\r\n感情线如同拔作，游戏角色又不能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长沢 雪樱\r\n\r\nSA\r\n妹妹：一般\r\n兄妹：一般\r\n妹线：不太行\r\n游戏风云\r\n\r\n\r\n\r\n《心灵重启》\r\n\r\n\r\n\r\n黑发\r\n亲妹\r\n大哥\r\n废萌\r\n美少女\r\n88分\r\n家庭主妇\r\n距离感\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB/A\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第3批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鹰仓杏铃\r\n\r\nSSS柔\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n金发撒娇妹代表\r\n\r\n\r\n\r\n《Clover Day’s》\r\n\r\n\r\n公主级\r\n金发\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n撒娇可爱\r\n亲密无间\r\n男主被养\r\n全家生活\r\n\r\n\r\n\r\n\r\n兄控/妹控\r\n甜蜜\r\nS\r\n温馨甜蜜，妹控福音、剧情也不差，白学羞萝场\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鹰仓杏璃\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n永远支持哥哥\r\n\r\n\r\n\r\n《Clover Day’s》\r\n\r\n\r\n双马尾\r\n灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n傲娇\r\n亲密无间\r\n男主被养\r\n全家生活\r\n\r\n\r\n\r\n\r\n兄控/妹控\r\n\r\nA\r\n温馨甜蜜，妹控福音、剧情也不差，白学羞萝场\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n春日井咲良\r\n\r\nSSS妹控\r\n妹妹：极好\r\n兄妹：极好\r\n妹线：良好\r\n想要把谎言变成真实\r\n\r\n\r\n\r\n《隙间樱花与谎言都市》\r\n\r\n\r\n妹控级\r\n银发\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n100分\r\n霸道柔弱\r\n相依为命\r\n被母虐待\r\n住宿\r\n\r\n\r\n\r\n\r\n妹控\r\n先苦后甜\r\nA\r\n离家出走，相依为命，我的最爱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n山神水绪里\r\n\r\nSS颜\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n你对于我来说是特别的\r\n\r\n\r\n\r\n《清澄如境之水面上》\r\n\r\n\r\n女神级\r\n黑发\r\n亲妹\r\n欧尼\r\n废萌\r\n美少女\r\n90分\r\n强大\r\n爱慕\r\n被封神\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n拔作向的废萌，颜值高，剧情一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仓野绘麻\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n为欧尼酱而生\r\n\r\n\r\n\r\n《仓野家双胞胎的故事》\r\n\r\n\r\n可爱级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n97分\r\n可爱撒娇\r\n亲密\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n撒娇卖萌小萝莉\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仓野弥惠\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n把我献给哥哥\r\n\r\n\r\n\r\n《仓野家双胞胎的故事》\r\n\r\n\r\n可爱级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n可爱\r\n亲近\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n标准废萌\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n间宫 羽咲\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：不错\r\n隐藏在地狱深渊的妹控魔神器\r\n\r\n\r\n\r\n《美好的每一天》素晴日\r\n\r\n\r\n埋葬级\r\n桃色\r\n同父异母\r\n欧尼酱\r\n神作\r\n萝莉\r\n88分\r\n娇小可爱\r\n守护\r\n？？？\r\n？？？\r\n\r\n膝枕\r\n\r\n\r\n妹控\r\n恶心人\r\nB\r\n大名鼎鼎素晴日，废萌玩家不建议推，\r\n\r\n\r\n\r\n\r\n大量牛头人，不过妹没有，不建议推，难受一个月，后劲太大\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n白藤友菜\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n魔法少女之妹妹\r\n\r\n\r\n\r\n《Animal☆Panic》\r\n\r\n\r\n可爱级\r\n浅粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n92分\r\n天真无邪\r\n守护\r\n哥父妹母\r\n兄妹同居\r\n\r\n摸头杀，婚纱\r\n\r\n\r\n\r\n\r\nA\r\n从此改变我对短发妹妹的看法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小雪（全年龄）\r\n\r\nSAAA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：良好\r\n四世轮回千年之恋\r\n\r\n\r\n\r\n《SAKURA~雪月华》\r\n\r\n\r\n千年之恋\r\n红/黑\r\n表/堂妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n93分\r\n天真善良\r\n亲和\r\n？？？\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n轮回\r\nA\r\n妹世差点，第一世我非常喜欢\r\n\r\n\r\n\r\n\r\n仅开局第四世是妹妹，单妹妹剧情不够多\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n沙那\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：不错\r\n妹线：凑合\r\n让哥哥只爱我一个人\r\n\r\n\r\n\r\n《吃醋大作战》\r\n\r\n\r\n满好感度\r\n黑发\r\n亲妹\r\n欧尼酱\r\n半拔\r\n美少女\r\n91分\r\n痴迷\r\n保护\r\n正常\r\n加母三人\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n典型的哥哥成分不足\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n黑川雫\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n为成为兄妹而努力着\r\n\r\n\r\n\r\n《家庭教师露美美》\r\n\r\n\r\n隐藏级\r\n灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n83分\r\n和善\r\n逐渐认可\r\n正常\r\n加女主同居\r\n\r\n婚纱\r\n\r\n\r\n\r\n\r\nC\r\n就表白勇猛\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小河坂 千波\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：还行\r\n你的幸福就是我的幸福\r\n\r\n\r\n\r\n《星空的记忆》\r\n\r\n\r\n活泼级\r\n红发\r\n同母异父\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n热情好客\r\n看护\r\n父母双亡\r\n加姨同居\r\n\r\n裸体围裙、女仆装\r\n\r\n\r\n妹控\r\n自然\r\nB\r\n在妹控道路越走越远，很自然又亲密的兄妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n萤铃音\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：还行\r\n一心同体的搭档\r\n\r\n\r\n\r\n《星辰恋曲的白色永恒》\r\n\r\n\r\n拥有级\r\n白毛\r\n同父异母\r\n欧尼酱\r\n废萌\r\n美少女\r\n61分\r\n进攻型\r\n隐藏\r\n？？？\r\n男主独居\r\n\r\n公主抱\r\n\r\n\r\n\r\n\r\nB\r\n隐藏妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n皆树\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：不太行\r\n妹线：一般\r\n你死了，我会为你哭\r\n\r\n\r\n\r\n《My Sweet Home》\r\n\r\n\r\n禁忌 级\r\n暗肉色\r\n义妹\r\n大哥\r\n妹单\r\n美少女\r\n90分\r\n贤惠\r\n加深型\r\n被收养\r\n加父同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n短小精悍，又禁忌感\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浦部 葵\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：凑合\r\n一起向未来出发\r\n\r\n\r\n\r\n《鬼的捉迷藏》FD妹线\r\n\r\n\r\n可靠级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n可靠\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n遗憾之作，本体优秀，FD妹线拉跨\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n樱庭 水穗\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：一般\r\n天使降临\r\n\r\n\r\n\r\n《LOVELYQUEST》\r\n\r\n\r\n天使级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n温柔贤惠\r\n甜蜜\r\n正常\r\n兄妹同居\r\n\r\n膝枕，和服\r\n\r\n\r\n\r\n\r\nS\r\n感情线不错，温馨甜蜜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n丘野日向（全年龄）\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：良好\r\n你就是我的唯一\r\n\r\n\r\n\r\n《Wind-a breath of heart-》\r\n\r\n\r\n兄妹情\r\n红发\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼洒脱\r\n兄妹情\r\n父死母失\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n妹控\r\n兄妹向\r\nB\r\n少有的体现纯粹兄妹情的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n天濑小雪\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：一般\r\n让我取回曾经美好的岁月\r\n\r\n\r\n\r\n《Magus ~世界树》\r\n\r\n\r\n少女级\r\n实木色\r\n义妹\r\n欧尼酱\r\n魔法\r\n美少女\r\n81分\r\n学霸型\r\n一般\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n各方面都很一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长濑湊\r\n\r\nSSS恋\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n我的生命中需要你\r\n\r\n\r\n\r\n《染红的街道》\r\n\r\n\r\n美少女\r\n灰色\r\n亲妹\r\n欧尼桑/酱\r\n剧情向\r\n美少女\r\n100分\r\n美少女\r\n间隔\r\n正常\r\n兄妹同居\r\n\r\n摸头杀，拥抱三连杀\r\n\r\n\r\n\r\n兄妹恋\r\nA\r\n从相爱到父母同意，比较全面的妹作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n濑名美优树\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n只为寻找你\r\n\r\n\r\n\r\n《妹之形》\r\n\r\n\r\n隐藏级\r\n浅粉红\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n63分\r\n害羞\r\n恋人成妹\r\n兄妹分离\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nB\r\n还有其他隐藏妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鹭泽缘（全年龄）\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n心灵拯救\r\n\r\n\r\n\r\n《秋之回忆4~从今以后》\r\n\r\n\r\n猫咪级\r\n白毛\r\n？？？\r\n欧尼酱\r\n三角恋\r\n美少女\r\n99分\r\n撒娇可爱\r\n开始接近\r\n正常\r\n男主独居\r\n\r\n\r\n\r\n\r\n\r\n三角恋\r\nB\r\n妹妹可爱，剧情不错，有点虐妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤堂 加奈\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：优秀\r\n妹线：不错\r\n妹控杀手与妹控福音共存\r\n\r\n\r\n\r\n《加奈，欢迎回来》\r\n\r\n\r\n妹控鼻祖\r\n黑发\r\n？？？\r\n欧尼酱\r\n三角恋\r\n美少女\r\n93分\r\n柔弱\r\n守护\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n5个be，1个he，\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n片濑雪希\r\n\r\nSS\r\n妹妹：还行\r\n兄妹：良好\r\n妹线：还行\r\n愿永不改变，愿永不分离\r\n\r\n\r\n\r\n《水色》\r\n\r\n\r\n回忆级\r\n浅红\r\n义妹\r\n欧尼酱\r\n伪三角恋\r\n美少女\r\n94分\r\n贤惠刻苦\r\n隐藏\r\n被收养\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n，短小精悍，共通线比较虐妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n野乃崎翼\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：凑合\r\n妹线：还行\r\n妹控监狱\r\n\r\n\r\n\r\n《假如明日天放晴》很虐妹！\r\n\r\n\r\n虐心级\r\n茶色\r\n义妹\r\n欧尼桑\r\n三角恋\r\n美少女\r\n93分\r\n刻苦自卑\r\n不敌姐姐\r\n被收养\r\n多女主居住\r\n\r\n\r\n\r\n\r\n虐妹\r\n虐妹\r\nB\r\n虐妹巅峰作，全程压抑，没病不建议推\r\n\r\n\r\n\r\n\r\n姐兄妹三角恋剧情，很虐妹！！！\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第4批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n乙原恋\r\n\r\nSSS粘人\r\n妹妹：完美\r\n兄妹：优秀\r\n妹线：优秀\r\n爱会让人倾尽所有，恋则会赋予人拯救\r\n\r\n\r\n\r\n《由梦想和色彩编制而成》\r\n\r\n\r\n亲密级\r\n金发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n100分\r\n勤劳能干\r\n亲密无双\r\n正常\r\n兄妹同居\r\n\r\n裸体围裙\r\n\r\n\r\n妹控\r\n拯救\r\nS\r\n感情线，剧情，人设都很优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n月岛和羽\r\n\r\nSSS萝莉\r\n妹妹：负极好\r\n兄妹：不错\r\n妹线：良好\r\n只想和你在一起\r\n\r\n\r\n\r\n《恋爱教室》\r\n\r\n\r\n可爱级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n娇小可爱\r\n温顺\r\n正常\r\n兄妹同居\r\n\r\n有孩子\r\n\r\n\r\n\r\n甜蜜\r\nS\r\n纯甜蜜作，家中有妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n苇原希里奈\r\n\r\nSS颜\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n化解不可能的未来\r\n\r\n\r\n\r\n《新娘太好找了我很方》\r\n\r\n\r\n伪天使\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n可靠努力\r\n亲近\r\n家族\r\n多女主同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n共通线妹妹戏份少，剧情一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n可可音（全年龄）\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n不甘只做妹妹\r\n\r\n\r\n\r\n《萌夏》\r\n\r\n\r\n转变级\r\n浅蓝灰\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n害羞努力\r\n亲近\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n麻雀虽小，五脏俱全，非亲似更亲\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘茉莉\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n不会让你受伤\r\n\r\n\r\n\r\n《妹选总选举》\r\n\r\n\r\n小公主\r\n金发\r\n同父异母\r\n欧尼酱\r\n废萌\r\n萝莉\r\n79分\r\n傲娇\r\n距离感\r\n正常\r\n亲兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n傲娇，金发，毒舌，大小姐，萝莉\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘四叶\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n愿意成为哥哥的妹妹\r\n\r\n\r\n\r\n《妹选总选举》\r\n\r\n\r\n小七海\r\n暗灰色\r\n同父异母\r\n欧尼酱\r\n废萌\r\n美少女\r\n83分\r\n实用能干\r\n亲和\r\n正常\r\n亲兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n起床温柔叫醒，做饭，学习都优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n樱木灰\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：良好\r\n只属于我的灰姑娘\r\n\r\n\r\n\r\n《恋爱少女崩坏的人格》\r\n\r\n\r\n霸道级\r\n紫发\r\n表/堂妹\r\n欧尼桑\r\n女装\r\n美少女\r\n74分\r\n成长型\r\n男好女差\r\n体弱多病\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n不知道男主女装，共通剧情比较优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神林丽\r\n\r\nSAAA颜\r\n妹妹：负优秀\r\n兄妹：良好\r\n妹线：还行\r\n想变得更加喜欢你\r\n\r\n\r\n\r\n《求神太多我的未来糟糕了》\r\n\r\n\r\n恋人级\r\n金发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n81分\r\n活泼洒脱\r\n天降\r\n胎死腹中\r\n兄妹同居\r\n\r\n膝枕\r\n\r\n\r\n\r\n\r\nS\r\n天降实妹不好接受\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神林真央\r\n\r\nSX颜\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：凑合\r\n让我做你的新娘\r\n\r\n\r\n\r\n《求神太多我的未来糟糕了》\r\n\r\n\r\n路人级\r\n浅黄色\r\n表/堂妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n65分\r\n害羞胆小\r\n路人\r\n正常\r\n男女主同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n路人级表妹，戏份少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n炽月\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n不忍哥哥离我而去\r\n\r\n\r\n\r\n《樱花盛典》\r\n\r\n\r\n表面级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n实力型\r\n距离感\r\n留学归来\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n剧情不行，还有个妹妹，不过是不能推，双飞\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n折口美羽\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：良好\r\n我只凝视着你\r\n\r\n\r\n\r\n《追亿夏色年华》\r\n\r\n\r\n相依为命\r\n玫瑰红\r\n双胞胎\r\n欧尼酱\r\n剧情向\r\n美少女\r\n100分\r\n相依为命\r\n亲密无间\r\n父母自杀\r\n同居、住宿\r\n\r\n\r\n\r\n\r\n\r\n悬疑\r\nB\r\n剧情可以，除了妹妹颜值差点都优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n筱崎步海\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：还行\r\n温馨甜蜜小情侣\r\n\r\n\r\n\r\n《与你心相连》\r\n\r\n\r\n表妹级\r\n银发\r\n表/堂妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n85分\r\n真表妹\r\n渐近\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n睡颜可爱，实妹不能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n近江小小路\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n你就是我的世界中心\r\n\r\n\r\n\r\n《世界与世界的中心》\r\n\r\n\r\n白毛萝莉\r\n白毛\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n98分\r\n勤劳能干\r\n亲密\r\n？？？\r\n住宿\r\n\r\n有孩子\r\n\r\n\r\n\r\n\r\nS\r\n白毛萝莉可爱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神乐鸟 雏\r\n\r\nSS\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：一般\r\n你对我来说就是这么重要\r\n\r\n\r\n\r\n《啾啾爱恋》\r\n\r\n\r\n女仆\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n81分\r\n自卑\r\n阻碍\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹非常自卑，害怕哥哥抛弃自己\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小野寺 鞠\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n拯救自己的愿望\r\n\r\n\r\n\r\n《妄想Complete！》\r\n\r\n\r\n诱惑\r\n红发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n活泼好动\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n共通有h，妹线还不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n一羽，二叶\r\n\r\nSSS虐\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n属于我们的理想乡\r\n\r\n\r\n\r\n《重生游戏》\r\n\r\n\r\n姐妹花\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n剧情作\r\n美少女\r\n91分\r\n双妹妹\r\n亲密\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n剧情不错，也有点虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n伊东美琴\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：还行\r\n探索未来的道路\r\n\r\n\r\n\r\n《恋色空模样》\r\n\r\n\r\n高冷\r\n灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n高冷高傲\r\n阻碍\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通线很长，妹妹误以为哥哥是变态而远离\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n花咲乃乃香\r\n\r\nSSS温柔\r\n妹妹：完美\r\n兄妹：良好\r\n妹线：良好\r\n如此爱着你\r\n\r\n\r\n\r\n《花咲workspring》\r\n\r\n\r\n温柔\r\n暗肉色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n温柔体贴\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n甜蜜\r\nS\r\n为报答哥哥，对男主无微不至的照顾\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n中条杏\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n你就是我的光\r\n\r\n\r\n\r\n《赠与你的空之花》\r\n\r\n\r\n甜蜜\r\n银发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n温柔体贴\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n甜蜜\r\nA\r\n甜蜜温馨，感情线不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n千岁佐奈\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n紧握手中的幸福\r\n\r\n\r\n\r\n《天神乱漫》\r\n\r\n\r\n独自哭泣\r\n金发\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n98分\r\n体贴\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n剧情作设定，废萌剧情，感情线还行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n友濑瑠奈\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：不太行\r\n想要拥有真实的你\r\n\r\n\r\n\r\n《少女与野兽》\r\n\r\n\r\n拥有级\r\n深灰色\r\n义妹\r\n名字\r\n废萌\r\n美少女\r\n93分\r\n坚强能干\r\n兄妹\r\n正常\r\n住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n感情线可以，剧情不错\r\n\r\n\r\n\r\n\r\n逆天，哥哥是妹妹的性奴\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第5批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小鸟游亚子\r\n\r\nSSS甜\r\n妹妹：完美\r\n兄妹：不错\r\n妹线：优秀\r\n兄妹关系天花板\r\n\r\n\r\n\r\n《Making Lovers》\r\n\r\n\r\n兄妹级\r\n桃色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n家庭主妇\r\n当世无双\r\n男主被养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n兄妹\r\nB\r\n大概只有本人有亲妹才写的出来的剧本\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n白羽濑 悠\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：良好\r\n爱恋之歌\r\n\r\n\r\n\r\n《杀恋~悠久之流传》\r\n\r\n\r\n守护级\r\n暗灰色\r\n亲妹\r\n欧尼酱\r\n带点\r\n美少女\r\n93分\r\n吵闹强硬\r\n从头\r\n兄妹分离\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n恋成妹\r\nB\r\n典型的中期知道是兄妹，而且be，但剧情不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n双见空\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：还行\r\n我守护着你，你保护着我\r\n\r\n\r\n\r\n《不要践踏天使的羽毛》\r\n\r\n\r\n信任级\r\n金发\r\n？？？\r\n大哥\r\n魔法\r\n美少年\r\n85分\r\n弟弟型\r\n姐弟？\r\n？？？\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n妹妹男装，男主女装，男主不知道\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n远野 恋\r\n\r\nSS颜\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：一般\r\n世界仅此你一人\r\n\r\n\r\n\r\n《夏空的英仙座》\r\n\r\n\r\n魅惑级\r\n深灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n94分\r\n对别高冷\r\n相依为命\r\n离家出走\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG美，设定好，但剧情有点偏了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n和泉妃爱\r\n\r\nSSS温柔\r\n妹妹：完美\r\n兄妹：良好\r\n妹线：不错\r\n契约之爱\r\n\r\n\r\n\r\n《灵感满溢的甜蜜幻想》\r\n\r\n\r\n兄妹级\r\n金发\r\n亲妹\r\n欧尼\r\n废萌\r\n美少女\r\n100分\r\n撒娇可爱\r\n依赖\r\n正常\r\n兄妹同居\r\n\r\n婚纱\r\n\r\n\r\n\r\n甜蜜\r\nS\r\n有名的富婆妹，人设好，剧情甜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n吹上初音\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：一般\r\n妹线：一般\r\n美梦粉碎留下的残骸\r\n\r\n\r\n\r\n《樱之社，净梦者》\r\n\r\n\r\n救赎\r\n浅粉红\r\n表/堂妹\r\n欧尼桑\r\n悬疑血腥\r\n美少女\r\n88分\r\n小女孩\r\n掩埋\r\n哥父母死\r\n家庭生活\r\n\r\n婚纱\r\n\r\n\r\n\r\n氛围作\r\nB\r\n大量血腥镜头，妹前期没存在感，好在剧情不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n山吹恋华（全年龄）\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n想看你的微笑\r\n\r\n\r\n\r\n《Canvas3 白银的肖像》\r\n\r\n\r\n兄妹级\r\n浅紫色\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n温柔宁静\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n兄妹并没有表露出爱意，平常生活突出关系\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名濑由佳奈\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：凑合\r\n妹的圣域\r\n\r\n\r\n\r\n《妹妹的圣域》\r\n\r\n\r\n兄妹级\r\n暗灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n兄控\r\n温馨\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控妹控\r\n\r\nA\r\n妹控与兄控结合，剧情够甜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n岛津秋\r\n\r\nSSS厌兄\r\n妹妹：负极好\r\n兄妹：负极好\r\n妹线：优秀\r\n爱，永恒不变\r\n\r\n\r\n\r\n《回忆录》\r\n\r\n\r\n拯救级\r\n紫色\r\n义妹\r\n欧尼桑\r\n官场\r\n美少女\r\n93分\r\n厌恶\r\n讨厌\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n究极妹控\r\n智斗\r\nS\r\n攻略前讨厌哥哥，攻略后病娇，剧情反转过瘾\r\n\r\n\r\n\r\n\r\n唯一一个真正讨厌哥哥的妹妹（仅限共通）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n永远\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n十秒钟的勇气\r\n\r\n\r\n\r\n《挚爱随行，倾慕相伴》\r\n\r\n\r\n兄控级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n92分\r\n调皮可爱\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n游戏中相爱，妹妹表现很好，就是h有点多坏好感\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n咲姬\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n锁住彼此的感情\r\n\r\n\r\n\r\n《妹锁》\r\n\r\n\r\n迷惑级\r\n实木色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n优等生\r\n距离\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹人设还行，剧情CG也比较甜，感情线不行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n真由\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n只有你能让我感到安宁\r\n\r\n\r\n\r\n《真由是只属于哥哥的》\r\n\r\n\r\n保护级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n妹单\r\n美少女\r\n95分\r\n胆小主动\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n各方面一般，没有啥优点也没啥缺点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n红星阳菜\r\n\r\nSX颜\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：凑合\r\n只为让你爱上我\r\n\r\n\r\n\r\n《LAMUNATION》\r\n\r\n\r\n宠溺级\r\n金发\r\n亲妹\r\n欧尼酱\r\n无厘头\r\n美少女\r\n85分\r\n母系\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG很美，剧情太无厘头，无聊\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仁科十花\r\n\r\nSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n愿你的笑容永不凋零\r\n\r\n\r\n\r\n《伊人天使妹侧畔》\r\n\r\n\r\n天降级\r\n浅粉红\r\n天降实妹\r\n老哥\r\n废萌\r\n美少女\r\n81分\r\n活泼\r\n一见钟情\r\n天降\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹设定不行，剧情逻辑不通，没有啥实妹感\r\n\r\n\r\n\r\n\r\n天降实妹，逆天操作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n三衣珠树\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：不错\r\n你就是我的英雄\r\n\r\n\r\n\r\n《将军大人风华正茂》\r\n\r\n\r\n夫妻级\r\n浅粉红\r\n义妹\r\n欧尼酱\r\n穿越\r\n美少女\r\n100分\r\n撒娇可爱\r\n亲密无间\r\n妹被收养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n穿越剧，兄控，感情线不错，兄妹关系好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n孔瑞丽（全年龄）\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：负极好\r\n世间永恒的爱恋\r\n\r\n\r\n\r\n《鬼哭街》重制版，设定有牛\r\n\r\n\r\n复仇级\r\n玫瑰红/蓝\r\n亲妹\r\n兄长大人\r\n剧情作\r\n美少女\r\n94/88分\r\n贤淑/病娇\r\n亲密\r\n？？？\r\n？？？\r\n\r\n\r\n\r\n\r\n\r\n战斗\r\nB\r\n妹妹设定吓退90%玩家，废萌玩家勿入→→→\r\n\r\n\r\n\r\n\r\n不好评价，对某些人也算牛，萌豚勿入\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浅井花音\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：良好\r\n挑战我作为妹妹的极限\r\n\r\n\r\n\r\n《G弦上的魔王》\r\n\r\n\r\n成长级\r\n玫瑰红\r\n义妹\r\n欧尼酱\r\n斗智作\r\n美少女\r\n97分\r\n任性外向\r\n认知\r\n男主死父\r\n独居，兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n斗智斗勇\r\nA\r\n成长型妹妹，喜爱哥哥，剧情不错，感情线可以\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤仓雅\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n被妹妹爱慕着是哥哥的荣耀\r\n\r\n\r\n\r\n《铳骑士》\r\n\r\n\r\n依靠级\r\n粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n双重人格\r\n亲密\r\n父死母游\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n妹妹戏份足，感情线还行人设可爱，但剧情幼儿化\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n树里\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：优秀\r\n除了哥哥我谁也不要\r\n\r\n\r\n\r\n《腐姬》设定有牛\r\n\r\n\r\n病娇姬\r\n暗灰色\r\n？？？\r\n欧尼酱\r\n轮回作\r\n萝莉\r\n82分\r\n病娇\r\n亲密\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n悬疑\r\nB\r\n妹妹戏份非常少不能推，但剧情特别牛逼，悬疑→\r\n\r\n\r\n\r\n\r\n不好评价，对某些人也算牛，萌豚勿入\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第6批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长谷川菜乃\r\n\r\nSSS妹控\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：优秀\r\n没有谁比你更重要\r\n\r\n\r\n\r\n《雪歌》\r\n\r\n\r\n兄妹级\r\n棕色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼撒娇\r\n仅此二人\r\n妹妹被养\r\n兄妹同居\r\n\r\n裸体围裙，三连问\r\n\r\n\r\n超级妹控\r\n兄妹\r\nB\r\n称为世界第一妹控哥哥不为过\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘木理帆\r\n\r\nSSS温馨\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：不错\r\n我的世界不能没有你\r\n\r\n\r\n\r\n《家有妹妹》\r\n\r\n\r\n兄妹级\r\n褐玫瑰红\r\n亲妹\r\n欧尼酱\r\n妹单\r\n美少女\r\n100分\r\n活泼可爱\r\n真兄妹\r\n正常\r\n兄妹同居\r\n\r\n三连问\r\n\r\n\r\n\r\n\r\nA\r\n除了结局开放外没有什么缺点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n御城由乃\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n我们是命中注定的\r\n\r\n\r\n\r\n《自黯淡之刻的尽头》\r\n\r\n\r\n穿越\r\n浅粉\r\n亲妹\r\n欧尼酱\r\n末日\r\n萝莉\r\n100分\r\n撒娇开朗\r\n兄妹\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n氛围轮回作\r\n\r\n\r\n\r\n\r\n带点恐怖，有很现实的be\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘 皋月\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n兄控大作战\r\n\r\n\r\n\r\n《Stellar☆Theater encore》\r\n\r\n\r\n兄控级\r\n·蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n兄控\r\n兄控\r\n正常\r\n兄妹同居\r\n\r\n裸体围裙，三连问\r\n\r\n\r\n重度兄控\r\nFD\r\nA\r\n完美的妹妹，而且兄控，FD才能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n黑瀨樱良\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：还行\r\n在一起是我们追求的命运\r\n\r\n\r\n\r\n《相见5分属于我，时间停止和不可避的命运》\r\n\r\n\r\n兄控级\r\n黑发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n温柔宁静\r\n依赖\r\n妹受伤\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n感情线不错，温馨甜蜜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n月见里 水雪\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n守护哥哥的幸福\r\n\r\n\r\n\r\n《未来收音机与人工鸽》\r\n\r\n\r\n守护级\r\n暗灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼外向\r\n吸引注意\r\n妹被收养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n真女主光环过强，妹线还是可以的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n时谷忍\r\n\r\nSA\r\n妹妹：不错\r\n兄妹：稀烂\r\n妹线：不太行\r\n愿成你妹\r\n\r\n\r\n\r\n《缘契初情乃今家舍妹》\r\n\r\n\r\n相伴级\r\n灰蓝色\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n84分\r\n温柔优等\r\n隔阂\r\n成兄妹\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n血压升高作，男主死活不接受妹妹表白\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n深峰莉子\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：还行\r\n留下彩虹以及对你的思念\r\n\r\n\r\n\r\n《永不消失的彩虹 Gift》\r\n\r\n\r\n兄妹级\r\n深红色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n温柔高冷\r\n思念\r\n被分开\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n日常感情戏很好，表现似亲妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nMeru\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n她的微笑如此美丽，但眼中充满悲伤\r\n\r\n\r\n\r\n《Millia -The ending》\r\n\r\n\r\n依靠\r\n金发\r\n义妹\r\n哥哥\r\n短篇\r\n美少女\r\n89分\r\n文静\r\n相依为命\r\n父母双亡\r\n兄妹同居\r\n\r\n裸体围裙\r\n\r\n\r\n\r\n\r\nC\r\n无语音，悲伤作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n瀨真梢\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n眼里只有哥哥\r\n\r\n\r\n\r\n《白恋SAKURA＊GRAM》\r\n\r\n\r\n喜爱级\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n89分\r\n害羞胆小\r\n亲密\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n隐藏可推角色，表现还行，戏份比较少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n希露菲·克劳德\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n回到兄妹时光\r\n\r\n\r\n\r\n《回转苹果亭的一千零一夜》\r\n\r\n\r\n重逢级\r\n褐色\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n纯洁无暇\r\n重逢\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n重逢感情做的很好，妹妹很圣洁\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新见雪月\r\n\r\nSSS兄妹\r\n妹妹：极好\r\n兄妹：极好\r\n妹线：极好\r\n创造属于我们兄妹自己的形式\r\n\r\n\r\n\r\n《银色遥远》\r\n\r\n\r\n兄妹级\r\n黑发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n温柔贤惠\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n裸体围裙\r\n\r\n\r\n\r\n\r\nA\r\n时间跨度很大，非常棒的妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n葉山莉寿\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：良好\r\n哥哥胜任之路\r\n\r\n\r\n\r\n《凝视那侧脸》\r\n\r\n\r\n守护级\r\n实木色\r\n义妹\r\n欧尼酱\r\n黑深残\r\n美少女\r\n91分\r\n活泼可爱\r\n伪亲密\r\n妹被收养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n黑马，意外感情线不错，就是有点暗黑\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n朝雾麻衣\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n一直一直喜欢你\r\n\r\n\r\n\r\n《更胜黎明前的琉璃色》\r\n\r\n\r\n家庭级\r\n桃色\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n92分\r\n天真活泼\r\n喜欢\r\n破镜重圆\r\n姐兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n无血缘，姐兄妹破镜重圆的故事\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n皇城一花\r\n\r\nSS颜\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：一般\r\n宛如鲜花绽放\r\n\r\n\r\n\r\n《恋慕之心的交织方式》\r\n\r\n\r\n颜值级\r\n紫发\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n91分\r\n善解人意\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nFD必推，除了流程短没有什么缺点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n高乃椎凪\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n彼此一如既往\r\n\r\n\r\n\r\n《雪境迷途遇仙踪》\r\n\r\n\r\n温情级\r\n蓝发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n96分\r\n温情\r\n亲密\r\n正常\r\n多女主居住\r\n\r\n膝枕\r\n\r\n\r\n\r\n\r\nA\r\n废萌，中规中矩\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n永仓小夏\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n人气声优养成\r\n\r\n\r\n\r\n《人气声优的养成方式》\r\n\r\n\r\n平常级\r\n实木色\r\n亲妹\r\n欧尼酱\r\n声优\r\n美少女\r\n84分\r\n勤奋努力\r\n平常\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n缺少兄妹单独剧情，表现一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n水泽巡\r\n\r\nS颜\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：拉跨\r\n寻找救赎\r\n\r\n\r\n\r\n《罪恋X2/3》\r\n\r\n\r\n颜值级\r\n紫发\r\n义妹\r\n欧尼桑\r\n狗血\r\n美少女\r\n81分\r\n外热内冷\r\n还行\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n颜值是真的高，剧情也是真的狗血，不太建议推\r\n\r\n\r\n\r\n\r\n三角恋狗血剧情，谨慎推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第7批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n青葉英梨歌\r\n\r\nSSS妹控\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n被尘封的爱恋\r\n\r\n\r\n\r\n《猫神大人与七颗星星》\r\n\r\n\r\n兄妹级\r\n金发\r\n亲妹\r\n欧尼酱/桑\r\n妹单\r\n美少女\r\n100分\r\n撒娇可爱\r\n亲密无间\r\n被母虐待\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n妹控\r\n兄妹\r\nS\r\n非常稀有的妹单佳作，完全符合我的兴趣\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n宝交祐佳\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n化作灯塔，指引你前进的方向\r\n\r\n\r\n\r\n《Berry’s》\r\n\r\n\r\n指引级\r\n棕色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n害羞胆小\r\n温和\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n先上车后补票，感情有点担忧\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n汀龙子\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n妹控勇往直前\r\n\r\n\r\n\r\n《こんそめ！～combination somebody～\r\n\r\n\r\n守护级\r\n浅粉\r\n义妹\r\n尼尼\r\n废萌\r\n美少女\r\n95分\r\n高冷撒娇\r\n重逢\r\n青梅\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n改邪归正，不可多得的妹作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤白乃绘里\r\n\r\nSA颜\r\n妹妹：极好\r\n兄妹：稀烂\r\n妹线：拉跨\r\n妹想妹而妹非妹\r\n\r\n\r\n\r\n《Dal Segno》\r\n\r\n\r\n\r\n·金发\r\n表/堂妹\r\n欧尼\r\n废萌\r\n美少女\r\n88分\r\n活泼可爱\r\n隔阂\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n亲妹不能推，男主不把表妹当妹，妹控慎推\r\n\r\n\r\n\r\n\r\n男主不随表妹意，只认亲妹却没线，表妹没得说标准妹妹形象\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n蜜娜\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n此生只为守护尼\r\n\r\n\r\n\r\n《猎人学院2》回合制RPG\r\n\r\n\r\n守护级\r\n暗灰色\r\n表/堂妹\r\n名字\r\nRPG\r\n美少女\r\n95分\r\n善良温柔\r\n相依为命\r\n父母双亡\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\nRPG\r\nB\r\n兄妹感情很好，很甜，但非gal而是rpg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n稜祁祥那\r\n\r\nSSS萝莉\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：负极好\r\n永世爱恋\r\n\r\n\r\n\r\n《少女神域~少女天狱》be污点\r\n\r\n\r\n萝莉级\r\n粉色\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n萝莉\r\n100分\r\n天真无邪\r\n兄妹情\r\n父母双亡\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n刀多，be像雷，无牛，真萝莉，后期剧情精彩，\r\n\r\n\r\n\r\n\r\nbe是污点，只走TE那就是全年龄，其他女主线可能有大雷\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n喜多芽衣\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：一般\r\n不想让你担心\r\n\r\n\r\n\r\n《正负战争》\r\n\r\n\r\n隐藏级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n84分\r\n勤劳能干\r\n隐藏\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n隐藏的感情可不太好，距离感也不太行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n忧姬（全年龄）\r\n\r\nSX\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：一般\r\n带你穿越黑暗\r\n\r\n\r\n\r\n《NOeSIS羽化》\r\n\r\n\r\n爱护级\r\n蓝发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n坚强能干\r\n漠视\r\n？？？\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n剧情有些阴暗，妹线男主才重视妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n待雪亚芽\r\n\r\nSA颜\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：凑合\r\n重新开始的关系\r\n\r\n\r\n\r\n《不可视之药与坎坷的命运》\r\n\r\n\r\n\r\n粉色\r\n表/堂妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n85分\r\n小傲娇\r\n阻碍\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nh过早，感情不到位，发展离谱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n朝仓音梦\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n好想、好想和你在一起\r\n\r\n\r\n\r\n《初音岛1》\r\n\r\n\r\n珍惜级\r\n实木色\r\n义妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n95分\r\n兄控活泼\r\n兄控\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n感情更加自然，前期发糖后期虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n速濑真奈美\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n一直相伴的思念\r\n\r\n\r\n\r\n《神风探索者》\r\n\r\n\r\n牵挂级\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n兄控活泼\r\n撒娇\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹超兄控，表白很棒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n结城铃（全年龄）\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n妹控是如何速成的？\r\n\r\n\r\n\r\n《女仆咖啡巧克拉》\r\n\r\n\r\n温馨级\r\n实木色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n94分\r\n内向孤僻\r\n伪兄妹\r\n妹被收养\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n家庭温馨感不错，妹妹占有欲强的不建议推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n津云\r\n\r\nSS\r\n妹妹：负不错\r\n兄妹：还行\r\n妹线：负一般\r\n欧尼酱~欧尼酱\r\n\r\n\r\n\r\n《九十九之月》\r\n\r\n\r\n迷途级\r\n白毛\r\n？？？\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n娇小可爱\r\n眩晕\r\n？？？\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n另一个妹妹操作让人不适，狂虐本妹\r\n\r\n\r\n\r\n\r\n假妹太虐真妹，痛苦之作，谨慎推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n葛木 姫乃\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n想要传达给你的爱恋\r\n\r\n\r\n\r\n《D.C.III R～ダ・カーポIII アール～ X-rated》\r\n\r\n\r\n亲密级\r\n棕色\r\n义妹\r\n尼桑\r\n废萌\r\n美少女\r\n99分\r\n固执温柔\r\n亲密无间\r\n兄被收养\r\n学校住宿\r\n\r\n公主抱\r\n\r\n\r\n\r\n\r\nB\r\n义妹但亲密度似亲妹，建议只推前世妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n佐久真 诗\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n献出我的契约之吻\r\n\r\n\r\n\r\n《我的恋天使太废材了好可怕》\r\n\r\n\r\n恋爱级\r\n桃色\r\n义妹\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n痴女温柔\r\n男女\r\n正常\r\n兄妹同居\r\n\r\n摸头杀，婚纱，裸体围裙\r\n\r\n\r\n\r\n\r\nS\r\n标准废萌，妹妹兄控好评，成痴女了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n柳瀬 詠歌\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n兄控无极限\r\n\r\n\r\n\r\n《突然发现我已恋上你》\r\n\r\n\r\n兄控级\r\n灰色\r\n亲妹\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n兄控毒舌\r\n恋爱\r\n父母失踪\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n兄控到一夜白头乃第一人，自慰狂魔\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第8批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n黑崎小夜\r\n\r\nSX\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：还行\r\n血液继承生命的温暖\r\n\r\n\r\n\r\n《青鸟》\r\n\r\n\r\n相遇级\r\n暗灰色\r\n双胞胎\r\n名字\r\n剧情向\r\n美少女\r\n89分\r\n抖S\r\n强硬\r\n？？？\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n强硬抖S妹，开局男主H很多贴脸，设定像拔作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n常坂二乃\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n一起活下去的约定\r\n\r\n\r\n\r\n《初音岛4》2个版本声优不一样\r\n\r\n\r\n颜萌级\r\n黑发\r\n义妹\r\n尼桑/欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n温柔可爱\r\n亲密无间\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n作为废萌还可以，作为初音岛系列就差不少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新山葵\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n爱的赞歌\r\n\r\n\r\n\r\n《秋色恋華》\r\n\r\n\r\n粉丝级\r\n棕色\r\n义妹\r\n欧尼酱\r\n废萌\r\n偶像\r\n89分\r\n活泼开朗\r\n粉丝\r\n正常\r\n兄妹分居\r\n\r\n\r\n\r\n\r\n\r\n偶像\r\nB\r\n注重偶像的绯闻，声音俏皮，整体不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n夏本 讽歌\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：负不错\r\n妹线：一般\r\n别，别碰我......会怀孕的\r\n\r\n\r\n\r\n《魔卡魅恋》\r\n\r\n\r\n萝莉傲娇级\r\n浅蓝发\r\n亲妹\r\n尼桑\r\n废萌\r\n萝莉\r\n95分\r\n傲娇可爱\r\n不肯承认\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n妹控\r\n\r\nA\r\n超可爱傲娇巨乳萝莉\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n茅崎夕樱\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：一般\r\n想要坚守爱你的信念\r\n\r\n\r\n\r\n《水葬银货》\r\n\r\n\r\n守护级\r\n粉红\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n100分\r\n古灵精怪\r\n？？？\r\n？？？\r\n多女主同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nS\r\n妹妹可靠能干，兄控言论满天飞，TE表现最佳\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n三谷 歩夢（全年龄）\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n我就是你的妹妹\r\n\r\n\r\n\r\n《现在立刻就想对哥哥说我是妹妹！》\r\n\r\n\r\n温柔级\r\n浅肉色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n勤劳能干\r\n隐藏\r\n再婚\r\n家庭生活\r\n\r\n隐藏妹妹身份的佳作\r\n\r\n\r\n\r\n\r\nB\r\n除了妹妹男装隐藏身份，其他都不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n飞鹰春奈\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：凑合\r\n迟到的感情\r\n\r\n\r\n\r\n《格林花园的少女》\r\n\r\n\r\n\r\n粉红色\r\n双胞胎\r\n名字\r\n废萌\r\n美少女\r\n75分\r\n孤僻坚强\r\n？？？\r\n？？？\r\n？？？\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n挂羊头卖狗肉，不建议推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n远野律\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：凑合\r\n命运共同体\r\n\r\n\r\n\r\n《闪耀青春追着逐记》\r\n\r\n\r\n依靠级\r\n茶色\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n95分\r\n兄控可爱\r\n可爱\r\n正常\r\n兄妹同居\r\n\r\n婚纱\r\n\r\n\r\n兄控\r\n\r\nB\r\n配角待遇，隐藏可推，流程短妹线剧情过于刻意\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n沢渡 满\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：还行\r\n妹线：还行\r\n你是我的眼\r\n\r\n\r\n\r\n《克洛的时钟》\r\n\r\n\r\n守护级\r\n黑发\r\n亲妹\r\n尼桑满\r\n废萌\r\n美少女\r\n96分\r\n兄控温柔\r\n还行\r\n？？？\r\n兄妹分居\r\n\r\n\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n兄妹描述的不够多，但家庭温馨感很不错，注重妹妹的成长\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n八重垣 瑠璃\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n兄妹携手迈向未来\r\n\r\n\r\n\r\n《交汇协奏曲》\r\n\r\n\r\n拯救级\r\n白毛\r\n双胞胎\r\n尼桑/欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n兄控温柔\r\n粘人\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n妹妹南原声音好听，私下粘人，剧情差点意思\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n如月 もも\r\n\r\nS\r\n妹妹：良好\r\n兄妹：一般\r\n妹线：不太行\r\n成为欧尼酱心中的第一\r\n\r\n\r\n\r\n《抚子革命 ナデレボ！》\r\n\r\n\r\n\r\n棕色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n活泼兄控\r\n？？？\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n本体不如青梅，if线满好感动，流程短\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n山吹爱丽丝\r\n\r\nSAAA\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：一般\r\n姐妹花，兄妹心\r\n\r\n\r\n\r\n《星之少女与六华的姐妹》\r\n\r\n\r\n姐妹级\r\n蓝色\r\n义妹\r\n尼尼\r\n废萌\r\n美少女\r\n97分\r\n兄控怕生\r\n当世无双\r\n正常\r\n学校住宿\r\n\r\n婚纱\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n颜值爆表，撒娇可爱还卖萌，写作兄妹，读作姐妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n春日野穹\r\n\r\nSSS妹\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：不错\r\n悠远的苍穹下，紧密相连的羁绊\r\n\r\n\r\n\r\n《缘之空》\r\n\r\n\r\n傲娇\r\n白毛\r\n亲妹\r\n名字\r\n废萌\r\n美少女\r\n100分\r\n傲娇，温情\r\n无你不活\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n妹控必经历的里程碑，恨妹不是穹，什么是兄妹恋？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n千惠\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n处男哥与反坑妹\r\n\r\n\r\n\r\n《童贞兄妹》\r\n\r\n\r\n相亲\r\n黑色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n傲娇，人精\r\n自然\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n感情铺垫不是很够，认ai当妹影响剧情，h过多\r\n\r\n\r\n\r\n\r\n多种性格选择\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n友坂玲夏\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：不错\r\n妹控初心\r\n\r\n\r\n\r\n《波子汽水》\r\n\r\n\r\n兄妹同心\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉/美少女\r\n95分\r\n温顺\r\n未曾不喜欢\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n非常优秀的童年剧情（萝莉体型），长大后再续前缘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n库可\r\n\r\nSA\r\n妹妹：不错\r\n兄妹：一般\r\n妹线：凑合\r\n你的鲨鱼我的妹\r\n\r\n\r\n\r\n《与鲨鱼共度的七日之间》\r\n\r\n\r\n隐藏\r\n白毛\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n40分\r\n天真无邪\r\n鲨鱼\r\n？？？\r\n兄妹同居\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n剧情尚可，但隐藏妹，毫无妹属性\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n谷风天音\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n杂鱼欧尼酱~\r\n\r\n\r\n\r\n《天使☆纷扰 RE-BOOT!》\r\n\r\n\r\n兄妹\r\n粉红\r\n亲妹\r\n欧尼酱/欧尼\r\n废萌\r\n美少女\r\n100分\r\n雌小鬼\r\n被埋藏\r\n正常\r\n兄妹同居\r\n\r\n膝枕，婚纱\r\n\r\n\r\n\r\n\r\nA\r\n柚子社第一位实妹，很甜很现实的兄妹关系，没有伦理\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n生肉妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n生肉gal\r\n\r\n\r\n翻译补丁网址 https://galge.fun/subjects\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第1批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n生肉\r\n\r\n\r\n汉化/翻译\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n千ヶ崎 入莉\r\n\r\nSSS救赎\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：优秀\r\n在探寻爱与希望的道路上不断前进\r\n\r\n\r\n\r\n《終わる世界とバースデイ》\r\n\r\n\r\n世界终结与生日快乐\r\n\r\n救赎级\r\n浅钢兰\r\n义妹\r\n欧尼桑\r\n剧情作\r\n美少女\r\n96分\r\n病弱孤独\r\n守护\r\n？？？\r\n兄妹同居\r\n\r\n妹控杀手\r\n\r\n\r\n超妹控\r\n感人/催泪\r\nS\r\n又一催泪神作，看兄妹如何相互救赎\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n爱沢花穗\r\n\r\nSSS甜\r\n妹妹：完美\r\n兄妹：极好\r\n妹线：极好\r\n今生今世永不分离\r\n\r\n\r\n\r\n《ラブラブル～Lover Able～》FD：《同棲ラブラブル》\r\n\r\n\r\n情侣热恋中\r\n\r\n甜蜜级\r\n蓝发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n100分\r\n小恶魔\r\n亲密无双\r\n正常\r\n兄妹同居\r\n\r\n甜死人不偿命\r\n\r\n\r\n\r\n甜蜜\r\nB\r\n超甜妹作，当世无双\r\n\r\n\r\n\r\n\r\n甜度神中神，FD甚至更优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n此花茉莉\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n相守一生\r\n\r\n\r\n\r\n《Marguerite Sphere -マーガレット スフィア- 》\r\n\r\n\r\n《丽特的占卜星》共通汉化\r\n\r\n双子级\r\n金发\r\n双胞胎\r\n欧尼酱\r\n废萌\r\n美少年\r\n100分\r\n双重人格\r\n忽冷忽热\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n感情发展，表白，伦理都处理的还可以\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n御法 光\r\n\r\nSSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n愿你只在我的身旁\r\n\r\n\r\n\r\n《運命予報をお知らせします》\r\n\r\n\r\nAI翻译\r\n\r\n陪伴级\r\n粉红色\r\n亲妹\r\n欧尼酱/桑\r\n废萌\r\n美少女\r\n94分\r\n冷静稳重\r\n兄控\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通发力表白优秀，怎么会拒绝这么可爱的妹妹呢\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n初駒ルリ\r\n\r\nSSS亲情\r\n妹妹：负完美\r\n兄妹：极好\r\n妹线：优秀\r\n陪你渡过幸福的一生\r\n\r\n\r\n\r\n《ルリのかさね ～いもうと物語り》\r\n\r\n\r\nAI翻译\r\n\r\n家人级\r\n黑发\r\n侄女\r\n欧尼酱\r\n温情\r\n萝莉\r\n94分\r\n相依为命\r\n非你莫属\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n亲情\r\nA\r\n亲情描写最强作，最纯粹的家人情感\r\n\r\n\r\n\r\n\r\n3条妹线，萝莉神中神，时间跨度大，催泪\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n香原瑞希\r\n\r\nSSS傲暴\r\n妹妹：负极好\r\n兄妹：负不错\r\n妹线：不错\r\n兄妹回归初心\r\n\r\n\r\n\r\n《かみぱに!》\r\n\r\n\r\n\r\n\r\n傲暴级\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n暴力独占\r\n回归\r\n阴影\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n感情发展稳定优秀，暴力妹妹比较少见\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仲神 かすが\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：凑合\r\n恋人宣言\r\n\r\n\r\n\r\n《ひだまりバスケット 》\r\n\r\n\r\nAI翻译\r\n\r\n活泼级\r\n实木色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼可爱\r\n妹主\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通优秀，妹线走下坡路，伦理没有写好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n夏島 みさき\r\n\r\nS\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n那一天，我对妹妹恋爱了\r\n\r\n\r\n\r\n《ナマイキデレーション》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n85分\r\n傲娇冷酷\r\n吸引\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n缺少感情转折，铺垫，很一般，像拔作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浅坂爱莉\r\n\r\nSSS巫女\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n爱上你是我的荣幸\r\n\r\n\r\n\r\n《妹のおかげでモテすぎてヤバい》\r\n\r\n\r\n因为妹妹太受欢迎了糟糕了\r\n\r\n相爱级\r\n金发\r\n亲妹\r\n尼桑\r\n废萌\r\n美少女\r\n100分\r\n活泼兄控\r\n真女主\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n各方面都很棒，声音还好听，妹妹真女主待遇\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小町谷 菜砂\r\n\r\nSSS温情\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n无限缩短彼此的距离\r\n\r\n\r\n\r\n《ココロネ=ペンデュラム》\r\n\r\n\r\nAI翻译\r\n\r\n思念级\r\n粉红\r\n亲妹\r\n啊尼给\r\n废萌\r\n美少女\r\n96分\r\n高傲兄控\r\n前辈\r\n分开3年\r\n学校住宿（同居）\r\n\r\n黑色枕大腿\r\n\r\n\r\n\r\n\r\nS\r\n前辈型妹妹，比较甜，兄妹感情发展优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n丹生 佳津美\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n你就是我的恋慕之心\r\n\r\n\r\n\r\n《コドモノアソビ》\r\n\r\n\r\nAI翻译\r\n\r\n恋情级\r\n紫发\r\n亲妹\r\n尼桑/欧尼\r\n废萌\r\n萝莉\r\n91分\r\n兄控高冷\r\n隐藏\r\n3年未认\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n开始高冷，进线主动，害羞可爱至极\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n白咲 ひな\r\n\r\nSSS撒娇\r\n妹妹：不错\r\n兄妹：负不错\r\n妹线：良好\r\n啊~哥哥雷达有反应啦！\r\n\r\n\r\n\r\n《SuGirly Wish》\r\n\r\n\r\nAI翻译\r\n\r\n喜欢级\r\n白杏色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n活泼可爱\r\n接近\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n超兄控\r\n\r\nB\r\n精力爆表，超喜欢哥哥，想成为哥哥的恋人\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n美野里 巴\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n尽情撒娇吧，妹妹\r\n\r\n\r\n\r\n《QUINTUPLE☆SPLASH》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n傲娇严厉\r\n隐藏\r\n正常\r\n学校住宿（同居）\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n画风可爱，CG很棒，但感情变化过快，剧情一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n遠海 佐奈\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n我们不i可分离\r\n\r\n\r\n\r\n《Angel Ring》\r\n\r\n\r\nAI翻译\r\n\r\n相思级\r\n实木色\r\n亲妹\r\n啊尼给\r\n废萌\r\n美少女\r\n95分\r\n暴力能干\r\n隐藏\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通非常棒，妹线感情变化不自然，犹豫不决\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n麻生 こま\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n相思成双\r\n\r\n\r\n\r\n《めぐり、ひとひら。》\r\n\r\n\r\n\r\n\r\n思念级\r\n棕色\r\n义妹\r\n欧尼酱\r\n带点剧情\r\n美少女\r\n93分\r\n善良温柔\r\n思念\r\n？？？\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n人设很好，共通日常过长，剧情反转过于简单\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n燕子花 こりす\r\n\r\nSS\r\n妹妹：极好\r\n兄妹：负良好\r\n妹线：一般\r\n期待着回心转意\r\n\r\n\r\n\r\n《めぐり、ひとひら。》\r\n\r\n\r\n\r\n\r\n追寻级\r\n白毛\r\n青梅\r\n尼桑\r\n剧情向\r\n美少女\r\n90分\r\n温柔贤惠\r\n不高\r\n追寻\r\n住宿\r\n\r\n苦苦追寻男主，毅力最强之妹\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n画风古老颜值依旧在，啥都好，可惜男主只在乎真妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第2批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n翻译补丁网址 https://galge.fun/subjects\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n生肉\r\n\r\n\r\n汉化/翻译\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n岛津朗\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n天才在左，废柴在右\r\n\r\n\r\n\r\n《木洩れ陽のノスタルジーカ》\r\n\r\n\r\n\r\n\r\n依赖级\r\n黑发\r\n义妹\r\n欧尼酱\r\n科技废萌\r\n美少女\r\n84分\r\n活泼开朗\r\n依赖\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹设定优秀，但表现拉跨，兄妹戏份不够多\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n常盘木 雪\r\n\r\nSX\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：一般\r\n编织属于我们的童话\r\n\r\n\r\n\r\n《雲上のフェアリーテイル》\r\n\r\n\r\nAI翻译\r\n\r\n公主级\r\n白毛\r\n亲妹\r\n哥哥大人\r\n废萌\r\n公主\r\n93分\r\n温文尔雅\r\n兄控\r\n分离几年\r\n住宿\r\n\r\n首个公主妹妹\r\n\r\n\r\n兄控\r\n公主\r\nS\r\n妹妹非常棒，但剧情不行，老套，无聊\r\n\r\n\r\n\r\n\r\nCG好看，剧情略显幼稚，而且非纯爱，在共通有男主跟其他女主h\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n双見 伊織（织）\r\n\r\nSSS宠物\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n妹妹宠物\r\n\r\n\r\n\r\n《Love Sweets》\r\n\r\n\r\nAI翻译\r\n\r\n粘人级\r\n黑发\r\n亲妹\r\n尼桑\r\n温情\r\n美少女\r\n100分\r\n文静粘人\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n文静可爱的妹妹谁不想守护呢？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神木彩花\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n兄妹的纯真\r\n\r\n\r\n\r\n《夏彩恋唄》\r\n\r\n\r\n夏彩恋歌\r\n\r\n萝莉级\r\n浅黄红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n93分\r\n活泼可爱\r\n粘人\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n活泼可爱萝莉妹妹，可惜流程短，感情线一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大日向 ルイ\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：良好\r\n妹线：一般\r\n心灵一体\r\n\r\n\r\n\r\n《ノブレスオブルージュ -Noblesse of Rouge》\r\n\r\n\r\nAI翻译\r\n\r\n温柔级\r\n黑发\r\n双胞胎\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n温柔优等\r\n兄妹一体\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n男主女装代替妹妹上学，流程短\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n十崎由衣\r\n\r\nSSS甜/虐\r\n妹妹：完美\r\n兄妹：还行\r\n妹线：优秀\r\n血脉相连至不可分离的羁绊\r\n\r\n\r\n\r\n《ALMA～ずっとそばに…～》\r\n\r\n\r\n\r\n\r\n喜与悲\r\n红发\r\n亲妹\r\n欧尼酱\r\n天堂与地狱\r\n美少女\r\n100分\r\n贤妻良母\r\n超级兄控\r\n？？？\r\n兄妹同居\r\n\r\n天堂与地狱同在\r\n\r\n\r\n兄控\r\n\r\nC\r\n妹人妻属性拉满，前期多甜后期多虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤宮凛\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：一般\r\n妹线：一般\r\n一生妹，一生随\r\n\r\n\r\n\r\n《よくばりサボテン》\r\n\r\n\r\n\r\n\r\n信念级\r\n白毛\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n活泼兄控\r\n妹攻哥受\r\n分离多年\r\n兄妹同居\r\n\r\n婚纱\r\n\r\n\r\n\r\n\r\nS\r\n白毛长发.猫耳，妹妹不错，男主比较懦弱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n海棠 璃々子\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n融入血缘的喜欢\r\n\r\n\r\n\r\n《サキガケ⇒ジェネレーション！》\r\n\r\n\r\nAI翻译\r\n\r\n萌兔级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n中二缅甸\r\n甜蜜\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n中二\r\nS\r\n妹妹娇羞可爱又中二，白毛万岁\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小鸟游夜夜\r\n\r\nSSA\r\n妹妹：完美\r\n兄妹：稀烂\r\n妹线：拉跨\r\n留住回忆，锁住感情\r\n\r\n\r\n\r\n《Clover Point》\r\n\r\n\r\n四叶奇迹\r\n\r\n温柔级\r\n金发\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n温柔体贴\r\n兄控\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n妹妹完美，男主太拉跨配不上妹妹\r\n\r\n\r\n\r\n\r\n妹妹太好，男主态度不行，还伤妹妹心\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n风祭 爱奈\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：还行\r\n妹线：还行\r\n守护在你的身旁\r\n\r\n\r\n\r\n《真夏の夜の雪物語 -MIDSUMMER SNOW NIGHT-》\r\n\r\n\r\n\r\n\r\n守护级\r\n金发\r\n表/堂妹\r\n尼桑\r\n废萌\r\n美少女\r\n86分\r\n勤劳能干\r\n异性\r\n？？？\r\n姐兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n颜值顶中顶，兄妹感不高，三个周目表现都不算好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第3批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n翻译补丁网址 https://galge.fun/subjects\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n生肉\r\n\r\n\r\n汉化/翻译\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n久我山 このか\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n今生今世，与你相遇\r\n\r\n\r\n\r\n《プリズム◇リコレクション！》\r\n\r\n\r\nAI翻译\r\n\r\n贤惠可爱\r\n黑色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n温柔乖巧\r\n兄控\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nS\r\n记录哥哥的天才少女，妹人设无敌，发糖也甜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n天都早紗\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：良好\r\n爱的魔法\r\n\r\n\r\n\r\n《夏の魔女のパレード》\r\n\r\n\r\nAI翻译\r\n\r\n温柔体贴\r\n黑色\r\n义妹\r\n尼桑\r\n魔法学校\r\n美少女\r\n99分\r\n忠犬\r\n兄控\r\n与老妈不合\r\n学校住宿\r\n\r\n婚纱\r\n\r\n\r\n兄控\r\n\r\nS\r\n重度兄控妹妹求爱记，世界名画壁咚表白，\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n八坂可子\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n无法抑制的喜欢\r\n\r\n\r\n\r\n《初音岛5》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n深灰色\r\n青梅\r\n尼桑\r\n废萌\r\n美少女\r\n69分\r\n柔情善良\r\n喜欢\r\n？？？\r\n姐兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n共通体验差，初音岛待遇最差的一妹妹，边缘化\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n莉丝·格里菲兹\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n为你而活为你而死，直至死亡将我们分离\r\n\r\n\r\n\r\n《シャマナ シャマナ～月とこころと太陽の魔法～》\r\n\r\n\r\n\r\n\r\n守护\r\n桃色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n85分\r\n淑女腼腆\r\n守护\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n超想守护的妹妹，柔弱腼腆，想撒娇却不敢行动\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n日向 なずな\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n守护这份情意\r\n\r\n\r\n\r\n《BLUE》\r\n\r\n\r\n\r\n\r\n恋爱\r\n黑色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n78分\r\n高冷\r\n外冷内热\r\n正常\r\n分开\r\n\r\n\r\n\r\n\r\n隐藏兄控\r\n\r\nB\r\n外冷内热型妹，隐藏兄控，流程短但算全，发糖不够\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n上杉朱乃\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n爱的鞭挞\r\n\r\n\r\n\r\n《俺の彼女のウラオモテ》\r\n\r\n\r\nAI翻译\r\n\r\n爱意\r\n黑色\r\n亲妹\r\n欧尼\r\n废萌\r\n美少女\r\n91分\r\n热情兄控\r\n兄控\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n在外骂哥哥，私下兄控，袒护哥哥，妹控福音\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n星央遥\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n爱上狮子的兔子\r\n\r\n\r\n\r\n《ガチ乙女クインテット》\r\n\r\n\r\n\r\n\r\n\r\n金发\r\n亲妹\r\n兄长大人\r\n废萌\r\n美少女\r\n95分\r\n温柔体贴\r\n喜欢\r\n正常\r\n兄妹同居\r\n\r\n摸头杀，婚纱\r\n\r\n\r\n\r\n\r\nC\r\n共通大量无关剧情且退其他女主线才能进，表现一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n宮沢 あきら\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n心房上的钥匙\r\n\r\n\r\n\r\n《ゆきいろ ～空に六花の住む町～》\r\n\r\n\r\n\r\n\r\n童年\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n98分\r\n温柔可爱\r\n粘人\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n童年戏份，超可爱，妹心理描写不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n雜賀ほたる\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n不可或缺的存在\r\n\r\n\r\n\r\nFD:《Whiteちょこっとファンディスク》\r\n\r\n\r\n\r\n\r\n\r\n粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n胆小柔弱\r\n自始不变\r\n分开\r\n多女主同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n童年剧情优秀，但其他女主吃醋让人血压升高，仅FD有妹线\r\n\r\n\r\n\r\n\r\n其他女主抢男主特别恶心人，谨慎推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n臣苗 鈴\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n撒娇行动\r\n\r\n\r\n\r\n《ナツイロココロログ》\r\n\r\n\r\nAI翻译\r\n\r\n双妹泡芙\r\n桃色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n腼腆自卑\r\n隐藏\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n双重人格，精华在前，什么？能破妹两次处？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n一ノ瀬 乙葉\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：还行\r\n你的梦魇我的心\r\n\r\n\r\n\r\n《幸福の食卓～しあわせのはね》\r\n\r\n\r\n\r\n\r\n灾恶\r\n黑发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n86分\r\n村姑\r\n不得不爱\r\n父母再婚\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n相爱在一起是幸福的，同时也是悲剧的，痛苦是无尽的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n七枷 琴子\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n让我在爱你一次\r\n\r\n\r\n\r\n《猫撫ディストーション》有FD\r\n\r\n\r\n\r\n\r\n虚幻\r\n白毛\r\n亲妹\r\n尼桑\r\n剧情向\r\n天使\r\n95分\r\n贤淑温柔\r\n再爱一次\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG超美，剧情冗长且哲学悲剧？？？？？？？？\r\n\r\n\r\n\r\n\r\n不是很推荐，只当收集好看CG妹还行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n青野七\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：不错\r\n一日为亲，终生为妹\r\n\r\n\r\n\r\n《海と雪のシアンブルー》\r\n\r\n\r\nAI翻译\r\n\r\n义兄妹\r\n深红\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n温文尔雅\r\n积极上升\r\n开局义妹\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n，开局天降，从陌生人到兄妹再到恋人描写的非常好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n早坂 羽未\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：一般\r\n影子下的阴影\r\n\r\n\r\n\r\n《春恋＊乙女～乙女の園でごきげんよう。～》\r\n\r\n\r\n\r\n\r\n继承\r\n浅玫瑰色\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n活泼开朗\r\n？？？\r\n？？？\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n妹妹可爱，发糖可，但妹线压抑\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n三枝 彩叶\r\n\r\nSSS萝莉\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：优秀\r\n我心永恒\r\n\r\n\r\n\r\n《ラムネ2》波子汽水2\r\n\r\n\r\nAI翻译\r\n\r\n兄控\r\n粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n直率兄控\r\n欧尼酱\r\n两天故事线\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n完全不同两条故事线，教科书式感情描述，但有点小虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n冬马琴未\r\n\r\nS\r\n妹妹：还行\r\n兄妹：凑合\r\n妹线：拉跨\r\n牵引着你的到来\r\n\r\n\r\n\r\n《私立アキハバラ学園》\r\n\r\n\r\n\r\n\r\n\r\n粉红\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n粘人\r\n喜欢\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n妹线反转极其拉跨，恶心人，不建议游玩\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n六桜 日奈々（全年龄\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：还行\r\n为你驱散黑暗\r\n\r\n\r\n\r\n《Primary ～Magical★Trouble★Scramble～》\r\n\r\n\r\nAI翻译\r\n\r\n可爱\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n懂事兄控\r\n妹妹\r\n失明\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n全年龄，兄控且令人怜爱的妹妹，男主十足的妹控\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n波佐見 都\r\n\r\nSAAA\r\n妹妹：极好\r\n兄妹：一般\r\n妹线：还行\r\n兄控进行史\r\n\r\n\r\n\r\n《南十字星恋歌》\r\n\r\n\r\n\r\n\r\n兄妹\r\n黑长直\r\n表/堂妹\r\n尼桑/欧尼酱\r\n废萌\r\n黑长直\r\n100分\r\n毒舌兄控\r\n喜欢喜欢\r\n分开\r\n学校住宿\r\n\r\n被膝枕，摸头杀\r\n\r\n\r\n\r\n\r\nS\r\n妹妹兄控黑长直无敌，但有大量党争以及现任哥剧情\r\n\r\n\r\n\r\n\r\n有前任哥（男主）与现任哥（会长）争妹剧情，不过妹妹只爱男主，有妹妹跟真女主党争剧情，而且男主有两个萝莉妹妹却不能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n舞浜 有梨子\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：不错\r\n名为爱情的媚药\r\n\r\n\r\n\r\n《リトルプリンセスＧＯ！》\r\n\r\n\r\nAI翻译\r\n\r\n爱情\r\n茶色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n冷漠热情\r\n暗恋\r\n正常\r\n家庭分开\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n一对兄妹，二次表白，三场约会，节节高升\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n速水 朝顔\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：一般\r\n爱的逃避行\r\n\r\n\r\n\r\n《ココロ＠ファンクション！》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n黑发\r\n亲妹\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n社恐\r\n暗恋\r\n收养人死亡\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n感情戏略少，发糖在h，ai抢走大部剧情甜度\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n桧山 璃子\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n内心深处的依赖\r\n\r\n\r\n\r\n《さくらビットマップ》\r\n\r\n\r\nAI翻译\r\n\r\n隐藏兄控\r\n蓝发\r\n义妹\r\n欧尼酱/欧尼\r\n废萌\r\n美少女\r\n99分\r\n害羞温柔\r\n隐藏\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n隐藏兄控，想撒娇，全文非常丝滑，大量发糖\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n初芝 愛衣\r\n\r\nSSS妹线\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：优秀\r\n初恋之心\r\n\r\n\r\n\r\n《そらいろ》\r\n\r\n\r\n\r\n\r\n初恋\r\n粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n纯朴天真\r\n爱恋\r\n情人成兄妹\r\n兄妹同居\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nB\r\n三条妹线极致的满足，精心打磨，稳步发展，小虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n叶野 夢\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：一般\r\n妹线：还行\r\n交往游戏\r\n\r\n\r\n\r\n《夏の幼馴染と冬のカノジョ》\r\n\r\n\r\nAI翻译\r\n\r\n病弱\r\n灰石色\r\n亲妹\r\n尼\r\n废萌\r\n美少女\r\n93分\r\n病弱\r\n白送\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n开局好感度满，缺失感情铺垫日常发糖，感情升温\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n周防 ななの\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n一起成长的约定\r\n\r\n\r\n\r\n《ほしうた》\r\n\r\n\r\n\r\n\r\n成长\r\n茶色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n柔弱坚强\r\n一直喜欢\r\n男主被收养\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n妹妹的成长记录，兄妹跟奶奶三人的亲情写的很棒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小田島小鈴\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：一般\r\n家人一体\r\n\r\n\r\n\r\n《秋のうららの ～あかね色商店街～》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n紫色\r\n义妹（大）\r\n欧尼/欧尼酱\r\n废萌\r\n美少女\r\n86分\r\n坚强努力\r\n慢慢喜欢\r\n天降\r\n三兄妹住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通不错少有的无血缘的家族情，但妹线感情线差点意思\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小田島 まゆ\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n家人一体\r\n\r\n\r\n\r\n《秋のうららの ～あかね色商店街～》\r\n\r\n\r\nAI翻译\r\n\r\n柔弱\r\n金发\r\n义妹（小）\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n柔弱温柔\r\n喜欢\r\n天降\r\n三兄妹住宿\r\n\r\n怀孕\r\n\r\n\r\n\r\n\r\nA\r\n共通同上，金发柔弱女子，窈窕淑女，一笑倾城\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n不能攻略的妹妹\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n没有妹线\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n久我 满琉\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：无\r\n一直陪伴着你\r\n\r\n\r\n\r\n《时钟机关的朝雾中飘零之花》\r\n\r\n\r\n\r\n\r\n兄妹级\r\n灰石色\r\n亲妹\r\n欧尼酱\r\n剧情作\r\n美少女\r\n95分\r\n兄控病弱\r\n守护\r\n相依为命\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n注意，妹妹不能推！妹妹很兄控，怕生（仅限pc版）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","categories":["其他","galgame相关"],"tags":["其他","galgame相关"]}]