[{"title":"绘隙碎笔","url":"/posts/29865.html","content":"​\r\n才三月份，石家庄就依旧进入繁盛的春天了啊。。。。在我的家乡长久生活的人，不知道会不会感叹这岁月的笔触实在是太快了。\r\n​\r\n又是一节我习惯绘画的课堂，坐在最靠窗户的一排，三月份已然有些许热气，拿出本来，感觉都温暖了许多。\r\n​\r\n我常于这光影交错处徘徊，看日光一寸寸移动，感觉把我生命的长度都不经意的丈量了。\r\n​\r\n所以我把这梦境画下，我又回到那个熟悉的楼里了，那个我可能再也不会有机会回去的，却满含怀念的建筑里。\r\n​\r\n她靠着下午五点半的夕阳，在梦里和我相遇吗。其实不然，在梦里只有楼和我，我却无法把自己画下，只能把祈莉作为我思索的对象，让她替我在一步一步的忧郁。\r\n\r\n\r\nShenBangQili\r\n\r\n\r\n\r\nShenBangQili\r\n\r\n\r\n&#123;% asset_img ShenBangQili.jpg example %&#125;\t\r\n​\r\n本人懈怠，绘画的热度感觉一日不如一日，也许我是想画吧，可是我用时间在绘画上的刻痕实在是太浅，被琐事纠缠的我，大概是无暇提笔哩。。。\r\n​ -2025.3.27 中午\r\n","categories":["杂谈","绘画相关"],"tags":["绘画相关","杂谈"]},{"title":"2025第十六届蓝桥杯Java省B题目加部分题解","url":"/posts/20522.html","content":"由于河北北京这边省赛那两天风很大的原因，所以导致蓝桥杯没有如期进行，所以说来做做已经考完了的人的比赛题目\r\n\r\nA. 逃离高塔\r\n\r\n\r\nA\r\n\r\n\r\n\r\nA\r\n\r\n首先如果不考虑溢出处理，用BigInteger估计一是比较慢二是方法写起来比较麻烦，所以还是取模取出个位数处理，因为只看个位数，所以取模不会对结果产生影响\r\npublic class A &#123;\tpublic static void main(String[] args) &#123;\t\tint res = 0;\t\tfor(int i = 1; i &lt;= 2025; i++) &#123;\t\t\t// 结果只取个位数，在每次乘方过程中都取模取出个位数，防止溢出\t\t\tint temp = (int) (((Math.pow(i, 2) % 10) * i) % 10);\t\t\tif(temp == 3) res++;\t\t&#125;\t\tSystem.out.print(res);\t\t// 202\t&#125;&#125;\r\nB. 消失的蓝宝\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n大模拟题，首先 N 肯定是从\r\n20250413开始遍历，但是直接遍历肯定要慢很多\r\n可以先打表发现，20260411 是第一个满足条件2 的数\r\n// 打表代码public class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor(long n = 20250413; n &lt; Long.MAX_VALUE; n++) &#123;\t\t\tif((n + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t\tif((n + 20240413) % 20250412 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);\t\t// 20260411\t&#125;&#125;\r\n所以从 20260411 开始，每次加 20250412\r\n确保满足条件2，然后判断条件1\r\npublic class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor (long N = 20260411; N &lt; Long.MAX_VALUE; N += 20250412) &#123;\t\t\tif ((N + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = N;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);    // 409876661809331\t&#125;&#125;\r\nC. 电池分组\r\n\r\n\r\nC\r\n\r\n\r\n\r\nC\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n两组电池异或和相等，异或 相同为\r\n0，不同为1，那么相等的数异或和为 0，要求能分成两组，\r\n那么就是意思组内所有数异或后为 0\r\npublic class C &#123;\tpublic static void main(String[] args) &#123;\t\tScanner sc = new Scanner(System.in);\t\tint T = sc.nextInt();\t\tfor(int i = 1; i &lt;= T; i++) &#123;\t\t\tint sum = 0;\t\t\tint N = sc.nextInt(); // 本组电池的数量\t\t\tfor (int j = 1; j &lt;= N; j++) &#123;\t\t\t\tint element = sc.nextInt();\t\t\t\tsum = sum ^ element;\t\t\t&#125;\t\t\tif(sum == 0) &#123;\t\t\t\tSystem.out.println(&quot;YES&quot;);\t\t\t&#125;else &#123;\t\t\t\tSystem.out.println(&quot;NO&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\r\nD. 魔法科考试\r\n\r\n\r\nimage-20250419141858122\r\n\r\n\r\n\r\nimage-20250419141858122\r\n\r\n\r\n\r\nimage-20250419141915330\r\n\r\n\r\n\r\nimage-20250419141915330\r\n\r\n朴素模拟发现只能过2/ 5的数据，那么该如何优化呢\r\nclass Solutions1&#123;\t// 质数筛\tboolean check(int p) &#123;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) return false;\t\t&#125;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\r\n首先，看到时间限制就知道这题不简单。\r\n我们在这里要注意以下几个点\r\n\r\n素数判定只需要判定这个数的算术平方根及以下的数是不是这个数的因数，这样更节省时间。\r\n对于已经判定过的数，不需要判断，所以可以打质数筛\r\nif\r\n判断是有顺序的（从左往右判断）所以素数判定放在最后，当前面不符时，会直接退出就不会再素数判定，节省时间。\r\n\r\n// AC代码import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.util.StringTokenizer;import java.util.*;public class Main &#123;\tpublic static void main(String[] args) &#123;\t\tnew Solutions1();\t&#125;&#125;class Solutions1&#123;\tint[] dx = new int[40004];\t// 质数筛\tboolean check(int p) &#123;\t\t// 已经判定过，就无须再判定\t\tif(dx[p] == 1) return false;\t\tif(dx[p] == 2) return true;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) &#123;\t\t\t\tdx[p] = 1;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t\tdx[p] = 2;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\t\t\tclass FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;/*3 42 3 103 4 5 1 */\r\nE. 爆破\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n题目大意：使用尽可能的小距离使 n 个圆连在一起。\r\n最小生成树，圆和圆的距离可以用圆心距离减半径，用 prim\r\n写吧，算法讲解都在注释里详细写下了\r\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    private int n;    private class cirlce implements Comparable&lt;cirlce&gt; &#123;        int x, y, r;        public cirlce() &#123;        &#125;        public cirlce(int x, int y, int r) &#123;            this.x = x;            this.y = y;            this.r = r;        &#125;        @Override        public int compareTo(cirlce o) &#123;            return this.x - o.x;        &#125;    &#125;    private cirlce[] cirlces = new cirlce[5005];    private double Getdist(int u, int v) &#123;        return Math.sqrt((cirlces[u].x - cirlces[v].x) * (cirlces[u].x - cirlces[v].x) + (cirlces[u].y - cirlces[v].y) * (cirlces[u].y - cirlces[v].y));    &#125;    private double prim() &#123;        boolean[] visited = new boolean[n];  // 用于标记每个顶点是否已经被加入到最小生成树中        double[] dist = new double[n];   // 距离数组        // 初始化        Arrays.fill(visited, false);        Arrays.fill(dist, Double.MAX_VALUE);         // 选择0号为起点，并且设为距离0        dist[0] = 0.0;        double sum = 0.0;    // 最小生成树的边总权重\t    // 每次选择一个顶点加入到最小生成树中        for (int i = 0; i &lt; n; i++) &#123;            int u = -1;            double minDist = Double.MAX_VALUE;   // 最小距离指针            // 找到距离最小生成树最近且未被访问的顶点            for (int j = 0; j &lt; n; j++) &#123;                if(!visited[j] &amp;&amp; dist[j] &lt; minDist)&#123;                    minDist = dist[j];                    u = j;                &#125;            &#125;            // 没有点可以移出去了，说明全部加入            if(u == -1)&#123;                break;            &#125;            visited[u] = true;            sum += minDist;\t\t   // 遍历所有未被访问的顶点，更新它们到最小生成树的距离            for(int v = 0; v &lt; n; v++)&#123;                if(!visited[v])&#123;                    double w;                    double spcr = Getdist(u, v);                    // 圆心之间距离小于等于半径之和，相交相切                    if(spcr &lt;= cirlces[u].r + cirlces[v].r)&#123;                        w = 0.0;   // 不需要搭桥                    &#125;else&#123;                        w = spcr - (cirlces[u].r + cirlces[v].r);                    &#125;                    // 松弛操作                    if(w &lt; dist[v])&#123;                        dist[v] = w;                    &#125;                &#125;            &#125;        &#125;        return sum;    &#125;    public Solutions() &#123;        FastReader sc = new FastReader();        n = sc.nextInt();        for (int i = 0; i &lt; n; i++) &#123;            cirlces[i] = new cirlce(sc.nextInt(), sc.nextInt(), sc.nextInt());        &#125;        double sum = prim();        System.out.printf(&quot;%.2f&quot;, sum);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\nF. 数组翻转\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n贪心，可以发现，答案只跟数组中每个数连续出现的次数有关，如果有两段一样且连续的数但是被分隔开了，那么肯定存在一种翻转方法翻转到答案的数值，所以答案就是统计这两段然后一乘\r\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    public Solutions() &#123;        FastReader in = new FastReader();        int n = in.nextInt();        int[] a = new int[n];        for (int a_i = 0; a_i &lt; n; a_i++) &#123;            a[a_i] = in.nextInt();        &#125;        // 桶，记录最大的两个连续值        int[][] backet = new int[1000086][2];        for(int i = 0; i &lt; n; i++)&#123;            int cp = 0;   // 出现次数            cp++;            // 发现了两个连续的相等的数            while(i &lt; n - 1 &amp;&amp; a[i] == a[i + 1])&#123;                cp++;                i++;   // 指针跳过相同的数            &#125;            // 第一段出现的更长            if(cp &gt; backet[a[i]][0])&#123;                backet[a[i]][1] = backet[a[i]][0];                backet[a[i]][0] = cp;            // 第二段出现的更长            &#125;else if(cp &gt; backet[a[i]][1])&#123;                backet[a[i]][1] = cp;            &#125;        &#125;        long res = 0;        for(int i = 0; i &lt; 1000003; i++)&#123;            // ai * 总段长 （backet[i][1] + backet[i][0]）            long temp = (long) i * (backet[i][1] + backet[i][0]);            if(temp &gt; res)&#123;                res = temp;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\nG. 2的幂\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n数组中所有元素的乘积是 2 的 k 次方倍数。\r\n\r\n要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。\r\n\r\n如果数组中所有元素的 2 的幂次之和大于k，已经符合了，输出0\r\n如果初始的 2 的幂次之和小于\r\nk，则需要通过重新选择或增加数组中的某些元素，来使总的 2 的幂次之和达到\r\nk。\r\n考虑dp\r\n\r\n使用一个 DP 数组 dp，其中 dp[j] 表示在增加的 2 的幂次之和为 j\r\n时，所需的最小增加的数的总和。\r\n遍历数组中的每个数 num，计算其在加上某个正整数后，新数能被 2 的 q\r\n次方整除的最小增量cost，并且能够获得的 2 的幂次增量 gain。\r\n更新 DP 数组，即通过考虑当前数的所有可能增加的选项来更新之前的 DP\r\n状态。\r\n如果 dp[re]（其中 re 是需要补充的 2\r\n的幂次）仍然是无穷大，说明无法达到目标，输出 -1\r\n\r\npackage 动态规划.subject.线性dp.P12160_蓝桥杯2025省JavaB_2的幂;import scala.reflect.internal.util.OwnerOnlyChmod;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions&#123;    // 计算一个数是 2 的几次幂    private int countTwos(int num) &#123;        int count = 0;        while(num % 2 == 0 &amp;&amp; num &gt; 0)&#123;            count++;            num /= 2;        &#125;        return count;    &#125;    public Solutions()&#123;        FastReader fs = new FastReader();        int n = fs.nextInt();        int k = fs.nextInt();    // 目标 2 的幂次        int[] a = new int[n + 1];        for (int i = 1; i &lt;= n; i++) a[i] = fs.nextInt();        // 初始状态 2 的幂次和        int total = 0;        for(int num: a)&#123;            total += countTwos(num);        &#125;        if(total &gt;= k)&#123;            System.out.println(0);            return;        &#125;        // 需要新增的2的幂次        int rp = k - total;  // 差2的rp次幂        int[] dp = new int[rp + 1];        Arrays.fill(dp, Integer.MAX_VALUE);        dp[0] = 0;   // 初始化dp[0]为0，意思是1为初态，不加        // 处理每个数        // 数组中所有元素的乘积是 2 的 k 次方倍数。        // 要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。        for (int i = 0; i &lt; n; i++) &#123;            int num = a[i];            int p = countTwos(num);    // 该数为2的几次幂            // 临时 DP 数组，避免同一组重复选择            int[] tempDp = dp.clone();            // 生成增量选项，开到30差不多            for (int q = p + 1; q &lt;= 30; q++) &#123;                long mp = (long)Math.pow(2, q);    // 2^q                if(mp &gt; 100000) break;   // 注意最大值限制                // 不小于 num 且是 2^q 倍数的最小数 sp                long sp = ((long)num + mp - 1) / mp * mp;                // 新数能被 2 的 q 次方整除的最小增量cost 和 能够获得的 2 的幂次增量 gain。                int cost = (int)(sp - num);                int gain = countTwos((int)sp) - p;                if (gain &lt;= 0) continue;                // 更新dp                for(int j = rp; j &gt;= gain; j--)&#123;                    // dp[j - gain] 不是无穷大，存在一种方式可以到达 j - gain 的 2 的幂次增量                    if(dp[j - gain] != Integer.MAX_VALUE)&#123;                        tempDp[j] = Math.min(tempDp[j], dp[j - gain] + cost);                    &#125;                &#125;            &#125;        &#125;        System.out.println(dp[rp] == Integer.MAX_VALUE? -1 : dp[rp]);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\nH. 研发资源分配\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n可以发现，题目思路类似于田忌赛马，贪心考虑，用下等马换掉对方的上等马\r\n例如题解 1 3 2 用 2 1 3，就是用 最下等的 1 抵掉了 最上等的 3\r\n而且由于是全排列，所以剩下的所有位置一定可以排出都比对方大的排列。\r\n// 我是真不知道为什么洛谷一直给我一个 WA 我也不知道哪里错了）public class Main &#123;    public static void main(String[] args) &#123;        new Solutions2();    &#125;&#125;// 1 2 3    2 3 1  1+2-3=0// 1 4 3 2   2 1 4 3  1-2+3+4=6// 1 3 2 4   2 4 3 1  1+2+3-4=2// 2 3 1 5 4   3 4 2 1 5   1+2+3-4+5// 经过了几个案例的打表，我们发现，总是存在这样一种排列，会使得资源份额的差值最大// 那么就是 对面最多只能拿到一天的分数，而且拿到的只能是等级最高的那天class Solutions2&#123;    public Solutions2()&#123;        FastReader sc = new FastReader();        int n = sc.nextInt();        int[] b = new int[n + 1];        for (int i = 1; i &lt;= n; i++) b[i] = sc.nextInt();        if (n == 1) &#123;            System.out.println(0);            return;        &#125;        long res = 0;        for (int i = 1; i &lt;= n; i++) &#123;            // 对面出动了最大的等级，我们使用最下等的去换取，这天的不要            if(b[i] == n)&#123;                res -= i;            &#125;else&#123;                // 别的情况我们都能凑出一种排列比他大，因为我们用最小的把他最大的给抵出去了                res += i;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\n\r\n\r\nimage-20250419164239152\r\n\r\n\r\n\r\nimage-20250419164239152\r\n\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"Hexo根目录下的_config.yml配置文件","url":"/posts/63024.html","content":"我们在使用hexo初始化一个项目的时候，在根目录下会有一个配置文件_config.yml，这个文件配置了所写博客里面的内容，我们从根目录的该文件来说明每个配置的作用\r\n头注释\r\n_config.yml文件在头部会有一些注释，Hexo Configuration下的两行表示hexo文档的相关文档，Docs指的是hexo的文档，Source指的是hexo的GitHub源码，方便供他人参考查阅\r\n# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/\r\n博客网站相关\r\nSite下面是网站相关的一些信息配置\r\n# Sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doelanguage: entimezone: &#x27;&#x27;\r\ntitle：网站的名字，会写在hexo\r\ngenerator命令生成后的public文件夹下的index.html文件的title标签里，作为你个人博客网站的标题，我们也可以在主题的首页左下角找到\r\nsubtitle：网站的副标题，生成的时候默认为空，一般会出现在你主标题的下面，也就是大约在背景图中间\r\ndescription：主要用于SEO，告诉搜索引擎一个关于站点的简单描述，在官方文档中建议在这段描述中增加自己的一些关键词\r\nkeywords：网站的关键词，使用半角逗号分隔开多个关键词，对SEO的优化有一定的作用\r\nauthor：顾名思义就是作者，这个也只是署个名而已，不会显式的看到\r\nlanguage：这里就写了网站使用的语言\r\ntimezone：网站对应的时区，一般情况下不用去刻意配置，会默认使用电脑的时区，但如果发布到其他地方的服务器，可能会使用当地服务器的时区，一般中国的时区可以设置为Asia/Shanghai或者北京\r\n博客网址相关\r\n# URL## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;url: http://example.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # 设置为false时会将末尾的index.html去掉  trailing_html: true # 设置为false时会将末尾的.html去掉，对index.html无效\r\nurl：指定博客的完整域名或 URL\r\n地址。当你将博客部署到互联网上时，访问者需要通过这个地址来访问你的博客，要确保\r\nurl\r\n地址准确无误，不然可能会导致博客内的链接（如文章内的图片链接、页面跳转链接等）无法正常访问\r\nroot：网站的根目录，指定博客在域名下的根目录，如果你的博客是直接部署在域名的根目录下，就将\r\nroot 设置为\r\n/；若博客部署在域名的子目录下，比如部署在\r\nhttp://example.com/blog 下，那么就需要把 root\r\n设置为 /blog/。正确设置 root\r\n很重要，不然会影响博客内资源（如 CSS、JavaScript\r\n文件等）的加载路径。\r\npermalink：文章的永久链接格式，一般是格式化日期字符串，可以在permalink这里配置，如默认中的配置，在hello\r\nworld文章中就会是这样的url\r\n\r\n当使用Font-matter中的值配置的时候（文章格式标签），可选的值有\r\n\r\n\r\nimg\r\n\r\n\r\npermalink_defaults:设置永久链接的默认值。当你在文章的\r\nFront -\r\nMatter（文章开头的元数据部分）中没有对某些永久链接相关的变量进行设置时，就会使用这里定义的默认值。不过在示例中，没有具体设置默认值，所以会采用\r\nHexo 的默认配置。\r\npretty_urls:就是如注释那样\r\n目录相关\r\n# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:\r\nsource_dir：存放hexo文章的文件夹，我们写的md文件都放在这个配置对应的文件夹下，默认值是source\r\npublic_dir：存放hexo g生成的文件，执行hexo\r\ng后根目录就会出现这个文件夹，默认值是public\r\ntag_dir：按标签存放文章的目录，默认值是tags，如果我们给文章添加标签，使用hexo\r\ng时public文件夹下就会多出一个tags文件夹（根据我们的配置文件夹名不同）\r\narchive_dir：归档文件夹，存放归档文件，默认值为archives\r\ncategory_dir：分类文件夹，按分类存放的文件，和上面的tags一样，只要在文章中的Font-matter添加了categories就会在使用hexo\r\ng构造时出现相应的文件夹\r\ncode_dir：Include code 文件夹，source_dir\r\n下的子目录，默认值为downloads/code\r\ni18n_dir：国际化（i18n）文件夹，默认值:lang\r\nskip_render：跳过指定文件的渲染，匹配到的文件将会被不做改动复制到public文件夹下，如果路径对应的是我们的文章，那会直接忽略掉该文章，我们这样设置来忽略掉hello-world.md文件\r\nskip_render: &quot;_posts/hello-world.md&quot;\r\n​ 然后hexo\r\ng之后可见生成的文件夹只有一些基础的内容，没有和hello-world.md相关的东西\r\n文章相关\r\n# Writingnew_post_name: :title.md default_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: false\r\nnew_post_name：新文章的默认名称，我们是使用hexo\r\nnew来构造文章的，生成的文章名就是通过这里配置的，默认为:title.md，也就是标题.md\r\ndefault_layout：预设布局，指定你新建文章的布局，布局决定了文章在渲染时使用的模板，hexo\r\nnew可以创建三种文件，post/帖子，draft/草稿，page/页面，这里设置默认值在使用hexo\r\nnew就可以直接创建对应默认类型的文章，设置了post就等同于说在命令行执行hexo\r\nnew 和执行hexo new post\r\n是一样的，也可以设置为draft和page\r\ntitlecase：控制是否将文章标题转换为标题大小写格式。当设置为\r\ntrue\r\n时，文章标题会被转换为标题大小写（即每个单词的首字母大写）；设置为\r\nfalse 则不进行转换，保持标题的原始大小写。\r\nexternal_link：\r\n\r\nenable：控制是否在新标签页中打开外部链接。设置为 true\r\n时，文章中的外部链接会在新标签页中打开；设置为 false\r\n则会在当前页面打开。\r\nfield：指定外部链接设置的应用范围。site\r\n表示该设置应用于整个网站。\r\nexclude：指定不应用此外部链接设置的域名或路径。这里为空字符串，表示没有排除的域名或路径。\r\n\r\nfilename_case：控制文件名的大小写规则。取值为\r\n0 时，文件名保持原始大小写；取值为 1\r\n时，文件名转换为小写；取值为 2 时，文件名转换为大写。\r\nrender_drafts：控制是否渲染草稿文章。草稿文章通常存放在\r\nsource/_drafts 目录下。设置为 true\r\n时，草稿文章会被渲染并显示在网站上；设置为 false\r\n则不会渲染草稿文章。\r\npost_asset_folder：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在source文件夹下建立一个统一的images文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，就可以设置为true，控制为每篇文章创建一个同名的资源文件夹。当设置为\r\ntrue 时，使用 hexo new\r\n命令创建文章时，会同时创建一个与文章同名的文件夹，用于存放该文章相关的图片、附件等资源；设置为\r\nfalse 则不会创建。\r\nrelative_link: 控制是否使用相对链接。设置为\r\ntrue 时，文章中的链接会使用相对路径；设置为\r\nfalse 则使用绝对路径。\r\nfuture：控制是否发布未来日期的文章。设置为\r\ntrue\r\n时，即使文章的发布日期设置为未来的某个时间，也会正常发布；设置为\r\nfalse 则不会发布未来日期的文章。\r\nhighlight：代码高亮的显示\r\n\r\nenable：控制是否启用代码高亮功能。设置为 true\r\n时，文章中的代码块会进行高亮显示；设置为 false\r\n则不进行高亮。\r\nline_number：控制是否显示代码块的行号。设置为 true\r\n时，代码块会显示行号；设置为 false 则不显示。\r\nauto_detect：控制是否自动检测代码块的语言。设置为 true\r\n时，Hexo 会尝试自动检测代码块的语言；设置为 false\r\n则需要在代码块中手动指定语言\r\ntable_replace：用n个空格来代表tab键，如果值为空，则不会代替tab键，这里为空字符串，表示不进行替换。\r\nwarp：是否将代码放在table标签里，默认为true\r\nhljs：控制是否使用 highlight.js 进行代码高亮。设置为\r\ntrue 时，使用 highlight.js 进行高亮；设置为\r\nfalse 则使用 Hexo 内置的高亮方式。\r\n\r\n主页设置\r\nindex_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date\r\nindex_generator：主页相关的设置\r\n\r\npath：主页对应的路径，默认为’’，即域名根目录就是主页的路径\r\nper_page：每页显示的帖子数，默认为10\r\norder_by：帖子的排序，默认为-date，即按日期倒序排\r\n\r\n分类和标签\r\n# Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名\r\ndefault_category：当你创建新文章时，如果没有在文章的\r\nFront -\r\nMatter（即文章开头的元数据部分）中明确指定文章的分类，那么这篇文章就会被自动归类到\r\ndefault_category 所指定的分类中。在这个例子里，默认分类是\r\nuncategorized，也就是 “未分类”。\r\ncategory_map：category_map\r\n用于设置分类的别名。在实际写文章和管理博客的过程中，你可能会使用一个比较简洁或者容易输入的分类名，但在博客的展示页面上，你希望使用更正式、美观或者表意更清晰的名称。这时就可以通过\r\ncategory_map 来实现分类名的映射。\r\n例如：\r\ncategory_map:  tech: 技术分享  life: 生活随笔\r\n当你在文章的 Front - Matter 中使用 categories: [tech]\r\n时，在博客的分类页面显示的分类名称将会是 “技术分享”，而不是\r\ntech。\r\ntag_map：tag_map 的作用与\r\ncategory_map\r\n类似，不过它是用于设置标签的别名。在写文章时，你可能会使用一些简单的标签名，但在博客展示时，希望使用更合适的名称，就可以通过\r\ntag_map 来进行映射。\r\n元数据元素\r\n# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true\r\n是否在页面开头插入下面的meta标签，默认为true\r\n\r\n\r\nimg\r\n\r\n日期和时间\r\n# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#x27;s date for updated date unless set in front-matteruse_date_for_updated: false\r\ndate_format：日期格式，默认为YYYY-MM-DD，即年月日\r\ntime_format：时间格式，默认为HH:mm:ss，即时分秒\r\nuse_date_for_updated：启用以后，如果 Front Matter\r\n中没有指定 updated（文件更新日期），post.updated 将会使用 date\r\n的值而不是文件的创建时间，默认值为true\r\n分页\r\n# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page\r\nper_page：分页时每页的文章数，如果为0则不分页，默认为10\r\npagination_dir分页的目录，默认为page，对应于public文件夹下的archives文件夹下的page文件夹，如果只有一页是不会生成这个文件夹的\r\n包括或不包括目录和文件\r\n# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:\r\ninclude：Hexo\r\n默认会忽略隐藏文件和文件夹（包括名称以下划线和 .\r\n开头的文件和文件夹，Hexo 的 _posts 和 _data\r\n等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source\r\n目录下。\r\nexclude：Hexo 会忽略这些文件和目录\r\nignore：忽略的文件,要注意的是，这里要写入的是数组，而yaml的数组要用-值表示数组中一个元素或者直接采用js中数组的写法[]\r\n主题\r\n# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 当前使用的主题名\r\n部署\r\n# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#x27;&#x27;\r\nhexo提供了快速方便的一键部署功能hexo\r\ndeploy，但我们至少需要在_config.yml文件中的deploy中至少配置一个type，比如\r\ndeploy:  type: git\r\ndeploy:  type: git  repo: &lt;repository url&gt; # 库地址  branch: [branch] # 分支名称  message: [message] # 自定义提交信息\r\n参考内容：\r\n部分内容转载自https://blog.csdn.net/zemprogram/article/details/104288872\r\nhexo官方中文文档\r\nhexo官方英文文档（有些中文文档没有的英文文档的才有）\r\nhexo fromt-matter\r\nhexo\r\n部署\r\n","categories":["实用","介绍说明"],"tags":["网站技术","Hexo相关","实用知识"]},{"title":"Hibernate框架之事务控制","url":"/posts/33452.html","content":"事务概述\r\nHibernate是对JDBC的轻量级封装，其主要功能是操作数据库。在操作数据库过程中，经常会遇到事务处理的问题，接下来就来介绍Hibernate中的事务管理。\r\n事务的并发问题\r\n在实际应用过程中，数据库是要被多个用户所共同访问的。在多个事务同时使用相同的数据时，可能会发生并发的问题，具体如下：\r\n\r\n脏读：一个事务读取到另一个事务未提交的数据。\r\n不可重复读：一个事务读到了另一个事务已经提交的update的数据，导致在同一个事务中的多次查询结果不一致。\r\n虚读/幻读：一个事务读到了另一个事务已经提交的insert的数据，导致在同一个事务中的多次查询结果不一致。\r\n\r\n事务的隔离级别\r\n为了避免事务并发问题的发生，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。\r\n\r\n读未提交(Read Uncommitted，1级):\r\n一个事务在执行过程中，既可以访问其他事务提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。此隔离级别可防止丢失更新。\r\n读已提交(Read committed, 2级):\r\n一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。此隔离级别可有效防止脏读。\r\n可重复读(Repeatable Read, 4级):\r\n一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务(但允许读事务),写事务则禁止任何其他事务。此隔离级别可有效的防止不可重复读和脏读。\r\n序列化/串行化(Serializable,\r\n8级):提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。此隔离级别可有效的防止脏读、不可重复读和幻读。\r\n\r\n在使用数据库时候，隔离级别越高，安全性越高，性能越低。\r\n实际开发中，不会选择最高或者最低隔离级别，选择READ_COMMITTED(oracle默认)、REPEATABLE_READ(mysql默认)\r\nHibernate的事务控制\r\nHibernate事务代码规范写法\r\n代码结构\r\ntry &#123; 开启事务 提交事务&#125;catch() &#123; 回滚事务&#125;finally &#123; 关闭&#125;\r\n@Test    public void testTx() &#123;        SessionFactory sessionFactory = null;        Session session = null;        Transaction tx = null;        try &#123;            sessionFactory = HibernateUtils.getSessionFactory();            session = sessionFactory.openSession();            //开启事务            tx = session.beginTransaction();                        //添加            User user = new User();            user.setUsername(&quot;小马&quot;);            user.setPassword(&quot;250&quot;);            user.setAddress(&quot;美国&quot;);                        session.save(user);                        int i = 10/0;            //提交事务            tx.commit();        &#125;catch(Exception e) &#123;            e.printStackTrace();            //回滚事务            tx.rollback();        &#125;finally &#123;            //关闭操作            session.close();            sessionFactory.close();        &#125;    &#125;\r\nHibernate的事务管理\r\n在Hibernate中，可以通过代码来操作管理事务，如通过Transaction  tx=session.beginTransactiong();开启一个事务，持久化操作后，通过tx.commit();\r\n提交事务；如果事务出现异常，又通过tx.rollback();操作来撤销事务(事务回滚)。\r\n除了在代码中对事务开启，提交和回滚操作外，还可以在hibernate的配置文件中对事务进行配置。配置文件中，可以设置事务的隔离级别。其具体的配置方法是在hibernate.cfg.xml文件中的&lt;session-factory&gt;标签元素中进行的。配置方法如下所示。\r\n&lt;!-- 　　　　事务隔离级别       hibernate.connection.isolation = 4       1-Read uncommitted isolation       2-Read committed isolation       4-Repeatable read isolation       8-Serializable isolation      --&gt;        &lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt;\r\n到这里我们已经设置了事务的隔离级别，那么我们在真正进行事务管理的时候，需要考虑事务的应用场景，也就是说我们的事务控制不应该是在DAO层实现的，应该在Service层实现，并且在Service中调用多个DAO实现一个业务逻辑的操作。具体操作如下显示：\r\n\r\n\r\nimg\r\n\r\nHibernate绑定session\r\n在Dao层操作数据库需要用到session对象，在Service控制事务也是使用session对象完成.\r\n我们要确保Dao层和Service层使用的使用同一个session对象。\r\n有两种办法可以实现：\r\n\r\n在业务层获取到Session，并将Session作为参数传递给DAO。\r\n使用ThreadLocal将业务层获取的Session绑定到当前线程中，然后在DAO中获取Session的时候，都从当前线程中获取。\r\n\r\n使用第二种方式肯定是最优方案，具体的实现已经不用我们来完成了，hibernate的内部已经将这个事情做完了。我们只需要在hibernate.cfg.xml中完成一段配置即可。\r\n&lt;!-- 配置session与当前线程绑定 --&gt; &lt;!--  thread：Session对象的生命周期与本地线程绑定(推荐)        jta：Session对象的生命周期与JTA事务绑定        managed：hibernate委托程序来管理Session对象的生命周期。  --&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;\r\n注意：上述配置一般和sessionFactory.getCurrentSession()这个方法一起配合使用。getCurrentSession()方法用来绑定session和ThreadLocal，而且这个与线程绑定的session可以不用关闭，当事务提交时,session会自动关闭，不要手动调用close关闭。\r\n//提供一个方法返回与本地线程绑定的sessionpublic static Session getSession()&#123;\treturn sessionFactory.getCurrentSession();&#125;\r\ngetCurrentSession获取当前线程的session对象，创建session对象之后不需要调用close方法，在线程结束的时候会自动将session关闭，不需要手动关闭，否则会出现session\r\nwas closed 错误\r\npackage com.itzheng.hibernate.demo01;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itzheng.hibernate.utils.HibernateUtils;/* * 测试当前线程绑定的Session */public class HibernateDemo04 &#123;\t@Test\tpublic void demo01() &#123;\t\t//会按照配置的好的事务处理方式去存储数据\t\tSession session = HibernateUtils.getCurrentSession();//保证每一个对象在调用该方法的时候都使用的是同一个session\t\tTransaction transaction = session.beginTransaction();\t\tCustomer customer = new Customer();\t\tcustomer.setCust_name(&quot;王西&quot;);\t\tsession.save(customer);\t\ttransaction.commit();\t\t//session.close();不需要二次关闭session。因为在当前线程结束的时候就会关闭session对象，也就缓存\t&#125;&#125;\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Hibernate框架之实体类编写规则和Session","url":"/posts/21432.html","content":"持久化类\r\nHibernate是持久层的ORM映射框架，专注于数据的持久化工作。\r\n所谓的持久化，就是将内存中的数据永久存储到关系型数据库中。\r\n所谓的持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。\r\n其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。\r\n那么我们编写持久化类的时候有哪些要求呢？\r\n实体类编写规则\r\n我们在编写持久化类的时候需要有一下几点需要注意：\r\n\r\n持久化类需要提供无参数的构造方法。因为在\r\nHibernate 的底层需要使用反射生成类的实例。\r\n持久化类的属性需要私有，对私有的属性提供公有的get和set方法。\r\n因为在Hibernate底层会将查询到的数据进行封装。也就是说，实体类里面属性是私有的\r\n持久化类的属性要尽量使用包装的类型。\r\n因为包装类和基本数据类型的默认值不同，包装类的类型语义描述更清晰而基本数据类型不容易描述。举个例子：\r\n假设表中有一列员工工资，如果使用double类型，如果这个员工工资忘记录入到系统中，系统会将默认值0存入到数据库，如果这个员工的工资被扣完了，也会向系统中存入0.那么这个0就有了多重含义，而如果使用包装类类型就会避免以上情况。如果使用Double类型，忘记录入的工资就会存入null，而如果这个员工的工资被扣完了，就会存入0，不会产生歧义。\r\n持久化类要有一个唯一标识OID与表的主键对应，也就是要求实体类有属性作为唯一值（一般使用id值）\r\n因为Hibernate中需要通过这个唯一标识OID区分在内存中是否是同一个持久化类。在Java中通过地址区分是否是同一个对象，在关系型数据库的表中是通过主键区分是否是同一条记录。那么Hibernate就是通过这个OID来进行区分的。Hibernate是不允许在内存中出现两个OID相同的持久化对象的。\r\n持久化类尽量不要使用final进行修饰。\r\n因为Hibernate中有延迟加载的机制，这个机制中会产生代理对象，Hibernate产生代理对象使用的是字节码的增强技术完成的，其实就是产生了当前类的一个子类对象实现的。如果使用了final修饰持久化类。那么就不能产生子类，从而就不会产生代理对象，那么Hibernate的延迟加载策略（是一种优化手段）就会失效。\r\n\r\n持久化类我们已经可以正常编写了，但是在持久化类中需要有一个唯一标识OID与表的主键去建立映射关系。而且主键一般我们是不会让客户手动录入的，一般我们是由程序生成主键。那么Hibernate中也提供了相应的主键生成的方式，下面我们来看Hibernate的主键生成策略。\r\n主键生成策略\r\n主键的类型\r\n在讲解Hibernate的主键生成策略之前，先来了解两个概念，即自然主键和代理主键，具体如下：\r\n\r\n自然主键（少见）：把具体业务含义的字段作为主键，称之为自然主键。\r\n例如在customer表中，如果把name字段作为主键，其前提条件必须是：每一个客户的名字不允许为null，不允许客户重名，并且不允许修改客户姓名。尽管这也是可行的，但是不能满足不断变化的业务需求，一旦出现了允许客户重名的业务需求，就必须修改数据模型，重新定义表的主键，这给数据库的维护增加了难度。\r\n代理主键：把不具备业务含义的字段作为主键（一般是ID），称之为代理主键。\r\n该字段一般取名为”ID“，通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间。在上面的例子中，显然更合理的方式是使用代理主键。\r\n\r\n主键生成策略\r\nhibernate要求实体类里面有一个属性作为唯一值，对应表主键，主键可以不同生成策略\r\nHibernate中，提供了几个内置的主键生成策略，其常用主键生成策略的名称和描述如下：\r\n\r\n自然主键\r\n\r\nassigned：自然主键生成策略.\r\nhibernate不会管理主键值.由开发人员自己录入。如果不知道 id\r\n元素的generator属性，则默认使用该主键生成策略。\r\n\r\n代理主键\r\n\r\nidentity：主键自增.要求在数据库中把主键定义为自增长类型.录入时不需要指定主键.\r\nsequence：Oracle中的主键生成策略.\r\nincrement(了解)：主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值.只有当没有其他进程向同一张表中插入数据时才可以使用，不能在集群环境下使用。\r\nnative：hilo+sequence+identity 自动三选一策略.适合跨数据库平台开发\r\n自动增长\r\nuuid：产生随机字符串作为主键. 主键类型必须为string 类型.\r\n\r\n\r\n\r\n\r\nimg\r\n\r\n持久化对象的状态\r\n持久化对象的三种状态\r\nHibernate为了更好的来管理持久化类，将持久化类分成了三种状态：瞬时态、持久态和脱管态，一个持久化类的实例可能处于三种不同状态中的某一中。\r\n　　1、瞬时态（transient）\r\n​ 对象里面没有id值，对象与session没有关联，不处于 Session 的缓存中\r\n　　瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate的Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库的数据没有任何关联，仅是一个信息携带的载体。\r\n　　2、持久态（persistent）\r\n​ 对象里面有id值，对象与session关联，也是持久化对象\r\n　　持久态的对象存在持久化标识OID，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。\r\n　　3、脱管态（detached）\r\n​ 对象有id值，对象与session没有关联\r\n　　脱管态也称为离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。\r\n区分对象的三种状态\r\n@Test    public void demo1() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();                Customer customer = new Customer(); //瞬时态对象:没有持久化标识OID,没有被session管理        customer.setCust_name(&quot;王五&quot;);        session.save(customer); // 持久化对象:有持久化标识OID,被session管理                tx.commit();        session.close();                System.out.println(customer); //脱管态对象:有持久化标识OID,没有被session管理    &#125;\r\ncustomer对象由new关键字创建，此时还未与Session进行关联，它的状态称为瞬时态；在执行了session.save(customer)操作后，customer对象纳入了Session的管理范围，这时的customer对象变成了持久态对象，此时Session的事务还没有被提交；程序执行完commit()操作并关闭了Session后，customer对象与Session的关联被关闭，此时customer对象就变成了脱管态。\r\n三种状态的转换\r\n\r\n\r\nimg\r\n\r\n从图中可以看出，当一个对象被执行new关键字创建后，该对象处于瞬时态；当对瞬时态对象执行Session的save()或saveOrUpdate()方法后，该对象将被放入Session的一级缓存，对象进入持久态；当对持久态对象执行evict()、close()或clear()操作后，对象进入脱管态（游离态）；当直接执行Session的get()、load()、find()或iterate()等方法从数据库里查询对象时，查询到的对象也处于持久态；当对数据库中的记录进行update()、saveOrUpdate()以及lock()等操作后，此时脱管态的对象就过渡到持久态；由于瞬时态和脱管态的对象不在Session的管理范围，所以一段时间后会被JVM回收。\r\n持久化对象的三种状态可以通过调用Session中的一系列方法实现状态间的转换，具体如下：\r\n瞬时态转换到其他状态\r\n通过前面学习可知，瞬时态的对象由new关键字创建，瞬时态对象转换到其他状态总结如下：\r\n\r\n瞬时态转换为持久态：执行Session的save()或saveOrUpdate()方法。\r\n瞬时态转换为脱管态：为瞬时态对象设置持久化标识OID。\r\n\r\n　　由于持久化对象状态演化图中没有涉及到瞬时态转换到脱管态的情况，这里做下简要的说明，在前面的学习中可知，脱管态对象存在OID，但是没有Session的关联，也就是说脱管态和瞬时态的区别就是OID有没有值，所以可以通过为瞬时态对象设置OID，使其变成脱管态对象。\r\n持久态对象转换到其他状态\r\n持久化对象可以直接通过Hibernate中Session的get()、load()方法，或者Query查询从数据库中获得，持久态对象转换到其他状态总结如下：\r\n\r\n持久态转换为瞬时态：执行Session的delete()方法，需要注意的是被删除的持久化对象，不建议再次使用。\r\n持久态转换为脱管态：执行Session的evict()、close()或clear()方法。evict()方法用于清楚一级缓存中某一对象；close()方法用于关闭Session，清楚一级缓存；clear()方法用于清除一级缓存的所有对象。\r\n\r\n脱管态对象转换到其他状态\r\n脱管态对象无法直接获得，是由其他状态对象转换而来的，脱管态对象转换到其他状态总结如下：\r\n\r\n脱管态转换为持久态：执行Session的update()、saveOrUpdate()或lock()方法。\r\n脱管态转化为瞬时态：将脱管态对象的持久化标识OID设置为null。\r\n\r\n由于持久化对象状态演化图中没有涉及到脱管态转换到瞬时态的情况，这里做下简要的说明，跟瞬时态转换到脱管态的情况相似，脱管态和瞬时态的区别就是OID有没有值，所有可以通过将脱管态对象的OID设置为null，使其变成瞬时态对象。例如在session.close()操作后，加入代码customer.setCust_id(null)，customer对象将由脱管态转化为瞬时态。\r\n持久态对象能够自动更新数据库\r\n// 测试持久化类的持久化对象有自动更新数据库的能力    @Test    public void demo2() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();        // 获得持久化对象        Customer customer = session.get(Customer.class, 1l);        customer.setCust_name(&quot;王五&quot;);        // session.update(customer); // 不用手动调用update方法j就可以更新        tx.commit();        session.close();    &#125;\r\n执行测试我们会发现，我们并没有手动调用update方法，Hibernate就可以将数据自动更新了。持久态对象之所以有这样的一个功能，其实都依赖了HIbernate的一级缓存。\r\n\r\n这一部分参考\r\nhttps://www.cnblogs.com/yft-javaNotes/p/10244422.html\r\n\r\nHibernate的一级缓存\r\nhibernate的一级缓存默认打开的\r\nhibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围\r\nhibernate的一级缓存中，存储数据必须 持久态数据\r\nHibernate的缓存分为一级缓存和二级缓存（二级缓存现在不使用了），Hibernate的这两级缓存都位于持久化层，存储的都是数据库数据的备份。其中第一级缓存为Hibernate的内置缓存，不能被卸载。接下来围绕Hibernate的一级缓存进行详细的讲解。\r\nHibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的Java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应的数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate一级缓存的作用就是减少对数据库的访问次数。\r\n在Session接口的实现中包含一系列的Java集合，这些Java集合构成了Session缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。所以一级缓存也被称为Session的基本缓存。\r\nHibernate的一级缓存有如下特点：\r\n\r\n当应用程序调用Session接口的save()、update()、saveOrUpdate()时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。\r\n当调用Session接口的load()、get()方法，一级Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询的对象，再去数据库中查询相应的对象，并添加到一级缓存中。\r\n当调用Session的close()方法时，Session缓存会被清空。\r\n\r\n测试一级缓存\r\n// 证明Hibernate一级缓存的存在    @Test    public void demo3() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();        // 马上发送一条sql语句查询1号客户,并将数据存入缓存        Customer customer1 = session.get(Customer.class, 1l);        System.out.println(customer1);        // 没有发送sql语句,从缓存中取的数据        Customer customer2 = session.get(Customer.class, 1l);        System.out.println(customer2);        // true 一级缓存缓存的是对象的地址        System.out.println(customer1 == customer2);        tx.commit();        session.close();    &#125;\r\n以上代码中，第一次执行Session的get()方法获取customer1对象时，由于一级缓存中没有数据，所以Hibernate会向数据库发送一条sql语句，查询id为1的对象；当再次调用Session的get()方法获取customer2对象时，不会再发送sql语句，这是因为customer2对象是从一级缓存中获取的。\r\n当Session对象的生命周期还没有结束的时候,在查询相同的数据对象,会现在缓存之中寻找,如果有找到就直接使用缓存中的数据.\r\n\r\n\r\nimg\r\n\r\n接下来验证一下代码的执行结果是否和描述的一致。在Customer customer1 =\r\nsession.get(Customer.class,\r\n1l);这一行设置断点，用debug方式执行该方法，程序进入断点后点击单步跳过（F6），代码执行过System.out.println(customer1);语句后，控制台的输出结果如下：\r\n\r\n\r\nimg\r\n\r\n从上图的输出结果可以看出，customer2对象的查询结果被直接打印了，说明第二次调用Session对象的get()方法时，没有向数据库发送select语句，而是直接从一级缓存中获取customer2对象。\r\n之前我们介绍过，Hibernate的持久态对象能够自动更新数据库，其实就是依赖了一级缓存。那么一级缓存为什么就可以去更新数据库呢？其实是因为一级缓存的一块特殊区域——快照区。\r\n\r\n\r\nimg\r\n\r\nHIbernate向一级缓存放入数据时，同时复制一份数据放入到Hibernate的快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果这两个对象中的属性发送变化，则执行update语句，将缓存中的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。\r\n// 一级缓存中的快照区:持久态对象能够自动更新数据库    @Test    public void demo4() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();                Customer customer = session.get(Customer.class, 1l);        customer.setCust_name(&quot;张三&quot;);                // 比对缓存中和快照区的数据是否一致,如果一致,不更新数据库        // 如果不一致则自动更新数据库        tx.commit();        session.close();    &#125;\r\nHibernate Session\r\nSession 概述\r\nSession 是什么\r\n\r\n持久化管理器：负责执行所有持久化操作的核心接口\r\n短生命周期对象：通常一个业务操作对应一个Session\r\n一级缓存：维护了持久化对象的缓存\r\n工作单元：代表应用程序与数据库的一次会话\r\n\r\nSession 概述\r\n\r\nSession接口是Hibernate向应用程序提供的操纵数据库的最主要的接口，它提供了基本的保存，更新，删除和加载Java对象的方法\r\nSession 具有一个缓存, 位于缓存中的对象称为持久化对象,\r\n它和数据库中的相关记录对应。Session 能够在某些时间点,\r\n按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库,\r\n这一过程被称为刷新缓存(flush)。也叫一级缓存。\r\n在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了\r\nSession 缓存。 只要 Session 实例没有结束生命周期,\r\n且没有清理缓存，则存放在它缓存中的对象也不会结束生命周期。Session\r\n缓存可减少 Hibernate 应用程序访问数据库的频率。\r\nsession缓存的示例\r\n@Test    public void getUser()&#123;        User user=session.get(User.class,1);        User user2=session.get(User.class,1);        System.out.println(user);        System.out.println(user2);//查询出来的两条记录完全一样    &#125;\r\n站在持久化的角度，Hibemate把对象分为4种状态：持久化态，临时状态，游离状态，删除状态，Session的特定方法能使对象从一个状态转换到另一个状态.\r\n\r\nSession 核心方法\r\n对象状态管理方法\r\n\r\n\r\n\r\n方法\r\n说明\r\n对象状态变化\r\n\r\n\r\n\r\n\r\nsave()\r\n将临时对象持久化\r\n临时 → 持久\r\n\r\n\r\npersist()\r\n同save()，但无返回值\r\n临时 → 持久\r\n\r\n\r\nget()\r\n立即加载对象\r\n无 → 持久\r\n\r\n\r\nload()\r\n延迟加载对象\r\n无 → 代理(持久)\r\n\r\n\r\nupdate()\r\n更新脱管对象\r\n脱管 → 持久\r\n\r\n\r\nmerge()\r\n合并脱管对象状态\r\n脱管 → 持久\r\n\r\n\r\ndelete()\r\n删除对象\r\n持久 → 删除\r\n\r\n\r\nsaveOrUpdate()\r\n智能保存或更新\r\n临时/脱管 → 持久\r\n\r\n\r\nevict()\r\n从缓存移除对象\r\n持久 → 脱管\r\n\r\n\r\nclear()\r\n清空整个缓存\r\n所有持久 → 脱管\r\n\r\n\r\nflush()\r\n同步缓存与数据库\r\n保持状态\r\n\r\n\r\n\r\n查询方法\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\ncreateQuery()\r\n创建HQL查询\r\n\r\n\r\ncreateSQLQuery()\r\n创建原生SQL查询\r\n\r\n\r\ncreateCriteria()\r\n创建Criteria查询(已废弃)\r\n\r\n\r\nbyId()\r\n通过ID加载(5.2+)\r\n\r\n\r\n\r\n事务控制方法\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\nbeginTransaction()\r\n开始事务\r\n\r\n\r\ngetTransaction()\r\n获取当前事务\r\n\r\n\r\n\r\n缓存管理方法\r\nevict()：移除特定对象\r\nsession.evict(student); // 从缓存移除该对象\r\nclear()：清空整个缓存\r\nsession.clear(); // 清空所有缓存对象\r\ncontains()：检查对象是否在缓存\r\nboolean cached = session.contains(student);\r\nsession缓存的操作方法\r\n\r\n\r\nimg\r\n\r\nflush方法：\r\nsession会按照缓存中对象属性的变化来更新数据库中的记录，使数据库中记录和缓存中的对象保持一致，默认情况下，在以下时间点会刷新缓存：\r\n\r\n当应用程序调用Transaction.commit()方法时，该方法会先调用flush()方法，然后在\r\n向 数据库提交事务\r\n显示的调用flush()方法时\r\n当应用程序执行一些查询(HQL,\r\nCriteria)操作时，如果缓存中持久化对象的属性已经发生了变化，会先 flush\r\n缓存，以保证查询结果能够反映持久化对象的最新状态\r\n\r\nflush 缓存的例外情况:\r\n如果对象使用 native 生成器生成 OID, 那么当调用 Session 的 save()\r\n方法保存对象时, 会立即执行向数据库插入该实体的 insert 语句.\r\nflush()和commit()方法的区别：\r\nflush()方法会执行一系列的sql语句，但是不会提交事物；commit()在提交事物前，会先调用flush()方法，然后再提交事物，提交事物以为这将数据库的操作永久的保存下来\r\n测试flush方法\r\n@Testpublic void testFlush()&#123;    News vo = (News) this.session.get(News.class,1);    vo.setInfo(&quot;flush()方法测试&quot;);    this.session.flush();//调用flush()方法    System.out.println(vo);&#125;\r\n可以发现当调用了修改了缓存之中的对象,在调用了flush()方法之后,会执行update语句以来保证缓存之中的数据和数据库之中的数据保持同步\r\n\r\n\r\nimg\r\n\r\n数据库之中保存的数据\r\n\r\n\r\nimg\r\n\r\nrefresh：\r\nrefresh会强制发送select语句，\r\n以使数据库中的记录和缓存中的对象保持一致；如果在调用refresh方法前，手动的修改数据库中的记录，查询出来的结果还不是最新的，这跟数据库的数据的隔离级别是相关的，可以在配置文件中显示的修改事物的隔离级别，每一个隔离级别都对应一个整数；\r\n@Testpublic void testReFlush()&#123;    News vo = (News) this.session.get(News.class,1);    /*使用断点,暂停程序,暂停程序的时候修改数据库中的数据,查看最后输出的内容是否有变化*/    this.session.refresh(vo);    System.out.println(vo);&#125;\r\n在暂停的时候修改数据库中的info数据\r\n\r\n\r\nimg\r\n\r\n但是会发现最后输出的结果并不是修改过的数据，因为可重复读的隔离级别，事务持续期间，禁止其他事务对这个字段进行更新。\r\n\r\n\r\nimg\r\n\r\n缓存同步机制\r\n自动同步：在以下时机会自动flush：\r\n\r\n事务提交时\r\n执行查询前(确保查询结果准确)\r\n显式调用session.flush()\r\n\r\n手动同步：\r\nsession.flush(); // 强制同步缓存与数据库\r\nevict()\r\n从session缓存中把指定的持久化对象移除\r\n@Testpublic void testEvict()&#123;    //使用load()方法将数据库中的一个对象将在到缓存之中    News vo1 = (News)this.session.load(News.class,4);        //使用evict()方法将缓存中的对象清除    this.session.evict(vo1);    //当要使用该对象的时候,系统无法从缓存之中初始化该对象,就会出现异常    System.out.println(vo1);&#125;\r\n\r\n\r\nimg\r\n\r\nSession核心方法详解\r\n对实体类 CURD 操作\r\n添加操作\r\n通过调用session里面的save方法实现\r\nsave()方法最大的特点就是将一个临时对象变为持久化对象\r\n为对象分配ID\r\n在flush()缓存时会发送一条INSERT语句.\r\n@Testpublic void testSave()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);    System.out.println(vo);    this.session.save(vo);    System.out.println(vo);&#125;\r\n\r\n\r\nimg\r\n\r\n\r\n在save()执行前，设置ID的方法是无效的，在save()方法执行过后修改id，会出现异常\r\n\r\n@Testpublic void testSave()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);        //在save()方法执行前设置ID    vo.setId(12345);        System.out.println(vo);    this.session.save(vo);    // 在save()方法执行过后修改id，会出现异常    vo.setId(12345);    System.out.println(vo);&#125;\r\n\r\n\r\nimg\r\n\r\n持久化对象的ID是不能够被修改的\r\n\r\n\r\nimg\r\n\r\n通过调用 presist() 方法\r\npersist()方法也会执行INSERT操作，与save()类似，但无返回值\r\n在presist()方法执行之前,如果对象已经有ID值,则不会执行INSERT,而会抛出一个异常.\r\n@Testpublic void testPersist()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);    vo.setId(12345);    System.out.println(vo);    this.session.persist(vo);    System.out.println(vo);&#125;\r\n\r\n\r\nimg\r\n\r\n与save()的区别：\r\n\r\n不保证立即执行INSERT(可能在flush时执行)\r\n不返回ID，需通过对象获取\r\nJPA规范方法，行为更标准化\r\n\r\n查询操作\r\n调用session里面的get方法实现\r\n执行get()方法会立即加载对象，session.get(实体类的class, id值)是根据\r\nid 查询\r\n@Testpublic void testGet()&#123;    News getVo = (News)this.session.get(News.class,1);    System.out.println(getVo.getClass().getName());&#125;\r\n特点：\r\n\r\n立即发出SELECT语句\r\n对象不存在时返回null\r\n返回真实对象(非代理)\r\n\r\n调用session里面的load方法实现\r\n延迟加载，返回代理对象\r\n执行load方法，若不使用该对象，则不会立即执行查询操作，而返回一个代理对象.\r\n// 返回代理对象，不立即查询Student student = session.load(Student.class, 1L);System.out.println(&quot;尚未查询数据库&quot;);// 实际访问非ID属性时才触发查询System.out.println(student.getName());  \r\n可以发现使用load()方法得到的对象在没有使用的情况下是一个代理对象,这是因为使用load()方法得到的对象，在没有使用任何属性的情况下，不会立即加载,而是加载到内存之中，在有需要的时候再加载对象.\r\n\r\n延迟加载(访问非ID属性时查询)\r\n对象不存在时抛ObjectNotFoundException\r\n返回代理对象(运行时生成子类)\r\n\r\n若查询一个数据表中没有的记录,而且Session也没有被关闭,同时需要使用对象的时候.\r\n\r\n使用get方法查询会：返回null\r\n使用load方法查询：若不是用该对象的任何属性没有问题，若需要初始化，抛出异常.\r\n\r\n在需要初始化代理对象之前若关闭Session. load方法可能会抛出 异常\r\n@Testpublic void testLoad()&#123;    News  loadVo = (News)this.session.load(News.class,1888);    this.session.close();//在使用loadVO类之前关闭session    System.out.println(loadVo);&#125;\r\n抛出的异常org.hibernate.LazyInitializationException: could not initialize proxy - no Session(无法初始化代理,没有Session)\r\n\r\n\r\nimg\r\n\r\n更新操作\r\n自动脏检查更新\r\n最常用方式：Hibernate自动检测变化\r\nStudent student = session.get(Student.class, 1L);student.setName(&quot;王五&quot;);  // 修改属性student.setEmail(&quot;wangwu@example.com&quot;);// 无需调用update方法，提交时自动更新tx.commit();  // 触发UPDATE语句\r\n\r\nSession跟踪持久化对象的状态\r\nflush时比较快照，生成UPDATE语句\r\n\r\n调用session里面的update方法实现\r\n首先查询，修改值，然后调用 update 显式更新脱管对象\r\nupdate()方法相当于sql语句之中的Update语句\r\n\r\n\r\nimg\r\n\r\n若更新一个持久化对象，不必显示的调用update()方法，因为在调用Transaction的commit()方法时，会调用session的flush()\r\n更新一个游离对象，需要显示的调用update()方法，可以将一个游离对象转换为持久化对象\r\n当 update() 方法关联一个游离对象时, 如果在 Session\r\n的缓存中已经存在相同 OID 的持久化对象, 会抛出异常\r\n当 update() 方法关联一个游离对象时, 如果在数据库中不存在相应的记录,\r\n也会抛出异常.\r\n注意：\r\n\r\n无论要更新的游离对象是否与数据表中的记录是否一致,都会发送Update语句.\r\n\r\n@Testpublic void  testUpdate()&#123;    News temp =new News();    temp.setId(1);    temp.setTitle(&quot;update()方法测试&quot;);    temp.setPrice(550.2);    temp.setInfo(&quot;testUpdate&quot;);    temp.setPubDate(new Date());    this.session.update(temp);&#125;\r\n\r\n\r\nimg\r\n\r\n如何能让update方法不再盲目的触发update语句?在.hbm.xml文件的class节点设置一个select-before-update=“true”()但通常不使用该属性\r\n&lt;class name=&quot;News&quot; table=&quot;NEWS&quot; select-before-update=&quot;true&quot;&gt;\r\n\r\n如果数据表中没有对应的记录,但还调用了update方法,会抛出异常\r\n当update()方法关联一个游离对象时,如果在Session的缓存之中已经存在了相同的OID的持久化对象.会出现异常,因为在Session缓存中,不能够同时存在两个OID相同的对象，也就是说\r\n同ID对象已存在于Session时会抛异常\r\n@Test public void  testUpdate()&#123;     //使用get()方法得到一个持久化对象,此时这个对象会保存在session的缓存之中     News vo = (News) this.session.get(News.class,1);        //创建一个于vo的id相同的对象     News temp = new News();     temp.setId(vo.getId());     //使用update()方法关联这个temp对象     //由于此时的temp对象和vo对象的id都是相同的     //并且vo对象已经保存在了session之中     //所以当使用update()方法的时候,就会出现在同一session之中存在两个id相同的对象     this.session.update(temp); &#125;   \r\n\r\n\r\nimg\r\n\r\n应确保对象所有属性已设置(否则可能覆盖为null)\r\n\r\n调用session里面的merge方法实现\r\n更安全的更新方式\r\n将脱管对象的状态复制到持久化对象中\r\nStudent detachedStudent = new Student();detachedStudent.setId(1L);detachedStudent.setName(&quot;钱七&quot;);Session newSession = sessionFactory.openSession();newSession.beginTransaction();// 合并对象状态Student persistentStudent = (Student) newSession.merge(detachedStudent);// merge返回的是持久化对象，参数对象仍为脱管状态System.out.println(detachedStudent == persistentStudent);  // falsenewSession.getTransaction().commit();newSession.close();\r\n方法工作流程\r\n\r\n检查传入对象：\r\n\r\n如果为 null，直接返回 null\r\n如果是持久化状态，直接返回该对象（无操作）\r\n\r\n查找对应持久化对象：\r\n\r\n在 Session 缓存中查找同 ID 的实体\r\n如果找到，将脱管对象属性值复制到该持久化对象\r\n如果未找到，从数据库加载或创建新实例\r\n\r\n返回值处理：\r\n\r\n返回的是持久化对象（可能是缓存中的或新创建的）\r\n重要：传入的参数对象不会被关联到 Session\r\n\r\n状态同步：\r\n\r\n在 flush 时，生成的持久化对象会同步到数据库\r\n\r\n\r\nmerge() 与 update() 的对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\nmerge()\r\nupdate()\r\n\r\n\r\n\r\n\r\n同ID对象存在时\r\n合并属性值到持久化对象\r\n抛出NonUniqueObjectException\r\n\r\n\r\n返回值\r\n返回持久化对象\r\n无返回值\r\n\r\n\r\n参数对象状态\r\n保持脱管状态\r\n转为持久化状态\r\n\r\n\r\nSQL执行时机\r\n根据flush策略\r\n根据flush策略\r\n\r\n\r\n级联行为\r\n支持CascadeType.MERGE\r\n支持CascadeType.UPDATE/SAVE_UPDATE\r\n\r\n\r\n新对象处理\r\n可能转为save操作\r\n抛出TransientObjectException\r\n\r\n\r\n性能\r\n可能需要额外SELECT\r\n直接操作\r\n\r\n\r\n\r\n调用session里面的saveOrUpdate方法实现\r\nSession 的 saveOrUpdate() 方法同时包含了 save() 与 update()\r\n方法的功能，自动判断保存或更新\r\n\r\n\r\nimg\r\n\r\n// 新对象(无ID) - 执行INSERTStudent newStudent = new Student();newStudent.setName(&quot;孙八&quot;);session.saveOrUpdate(newStudent);// 脱管对象(有ID) - 执行UPDATEStudent detachedStudent = new Student();detachedStudent.setId(1L);detachedStudent.setName(&quot;周九&quot;);session.saveOrUpdate(detachedStudent);\r\n判断对象是不是临时对象：\r\n\r\nJava 对象的 OID 为 null\r\n映射文件中为 &lt;id&gt; 设置了 unsaved-value 属性,\r\n并且 Java 对象的 OID 取值与这个 unsaved-value 属性值匹配\r\n\r\n判断逻辑：\r\n\r\n对象ID为null → save()\r\n对象ID非null → update()\r\n\r\n如果OID不为null,但数据表中还没有和其对应的记录,会抛出一个异常.\r\n@Testpublic void testSaveOrUpdate()&#123;    News news = new News();    news.setId(123456);//此时数据库之中不存在此id的数据    this.session.saveOrUpdate(news);//如果调用saveOrUpdate()方法就会出现异常&#125;\r\n\r\n\r\nimg\r\n\r\n删除操作\r\n调用session中的delete() 方法\r\n删除持久化对象，只要OID和数据表中的一条记录对应，就执行delete操作\r\n如果OID和数据库中的一条记录保持一致，则执行删除操作，把对象从 Session\r\n缓存中删除,\r\n该对象进入删除状态，若OID在数据库中没有对应的记录，则抛出异常，Hibernate\r\n的 cfg.xml 配置文件中有一个 hibernate.use_identifier_rollback 属性,\r\n其默认值为 false, 若把它设为 true，改变 delete() 方法的运行行为:\r\ndelete() 方法会把持久化对象或游离对象的 OID 设置为 null,\r\n使它们变为临时对象，软删除\r\nStudent student = session.get(Student.class, 1L);// 删除对象session.delete(student);  // 转为Removed状态// 也可以直接删除(避免先查询)Student studentToDelete = new Student();studentToDelete.setId(2L);session.delete(studentToDelete);  // 按ID删除tx.commit();  // 执行DELETE语句\r\n注意事项：\r\n\r\n删除后对象变为Removed状态\r\n关联对象需考虑级联删除\r\n批量删除建议使用HQL更高效\r\n\r\nSession 方法的完整例子\r\n使用 spring data jpa\r\n添加依赖\r\n&lt;dependencies&gt;    &lt;!-- Spring Boot Starter Data JPA --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;!-- H2 数据库 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.h2database&lt;/groupId&gt;        &lt;artifactId&gt;h2&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- Lombok --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n应用配置 (application.yml)\r\nspring:  datasource:    url: jdbc:h2:mem:testdb    driver-class-name: org.h2.Driver    username: sa    password:   jpa:    hibernate:      ddl-auto: update    show-sql: true    properties:      hibernate:        format_sql: true\r\n定义实体类\r\nimport javax.persistence.*;import lombok.Data;@Data@Entity@Table(name = &quot;students&quot;)public class Student &#123;        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(nullable = false)    private String name;        private String email;        private Integer age;        @Version    private Integer version; // 乐观锁版本字段&#125;\r\nRepository 接口\r\nimport org.springframework.data.jpa.repository.JpaRepository;public interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;&#125;\r\n完整 Service 示例\r\nimport javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.transaction.Transactional;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class StudentService &#123;        @PersistenceContext    private EntityManager entityManager; // 相当于Hibernate Session        private final StudentRepository studentRepository;        public StudentService(StudentRepository studentRepository) &#123;        this.studentRepository = studentRepository;    &#125;        // ========== 创建操作 ==========        /**     * 使用EntityManager的persist方法     */    @Transactional    public Long createWithPersist(Student student) &#123;        entityManager.persist(student);        return student.getId(); // 返回生成的ID    &#125;        /**     * 使用Repository的save方法     */    @Transactional    public Student createWithSave(Student student) &#123;        return studentRepository.save(student);    &#125;        // ========== 读取操作 ==========        /**     * 使用EntityManager的find方法(相当于get)     */    @Transactional    public Student findById(Long id) &#123;        return entityManager.find(Student.class, id);    &#125;        /**     * 使用EntityManager的getReference方法(相当于load)     */    @Transactional    public Student lazyFindById(Long id) &#123;        return entityManager.getReference(Student.class, id);    &#125;        /**     * 使用Repository方法查询     */    public List&lt;Student&gt; findAllStudents() &#123;        return studentRepository.findAll();    &#125;        // ========== 更新操作 ==========        /**     * 自动脏检查更新     */    @Transactional    public Student updateWithDirtyChecking(Long id, String newName) &#123;        Student student = entityManager.find(Student.class, id);        student.setName(newName);        return student; // 事务提交时会自动更新    &#125;        /**     * 使用merge方法更新脱管对象     */    @Transactional    public Student updateWithMerge(Student detachedStudent) &#123;        return entityManager.merge(detachedStudent);    &#125;        // ========== 删除操作 ==========        /**     * 使用EntityManager的remove方法     */    @Transactional    public void deleteWithRemove(Long id) &#123;        Student student = entityManager.find(Student.class, id);        if (student != null) &#123;            entityManager.remove(student);        &#125;    &#125;        /**     * 使用Repository的delete方法     */    @Transactional    public void deleteWithRepository(Long id) &#123;        studentRepository.deleteById(id);    &#125;        // ========== 其他操作 ==========        /**     * 刷新对象状态     */    @Transactional    public Student refreshStudent(Long id) &#123;        Student student = entityManager.find(Student.class, id);        entityManager.refresh(student); // 从数据库重新加载        return student;    &#125;        /**     * 清空持久化上下文     */    @Transactional    public void clearPersistenceContext() &#123;        entityManager.clear();    &#125;        /**     * 立即刷新到数据库     */    @Transactional    public void flushChanges() &#123;        entityManager.flush();    &#125;&#125;\r\n测试控制器\r\nimport org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/api/students&quot;)public class StudentController &#123;        private final StudentService studentService;        public StudentController(StudentService studentService) &#123;        this.studentService = studentService;    &#125;        @PostMapping    public Long createStudent(@RequestBody Student student) &#123;        return studentService.createWithPersist(student);    &#125;        @GetMapping(&quot;/&#123;id&#125;&quot;)    public Student getStudent(@PathVariable Long id) &#123;        return studentService.findById(id);    &#125;        @GetMapping(&quot;/lazy/&#123;id&#125;&quot;)    public Student getStudentLazy(@PathVariable Long id) &#123;        Student student = studentService.lazyFindById(id);        System.out.println(&quot;Before access: Proxy object&quot;);        System.out.println(&quot;Name: &quot; + student.getName()); // 触发实际加载        return student;    &#125;        @GetMapping    public List&lt;Student&gt; getAllStudents() &#123;        return studentService.findAllStudents();    &#125;        @PutMapping(&quot;/&#123;id&#125;&quot;)    public Student updateStudent(@PathVariable Long id, @RequestBody Student student) &#123;        student.setId(id);        return studentService.updateWithMerge(student);    &#125;        @PatchMapping(&quot;/&#123;id&#125;&quot;)    public Student updateName(@PathVariable Long id, @RequestParam String name) &#123;        return studentService.updateWithDirtyChecking(id, name);    &#125;        @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void deleteStudent(@PathVariable Long id) &#123;        studentService.deleteWithRemove(id);    &#125;        @PostMapping(&quot;/refresh/&#123;id&#125;&quot;)    public Student refresh(@PathVariable Long id) &#123;        return studentService.refreshStudent(id);    &#125;&#125;\r\n测试用例\r\nimport javax.transaction.Transactional;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTest@Transactionalclass StudentServiceTest &#123;        @Autowired    private StudentService studentService;        @Test    void testFullCrudCycle() &#123;        // 1. 创建        Student student = new Student();        student.setName(&quot;Test Student&quot;);        student.setEmail(&quot;test@example.com&quot;);        student.setAge(20);                Long id = studentService.createWithPersist(student);        assertNotNull(id);                // 2. 查询        Student found = studentService.findById(id);        assertEquals(&quot;Test Student&quot;, found.getName());                // 3. 更新(自动脏检查)        found.setName(&quot;Updated Name&quot;);        // 不需要显式调用update方法                // 4. 验证更新        Student updated = studentService.findById(id);        assertEquals(&quot;Updated Name&quot;, updated.getName());                // 5. 删除        studentService.deleteWithRemove(id);                // 6. 验证删除        Student deleted = studentService.findById(id);        assertNull(deleted);    &#125;        @Test    void testMergeDetachedEntity() &#123;        // 1. 创建并持久化        Student student = new Student();        student.setName(&quot;Original&quot;);        Long id = studentService.createWithPersist(student);                // 2. 模拟脱管对象        Student detached = new Student();        detached.setId(id);        detached.setName(&quot;Detached&quot;);        detached.setAge(25);                // 3. 合并        Student merged = studentService.updateWithMerge(detached);                // 验证        assertEquals(id, merged.getId());        assertEquals(&quot;Detached&quot;, merged.getName());        assertEquals(25, merged.getAge());    &#125;&#125;\r\nSpring Data JPA 与 Hibernate Session 的关系\r\n\r\nEntityManager：JPA 标准接口，Spring\r\nData JPA 底层使用 Hibernate 实现\r\n\r\npersist() → Hibernate\r\nsave()/persist()\r\nmerge() → Hibernate merge()\r\nfind() → Hibernate get()\r\ngetReference() → Hibernate load()\r\nremove() → Hibernate delete()\r\n\r\nRepository 方法：\r\n\r\nsave()：实际执行 merge 语义\r\ndeleteById()：先查询再删除\r\n\r\n\r\n事务管理\r\n\r\n@Transactional 注解自动管理事务边界\r\n方法结束时自动提交，异常时回滚\r\n同一个事务内共享持久化上下文\r\n\r\n乐观锁冲突处理\r\n@Transactionalpublic Student updateWithOptimisticLock(Long id, String newName) &#123;    Student student = studentRepository.findById(id)        .orElseThrow(() -&gt; new RuntimeException(&quot;Student not found&quot;));        student.setName(newName);        try &#123;        return studentRepository.save(student);    &#125; catch (ObjectOptimisticLockingFailureException e) &#123;        // 处理并发修改冲突        throw new RuntimeException(&quot;数据已被其他用户修改，请刷新后重试&quot;);    &#125;&#125;\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Hibernate,JPA 和 Spring Data JPA 之间的关系","url":"/posts/47644.html","content":"Hibernate， JPA 和 Spring Data\r\nJPA\r\n我们都知道Java 持久层框架访问数据库的方式大致分为两种。\r\n\r\n一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。\r\n另一种是以 Java\r\n实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的\r\nORM框架，如：Hibernate、Spring Data JPA。\r\n\r\nJPA\r\nJPA的全称是Java Persistence API，\r\n即Java持久化API，是SUN公司推出的一套基于ORM的规范。\r\n它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。\r\nJava在操作数据库的时候，底层使用的其实是JDBC，而JDBC是一组操作不同数据库的规范。我们的Java应用程序，只需要调用JDBC提供的API就可以访问数据库了，而JPA也是类似的道理。\r\nJPA统一了Java应用程序访问ORM框架的规范\r\nJPA为我们提供了以下规范：\r\n\r\nORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中\r\nJPA\r\n的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了\r\nJPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。\r\n\r\nHibernate\r\nHibernate是一个JPA规范的具体实现，是ORM类型的框架，对象映射模型。\r\nHibernate是Java中的对象关系映射解决方案。对象关系映射或ORM框架是将应用程序数据模型对象映射到关系数据库表的技术。Hibernate\r\n不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL\r\n数据类型的映射。\r\nHibernate 可以自动生成 SQL 语句，自动执行\r\n关系\r\nJPA规范本质上就是一种ORM规范，不是ORM框架，因为JPA并未提供ORM实现,JPA仅仅定义了一些接口\r\nHibernate除了作为ORM框架之外，它也是一种JPA实现。\r\nSpring Data\r\nSpring Data是Spring\r\n社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。\r\n它提供很多模板操作\r\n\r\nSpring Data Elasticsearch\r\nSpring Data MongoDB\r\nSpring Data Redis\r\nSpring Data Solr\r\n强大的 Repository，和定制的数据储存对象的抽象映射\r\n对数据访问对象的支持\r\n\r\nSpring Data JPA\r\n接口的再次封装抽象更多的可用接口\r\nSpring Data\r\nJPA是在JPA规范下提供了Repository层的再次封装，提供了更多可用的接口，然后底层通过Hibernate实现。\r\nJPA是一种规范，Hibernate是一个实现了JPA规范的框架，Spring Data\r\nJPA是对JPA简化操作的实现，实现了更多可用的接口，底层具体实现用了Hibernate。\r\nSpring Data JPA给我们提供的主要的类和接口\r\nRepository 接口：\r\n\r\nRepository\r\nCrudRepository\r\nJpaRepository\r\n\r\nRepository 实现类：\r\n\r\nSimpleJpaRepository\r\nQueryDslJpaRepository\r\n\r\n以上这些类和接口就是我们以后在使用Spring Data\r\nJPA的时候需要掌握的。\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识","Spring Data JPA"]},{"title":"Hibernate的其他API以及HQL查询.md","url":"/posts/48129.html","content":"Hibernate的其他API\r\nQuery\r\nQuery接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。\r\nHQL：Hibernate Query Language\r\n：Hibernate查询语言。这种语言与SQL的语法及其类似，是一个面向对象的查询语言。\r\nSQL的操作对象是数据表、列等数据库对象，而HQL操作对象是类、对象、属性等。\r\nQuery 接口用来执行 HQL，Query 接口实例可以从 Session 对象 session\r\n中生成：session.createQuery(String hql)\r\n// HQL 查询Query&lt;Student&gt; hqlQuery = session.createQuery(&quot;FROM Student WHERE age &gt; :age&quot;, Student.class);// 原生 SQL 查询Query&lt;Student&gt; sqlQuery = session.createNativeQuery(&quot;SELECT * FROM students WHERE age &gt; ?&quot;, Student.class);\r\n通过 JPA EntityManager 创建\r\n// JPQL 查询javax.persistence.Query jpqlQuery = entityManager.createQuery(&quot;SELECT s FROM Student s WHERE s.age &gt; :age&quot;);// 原生 SQL 查询javax.persistence.Query sqlQuery = entityManager.createNativeQuery(&quot;SELECT * FROM students&quot;);\r\nQuery对象在Session对象关闭之前有效，否则会抛出SessionException异常。因为Session对象就想ＪＤＢＣ中的Connection\r\n对象，即数据库的一次连接。关闭Connection对象，Statement对象就不能再使用，所以关闭Session后就不能再使用Query对象了。\r\nQuery经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。\r\n通过Query即可以执行hql语句:\r\nQuery query = session.createQuery(&quot;hql语句&quot;);\r\n又可以执行本地sql语句：\r\nSQLQuery sqlQuery = session.createSQLQuery(&quot;本地sql语句&quot;);\r\n其中SQLQuery是Query的子类\r\nQuery 接口的主要方法\r\nQuery 的主要方法：\r\nsetxxx():用于设置HQL语句中问号或者变量的值;\r\nsetString(int position,String value);\r\n设置HQL中的“？”的值，其中position代表“？”在HQL中的位置，value是要为“？”设置的值\r\nQuery query=session.createQuery(&quot;from UserInfoPO u where u.age&gt;? and u.useName like ?&quot;);query.setInteger(0, 22);     //使用&quot;?&quot;,第一个下标是从0开始的，给第一个问号赋值22query.setString(1, &quot;%志%&quot;);   //设置第二个问号的值为“%志%”\r\nsetString(String paraName,String value);\r\n设置HQL中“：”后所跟变量的值；其中\r\nparaName代表HQL中“：”后边的变量名，value是该变量的值：\r\nQuery query=session.createQuery(&quot;from UserInfoPO u where u.age&gt;：minAge and u.useName like:useName&quot;);query.setInteger(&quot;minAge&quot;, 22);       //设置minAge的值query.setString(&quot;userName&quot;, &quot;%志%&quot;);   //设置useName的值\r\nsetParameter()方法：参数绑定方法\r\n位置参数绑定\r\nQuery&lt;Student&gt; query = session.createQuery(    &quot;FROM Student WHERE age &gt; ?1 AND name LIKE ?2&quot;,     Student.class);query.setParameter(1, 18);query.setParameter(2, &quot;张%&quot;);\r\n命名参数绑定\r\nQuery&lt;Student&gt; query = session.createQuery(    &quot;FROM Student WHERE age &gt; :minAge AND age &lt; :maxAge&quot;,     Student.class);query.setParameter(&quot;minAge&quot;, 18);query.setParameter(&quot;maxAge&quot;, 25);\r\n分页控制方法：\r\nsetFirstResult：设定从哪一个对象开始检索，参数表示这个对象在查询结果中的索引位置，起始值为0，默认情况下，从查询结果的第一个对象开始检索\r\nsetMaxResults：一次检索最多返回多少数目\r\nQuery&lt;Student&gt; query = session.createQuery(&quot;FROM Student ORDER BY name&quot;, Student.class);query.setFirstResult(10); // 从第10条记录开始(0-based)query.setMaxResults(5);   // 最多返回5条记录List&lt;Student&gt; students = query.getResultList();\r\nlist()；返回查询结果，并把查询结果转换成list对象\r\nQuery query=session.createQuery(&quot;from UserInfoPO u where u.age&gt;：minAge and u.useName like:useName&quot;);           query.setInteger(&quot;minAge&quot;, 22);       //设置minAge的值           query.setString(&quot;userName&quot;, &quot;%志%&quot;);   //设置useName的值           List&lt;UserInfoPO&gt; list=query.list();                     for(int i=0;i&lt;list.size();i++)&#123;       \t   ui=(UserInfoPO)list.get(i);       \t   System.out.println(ui.getUserName());          &#125;\r\ngetResultList();：也可以获取结果列表\r\nList&lt;Student&gt; students = query.getResultList();\r\nexecuteUpdate()：执行更新，删除：\r\nQuery&lt;?&gt; updateQuery = session.createQuery(    &quot;UPDATE Student SET email = :email WHERE id = :id&quot;);updateQuery.setParameter(&quot;email&quot;, &quot;new@example.com&quot;);updateQuery.setParameter(&quot;id&quot;, 1L);int updatedCount = updateQuery.executeUpdate();\r\n标量结果\r\nQuery&lt;Long&gt; countQuery = session.createQuery(    &quot;SELECT COUNT(*) FROM Student&quot;, Long.class);long count = countQuery.getSingleResult();\r\n\r\n查询所有表当中信息\r\n\r\npublic class HibernateDemo5 &#123;\t@Test\t// Query\tpublic void demo01() &#123;\t\tSession session = HibernateUtils.getCurrentSession();\t\tTransaction transaction = session.beginTransaction();\t\t// 通过Session活动Query接口\t\tString hql = &quot;from Customer&quot;;\t\tQuery query = session.createQuery(hql);\t\tList&lt;Customer&gt; list = query.list();\t\tfor (Customer customer : list) &#123;\t\t\tSystem.out.println(customer);\t\t&#125;\t\ttransaction.commit();\t&#125;&#125;\r\n\r\n\r\nimg\r\n\r\n\r\n查询指定字符的数据（条件查询）\r\npublic class HibernateDemo5 &#123;\t@Test\t// Query\tpublic void demo01() &#123;\t\tSession session = HibernateUtils.getCurrentSession();\t\tTransaction transaction = session.beginTransaction();\t\t// 通过Session活动Query接口\t\t// String hql = &quot;from Customer&quot;;\t\tString hql = &quot;from Customer where cust_name like ?&quot;;\t\tQuery query = session.createQuery(hql);\t\tquery.setParameter(0, &quot;王%&quot;);\t\tList&lt;Customer&gt; list = query.list();\t\tfor (Customer customer : list) &#123;\t\t\tSystem.out.println(customer);\t\t&#125;\t\ttransaction.commit();\t&#125;&#125;\r\n\r\n\r\nimg\r\n\r\n分页查询\r\npublic class HibernateDemo5 &#123;\t@Test\t// Query\tpublic void demo01() &#123;\t\tSession session = HibernateUtils.getCurrentSession();\t\tTransaction transaction = session.beginTransaction();\t\t// 通过Session活动Query接口\t\t//分页查询\t\tString hql = &quot;from Customer&quot;;\t\tQuery query = session.createQuery(hql);\t\t//设置分页\t\tquery.setFirstResult(0);//相当于MySQL当中limit的第一个参数\t\tquery.setMaxResults(3);\t\t//query.setParameter(0, &quot;王%&quot;);\t\tList&lt;Customer&gt; list = query.list();\t\tfor (Customer customer : list) &#123;\t\t\tSystem.out.println(customer);\t\t&#125;\t\ttransaction.commit();\t&#125;&#125;\r\n\r\n\r\nimg\r\n\r\n\r\nCriteria与条件查询\r\nCriteria API\r\n是一种面向对象的查询方式，它允许你通过编程方式构建查询条件，而无需编写\r\nSQL 或 HQL。这种方式也被称为 QBC（Query By\r\nCriteria），即 “条件查询”\r\n使用QBC(Query By\r\nCriteria);更加面向对象的一种查询方式。\r\nCriteria接口与Query接口非常类似，也是Hibernate的查询接口，它允许创建并执行面向对象方式的查询。\r\nCriteria的主要作用：\r\n\r\nCriteria查询通过面向对象的设计，将数据查询条件封装为一个对象。简单的说，Criteria查询可以看成是传统SQL语言的对象化表示。\r\nCriteria接口完全封装了基于字符串形式的查询语句，它更擅长于执行动态查询。\r\n\r\n条件查询查询的步骤：\r\n\r\n获得Hibernate的Session对象。\r\n以Session对象创建Criteria对象。\r\n使用Restrictions的方法为Criteria对象设置查询条件，Order工具类的方法设置排序方式，Projections工具类的方法进行统计和分组。\r\n向Criterion查询添加Criterion查询条件。\r\n执行Criteria的list()或uniqueResult()方法返回结果集。\r\n\r\n核心组件\r\n\r\nCriteria：主查询接口，通过\r\nsession.createCriteria(EntityClass.class) 创建。\r\nCriterion：查询条件（如 eq,\r\nlike, gt 等），通过 Restrictions\r\n工具类生成。\r\nProjection：结果集投影（如 count,\r\navg, group by 等），通过\r\nProjections 工具类生成。\r\nOrder：排序规则，通过 Order.asc() 或\r\nOrder.desc() 创建。\r\nDetachedCriteria：独立于 Session\r\n的查询对象，可在多个 Session 中复用。\r\n\r\nimport org.hibernate.*;import org.hibernate.boot.registry.*;import org.hibernate.cfg.*;import org.hibernate.service.*; public class HibernateUtil &#123;    public static final SessionFactory sessionFactory;     static &#123;        try &#123;            // 使用默认的hibernate.cfg.xml配置文件创建Configuration实例            Configuration cfg = new Configuration().configure();            // 以Configuration实例来创建SessionFactory实例            ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();            sessionFactory = cfg.buildSessionFactory(serviceRegistry);        &#125; catch (Throwable ex) &#123;            System.err.println(&quot;Initial SessionFactory creation failed.&quot; + ex);            throw new ExceptionInInitializerError(ex);        &#125;    &#125;     // ThreadLocal可以隔离多个线程的数据共享，因此不再需要对线程同步    public static final ThreadLocal&lt;Session&gt; session = new ThreadLocal&lt;Session&gt;();     public static Session currentSession() throws HibernateException &#123;        Session s = session.get();        // 如果该线程还没有Session,则创建一个新的Session        if (s == null) &#123;            s = sessionFactory.openSession();            // 将获得的Session变量存储在ThreadLocal变量session里            session.set(s);        &#125;        return s;    &#125;     public static void closeSession() throws HibernateException &#123;        Session s = session.get();        if (s != null)            s.close();        session.set(null);    &#125;&#125;\r\n在条件查询中，Criteria接口代表一次查询，该查询本身不具备任何数据筛选功能，Session调用createCriteria(Class\r\nclazz)方法对某个持久化类创建条件查询实例。\r\n常用的Criteria操作方法：\r\n\r\nadd()方法：它用来设置查询的条件，可以根据查询条件的个数，追加任意个add()方法。\r\naddOrder()方法：用来设置查询结果集的排序规则，相当于SQL语句中的order\r\nby子句。\r\ncreateCriteria()方法：当需要从多张表中联合查询时可使用createCriteria()方法。\r\nsetFirstResult(int firstResult)：设置查询返回的第一行记录。\r\nsetMaxResults(int maxResults)：设置查询返回的记录数。\r\n\r\n//分页查询前10条Criteria criteria = session.createCriteria(Customer.class);criteria.addOrder( Order.asc(&quot;name&quot;) ); //排序方式criteria.setFirstResult(0);criteria.setMaxResults(10);List result = criteria.list（）\r\n常用查询条件\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n说明\r\n示例\r\n\r\n\r\n\r\n\r\neq(property, value)\r\n等于\r\nRestrictions.eq(\"age\", 20)\r\n\r\n\r\nne(property, value)\r\n不等于\r\nRestrictions.ne(\"name\", \"张三\")\r\n\r\n\r\ngt(property, value)\r\n大于\r\nRestrictions.gt(\"age\", 18)\r\n\r\n\r\nge(property, value)\r\n大于等于\r\nRestrictions.ge(\"score\", 90)\r\n\r\n\r\nlt(property, value)\r\n小于\r\nRestrictions.lt(\"age\", 30)\r\n\r\n\r\nle(property, value)\r\n小于等于\r\nRestrictions.le(\"price\", 100.0)\r\n\r\n\r\nlike(property, value)\r\n模糊查询（支持 % 和 _）\r\nRestrictions.like(\"name\", \"张%\")\r\n\r\n\r\nin(property, values)\r\n包含在集合中\r\nRestrictions.in(\"id\", Arrays.asList(1, 2, 3))\r\n\r\n\r\nisNull(property)\r\n为空\r\nRestrictions.isNull(\"email\")\r\n\r\n\r\nisNotNull(property)\r\n不为空\r\nRestrictions.isNotNull(\"phone\")\r\n\r\n\r\nand(criterion1, criterion2)\r\n逻辑与\r\nRestrictions.and(gt(\"age\", 18), like(\"name\", \"张%\"))\r\n\r\n\r\nor(criterion1, criterion2)\r\n逻辑或\r\nRestrictions.or(eq(\"status\", 1), isNull(\"deleted\"))\r\n\r\n\r\n\r\n\r\nHQL查询\r\nHQL查询语句\r\nHQL ——(Hibernate Query\r\nLanguage)：Hibernate语言查询它是完全面向对象的查询语句，查询功能非常强大，具备继承、多态和关联等特性\r\n。Hibernate官方推荐使用HQL进行查询。 QBC——(Query By\r\nCriteria)：标准化对象查询，以对象的方式进行查询，将查询语句封装为对象操作。优点：可读性好，符合Java\r\n程序员的编码习惯。 Native SQL\r\nQueries：原生SQL查询，直接使用数据库提供的SQL方言进行查询。\r\nHQL是Hibernate Query\r\nLanguage的缩写，HQL的语法与SQL相似，但HQL是一种面向对象的查询语言。SQL的操作对象是数据表、列等数据库对象，而HQL操作对象是类、对象、属性等。\r\nHibernate查询语言（HQL）是面向对象的查询语言，其结构与SQL查询相似，不同的是，HQL查询的主体是持久化类而不是数据表。\r\nHQL提供了一种应用和数据库之间的抽象，提高了可移植性。\r\nHQL子句本身大小写无关，但是其中出现的类名和属性名必须注意大小写。\r\nHQL是完全面向对象的查询语言，支持继承和多态等特性。\r\nHQL语句本身是不区分大小写的，也就是说HQL语句的关键字、函数都是不区分大小写的。但HQL语句中所有使用的包名、类名、实例名、属性名都区分大小写。\r\nHQL查询依赖于Query类，每个Query对象对应一个查询对象。查询步骤如下：\r\n\r\n获取Hibernate Session对象。\r\n编写HQL查询语句。\r\n以HQL语句为参数，调用session的createQuery方法，创建查询对象Query。\r\n如果HQL语句中带有参数，则调用Query的setXxx方法，对参数赋值。\r\n调用Query的list, unique Result等方法，查询获得结果。\r\n\r\nfrom子句\r\nfrom是最简单的HQL语句，也是最基本的HQL语句。from关键字后紧跟持久化类的类名。\r\nfrom Person表明从Person 持久化类中选出全部的实例。from Person as p | from Person p–\t为实体类指定别名\r\nfrom后还可以同时出现多个持久化类，此时将产生一个笛卡尔积或跨表的连接。但实际上这种用法很少使用，因为通常需要使用跨表连接时，可以考虑使用隐式连接或者显式连接，而不是直接在from后紧跟多个表名。\r\n基本查询结构\r\nSELECT [DISTINCT] 属性列表 FROM 实体名 [AS] 别名 [WHERE 条件] [GROUP BY 分组属性] [HAVING 分组条件] [ORDER BY 排序属性 [ASC|DESC]]\r\n// 查询所有学生String hql = &quot;FROM Student&quot;;Query&lt;Student&gt; query = session.createQuery(hql, Student.class);List&lt;Student&gt; students = query.getResultList();// 带别名的查询String hql = &quot;FROM Student AS s WHERE s.age &gt; 20&quot;;Query&lt;Student&gt; query = session.createQuery(hql, Student.class);\r\n关联和连接\r\n当程序需要从多个数据表中取得数据时，SQL语句将会考虑多表连接查询。Hibernate使用关联映射来处理底层数据表之间的连接，一旦提供了正确的关联映射后，当程序通过Hibernate进行持久化访问时，将可利用Hibernate关联来进行连接。\r\nHQL支持两种关联连接形式：显式和隐式。\r\n隐式连接不需要使用join关键字，使用英文点号（.）来隐式连接关联实体，而Hibernate底层将自动进行关联查询。\r\n// 查询部门名称为&quot;研发部&quot;的学生String hql = &quot;FROM Student s WHERE s.department.name = &#x27;研发部&#x27;&quot;;\r\n使用显示连接可以为相关联的实体，甚至是关联集合中的全部元素指定一个别名。\r\n\r\ninner join内连接，可简写为join\r\nleft outer join左外连接\r\nright outer join右外连接\r\nfull join全连接\r\n\r\nString hql=&quot;select p from person p inner join p.myevent e where e.title like&#x27;%上课%&#x27;&quot;;\r\n隐式连接和显式连接的区别：\r\n隐式连接底层将转换成SQL99的交叉连接，显式连接将转换成SQL99的inner\r\njoin、left join、right join等连接。\r\n隐式连接和显式连接查询后返回的结果不同。当HQL省略关键字select时，隐式连接返回的结果是多个被查询实体组成的集合；显示连接查询返回的是被查询的持久化对象和被关联的持久化对象组成的数组。\r\n\r\n隐式连接查询中，在HQL中，省略select，直接使用from开头 例如：from\r\nMessage m where m.topic.id=3\r\n对Message和Topic进行了连接查询，但是结果只包含Message的数据，结果为：List\r\n显示连接查询中，在HQL中，省略select，直接使用from开头 例如：from\r\nMessage m join m.topic t where t.id=3;\r\n对Message和Topic进行了连接查询，每条记录包含Message和Topic两个实体的数据，两个实体构成一个数组，多条记录构成集合，结果为：List&lt;Object[\r\n]&gt;\r\n\r\nSELECT子句\r\nselect子句用于选择指定的属性或直接选择某个实体，当然select选择的属性必须是from后持久化类包含的属性。\r\nselect选择的属性是实体类的属性；结果是一个集合，集合中的每个元素是一个Object数组：Object[]\r\n查询特定属性\r\n// 只查询姓名和年龄String hql = &quot;SELECT s.name, s.age FROM Student s&quot;;Query&lt;Object[]&gt; query = session.createQuery(hql, Object[].class);// 查询结果自动封装为对象List&lt;Object[]&gt; results = query.getResultList();results.forEach(row -&gt; &#123;    String name = (String) row[0];    Integer age = (Integer) row[1];    System.out.println(name + &quot;: &quot; + age);&#125;);\r\n使用 DTO\r\n// 创建DTO类public class StudentDTO &#123;    private String name;    private Integer age;    // 构造器、getter/setter&#125;// 查询并使用构造器String hql = &quot;SELECT NEW com.example.StudentDTO(s.name, s.age) FROM Student s&quot;;Query&lt;StudentDTO&gt; query = session.createQuery(hql, StudentDTO.class);\r\n聚合函数\r\nHQL中支持的聚合函数有：concat(str,str)、substring()、trim()、lower()、upper()、length()、abs()、sqrt()、mod()、count()、avg()、min()、max()、sum()、current_date()、current_time()、current_timestamp()、day()、\r\nmonth()、year()等。\r\n也可以支持数学运算和连接符号等\r\n同时也支持经验证SQL函数，如length()、lower()、upper()、trim()等\r\n可以使用distinct去除重复数据\r\n// 统计各年龄段学生数量String hql = &quot;SELECT s.age, COUNT(s) FROM Student s GROUP BY s.age&quot;;Query&lt;Object[]&gt; query = session.createQuery(hql, Object[].class);\r\nWHERE子句\r\nwhere子句用来筛选选中的结果，缩小选择范围。如果没有持久化实例命名别名，则可以直接使用属性名来引用属性。\r\nwhere子句中支持大部分SQL的表达式：\r\n设置参数\r\n// 冒号+参数名from Person p where p.age &lt;:max query.setInteger(“max”,20);// 问号为占位符from Person p where p.age &lt;？ query.setInteger(0,20);// 问号与指定数字位置from Person p where p.age &lt;？1query.setInteger(“1“,20);\r\n基本条件\r\n// 比较运算String hql = &quot;FROM Student s WHERE s.age &gt; 20&quot;;// 模糊查询String hql = &quot;FROM Student s WHERE s.name LIKE &#x27;张%&#x27;&quot;;// 范围查询String hql = &quot;FROM Student s WHERE s.age BETWEEN 18 AND 22&quot;;// 空值检查String hql = &quot;FROM Student s WHERE s.email IS NOT NULL&quot;;\r\n集合查询\r\n// IN 查询String hql = &quot;FROM Student s WHERE s.name IN (&#x27;张三&#x27;, &#x27;李四&#x27;)&quot;;// 集合大小String hql = &quot;FROM Student s WHERE s.projects.size &gt; 2&quot;;// 集合元素检查String hql = &quot;FROM Student s WHERE &#x27;数学&#x27; MEMBER OF s.courses&quot;;\r\nHQL子查询\r\n如果底层数据库支持子查询（所谓子查询就是，要查询的字段及信息在A表，条件在B表），则可以在HQL语句中使用子查询。与SQL中子查询相似的是，HQL中的子查询也需要使用()。\r\n如果子查询返回多条记录，则可以使用下面关键字：\r\n\r\nall：表示子查询语句返回的所有记录。\r\nany：表示子查询语句返回的任意一条结果。\r\nsome：与”any”等价。\r\nin：与”=any”等价。\r\nexists：表示子查询语句至少返回一条记录。\r\n\r\n如果在子查询中操作集合，HQL提供了一组操纵集合的函数和属性：\r\nsize()函数和size属性：获得集合中元素的数量。\r\nminIndex()函数和minIndex属性：对于建立了索引的集合获得最小索引值（关于集合索引参考第一部分映射值类型集合）。\r\nminElement()函数和minElement属性：对于包含基本类型的元素集合，获得集合中值最小的元素。\r\nmaxElement()函数和maxElement属性：对于包含基本类型元素的集合，获得集合中值最大的元素。\r\nelement()函数：获得集合中所有元素。\r\n更新和删除\r\n更新：执行删除操作调用Query接口的executeUpate()方法，然后提交事务\r\nHQL：Delete from Student where id = 10\r\n删除：执行删除操作调用Query接口的executeUpate()方法，然后提交事务\r\nHQL：update Student set age = 20,name=‘李四’ where id = 20\r\nSQL查询\r\nHibernate还支持使用原生SQL查询，使用原生SQL查询可以利用某些数据库的特性，或者需要将原有JDBC应用迁移到Hibernate应用上，也可能需要使用原生SQL查询。类似于HQL查询，原生SQL查询也支持将SQL语句放在配置文件中配置，从而提高程序的解耦。命名SQL查询还可以用于调用存储过程。\r\nSQL查询是通过SQLQuery接口来表示的，SQLQuery 接口是Query\r\n接口的子接口，因此完全可以调用Query 接口的方法：\r\n\r\nlist()：获取记录集。\r\nuniqueResult()：返回唯一记录。\r\naddEntity()：将查询到的数据封装为特定的实体。\r\nsetFirstResult()：设置结果集的起点。\r\nsetMaxResults()：设置获取记录的最大条数。\r\naddScalarˈskeɪlə ()：将查询的记录关联成标量值。\r\n\r\n执行SQL查询的步骤：\r\n\r\n获取Session对象。\r\n编写SQL语句。\r\n以SQL语句作为参数，调用Session的createSQLQuery()方法创建查询对象。\r\n调用SQLQuery对象的addScalar()或addEntity()方法将选出的结果与标量值或实体进行关联。\r\n如果SQL语句包含参数，则调用Query的setXxx()方法为参数赋值。\r\n调用Query的list()方法或uniqueResult()方法返回查询的结果集。\r\n\r\n标量查询\r\n最基本的SQL查询就是获得一个标量（数值）列表。\r\n标量查询（Scalar\r\nQuery）是指直接返回数据库列值（而非实体对象）的查询方式。\r\nsession.createSQLQuery(&quot;select * from student&quot;).list();\r\n默认情况下，查询语句将返回由Object数组组成的List，数据的每个元素时student表的列值，Hibernate会通过ResultSetMetadata来判定所返回数据列的实际顺序和类型。如果select后面只有一个字段，那么返回的List集合元素就不是数组，而只是单个的变量值。\r\n当执行 SQL 查询且未指定返回类型时，Hibernate 默认返回\r\nList，每个数组元素对应数据库的一列：\r\n// 默认行为：返回 Object [] 列表SQLQuery query = session.createSQLQuery(&quot;SELECT id, name, age FROM student&quot;);List&lt;Object[]&gt; results = query.list();// 遍历结果for (Object[] row : results) &#123;    Long id = (Long) row[0];       // 第一列    String name = (String) row[1]; // 第二列    Integer age = (Integer) row[2]; // 第三列    // 处理数据&#125;\r\n如果 SQL 中只选择一个字段，Hibernate 会直接返回\r\nList&lt;列类型&gt;：\r\nSQLQuery query = session.createSQLQuery(&quot;SELECT name FROM student&quot;);List&lt;String&gt; names = query.list(); // 直接返回 String 列表\r\n使用 addScalar() 指定返回类型\r\naddScalar() 方法用于明确指定返回列的类型，避免 Hibernate\r\n通过 ResultSetMetadata\r\n动态推断类型，从而提高性能，因此建议为这些数据列指定更明确的返回值类型。明确指定返回值类型通过addScalar()方法实现。addScalar()主要有两个作用：\r\n\r\n指定查询结果包含那些数据列——没有被addScalar()选出的列将不会包含在查询结果里面中。\r\n指定查询结果中数据列的数据类型。\r\n\r\nSQLQuery query = session.createSQLQuery(&quot;SELECT id, name, age FROM student&quot;);query.addScalar(&quot;id&quot;, StandardBasicTypes.LONG)    // 指定 id 为 Long 类型     .addScalar(&quot;name&quot;, StandardBasicTypes.STRING) // 指定 name 为 String 类型     .addScalar(&quot;age&quot;, StandardBasicTypes.INTEGER); // 指定 age 为 Integer 类型List&lt;Object[]&gt; results = query.list();\r\n此时Hibernate不再需要使用ResultSetMetadata来获取信息，而是直接从ResultSet中取出name列的值，并把name列的数据类型当成字符串处理。因此，即使使用了“*”作为查询的字段列表，但Hibernate查询的结果也只是name字段所组成的表。\r\n在原生SQL查询里，程序指定的原生SQL语句时标准的SQL语句，因此SQL语句中使用的就是数据表、数据列等对象，而不是持久化类、属性。\r\n实体查询\r\n前面的标量值查询只是返回一些标量的结果集，这种查询方式与使用JDBC查询的效果基本类似。查询返回多个记录行，每个记录对应一个列表的元素，每个列表元素是一个数组，每个数组元素对应当前行、当前列的值。\r\n如果查询返回了某个数据表的全部数据列，且该数据表有对应的持久化类映射，接下来就可把查询结果转换成实体。将查询结果转换成实体，可以使用SQLQuery提供的多个重载addEntity()方法。\r\n使用 addEntity(Class entityClass)\r\n方法将查询结果映射为实体\r\nList list = session.createSQLQuery(&quot;select * from animal&quot;)            .addEntity(Animal.class)            .list();\r\n注意事项：\r\n\r\n必须查询所有列：SQL\r\n中需包含实体类映射的所有字段（通常用 SELECT *）。\r\n外键列必须存在：若实体包含 @ManyToOne\r\n等关联，SQL 必须返回对应的外键列（如 owner_id）。\r\n列名与属性名需匹配：默认情况下，数据库列名需与实体属性名一致（或通过\r\n@Column 注解映射）。\r\n\r\n在原生SQL中一样支持使用参数，这些参数既可以使用问号+索引的占位符参数（?N），也可以使用名字参数。\r\n\r\n不仅如此，如果在SQL语句中显式使用了多表连接，则SQL语句可以选出多个数据表的数据。Hibernate还支持将查询结果转换成多个实体。如果要将查询结果转换成多个实体，则SQL字符串中应为不同数据表指定不同的别名，并调用addEntity(String\r\nalias,Class entityClass)方法将不同的数据表转换成不同实体。\r\n当 SQL 中使用列别名时，需通过 @Column 注解或\r\nResultTransformer 显式映射：\r\n// SQL 使用别名SQLQuery query = session.createSQLQuery(&quot;SELECT id AS animal_id, name FROM animal&quot;);// 方法一：在实体类的属性上添加 @Column 注解@Column(name = &quot;animal_id&quot;)private Long id;// 方法二：使用 ResultTransformerquery.setResultTransformer(Transformers.aliasToBean(Animal.class));\r\n不仅如此，Hibernate还可以将查询结果转换成非持久化实体（即普通的JavaBean），只要该JavaBean为这些数据提供了对应的setter和getter方法即可。Query接口提供了一个setResulltTransformer()方法，该方法可接受一个Transformers对象，通过使用该对象即可把查询到的结果集转换成JavaBean集。\r\n使用 Transformers.aliasToBean(Class) 将结果映射到普通\r\nJavaBean：\r\n// 创建 JavaBeanpublic class AnimalDTO &#123;    private Long id;    private String name;    private String ownerName;    // getter/setter 方法&#125;\r\nString sql = &quot;SELECT a.id, a.name, o.name AS ownerName &quot; +             &quot;FROM animal a JOIN owner o ON a.owner_id = o.id&quot;;SQLQuery query = session.createSQLQuery(sql);query.setResultTransformer(Transformers.aliasToBean(AnimalDTO.class));List&lt;AnimalDTO&gt; dtos = query.list();\r\n\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"Hibernate框架之介绍与初识Hibernate程序","url":"/posts/48900.html","content":"Hibernate介绍\r\nHibernate是一个开源的Java对象关系映射（ORM）框架，它提供了一种方便的方式将Java对象与关系型数据库进行映射和交互。通过Hibernate，开发人员可以使用面向对象的方式操作数据库，而不需要直接编写SQL查询语句\r\n架构图\r\n\r\nHibernate是一个开源的对象关系映射（ORM）框架，用于将Java对象映射到关系型数据库中的关系表。\r\n它提供了一种面向对象的方式来操作数据库，简化了开发人员对数据库的访问和管理\r\n如何理解提供了一种面向对象的方式来操作数据库。\r\n\r\n一方面：Hibernate可以将定义好的java类映射为数据库中的表，并将java类的实例化的对象，映射为对应表中的一行记录。\r\n另一方面：使用Hibernate，开发人员可以直接操作对象，不需要编写复杂的SQL语句。通过对象的属性和方法来进行数据的读取、修改和删除等操作。\r\n\r\nHibernate提供的核心功能和特性\r\nORM映射（可以将java对象与数据库表之间进行映射，实现对象和关系数据库之间的转换，支持各种映射策略和注解）；\r\n数据库查询（提供了一组丰富的API，用于执行数据库操作，包括插入、更新、删除、查询，还支持HQL和基于SQL的查询一级Criteria查询和原生SQL查询）；\r\n缓存机制(Hibernate内置了一级缓存和二级缓存机制，用于提供查询性能和减少数据库的访问。一级缓存是会话级别的缓存，保存了会话期间加载的实体对象。二级缓存是跨会话的缓存，可以在多个会话之间共享缓存数据）；\r\n事物管理（可以通过编程或声明式的方式管理数据库事物。支持标准的java事物API（JTA）和本地事物管理）；\r\n延迟加载（允许按需加载关联对象，提高查询性能。这意味着只有在需要访问关联对象时，才会从数据库中加载相应的数据。）；\r\n对象状态管理（通过跟踪对象的状态来管理对象的持久化。它提供了持久化、脱管和删除等状态之间的转换，使开发人员能够方便地操作对象。）\r\n对象的持久化\r\n把对象永久的保存到数据库中\r\n持久化包括和数据库相关的各种操作\r\n\r\n保存\r\n更新\r\n删除\r\n查询\r\n加载：加载特定的 OID，把一个对象从数据库加载到内存中\r\n\r\nOID：为了在系统中能找到所需对象，需要为对象分配一个唯一的标识号，在关系型数据库中称为主键，在对象术语中叫对象标识OID\r\nORM 对象关系映射\r\nORM主要解决对象-关系的映射\r\n\r\n类的一个对象可以对应一张表，对象对应表的行，属性对应位表的列\r\n\r\nORM的思想：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。\r\nORM 采用元数据来描述对象-关系映射细节,元数据通常采用XML\r\n格式,并且存放在专门的对象-关系映射文件中。描述数据的数据\r\n\r\n\r\nimage-20250510201350695\r\n\r\nHibernate框架的优点\r\n\r\n使开发更加面向对象化：Hibernate提供了一个面向对象的编程模型，使开发人员可以使用面向对象的思想来操作数据库。\r\n提高开发效率：Hibernate提供了许多强大的特性和工具：如自动生成数据库表结构，提供了公共的操作数据库的方法，让开发人员不用写SQL语句、缓存机制、事物管理。可以大大减少开发人员的工作量，提高开发效率。\r\n可移植性：Hibernate可以在不同的数据库系统上运行，如Mysql、Oracle、SQL\r\nServer等，开发人员可以使用统一的API和语法，无需关系底层数据库的差异。\r\n\r\nHibernate、jpa、jdbc他们三者之间是什么关系\r\n\r\njdbc：jdbc是Java提供的用于与关系型数据库进行交互的标准API，它提供了一组接口和类，使开发人员能够执行数据库的连接、查询、更新等操作。JDBC\r\n需要开发人员手动编写 SQL\r\n查询和处理数据库结果集，对于较低层次的数据库操作提供了灵活性。使开发人员能够执行数据库的连接、查询、更新等操作。JDBC\r\n需要开发人员手动编写 SQL\r\n查询和处理数据库结果集，对于较低层次的数据库操作提供了灵活性。\r\nJPA：JPA是Java持久化标准，定义了一组API和规范，提供了一种与数据库无关的方式来操作实体对象。JPA定义了实体、映射关系、查询语言和事物管理等方面的规范，使开发人员能够以面向对象的方式进行数据库的操作。\r\nHibernate：Hibernate实现了JPA规范，同时还提供了一些额外的功能和特性。Hibernate封装了底层的JDBC操作，提供了更高层次的抽象，来简化开发人员对数据库的访问。通过\r\nHIbernate\r\n开发人员可以通过配置和注解来定义实体和映射关系，使用面向对象的方式进行数据库操作。\r\n\r\nHibernate 是 JPA 的实现之一，而 JPA\r\n则是对数据库持久化操作的规范。JDBC\r\n是底层的数据库连接和操作技术，Hibernate 和 JPA 则在 JDBC\r\n的基础上提供了更高层次的抽象和便利性，使得开发人员能够以面向对象的方式进行数据库操作\r\n下载安装\r\n现在 Spring Boot JPA 集成的 Hibernate 进行数据持久化更加常见，\r\n一般不用安装，装好依赖就行了，配置文件配置properties就行。\r\n不用maven导入，jar包到 官网 下就行。\r\n下载网站：https://sourceforge.net/projects/hibernate/files/hibernate-orm/\r\nHibernate开发步骤\r\n\r\n\r\nimage-20250511142748170\r\n\r\n第一个例子——学生信息管理\r\n编写例子\r\n\r\n创建了一个Java项目（Maven或Gradle）\r\n添加了Hibernate依赖（如果是Maven项目，在pom.xml中添加）\r\n&lt;!-- Hibernate核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;    &lt;version&gt;5.6.14.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库驱动（这里使用H2内存数据库作为示例） --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;2.1.214&lt;/version&gt;&lt;/dependency&gt;\r\n创建实体类\r\n使用hibernate时候，不需要自己手动创建表，hibernate帮把表创建\r\nimport javax.persistence.*;@Entity@Table(name = &quot;students&quot;)public class Student &#123;        // Hibernate作为JPA的实现，支持这些标准JPA注解    // 注解表示了对象关系映射的基本信息    // Hibernate 要求实体类有一个属性是唯一的    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;name&quot;, nullable = false)    private String name;        @Column(name = &quot;email&quot;)    private String email;        @Column(name = &quot;age&quot;)    private Integer age;        // 必须有无参构造函数    public Student() &#123;&#125;        // 全参构造函数    public Student(String name, String email, Integer age) &#123;        this.name = name;        this.email = email;        this.age = age;    &#125;        // Getter和Setter方法    public Long getId() &#123;        return id;    &#125;        public void setId(Long id) &#123;        this.id = id;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public String getEmail() &#123;        return email;    &#125;        public void setEmail(String email) &#123;        this.email = email;    &#125;        public Integer getAge() &#123;        return age;    &#125;        public void setAge(Integer age) &#123;        this.age = age;    &#125;        @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\r\n使用xml或者纯注解配置\r\nHibernate配置文件 hibernate.cfg.xml\r\n是Hibernate框架中至关重要的部分，它负责初始化Hibernate并提供与数据库交互所需的所有配置信息。在这个配置文件中，开发者需要指定数据库连接的URL、用户名和密码，以及数据库使用的方言，这些信息是Hibernate能够正常工作所必须的。\r\n该配置文件的结构通常包含以下几个主要部分：\r\n\r\nhibernate-configuration\r\n：这是配置文件的根元素，其中可以包含一个或多个 session-factory\r\n元素。\r\nsession-factory ：定义了一个或多个 session-factory ，每一个\r\nsession-factory 都可以配置不同的数据库连接信息。\r\nproperty ：在 session-factory 内部，使用多个 property\r\n元素来指定Hibernate连接数据库所需的参数，如\r\nconnection.url 、 connection.username 、 connection.password 、\r\ndialect 等。\r\nmapping ：这个元素用于指定实体类与数据库表的映射关系，可以通过 class\r\n或 mapping-file 指定。\r\n\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库连接设置 --&gt;        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;org.h2.Driver&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:h2:mem:testdb&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.username&quot;&gt;sa&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.password&quot;&gt;&lt;/property&gt;                &lt;!-- JDBC连接池大小 --&gt;        &lt;property name=&quot;hibernate.connection.pool_size&quot;&gt;1&lt;/property&gt;                &lt;!-- SQL方言 - 告诉Hibernate使用哪种数据库语法 --&gt;        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.H2Dialect&lt;/property&gt;                &lt;!-- 在控制台显示SQL语句 --&gt;        &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;                &lt;!-- 自动创建/更新数据库表结构 --&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;                &lt;!-- 映射实体类 --&gt;        &lt;mapping class=&quot;com.example.Student&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;\r\n数据库连接和方言配置： 配置数据库连接信息是通过 hibernate.cfg.xml 中\r\nproperty 元素的几个关键属性来完成的。 connection.url\r\n指定了数据库的连接字符串， connection.username 和 connection.password\r\n分别指定了数据库的用户名和密码，而 dialect\r\n属性则指定了对应数据库的方言。\r\n方言配置对于Hibernate的SQL生成至关重要。方言是Hibernate为不同数据库提供的抽象，它知道如何生成特定数据库支持的SQL语法。这样，Hibernate可以为不同的数据库产生正确的SQL语句而无需修改代码。\r\n参数说明 ：\r\nconnection.url ：该属性定义了数据库的连接URL，格式取决于所使用的JDBC驱动程序。\r\nconnection.username 和 connection.password ：分别定义了访问数据库时所需的用户名和密码。\r\ndialect ：该属性指定了数据库方言的完全限定类名，Hibernate根据这个类来生成特定数据库的SQL语句。 \r\n使用properties配置文件和xml配置属于是一样的\r\n在纯注解方式下，我们可以完全摆脱hibernate.cfg.xml文件，使用Java配置类和JPA注解来配置Hibernate。\r\nimport java.util.Properties;import javax.sql.DataSource;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.AvailableSettings;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;public class HibernateUtil &#123;        private static SessionFactory sessionFactory;        public static SessionFactory getSessionFactory() &#123;        if (sessionFactory == null) &#123;            try &#123;                Configuration configuration = new Configuration();                                // 设置数据库连接属性                Properties settings = new Properties();                settings.put(AvailableSettings.DRIVER, &quot;org.h2.Driver&quot;);                settings.put(AvailableSettings.URL, &quot;jdbc:h2:mem:testdb&quot;);                settings.put(AvailableSettings.USER, &quot;sa&quot;);                settings.put(AvailableSettings.PASS, &quot;&quot;);                                // Hibernate特定属性                settings.put(AvailableSettings.DIALECT, &quot;org.hibernate.dialect.H2Dialect&quot;);                settings.put(AvailableSettings.SHOW_SQL, &quot;true&quot;);                settings.put(AvailableSettings.HBM2DDL_AUTO, &quot;update&quot;);                                configuration.setProperties(settings);                                // 添加实体类                configuration.addAnnotatedClass(Student.class);                                ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()                    .applySettings(configuration.getProperties()).build();                                sessionFactory = configuration.buildSessionFactory(serviceRegistry);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return sessionFactory;    &#125;        public static void shutdown() &#123;        if (sessionFactory != null) &#123;            sessionFactory.close();        &#125;    &#125;&#125;\r\n创建主程序进行 CURD 操作\r\n，创建SessionFactory对象import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import java.util.List;public class HibernateDemo &#123;        public static void main(String[] args) &#123;        // 1. 创建SessionFactory，对应hibernate基本配置信息        // 加载hibernate核心配置文件，Configuration类加载 hibernate.cfg.xml        SessionFactory sessionFactory = new Configuration()                .configure(&quot;hibernate.cfg.xml&quot;)                .buildSessionFactory();                try &#123;            // 2. 创建Session，创建SessionFactory对象            // 并且使用SessionFactory创建session对象，类似于连接            Session session = sessionFactory.openSession();                        // 3. 开始事务            Transaction transaction = session.beginTransaction();                        // 4. 创建学生对象并保存            Student student1 = new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20);            Student student2 = new Student(&quot;李四&quot;, &quot;lisi@example.com&quot;, 22);                        System.out.println(&quot;保存学生...&quot;);            // 调用session的方法实现添加            session.save(student1);            session.save(student2);                        // 5. 提交事务            transaction.commit();                        // 6. 查询所有学生            transaction = session.beginTransaction();            System.out.println(&quot;\\n查询所有学生...&quot;);            List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        // 7. 更新学生信息            System.out.println(&quot;\\n更新学生信息...&quot;);            Student studentToUpdate = session.get(Student.class, student1.getId());            studentToUpdate.setEmail(&quot;newemail@example.com&quot;);            session.update(studentToUpdate);                        // 8. 再次查询验证更新            System.out.println(&quot;\\n查询更新后的学生...&quot;);            Student updatedStudent = session.get(Student.class, student1.getId());            System.out.println(updatedStudent);                        // 9. 删除学生            System.out.println(&quot;\\n删除学生...&quot;);            session.delete(student2);                        // 10. 最终查询            System.out.println(&quot;\\n最终学生列表...&quot;);            students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        transaction.commit();                        // 11. 关闭Session            session.close();                    &#125; finally &#123;            // 12. 关闭SessionFactory            sessionFactory.close();        &#125;    &#125;&#125;\r\n这个例子使用了H2内存数据库，所以不需要额外安装数据库服务器，H2数据库非常适合学习和测试。\r\n这个简单的示例展示了Hibernate的核心功能：\r\n\r\n对象-关系映射：通过注解将Java类映射到数据库表\r\nCRUD操作：\r\n\r\n创建(Create)：session.save()\r\n读取(Read)：session.get()和HQL查询\r\n更新(Update)：session.update()\r\n删除(Delete)：session.delete()\r\n\r\n事务管理：通过Transaction对象管理\r\nHQL查询：使用面向对象的查询语言from Student\r\n\r\n使用新的配置方式，该如何写\r\nimport org.hibernate.Session;import org.hibernate.Transaction;public class HibernateAnnotationDemo &#123;        public static void main(String[] args) &#123;        // 获取SessionFactory        SessionFactory sessionFactory = HibernateUtil.getSessionFactory();        Session session = sessionFactory.openSession();                try &#123;            // 开始事务            Transaction transaction = session.beginTransaction();                        // 创建并保存学生            Student student1 = new Student(&quot;王五&quot;, &quot;wangwu@example.com&quot;, 21);            Student student2 = new Student(&quot;赵六&quot;, &quot;zhaoliu@example.com&quot;, 23);                        System.out.println(&quot;保存学生...&quot;);            session.save(student1);            session.save(student2);                        // 提交事务            transaction.commit();                        // 查询示例            transaction = session.beginTransaction();            System.out.println(&quot;\\n所有学生:&quot;);            List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        transaction.commit();                    &#125; finally &#123;            session.close();            HibernateUtil.shutdown();        &#125;    &#125;&#125;\r\n其中的注解声明\r\n\r\n\r\n\r\n注解\r\n来源\r\n说明\r\n\r\n\r\n\r\n\r\n@Entity\r\nJPA\r\n标记类为实体类，将映射到数据库表\r\n\r\n\r\n@Table\r\nJPA\r\n指定映射的表名\r\n\r\n\r\n@Id\r\nJPA\r\n标记主键字段\r\n\r\n\r\n@GeneratedValue\r\nJPA\r\n指定主键生成策略\r\n\r\n\r\n@Column\r\nJPA\r\n指定字段与列的映射关系\r\n\r\n\r\n@Transient\r\nJPA\r\n标记不持久化的字段\r\n\r\n\r\n\r\n\r\n涉及到的API\r\nConfiguration\r\n在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。\r\n\r\nHibernate 运行的底层信息：数据库的\r\nURL，用户名，密码，JDBC驱动类，数据库Diaiect，数据库连接池等，对应hibernate.cfg.xml\r\n文件\r\n持久化类与数据表的映射关系 hbm.xml文件\r\n\r\n在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。\r\nHibernate通常使用Configuration config = new Configuration().configure()；的方式创建实例，此种方式默认会去src下读取hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下：\r\nConfiguration config = new Configuration().configure(&quot;xml文件位置&quot;);\r\n传递 hibernate.properties 属性文件\r\nConfiguration config = new Configuration();\r\n此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示：\r\nConfiguration config = new Configuration().configure(&quot;/config/hibernate.cfg.xml&quot;);\r\nSessionFactory\r\nSessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。\r\n\r\n针对单个数据库映射关系经过编译后的内存镜像，是线程安全的。\r\nSessionFactory对象一且构造完毕，即被赋予特定的配置信息。\r\nSessionFactory是生成Session的工厂\r\n构造SessionFactory很消耗资源，一般情况下一个应用中只初始化一个SessionFactory对象。\r\nHibernate4 新增了一个ServiceRegistry接口，所有基于Hibernate\r\n的配置或者服务都必须统一向这个ServiceRegistry注册后才能效，但是\r\nHibernate5 又不需要了\r\n\r\nSessionFactory实例是通过Configuration对象获取的，其获取方法如下所示：\r\nSessionFactory sessionFactory = config.buildSessionFactory();\r\nSessionFactory具有以下特点：\r\n\r\n它是线程安全的，它的同一个实例能够供多个线程共享。\r\n它是重量级的，不能随意的创建和销毁它的实例。\r\n\r\n由于SessionFactory的这些特点，一般情况下，一个项目中只需要一个SessionFactory，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，在实际项目使用中，通常会抽取出一个HibernateUtils的工具类，用来提供Session对象。\r\nSession\r\nSession是应用程序与数据库之间交互操作的一个单线程对象，是Hibernate运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。\r\n相当于 JDBC 的 Connection，持久化类与 Session\r\n关联起来之后就具有了持久化的能力\r\n创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下：\r\n// 采用openSession方法创建session =&gt; 获得全新sessionSession session = sessionFactory.openSession();// 采用getCurrentSession方法创建session =&gt; 获得与线程绑定的sessionSession session = sessionFactory.getCurrentSession();\r\n以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。\r\nSession是线程不安全的，多个并发线程同时操作一个Session实例时，就可能导致Session数据存在混乱（方法内部定义和使用Session时，不会出现线程问题）。因此设计软件架构时，应避免多个线程共享一个Sesion实例。同时它也是轻量级的，实例的创建和销毁不需要消耗太多的资源。它还有一个缓存，即Hibernate的一级缓存，这个缓存主要用于存放当前工作单元加载的对象。\r\n在Session中提供了大量的常用方法，具体如下：\r\n\r\nsave()、update()和saveOrUpdate()方法：用于增加和修改对象\r\ndelete()方法：用于删除对象\r\nget()和load()方法：根据主键查询\r\ncreateQuery()和createSQLQuery()方法：用于数据库操作对象\r\ncreateCriteria()方法：条件查询\r\n\r\nTransaction\r\nTransaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示：\r\nTransaction transaction = session.beginTransaction();\r\n在Transaction接口中，提供了事务管理的常用方法，具体如下：\r\n\r\ncommit()方法：提交相关联的session实例。\r\nrollback()方法：撤销事务操作\r\nwasCommitted()方法：检查事务是否提交\r\n\r\n**Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。\r\n发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发送错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。\r\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"JavaWeb-http","url":"/posts/31243.html","content":"HTTP请求\r\n客户端–&gt;请求–&gt;服务器\r\n\r\n超文本传输协议（Hypertext Transfer\r\nProtocol，HTTP）是一个简单的请求-响应协议，是用于从万维网（WWW:World\r\nWide Web ）服务器传输超文本到本地浏览器的传送协议。\r\nHTTP是基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件,\r\n查询结果等）。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\r\nHTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。\r\n\r\n以请求百度为例\r\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\r\nAccept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9  语言Cache-Control: max-age=0Connection: keep-alive\r\n1.请求行\r\n请求行中的请求方式：GET\r\n\r\n\r\n\r\n请求头图\r\n\r\nGET请求方式\r\n请求方式：\r\n\r\n\r\n\r\nimage-20250414142250490\r\n\r\n2.消息头\r\n\r\n\r\n\r\nimage-20250414142603869\r\n\r\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接\r\nHTTP响应\r\n服务器–&gt;响应–&gt;客户端\r\n例子\r\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\r\n响应体\r\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的    sendRedirect方法，该方法同时设置状态代码为302。Set-Cookie:设置和页面关联的Cookie。\r\n响应状态码\r\n常见状态码\r\n200：请求响应成功\r\n301：请求重定向\r\n\r\n请求重定向(Redirect)：通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。\r\n\r\n404: 找不到资源\r\n500：服务器代码错误\r\nHTTP状态码分类\r\nHTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\r\n\r\n\r\n\r\nimage-20250414143407248\r\n\r\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaWeb","JavaEE","Web"]},{"title":"JSON之基础部分与语法","url":"/posts/18280.html","content":"JSON基础部分\r\n什么是JSON\r\nJavaScript 对象表示法（JSON）是用于将结构化数据表示为 JavaScript\r\n对象的标准格式，通常用于在网站上表示和传输数据（例如从服务器向客户端发送一些数据，因此可以将其显示在网页上）\r\nJSON: JavaScript\r\nObject Notation(JavaScript\r\n对象表示法)\r\nJSON 是存储和交换文本信息的语法，类似 XML。\r\nJSON 比 XML 更小、更快，更易解析。\r\nJSON 是轻量级的文本数据交换格式\r\nJSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON\r\n仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。\r\n目前非常多的动态（PHP，JSP，.NET）编程语言都支持 JSON\r\nJSON 具有自我描述性，更易理解\r\nJSON 文本格式在语法上与创建 JavaScript 对象的代码相同。\r\nJSON 可以作为一个对象或者字符串存在，前者用于解读 JSON\r\n中的数据，后者用于通过网络传输 JSON 数据\r\n\r\n将字符串转换为原生对象称为反序列化（deserialization），而将原生对象转换为可以通过网络传输的字符串称为序列化（serialization）。\r\n\r\n由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval()\r\n函数，用 JSON 数据来生成原生的 JavaScript 对象。\r\n\r\nJSON 格式化工具：https://www.jyshare.com/front-end/53/\r\nJSON 转义/去除转义：https://www.jyshare.com/front-end/7683/\r\nJSON 在线解析工具：https://www.jyshare.com/front-end/7438/\r\nJSON 差异对比工具：https://www.jyshare.com/front-end/9557/\r\n\r\n\r\nJSON语法与结构\r\nJSON 语法是 JavaScript\r\n语法的子集\r\n\r\n数据在名称/值对中\r\n数据由逗号 , 分隔\r\n使用斜杆  来转义字符\r\n大括号 {} 保存对象\r\n中括号 [] 保存数组，数组可以包含多个对象\r\n\r\nJSON的两种结构：\r\nJSON 是一个字符串，其格式非常类似于 JavaScript\r\n对象字面量的格式。你可以在 JSON 中包含与标准 JavaScript\r\n对象相同的基本数据类型——字符串、数字、数组、布尔值和其他对象字面量。这使你可以构建一个数据层次结构，如下所示：\r\n&#123;  &quot;squadName&quot;: &quot;Super hero squad&quot;,  &quot;homeTown&quot;: &quot;Metro City&quot;,  &quot;formed&quot;: 2016,  &quot;secretBase&quot;: &quot;Super tower&quot;,  &quot;active&quot;: true,  &quot;members&quot;: [    &#123;      &quot;name&quot;: &quot;Molecule Man&quot;,      &quot;age&quot;: 29,      &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;,      &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;Madame Uppercut&quot;,      &quot;age&quot;: 39,      &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;,      &quot;powers&quot;: [        &quot;Million tonne punch&quot;,        &quot;Damage resistance&quot;,        &quot;Superhuman reflexes&quot;      ]    &#125;,    &#123;      &quot;name&quot;: &quot;Eternal Flame&quot;,      &quot;age&quot;: 1000000,      &quot;secretIdentity&quot;: &quot;Unknown&quot;,      &quot;powers&quot;: [        &quot;Immortality&quot;,        &quot;Heat Immunity&quot;,        &quot;Inferno&quot;,        &quot;Teleportation&quot;,        &quot;Interdimensional travel&quot;      ]    &#125;  ]&#125;\r\n\r\n对象：大括号\r\n&#123;&#125;保存的对象是一个无序的名称/值对集合。一个对象以左括号&#123;开始，\r\n右括号&#125;结束。每个”键”后跟一个冒号\r\n:，名称/值对使用逗号,分隔。\r\n数组：中括号[]保存的数组是值（value）的有序集合。一个数组以左中括号[开始，\r\n右中括号]结束，值之间使用逗号,分隔。\r\n\r\n值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、\r\nnull、对象（object）或者数组（array），它们是可以嵌套。\r\n\r\n\r\nJSON名称 / 键值对\r\nJSON 数据的书写格式是：\r\nkey : value\r\n名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：\r\n&quot;name&quot; : &quot;ErgouTree&quot;\r\n这很容易理解，等价于这条 JavaScript 语句：\r\nname = &quot;ErgouTree&quot;\r\nJSON 值可以是：\r\n\r\n数字（整数或浮点数）\r\n字符串（在双引号中）\r\n逻辑值（true 或 false）\r\n数组（在中括号中）\r\n对象（在大括号中）\r\nnull\r\n\r\nJSON 对象\r\n对象语法\r\nJSON 对象在大括号 {} 中书写，对象可以包含多个名称/值对：\r\n&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;\r\nkey 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字,\r\n对象, 数组, 布尔值或 null）。\r\nkey 和 value 中使用冒号 : 分割。\r\n每个 key/value 对使用逗号 , 分割。\r\n访问对象值\r\n你可以使用 点号. 和\r\n中括号[]来访问对象的值：\r\nvar myObj, x;myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;x = myObj[&quot;name&quot;];x = myObj.name;\r\n循环对象\r\n你可以使用 for-in 来循环对象的属性：\r\nvar myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;for (x in myObj) &#123;    document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125;\r\n嵌套JSON对象\r\nJSON 对象中可以包含另外一个 JSON 对象：\r\nmyObj = &#123;    &quot;name&quot;:&quot;runoob&quot;,    &quot;alexa&quot;:10000,    &quot;sites&quot;: &#123;        &quot;site1&quot;:&quot;www.runoob.com&quot;,        &quot;site2&quot;:&quot;m.runoob.com&quot;,        &quot;site3&quot;:&quot;c.runoob.com&quot;    &#125;&#125;\r\n你可以使用点号 .或者中括号[...]来访问嵌套的\r\nJSON 对象。\r\nx = myObj.sites.site1;// 或者x = myObj.sites[&quot;site1&quot;];\r\n修改值\r\n你可以使用点号 . 或中括号\r\n[]来通过赋值的方式修改 JSON 对象的值\r\nmyObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;;\r\n删除对象属性\r\n我们可以使用 delete 关键字来删除 JSON\r\n对象的属性：\r\ndelete myObj.sites.site1;delete myObj.sites[&quot;site2&quot;]\r\nJSON数组\r\n数组作为 JSON 对象\r\nJSON 数组在中括号中书写。\r\n中括号 [] 保存的数组是值（value）的有序集合，值之间使用逗号 ,\r\n分隔。\r\nJavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript\r\n的表达式，包括函数，日期，及 undefined。\r\n对象属性的值可以是一个数组\r\n&#123;&quot;name&quot;:&quot;网站&quot;,&quot;num&quot;:3,&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]&#125;// 访问x = myObj.sites[0];\r\n循环数组也可以使用，类似于 js 和 java的增强 for 循环\r\n修改和删除和对象一样\r\nmyObj.sites[1] = &quot;Github&quot;;delete myObj.sites[1];\r\nJSON.parse()\r\nJSON 通常用于与服务端交换数据。\r\n在接收服务器数据时一般是字符串。\r\n我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。\r\nJSON.parse(text[, reviver])\r\n参数说明：\r\n\r\ntext:必需， 一个有效的 JSON 字符串。\r\nreviver: 可选，一个转换结果的函数，\r\n将为对象的每个成员调用此函数。\r\n\r\nJSON解析实例\r\n例如我们从服务器接收了以下数据：\r\n&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;\r\n我们使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript\r\n对象：\r\nvar obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);\r\n解析完成后，我们就可以在网页上使用 JSON 数据了：\r\n&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt;var obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;：&quot; + obj.site;&lt;/script&gt;\r\n从服务端接收 JSON 数据\r\n我们可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript\r\n对象。\r\nvar xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123;    if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;        myObj = JSON.parse(this.responseText);        document.getElementById(&quot;demo&quot;).innerHTML = myObj.name;    &#125;&#125;;xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/json_demo.txt&quot;, true);xmlhttp.send();\r\n如果从服务端接收的是数组的 JSON 数据，则 JSON.parse 会将其转换为\r\nJavaScript 数组：\r\n异常解析\r\nJSON 不能存储 Date 对象。\r\n如果你需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为\r\nDate 对象。\r\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期: &quot; + obj.initDate;\r\n我们可以启用 JSON.parse 的第二个参数\r\nreviver，一个转换结果的函数，对象的每个成员调用此函数。\r\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text, function (key, value) &#123;    if (key == &quot;initDate&quot;) &#123;        return new Date(value);    &#125; else &#123;        return value;&#125;&#125;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期：&quot; + obj.initDate;\r\nJSON\r\n不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。\r\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:&quot;function () &#123;return 10000;&#125;&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.alexa = eval(&quot;(&quot; + obj.alexa + &quot;)&quot;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot; Alexa 排名：&quot; + obj.alexa();\r\nJSON.stringify()\r\nJSON 通常用于与服务端交换数据。\r\n在向服务器发送数据时一般是字符串。\r\n我们可以使用 JSON.stringify() 方法将 JavaScript\r\n对象转换为字符串。\r\n语法\r\nJSON.stringify(value[, replacer[, space]])\r\n参数说明：\r\n\r\nvalue:\r\n必需， 要转换的 JavaScript 值（通常为对象或数组）。\r\nreplacer:\r\n可选。用于转换结果的函数或数组。\r\n如果 replacer 为函数，则 JSON.stringify\r\n将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回\r\nundefined，则排除成员。根对象的键是一个空字符串：““。\r\n如果 replacer\r\n是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当\r\nvalue 参数也为数组时，将忽略 replacer 数组。\r\nspace:\r\n可选，文本添加缩进、空格和换行符，如果 space\r\n是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于\r\n10，则文本缩进 10 个空格。space 也可以使用非数字，如：\r\n\r\nJavaScipt对象转换\r\n例如我们向服务器发送以下数据：\r\nvar obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;\r\n使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：\r\nvar myJSON = JSON.stringify(obj);\r\n可以将 myJSON 发送到服务器：\r\nvar obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\n数组转换和对象转换差不多\r\nvar arr = [ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Facebook&quot; ];var myJSON = JSON.stringify(arr);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\n异常解析\r\nJSON 不能存储 Date 对象。\r\nJSON.stringify() 会将所有日期转换为字符串。\r\nJSON 不允许包含函数，JSON.stringify() 会删除 JavaScript\r\n对象的函数，包括 key 和 value。\r\nvar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\n我们可以在执行 JSON.stringify()\r\n函数前将函数转换为字符串来避免以上问题的发生：\r\nvar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\r\nJSON使用\r\n把 JSON 文本转换为\r\nJavaScript 对象\r\nJSON 最常见的用法之一，是从 web 服务器上读取 JSON\r\n数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript\r\n对象，然后在网页中使用该数据。\r\n实例：\r\n创建包含 JSON 语法的 JavaScript 字符串\r\nvar txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;;\r\n由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval()\r\n可用于将 JSON 文本转换为 JavaScript 对象。\r\neval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成\r\nJavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：\r\nvar txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;; var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); document.getElementById(&quot;name&quot;).innerHTML=obj.sites[0].name document.getElementById(&quot;url&quot;).innerHTML=obj.sites[0].url\r\n一些注意事项\r\n\r\nJSON 是一种纯数据格式，它只包含属性，没有方法。\r\nJSON 要求在字符串和属性名称周围使用双引号。单引号无效。\r\n甚至一个错位的逗号或分号就可以导致 JSON\r\n文件出错。你应该小心的检查你想使用的数据（虽然计算机生成的 JSON\r\n很少出错，只要生成程序正常工作）。你可以通过像 JSONLint 这样的应用程序来验证\r\nJSON。\r\nJSON 实际上可以是任何可以有效包含在 JSON\r\n中的数据类型的形式。比如，单个字符串或者数字就是有效的 JSON 对象。\r\n与 JavaScript 代码中对象属性可以不加引号不同，JSON\r\n中只有带引号的字符串可以用作属性。\r\n\r\n","categories":["前端技术","JSON"],"tags":["实用知识","前端技术","JSON","JavaScript","语法知识"]},{"title":"Java之动态代理","url":"/posts/60449.html","content":"设计模式–代理模式\r\n代理模式是常用的java设计模式，它允许你通过创建一个代理对象来控制对另一个对象（即目标对象）的访问，代理类与委托类有同样的接口。\r\n代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。\r\n代理对象充当了目标对象的接口，客户端通过代理对象与目标对象进行交互，而不是直接访问目标对象。\r\n代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。\r\n在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。代理模式可以在不改变目标对象代码的前提下，对目标对象的功能进行增强或扩展。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n可以发现，其中有\r\n\r\n代理对象\r\n被代理的行为\r\n被代理的对象\r\n行为的完全控制\r\n\r\n静态代理\r\n静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。\r\n简单实现\r\n首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。\r\n/** * 创建Person接口 * @author Gonjan */public interface Person &#123;    //上交班费    void giveMoney();&#125;\r\nStudent类实现Person接口。Student可以具体实施上交班费的动作。\r\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\r\nStudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为\r\n// 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为public class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        stu.giveMoney();    &#125;&#125;\r\n测试主类 public class StaticProxyTest &#123;    public static void main(String[] args) &#123;        //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成        Person zhangsan = new Student(&quot;张三&quot;);                //生成代理对象，并将张三传给代理对象        Person monitor = new StudentsProxy(zhangsan);                //班长代理上交班费        monitor.giveMoney();    &#125;&#125;\r\n这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。\r\n代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。\r\n代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。\r\n这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以很方便的加上一些其他用途\r\npublic class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        System.out.println(&quot;张三最近学习有进步！&quot;);  // 代理类顺便告诉张三最近学习有进步        stu.giveMoney();    &#125;&#125;\r\n可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。\r\n动态代理\r\n介绍\r\n代理类在程序运行时创建的代理方式被成为动态代理。\r\n我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。\r\n然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。\r\n相比于静态代理，\r\n动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\r\n比如说，想要在每个代理的方法前都加上一个处理方法：\r\npublic void giveMoney() &#123;      //调用被代理方法前加入处理方法      beforeMethod();      stu.giveMoney();  &#125;\r\n这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。\r\n简单实现\r\n在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。\r\n相关方法：\r\n创建一个InvocationHandler对象\r\n//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);\r\nInvocationHandler接口定义了一个invoke方法，当通过代理对象调用目标方法时，invoke\r\n方法会被调用。invoke\r\n方法接收三个参数：代理对象、被调用的方法对象以及方法的参数数组。在\r\ninvoke\r\n方法中，我们可以编写额外的逻辑，然后调用目标方法并返回结果。\r\n例如\r\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler接口 &#123;  // 实现InvocationHandler接口    private Object target;    public MyInvocationHandler(Object target) &#123;        // 存储目标对象。这个目标对象就是我们要为其添加额外功能的对象。        this.target = target;    &#125;    // 需要重写invoke方法    @Override    // Object proxy：代理对象本身   Method method：被调用的目标方法对象   Object[] args：调用目标方法时传递的参数数组    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        // 调用目标方法前的逻辑，例如记录日志        System.out.println(&quot;Before method invocation: &quot; + method.getName());        // 调用目标方法        Object result = method.invoke(target, args);   // 代理target对象实际方法        // 调用目标方法后的逻辑，例如记录日志        System.out.println(&quot;After method invocation: &quot; + method.getName());        return result;    &#125;&#125;\r\n使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass\r\nClass&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;);\r\n该类提供了静态方法用于创建动态代理类和代理对象。\r\n其中，newProxyInstance\r\n方法是创建代理对象的关键方法，它接收三个参数：类加载器、目标对象实现的接口数组以及\r\nInvocationHandler 实例。\r\n例如\r\nimport java.lang.reflect.Proxy;// 为传入的目标对象创建一个动态代理对象。public class ProxyFactory &#123;    public static Object createProxy(Object target) &#123;        return Proxy.newProxyInstance(                target.getClass().getClassLoader(),     // 类加载器// 动态代理只能为实现了接口的类创建代理对象，因此需要指定目标对象实现的接口，这样代理对象才能实现相同的接口。                target.getClass().getInterfaces(),   // 获取目标对象所实现的所有接口的数组                new MyInvocationHandler(target));    &#125;&#125;\r\n获得stuProxyClass\r\n中一个带InvocationHandler参数的构造器constructor\r\nConstructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);\r\n在 Java 反射机制中，Class\r\n类提供了一系列方法来获取类的构造器信息。这里通过\r\nPersonProxy.getConstructor(InvocationHandler.class) 来获取\r\nPersonProxy 类中，参数为\r\nInvocationHandler.class\r\n的构造器。getConstructor 方法会返回一个\r\nConstructor 对象，它代表了对应的构造器。\r\n通过构造器constructor来创建一个动态实例stuProxy\r\nPerson stuProxy = (Person) cons.newInstance(stuHandler);\r\nConstructor 类的 newInstance\r\n方法用于根据构造器来创建类的实例。这里传入了 stuHandler\r\n作为参数，stuHandler 应该是实现了\r\nInvocationHandler\r\n接口的对象实例。它会调用之前获取到的构造器（要求参数为\r\nInvocationHandler 类型 ）来初始化一个\r\nPersonProxy 实例，并将其强制转换为 Person\r\n类型（前提是 PersonProxy 类实现了 Person 接口\r\n）\r\n一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化\r\n//创建一个与代理对象相关联的InvocationHandler  InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);\r\n完整的动态代理例子\r\n定义一个Person接口，里面定义一个抽象方法giveMoney();\r\npublic interface Person &#123;    //上交班费    void giveMoney();&#125;\r\n创建需要被代理的实际类\r\nStudent类，实现了Person接口，是被代理的目标对象：\r\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;        try &#123;          //假设数钱花了一秒时间            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\r\n再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。\r\npublic class MonitorUtil &#123;        private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();        public static void start() &#123;        tl.set(System.currentTimeMillis());    &#125;        //结束时打印耗时    public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();        System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);    &#125;&#125;\r\n创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。再在invoke方法中执行被代理对象target的相应方法。\r\n所以说InvocationHandler\r\n负责处理代理对象方法的调用，当调用代理对象的方法时，实际上会调用\r\nInvocationHandler 的 invoke 方法。\r\n当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。\r\npublic class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123;   // invocationHandler持有的被代理对象    T target;        public StuInvocationHandler(T target) &#123;       this.target = target;    &#125;        /**     * proxy:代表动态代理对象     * method：代表正在执行的方法     * args：代表调用目标方法时传入的实参     */     @Override   // 实现 InvocationHandler 接口需要重写invoke方法    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;);          //代理过程中插入监测方法,计算该方法耗时        MonitorUtil.start();        Object result = method.invoke(target, args);        MonitorUtil.finish(method.getName());        return result;    &#125;&#125;\r\n我们使用简化的方式创建动态代理对象：\r\npublic class ProxyTest &#123;    public static void main(String[] args) &#123;        //创建一个实例对象，这个对象是被代理的对象        Person zhangsan = new Student(&quot;张三&quot;);        //创建一个与代理对象相关联的InvocationHandler        InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan);        //创建一个代理对象stuProxy来代理张三，代理对象的每个执行方法都会替换执行Invocation中的invoke方法        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；       //代理执行上交班费的方法        stuProxy.giveMoney();    &#125;&#125;\r\n过程讲解：\r\nstuHandler为代理对象相关联的InvocationHandler，将目标对象\r\n张三 传递给 StuInvocationHandler\r\n的构造函数。InvocationHandler\r\n的作用是处理代理对象方法的调用，当调用代理对象的方法时，会自动调用\r\nInvocationHandler 的 invoke 方法\r\n使用 Proxy.newProxyInstance 方法创建一个代理对象\r\nstuProxy，需要传入类加载器，实现的接口，指定处理代理对象方法调用的InvocationHandle对象，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\r\n之后调用代理对象的 giveMoney 方法，实际上会调用\r\nStuInvocationHandler 的 invoke 方法，在\r\ninvoke 方法中会先调用 MonitorUtil.start()\r\n记录开始时间，然后调用目标对象的 giveMoney 方法，最后调用\r\nMonitorUtil.finish() 计算并打印方法执行的耗时。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\r\n是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。\r\n例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而只做了很少的代码量。\r\n动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。\r\n因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行，这就涉及到java动态代理的原理了\r\n动态代理原理分析\r\nJava动态代理创建出来的动态代理类\r\n上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：\r\n/** * 返回一个指定接口的代理类实例，该实例会将方法调用分派到指定的调用处理器。 * * @param loader 定义代理类的类加载器 * @param interfaces 代理类要实现的接口列表 * @param h 调度方法调用的调用处理器 * @return 一个实现了指定接口的代理类实例，它会将方法调用分派给指定的调用处理器 * @throws IllegalArgumentException 如果违反了对该方法参数的任何限制 */public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)    throws IllegalArgumentException&#123;    // 检查调用处理器是否为 null，如果为 null 则抛出 NullPointerException    Objects.requireNonNull(h);    // 克隆接口数组，防止外部对原数组进行修改影响后续操作    final Class&lt;?&gt;[] intfs = interfaces.clone();    // 获取系统的安全管理器    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        // 如果存在安全管理器，检查调用者是否有创建代理类的权限        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    /*     * 查找或生成指定的代理类。     */    // 通过类加载器和接口数组获取代理类的 Class 对象    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * 使用指定的调用处理器调用其构造函数。     */    try &#123;        if (sm != null) &#123;            // 如果存在安全管理器，检查调用者是否有创建代理实例的权限            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        // 获取代理类的构造函数，该构造函数接收一个 InvocationHandler 类型的参数        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        // 保存传入的调用处理器        final InvocationHandler ih = h;        if (!Modifier.isPublic(cl.getModifiers())) &#123;            // 如果代理类不是公共类，则使用特权操作将构造函数设置为可访问            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;        // 使用构造函数创建代理类的实例，并传入调用处理器        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;        // 处理非法访问或实例化异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        // 处理构造函数调用抛出的异常        Throwable t = e.getCause();        if (t instanceof RuntimeException) &#123;            // 如果是运行时异常，直接抛出            throw (RuntimeException) t;        &#125; else &#123;            // 否则抛出内部错误            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        // 处理构造函数未找到的异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125;&#125;\r\nClass&lt;?&gt; cl = getProxyClass0(loader, intfs);\r\n\r\nloader：这是一个 ClassLoader\r\n对象，它指定了代理类应该使用哪个类加载器来加载。类加载器负责将类的字节码文件加载到\r\nJVM\r\n中，不同的类加载器可能会从不同的位置（如文件系统、网络等）加载类。通常，我们会使用被代理接口的类加载器，这样可以确保代理类和被代理接口在同一个类加载器的命名空间中，从而避免类加载的冲突。\r\nintfs：这是一个 Class[]\r\n数组，包含了代理类需要实现的接口列表。代理类会实现这些接口中定义的所有方法，当调用代理对象的这些方法时，实际上会将调用转发到\r\nInvocationHandler 的 invoke\r\n方法中进行处理。\r\n\r\n其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader,\r\nintfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，这个类文件时缓存在java虚拟机中的\r\n\r\n在 Java 动态代理中，Proxy.newProxyInstance\r\n方法的核心目标是创建一个实现了指定接口的代理对象。而\r\ngetProxyClass0\r\n方法就是用来生成这个代理对象所对应的代理类的。这个代理类是在运行时动态生成的，并且会被加载到\r\nJava\r\n虚拟机（JVM）中，后续的代理对象实例就是基于这个动态生成的类来创建的。\r\n\r\n那么是如何动态生成代理类的：\r\n\r\ngetProxyClass0\r\n方法会根据传入的类加载器和接口数组，在运行时动态生成一个代理类的字节码。这个代理类会实现\r\nintfs\r\n数组中指定的所有接口，并且会重写这些接口中的方法。在重写的方法中，会调用\r\nInvocationHandler 的 invoke\r\n方法，从而实现对目标方法的增强。\r\n这其中有一个缓存机制，为了提高性能，Java\r\n虚拟机对动态生成的代理类采用了缓存机制。也就是说，如果已经为相同的类加载器和接口列表生成过代理类，那么\r\ngetProxyClass0\r\n方法会直接从缓存中获取这个代理类，而不是再次生成。这样可以避免重复生成相同的代理类，减少开销。\r\n\r\n之后对这个class文件反编译\r\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.Person;// $Proxy0 是动态生成的代理类，它继承自 Proxy 类并实现了 Person 接口。Proxy 类是 Java 中所有代理类的基类// 它持有一个 InvocationHandler 类型的成员变量 h，用于处理方法调用public final class $Proxy0 extends Proxy implements Person&#123;  // 这些静态变量用于存储通过反射获取的方法对象。m3 对应 Person 接口的 giveMoney 方法，m0、m1、m2 分别对应 Object 类的 hashCode、equals 和 toString 方法。  private static Method m1;  private static Method m2;  private static Method m3;  private static Method m0;    /**  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，代理类的构造方法接收一个 InvocationHandler 类型的参数，并调用父类 Proxy 的构造方法将其传递给父类的 h 成员变量。这意味着代理类持有一个 InvocationHandler 对象，后续的方法调用将由该对象处理。  *  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。  *父类持有：protected InvocationHandler h;  *Proxy构造方法：  *    protected Proxy(InvocationHandler h) &#123;  *         Objects.requireNonNull(h);  *         this.h = h;  *     &#125;  *  */  public $Proxy0(InvocationHandler paramInvocationHandler)    throws   &#123;    super(paramInvocationHandler);  &#125;    //这个静态块本来是在最后的，我把它拿到前面来，方便描述   static  &#123;    try    &#123;      //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);      m3 = Class.forName(&quot;proxy.Person&quot;).getMethod(&quot;giveMoney&quot;, new Class[0]);      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);      return;    &#125;    catch (NoSuchMethodException localNoSuchMethodException)    &#123;      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());    &#125;    catch (ClassNotFoundException localClassNotFoundException)    &#123;      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());    &#125;  &#125;   /**  *   *当调用代理对象的 giveMoney 方法时，实际上会调用 InvocationHandler 对象的 invoke 方法，并将代理对象本身（this）、giveMoney 方法的 Method 对象（m3）和方法参数（这里为 null）作为参数传递给 invoke 方法。  *this.h.invoke(this, m3, null);这里简单，明了。  *InvocationHandler 对象持有被代理对象的引用，在 invoke 方法中可以调用被代理对象的相应方法，并可以在方法调用前后添加额外的逻辑，从而实现对被代理对象方法的增强。  */  public final void giveMoney()    throws   &#123;    try    &#123;      this.h.invoke(this, m3, null);      return;    &#125;    catch (Error|RuntimeException localError)    &#123;      throw localError;    &#125;    catch (Throwable localThrowable)    &#123;      throw new UndeclaredThrowableException(localThrowable);    &#125;  &#125;  //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。&#125;\r\njdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。\r\n我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。\r\n代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。\r\n引用\r\n[java动态代理实现与原理详细分析\r\nJava动态代理详细讲解-使用方式及应用场景\r\n","categories":["Java学习","JavaSE","JavaEE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"JavaWeb之Filter过滤器","url":"/posts/42974.html","content":"Filter 介绍\r\n过滤器，顾名思义就是对事物进行过滤的，在Web中的过滤器，当然就是对请求进行过滤，对web服务器管理的所有web资源，我们使用过滤器，就可以对请求进行拦截，然后做相应的处理，实现许多特殊功能。如登录控制，权限管理，过滤敏感词汇等.\r\nServlet\r\nAPI中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过\r\nFilter\r\n技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，Filter接口源代码：\r\npublic abstract interface Filter&#123;    public abstract void init(FilterConfig paramFilterConfig) throws ServletException;    public abstract void doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain         paramFilterChain) throws IOException, ServletException;    public abstract void destroy();&#125;\r\nFilter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：\r\n- 调用目标资源之前，让一段代码执行。 -\r\n是否调用目标资源（即是否让用户访问web资源）。\r\nweb服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个\r\ndoFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。\r\n过滤器原理\r\n当我们使用过滤器时，过滤器会对游览器的请求进行过滤，过滤器可以动态的分为3个部分\r\n1.放行之前的代码，2.放行，3.放行后的代码\r\n\r\n第一部分代码会对游览器请求进行第一次过滤，然后继续执行\r\n第二部分代码就是将游览器请求放行，如果还有过滤器，那么就继续交给下一个过滤器\r\n第三部分代码就是对返回的Web资源再次进行过滤处理\r\n\r\n我们使用过滤器，也就是说，不止请求会经过过滤器，我们的响应也会经过过滤器。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n使用过滤器\r\n我们创建Filter，只需要继承Filter接口就行。\r\nimport javax.servlet.*;import java.io.IOException;@WebFilter(&quot;/*&quot;)public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;对request进行过滤&quot;);        //下面这行代码就是放行        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;对response进行过滤&quot;);    &#125;&#125;\r\n我们实现了一个 doFilter\r\n方法，这个方法就是我们写过滤代码的地方，具体逻辑就是和上面介绍的过滤器原理一样的。\r\n我简单介绍下上面的代码，WebFilter(\"/*\")\r\n表示对所有请求进行过滤,而在doFilter中的放行代码，也就是filterChain.doFilter(servletRequest,servletResponse);这行代码就是对拦截进行放行\r\n过滤器并不会管资源是否存在，而只会对配置的拦截路径进行拦截。拦截不仅会对请求进行拦截，而且还会对相应进行拦截。\r\n配置过滤器拦截路径\r\n配置Filter的拦截路径有2种方式，一种是注解，一种是xml方式，我们分别进行讲解\r\n注解方式\r\n我们如果使用注解来进行配置，那么我们就需要使用 @WebFilter ，直接看该注解的源码\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\nfilterName：该filter的名字\r\ninitParams：初始化参数\r\ndisplayName：filter显示名称\r\nservletNames：指定对哪些servlet进行过滤\r\nasyncSupported：是否支持异步模式\r\nurlPatterns：指定拦截路径\r\nvalue：指定拦截路径\r\n\r\nurlPatterns和value是一样的。urlPatterns和value只能配置一个，不能两个都配置，两个都配置就会报错。\r\n对于使用@WebFilter,里面的多个参数用\r\n, 进行分隔。\r\n如果我们仅仅需要配置一个拦截路径，那么我们可以直接简写@WebLister(“拦截路径”)，如@WebFilter(“/*”)就是拦截所有请求。\r\n@WebFilter(value = &#123;&quot;/login&quot;&#125;, filterName = &quot;filtersss&quot;)public class CharSetFilter implements Filter &#123;\r\n多个参数配置，需要分隔\r\nxml 方式\r\nxml方式可以说是和Servlet使用xml配置方式一样了\r\n&lt;filter&gt;    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.ergoutree.filter.MyFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\r\n把注解换成了xml标签来配置，里面属性都是一样的，这个和Servlet的配置方式基本一样\r\n过滤器生命周期\r\nFilter 的生命周期和 Servlet 也十分相似\r\n创建一个类\r\nimport javax.servlet.*;import java.io.IOException; public class LifeCycleFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\nFilter有3个阶段，分别是初始化，拦截和过滤，销毁。\r\n\r\n初始化阶段：当服务器启动时，我们的服务器(Tomcat)就会读取配置文件，扫描注解，然后来创建我们的Filter。\r\n拦截和过滤阶段：只要请求资源的路径和拦截的路径相同，那么过滤器就会对请求进行过滤，这个阶段在服务器运行过程中会一直循环。\r\n销毁阶段：当服务器(Tomcat)关闭时，服务器创建的Filter也会随之销毁。\r\n\r\nFilter的三个阶段就对应着Filter的3个方法，init 方法会在 Filter\r\n创建时调用，doFilter 方法会在请求和拦截匹配时调用，destroy 方法会在\r\nFilter 销毁时调用。\r\n@WebFilter(value = &#123;&quot;/login&quot;&#125;, filterName = &quot;filtersss&quot;)public class CharSetFilter implements Filter &#123;    private static final Logger LOGGER = Logger.getLogger(CharSetFilter.class.getName());    private static final String CHARSET = &quot;UTF-8&quot;;    public void init(FilterConfig config) throws ServletException &#123;        System.out.println(&quot;LoginOccasion过滤器初始化完成 - &quot; + new Date());    &#125;    public void destroy() &#123;        System.out.println(&quot;LoginOccasion过滤器被销毁 - &quot; + new Date());    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;        // 1. 预处理 - 在请求到达Servlet之前执行        System.out.println(&quot;LoginOccasion过滤器: 预处理开始&quot;);        // 获取客户端IP地址        String ipAddress = request.getRemoteAddr();        System.out.println(&quot;请求来自IP: &quot; + ipAddress + &quot; - &quot; + new Date());        request.setCharacterEncoding(CHARSET);        response.setCharacterEncoding(CHARSET);        response.setContentType(&quot;text/html; charset=&quot; + CHARSET);        if(request instanceof HttpServletRequest) &#123;            HttpServletRequest httpRequest = (HttpServletRequest) request;            System.out.println(&quot;访问的URL: &quot; + httpRequest.getRequestURL());            System.out.println(&quot;HTTP方法: &quot; + httpRequest.getMethod());        &#125;        // 记录请求开始时间        long startTime = System.currentTimeMillis();        // 2. 将请求传递给下一个过滤器或目标Servlet        chain.doFilter(request, response);        // 3. 后处理 - 在响应返回客户端之前执行        long endTime = System.currentTimeMillis();        System.out.println(&quot;请求处理耗时: &quot; + (endTime - startTime) + &quot;毫秒&quot;);        System.out.println(&quot;LoginOccasion过滤器: 后处理完成&quot;);    &#125;&#125;\r\nFilterConfig和FilterChain\r\nFilterConfig和FilterConfig这2个对象是由服务器(Tomcat)在创建和调用Filter对象时所传入的，这2个对象十分有用，FilterConfig对象可以读取我们配置的初始参数，FilterChain可以实现多个Filter之间的连接。\r\nFilterConfig\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n里面的方法就4个，下面我们分别进行讲解\r\n\r\ngetFilterName()：获取filter的名称\r\ngetServletContext()：获取ServletContext\r\ngetInitparamter(String var1)：获取配置的初始参数的值\r\ngetInitParamterNames()：获取配置的所有参数名称\r\n\r\n实际例子\r\n我们在init方法中使用FilterConfig来读取配置的数据库的信息，然后输出。\r\nimport javax.servlet.*;import java.io.IOException;import java.util.Enumeration; public class MyFilterConfig implements Filter &#123;     @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;-----------获取全部key:value------------&quot;);        //得到所有配置参数的名字        Enumeration&lt;String&gt; names = filterConfig.getInitParameterNames();        while (names.hasMoreElements()) &#123;            //得到每一个名字            String name = names.nextElement();            System.out.println(name+&quot; = &quot;+filterConfig.getInitParameter(name));        &#125;        System.out.println(&quot;-----------end.....------------&quot;);    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\nxml 配置\r\n&lt;filter&gt;        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;        &lt;filter-class&gt;com.clucky.filter.MyFilterConfig&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;driver&lt;/param-name&gt;            &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;url&lt;/param-name&gt;            &lt;param-value&gt;jdbc:mysql://localhost:3306/equip_employ_manage?serverTimezone=GMT&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;username&lt;/param-name&gt;            &lt;param-value&gt;root&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;password&lt;/param-name&gt;            &lt;param-value&gt;root&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n我们使用FilterConfig提供的方法就成功实现了功能，FilterConfig就是用来读取配置文件的。\r\n\r\nFilterChain\r\n在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在\r\nweb.xml 文件中的注册顺序，决定先调用哪个Filter，当第一个 Filter 的\r\ndoFilter 方法被调用时，web服务器会创建一个代表 Filter 链的FilterChain\r\n对象传递给该方法。在 doFilter 方法中，开发人员如果调用了 FilterChain\r\n对象的 doFilter 方法，则 web 服务器会检查 FilterChain\r\n对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n我们查看类图，可以发现 FilterChain\r\n就只有一个方法，其实这个方法就是用来对拦截进行放行的，如果有多个拦截器，那么就会继续调用下一个Filter进行拦截。doFilter\r\n方法需要传入个参数，一个是 ServletRequest ，一个是 ServletResponse\r\n参数，这个直接传入进行。\r\nTomcat 在调用过滤器时，默认就会传入 Request 和\r\nResponse，这个参数封装了请求和响应，我们直接使用就行。ServletResquest 和\r\nServletResponse 可以直接强转成 HttpServletRequest 和\r\nHttpServletResponse，然后使用相应的方法。\r\n将ServletRequest转成HttpServletRequest\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n应用实例\r\n我们前面一直都是一个Filter，现在我们来配置2个Filter，通过FilterChain来进行多个过滤。\r\n第一个 Filter\r\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Filter01 implements Filter &#123;     @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;调用过滤器01对请求进行过滤~~~~&quot;);        //放行,如果还有过滤器，那么就执行下一个过滤器        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;调用过滤器01对响应进行过滤~~~~&quot;);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\n第二个Filterl\r\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Filter02 implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;调用过滤器02对请求进行过滤~~~~&quot;);        //放行,如果还有过滤器，那么就执行下一个过滤器        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;调用过滤器02对响应进行过滤~~~~&quot;);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\r\n启动服务器，访问8080，查看控制台输出。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n我们可以看见Filter01先进行过滤，然后交给Filter02，然后访问资源，然后Filter02对响应进行过滤，然后Filter01对响应进行过滤。图示如下：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n多个 Filter 的执行顺序\r\n上面我们配置了2个过滤器，那么我们怎么知道那个过滤器先执行呢？\r\n\r\n如果我们是在web.xml中配置的过滤器，那么过滤器的执行顺序就是在web配置的顺序，配置在上面那么就会先执行。\r\n如果我们是使用@WebFilter进行配置的，那么执行顺序就是字符比较顺序来执行，例如有2个过滤器，一个是AFilter，一个是BFilter，那么AFilter就会先执行。\r\n如果注解和xml混用，那么在web.xml中配置的会先执行。\r\n\r\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaWeb","JavaEE"]},{"title":"Java难绷知识01之对象流","url":"/posts/54621.html","content":"Java难绷知识01之对象流\r\n本篇文章会探讨一些JavaIO流中比较容易被忽视的对象流，而且会相对的探讨其中的一些细节\r\n其中对于对象流的操作讲解会少一些，主要讨论的是一些细节\r\n在 Java IO 流中，对象流（ObjectInputStream对象输入流 和\r\nObjectOutputStream对象输出流）用于将对象进行序列化和反序列化操作\r\n对象流及其序列化\r\n首先，ObjectInputStream和ObjectOutputStream这两个类都属于是字节流，它们分别继承自InputStream和OutputStream\r\n对象输出流，ObjectOutputStream，用于对象的序列化，也就是把Java对象转换成字节序列，把字节序列写出到文件，以这种对象转换为字节序列的机制实现了对象存储\r\n序列化目的是能够将整个 Java\r\n对象（包括对象的状态，即成员变量的值）转换为字节流，以便在网络上传输或存储到文件中，之后还能稳定的从字节流中恢复出原来的对象。\r\n通过序列化，对象的状态信息（包括成员变量的值）可以被保存下来，以便后续传输或存储。\r\n对象输入流，ObjectInputStream，用于对象的反序列化，是将文件中的字节序列恢复为Java对象，以这种字节序列转换为对象的机制实现了对象读取\r\n反序列化时，系统会根据字节流中的信息重新构建对象的状态。\r\n\r\n在其基础上，我们再探讨序列化的一些细节\r\n对象序列化的条件\r\n要想使一个类的对象能够被序列化，该类必须实现 java.io.Serializable\r\n接口\r\n这是一个标记接口，没有任何方法需要实现。实现该接口，意味着告诉 Java\r\n虚拟机这个类的对象可以被序列化。\r\n\r\n\r\n点击查看代码\r\n\r\nimport java.io.*;// 定义一个实现Serializable接口的类class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;public class SerializationExample &#123;    public static void main(String[] args) &#123;        // 创建一个对象        Person person = new Person(&quot;Alice&quot;, 30);        // 序列化对象到文件        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) &#123;            oos.writeObject(person);            System.out.println(&quot;对象已成功序列化到文件 person.ser&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 从文件反序列化对象        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) &#123;            Person deserializedPerson = (Person) ois.readObject();            System.out.println(&quot;反序列化后的对象: &quot; + deserializedPerson);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n注意：\r\n每个可序列化的类都应该有一个serialVersionUID，用于验证序列化和反序列化过程中的版本兼容性\r\n使用transient关键字声明的成员变量不会被序列化\r\n序列化可能会引发安全问题\r\n对象流的使用细节\r\n对象流需要关闭吗\r\n先说结论，可以不关\r\n但是强烈建议关闭。这与 Java 流的资源管理机制紧密相关。\r\n涉及到对外部资源的读写操作，包括网络、硬盘等等的I/O流，如果在使用完毕之后不关闭，会导致资源泄漏以及可能会引起文件锁定等问题。\r\n当我们使用流进行数据操作时，它们会占用系统资源，如文件句柄、网络连接等。如果不关闭流，这些资源将不会被释放，可能导致资源泄漏问题。长时间运行的程序如果频繁出现资源泄漏，最终可能耗尽系统资源，导致程序崩溃或系统性能严重下降。\r\n而且关闭流可以确保所有已写入的数据被正确地传输到目标位置 例如，当使用\r\nObjectOutputStream\r\n将对象写入文件时，关闭流会保证缓冲区中的所有数据都被写入文件，避免数据丢失。\r\n通常建议使用try - with - resources语句来自动关闭流，示例代码如下\r\n\r\n\r\n\r\n示例代码\r\n\r\nimport java.io.*;class MyClass implements Serializable &#123;    private static final long serialVersionUID = 1L;    int data;    public MyClass(int data) &#123;        this.data = data;    &#125;&#125;public class SerializeExample &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass(42);        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myfile.ser&quot;))) &#123;            oos.writeObject(obj);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n对象流需要使用flush吗\r\n先说结论，不用\r\nObjectOutputStream内部维护了一个缓冲区。在调用writeObject方法时，数据首先会被写入缓冲区。调用flush方法可以强制将缓冲区中的数据立即写入底层输出流。然而，在大多数情况下，并不需要显式调用flush。因为当缓冲区满、流关闭或者调用某些特定方法（如writeObject在某些情况下会触发缓冲区数据的刷新）时，缓冲区的数据会自动被写入底层流。\r\n当然特意需要弄的时候可以弄\r\nserialVersionUID在对象流中的必要性\r\n凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量：\r\nprivate static final long serialVersionUID;\r\n来表明类的不同版本间的兼容性。\r\n在完成序列化操作后，如果对序列化对象进行了修改，那么我们再进行反序列化就会抛出InvalidClassException异常。\r\n因为serialVersionUID缺失（没有显式分配）或者serialVersionUID发生了变化，\r\nserialVersionUID的作用在此体现——对序列化对象进行版本控制，有关各版本反序加化时是否兼容。避免混乱。\r\nclass Person implements Serializable &#123;    private static final long serialVersionUID = 1234567890123456789L;    private String name;    private int age;    // 后续可以安全地对类结构进行一些兼容的修改&#125;\r\n一个类在没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。\r\n若类的实例变量做了修改，serialVersionUID\r\n可能发生变化。所以建议一般显式声明。\r\n序列化的一些细节\r\nstatic修饰的属性 不可以被序列化\r\n原因在于 static\r\n变量属于类，而不是类的实例。它们是类级别的共享数据，与对象的状态无关。\r\n序列化的目的是保存对象的状态，所以 static\r\n变量不会被包含在序列化的内容中。 class StaticExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private static int sharedValue = 10;    private int instanceValue;    public StaticExample(int instanceValue) &#123;        this.instanceValue = instanceValue;    &#125;&#125; 当我们序列化\r\nStaticExample 类的对象时，sharedValue 不会被序列化。\r\n在反序列化时，sharedValue\r\n的值将取决于类加载时的初始化状态，而不是序列化时的值\r\ntransient 修饰的属性不可以被序列化 transient\r\n关键字用于标记那些不希望被序列化的属性。\r\n这在某些场景下非常有用，比如当对象的某个属性包含敏感信息（如密码）或者该属性在反序列化后可以通过其他方式重新计算得到时。\r\nclass TransientExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String username;    private transient String password;    public TransientExample(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;&#125; 当对 TransientExample 对象进行序列化时，password\r\n的值不会被写入序列化流。这样可以保护敏感信息，防止其在序列化过程中被泄露。在反序列化后，password\r\n属性的值将为 null，程序可以重新设置该值。\r\n对象序列化的作用\r\n为什么JavaIO流要特意造出这么一个IO流\r\n当你需要把对象写入到文件或者读取的时候，其实我们更多的情况通常是保存对象的有效值字段，也就是对象的具体实例的字段，那么使用文件操作流FileOutputStream和字符输出流BufferedWriter或PrintStream就足够。这些流可以用于处理文件写入和基本数据类型及字符串的输出，但对象序列化有着独特且不可替代的作用\r\n网络传输对象\r\n对象序列化机制是Java内建的一种对象持久化方式，可以很容易实现在JVM中的活动对象与字节流之间进行转换\r\n在网络传输中，发送端将对象序列化成字节流，经过网络传输到网络的另一端，可以从字节流重新还原为对象，这个特点使得在进行端到端的网络传输数据时候，字节流和Java对象之间的转换稳定且快速。\r\n在其中分布式系统中，不同的节点之间需要进行对象的传递，对象序列化使得这种对象传输变得简单直接，确保了对象在不同\r\nJava 虚拟机之间的准确传输，即使这些 JVM 运行在不同的操作系统上。\r\nRMI 是 Java 的一种远程方法调用机制，它允许一个 JVM 中的对象调用另一个\r\nJVM 中的对象的方法。对象序列化也在其中起着关键作用\r\n确保对象深层次的复制和持久化\r\n当对一个对象进行序列化然后反序列化时，会得到一个与原对象状态完全相同但内存地址不同的新对象。可以实现在不影响原对象的情况下对对象进行操作，多线程下的数据处理的机制也有一定序列化和反序列化的影子。\r\n这种情况对于远程创建对象副本并且调度的时候十分方便，而且不会干扰对象内部包含的复杂的引用关系，合理使用对象流可以大大提高程序处理复杂数据的能力。\r\n在很多情况下，对象内部状态是需要被持久化的，序列化通过把对象写为字节流，保存的位置从JVM内存转移到文件系统，在需要的时候随时可以进行快速方便的还原\r\n例如：在一个游戏中，可以使用对象流将玩家的游戏进度（一个复杂的对象，包含玩家角色信息、游戏关卡等）保存到文件中，下次玩家启动游戏时可以恢复到上次的进度。\r\n对象流与其他流的关系\r\n与字节流的关系\r\n字符流是对象流的特例，它们处理的是字符数据的序列化和反序列化。\r\n字符流（Reader 和 Writer 及其子类，如 BufferedReader、BufferedWriter\r\n等）主要用于处理字符数据。Java 采用 Unicode\r\n编码来表示字符，字符流对其的输入输出有优化。而且字符流在处理数据时，会根据指定的字符编码进行字节和字符之间的转换\r\n而对象流可以将任何实现了 Serializable\r\n接口的对象进行序列化和反序列化，意味着对象流操作的数据是复杂的对象结构，包括对象的成员变量、对象之间的引用关系。\r\n##### 与缓冲流的关系 功能叠加：缓冲流（如\r\nBufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter）的主要作用是提高数据读写的效率，通过在内存中设置缓冲区，减少实际的\r\nI/O 操作次数。\r\n对象流可以和缓冲流结合使用，以提升对象序列化和反序列化的性能。\r\n可以将 ObjectOutputStream 包装在 BufferedOutputStream\r\n中，这样在写入对象时，数据会先写入缓冲区，当缓冲区满或流关闭时，才会一次性将数据写入底层输出流，从而减少磁盘\r\nI/O 操作的频率，提高写入效率。\r\n在处理大量对象的序列化或反序列化时，结合缓冲流能显著提升性能。不过反序列化涉及到的种种安全关系，这种情况，讨论一下就好。\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识02-抽象类中只能有或者必须有抽象方法吗以及抽象类的细节探讨","url":"/posts/44268.html","content":"Java难绷细节02—抽象类中只能有抽象方法吗\r\n首先回答标题抛出的问题——False\r\n显然，有抽象方法的类是抽象类，但是，抽象类中只能有抽象方法吗？\r\n抽象类可以包含抽象方法，也可以包含具体方法\r\n如果一个类包含至少一个抽象方法，用abstract关键字修饰，那么这个类必须被声明为抽象类。\r\n抽象类除了可以有抽象方法外，还可以包含具体的方法，即有方法体的方法。\r\n一个类用abstract修饰，那它就是抽象类了，但是不是说抽象类中必须有抽象方法，如果一个类像接口那样所有方法都有具体的实现，也可以用abstract修饰为抽象类\r\n那么反过来想，抽象方法只能写在抽象类中，但是抽象类中不一定要有抽象方法\r\n一个包含了抽象方法和具体方法的抽象类 public abstract class Shape &#123;    // 抽象方法    public abstract double getArea();    // 具体方法    public void displayInfo() &#123;        System.out.println(&quot;This is a shape.&quot;);    &#125;&#125; abstract class AbstractParent &#123;    // 具体方法    public void printMessage() &#123;        System.out.println(&quot;This is a message from AbstractParent.&quot;);    &#125;&#125;// 子类继承抽象类，非抽象子类需要实现抽象方法class Child extends AbstractParent &#123;    // 子类可以直接使用父类的具体方法，根据需要重写    @Override    public void printMessage() &#123;        System.out.println(&quot;This is a message from Child, overriding the parent method.&quot;);    &#125;&#125;\r\n另外，如果一个抽象类并没有包含任何抽象方法，那么它的子类即使不实现任何方法也是非抽象类\r\n总之，抽象类是一种特殊的类，它的存在主要是为了提供一个通用的框架或基类，让其他子类去继承和实现具体的功能，抽象类可以包含抽象方法和具体方法，但是有抽象方法的类必须是抽象类\r\n如果我这篇博客就说这一点东西就有种，“因为这点事就把大伙叫过来？”的蹩脚感觉\r\n于是我们接着探讨一些抽象类中的各种令人很难绷的住的细节\r\n为什么要有抽象类\r\n这个问题尽管乍看之下对实际开发的直接引导作用并非立竿见影，但深入剖析其中缘由，能让我们对\r\nJava\r\n语言的设计理念和面向对象编程的本质有更为透彻的理解（也能让我说出更多东西）\r\n抽象类和抽象方法的产生是为了维护继承链的逻辑，即抽象类相对于那些普通的类处于继承树的根部。抽象类和抽象方法的诞生，很大程度上是为了维护继承体系的逻辑完整性与合理性\r\n首先，类用于描述现实生活中一类事物。类中有属性、方法等成员\r\n那么，抽象类中，有用的就是方法的声明，方法主体存在的意义被弱化，这种情况下十分适合用于取规范一个子类应该具备一个怎样的方法，既可以定义需要子类去实现的抽象行为，以满足不同子类的个性化需求，又能实现一些通用的行为或属性，让子类能够共享这些功能，从而提高代码的复用性和可维护性。\r\n但是，抽象类中的非抽象方法如同在非抽象类中一样，正常继承使用。\r\n所以，抽象类通常用于作为其他类的父类，用来定义一些需要子类去实现的抽象行为\r\n主要目的是为了阻止其他类直接实例化这个类，同时为其子类提供一个通用的基类框架，用于实现一些通用的行为或属性。\r\n抽象类可以设计模板模式，其中的某些步骤由抽象方法表示，具体的实现留给子类，大大增加了可读性和简便程度。\r\n抽象类可以用于定义一组相关类的通用接口规范，通过抽象类，我们可以确保所有相关类都具有特定的行为，同时又允许它们根据自身特性进行个性化实现。\r\n抽象方法\r\n抽象方法只有方法声明，没有方法体（有爆Error），并且必须使用 abstract\r\n关键字修饰。 public abstract class Shape &#123;    public abstract double getSquare();&#125; #### 抽象方法的特点\r\n- 抽象方法必须存在于抽象类中 -\r\n包含抽象方法的类必须被声明为抽象类。这样做的目的是为了确保抽象方法不会被意外调用，因为抽象方法本身没有实际的执行代码，实例化该类时就可能调用到没有实现的方法，这会导致运行时错误。\r\n\r\n所有子类都需要实现抽象类中的抽象方法，除非子类本身也是抽象类。\r\n\r\n抽象类定义了一种抽象的概念，其中的抽象方法是这种概念下未完成的行为。子类继承抽象类，就继承了这种抽象概念及其未完成的行为。如果子类不实现抽象方法，那么这个子类仍然是不完整的，因为它没有完成抽象类中定义的行为。\r\n\r\n强制子类实现\r\n\r\n这个没啥好说的，当一个类继承自包含抽象方法的抽象类时，除非子类本身也是抽象类，否则它必须实现父类中的所有抽象方法。这是保证行为一致性的重要手段。\r\n\r\n\r\nabstract class Shape &#123;    public abstract double getArea();&#125;// 子类本身是抽象类，可以不实现getArea方法abstract class ThreeDShape extends Shape &#123;    // 这里没有实现getArea方法，因为ThreeDShape是抽象类&#125;class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\r\n\r\n抽象方法不能用private、final、static、native修饰。\r\n\r\n抽象方法不能被声明为\r\nstatic，静态方法属于类本身，而不是类的实例，而抽象方法的实现依赖于具体的子类实例。如果将抽象方法声明为静态，就无法通过子类实例来提供具体的实现。来回的限制区域错误会导致无法通过子类实例来提供具体的实现\r\nprivate修饰的成员只能在本类中访问，抽象方法的设计目的是为了让子类去实现，矛盾\r\nfinal修饰的方法不能被子类重写。如果一个方法同时被abstract和final修饰，就会产生矛盾\r\nnative方法表示该方法的实现是由本地代码提供的，Java\r\n本身不包含该方法的实现。抽象方法没有实现，就会出现冲突\r\n\r\n\r\n抽象类的一些各种细节\r\n1、抽象类不能被实例化\r\n首先抽象类是不能实例化的类\r\n抽象类存在的意义是作为一种抽象概念，为子类提供一个通用的框架，可能包含一些尚未具体实现的抽象方法，这些方法需要子类去实现\r\n如果抽象类可以被实例化，就可能调用到未实现的抽象方法，导致运行时错误\r\nabstract class Galgame &#123;    public abstract void run();&#125;\r\n如果允许Galgame被实例化，如Galgame galgame = new Galgame();\r\n当调用galgame.run()时，由于run方法没有具体实现，就会出现问题\r\n2、abstract不能static\r\n抽象方法可以使用 public 或 protected\r\n作为访问修饰符，但是static不行\r\n再次强调，抽象方法是一种只有声明没有实现的方法，需要子类去重写实现。它依赖于具体的子类实例来确定具体的行为。\r\n而静态方法属于类本身的方法，不依赖于任何类的实例，是通过类名直接调用。在类加载时就已经确定，其生命周期与类的生命周期相同。\r\n如果一个方法同时被abstract和static修饰，就会产生矛盾。\r\n因为抽象方法没有具体实现，不能直接调用。只有在创建了子类的实例，并将其赋值给父类类型的引用变量后，通过该引用变量调用抽象方法时，才会执行子类中重写的具体实现。而静态方法不依赖于实例，在类加载时就可调用，这样会导致内存的顺序出现问题，因为静态方法不依赖于对象实例，而抽象方法却依赖子类实例来提供具体实现\r\n反证法，如果是静态抽象方法，那么在类加载时就可调用，但此时由于它是抽象的，没有具体实现，调用必然出错。\r\n3、抽象类的构造器\r\n抽象类可以有构造器\r\n虽然抽象类不能被直接实例化，但它的构造器用于被子类调用\r\n因为抽象类中是可以有成员变量的\r\n当创建子类对象时，会先调用抽象类的构造器，然后再调用子类的构造器。这确保了在子类对象初始化之前，从抽象类继承的部分已经被正确初始化。\r\n4、可以有成员变量\r\n抽象类可以有成员变量的原因是抽象类中的成员变量可以用于存储子类共享或需要继承的状态信息，如果子类需要，抽象父类可以提供\r\n成员变量的访问控制：与普通类一样，抽象类中的成员变量可以有不同的访问修饰符\r\nabstract class Vehicle &#123;    private int wheels;    protected String color;    public int speed;    Vehicle(int wheels, String color, int speed) &#123;        this.wheels = wheels;        this.color = color;        this.speed = speed;    &#125;    public int getWheels() &#123;        return wheels;    &#125;    public abstract void move();&#125;class Car extends Vehicle &#123;    public Car(int wheels, String color, int speed) &#123;        super(wheels, color, speed);    &#125;    @Override    public void move() &#123;        System.out.println(&quot;The &quot; + color + &quot; car is moving.&quot;);    &#125;&#125;\r\n5、继承抽象类的抽象子类问题\r\n如果一个类继承自抽象类，但它本身也是抽象类，那么它可以选择不实现父类的抽象方法\r\nabstract class Shape &#123;    public abstract double getArea();&#125;abstract class ThreeDShape extends Shape &#123;    // 可以不实现getArea方法，因为ThreeDShape本身是抽象类&#125;// 而 Sphere 类继承自 ThreeDShape，作为具体类，它必须实现 getArea 方法。class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\r\n抽象类跟接口\r\n包括我而言，很多人不禁疑惑，为什么有了抽象类，还要干出一个接口来？？\r\n这俩都是一定程度上规范子类的方法，功能一眼看过去差不多\r\n这个我打算写一篇详细的文章，但是算了，没啥时间））我还要推gal，而且这不是一个需要长篇大论的问题，在这里和大家简单探讨一下\r\n其实是很简单的问题，但凡遇到了两种东西，功能很相似，通常情况就是这几种：使用场景不同，产生的最终结果不同，兼容性与更优性问题。\r\n突破继承限制与灵活性\r\n在 Java\r\n中，一个类只能继承一个直接父类。这是为了避免多重继承带来的诸如继承混乱问题（什么哈斯图，我正好在看离散）\r\n而接口则打破了这种限制，一个类可以实现多个接口。这使得类能够从多个不同的\r\n“行为集合”\r\n中获取规范，灵活性极大up，使得子类更好的拥有多种行为能力。\r\n功能侧重点差异\r\n抽象类虽然可以包含抽象方法，但也能有具体的属性和方法实现。这意味着抽象类在一定程度上仍然保留了对具体实现细节的描述。这是根据子类的需要，抽象类并不特别死的限制会带来很多方便和意想不到的特别之处\r\n接口是一种完全抽象的类型，它只包含抽象方法（Java 8\r\n及之后版本可包含默认方法和静态方法，但是本质绝对不会因为这个改动而改变），没有任何成员变量，只关注行为的定义，不涉及任何细节，只做出最少最需要的方法约束，更加纯粹地体现了一种行为规范，而且不用不行。\r\n场景差异\r\n当多个类之间存在一些共同的属性和行为，并且这些共同部分可以在抽象类中进行部分实现时，适合使用抽象类。也就是对于很多个类中，我抽象出了一些共有属性实现了一个类，之后的符合该属性的类，就按照抽象类的规定来实现。与行为约束相比，更偏向共性总结。\r\n而当需要为不相关的类添加一些通用行为时，接口更为合适。也就是接口这是一个规矩，有什么类需要实现这个规矩，我就用接口来规范它。\r\n扩展性差异\r\n如果在抽象类中添加新的方法，可能需要在所有子类中实现该方法，这对于已经存在的大量子类来说，维护成本较高，一个个改会比较累。\r\n对于接口，如果添加新的方法，（在 Java 8\r\n之前，实现该接口的类不会受到影响（除非强制要求实现新方法）），那么实现该接口的类会分为两种，一个是完全实现了接口的类，一个是未完全实现了接口的类。在\r\nJava 8\r\n及之后，新增的默认方法有了默认实现，实现接口的类可以选择是否重写这些默认方法，这使得接口在扩展时对已有实现类的影响较小，更易于维护和扩展。\r\n\r\n文章个人编辑较为匆忙，需要大家积极反馈来帮助这篇文章和我的更进一步\r\nQQ：1746928194，是喜欢画画的coder，欢迎来玩！\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java注解与Annotation类","url":"/posts/54622.html","content":"了解注解\r\nJava 注解（Annotation）又称 Java 标注，是 JDK5.0\r\n引入的一种注释机制。是提供一种为程序元素设置元数据的方法，这些信息可以被编译器、开发工具或运行时环境读取和处理。\r\n（程序元素：接口、类、属性、方法等； 元数据：描述数据的数据）\r\n关键特性：\r\n\r\n注解本身不包含业务逻辑，但可以通过反射机制在运行时获取并处理\r\n注解不影响程序本身的执行，但可以通过工具影响程序的行为\r\n注解可以包含命名参数，这些参数可以有默认值\r\n\r\n其实就是写在接口、类、属性、方法上的一个标签，或者说是一个特殊形式的注释，普通注释只是一个注释，而注解在代码运行时是可以被反射读取并进行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。\r\nJava 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc\r\n不同，Java 标注可以通过反射获取标注内容。\r\n在编译器生成类文件时，标注可以被嵌入到字节码中。Java\r\n虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义\r\nJava 标注。\r\n可以利用注解来自定义一些实现，比如在某个方法上加一个自定义注解，就可以实现方法日志的自动记录打印\r\n举例@Override:\r\n它的作用是告诉阅读者(开发人员、编译器)这个方法重写了父类的方法，对于开发人员只是一个标志，然而编译器如果发现方法标注了这个注解，就会检查这个方法到底是不是真的覆写了父类的方法，如果没有会报错，而如果不添加@Override注解，程序也是可以正常运行的，不过缺乏了静态的检查\r\n在spring框架中加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。\r\n注意：注解不能直接干扰程序代码的运行\r\n注解的作用\r\n话说当年非常流行xml配置的。优点呢就是整个项目的配置信息集中在一个文件中，从而方便管理，是集中式的配置。缺点也显而易见，当配置信息非常多的时候，配置文件会变得越来越大不易查看管理，特别是多人协作开发时会导致一定的相互干扰。\r\n现在都提倡解耦、轻量化或者说微小化，那么注解就顺应了这一需求，各个包或模块在内部方法或类上使用注解即可实现指定功能，缺点呢就是不方便统一管理，如果需要修改某一类功能，则需要整体搜索逐个修改，是分散式的存在各个角落。\r\nxml的方式是集中式的元数据，不需要和代码绑定的，而注解是一种分散式的元数据设置方式。\r\n开发者的视角可以解读出这个类/方法/属性的作用以及该怎么使用，而从框架的视角则可以解析注解本身和其属性实现各种功能，编译器的角度则可以进行一些预检查(@Override)和抑制警告(@SuppressWarnings)等。\r\n\r\n作为特定标记，用于告诉编译器一些信息\r\n编译时动态处理，如动态生成代码\r\n运行时动态处理，作为额外信息的载体，如获取注解信息\r\n\r\nAnnotation架构\r\nJava 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在\r\njava.lang.annotation 中。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n其中\r\n\r\n1 个 Annotation 和 1 个 RetentionPolicy 关联。\r\n\r\n可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。\r\n\r\nRetentionPolicy\r\n是一个枚举类型，它定义了注解的保留策略，也就是规定了注解在什么阶段是可用的。\r\n\r\n\r\n1 个 Annotation 和 1~n 个 ElementType 关联。\r\n\r\n对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性\r\n\r\nAnnotation 有许多实现类，包括：Deprecated, Documented,\r\nInherited, Override 等等。\r\n\r\n每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于\r\nElementType 属性，则有 1~n 个。\r\n\r\n\r\nAnnotation 组成部分\r\njava Annotation 的组成中，有 3\r\n个非常重要的主干类。它们分别是：Annotation ElementType\r\nRetentionPolicy\r\npackage java.lang.annotation;public interface Annotation &#123;    // 当两个注解对象满足以下条件时，认为它们相等：注解类型相同  所有注解元素的值都相等    boolean equals(Object obj);    int hashCode();    // 将当前注解对象转换为字符串表示形式,字符串表示通常包含注解的类型名称和所有注解元素的值。    String toString();       // 获取当前注解对象的注解类型。注解类型是一个 Class 对象，它表示定义该注解的接口。    Class&lt;? extends Annotation&gt; annotationType();   &#125;\r\npackage java.lang.annotation;public enum ElementType &#123;    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */&#125;\r\npackage java.lang.annotation;public enum RetentionPolicy &#123;    SOURCE,   /*源码级 Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /*类文件级 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /*运行级 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125;\r\n其中：\r\n\r\nAnnotation这个接口中，每 1 个 Annotation 对象，都会有唯一的\r\nRetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\r\nElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。当\r\nAnnotation 与某个 ElementType\r\n关联时，就意味着：Annotation有了某种用途\r\n就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。\r\n\r\nAnnotation 通用定义\r\n@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125;\r\n上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。\r\n定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1”\r\n来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1\r\n的。\r\njava常用的Annotation\r\n@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented  -- @Documented 所标注内容，是否包含在用户文档中javadoc@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention   -- @Retention只能被用来标注“Annotation类型”，用来指定Annotation的RetentionPolicy属性作用域。@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。\r\nAnnotation 的作用\r\n编译检查\r\nAnnotation 具有”让编译器进行编译检查的作用”。\r\n例如\r\n\r\n@SuppressWarnings, @Deprecated 和 @Override\r\n都具有编译检查作用。\r\n若某个方法被 @Override\r\n的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override\r\n标示，但父类中却没有”被 @Override\r\n标注”的同名方法，则编译器会报错。\r\n\r\n\r\n\r\nimg\r\n\r\n我们可以发现 getString() 函数会报错。这是因为\r\ngetString() 被 @Override\r\n所标注，但在OverrideTest 的任何父类中都没有定义\r\ngetString() 函数”。\r\n反射中使用Annotation\r\n在反射的 Class, Method, Field 等函数中，有许多于 Annotation\r\n相关的接口。我们可以在反射中解析并使用 Annotation。\r\n/** * Annotation在反射函数中的使用示例 */@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String[] value() default &quot;unknown&quot;;&#125;/** * Person类。它会使用MyAnnotation注解。 */class Person &#123;        /**     * empty()方法同时被 &quot;@Deprecated&quot; 和 &quot;@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注      * (01) @Deprecated，意味着empty()方法，不再被建议使用     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;     */    @MyAnnotation    @Deprecated    public void empty()&#123;        System.out.println(&quot;\\nempty&quot;);    &#125;        /**     * sombody() 被 @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，     * @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;     */    @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)    public void somebody(String name, int age)&#123;        System.out.println(&quot;\\nsomebody: &quot;+name+&quot;, &quot;+age);    &#125;&#125;public class AnnotationTest &#123;    public static void main(String[] args) throws Exception &#123;                // 新建Person        Person person = new Person();        // 获取Person的Class实例        Class&lt;Person&gt; c = Person.class;        // 获取 somebody() 方法的Method实例        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]&#123;String.class, int.class&#125;);        // 执行该方法        mSomebody.invoke(person, new Object[]&#123;&quot;lily&quot;, 18&#125;);        iteratorAnnotations(mSomebody);                // 获取 somebody() 方法的Method实例        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]&#123;&#125;);        // 执行该方法        mEmpty.invoke(person, new Object[]&#123;&#125;);                iteratorAnnotations(mEmpty);    &#125;        public static void iteratorAnnotations(Method method) &#123;        // 判断 somebody() 方法是否包含MyAnnotation注解        if(method.isAnnotationPresent(MyAnnotation.class))&#123;            // 获取该方法的MyAnnotation注解实例            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);            // 获取 myAnnotation的值，并打印出来            String[] values = myAnnotation.value();            for (String str:values)                System.out.printf(str+&quot;, &quot;);            System.out.println();        &#125;                // 获取方法上的所有注解，并打印出来        Annotation[] annotations = method.getAnnotations();        for(Annotation annotation : annotations)&#123;            System.out.println(annotation);        &#125;    &#125;&#125;\r\n注解的分类\r\n通常来说注解分为以下三类\r\n\r\n元注解 – java内置的注解，标明该注解的使用范围、生命周期等。\r\n标准注解 –\r\nJava提供的基础注解，标明过期的元素/标明是复写父类方法的方法/标明抑制警告。\r\n自定义注解 – 第三方定义的注解，含义和功能由第三方来定义和实现。\r\n\r\n元注解\r\n用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。\r\n元注解就是最基本不可分解的注解，我们不能去改变它只能使用它来定义自定义的注解。\r\n元注解包含以下五种： @Retention、@Target、@Documented、@Inherited、@Repeatable\r\n@Retention\r\n定义\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    RetentionPolicy value();&#125;\r\n标明自定义注解的生命周期，这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。它决定了注解在何时有效以及在何处可用。\r\n从编写Java代码到运行主要周期为源文件→\r\nClass文件 → 运行时数据，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为SOURCE\r\n→CLASS→RUNTIME。 -\r\nSOURCE：源代码java文件，不会包含在编译后的 class 文件中，编译时候会丢弃\r\n-\r\nCLASS：类文件级别保留，class文件中会保留注解，但是jvm加载运行时就没有了，是默认的保留策略\r\n-\r\nRUNTIME：运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的\r\n各个生命周期的用途：\r\n\r\nSOURCE级别：\r\n\r\n典型应用：Lombok的@Getter、@Setter\r\n特点：编译后完全消失，不会增加运行时负担\r\n使用场景：仅用于编译期检查或代码生成\r\n\r\nCLASS级别：\r\n\r\n典型应用：Android的@Keep注解\r\n特点：保留到class文件但不会被加载到JVM\r\n使用场景：字节码分析工具使用\r\n\r\nRUNTIME级别：\r\n\r\n典型应用：Spring的@Controller、@Service\r\n特点：可通过反射获取，影响运行时行为\r\n使用场景：框架开发中最常用\r\n\r\n\r\n// Lombok的@Getter示例 SOURCE级别@Retention(RetentionPolicy.SOURCE)public @interface Getter &#123;    AccessLevel value() default AccessLevel.PUBLIC;&#125;// 使用@Getterpublic class User &#123;    private String name;&#125;// 编译时会生成getName()方法，但注解本身不会保留\r\n@Target\r\n描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上(类、方法、属性、局部属性、参数…)\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    ElementType[] value();&#125;\r\nvalue是一个数组，可以有多个取值，说明同一个注解可以同时用于标注在不同的元素上。value的取值如下\r\n@Target可以指定更精确的应用目标，包括：\r\n@Target(&#123;    ElementType.TYPE,               // 类、接口、枚举    ElementType.FIELD,              // 字段（包括枚举常量）    ElementType.METHOD,             // 方法    ElementType.PARAMETER,          // 方法参数    ElementType.CONSTRUCTOR,        // 构造器    ElementType.LOCAL_VARIABLE,     // 局部变量    ElementType.ANNOTATION_TYPE,    // 注解类型    ElementType.PACKAGE,            // 包    ElementType.TYPE_PARAMETER,     // 类型参数（Java 8+）    ElementType.TYPE_USE            // 类型使用（Java 8+）&#125;)\r\n自定义一个注解@MyAnnotation1想要用在类或方法上，就可以如下定义\r\n/**    * 自定义注解，使用@Target指定该注解可以应用在哪些元素上    * 这里指定了TYPE(类/接口/枚举等)和METHOD(方法)上    */   @Retention(RetentionPolicy.RUNTIME)    // 运行时保留   @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)  // 只能用于类和方法上   public @interface MyAnnotation &#123;       String description() default &quot;&quot;;   // 注解属性默认值   &#125;   /**    * 测试类，演示@Target的使用    * 因为@MyAnnotation允许用在TYPE上，所以可以用在类声明上    */   @MyAnnotation(description = &quot;这是一个类级别的注解示例&quot;)   public static class AnnotationTest &#123;       // @MyAnnotation   用在属性上则会报错       public String name;       @MyAnnotation(description = &quot;这是一个方法级别的注解示例&quot;)       public void testMethod() &#123;           System.out.println(&quot;测试方法执行&quot;);       &#125;   &#125;\r\n获取其中的注解，只能获取到类和方法上的\r\npublic static void main(String[] args) &#123;        // 获取类上的注解        MyAnnotation classAnnotation = AnnotationTest.class.getAnnotation(MyAnnotation.class);        System.out.println(classAnnotation.description());        try&#123;            // 获取方法上的注释            Method method = AnnotationTest.class.getMethod(&quot;testMethod&quot;);            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);            System.out.println(annotation.description());        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;\r\n@Inherited\r\n表示是否可以被标注类的子类继承。当注解 Inheritable 被 @Inherited\r\n标注时，它具有继承性。否则，没有继承性。\r\n定义如下\r\n@Documented   // 说明该注解能出现在 javadoc 中。@Retention(RetentionPolicy.RUNTIME)   // 指定 Inherited 的策略是 RetentionPolicy.RUNTIME@Target(ElementType.ANNOTATION_TYPE)  // @Inherited 只能被用来标注 &quot;Annotation 类型&quot;// 它的用来修饰 Inherited，意味着 Inherited 实现了 Annotation 接口；即 Inherited 就是一个注解。public @interface Inherited &#123;    &#125;\r\n当一个类使用了带有 @Inherited\r\n的注解时，这个注解会被该类的子类继承。\r\n\r\n仅对类注解有效：@Inherited\r\n只对类级别的注解有效（即注解的 @Target 包含\r\nElementType.TYPE）\r\n不适用于接口：从父类继承的注解不会应用于实现接口的类\r\n不适用于方法等其他元素：方法上的注解不会被继承\r\n\r\n\r\n示例，通过反射获取注解\r\n// 定义一个可以被继承的注释@Inherited@Retention(RetentionPolicy.RUNTIME)  // 运行时保留，可以通过反射获取@Target(ElementType.TYPE)  // 只能用于类/接口/枚举上@interface InheritableAnnotation &#123;    String value() default &quot;父类注解&quot;;&#125;// 定义一个不可被继承的注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface NonInheritableAnnotation &#123;    String value() default &quot;不可继承的注解&quot;;&#125;// 父类，带有可继承和不可继承的注解@InheritableAnnotation(&quot;这是父类的可继承注解&quot;)@NonInheritableAnnotation(&quot;这是父类的不可继承注解&quot;)class ParentClass &#123;&#125;// 子类，继承自ParentClass，没有显式添加任何注解class ChildClass extends ParentClass &#123;&#125;\r\n打印注解的信息后可以发现：\r\n类 ParentClass 上的注解:  InheritableAnnotation:   NonInheritableAnnotation: 类 ChildClass 上的注解:  InheritableAnnotation: \r\n发现ChildClass 类没有继承\r\nNonInheritableAnnotation 注解\r\n@Repeatable\r\n定义如下\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123;    // 指定包含重复注解的容器注解类型    Class&lt;? extends Annotation&gt; value();&#125;\r\n标识某注解可以在同一个声明上使用多次。（Java 8+特性）\r\n示例：\r\n// 定义可重复注解@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;// 定义包含可重复注解的容器注解@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations &#123;    MyAnnotation[] value();&#125;// 使用可重复注解@MyAnnotation(&quot;First Annotation&quot;)@MyAnnotation(&quot;Second Annotation&quot;)class MyClass &#123;    // 类的内容&#125;public class RepeatableExample &#123;    public static void main(String[] args) &#123;        // 普通的获取类上的所有 MyAnnotation 注解        // 需要定义容器注解来存放重复注解        // 通过getAnnotationsByType()获取重复注解        MyAnnotation[] annotations = MyClass.class.getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation annotation : annotations) &#123;            System.out.println(annotation.value());        &#125;        // 使用MyAnnotations，获取类上的 MyAnnotations 注解        MyAnnotations container = MyClass.class.getAnnotation(MyAnnotations.class);        if (container != null) &#123;   // 语法糖，相当于是返回一个MyAnnotation[]            for (MyAnnotation annotation : container.value()) &#123;                System.out.println(annotation.value());            &#125;        &#125;    &#125;&#125;\r\n虽然我们标注的是多个@MyAnnotation，其实会给我们返回一个@MyAnnotations，相当于是Java帮我们把重复的注解放入了一个数组属性中\r\n@Documented\r\n定义如下\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\r\n标记注解是否包含在Javadoc中。被@Documented标注的注解会出现在生成的API文档里。\r\n\r\n无参数\r\n只影响文档生成\r\n常用于重要的API注解\r\n\r\n根据 Annotation 生成帮助文档：\r\n通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation\r\n标签出现在 javadoc 中。\r\n标准注解\r\n@Override\r\n定义\r\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\r\n标识方法覆写了父类或接口中的方法，提供编译时检查。\r\n\r\n仅用于方法\r\n编译时检查（非强制使用）\r\n源代码级别（不保留到class文件）\r\n可防止拼写错误导致意外创建新方法\r\n\r\n支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD,\r\nPACKAGE, PARAMETER, TYPE\r\n这个天天用，估计大伙都会都知道，很多人注解学习的起步就是@Override\r\n@Deprecated\r\n某个方法被 @Deprecated\r\n标注，则该方法不再被建议使用\r\n如果有开发人员试图使用或重写被 @Deprecated\r\n标示的方法，编译器会给相应的提示信息\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n定义如下\r\n@Documented  // 会出现在doc中@Retention(RetentionPolicy.RUNTIME)   // 指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。// @interface -- 它的用来修饰 Deprecated,即 Deprecated 就是一个注解public @interface Deprecated &#123;&#125;\r\n@SuppressWarnings\r\n让编译器对”它所标注的内容”的某些警告保持静默。\r\n\r\n\r\nimage-20250414173247356\r\n\r\n定义如下\r\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();  // SuppressWarnings 能指定参数&#125;\r\n@FunctionalInterface\r\n用于标识函数式接口\r\n定义：\r\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125;\r\n使用示例 @FunctionalInterfaceinterface Greeter &#123;    void greet(String name);        // 可以有默认方法    default void defaultGreet() &#123;        System.out.println(&quot;Hello, world!&quot;);    &#125;&#125;\r\n编译时会检查是否确实是函数式接口\r\n如果不是（有多个抽象方法），会报错\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识05--Swing中的事件调度线程和资源释放","url":"/posts/15372.html","content":"Swing中的事件调度线程\r\n先了解一下Swing中的单线程模型\r\n单线程模型有什么作用\r\n虽然大伙认为Swing又丑又落后（但是我编写gui入门真的是从Swing开始）\r\nSwing 最初设计是单线程模型，这意味着所有与 Swing\r\n组件交互的代码都应该在同一个线程中执行。\r\n单线程模型避免了 Swing\r\n组件可能因为会多个线程同时访问和修改而导致数据不一致或界面闪退等问题\r\n而且单线程模型使得开发者无需处理复杂的线程同步问题，这是保持页面一致性的重要原因，同一时间只有一个线程可以操作组件，正常思维去调度下不会出现部分界面更新而其他部分未更新的情况。\r\n但是单线程模型会造成一个迟钝的API。为了达到单线程模型，有一个专门的线程用于和Swing组件交互，就是Swing事件调度线程（Event\r\nDispatchThread，EDT)。\r\n如果对单线程模型线程不清楚，可能在打造响应式界面和其他更多的扩展应用上会出很多问题。\r\n为什么要了解事件调度线程（EDT）\r\n因为，EDT 是 Swing 单线程模型的核心\r\n在Swing中，所有与 UI\r\n相关的操作，如创建组件、修改组件属性、添加或移除组件等，都必须在 EDT\r\n中执行，EDT 负责处理所有的 Swing\r\n事件，但是如果长时间运行的任务或者带有阻塞机制的任务在EDT\r\n中执行，会导致UI冻结，对EDT机制深入了解就会做出更正确的取舍。所以在Swing中执行耗时任务时，要在一个新线程中执行，不能阻塞EDT线程，否则会造成swing界面的不响应，那就卡死了。SwingWorker就是用来管理任务线程和EDT之间调度的一个工具类。在这里我们先不讲SwingWorker，因为这个东西我也不咋会。\r\n并且Swing 组件不是线程安全的，这意味着如果在非 EDT 线程中更新\r\nUI，会导致不可预测的行为（通常是卡死然后瞬间爆炸）\r\n而且在后台中，通常会有其他线程去操作Swing，EDT机制就是后台线程操作\r\nSwing\r\n组件的特定机制，即保持了单线程模型的完整性，而且也能利用多线程的优势来提高应用程序的性能。\r\nSwing中的三种线程\r\n一个swing程序包含三种类型的线程：初始化线程（Initial\r\nThread）、事件调度线程（Event Dispatch Thread）和任务线程（Worker\r\nThread）。\r\n初始化线程\r\n初始化线程读取程序参数并初始化一些对象。该线程主要目的是启动程序的图形用户界面(GUI)。\r\n初始化线程用于创建各种容器，组件并显示他们，一旦创建并显示，初始化线程的任务就结束了，程序的控制权就交给了UI。\r\n初始化线程的在main方法中启动点z：main方法在主线程中执行。这也是\r\nJava 应用程序的入口点。\r\n虽然主线程可以启动 Swing 应用程序，但直接在主线程中创建和操作 Swing\r\n组件是不推荐的，因为这可能导致界面不响应或出现线程安全问题。通常，主线程会将\r\nSwing 组件的创建和初始化工作委托给事件调度线程。\r\n如代码所示，同时我们在初始化一个图形界面的时候，都会直接在主方法的主线程里，直接调用如下代码来进行初始化\r\nnew TestFrame().setVisible(true);\r\n但是复杂的程序我不推荐这样处理，因为这里有两个线程在同时访问组件：1.\r\n主线程 2. 事件调度线程。\r\n如果是复杂的图形界面程序，就有可能出现这两个线程同时操作的情况，导致同步问题的产生。\r\n所以说我们创建和显示界面的工作，最好也交给事件调度线程\r\nSwingUtilities.invokeLater(new Runnable() &#123;    public void run() &#123;        new TestFrame().setVisible(true);    &#125;&#125;);\r\n事件调度线程\r\n事件调度线程主要负责GUI组件的绘制和更新，并响应用户的输入。\r\n大家学了Swing那肯定都学了事件监听，通过对事件监听的学习，我们了解到Swing是一个事件驱动的模型，所以说所有和事件相关的操作都放是放在事件调度线程\r\n(Event Dispatch)中进行的。\r\n在 Swing 应用程序启动时，EDT\r\n会自动启动。一般通过SwingUtilities.invokeLater方法将代码块提交到\r\nEDT 执行。例如：\r\nimport javax.swing.*;public class EDTExample &#123;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;EDT Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setVisible(true);        &#125;);    &#125;&#125;\r\n事件队列处理：\r\n每个EDT都会负责管理一个事件队列，用户每次对界面更新的请求都会排到事件队列中，然后等待EDT的处理。\r\nEDT 负责从一个特定的事件队列中取出事件，并将其分发给相应的 Swing\r\n组件进行处理。当用户与 Swing\r\n界面进行交互时，比如点击按钮、移动鼠标、输入键盘字符等操作，都会生成相应的事件对象，这些对象会被放入事件队列。EDT\r\n不断循环，从队列中取出事件，并调用组件注册的事件监听器中的对应方法\r\n由于 EDT\r\n是单线程处理事件，它保证了事件处理的顺序性。避免了多线程并发访问导致的不一致性和错误。\r\n保证Swing组件的线程安全\r\n单线程操作模型：Swing\r\n组件并非线程安全，这意味着如果多个线程同时尝试访问和修改同一个 Swing\r\n组件，可能会导致数据不一致、界面显示异常甚至程序崩溃等问题。EDT\r\n通过将所有与 Swing\r\n组件的交互操作限制在单个线程内执行，有效地避免了这些线程安全问题。\r\n协调 UI 更新：所有对 Swing\r\n组件可视化属性的修改，如改变组件的大小、位置、颜色等，都必须在 EDT\r\n中进行。这样可以保证在任何时刻，组件的状态都是可预测和一致的。\r\nimport javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class SingleThreadModelExample &#123;    private static JLabel label;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;Single - Thread Model Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setLayout(new FlowLayout());            JButton button = new JButton(&quot;Start Bad Thread&quot;);            label = new JLabel(&quot;Initial Text&quot;);            button.addActionListener(new ActionListener() &#123;                @Override                public void actionPerformed(ActionEvent e) &#123;                    // 错误做法：在非EDT线程中尝试更新Swing组件                    // 在非 EDT 线程中更新 Swing 组件可能出现问题                    Thread badThread = new Thread(() -&gt; &#123;                        // 这会导致异常，因为Swing组件不是线程安全的，不能在非EDT线程中更新                        // label.setText(&quot;This will cause an issue&quot;);                        // 正确做法：使用SwingUtilities.invokeLater在EDT中更新                        SwingUtilities.invokeLater(() -&gt; &#123;                            label.setText(&quot;Updated in EDT&quot;);                        &#125;);                    &#125;);                    badThread.start();                &#125;            &#125;);            frame.add(button);            frame.add(label);            frame.setVisible(true);        &#125;);    &#125;&#125;\r\n任务线程\r\n在上面我们一直在说，有阻塞能力或者耗时长的操作中我们不放在事件调度线程中执行，那么就放在任务线程\r\n任务线程用于执行耗时操作如网络连接、文件读写、复杂计算等，以避免阻塞\r\nEDT，保证 Swing 应用程序的界面始终保持响应性。\r\n这些操作一般都会在事件响应后发起，就会自动进入事件调度线程。\r\n而事件调度线程又是单线程模式，其结果就会是在执行这些长耗时任务的时候，界面就无响应了。\r\n工作者线程在完成任务后，如果需要更新 Swing\r\n组件，不能直接操作，而是要通过SwingUtilities.invokeLater方法将更新操作提交到\r\nEDT。\r\nimport javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class WorkerThreadExample &#123;    private static JLabel label;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;Worker Thread Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setLayout(new java.awt.FlowLayout());\t\t\t            // 点击按钮启动工作者线程，工作者线程完成模拟耗时操作后，通过SwingUtilities.invokeLater方法在 EDT 中更新标签的文本。            JButton button = new JButton(&quot;Start Worker&quot;);            label = new JLabel(&quot;Status: Not started&quot;);            frame.add(button);            frame.add(label);            frame.setVisible(true);            button.addActionListener(new ActionListener() &#123;                @Override                public void actionPerformed(ActionEvent e) &#123;                    new Thread(() -&gt; &#123;                        // 模拟耗时操作                        try &#123;                            Thread.sleep(3000);                        &#125; catch (InterruptedException ex) &#123;                            ex.printStackTrace();                        &#125;                        // 更新UI，必须在EDT中执行                        SwingUtilities.invokeLater(() -&gt; &#123;                            label.setText(&quot;Status: Completed&quot;);                        &#125;);                    &#125;).start();                &#125;            &#125;);        &#125;);    &#125;&#125;\r\nEDT线程的注意事项和细节\r\n事件调度线程的单线程的\r\n始终记住事件调度线程是单线程的。\r\n这是因为\r\nSwing里面的各种组件类都不是线程安全的，这就意味着，如果有多个线程，那么同一个组件的方法可能会被多个线程同时调用，这会导致同步问题以及错误数据的发生。\r\n为了规避同步问题，以及降低整个Swing设计的复杂度，提高Swing的相应速度，Swing中的\r\n事件调度线程被设计成为了单线程模式，即只有一个线程在负责事件的响应工作。\r\nEDT 的启动\r\n在 Swing 应用程序启动时，EDT\r\n会自动启动。当调用SwingUtilities.invokeLater或SwingUtilities.invokeAndWait时，实际上是将任务提交到\r\nEDT 的事件队列中。\r\n任何GUI的请求都必须由EDT线程来处理\r\n保证线程安全\r\nSwing 组件不是线程安全的。如果在非 EDT 线程中执行 UI\r\n相关操作，会导致不可预测的行为。\r\n使用SwingUtilities.invokeLater(Runnable doRun)方法将 UI\r\n操作代码封装在Runnable对象中提交给 EDT 执行。\r\nSwingUtilities.invokeLater(() -&gt; &#123;    JLabel label = new JLabel(&quot;New Label&quot;);    frame.add(label);    frame.revalidate();    frame.repaint();&#125;);\r\nEDT线程将所有的GUI组件绘制和更新请求以及事件请求都放入了一个事件队列中。通过事件队列的机制，就可以将并发的GUI请求转化为事件队列，从而按顺序处理，这样有效的保护了线程安全，所以说，尽管大多数swing\r\nAPI本身不是线程安全的，但是swing通过EDT线程和事件队列机制实现了保障线程安全。\r\n同理，不建议从其他线程直接访问UI组件及其事件处理器，这会破坏线程安全的保障，可能会导致界面更新和绘制错误。\r\n在非EDT线程中通过invokeLater和invokeAndWait方法向EDT线程的事件队列添加GUI请求\r\n有的时候需要在一个非EDT线程中调用swing\r\nAPI来处理GUI请求，显然我们不能直接访问GUI组件，就需要使用SwingUtilities.invokeLater和SwingUtilities.invokeAndWait方法向\r\nEDT 的事件队列添加 GUI 请求。\r\n通过invokeLater和invoke方法，可以从一个非EDT线程中，将GUI请求添加到EDT线程的事件队列中去。\r\ninvokeLater是异步的，调用该方法时，该方法将GUI请求添加到事件队列中后直接返回。InvokeAndWait是同步的，调用该方法时，该方法将GUI请求添加到事件队列中后，会一直阻塞，直到该请求被完成后才会返回。\r\n但是在 EDT\r\n线程中调用invokeAndWait可能会导致死锁，例如，如果 EDT\r\n在等待另一个线程释放资源，而这个线程又在等待 EDT\r\n执行invokeAndWait提交的任务，就会形成死锁。而且invokeAndWait会阻塞调用线程，可能会影响程序的整体性能。因此，要避免在\r\nEDT 中调用invokeAndWait。\r\n下面简单介绍这两个方法：\r\nSwingUtilities.invokeLater\r\n\r\ninvokeLater方法用于将一个Runnable任务添加到\r\nEDT 的事件队列末尾。EDT\r\n会在处理完当前队列中的所有事件后，尽快执行这个任务。这意味着提交的任务不会立即执行，而是在\r\nEDT 有空闲时才会被处理。\r\n适用于那些对执行时机要求不是特别严格的 GUI 更新操作。\r\nimport javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class InvokeLaterExample &#123;    private static JLabel label;    public static void main(String[] args) &#123;        SwingUtilities.invokeLater(() -&gt; &#123;            JFrame frame = new JFrame(&quot;InvokeLater Example&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setSize(300, 200);            frame.setLayout(new FlowLayout());            JButton button = new JButton(&quot;Start Thread&quot;);            label = new JLabel(&quot;Initial Text&quot;);            button.addActionListener(new ActionListener() &#123;                @Override                public void actionPerformed(ActionEvent e) &#123;                    new Thread(() -&gt; &#123;                        // 模拟后台任务                        try &#123;                            // 模拟一个耗时 2 秒的任务                            Thread.sleep(2000);                        &#125; catch (InterruptedException ex) &#123;                            ex.printStackTrace();                        &#125;                        // 任务完成后，通过invokeLater方法将更新JLabel文本的操作添加到 EDT 的事件队列中                        SwingUtilities.invokeLater(() -&gt; &#123;                            label.setText(&quot;Text updated from background thread&quot;);                        &#125;);                    &#125;).start();                &#125;            &#125;);            frame.add(button);            frame.add(label);            frame.setVisible(true);        &#125;);    &#125;&#125;\r\n\r\nSwingUtilities.invokeAndWait\r\n\r\ninvokeAndWait方法同样用于将一个Runnable任务添加到\r\nEDT\r\n的事件队列，但与invokeLater不同的是，调用invokeAndWait的线程会阻塞，直到\r\nEDT\r\n执行完提交的任务。这确保了调用线程可以立即获取到任务执行的结果\r\n当非 EDT 线程需要依赖 GUI\r\n操作的结果继续执行后续逻辑时，适合使用invokeAndWait。\r\n```Java\r\nimport javax.swing.; import java.awt.; import\r\njava.awt.event.ActionEvent; import java.awt.event.ActionListener; import\r\njava.awt.event.WindowAdapter; import\r\njava.awt.event.WindowEvent;\r\n\r\npublic class InvokeAndWaitExample { private static JTextField\r\ntextField;\r\npublic static void main(String[] args) &#123;\r\n    SwingUtilities.invokeLater(() -&gt; &#123;\r\n        JFrame frame = new JFrame(&quot;InvokeAndWait Example&quot;);\r\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        frame.setSize(300, 200);\r\n        frame.setLayout(new FlowLayout());\r\n\r\n        JButton button = new JButton(&quot;Get Text&quot;);\r\n        textField = new JTextField(10);\r\n\r\n        button.addActionListener(new ActionListener() &#123;\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) &#123;\r\n                new Thread(() -&gt; &#123;\r\n                    try &#123;\r\n                        // 后台线程通过invokeAndWait获取JTextField中的文本\r\n                        String text = SwingUtilities.invokeAndWait(() -&gt; &#123;\r\n                            return textField.getText();\r\n                        &#125;);\r\n                        // 由于invokeAndWait会阻塞后台线程，直到 EDT 执行完获取文本的任务，所以可以确保获取到准确的文本值并显示在对话框中。\r\n                        JOptionPane.showMessageDialog(frame, &quot;Text from field: &quot; + text);\r\n                    &#125; catch (Exception ex) &#123;\r\n                        ex.printStackTrace();\r\n                    &#125;\r\n                &#125;).start();\r\n            &#125;\r\n        &#125;);\r\n\r\n        frame.add(textField);\r\n        frame.add(button);\r\n        frame.setVisible(true);\r\n    &#125;);\r\n&#125;\r\n避免在 EDT 中执行耗时操作\r\nEDT 负责处理所有的 Swing 事件和 UI 更新。\r\nEDT的事件队列的机制在保障了线程安全的同时，也引入了一个新的问题：假设事件队列中某一个GUI请求执行时间非常长，那么由于队列的特点，队列中的后续GUI请求都会被阻塞，导致界面无法响应用户输入，出现界面冻结的情况。\r\n考虑到用户体验性，应使用独立的任务线程来执行耗时计算或输入输出密集型任务\r\n所以，将耗时操作放在任务线程中执行，在任务线程完成任务后，如果需要更新\r\nUI，再通过SwingUtilities.invokeLater将更新操作提交到\r\nEDT。\r\n调试 EDT 相关问题\r\n检测跨线程操作：使用工具如 Java VisualVM 或 Eclipse\r\n的调试工具，可以检测是否存在在非 EDT 线程中访问 Swing 组件的情况\r\n监控 EDT 性能：如果怀疑 EDT\r\n出现性能问题（如界面响应缓慢），可以通过分析事件处理代码的执行时间，查找是否存在耗时操作在\r\nEDT 中执行。可以使用简单的日志记录或性能分析工具（ YourKit Java\r\nProfiler）来辅助诊断。\r\n\r\n上一篇：Java难绷知识03–异常处理中的finally块\r\n下一篇：Java难绷知识06——Scanner等输出的细节\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识04--异常处理中的finally块","url":"/posts/683.html","content":"Java难绷知识04——异常处理中的finally块\r\n前情提要：该文章是个人花的时间最长，查询资料最多，可能是有关finally块的最长文章，希望大家能看下去\r\n一些前言\r\n在Java中，异常处理机制是程序设计中至关重要的一部分。它允许程序员在程序运行时捕获并处理错误，防止程序因为异常情况而突然崩溃。\r\ntry - catch -\r\nfinally结构是异常处理的核心部分。而finally块虽非必需，但为什么finally是异常处理中的最后一道防线\r\n我的想法主要认为finally的必要关键之处是能够确保代码健壮性。\r\n而且finally块中存在许多深入理解的地方，在这篇文章我将依旧侧重于finally在异常处理中的细节\r\n\r\ntry - catch -\r\nfinally结构及其基础内容\r\ntry - catch -\r\nfinally结构是Java异常处理的核心部分。它允许你在代码出现错误时进行适当的处理，而不是让程序崩溃。\r\n在这里只对其简单阐述，本篇文章侧重点是finally\r\n基本结构 try &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType e) &#123;    // 异常处理代码&#125; finally &#123;    // 无论是否发生异常，都会执行的代码&#125;\r\ntry语句\r\n作用：try语句块用于包含可能抛出异常的代码\r\n它是异常监控的起始点，我们需要将可能出现问题的代码段放在 try\r\n块内。\r\n其中：\r\n一个 try 块后必须至少跟一个 catch 块或者一个 finally\r\n块。不能单独存在 try 块。\r\ntry\r\n块内的代码一旦抛出异常，异常抛出点之后的代码将不会继续执行，程序流程会立即跳转到相应的\r\ncatch 块\r\n\r\ncatch语句:\r\n作用：catch 块用于捕获并处理 try 块中抛出的异常。每个 catch\r\n块指定了它能够捕获的异常类型。\r\n在 catch\r\n块内，你可以对捕获到的异常进行处理，例如记录日志、向用户显示更友好的错误信息、进行恢复操作等。捕获到的异常对象可以通过\r\ncatch 块的参数（如 e）来访问，通过这个对象可以获取异常的详细信息\r\n其中：\r\ncatch 块会按顺序检查，只有与抛出异常类型匹配（包括子类类型匹配）的 catch\r\n块才会被执行。\r\n示例代码如下： try &#123;    // 有一些语句抛出了 IOException &#125; catch (IOException e)) &#123;    // 那么 catch (IOException e) 块会先被执行    // 如果没有 catch (IOException e)，才会执行 catch (Exception e)&#125; catch (Exception e) &#123;    &#125;\r\n多个 catch 块顺序：在编写多个 catch 块时，子类异常的 catch\r\n块必须放在父类异常的 catch\r\n块之前。否则，编译器会报错，因为子类异常永远无法被捕获。例如，以下代码会报错：\r\ntry &#123;    // 有一些语句抛出了 IOException&#125; catch (Exception e) &#123;   &#125; catch (IOException e) &#123;    // 编译器会报错，因为子类异常永远无法被捕获&#125; catch语句可以有多个\r\n\r\nfinally语句\r\nfinally语句块是可选的\r\n无论try块是否抛出异常，finally块代码通常都会执行。\r\n它允许程序员在程序运行时捕获并处理错误，防止程序因为异常情况而突然崩溃。\r\n如下代码片段验证finally的执行情况 try &#123;    System.out.println(&quot;Inside try block&quot;);&#125; catch (Exception e) &#123;    System.out.println(&quot;Exception caught&quot;);&#125; finally &#123;    System.out.println(&quot;Finally block always executes&quot;);&#125;\r\n它主要用于放置必须执行的清理代码，如关闭文件流、释放数据库连接等。\r\nfinally块中的代码总是在try和catch执行之后、方法返回之前执行。即使在try或catch中出现了return语句，finally块依然会执行。\r\n\r\nfinally的基础知识\r\nfinally块的作用\r\n\r\n确保资源释放：\r\n\r\nfinally 块最主要的作用是确保无论 try 块中是否发生异常，也无论\r\ncatch\r\n块是否捕获到异常，特定的代码段（通常用于资源清理和关闭资源）都会被执行。这对于需要手动管理资源的情况（如文件流、数据库连接、网络连接等）至关重要，避免资源泄漏。\r\nfinally\r\n块常用于确保文件流、数据库连接、网络连接等资源的正确关闭。在 Java\r\n中，这些资源若不及时关闭，可能导致资源泄漏，长时间运行后会耗尽系统资源，使程序性能下降甚至崩溃。\r\n我认为这是finally块在异常中被设计出来的初衷，因为我们也不知道也需要一个异常后被正确处理的情况。\r\n虽然现在，大家使用更多的是使用try-with-resources语法，因为它能够自动管理资源，减少错误发生的概率。省事还高级。\r\n\r\n\r\n\r\n\r\n异常后执行清理工作：\r\n\r\nfinally块确保程序不会因为异常中断而漏掉必要的清理操作。这样可以避免资源泄漏或系统状态不一致的问题。\r\n其中，在涉及多层资源嵌套的场景中，finally\r\n块的作用更为突出，多层资源之间的关系密切复杂，在finally块中去有条理的解决即友好又省事。因为finally\r\n块确保了处理是成功还是因异常回滚，相关资源都能被正确释放。\r\n\r\n\r\n\r\n\r\n对某些操作的保证：finally 块会影响 return\r\n语句的执行流程，确保在返回值确定前执行必要的清理操作。即使try或catch语句中发生了return语句，finally块的代码依然会执行，保证了关键代码的执行。我们可以利用这个来处理异常发生后的操作。\r\n   public class FinallyWithReturnExample &#123;   public static int test() &#123;       try &#123;           // 当 try 块执行到 return 1 时，会先暂存返回值 1,然后执行 finally 块中的代码,最后再返回暂存的 1           return 1;       &#125; finally &#123;           // finally 块在 return 语句真正返回前执行,在有 return 的情况下，也能保证清理等必要收尾操作的执行，前提是你finally块中没有retrun语句           System.out.println(&quot;Finally block in test method&quot;);       &#125;   &#125;   \tpublic static void main(String[] args) &#123;       \tint result = test();       \tSystem.out.println(&quot;Result: &quot; + result);   \t&#125;&#125;\r\n\r\n\r\n\r\n维护程序状态一致性\r\n\r\n确保部分操作完成：在某些业务逻辑中，部分操作完成后需要执行特定的收尾操作以维护程序状态的一致性。\r\n恢复中间状态：在一些复杂的业务流程中，程序可能会在执行过程中进入临时的中间状态。finally\r\n块可用于在异常发生时恢复到之前的稳定状态。\r\n   public class OrderProcessingExample &#123;   private static String orderStatus = &quot;INITIAL&quot;;   public static void processOrder() &#123;   \t// try 块尝试处理订单并更新订单状态       try &#123;           orderStatus = &quot;PROCESSING&quot;;           // 模拟订单处理的复杂逻辑，可能抛出异常           if (Math.random() &gt; 0.5) &#123;               throw new RuntimeException(&quot;Order processing failed&quot;);           &#125;           orderStatus = &quot;COMPLETED&quot;;       &#125; catch (Exception e) &#123;           e.printStackTrace();       // finally 块会检查订单状态       &#125; finally &#123;       \t// 如果不是 COMPLETED，则将其恢复到 INITIAL 状态       \t// 保证程序状态的一致性和准确性。           if (!&quot;COMPLETED&quot;.equals(orderStatus)) &#123;               orderStatus = &quot;INITIAL&quot;;           &#125;           System.out.println(&quot;Final order status: &quot; + orderStatus);       &#125;   &#125;   \tpublic static void main(String[] args) &#123;       \tprocessOrder();   \t&#125;&#125;\r\n增强代码的健壮性与可维护性：finally\r\n块为异常处理提供了一个统一的出口，无论 try\r\n块中发生何种异常，都能在此进行统一的处理逻辑。这使得代码结构更加清晰，易于理解和维护。而且这样能够大量的减少代码重复。\r\n\r\n\r\n\r\n所以这就是为什么要有异常捕获结构中要有finally块。 \r\nfinally关键字的细节之处\r\n\r\n有异常但未被捕获时，finally块的执行情况\r\nfinally块的执行与异常是否被捕获和处理是相对独立的。即使异常未被捕获，finally块也会执行其代码。这确保了无论异常如何传播，finally块中的资源清理或其他关键代码都能得到执行。\r\n这里也可以看出finally块的必定会被执行的一个性质\r\nfinally块执行完毕后，向外传播的异常类型和try块中抛出的异常类型一致，不会因为finally块的存在而改变。但是，如果finally块中的代码抛出了异常，它会覆盖try块或catch块中已经抛出的异常\r\n例如，如果try块抛出IOException，即使经过finally块的执行，向外传播的依然是IOException。\r\n示例代码如下 public class FinallyThrowsExceptionExample &#123;    public static void main(String[] args) &#123;        try &#123;            methodThatThrowsException();        &#125; catch (Exception e) &#123;            System.out.println(&quot;Caught in main: &quot; + e.getMessage());        &#125;    &#125;\t\t// main方法捕获到的异常信息是Caught in main: Exception thrown in finally    public static void methodThatThrowsException() &#123;        try &#123;        \t// 原始try块中的异常被覆盖            throw new RuntimeException(&quot;Exception thrown in inner try&quot;);        &#125; finally &#123;            throw new RuntimeException(&quot;Exception thrown in finally&quot;);        &#125;    &#125;&#125;\r\n\r\n与 return 语句的交互\r\n首先，在 finally\r\n代码块中改变返回值并不会改变最后返回的内容，而且finally中的语句一定会执行\r\n\r\n1.当 try 代码块和 catch 代码块中有 return 语句时，finally\r\n仍然会被执行。且 try 代码块或 catch 代码块中的 return\r\n语句执行之前，都会先执行 finally 语句\r\npublic class TryReturnFinallyExample &#123;    public static int test() &#123;        try &#123;        \tint result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;        \treturn 2;        &#125; finally &#123;            System.out.println(&quot;Finally block in test method&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n\r\n2.finally 块中的代码可以访问和修改 try 块和 catch\r\n块中定义的局部变量，但这种修改不会影响 return 语句返回的值\r\npublic class CatchReturnFinallyVariableExample &#123;    public static int test() &#123;        try &#123;            int result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;            int num = 2;            return num;        &#125; finally &#123;        \t// finally 块将 num 修改为 3            num = 3;        &#125;    &#125;\t\t// 但 return 语句返回的还是 catch 块中 return 语句执行时 num 的值    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n\r\n如果此时，finally 块本身也有 return\r\n语句，会以一种较为复杂的方式处理局部变量\r\ntry和catch块中的局部变量：即便finally块可以访问并修改try和catch块中定义的局部变量，由于finally块中的return会主导返回值，所以这种修改对最终返回值的影响也会被finally块的return逻辑所掩盖。\r\n当在try块暂存return的结果时候，如果finally块修改了局部变量影响了返回值，但本质是finally块的return起了决定性作用。\r\n示例代码 public class FinallyModifyLocalVar &#123;    public static int test() &#123;        int num = 1;        try &#123;            return num;        &#125; finally &#123;            num = 3;            return num;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n\r\n\r\n如果 finally 块中有 return 语句，它会覆盖 try 或 catch 块中的 return\r\n语句。这意味着无论 try 或 catch 块中原本打算返回什么值，最终都会被\r\nfinally 块中的 return 值取代。\r\n\r\npublic class FinallyReturnOverrideExample &#123;    public static int test() &#123;        try &#123;        \t// 尽管 try 块原本要返回 1            return 1;        &#125; catch (Exception e) &#123;            return 2;        &#125; finally &#123;        \t// 但由于 finally 块中有 return 3，最终返回的值是 3。            return 3;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n所以说finally块中最好不要包含 return\r\n语句，要不然程序会提前退出,，而且使用 finally 块中的 return\r\n语句会使代码的逻辑变得混乱，因为它打破了正常的 try - catch - finally\r\n异常处理流程，使得代码的返回值不依赖于 try 或 catch\r\n块中的逻辑。可读性和可维护性会瞬间爆炸\r\n\r\n\r\n异常情况下的返回：如果try块抛出异常，catch块捕获并处理异常，finally块的return语句依然会生效，覆盖catch块中的return\r\n\r\npublic class FinallyReturnWithException &#123;    public static int test() &#123;        try &#123;            int result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;            return 2;        &#125; finally &#123;            return 3;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\r\n在这里强调一下，如果出现了异常未捕获的情况，就是try块抛出异常且未被catch块捕获，那么finally块执行完毕后，finally块中的return会阻止异常继续传播，并且返回finally块中的值。（这种情况可能会隐藏程序中的异常，导致调试难度从Galgme变成黑暗之魂，别用）\r\n\r\n异常屏蔽\r\n首先要知道一个前提：\r\ntry 块抛出异常且 catch 块未捕获：当 try 块抛出异常，而 catch\r\n块没有捕获该异常时，finally 块依然会执行。执行完 finally\r\n块后，异常会继续向外层传递。\r\npublic class ExceptionFinallyInteractionExample &#123;    public static void test() &#123;        try &#123;            throw new RuntimeException(&quot;Exception in try block&quot;);        &#125; finally &#123;            System.out.println(&quot;Finally block in test method&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            test();        &#125; catch (RuntimeException e) &#123;            System.out.println(&quot;Caught in main method: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n\r\n如果finally块中的代码抛出了异常，它会覆盖try块或catch块中已经抛出的异常。\r\n所以我们应该尽量避免在finally块中抛出异常，因为会覆盖异常本身的情况，导致调试出现歧义\r\npublic class FinallyThrowsExceptionExample &#123;    public static void test() &#123;        try &#123;            throw new RuntimeException(&quot;Exception in try block&quot;);        &#125; finally &#123;            throw new RuntimeException(&quot;Exception in finally block&quot;);        &#125;    &#125;\t\t// main 方法捕获到的是 finally 块抛出的异常信息 Exception in finally block    public static void main(String[] args) &#123;        try &#123;            test();        &#125; catch (RuntimeException e) &#123;            System.out.println(&quot;Caught in main method: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n\r\nfinally中可能抛出异常的情况的处理\r\n&lt; 引用自\r\nhttps://blog.csdn.net/qq_44861675/article/details/106353369\r\n本人作补充\r\n有这样一段代码 package Stream_IntOut;import java.io.*;/** * 使用缓冲区输入流和缓冲区输出流实现复制文件的功能。 * 并简单处理IO异常 * */public class Practice3_BufferedWriter_BufferedReader_Copy &#123;    public static void main(String[]args)&#123;        FileWriter fw = null;        FileReader fr = null;        BufferedWriter bufw = null;        BufferedReader bufr = null;        try&#123;            fw = new FileWriter(&quot;E:\\\\file_copy2.txt&quot;);            fr = new FileReader(&quot;E:\\\\file.txt&quot;);            bufw = new BufferedWriter(fw);            bufr = new BufferedReader(fr);            String line;            while((line=bufr.readLine())!=null)&#123;                bufw.write(line);                //写入换行符                bufw.newLine();                //刷新一次流对象                bufw.flush();            &#125;        &#125;catch(IOException e)&#123;            e.printStackTrace();        &#125;finally &#123;            if(fr!=null)                try&#123;                    assert bufr != null;                    bufr.close();            &#125;catch (IOException e)&#123;                    throw new RuntimeException(&quot;无法关闭fr流对象&quot;);                &#125;            if(fw!=null)                try&#123;                    assert bufw != null;                    bufw.close();                &#125;catch (IOException e)&#123;                    throw new RuntimeException(&quot;无法关闭fw流对象&quot;);                &#125;        &#125;    &#125;&#125;\r\n我们可以从IDEA的提示里边看到一些东西: throw inside “finally”\r\nblock\r\n也就是说，finally块里边抛出异常是不建议的，java异常语句中的finally块通常用来做资源释放操作，finally块和普通代码块一样，无法同时使用return语句和throw语句，因为无法通过编译\r\n为什么不被建议？\r\nfinally块中的throw语句会覆盖try和catch语句中的异常\r\n实例代码 package 面试题;public class FinallyAndReturnAndThrow3 &#123;    public static void main(String[]args)&#123;        displayTest();    &#125;    private static void displayTest() &#123;        try&#123;            System.out.println(2/0);//异常发生        &#125;catch (Exception e)&#123;            System.out.println(&quot;displayTest&#x27;s catch&quot;);            throw new RuntimeException(&quot;除数为0&quot;);        &#125;finally &#123;            System.out.println(&quot;displayTest&#x27;s finally&quot;);            throw new RuntimeException(&quot;俺会覆盖catch的异常&quot;);        &#125;    &#125;&#125;\r\n在结果中，返回的异常是finally里面的，catch的异常并没有被抛出。同样的try中捕抓的异常也会被掩盖。\r\n在Java核心技术书中，作者建议在finally块中尽量不要使用会抛出异常的资源回收语句。\r\n那么在我们使用IO流时，常常在finally使用到throw，那该如何解决呢？\r\n其中一个方法，就是接下来说的，在finally块中使用try-catch块，进行多层嵌套的try\r\n- catch - finally情况\r\n但其实，大家更常用的方法就是 使用 Java 7\r\n的try-with-resources语句，在关闭资源时抛出的异常会被添加为原来异常的被抑制异常并展示，不会掩盖try块中的异常。\r\n\r\n多层嵌套的try - catch -\r\nfinally情况\r\n异常捕获顺序\r\n\r\n内层优先：当异常发生时，Java\r\n首先会尝试在最内层的try块对应的catch块中捕获异常。如果内层try块没有匹配的catch块，异常会向外层try块传播，寻找匹配的catch块。\r\n也需要遵循子类优先：在编写catch块时，捕获子类异常的catch块应该放在其父类异常的catch块之前。否则，子类异常的catch块永远不会被执行，编译器会报错。\r\n\r\nfinally块的执行顺序\r\n\r\n内层优先：无论异常是否发生，内层try块的finally块总是在内层try块结束时（正常结束或因异常结束）立即执行，然后才会执行外层try块的finally块。\r\n异常传递：如果内层try块的finally块抛出异常，这个异常会向外层传播，可能会掩盖内层try块中原本抛出的异常。为避免这种情况，可以在内层finally块中捕获并处理异常，或者使用辅助变量记录内层try块的异常，同时处理内层finally块抛出的异常。\r\n\r\n注意资源的关闭顺序，永远是在多层嵌套中需要注意的地方\r\n所以我建议使用try - with - resources语句，它会自动管理资源的关闭，并确保每个资源只被关闭一次。\r\n示例代码\r\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class NestedTryCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            try &#123;                InputStream inputStream = new FileInputStream(&quot;example.txt&quot;);                try &#123;                    int data;                    while ((data = inputStream.read())!= -1) &#123;                        System.out.print((char) data);                    &#125;                &#125; catch (IOException e) &#123;                    System.out.println(&quot;读取文件时出错: &quot; + e.getMessage());                &#125; finally &#123;                    try &#123;                        if (inputStream!= null) &#123;                            inputStream.close();                        &#125;                    &#125; catch (IOException e) &#123;                        System.out.println(&quot;关闭文件时出错: &quot; + e.getMessage());                    &#125;                &#125;            &#125; catch (FileNotFoundException e) &#123;                System.out.println(&quot;文件未找到: &quot; + e.getMessage());            &#125;        &#125; catch (Exception e) &#123;            System.out.println(&quot;发生其他异常: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n\r\n上一篇：Java难绷知识03–包装器类及其自动装箱和拆箱\r\n下一篇：Java难绷知识05——Swing中的事件调度线程和资源释放\r\n\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识03--包装器类及其自动装箱和拆箱","url":"/posts/24697.html","content":"Java难绷知识03——包装器类及其自动装箱和拆箱\r\n本篇文章和之前的倾向稍微有些不同，这篇文章我不仅要讨论一些容易头疼的细节，而且我打算尝试讨论一下如何理解Java中的包装类以及自动拆箱和自动装箱\r\n\r\n自动装箱（Autoboxing）和自动拆箱（Unboxing）是在基本数据类型和它们对应的包装类之间“转换”的一个包装过程，其中\r\n装箱：基本数据类型包装成对应的包装类\r\n拆箱：包装类拆包装成基本数据类型\r\n自动拆装箱下，上述转换在代码中是隐式的，由编译器自动完成。 \r\n为什么Java要引入包装类，来包装起来数据类型\r\n其实很简单，原因就是因为：Java的面向对象语言，一切面向对象\r\n为了让基本类型也具有对象的特征，Java引入了包装器类，使得它具有了对象的性质\r\n\r\n统一数据类型处理\r\n基本数据类型不是对象，无法使用对象的特性,包装类将基本数据类型包装成对象，使其能够融入面向对象的编程体系\r\n在集合框架中，如ArrayList、HashMap等，它们只能存储对象类型。如果要将基本数据类型存储到这些集合中，就需要使用对应的包装类。\r\n\r\n使其支持多态\r\n包装类使得基本数据类型也能参与多态的实现。通过向上转型，不同的包装类对象可以被统一处理。\r\n例如，所有的包装类都继承自Number类（Boolean除外），可以在需要Number类型的地方使用Integer、Double等包装类对象，来满足Number的特别支持，也就是满足多态\r\n\r\n使其支持泛型和反射机制\r\n支持泛型\r\n在泛型代码中，类型参数必须是引用类型，不能是基本数据类型。这与泛型的实现原理有关，在编译后，泛型类型信息会被擦除，替换为其限定的类型，所以基本数据类型无法直接参与这种类型擦除机制。引入了包装器类\r\n用ArrayList存储整数时使用泛型作为例子 import java.util.ArrayList;import java.util.List;public class GenericWithWrapper &#123;    public static void main(String[] args) &#123;        // 使用Integer包装类在泛型中存储整数        List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();        intList.add(10);        int num = intList.get(0); // 自动拆箱    &#125;&#125;\r\n有兴趣可以试试String丢进去会咋样瞬间爆炸\r\n\r\n支持反射\r\n反射允许程序在运行时获取和操作类的信息\r\n那你基本数据类型就没法支持了，众所周知反射在java里面有多有用，所以引入了包装器类\r\n包装类为基本数据类型提供了对应的类对象，使得可以通过反射操作基本数据类型\r\n包装类在反射机制中为基本数据类型提供对象层面的操作能力\r\n通过Class.forName(“java.lang.Integer”)获取Integer包装类的Class对象，然后利用反射机制调用其构造函数创建Integer对象，同样，也可以通过反射调用包装类的方法。\r\npublic class ReflectionInWrapper &#123;    public static void main(String[] args) &#123;        try &#123;            // 获取Integer类的Class对象            Class&lt;?&gt; wrapperClass = Class.forName(&quot;java.lang.Integer&quot;);            // 通过反射调用构造函数创建对象            Object instance = wrapperClass.getConstructor(int.class).newInstance(10);            System.out.println(instance);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n基本数据类型及其细节\r\n为什么还要重新讲一下8\r\n种基本数据类型，很简单，因为他们是Java语言的基础，并且在自动装箱（autoboxing）和自动拆箱（unboxing）机制中扮演着关键角色（毕竟进行的是基本数据类型和引用数据类型的“转换”）\r\n #### 不厌其烦的八种基本数据类型\r\nJava是一种强类型语言，第一次变量赋值称为变量的初始化 8\r\n种基本数据类型可以分类为如下三类： 字符类型 char 布尔类型 boolean\r\n数值类型 byte、short、int、long、float、double \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n基本数据类型\r\n所占字节数（大小）\r\n备注\r\n\r\n\r\n\r\n\r\nbyte\r\n1字节\r\n表示范围 -128 到 127\r\n\r\n\r\nshort\r\n2字节\r\n表示范围 -32,768 到 32,767\r\n\r\n\r\nint\r\n4字节\r\n范围是-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)\r\n\r\n\r\nlong\r\n8字节\r\n范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807\r\n(2^63-1)\r\n\r\n\r\nfloat\r\n4字节\r\n大约 7 位有效数字\r\n\r\n\r\ndouble\r\n8字节\r\n大约 15 - 17 位有效数字\r\n\r\n\r\nchar\r\n2字节\r\n采用 Unicode 编码\r\n\r\n\r\nboolean\r\n通常占用 1 位\r\n\r\n\r\n\r\n\r\n\r\n类型转换问题（向上和向下取型）\r\n为什么上面我还要列个表格，就是要注意，在进行自动拆装箱和类型转换时，要注意数据的范围和精度问题，可能会隐藏一些类型转换错误。\r\n在 Java\r\n的基本数据类型中，类型转换分为自动类型转换（向上转型）和强制类型转换（向下转型）。\r\n自动类型转换（向上转型）：当把一个取值范围小的类型赋值给取值范围大的类型时，会自动进行转换。\r\n强制类型转换（向下转型）：当把一个取值范围大的类型赋值给取值范围小的类型时，需要进行强制类型转换，这可能会导致数据丢失。\r\n当基本数据类型自动装箱为包装器类时，也遵循自动类型转换的规则，转换的是包装器类所继承的类，例如，byte\r\n装箱为 Byte，Byte 可以自动向上转型为 Number（因为 Byte 继承自\r\nNumber）。\r\n当从包装器类自动拆箱为基本数据类型时，如果要进行向下转型，同样需要强制类型转换。\r\n跨类型的包装器转换：对于数值类型的包装器类，有时需要进行跨类型的转换。例如，将\r\nInteger 转换为 Double。这需要先拆箱再装箱。\r\nInteger intValue = 10;// 先拆箱为int，再装箱为DoubleDouble doubleValueFromInt = new Double(intValue); \r\nboolean 类型及其包装类 Boolean\r\n与其他基本数据类型和包装类之间不存在类型转换关系。boolean 类型只有 true\r\n和 false 两个值，不能转换为数值类型或其他类型。\r\nchar 类型及其包装类 Character 可以与数值类型进行一些转换。 char\r\n本质上是一个无符号的 16 位整数，所以 char 可以自动转换为 int 类型。\r\nCharacter charValue = &#x27;A&#x27;;int intValueFromChar = charValue; // 自动装箱后，Character可自动转换为int\r\n\r\n有关溢出\r\n在基本数据类型下，进行同类型数值运算的时候溢出并不会抛异常，也没有任何提示，需要注意\r\n包装器类下溢出的情况代码 public class WrapperOverflowExample &#123;    public static void main(String[] args) &#123;        Integer maxInt = Integer.MAX_VALUE;        // 尝试增加1        Integer result = maxInt + 1;        System.out.println(&quot;运算结果: &quot; + result);    &#125;&#125; 以上例而言，Integer.MAX_VALUE 是\r\nint 类型能表示的最大值。当对 maxInt 加 1 时，会发生溢出，结果变为\r\nInteger.MIN_VALUE，这和直接使用 int 基本数据类型进行运算溢出的情况一致。\r\n所以处理极大数的时候，我们偏向使用 BigInteger 和 BigDecimal 类\r\nJava中的数值类型不存在无符号的，它们的取值范围是固定的 \r\n伏笔\r\n实际上，Java中还存在另一种基本类型void，它也有对应的包装类java.lang.Void，不过他很特殊，我们无法直接对它们进行操作，这个在下面我会特意说\r\n\r\n基本数据类型及其包装类\r\n八种基本数据类型都分别都有对应的包装类，如下表\r\n\r\n\r\n\r\n基本数据类型\r\n包装类\r\n缓存值范围\r\n\r\n\r\n\r\n\r\nboolean\r\njava.lang.Boolean\r\ntrue和false\r\n\r\n\r\nbyte\r\njava.lang.Byte\r\n-128～127\r\n\r\n\r\nchar\r\njava.lang.Character\r\n0 ~ 127\r\n\r\n\r\nfloat\r\njava.lang.Float\r\n没有缓存\r\n\r\n\r\nint\r\njava.lang.Integer\r\n-128～127\r\n\r\n\r\nlong\r\njava.lang.Long\r\n-128～127\r\n\r\n\r\nshort\r\njava.lang.Short\r\n-128～127\r\n\r\n\r\ndouble\r\njava.lang.Double\r\n没有缓存\r\n\r\n\r\n\r\n有关记忆：在这八个类名中，除了Integer和Character类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。\r\n\r\n包装类的方法与常量\r\n首先，使用和声明包装器类需要实例化，因为包装器类对象，需要进行实例化，才能对变量数据进行处理。\r\n包装类提供了丰富的方法和常量方便对基本数据类型进行操作\r\n方法\r\n构造方法（在 Java 9 及之后不推荐使用） Integer(int value)Integer i = new Integer(1000);\r\n\r\n因为我们更多使用静态工厂方法：（也就是valueOf进行装箱） 例如\r\nvalueOf(byte b)：返回一个表示指定 byte 值的 Byte 实例。例如：Byte byteObj = Byte.valueOf((byte)5);valueOf(String s)：返回表示字符串指定值的相应包装类实例，其值由字符串参数解析得到例如：Integer intFromString = Integer.valueOf(&quot;123&quot;);，但字符串必须是合法的数值表示，否则会抛出 NumberFormatException。\r\n\r\n解析方法：\r\nparseXxx()\r\n该方法用于将字符串解析为对应的基本数据类型。字符串必须是合法的数值表示形式，否则会抛出\r\nNumberFormatException int num = Integer.parseInt(&quot;123&quot;);double d = Double.parseDouble(&quot;3.14&quot;);\r\n特殊的一点，在parseBoolean(String s)，将字符串参数解析为 boolean\r\n值时候\r\n如果输入的字符串不是 “true”（不区分大小写），该方法将返回 false。\r\n这种设计使得 Boolean.parseBoolean\r\n方法在处理非标准布尔字符串输入时，有一个明确且一致的返回值，不会抛出异常，而是统一返回\r\nfalse。\r\n\r\n转换方法：\r\nXxxValue()\r\n该方法以Xxx类型返回输入的Byte、Short、Integer、Long、Float、Double\r\n的值\r\n例如： shortValue()以 short 类型返回此 Short、Integer、Long、Float、Double 的值。Long l = 20L; short s = l.shortValue();\r\n其中在Character中，还有一些字符判断方法和字符转换方法，看一下就会用，也没啥特殊之处需要注意，就不在这里说了。\r\n\r\n常量\r\nMIN_VALUE 和 MAX_VALUE\r\n每个数值型包装类和Character都有这两个常量，分别表示该类型能够表示的最大值和最小值。\r\n例如，Integer.MAX_VALUE 表示 int\r\n类型能表示的最大整数值，Double.MIN_VALUE 表示 double\r\n类型能表示的最小正非零值（接近零）。\r\n在Character中，Character.MIN_VALUE 表示 char 类型能表示的最小 Unicode\r\n代码点（‘000’），Character.MAX_VALUE 表示 char 类型能表示的最大 Unicode\r\n代码点（‘’）。\r\n在Character中，Character.MIN_VALUE和Character.MAX_VALUE分别表示所缓存的最大值\r\n\r\nTRUE 和 FALSE\r\n两个常量分别表示布尔值 true 和 false。它们是 Boolean\r\n类的静态成员，用于获取对应的 Boolean 对象。\r\n在使用 Boolean 对象时，推荐使用这两个常量，而不是通过 new\r\nBoolean(true) 或 new Boolean(false)\r\n创建对象，因为后者会创建新的对象实例，可能会引起问题 \r\n基本数据类型和包装类需要注意的问题\r\n缓存机制：部分包装类（如\r\nInteger、Byte、Short、Long、Character）在一定范围内会缓存对象。就拿Integer来说，Integer缓存了\r\n-128 到 127 之间的整数。这意味着在这个范围内，相同值的对象是共享的。\r\nInteger a = 100; Integer b = 100; System.out.println(a == b); // 输出 true，因为 a 和 b 引用的是缓存中的同一个对象Integer c = 200; Integer d = 200; System.out.println(c == d); // 输出 false，因为 200 超出缓存范围，c 和 d 是不同的对象\r\n\r\n自动拆装箱\r\n如何理解自动拆装箱\r\n从用途上理解其实就是下述这样，自动装箱就是将基本数据类型自动转换为封装类型，自动拆箱是将封装类型自动转换为基本数据类型。\r\n但是其实编译器的自动执行情况如下：\r\n自动装箱，相当于Java编译器替我们执行了 Integer.valueOf(XXX);\r\n自动拆箱，相当于Java编译器替我们执行了Integer.intValue(XXX)\r\n/ 自动装箱 Autoboxing// Xxx.valueOf(xxx i)// 编译器会转成 Integer.valueOf(int i) 进行自动装箱Integer i = 100;Integer j = Integer.valueOf(100);System.out.println(&quot;i == j --&gt; &quot; + (i == j));j = Integer.valueOf(i);System.out.println(&quot;i == j --&gt; &quot; + (i == j));// 直接创建包装器类型的对象Integer k = new Integer(100);System.out.println(&quot;i == k --&gt; &quot; + (i == k));// 拆箱 Unboxing// Xxx..xxxValue()// 编译器会转成 Integer.intValue() 进行拆箱int m = i;System.out.println(&quot;i == m --&gt; &quot; + (i == m));\r\n\r\n参考：https://www.cnblogs.com/wpbxin/p/14311010.html\r\n\r\n\r\n什么时候会发生自动拆装箱\r\n 赋值操作 = ： 原始数据类型与对应包装器类型之间的相互赋值操作 =\r\n，会自动装箱(拆箱)\r\n注意：注：原始数据类型赋值给 Long ，都需要明确标出是长整型\r\n\r\n作为方法参数：\r\n例如包装器类型.equals(原始数据类型)，原始数据类型会自动装箱。\r\nInteger.equals(1)\r\n如果方法参数接收的是原始数据类型，则传入包装器类型时会拆箱；如果方法参数接收的是包装器类型，则传入原始数据类型时会自动装箱。\r\n作为方法返回值：\r\n方法返回值是包装器类型：如果返回的是原始数据类型，会自动装箱\r\n方法返回值是原始数据类型：如果返回的是包装器类型，会拆箱。\r\n\r\n算术运算和比较运算:\r\n在对包装类对象进行算术运算（如加、减、乘、除等）或比较运算（如\r\n==、&gt;、&lt;\r\n等）时，会发生自动拆箱。因为这些运算符通常只适用于基本数据类型。\r\nInteger num3 = 10;Integer num4 = 20;int sum = num3 + num4; // num3 和 num4 自动拆箱为基本数据类型 int 后进行加法运算boolean isGreater = num3 &gt; num4; // num3 和 num4 自动拆箱为基本数据类型 int 后进行比较运算\r\n\r\n集合操作:\r\n当向集合（如 List、Set、Map\r\n等）中添加基本数据类型时，会发生自动装箱，因为集合只能存储对象。\r\n当从集合中获取元素并赋值给基本数据类型变量时，会发生自动拆箱。\r\nimport java.util.ArrayList;import java.util.List;public class CollectionExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int num = 5;        list.add(num);         // 这里将 int 类型的 num 自动装箱为 Integer 后添加到 list 中        int retrievedNum = list.get(0);         // 这里将从 list 中获取的 Integer 对象自动拆箱为 int 类型并赋给 retrievedNum    &#125;&#125;\r\n\r\n一定要注意Java自动拆装箱的类型敏感问题，空指针问题和性能敏感问题\r\n\r\n自动拆装箱需要注意的问题和细节\r\n\r\n空指针异常：\r\n当对一个 null 值的包装类对象进行自动拆箱时，会抛出\r\nNullPointerException; 因为自动拆箱实际是调用包装类对象的 xxxValue\r\n方法，null 对象无法调用该方法。\r\n\r\n装箱拆箱有开销：\r\n自动装箱和拆箱过程涉及对象的创建与销毁，相较于直接操作基本数据类型，会带来额外的性能开销。在性能敏感的场景（如频繁的循环操作）中，应尽量减少自动拆装箱的使用。\r\n可以用如下代码了解自动拆装箱的性能开销 long startTime = System.currentTimeMillis();for (int i = 0; i &lt; 1000000; i++) &#123;    Integer wrapper = i;     int primitive = wrapper; &#125;long endTime = System.currentTimeMillis();System.out.println(&quot;Time taken: &quot; + (endTime - startTime) + &quot; ms&quot;);\r\n\r\n方法重载与自动拆装箱：\r\n在方法重载的情况下，自动拆装箱可能导致选择错误的方法。\r\n例如，当有一个方法接受 int 参数，另一个方法接受 Integer\r\n参数时，传递一个 Integer 对象可能会调用接受 Integer\r\n参数的方法，而不是自动拆箱后调用接受 int 参数的方法。\r\npublic class AutoBoxingOverload &#123;    public static void print(Object obj) &#123;        System.out.println(&quot;Object method: &quot; + obj);    &#125;    public static void print(int num) &#123;        System.out.println(&quot;int method: &quot; + num);    &#125;    public static void main(String[] args) &#123;        Integer i = 10;        print(i);         // 调用 print(Object obj) 方法，可能与预期不符    &#125;&#125;\r\n\r\n运算：\r\n当 ==\r\n运算符的两个操作数都是包装器类型引用，则比较指向的是否是同一个对象，而如果其中有一个操作数是原始数据类型（包含表达式结果）则比较的是数值（即会触发自动拆箱）。\r\n不同类型的包装器不能 == 比较，报错提示：Incompatible operand types\r\nLong and Integer\r\n\r\n有关void和Void\r\nvoid 是 Java 中的一种特殊数据类型，它表示 “无类型” 或 “空类型”\r\nJava不能声明 void 类型的变量，void 不能作为数组元素类型。\r\n\r\nVoid包装类:\r\nVoid 是 void\r\n对应的包装类，它是一个不可实例化的类（其构造函数是私有的）。Void\r\n类主要用于与 Java 反射机制和泛型等特性交互。\r\n\r\n特殊之处如下：\r\nVoid 类没有公共的构造函数，所以无法创建 Void 类的实例。 因为 void\r\n本身表示无值，创建 Void 实例没有实际意义。\r\n唯一常量 TYPE：Void 类包含一个公共的静态成员 TYPE 它是一个\r\nClass 类型的对象，用于表示 void 类型本身。\r\n在反射中获取一个返回 void 的方法的返回类型 import java.lang.reflect.Method;public class VoidExample &#123;    public void voidMethod() &#123;&#125;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method method = VoidExample.class.getMethod(&quot;voidMethod&quot;);        if (method.getReturnType() == Void.TYPE) &#123;            System.out.println(&quot;The method returns void.&quot;);        &#125;    &#125;&#125;\r\n\r\n不要混淆 Void 与 void：虽然 Void 是 void\r\n的包装类，但它们的使用场景和语义有很大区别。void\r\n用于声明方法返回类型或在特定语义中表示无值，而 Void\r\n主要用于在需要对象表示 void 类型的场景\r\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Log4j2日志记录框架的使用与配置文件的解析","url":"/posts/47832.html","content":"Log4j2如何使用\r\n什么是日志\r\n日志(Log)是软件系统运行时记录的重要事件、状态信息和操作轨迹的机制。它是软件开发、测试和维护过程中不可或缺的工具，具有以下特点和作用：\r\n\r\n问题诊断：当系统出现异常或错误时，日志提供了问题发生的上下文信息，帮助开发人员快速定位问题根源\r\n行为追踪：记录用户操作和系统行为，便于审计和追踪业务流程\r\n性能监控：通过记录关键操作的时间戳，可以分析系统性能瓶颈\r\n安全审计：记录系统访问和敏感操作，满足合规性要求\r\n运行状态记录：保存系统运行期间的重要状态变化，便于事后分析\r\n\r\n日志通常分为不同级别，便于过滤和分类处理：\r\n\r\nFATAL/ERROR：错误，严重错误事件，可能导致系统崩溃或功能失效\r\nWARN：警告，输出警告的信息，潜在的有害情况，需要引起注意但不会立即影响系统运行\r\nINFO：信息，输出重要的运行时信息，记录系统正常运行状态\r\nDEBUG：调试，一般在开发中都设置的最低级别，详细的调试信息，用于开发阶段问题排查\r\nTRACE：追踪，最低的日志级别，最详细的跟踪信息，记录程序执行的详细路径\r\n\r\n级别高的日志会自动屏蔽级别低的日志\r\n日志的输出目的地指定了日志将会打印到控制台还是文件中，输出格式控制了日志信息的显示内容\r\nLog4j2作为Java生态中最流行的日志框架之一，提供了强大的日志记录能力，能够满足上述所有日志需求。\r\n简介\r\nLog4j的1.x版本虽然已经被广泛使用于很多应用程序中，但由于出现内存泄漏等bug，代码难以维护，以及需要使用老版本的jdk等劣势，在2015年8月已经玩完。它的替代品，SLF4J，Logback，Log4j2对日志框架做了很多必要的改进。\r\n历史上出现了很多的日记框架，如：\r\nLog4j：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki\r\nGülcü首创的，现在则是Apache软件基金会的一个项目。\r\nLog4j是几种Java日志框架之一。\r\nLog4j2：Apache Log4j 2是apache开发的一款Log4j的升级产品。\r\nCommons\r\nLogging：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta\r\nCommons Logging，后更名为Commons Logging。\r\nSlf4j：类似于Commons\r\nLogging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging\r\nFacade for Java，缩写Slf4j）。\r\nLogback：一套日志组件的实现(Slf4j阵营)。\r\nJul(Java Util Logging)：自Java1.4以来的官方日志实现。\r\n安装\r\n在开发中使用Log4j2日志记录框架需要引入的jar包如下：\r\nlog4j-api-2.13.0.jarlog4j-core-2.13.0.jar\r\nmaven中配置xml如下\r\n&lt;properties&gt;    &lt;logging.log4j.version&gt;2.13.0&lt;/logging.log4j.version&gt;&lt;/properties&gt; &lt;dependencies&gt;    &lt;!-- Log4j2日志记录框架 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n配置文件\r\n在项目的src根目录下，创建log4j2.xml配置文件。配置信息如下：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;     &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\r\n日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR\r\n&lt;\r\nFATAL，如果设置为WARN，则低于WARN的信息都不会输出。对于Loggers中level的定义同样适用。\r\n下面是Appender配置，Appender可以理解为日志的输出目的地，这里配置了一个类型为Console的Appender，也就是输出到控制台。Console节点中的PatternLayout定义了输出日志时的格式。\r\nLog4j提供的转换模式：\r\n\r\n%m 输出代码中指定的消息。\r\n%p 输出优先级，即DEBUG,INFO,WARN,ERROR,FATAL。\r\n%r 输出自应用启动到输出该log信息耗费的毫秒数。\r\n%c 输出所属的类目,通常就是所在类的全名。\r\n%t 输出产生该日志事件的线程名。\r\n%n 输出一个回车换行符，Windows平台为“”，Unix平台为“”。\r\n%d\r\n输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{dd\r\nMMM yyyy HH:mm:ss,SSS}，输出类似：02 Nov 2012 14:34:02,781)。\r\n%l\r\n输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数，\r\n如：Testlog.main(TestLog.java:10)。\r\n%F 输出日志消息产生时所在的文件名称。\r\n%L 输出代码中的行号。\r\n%x 输出和当前线程相关联的NDC(嵌套诊断环境)，像java\r\nservlets多客户多线程的应用中。\r\n%% 输出一个”%“字符。\r\n\r\n最后是Logger的配置，这里只配置了一个Root Logger。\r\n可以用如下代码测试\r\npublic static void main(String[] args)&#123;    Logger logger = LogManager.getLogger(LogFunction.class);    logger.trace(&quot;trace level&quot;);    logger.debug(&quot;debug level&quot;);    logger.info(&quot;info level&quot;);    logger.warn(&quot;warn level&quot;);    logger.error(&quot;error level&quot;);    logger.fatal(&quot;fatal level&quot;);&#125;\r\nSpring中整合Log4j2日志框架\r\nLog4j2依赖导入\r\n引入Log4j2的依赖\r\n&lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;\r\n在引入log4j2时，需要排除掉Logback日志框架的依赖即。\r\n&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\r\nlog4j2一般可以通过xml,json,yaml或者properties形式文件来实现，我们这边主要介绍xml文件格式。因为log4j\r\n2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,“.json”或者”.jsn”。\r\n系统选择配置文件的优先级(从先到后)如下：\r\n(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件。\r\n(2).classpath下的名为log4j2-test.xml的文件。\r\n(3).classpath下名为log4j2.json 或者log4j2.jsn的文件。\r\n(4).classpath下名为log4j2.xml的文件。\r\n我们一般默认使用log4j2.xml进行命名。如果本地要测试，可以把log4j2-test.xml放到classpath，而正式环境使用log4j2.xml，则在打包部署的时候不要打包log4j2-test.xml即可。\r\nLog4j2的路径相关\r\n默认路径\r\n引入log4j2依赖后，默认在src/main/resources目录下加入log4j2.xml配置文件对日志进行配置即可，然后在application.yml中进行访问路径的配置。\r\n示例如下：\r\n\r\nlog4j2.xml部署位置\r\n在代码工程中的src/main/resources目录下放入配置文件。\r\nyml配置\r\n\r\n#日志配置 无特殊需求无需更改logging:  config:  classpath:log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\r\n那么如何自定义部署位置\r\n当然我们也可以在微服务部署的config/目录下放置，然后在application.yml中进行访问路径的配置。\r\n举例：我们的micro-service01部署中配置的log4j2.xml路径。\r\n\r\nlog4j2.xml部署位置\r\n\r\n[userA@linux01 config]$ pwd/home/userA/SpringBoot/micro-service01/config[userA@linux01 config]$ lltotal 24-rwxr-xr-x 1 userA userA 5938 Sep  9 16:30 application.yml-r-------- 1 userA userA 8342 Sep  8 16:33 log4j2.xml\r\n\r\nyml配置\r\n\r\n#日志配置 无特殊需求无需更改logging:  config: /home/userA/SpringBoot/micro-service01/config/log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\r\nLog4j2.xml配置详解\r\n缺省默认配置文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;&lt;Appenders&gt;    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;        &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;    &lt;/Console&gt;&lt;/Appenders&gt;&lt;Loggers&gt;    &lt;Root level=&quot;error&quot;&gt;        &lt;AppenderRef ref=&quot;Console&quot; /&gt;    &lt;/Root&gt;&lt;/Loggers&gt;&lt;/Configuration&gt;\r\n解读：\r\n全局配置：\r\n\r\n仅输出 ERROR\r\n及以上级别的日志（Root level=\"error\"）。\r\n使用名为 Console 的Appender（控制台输出）。\r\n\r\n日志格式：\r\n14:25:30.456 [main] ERROR com.example.MyClass - This is an error message\r\n\r\n%d&#123;HH:mm:ss.SSS&#125; → 时间（时:分:秒.毫秒）。\r\n[%t] → 线程名（如 [main]）。\r\n%-5level → 左对齐的日志级别（如\r\nERROR）。\r\n%logger&#123;36&#125; → 类名（长度限制为36字符）。\r\n%msg%n → 日志内容 + 换行。\r\n\r\n配置文件节点解析\r\n\r\n**根节点 &lt;Configuration**&gt;\r\n&lt;Configuration status=&quot;WARN&quot;&gt;\r\n\r\n作用：整个配置文件的根节点。\r\n两个属性：\r\n\r\nstatus：用来指定log4j2本身的打印日志的级别，用于调试配置文件问题。可选值：TRACE,\r\nDEBUG, INFO, WARN,\r\nERROR, FATAL。\r\n其他可选属性：monitorInterval=\"30\"用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s\r\n\r\n有两个子节点：Appenders和Loggers(表明可以定义多个Appender和Logger)。\r\n\r\n日志输出器Appenders节点，常见的有三种子节点：Console、RollingFile、File。\r\n&lt;Appenders&gt;  &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;    &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;  &lt;/Console&gt;&lt;/Appenders&gt;\r\n\r\n作用：定义日志输出的目的地（如控制台、文件等）。\r\n子节点类型：\r\n\r\n&lt;Console&gt;：定义输出到控制台的Appender。\r\n\r\nname：唯一标识符,指定Appender的名字。（后续通过\r\nAppenderRef 引用）。\r\ntarget：输出目标，可选\r\nSYSTEM_OUT（标准输出）或\r\nSYSTEM_ERR（标准错误）。一般只设置默认：SYSTEM_OUT。\r\nPatternLayout：输出格式，不设置默认为:%m%n。\r\n\r\n&lt;File&gt;：输出到文件（支持滚动日志）。用来定义输出到指定位置的文件的Appender。\r\n\r\nname：指定Appender的名字\r\nfileName：指定输出日志的目的文件带全路径的文件名。\r\nPatternLayout：输出格式，不设置默认为:%m%n。\r\n\r\n&lt;RollingFile&gt;节点用来定义超过指定大小自动删除旧的创建新的的Appender。\r\n\r\nname：指定Appender的名字。\r\nfileName：指定输出日志的目的文件带全路径的文件名。\r\nPatternLayout：输出格式，不设置默认为:%m%n。\r\nfilePattern：指定新建日志文件的名称格式。\r\nPolicies：指定滚动日志的策略，就是什么时候进行新建日志文件输出日志。\r\nTimeBasedTriggeringPolicy：Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1\r\nhour。modulate=true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am。\r\nSizeBasedTriggeringPolicy：Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小。\r\nDefaultRolloverStrategy：用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。\r\n\r\n其他：&lt;Socket&gt;\r\n&lt;Kafka&gt; &lt;JDBC&gt; 等\r\n\r\n&lt;PatternLayout&gt;：定义日志格式。\r\n\r\npattern：格式模板，常用占位符：\r\n\r\n%d：日期时间（可指定格式如\r\n%d&#123;yyyy-MM-dd HH:mm:ss&#125;）。\r\n%t：线程名。\r\n%-5level：左对齐的日志级别（长度5）。\r\n%logger&#123;36&#125;：Logger名称（最大长度36）。\r\n%msg：日志消息。\r\n%n：换行符。\r\n\r\n\r\n\r\n日志记录器&lt;Loggers&gt;\r\n&lt;Loggers&gt;  &lt;Root level=&quot;error&quot;&gt;    &lt;AppenderRef ref=&quot;Console&quot; /&gt;  &lt;/Root&gt;&lt;/Loggers&gt;\r\n\r\n作用：定义日志的采集规则（哪些级别的日志被记录，输出到哪些Appender）。常见的有两种：Root和Logger。\r\n核心节点：\r\n\r\nRoot节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出。\r\nlevel：日志输出级别，共有8个级别，按照从低到高为：All\r\n&lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt;\r\nOFF。\r\nAppenderRef：Root的子节点，用来指定该日志输出到哪个Appender。\r\nLogger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。\r\nlevel：日志输出级别，共有8个级别，按照从低到高为：All\r\n&lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt;\r\nOFF。\r\nname：用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点。\r\nAppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=\"false\"只在自定义的Appender中进行输出。\r\n\r\n\r\n关于日志level\r\n共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt;\r\nWarn &lt; Error &lt; Fatal &lt; OFF。\r\n\r\nAll：最低等级的，用于打开所有日志记录。\r\nTrace：是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出。\r\nDebug：指出细粒度信息事件对调试应用程序是非常有帮助的。\r\nInfo：消息在粗粒度级别上突出强调应用程序的运行过程。\r\nWarn：输出警告及warn以下级别的日志。\r\nError：输出错误信息日志。\r\nFatal：输出每个严重的错误事件将会导致应用程序的退出的日志。\r\nOFF：最高等级的，用于关闭所有日志记录。\r\n\r\n程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。\r\n\r\n比较完整的log4j2.xml配置模板\r\n配置模板1:\r\n不同级别日志分离存储带日志滚动归档，历史日志分析\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;!--先定义所有的appender--&gt;    &lt;appenders&gt;        &lt;!--这个输出控制台的配置--&gt;         &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;        &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;        &lt;/File&gt;        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/info.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/warn.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/error.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;loggers&gt;        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;        &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;root level=&quot;all&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\r\n配置模板2\r\n基础控制台 + 文件日志（带滚动策略）\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- status=&quot;WARN&quot; 表示 Log4j2 自身日志级别，调试时可设为 TRACE --&gt;&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;Appenders&gt;        &lt;!-- 控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 滚动文件日志 (每天滚动，最多保留7天) --&gt;        &lt;RollingFile name=&quot;RollingFile&quot;                      fileName=&quot;logs/app.log&quot;                      filePattern=&quot;logs/app-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout&gt;                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;            &lt;/PatternLayout&gt;            &lt;Policies&gt;                &lt;!-- 每天午夜滚动日志 --&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;                &lt;!-- 单个日志文件最大 100MB --&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- 最多保留 7 天的日志 --&gt;            &lt;DefaultRolloverStrategy max=&quot;7&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- Spring 框架日志控制 --&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- Hibernate 日志控制 --&gt;        &lt;Logger name=&quot;org.hibernate&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 项目代码日志 (包路径根据实际情况修改) --&gt;        &lt;Logger name=&quot;com.example&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 根日志配置 --&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n配置模板3\r\n按环境区分配置（开发/生产）\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Properties&gt;        &lt;!-- 通过环境变量切换配置 --&gt;        &lt;Property name=&quot;log.level&quot;&gt;$&#123;sys:spring.profiles.active:-dev&#125;&lt;/Property&gt;        &lt;Property name=&quot;logPath&quot;&gt;logs&lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!-- 彩色控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;cyan&#125; %highlight&#123;%-5level&#125; %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 生产环境专用文件日志 --&gt;        &lt;RollingFile name=&quot;ProdFile&quot;                      fileName=&quot;$&#123;logPath&#125;/prod.log&quot;                     filePattern=&quot;$&#123;logPath&#125;/prod-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;500 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 开发环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;dev&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;DEBUG&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;        &lt;!-- 生产环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;prod&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;WARN&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;                &lt;AppenderRef ref=&quot;ProdFile&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n配置模板4\r\n高性能异步日志\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;!-- 启用异步日志 --&gt;    &lt;AsyncLoggerConfig includeLocation=&quot;true&quot; /&gt;    &lt;Appenders&gt;        &lt;!-- 异步文件追加器 --&gt;        &lt;RollingRandomAccessFile name=&quot;AsyncFile&quot;                                fileName=&quot;logs/async.log&quot;                                filePattern=&quot;logs/async-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;ISO8601&#125; %-5level [%t] %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;200 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;!-- 控制台快速输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 异步记录器配置 --&gt;        &lt;AsyncLogger name=&quot;com.example&quot; level=&quot;INFO&quot; includeLocation=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/AsyncLogger&gt;        &lt;!-- SQL 日志单独记录 --&gt;        &lt;Logger name=&quot;jdbc.sqlonly&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;WARN&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n模板5\r\nJSON 格式日志（适用于 ELK 收集）\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;JsonLayout compact=&quot;true&quot; eventEol=&quot;true&quot;&gt;                &lt;KeyValuePair key=&quot;app&quot; value=&quot;MySpringApp&quot;/&gt;                &lt;KeyValuePair key=&quot;env&quot; value=&quot;$&#123;sys:spring.profiles.active&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/Console&gt;        &lt;File name=&quot;JsonFile&quot; fileName=&quot;logs/app.json&quot;&gt;            &lt;JsonLayout complete=&quot;false&quot; compact=&quot;false&quot;&gt;                &lt;KeyValuePair key=&quot;timestamp&quot; value=&quot;$$&#123;date:yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#125;&quot;/&gt;                &lt;KeyValuePair key=&quot;thread&quot; value=&quot;%t&quot;/&gt;                &lt;KeyValuePair key=&quot;level&quot; value=&quot;%level&quot;/&gt;                &lt;KeyValuePair key=&quot;logger&quot; value=&quot;%logger&quot;/&gt;                &lt;KeyValuePair key=&quot;message&quot; value=&quot;%message&quot;/&gt;                &lt;KeyValuePair key=&quot;exception&quot; value=&quot;%ex&#123;full&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/File&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 结构化日志专用配置 --&gt;        &lt;Logger name=&quot;com.example.api&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\r\n自定义配置文件夹位置\r\nlog4j2默认在classpath下查找配置文件，可以修改配置文件的位置。在非web项目中：\r\npublic static void main(String[] args) throws IOException&#123;    File file = new File(&quot;D:/log4j2.xml&quot;);    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));    final ConfigurationSource source = new ConfigurationSource(in);    Configurator.initialize(null, source);     Logger logger = LogManager.getLogger(&quot;mylog&quot;);&#125;\r\n如果是web项目，在web.xml中添加：\r\n&lt;context-param&gt;    &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt;    &lt;param-value&gt;/WEB-INF/conf/log4j2.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;listener&gt;    &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;&lt;/listener&gt;\r\n\r\n上述内容部分引用自\r\nhttps://blog.csdn.net/pan_junbiao/article/details/104313938\r\n推荐教程\r\n推荐几篇我在网上找到的，写的很好的学习教程：\r\n学习资料1：详解log4j2(上)\r\n- 从基础到实战\r\n学习资料2：详解log4j2(下)\r\n- Async/MongoDB/Flume Appender 按日志级别区分文件输出\r\n学习资料3：SpringBoot—整合log4j2入门和log4j2.xml配置详解\r\n\r\n简单示例\r\n在项目的src根目录下的resources文件夹创建如下log4j2.xml文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;    &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\r\n日志功能测试类\r\npublic class TestUser &#123;    // 创建Logger    private Logger logger = LoggerFactory.getLogger(TestUser.class);    @Test    public void test() &#123;        // 加载spring配置文件，对象创建        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 获取创建的对象        User user = (User)context.getBean(&quot;user&quot;);        System.out.println(&quot;1:&quot; + user);    // 输出了对象的地址        // 使用对象调用方法完成测试        System.out.println(&quot;2:&quot;);        user.add();        // 手动写日志        logger.info(&quot;@执行调用成功&quot;);        // 追踪        logger.trace(&quot;trace level&quot;);        logger.debug(&quot;debug level&quot;);        logger.info(&quot;info level&quot;);        logger.warn(&quot;warn level&quot;);        logger.error(&quot;error level&quot;);    &#125;\r\n输出结果\r\n\r\n\r\nimage-20250416203626062\r\n\r\n\r\n\r\nimage-20250416203626062\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework","日志与调试"]},{"title":"Little Busters!EX游戏攻略","url":"/posts/28134.html","content":"前言\r\n请注意！ 本攻略转载自“LBEX中文化攻略Ver1.01”，侵删 制作：抛雨挥虹\r\n修订：中野梓喵 攻略：Pyhh\r\nLBEX流程图攻略转自 https://bbs.inapom.com/3096.html 是Steam English\r\nEdition版本的\r\n\r\n游戏简介\r\nLittle\r\nBusters！EX（リトルバスターズ!エクスタシー）是VisualArt’s/KEY继1999年的KANON，2000年的AIR，2004年的Clannad，2005年的智代after，2007年的Little\r\nBusters!之后，2008年7月25日发售的新作。 Little Busters-EX和Little\r\nBusters!不同的地方在于Little\r\nBusters!里的配角二木佳奈多和笹濑川佐佐美升为可攻略女主角，另外再加一个可攻略新女主角朱鹭户沙耶，新的迷你游戏与音乐也是追加要素。\r\n一般把原本的Little Busters!称为“无印”(没有EX印记的意思)，而Little\r\nBusters！EX称为EX。\r\n游戏名称：リトルバスターズ!エクスタシー (Little Busters!EX)\r\n制作公司：VisualArt’s/KEY\r\n游戏类型：AVG/ADV\r\n年龄限制：18X 游戏语音：全程语音\r\n故事简介：\r\n主角直枝理树与其青梅竹马的朋友棗恭介、棗铃、井之原真人、宫沢谦吾一起过着全寄宿制的高中生活。他们从小就结成了一个与恶势力作斗争，号称正义的使者的队伍，名为“Little\r\nBusters”。升上高中后，他们依然像以前一样过着快乐的每一天，理树也渴望与伙伴们的日子能够永远持续下去。\r\n一天，恭介提议要组成一个棒球队伍，像从前一样再热闹地玩一次。于是理树他们就开始寻找队员，挥洒着青春的光彩…\r\n\r\n注意事项\r\n1.是否开启棒球练习和战斗排位赛都不会对攻略有影响。如果在游戏中开启了则在攻略上没有「闲逛」「挑战」「到处走走」之类的选项均可自行选择。此攻略在战斗排位赛和棒球练习OFF的情况下制作。\r\n2.如想在第一次游戏就攻略沙耶,佳奈多,佐佐美,需在游戏起始询问「你知道世界的秘密吗?」选「是」；如果没玩过此游戏建议选「否」。\r\n3.如果在游戏起始询问「你知道世界的秘密吗?」选「否」，在攻略标上符号“★”的部分是必须完成Refrain之后才能攻略。\r\n4.用( )括号括住的选项是在特定的情况下才会出现，如果在游戏时攻略上带(\r\n)的选项没出现请忽略。\r\n5.攻略过的女主角再攻略一次时有些选项会变成灰色不能选择，不能再进入已攻略过的角色线(铃和小毬除外)，到Refrain之后会恢复。\r\n6.本攻略为最速攻略，只保证收集全部CG以及Scene，不保证剧情的100%达成，追求完整剧情的同学请自行探索。\r\n\r\n流程图版本攻略\r\n这里是共通线的，人物线在对应的位置\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n共通线\r\n5月14日Mon\r\n出声招呼 不怎么好 不怎么好\r\n不怎么好 不怎么好\r\n\r\n5月15日Tue\r\n借 去找她\r\n存档A 就这样看着 用别的笔记代替\r\n\r\n5月16日Wed\r\n追铃 暂时看着 赶紧找人 接受 去凑热闹 结束算了 帮忙找\r\n\r\n5月17日Thu\r\n找找看吧 沉默 去追铃 暂时先看着 去屋顶\r\n-——————————————————————————-\r\n5月18日Fri\r\n存档B 我 西园 留在中庭 她到底问了什么呢？ 西园 去买果汁 接受\r\n(感觉到了敌意) 制止她\r\n-——————————————————————————-\r\n5月19日Sat\r\n去找铃 站着看一会 (还是很在意)\r\n(到屋外去)\r\n(帮忙) 参与进去 中庭 (结束) 帮忙\r\n\r\n5月20日Sun\r\n去\r\n(找人) 恭介 存档① 普通的甜甜圈\r\n↓CG回收(如不需100%CG达成率可以忽略此步骤)\r\n※在此处选择不同的选项在24日活动室里小毬的小裤裤CG会有变化\r\n※在选择其中一个选项后继续剧情直到24日对应→CG回收的步骤\r\n→第1次读取存档①后选择\r\n有巧克力条纹的甜甜圈\r\n→第2次读取存档①后选择\r\n软软的草莓的甜甜圈\r\n-——————————————————————————-\r\n5月21日Mon\r\n(认真阅读) 去买果汁去 去找找看 善意 去听听她们在说什么 铃\r\n\r\n5月22日Tue\r\n去叫她 回教室 存档② 去中庭 (劝谦吾) 听听她们在说什么 对着库特点头。\r\n去\r\n-——————————————————————————-\r\n5月23日Wed\r\n和库特打招呼 上前打招呼 存档③ 制止她 存档④ 去屋顶 买果汁去\r\n去听听在谈些什么 和恭介他们一起吃 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 帮忙 回教室 去听听她们在说些什么 →CG回收\r\n※在活动室获取第1张小毬的CG后\r\n→第1次读取存档①\r\n※获取此处第2张小毬的CG后\r\n→第2次读取存档① ※获取此处第3张小毬的CG后继续下面的剧情 小毬 库特\r\n-——————————————————————————-\r\n5月25日Fri\r\n就这样决定了\r\n(躲进去) 谢绝 结束\r\n(兔子)\r\n(乔)\r\n\r\n5月27日Sun\r\n存档⑤\r\n※共通线结束，开始角色线\r\n\r\n\r\n神北 小毬\r\n5月27日Sun\r\n那下个晴天再去不就行了吗\r\n\r\n5月28日Mon\r\n去屋顶 ●小毬 给恭介发短信 上网找找 拉好 询问关于梦的事情 找来谷问\r\n存档⑥\r\n小毬TRUE END\r\n不直面这些不行 小毬TRUE END\r\n\r\n小毬BAD END\r\n上述END后 读取存档⑥ 把这些抛到脑后就好 这就是守护了吧 小毬BAD END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n能美 库特莉亚芙卡\r\n读取存档⑤\r\n5月27日Sun\r\n库特TRUE END\r\n要不要我来拿东西呢？ 铃的 ●库特莉亚芙卡 叶留佳和西园\r\n去调查下关于昨晚的疑问 存档⑦ 现在，就想回应她 对她说，回去吧 库特TRUE\r\nEND\r\n\r\n上述END后 库特BAD END\r\n读取存档⑦ 现在就回应她这样好吗 对她说，希望她能留下来 库特BAD END\r\n★以下攻略必须完成Refrain线后开启\r\n\r\n库特TRUE END２\r\n以下攻略必须完成Refrain线后开启\r\n读取存档⑦ 现在，就想回应她 听听库特自己希望怎么样 小卖部\r\n查找语言学的书架 ※库特CG回收 库特TRUE END２\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n库特挂科整理(给有需求的人使用)\r\n\r\n\r\nimg\r\n\r\n\r\n三枝 叶留佳\r\n读取存档②\r\n5月22日Tue\r\n去食堂 我先 叶留佳 (去追恭介) 听听她们在说什么 对着库特摇头。 去\r\n\r\n5月23日Wed\r\n进教室 上前打招呼 制止她 去食堂 帮忙 买果汁去 去听听在谈些什么\r\n和恭介他们一起吃 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 去找猫 去听听她们在说些什么 叶留佳 美鱼\r\n\r\n5月25日Fri\r\n就这样决定了 (躲进去) 谢绝 结束 (乔) (外星人)\r\n\r\n5月28日Mon (叶留佳TRUE END)\r\n中庭的自动贩卖机 去问问发生什么事了 ●叶留佳 去委员会室 询问真相\r\n去确认一下 继续找叶留佳 回答说看名单找到的 有 我明白了 觉得可以 蓝莓之类\r\n进一步的 用手\r\n→CG回收\r\n※获取用手的CG后在菜单选择返回上一选择肢\r\n用嘴 接收条件 存档⑧ 不放弃 叶留佳TRUE END\r\n\r\n叶留佳BAD END\r\n上述END后 读取存档⑧ 放弃 期望 叶留佳BAD END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n来谷 唯湖\r\n读取存档②\r\n5月22日Tue\r\n去后院 仔细听 (去追恭介) 听听她们在说什么 对着库特摇头。 去\r\n\r\n5月23日Wed\r\n进教室 上前打招呼 制止她 去食堂 拒绝 买果汁去 去听听在谈些什么\r\n(打扫一下吧) 和恭介他们一起吃 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 回教室 去听听她们在说些什么 来谷 库特\r\n\r\n5月25日Fri\r\n就这样决定了 (躲进去) 拒绝 结束\r\n\r\n5月28日Mon （来谷TRUE END）\r\n不说 ●来谷 死不承认\r\n存档⑨\r\n↓下面3个选项的顺序可随意选择（包括人物也可以自由选择，叶留佳也可以作为选项之一）\r\n库特 美鱼 小毬\r\n↑上面3个选项的顺序可随意选择 恭介 就是前面 就算是那样… 老实回答\r\n来谷TRUE END\r\n★以下攻略必须完成Refrain线之后开启\r\n\r\n来谷TRUE END２\r\n以下攻略必须完成Refrain线之后开启\r\n读取存档⑨\r\n↓下面3个选项的顺序可随意选择，建议多S/L几次选择不同的顺序会有很有趣的剧情\r\n库特 美鱼\r\n小毬\r\n↑上面3个选项的顺序可随意选择（包括人物也可以自由选择，叶留佳也可以作为选项之一）\r\n恭介\r\n就是前面\r\n就算是那样… 老实回答 ※下面的选项在三周目以后追加\r\n记得这个名字\r\n※来谷CG回收 来谷TRUE END２\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n西园 美鱼\r\n读取存档④\r\n5月23日Wed\r\n去中庭 和真人玩 去听听在谈些什么 上前搭话 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 去中庭 回教室 去听听她们在说些什么 美鱼 小毬\r\n\r\n5月25日Fri\r\n就这样决定了 (跑过走廊) 拒绝 结束 (兔子) (乔)\r\n\r\n5月27日Sun\r\n那下个晴天再去不就行了吗\r\n\r\n5月28日Mon （美鱼TRUE END）\r\n去中庭 ●美鱼\r\n↓下面5个选项的顺序可随意选择 库特 小毬 铃 恭介 真人\r\n↑上面5个选项的顺序可随意选择 美鸟 存档⑩ 善意 美鱼TRUE END\r\n\r\n美鱼TRUE END２\r\n上述END后\r\n读取存档⑩ 善意\r\n※美鱼Hscene 美鱼TRUE END２\r\n读取存档⑩ 恶意\r\n※美鸟Hscene 美鸟END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n棗 铃 BAD END\r\n※在第一次攻略 棗铃时无法避免BAD END\r\n※完成Refrain后再攻略此路线时将不会再出现BAD END而直接进入棗\r\n铃END1\r\n\r\n读取存档③\r\n5月23日Wed\r\n继续帮忙 和真人玩 集中精神练习 (继续用那种眼神盯着看)\r\n和恭介他们一起吃 再来一碗 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 去找猫 去练习 铃 库特\r\n\r\n5月25日Fri\r\n跟铃商量 (躲进去) 拒绝 结束 (外星人) (兔子)\r\n\r\n5月27日Sun （铃BAD END）\r\n那下个晴天再去不就行了吗 ●铃 鼓励她 举手 铃BAD END\r\n※完成铃BAD END和小毬、库特、叶留佳、来谷、美鱼的END后将开启棗\r\n铃END１\r\n\r\n棗 铃 END１\r\n※此路线必须先完成棗铃BAD\r\nEND和小毬、库特、叶留佳、来谷、美鱼的END后才能开启\r\n※此路线为开启Refrain的最后条件，在标题画面选Start→New\r\nGame开始\r\n\r\n5月14日Mon\r\n就这样看着 不怎么好 不怎么好 不怎么好 不怎么好\r\n-——————————————————————————-\r\n5月15日Tue\r\n不借 去找她 出声招呼 用别的笔记代替\r\n-——————————————————————————-\r\n5月16日Wed\r\n追铃 搭话 赶紧找人 让他自己去 结束算了 不要管太多了\r\n\r\n5月17日Thu\r\n没有 制止 去追铃 打个招呼 不去屋顶\r\n\r\n5月18日Fri\r\n返回食堂 和真人玩 (感觉到了敌意) 制止她\r\n\r\n5月19日Sat\r\n去找铃 出声打招呼 与真人玩 老实待着 还有作业…\r\n\r\n5月20日Sun\r\n去\r\n(找人) 恭介 软软的草莓的甜甜圈\r\n\r\n5月21日Mon\r\n和真人玩 就此结束 铃\r\n\r\n5月22日Thu\r\n和真人玩 去后院 劝谦吾 认真练习 去\r\n\r\n5月23日Wed\r\n上前打招呼\r\n存档⑪\r\n继续帮忙 买果汁去 集中精神练习 继续用那种眼神盯着看 打扫一下吧\r\n上前打招呼 在一旁看着 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 去找猫 去练习 不阻止 铃 小毬\r\n\r\n5月25日Fri （铃END１）\r\n跟铃商量 (躲进去) 拒绝 结束 (兔子) (乔) ●铃 鼓励她 举手 中庭 去\r\n铃END１ ※ＥＤ后 从此坚强地活下去\r\n\r\nRefrain\r\n※此路线必须完成铃END１后开启，在标题画面选择Refrain\r\n\r\n5月21日Mon\r\n靠头脑\r\n\r\n5月23日Wed\r\n问他\r\n\r\n5月24日Thu （铃END２）\r\n问他看看 他想起来左手受伤了 ●修学旅行 带着铃逃走 铃END２\r\n\r\n铃TRUE END &amp; Little\r\nBusters!TRUE END\r\n※ＥＤ后\r\n●Epilogue 不好 ●修学旅行 冷静下来 去折树枝 之后再来 去大家的包里找\r\n思考一下 救恭介 Little Busters!TRUE END\r\n铃TRUE END &amp; Little Busters!TRUE END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\nLittle Busters! TRUE\r\nEND的其他回收\r\n※完成一次Refrain线后在标题画面选择Start里Refrain\r\n\r\n5月21日Mon\r\n靠头脑\r\n\r\n5月23日Wed\r\n问他\r\n\r\n5月24日Thu\r\n问他看看 他想起来左手受伤了 ●修学旅行\r\n带着铃逃走 ●Epilogue\r\n嗯\r\n※ＥＤ后 不好\r\n●修学旅行 冷静下来 去折树枝 之后再来 去大家的包里找 思考一下 救恭介\r\n铃TRUE END Little Busters! TRUE END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n笹濑川 佐佐美\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n读取存档⑪\r\n5月23日Wed\r\n制止她 拒绝 买果汁去 集中精神练习 练习 不管 去食堂要紧 算了\r\n去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 回教室 去练习 阻止她 小毬 美鱼\r\n\r\n5月25日Fri\r\n跟铃商量 (躲进去) 请他帮忙 结束 (外星人) (乔)\r\n\r\n10月23日Tue （佐佐美TRUE END）\r\n脸被拧了 ●佐佐美 猫食 默不作声地拿出猫粮 娶她 库特 存档C 待在她身边\r\n我也…\r\n※佐佐美Hscene 佐佐美TRUE END\r\n\r\n佐佐美GOOD END\r\n上述END后 读取存档C 就这样让她一个人静一静 还有其他的答案 佐佐美GOOD\r\nEND\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n二木 佳奈多\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n读取存档B\r\n5月18日Fri\r\n我 小毬 返回食堂 差不多该走了 和真人玩 感觉到了好意 制止她\r\n\r\n5月19日Sat\r\n不管她 还是很在意 到屋外去 帮忙\r\n参与进去 帮忙\r\n\r\n5月20日Sun\r\n去\r\n(找人) 真人 有巧克力条纹的甜甜圈\r\n\r\n5月21日Mon\r\n随便读一下 到外面去呼吸新鲜空气 就此结束 叶留佳\r\n\r\n5月22日Tue\r\n平时的那家伙又出现了！ 回教室 去后院 去追恭介 认真练习 对着库特摇头。\r\n去\r\n\r\n5月23日Wed\r\n和库特打招呼 去食堂 帮忙 买果汁去 集中精神练习 练习 (打扫一下吧)\r\n去食堂要紧 算了 去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n去买果汁 目送她离去 去找猫 去练习 叶留佳 库特\r\n\r\n5月25日Fri\r\n就这样决定了 (跑过走廊) 拒绝 结束 (兔子) (外星人)\r\n\r\n5月28日Mon （佳奈多TRUE END）\r\n去帮忙 ●佳奈多 去宿舍会帮忙\r\n存档D 不出去 不出去 不叫 电影赠票 问问关于泡菜的问题 喜欢你\r\n※佳奈多Hscene 佳奈多TRUE END\r\n\r\n佳奈多BAD END\r\n上述END后\r\n读取存档D\r\n出去\r\n佳奈多BAD END\r\n\r\n流程图\r\n\r\n\r\nimg\r\n\r\n\r\n朱鹭户 沙耶(理树通常ver)\r\n\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n※射击游戏OFF\r\n\r\n读取存档A\r\n5月15日Tue\r\n出声招呼\r\n※如果此处出现询问「想要能再次攻略沙耶线吗?」选「是」开启沙耶线 去取\r\n返回学校\r\n\r\n5月16日Wed\r\n乞求帮助 结束算了 不好 金字塔\r\n\r\n5月17日Thu\r\n没有\r\n制止\r\n不放弃\r\n\r\n5月18日Fri\r\n默不作声 喜欢 恭介\r\n\r\n※在迷宫部分，符号“&gt;”表示提示\r\n\r\n■地下１层 &gt;右上方的房间 我\r\n\r\n■地下２层\r\n\r\n\r\nimg\r\n\r\n&gt;中间的房间 往右转\r\n\r\n5月19日Sat\r\n确实也有感到有趣的时候\r\n\r\n■地下３层 \r\n&gt;右上方尽头的房间 老老实实地去 石头(此处选项可随意选择)\r\n\r\n■地下４层 \r\n&gt;左上方3个房间中顶部的房间 到房间外面去调查\r\n\r\n5月20日Sun\r\n想和朱鹭户同学待在一起 问她喜欢什么样的男人 有巧克力条纹的甜甜圈\r\n\r\n■地下５层\r\n\r\n\r\nimg\r\n\r\n&gt;右下方的房间 用冰来雕刻出这条龙的形象 更加努力 更加努力\r\n\r\n■地下６层\r\n &gt;其中一边黄色地点→另一边黄色地点→红色点的房间\r\n重新看一次这层的地图 王\r\n\r\n\r\n&gt;返回其中一边黄色地点 &gt;打通地图成“王”字 &gt;右上方的空房间\r\n打开这个房间的棺材 去找木乃伊\r\n&gt;在各个房间寻找\r\n\r\n5月21日Mon\r\n(随便读一下) 库特 库特 我和恭介在交往中 真人 就此结束\r\n\r\n5月22日Tue\r\n说 去后院 去追恭介 握她的手\r\n\r\n■地下７层\r\n\r\n\r\nimg\r\n\r\n&gt;把迷宫全部走遍 试着碰她的手\r\n&gt;在迷宫内侧移动 试着抚摸她的头\r\n&gt;回到起点的房间 &gt;按一笔书规则在迷宫内侧走“８”字 \r\n\r\n■地下８层\r\n\r\n\r\nimg\r\n\r\n&gt;右下方尽头\r\n\r\n■地下８层\r\n&gt;右下方尽头 开枪\r\n&gt;在各处寻找\r\n\r\n■重播\r\n※为完成此路线必须按步骤GAME OVER数次\r\n※每次GAME OVER选择REPLAY继续游戏\r\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\r\n\r\n存档E 调查地板 调查后面的黑板\r\n\r\n■地下１层\r\n &gt;绿色的房间 拉绳索\r\n左\r\n&gt;回到绿色的房间\r\n拉绳索\r\n正中\r\n&gt;回到绿色的房间\r\n拉绳索\r\n右\r\n&gt;回到绿色的房间\r\n问问理树的意见\r\n\r\n■地下２层\r\n &gt;黄色的房间\r\n听听理树的意见\r\n&gt;绿色的房间 试试看 &gt;回到绿色的房间\r\n&gt;再回到绿色的房间 跳进去\r\n\r\n■地下３层 \r\n&gt;绿色的房间 飞身退避 &gt;回到绿色的房间 登上石像\r\n\r\n■地下４层 \r\n&gt;绿色的房间\r\n进入沸水里 还是要进去 &gt;红色的房间→绿色的房间\r\n\r\n■地下５层\r\n &gt;红色的房间 去弄清楚 &gt;绿色的房间 寻找别的方法\r\n&gt;红色的房间 脱掉衣服 连内裤都脱掉 &gt;绿色的房间\r\n\r\n■地下６层\r\n\r\n\r\nimg\r\n\r\n&gt;经过4个房间后向迷宫正中心移动\r\n\r\n\r\nimg\r\n\r\n&gt;往黄色的地点进行爆破→绿色的房间→红色的房间 移动\r\n&gt;绿色的房间 打开这个房间的棺材\r\n\r\n■地下７层 \r\n&gt;在迷宫内侧走“８”字 问问理树君的意见\r\n\r\n\r\nimg\r\n\r\n&gt;在迷宫内侧走“５”字\r\n\r\n■地下８层 &gt;右下方尽头\r\n\r\n※在标题画面选择Start里New Game继续\r\n5月14日Mon\r\n出声招呼 可以\r\n(可以)\r\n(可以)\r\n(可以)\r\n\r\n5月15日Tue\r\n不借 不管她 去取 返回学校\r\n\r\n5月16日Wed\r\n自己想办法上去 结束算了 不好\r\n\r\n5月17日Thu (沙耶END)\r\n取下来 没有 制止 沙耶END\r\n\r\n沙耶线的流程图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n※如果之前未攻略过沙耶线，此路线结束后请攻略朱鹭户沙耶(笨蛋理树ver)，回收CG和部分内容会有变化。\r\n\r\n朱鹭户 沙耶(笨蛋理树ver)①\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n读取存档A\r\n5月15日Tue\r\n出声招呼\r\n※如果此处出现询问「想要能再次攻略沙耶线吗?」选「是」开启沙耶线\r\n去取 返回学校\r\n\r\n5月16日Wed\r\n乞求帮助 结束算了 我会逃掉的 和她合作 太阳塔 罗森\r\nFamima\r\n\r\n5月17日Thu\r\n没有 沉默\r\n※射击游戏OFF 不放弃\r\n\r\n5月18日Fri\r\n呼喊 呼唤爱 对她说谎 最喜欢了 绝对是恭介\r\n\r\n※在迷宫部分，符号“&gt;”表示提示\r\n\r\n■地下１层\r\n &gt;先去岔路上方的房间  &gt;之后进入岔路右边的房间 朱鹭户\r\n坚持要跳\r\n\r\n■地下２层\r\n &gt;先走一遍迷宫外侧 \r\n&gt;最后进入中间的房间 往左转 回转一圈\r\n\r\n5月19日Sat\r\n不比 十分有趣\r\n\r\n■地下３层\r\n&gt;为了把地图全部发现在各个地方走一遍 \r\n&gt;反复5次左右进入有陷阱的房间 \r\n&gt;最后进入右上方尽头的房间 让朱鹭户去 布(此处选项可随意选择)\r\n\r\n■地下４层\r\n&gt;为把地图全部发现在各个地方走一遍\r\n\r\n\r\nimg\r\n\r\n&gt;最后进入左上方3个房间中顶部的房间 到房间外面去调查\r\n\r\n5月20日Sun\r\n想和朱鹭户同学待在一起 问她喜欢什么样的男人 其实我年纪比你大啊？\r\n(试一下)\r\n有巧克力条纹的甜甜圈\r\n\r\n■地下５层\r\n&gt;为把地图全部发现在各个地方走一遍 \r\n&gt;最后进入右下方的房间 边赏龙边喝冰镇酒 更加努力 更加努力\r\n\r\n■地下６层 \r\n&gt;其中一边黄色地点→另一边黄色地点→红色点的房间 重新看一次这层的地图 死\r\n &gt;返回其中一边黄色地点\r\n&gt;打通地图成“王”字→右边的空房间→右边另一间空房间 打开这个房间的棺材\r\n去找木乃伊 &gt;在各个房间寻找\r\n\r\n5月21日Mon\r\n(随便读一下) 西园 铃 我和恭介在交往中 来谷 西园 就此结束\r\n\r\n5月22日Tue\r\n蒙混过去 去食堂 最后再去 去追恭介 握她的手\r\n\r\n■地下７层\r\n &gt;把迷宫全部走遍 试试碰她的手 &gt;在迷宫内侧移动\r\n试试抚摸她的头\r\n&gt;回到起点的房间\r\n&gt;反复走错路6次以上(例如向前走一步然后向后走一步) \r\n&gt;按一笔书规则在迷宫内侧走“８”字\r\n\r\n■地下８层\r\n&gt;把迷宫全部走一遍  &gt;右下方尽头\r\n\r\n■地下８层\r\n&gt;右下方尽头 开枪 &gt;在各处寻找\r\n\r\n●重播 ※为完成此路线必须按步骤GAME\r\nOVER数次\r\n※每次GAME OVER选择REPLAY继续游戏\r\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\r\n\r\n朱鹭户 沙耶(笨蛋理树ver)②\r\n存档E\r\n移动桌子 试着移动桌子 调查后面的黑板\r\n\r\n■地下１层\r\n\r\n&gt;重复3次进入红色的房间(进入房间REPLAY后再返回此房间如此类推)\r\n&gt;之后进入绿色的房间 拉绳索\r\n左\r\n&gt;回到绿色的房间\r\n拉绳索\r\n正中\r\n&gt;回到绿色的房间\r\n拉绳索\r\n右\r\n&gt;回到绿色的房间\r\n问问理树的意见\r\n\r\n■地下２层\r\n &gt;重复3次进入红色的房间 &gt;之后进入绿色的房间 还是自己上\r\n&gt;回到绿色的房间 紧抱住把手 &gt;回到绿色的房间\r\n\r\n■地下３层\r\n &gt;重复3次进入红色的房间 &gt;之后进入绿色的房间 用枪应战\r\n&gt;回到绿色的房间 &gt;再回到绿色的房间 拿剑 &gt;回到绿色的房间\r\n\r\n■地下４层\r\n &gt;先进入绿色的房间 进入沸水里 还是要进去\r\n&gt;回到绿色的房间 想别的办法 &gt;红色的房间\r\n&gt;逃脱之后再回到红色的房间 不相信 &gt;回到红色的房间 相信理树君\r\n&gt;逃脱后进入绿色的房间\r\n\r\n■地下５层\r\n &gt;红色的房间 去弄清楚 &gt;之后绿色的房间 用冰雕出龙\r\n&gt;红色的房间 裸足下去 &gt;回到红色的房间 脱掉衣服 不要越过这条线\r\n&gt;回到红色的房间 脱掉衣服 &gt;绿色的房间\r\n\r\n■地下６层\r\n\r\n\r\nimg\r\n\r\n&gt;经过4个房间后向迷宫正中心移动\r\n\r\n\r\nimg\r\n\r\n&gt;往黄色的地点进行爆破→绿色的房间→红色的房间 打开这个房间的棺材\r\n&gt;往黄色的地点移动→绿色的房间 打开这个房间的棺材\r\n\r\n■地下７层\r\n &gt;在迷宫内侧走“８”字 问问理树君的意见  &gt;在迷宫内侧走“５”字\r\n\r\n■地下８层\r\n&gt;右下方尽头\r\n\r\n※在标题画面选择Start里New Game继续\r\n5月14日Mon\r\n出声招呼 可以 (可以) (可以) (可以)\r\n\r\n5月15日Tue\r\n不借 不管她 去取 返回校舍\r\n\r\n5月16日Wed\r\n自己想办法上去 结束算了 不怎么好\r\n\r\n5月17日Thu (沙耶BAD END)\r\n存档F 不取下来 没有 制止 沙耶BAD END\r\n\r\n※如果在Refrain之前\r\n(沙耶TRUE END)\r\n读取存档F 取下来 没有 制止 沙耶TRUE END\r\n\r\n※如果在Refrain之后 (沙耶TRUE\r\nEND)\r\n读取存档F 取下来 没有 就这么等待着\r\n存档G 是沙耶同学赢了 制止 沙耶TRUE END\r\n\r\n读取存档G (沙耶CG回收)\r\n是我赢了 沙耶CG回收\r\n\r\n※这样能避免一部分CG和选项不出现\r\n情况是在完成Refrain后而且是笨蛋理树，需要笨蛋沙耶推进。\r\n如果按照上述攻略到Refrain后再来攻略的话将会全部出现\r\n\r\nSchoolRevo 学园革命线\r\n※此路线必须完成一次沙耶END后才能开启\r\n\r\n●重播 ※为完成此路线必须按步骤GAME\r\nOVER数次\r\n※每次GAME OVER选择REPLAY继续游戏\r\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\r\n\r\n读取存档E\r\n移动桌子 试着移动桌子 调查后面的黑板\r\n\r\n■地下１层\r\n※必须开启射击游戏，难度自行选择 \r\n&gt;重复3次以上进入红色的房间(进入房间后REPLAY再返回此房间如此类推)\r\n※直到沙耶说「搞什么，谁会喜欢啊！！」为止\r\n&gt;绿色的房间 拉绳索\r\n左\r\n&gt;回到绿色的房间\r\n拉绳索\r\n正中\r\n&gt;回到绿色的房间\r\n拉绳索\r\n右\r\n&gt;回到绿色的房间\r\n问问理树的意见\r\n\r\n■地下２层\r\n &gt;重复3次以上进入红色的房间\r\n※直到沙耶说「很好，来吧—！！ 毒蛇们、COME ON–！！」为止\r\n&gt;绿色的房间 还是自己上 &gt;回到绿色的房间 紧抱住把手\r\n&gt;回到绿色的房间\r\n\r\n■地下３层\r\n &gt;按黄色的路线移动(为避免进入绿色的房间)\r\n&gt;重复3次以上进入红色的房间\r\n※直到沙耶说「喂，来吧—-！！」为止 &gt;绿色的房间\r\n用枪应战 &gt;回到绿色的房间 &gt;再回到绿色的房间 拿剑\r\n&gt;回到绿色的房间\r\n\r\n■地下４层\r\n &gt;绿色的房间 进入沸水里 还是要进去 &gt;回到绿色的房间\r\n进入沸水里 还是要进去 &gt;回到绿色的房间 进入沸水里 还是要进去\r\n※看到沙耶说「开水、我–来–啦–！！」为止 &gt;红色的房间\r\n&gt;逃脱之后再回到红色的房间 不相信 &gt;回到红色的房间 不相信\r\n&gt;回到红色的房间 不相信 ※看到沙耶说「水、COME\r\nON—-！」为止 &gt;回到红色的房间 相信理树君 &gt;绿色的房间\r\n\r\n■地下５层\r\n &gt;红色的房间 去弄清楚\r\n&gt;绿色的房间 用冰雕出龙\r\n&gt;红色的房间 裸足下去\r\n&gt;回到红色的房间 裸足下去\r\n&gt;回到红色的房间 裸足下去\r\n※看到沙耶说「哟嚯———–…」为止\r\n&gt;回到红色的房间 脱掉衣服 不要越过这条线\r\n&gt;回到红色的房间 脱掉衣服 &gt;绿色的房间\r\n\r\n■地下６层\r\n &gt;经过4个房间后向迷宫正中心移动  &gt;往黄色的地点进行爆破→绿色的房间→红色的房间\r\n打开这个房间的棺材\r\n&gt;回到红色的房间 打开这个房间的棺材\r\n&gt;回到红色的房间 打开这个房间的棺材\r\n※看到沙耶说「我来送死了！ 嘿，陷阱COME\r\nON—-！！」为止\r\n&gt;绿色的房间 打开这个房间的棺材\r\n\r\n■地下７层\r\n&gt;现在！！必须要做的就是让沙耶不断去被镭射光XXOO\r\n(向前走一步然后往后走一步即可实现)\r\n※直到沙耶说「很好，镭射光，COME ON—！」\r\n※看屏幕出现\r\n  沙耶M觉醒,能发动Ecstasy模式\r\n于是我们的革命战争开始了！！\r\n &gt;在迷宫内侧走“８”字 问问理树君的意见\r\n\r\n■地下８层 (SchoolRevo END)\r\n &gt;右下方的路口\r\n※在与时风战斗时Ecstasy模式发动后并不能够无限回复生命，被击中6次就会失败，建议在战斗前存档\r\n当受到几次伤害之后Ecstasy模式发动，打败时风瞬 SchoolRevo END\r\n\r\n真人 肌肉线\r\n※此路线即使不攻略也不会对其他路线有影响\r\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\r\n→选「是」可以在一周目攻略\r\n→选「否」需要完成Refrain线后开启\r\n\r\n5月14日Mon\r\n就这样看着 不怎么好 不怎么好 不怎么好 不怎么好\r\n\r\n5月15日Tue\r\n不借 不管她 用别的笔记代替\r\n\r\n5月16日Wed\r\n用手机读取QR code 让他自己去 结束算了 帮忙找\r\n\r\n5月17日Thu\r\n没有 沉默\r\n进入手机网站\r\n接着读吧(×133) (去追铃) (就这样看着) 去屋顶\r\n\r\n5月18日Fri\r\n我 西园 (留在中庭) 她到底问了什么呢？ 西园 去食堂 和真人玩\r\n(感觉到了敌意) 制止她\r\n\r\n5月19日Sat\r\n(不看) 与真人玩 和真人玩 帮忙\r\n\r\n5月20日Sun\r\n去\r\n(找人) 真人 普通的甜甜圈\r\n\r\n5月21日Mon\r\n(随便读一下) 和真人玩 (去练习) 就此结束 真人 铃\r\n\r\n5月22日Tue\r\n清扫用具的整理 和真人玩 去食堂 我先 真人 去追恭介 听听她们在说什么\r\n对着库特点头. 和恭介他们一起玩\r\n真的\r\n\r\n5月23日Wed\r\n和库特打招呼\r\n去食堂 拒绝 和真人玩 去听听在谈些什么 打扫一下吧 上前搭话\r\n去恭介的房间 叫大家来\r\n\r\n5月24日Thu\r\n陪真人玩 回教室 去听听她们在说些什么 库特 美鱼\r\n\r\n5月25日Fri\r\n就这样决定了 (躲进去) 拒绝 结束 (兔子) (乔)\r\n\r\n5月27日Sun （真人 肌肉END）\r\n要不要我来拿东西呢？ 真人的\r\n我和真人 (去调查下关于昨晚的疑问) 肌肉 肌肉 肌肉 就算如此还是肌肉\r\n真人 肌肉END\r\n\r\n游戏攻略常见问题\r\n■Ｑ.看不到库特线的TRUE END2。\r\n□Ａ.在游戏起始的讯问「你知道世界的秘密吗?」选「是」在完成库特TRUE\r\nEND1和BAD END后会出现\r\n​ 追加选项。选「否」需要完成库特TRUE END1和BAD\r\nEND以及Refrain后会出现追加选项。\r\n■Ｑ.攻略沙耶线到后期直接回到了标题画面。\r\n□Ａ.从最初遇见沙耶处继续攻略会有不同剧情。\r\n■Ｑ.无法取回沙耶剩余的CG和Hscene。\r\n□Ａ.走笨蛋理树线的话可以回收不足的CG。\r\n​\r\n在完成因各种陷阱死去的沙耶线路重播(Replay)后，再一次进入沙耶线会追加选项。\r\n■Ｑ.无法再次进入朱鹭户沙耶线。\r\n□Ａ.Clear所有角色(包括EX追加角色)并完成Refrain线，之后选择“New\r\nGame”到5月15日会追加\r\n​ 「想要能再次攻略沙耶线吗?」的询问。\r\n■Ｑ.无法取回佳奈多的剩余CG。 □Ａ.在叶留佳线获得。\r\n■Ｑ.来谷的CG没有填满。 □Ａ.请在Refrain之后再一次攻略来谷。\r\n■Ｑ.没有铃的Hscene啊。\r\n□Ａ.Refrain完后再开一次Refrain，这次记得向铃求婚哦。\r\n■Ｑ.小毬线Clear之后还差一张CG。\r\n□Ａ.铃END1之后，22日的选项选择「去」女生宿舍。\r\n※如果在“知道世界的秘密”的情况下2周目回收可能。\r\n■Ｑ.小毬不同种类的内裤CG回收不能。\r\n□Ａ.20日的甜甜圈选项会影响24日小毬CG的变化。请按攻略走3次。\r\n■Ｑ.找不到佐佐美的Hscene。 □Ａ.进入路线以后请按攻略进行。\r\n(猫食→默不作声地拿出猫粮→娶她→待在她身边→我也…)\r\n■Ｑ.虽然看到了美鸟的Hscene，但是没看到美鱼的。(世界的秘密：不知道)\r\n□Ａ.请在最后的选项之前「善意or恶意」存档\r\n美鱼END之后读取存档选择「善意」。\r\n※(世界的秘密：知道)只需一次就能看到Hscene。\r\n■Ｑ.怎样决定攻略的顺序才好呢？\r\n□Ａ.※不知道世界的秘密的情况下，推荐以下攻略顺序\r\n共通线→(铃BAD\r\nor小毬or库特or叶留佳or来谷or西园)→铃END1→Refrain→\r\n​ (库特TRUE2＆来谷TRUE2 or\r\nRefrain)or佐佐美or佳奈多or沙耶\r\n\r\n※知道世界的秘密的情况下(沙耶、佐佐美、佳奈多在Refrain前后都可以攻略)\r\n​ 共通线→沙耶or佳奈多or佐佐美or(铃BAD\r\nor小毬or库特or叶留佳or来谷or西园)→\r\n​ 铃END1→Refrain→(来谷TRUE2 or\r\nRefrain)→沙耶(为了回收不同的CG)\r\n\r\n\r\n\r\nimg\r\n\r\n\r\nErgouTree 进行整理\r\n","categories":["其他","galgame相关","攻略"],"tags":["galgame","其他","攻略","杂项"]},{"title":"MySql的数据类型","url":"/posts/33441.html","content":"MySQL数据类型\r\nMySQL\r\n支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。\r\nMySQL 支持所有标准 SQL 数值数据类型。\r\n这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和\r\nNUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。\r\n关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。\r\nBIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和\r\nBDB表。\r\n数值和数据类型\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n大小\r\n范围（有符号）\r\n范围（无符号）\r\n用途\r\n\r\n\r\n\r\n\r\nTINYINT\r\n1 Bytes\r\n(-128，127)\r\n(0，255)\r\n小整数值\r\n\r\n\r\nSMALLINT\r\n2 Bytes\r\n(-32 768，32 767)\r\n(0，65 535)\r\n大整数值\r\n\r\n\r\nMEDIUMINT\r\n3 Bytes\r\n(-8 388 608，8 388 607)\r\n(0，16 777 215)\r\n大整数值\r\n\r\n\r\nINT或INTEGER\r\n4 Bytes\r\n(-2 147 483 648，2 147 483 647)\r\n(0，4 294 967 295)\r\n大整数值\r\n\r\n\r\nBIGINT\r\n8 Bytes\r\n(-9,223,372,036,854,775,808（-(2^63)），9 223 372 036 854 775\r\n807（(2^63)-1）)\r\n(0，18 446 744 073 709 551 615)\r\n极大整数值\r\n\r\n\r\nFLOAT\r\n4 Bytes\r\n(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351\r\nE-38，3.402 823 466 351 E+38)\r\n0，(1.175 494 351 E-38，3.402 823 466 E+38)\r\n单精度 浮点数值\r\n\r\n\r\nDOUBLE\r\n8 Bytes\r\n(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4\r\nE-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7\r\nE+308)\r\n0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7\r\nE+308)\r\n双精度 浮点数值\r\n\r\n\r\nDECIMAL 定点类型\r\n对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2\r\n依赖于M和D的值，M：总位数，D：小数位数\r\n依赖于M和D的值\r\n小数值\r\n\r\n\r\n\r\n整数类型\r\nMySQL 支持 SQL 标准整数类型\r\nINTEGER（或INT）和 SMALLINT.\r\n作为标准的扩展，MySQL 还支持整数类型\r\nTINYINT、MEDIUMINT和 BIGINT。\r\nMySQL 支持的整数类型所需的存储和范围\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n存储（字节）\r\n有符号最小值\r\n最小值无符号\r\n有符号最大值\r\n最大值无符号（UNSIGNED）\r\n\r\n\r\n\r\n\r\nTINYINT\r\n1个\r\n-128\r\n0\r\n127\r\n255\r\n\r\n\r\nSMALLINT\r\n2个\r\n-32768\r\n0\r\n32767\r\n65535\r\n\r\n\r\nMEDIUMINT\r\n3个\r\n-8388608\r\n0\r\n8388607\r\n16777215\r\n\r\n\r\nINT\r\n4个\r\n-2147483648\r\n0\r\n2147483647\r\n4294967295\r\n\r\n\r\nBIGINT\r\n8个\r\n-2^63\r\n0\r\n2^63-1\r\n2^64-1\r\n\r\n\r\n\r\n定点类型\r\nDECIMAL和NUMERIC 类型存储精确的数字数据值\r\n。当保持精确的精度很重要时使用这些类型\r\n在DECIMAL列声明中，可以（并且通常）指定精度和小数位数。例如：\r\nsalary DECIMAL(5,2)\r\n在此示例中，5是精度，2是标度。精度表示为值存储的有效位数，标度表示小数点后可以存储的位数。\r\n如果小数位数为\r\n0，则DECIMAL值不包含小数点或小数部分。\r\n浮点类型（近似值）\r\nFLOAT DOUBLE——MySQL\r\n对单精度值使用四个字节，对双精度值使用八个字节。\r\nBIT——比特值类型\r\nBIT数据类型用于存储位值。一种允许存储-bit\r\n值的类型。范围从 1 到 64。\r\n如果您将值分配给长度小于位的列，则该值将在左侧填充零。例如，为列分配一个值实际上与分配\r\n.\r\nBIT(*M*)Mb'101'``BIT(6)``b'000101'\r\n日期和时间类型\r\n表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。\r\n每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。\r\n常用的日期有如下三个：\r\n\r\ndate :日期 ‘yyyy-mm-dd’ ，占用三字节。\r\ndatetime 时间日期格式 ‘yyyy-mm-dd HH:ii:ss’ 表示范围从 1000 到 9999\r\n，占用八字节。\r\ntimestamp ：时间戳，从1970年开始的 yyyy-mm-dd HH:ii:ss 格式和\r\ndatetime 完全一致，占用四字节。 表示现在的时间。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n大小 ( bytes)\r\n范围\r\n格式\r\n用途\r\n\r\n\r\n\r\n\r\nDATE\r\n3\r\n1000-01-01/9999-12-31\r\nYYYY-MM-DD\r\n日期值\r\n\r\n\r\nTIME\r\n3\r\n‘-838:59:59’/‘838:59:59’\r\nHH:MM:SS\r\n时间值或持续时间\r\n\r\n\r\nYEAR\r\n1\r\n1901/2155\r\nYYYY\r\n年份值\r\n\r\n\r\nDATETIME\r\n8\r\n‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’\r\nYYYY-MM-DD hh:mm:ss\r\n混合日期和时间值\r\n\r\n\r\nTIMESTAMP\r\n4\r\n‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC 结束时间是第\r\n2147483647 秒，北京时间 2038-1-19\r\n11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07\r\nYYYY-MM-DD hh:mm:ss\r\n混合日期和时间值，时间戳\r\n\r\n\r\n\r\n字符串类型\r\n字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。\r\n\r\n\r\n\r\n类型\r\n大小\r\n用途\r\n\r\n\r\n\r\n\r\nCHAR\r\n0-255 bytes\r\n定长字符串\r\n\r\n\r\nVARCHAR\r\n0-65535 bytes\r\n变长字符串\r\n\r\n\r\nTINYBLOB\r\n0-255 bytes\r\n不超过 255 个字符的二进制字符串\r\n\r\n\r\nTINYTEXT\r\n0-255 bytes\r\n短文本字符串\r\n\r\n\r\nBLOB\r\n0-65 535 bytes\r\n二进制形式的长文本数据\r\n\r\n\r\nTEXT\r\n0-65 535 bytes\r\n长文本数据\r\n\r\n\r\nMEDIUMBLOB\r\n0-16 777 215 bytes\r\n二进制形式的中等长度文本数据\r\n\r\n\r\nMEDIUMTEXT\r\n0-16 777 215 bytes\r\n中等长度文本数据\r\n\r\n\r\nLONGBLOB\r\n0-4 294 967 295 bytes\r\n二进制形式的极大文本数据\r\n\r\n\r\nLONGTEXT\r\n0-4 294 967 295 bytes\r\n极大文本数据\r\n\r\n\r\n\r\nchar(n) 和 varchar(n) 中括号中 n\r\n代表字符的个数，一个定长一个不定长。\r\nvarchar长度可以指定为0到65535之间的值，但是有1 - 3\r\n个字节用于记录数据大小，所以说有效字节数是65532。\r\n当我们的表的编码是utf8时，varchar(n)的参数n最大值是65532/3=21844，（因为utf中，一个字符占用3个字节），如果编码是gbk，varchar(n)的参数n最大是65532/2=32766（因为gbk中，一个字符占用2字节）。\r\n\r\n\r\nimage-20250318083228988\r\n\r\nCHAR 和 VARCHAR\r\n类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。\r\n枚举与集合类型（Enumeration\r\nand Set Types）\r\nENUM: 枚举类型，用于存储单一值，可以选择一个预定义的集合。\r\nenum(&#39;选项1&#39;,&#39;选项2&#39;,&#39;选项3&#39;,...);\r\n  该设定只是提供了若干个选项的值，最终一个单元格中，实际只存储了其中一个值；而且出于效率考虑，这些值实际存储的是“数字”，因为这些选项的每个选项值依次对应如下数字：1,2,3,…最多65535个；当我们添加枚举值时，也可以添加对应的数字编号。\r\nSET: 集合类型，用于存储多个值，可以选择多个预定义的集合。\r\nset(&#39;选项值1&#39;,&#39;选项值2&#39;,&#39;选项值3&#39;, ...);\r\n  该设定只是提供了若干个选项的值，最终一个单元格中，设计可存储了其中任意多个值；而且出于效率考虑，这些值实际存储的是“数字”，因为这些选项的每个选项值依次对应如下数字：1,2,4,8,16,32，…最多64个。\r\n\r\n空间数据类型（Spatial Data\r\nTypes）\r\nGEOMETRY, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING,\r\nMULTIPOLYGON, GEOMETRYCOLLECTION:\r\n用于存储空间数据（地理信息、几何图形等）。\r\n","categories":["学习类","数据库","MySql","MySql基础"],"tags":["实用知识","数据库","MySql","常用知识","语言基础"]},{"title":"Python基础部分","url":"/posts/39185.html","content":"Python程序基础\r\nPython程序构成\r\nPython程序可分解为模块、语句、表达式和对象。\r\n\r\nPython程序由模块组成，模块对应于扩展名为.py的源文件。\r\n模块由语句组成，运行Python程序时，按照模块中的语句顺序依次执行。\r\n语句包含表达式。表达式由操作数和运算符组成。\r\n表达式用于创建和处理\r\n对象。\r\n\r\n\r\n\r\nimage-20250513193726574\r\n\r\n对象\r\n对象是Python中对数据的抽象。\r\n每个对象都有identity、type和value。\r\n对象和变量\r\n\r\n对象是python中的各种数据，存在于计算机内存中的一个内存块中。\r\n变量是用来指向（绑定）对象的，也称为对象的引用。\r\n变量名必须为有效的标识符。\r\n\r\n标识符\r\n\r\n标识符是程序中为了区分或引用各种数据而定义的名称，如变量名、常量名、函数名、类名、模块名等。\r\n关键字（保留字）是特殊的标识符，在Python中有特定的含义，开发人员不能定义和关键字相同的标识符。\r\n\r\n变量名命名规则\r\n\r\n由字母、数字或下划线组成，\r\n数字不能做开头\r\n不能以Python关键字作为变量名\r\n变量名要有意义\r\n变量名区分大小写\r\n建议使用驼峰法或加下划线方式命名\r\n\r\n变量赋值\r\n\r\n等号”=“用来给变量赋值。\r\nPython 中的变量赋值不需要类型声明。\r\n每个变量在使用前都必须赋值，变量赋值后才创建成功。\r\n\r\n字面量（literal）\r\n\r\n用于某种数据类型固定值的表示法。\r\nPython基于字面量创建相应数据类型的对象。\r\n\r\na = 123s = &#x27;az78&#x27;l = [4, &#x27;f&#x27;]\r\n表达式\r\n表达式是一段能计算的代码片段，由操作数（如变量、常量）和运算符（如+、*、()）构成。\r\nPrimary\r\n是语言中最紧密绑定的操作，即表达式中优先级最高、最先被计算的部分。（primary\r\n::= atom | attributeref | subscription | slicing | call）\r\n“最紧密绑定”是指在表达式的运算顺序中，这部分会首先被解析或计算。\r\n语法规则（使用 BNF 表示）：\r\nprimary ::= atom | attributeref | subscription | slicing | call\r\n各部分含义：\r\n\r\natom：原子操作，如变量、常量、字面量（如42、\"hello\"）。\r\nattributeref：属性引用，如obj.attr。\r\nsubscription：下标操作，如list[0]。\r\nslicing：切片操作，如list[1:3]。\r\ncall：函数 / 方法调用，如func()。\r\n\r\n::=\r\n表示“定义为”或“被指定为”，用来定义一个语法规则的左边可以被右边的一个或多个符号序列替换。\r\n|：表示 “或”，即左边的符号可以被右边的任一选项替换\r\n这种定义方式是巴科斯-诺尔范式（Backus-Naur Form, BNF）和扩展巴科斯-诺尔范式（Extended Backus-Naur Form, EBNF）的一部分，它们是用于描述编程语言语法的形式化方法。\r\n操作数和运算符通过一定规则构成表达式\r\n操作数包含Primary，Primary包含atom。\r\n最基本元素（atom）\r\n\r\nidentifier 标识符\r\nliteral 字面量\r\nenclosure（翻译为包围、围住的意思）小括号、方括号或花括号的封闭结构\r\n\r\n属性引用\r\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = ageperson = Person(&quot;Alice&quot;, 30)# 访问对象的属性print(person.name)  print(person.age)\r\nPython代码规范\r\nPEP8 Python编码规范：https://www.python.org/dev/peps/pep-0008/\r\n缩进\r\n- Python\r\n使用缩进来表示代码的逻辑结构，一般使用Tab键或4个空格作为一个缩进级别。\r\n- 优先使用空格缩进，tab制表符一般用于已经使用了制表符的代码中。\r\n-\r\n有括号的参数缩进：与开始括号垂直对齐，或者回车到下一行后再额外添加4个空格。\r\n#缩进演示示例def imn(x):    a = 9    if x != 0:        a = a/ax        print(&#x27;ok!&#x27;)    return a### 有括号的参数缩进def long_function_name(var_one,                        var_two,                        var_three,                       var_four):    print(var_one)foo = long_function_name(&quot;aaa&quot;,                          &quot;bb&quot;,                         &quot;vv&quot;,                         &quot;ww&quot;)  \r\n跨行语句\r\n当一行的内容太多时，为了增加代码的可读性，可让一条语句跨多行显示。\r\nPEP8规范推荐每行的最大长度为79个字符\r\n\r\n使用反斜杠\\换行\r\n使用括号()换行\r\n\r\n注意：使用反斜杠换行之后，反斜杠后面不能再添加任何字符（包括空格）或注释语句。\r\n换行在二元运算符之前还是之后呢？\r\n答案是都可以，但是推荐在二元运算符之前。 即：\r\nincome = (gross_wages         + taxable_interest         + (dividends - qualified_dividends)         - ira_deduction         - student_loan_interest)\r\n空格\r\n\r\n在运算符两边添加空格\r\n+,*,=,-,+=,==,&gt;,in,is not, and等。\r\n复杂表达式中，建议在具有最低优先级的操作符两端添加空格。\r\n在函数的参数列表中，参数默认值等号 =\r\n两边不添加空格。\r\n\r\nPython语句\r\n\r\nPython语句分为简单语句和复合语句。\r\n简单语句包括表达式语句、赋值语句、import语句等等\r\n复合语句包括if语句、while语句、for语句等等\r\n\r\n导入语句需要单独在一行上\r\n多条简单语句可用分号（;）隔开，写到一行\r\n如果条件语句、循环语句、函数定义和类定义比较短，可放在同一行\r\n流程控制代码规范\r\n程序的流程\r\n\r\n输入→处理→输出\r\n无论程序的规模如何，每个程序都可以分为以上三部分：程序通过输入接收待处理的数据（Input），然后执行相应的处理过程（Process），最后通过输出返回处理结果（Output）。该过程通常称为IPO程序编写方法。\r\n\r\n程序流程图\r\n\r\n程序流程图又称（程序框图），是描述程序运行具体步骤的图形表示。 \r\n\r\n程序的控制结构\r\n\r\n顺序结构\r\n\r\n程序中各语句按其出现的先后次序执行，称之为顺序结构。\r\n\r\n选择结构\r\n\r\n选择结构可以根据条件来控制代码的执行分支，也成为分支结构。\r\nPython使用 if 语句实现分支结构。\r\n#单分支结构x = int(input(&quot;请输入x的值：&quot;))y = int(input(&quot;请输入y的值：&quot;))if(x &gt; y):    a = x - y    print(&quot;a的值为：&quot;,a)    #双分支结构import matha = float(input(&quot;请输入三角形的边长a：&quot;))b = float(input(&quot;请输入三角形的边长b：&quot;))c = float(input(&quot;请输入三角形的边长c：&quot;))if(a + b &gt; c and b + c &gt; a and a + c &gt; b):    h = (a+b+c) / 2    area = math.sqrt(h * (h-a) * (h-b) * (h-c))    print(str.format(&quot;三角形的三条边分别为：a=&#123;0&#125;,b=&#123;1&#125;,c=&#123;2&#125;&quot;, a, b, c))    print(str.format(&quot;三角形的面积=&#123;0&#125;&quot;, area))else:    print(&quot;输入的三条边无法构成三角形，请重新输入。&quot;)# 多分支结构x = int(input(&quot;请输入x的坐标：&quot;))y = int(input(&quot;请输入y的坐标：&quot;))if(x &gt; 0 and y &gt; 0):    print(&quot;该点位于第一象限&quot;)elif(x &lt; 0 and y &gt; 0):    print(&quot;该点位于第二象限&quot;)elif(x &lt; 0 and y &lt; 0):    print(&quot;该点位于第三象限&quot;)elif(x &lt; 0 and y &lt; 0):    print(&quot;该点位于第四象限&quot;)else:    print(&quot;该点位于坐标轴上&quot;)\r\n\r\n循环结构\r\n\r\n循环结构用来重复执行一条或多条语句。\r\nPython使用for语句和while语句来实现循环结构。\r\ni = 1while(i &lt;= 5):    k = 1    while(k &lt;= 5-i):        print(&quot; &quot;, end = &quot;&quot;)        k = k + 1    j = 1    while(j &lt;= i):        print(i, end = &quot; &quot;)        j = j + 1    print()    i = i + 1def sum_100():    sum = 0    for i in range(1,101):        sum += i    return sumsum_100 = sum_100()print(sum_100)\r\n\r\n\r\nimage-20250513195423897\r\n\r\nfor\r\n循环用于迭代序列（即列表、元组、字典、集合或字符串等）。这与其他编程语言中的\r\nfor\r\n关键字不太相似，而是更像其他面向对象编程语言中的迭代器方法。\r\n\r\n\r\n循环结构中的跳转语句\r\n\r\nbreak语句 （立即终止循环，跳出循环，执行循环后的代码。）\r\ncontinue语句 （跳过当前循环的剩余部分，并开始下一次循环。）\r\npass语句\r\n（用于占位或作为语法要求的空代码块，在循环中，不做任何事情）\r\nbreak 和 continue 语句的使用，通常是与 if 条件语句配合的，当满足 if\r\n条件语句的时候，结束整个循环或者结束本轮循环。\r\n\r\n# 将 break 用于 for 循环# 对 1 到 20 的数字求和，当和大于 100 时，便停止求和numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]count = 0for var in numbers:    count += var    if count &gt;= 100:        breakprint(&quot;count = &quot;, count)# continue# 对 20 以内的偶数求和numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]count = 0for var in numbers:    # 奇数，除以2的余数不为0，也就是不能被2整除    if var % 2 != 0:        # 当数字为奇数时，退出本次循环        continue    count += varprint(&quot;count = &quot;, count)\r\nrange()函数\r\n\r\nrange类型表示一个不可变的数字序列，通常用于在for循环中循环特定次数。\r\n语法：range(start, stop[, step])\r\n\r\nstart：序列的起始值（包含）。默认为 0。\r\nstop：序列的结束值（不包含）。必须指定。\r\nstep：序列的步长（即相邻两个值之间的差）。默认为 1。\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"MySql中的约束","url":"/posts/23211.html","content":"约束\r\n概述\r\n约束（Constraints）是用于限制表中数据的规则，确保数据的完整性和一致性。\r\n\r\n安全性约束\r\n完整性约束：确保数据的准确和可靠\r\n\r\n实体完整性约束（主键约束）\r\n域完整性约束（数据类型）\r\n引用完整性约束（外键约束）\r\n用户自定义完整性约束（check 约束）\r\n\r\n\r\n主键约束（PRIMARY\r\nKEY）\r\n作用：唯一标识表中的每一行，确保数据的唯一性\r\n基本特性\r\n\r\n唯一性：关系中任意元组的主键值必须唯一\r\n\r\n主键列的值必须唯一且不能为 NULL。\r\n一个表只能有一个主键，但主键可以由多个列组成（复合主键）。\r\n关系中任意元组的主键值必须唯一（unique）\r\n\r\n非空性：关系中任意元组在主键值必须非空\r\n\r\n关系中任意元组在主键值必须非空（not null）\r\n\r\n不可更改性：主键值一旦设定，通常不应修改\r\n\r\n-- 创建表时指定主键CREATE TABLE users (    id INT AUTO_INCREMENT PRIMARY KEY,    username VARCHAR(50) NOT NULL);-- 添加复合主键CREATE TABLE order_items (    order_id INT,    product_id INT,    quantity INT,    PRIMARY KEY (order_id, product_id));-- 修改表添加主键ALTER TABLE employees ADD PRIMARY KEY (emp_id);-- 删除主键约束ALTER TABLE employees DROP PRIMARY KEY;\r\n主键选择策略\r\n\r\n自然主键：使用业务中有意义的字段（如身份证号）\r\n代理主键：使用无意义的自增ID（推荐）\r\n复合主键：多个字段组合作为主键\r\n\r\n域完整性约束\r\n规则：关系中某属性取值必须在合法的范围内\r\n实现：\r\n\r\n一般通过数据类型来实现域完整性约束。不同的数据类型限制了属性可以接受的值的类型和范围。\r\nCREATE TABLE products (    price DECIMAL(10,2) NOT NULL,  -- 价格必须为数字    in_stock BOOLEAN DEFAULT TRUE   -- 布尔类型约束);\r\n用户自定义完整性约束。\r\nCREATE TABLE employees (    age INT CHECK (age &gt;= 18 AND age &lt;= 65),    email VARCHAR(100) CHECK (email LIKE &#x27;%@%.%&#x27;));\r\n为列设置默认值，当插入数据时如果没有指定该列的值，数据库将自动使用默认值。\r\nENUM 类型\r\nCREATE TABLE orders (    status ENUM(&#x27;pending&#x27;, &#x27;processing&#x27;, &#x27;shipped&#x27;, &#x27;delivered&#x27;) DEFAULT &#x27;pending&#x27;);\r\n\r\n作用：用于确保表中列（属性）取值有效性和正确性的一种机制\r\n唯一约束（UNIQUE）\r\n\r\n作用：确保列中的值唯一，但允许 NULL\r\n值。\r\n特点：\r\n\r\n一个表可以有多个唯一约束。\r\n唯一约束可以作用于单列或多列（复合唯一约束）。\r\n\r\n\r\n与主键的区别\r\n\r\n\r\n\r\n特性\r\n主键约束\r\n唯一约束\r\n\r\n\r\n\r\n\r\nNULL值\r\n不允许\r\n允许（但只能有一个NULL）\r\n\r\n\r\n数量\r\n每表一个\r\n每表多个\r\n\r\n\r\n索引类型\r\n聚集索引\r\n非聚集索引\r\n\r\n\r\n\r\nCREATE TABLE users (    email VARCHAR(100) UNIQUE,  -- 单列唯一约束    username VARCHAR(50),    CONSTRAINT uc_username_email UNIQUE (username, email)  -- 复合唯一约束);\r\n非空约束（NOT NULL）**\r\n\r\n作用：确保列中的值不能为 NULL。\r\n特点：\r\n\r\n非空约束只能作用于单列。\r\n\r\n\r\n-- 创建表时指定CREATE TABLE customers (    name VARCHAR(100) NOT NULL,    phone VARCHAR(20) NOT NULL);-- 修改现有列ALTER TABLE customers MODIFY COLUMN email VARCHAR(100) NOT NULL;-- 配合DEFAULT使用CREATE TABLE orders (    order_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP);\r\n默认约束（DEFAULT）\r\n\r\n作用：为列设置默认值，当插入数据时未指定该列的值时，使用默认值。\r\n特点：\r\n\r\n默认值可以是常量、表达式或函数。\r\n\r\n\r\n常用默认值：\r\nCREATE TABLE logs (    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,    status VARCHAR(20) DEFAULT &#x27;active&#x27;,    counter INT DEFAULT 0);\r\n动态默认值：\r\n-- 使用函数作为默认值CREATE TABLE documents (    doc_number VARCHAR(50) DEFAULT CONCAT(&#x27;DOC-&#x27;, UUID()),    created_date DATE DEFAULT CURDATE());\r\n外键约束（FOREIGN\r\nKEY）\r\n\r\n作用：确保表之间的引用完整性，用于关联两个表。\r\n规则：设F是关系R的外键，则R中任意元组的F属性值必须满足：F\r\n为空或F不为空，其值必须在 S 中存在\r\n特点：\r\n\r\n外键列的值必须存在于被引用表的主键或唯一键中。\r\n外键可以为 NULL。\r\n\r\n\r\n完整语法\r\nCREATE TABLE child_table (    id INT PRIMARY KEY,    parent_id INT,    FOREIGN KEY (parent_id)         REFERENCES parent_table(id)        ON DELETE action_type        ON UPDATE action_type);\r\n检查约束（CHECK）\r\n\r\n作用：确保列中的值满足指定条件。\r\n特点：\r\n\r\nMySQL 8.0.16 及以上版本支持 CHECK 约束。\r\n条件可以是逻辑表达式。\r\n\r\n\r\nCREATE TABLE employees (    salary DECIMAL(10,2) CHECK (salary &gt; 0),    hire_date DATE CHECK (hire_date &gt;= &#x27;2000-01-01&#x27;),    department VARCHAR(50),    CONSTRAINT chk_dept CHECK (department IN (&#x27;IT&#x27;, &#x27;HR&#x27;, &#x27;Finance&#x27;)));-- 表级检查约束ALTER TABLE products ADD CONSTRAINT chk_price CHECK (price &gt; cost * 1.2);\r\n动递增约束（AUTO_INCREMENT）\r\n\r\n作用：自动为列生成唯一的递增值，通常用于主键列。\r\n特点：\r\n\r\n只能用于整数类型的列。\r\n每个表只能有一个 AUTO_INCREMENT\r\n列。\r\n\r\n\r\n复合约束\r\n\r\n作用：将多个列组合在一起作为约束条件。\r\n常见类型：\r\n\r\n复合主键：多个列共同作为主键。\r\n复合唯一约束：多个列共同确保唯一性。\r\n\r\n\r\nCREATE TABLE orders(    order_id INT,    product_id INT,    PRIMARY KEY (order_id, product_id));\r\n约束操作\r\n约束的添加\r\nALTER TABLE 表名 ADD CONSTRAINT 约束名 约束类型 (列名);\r\n约束的删除\r\nALTER TABLE 表名 DROP CONSTRAINT 约束名;\r\n约束的命名\r\nCREATE TABLE 表名 (    列名 数据类型,    CONSTRAINT 约束名 约束类型 (列名));\r\n查看约束\r\n-- 从information_schema.TABLE_CONSTRAINTS系统表中获取信息-- TABLE_SCHEMA用于指定数据库名，需替换为实际的数据库名称-- TABLE_NAME用于指定表名，需替换为实际的表名称SELECT * FROM information_schema.TABLE_CONSTRAINTSWHERE TABLE_SCHEMA = &#x27;your_db&#x27; AND TABLE_NAME = &#x27;your_table&#x27;;\r\n修改约束\r\n-- 修改检查约束（MySQL中需要先删除再添加）ALTER TABLE employees DROP CHECK chk_salary;ALTER TABLE employees ADD CONSTRAINT chk_salary CHECK (salary &gt; 0);\r\n约束演示\r\n-- 约束建表CREATE TABLE Bin_user(    id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,   -- 多个约束空格分开    name VARCHAR(10) NOT NULL UNIQUE COMMENT &#x27;姓名&#x27;,    age INT CHECK ( age &gt;= 0 AND age &lt;= 120 ) COMMENT &#x27;年龄&#x27;,    status CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;状态&#x27;,    gender CHAR(1)  COMMENT &#x27;性别&#x27;)COMMENT &#x27;用户表&#x27;;-- 主键约束的自动增长INSERT INTO Bin_user (name, age, status, gender) VALUES (&#x27;Tom1&#x27;, 18, &#x27;1&#x27;, &#x27;M&#x27;), (&#x27;SJD&#x27;, 23, &#x27;1&#x27;, &#x27;W&#x27;);-- name的非空约束INSERT INTO Bin_user (name, age, status, gender) VALUES (NULL, 18, &#x27;1&#x27;, &#x27;M&#x27;);-- name的唯一约束INSERT INTO Bin_user (name, age, status, gender) VALUES (&#x27;Tom1&#x27;, 18, &#x27;1&#x27;, &#x27;M&#x27;);-- age的检查约束INSERT INTO Bin_user (name, age, status, gender) VALUES (&#x27;Tom1&#x27;, -18, &#x27;1&#x27;, &#x27;M&#x27;);-- status的默认约束INSERT INTO Bin_user (name, age, gender) VALUES (&#x27;Tom1&#x27;, 18, &#x27;M&#x27;);\r\n外键约束\r\n添加外键\r\nCREATE TABLE 表名(\t字段名 数据类型，    。。。    [CONSTRAIN] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名))\r\n示例\r\nCREATE TABLE customers (    id INT AUTO_INCREMENT PRIMARY KEY, -- 客户ID，主键    name VARCHAR(100) NOT NULL,        -- 客户姓名    email VARCHAR(100) UNIQUE          -- 客户邮箱，唯一);CREATE TABLE orders (    order_id INT AUTO_INCREMENT PRIMARY KEY, -- 订单ID，主键    order_date DATE NOT NULL,               -- 订单日期    amount DECIMAL(10, 2) NOT NULL,         -- 订单金额    customer_id INT,                        -- 客户ID，外键    FOREIGN KEY (customer_id) REFERENCES customers(id) -- 外键约束);INSERT INTO customers (name, email) VALUES(&#x27;张三&#x27;, &#x27;zhangsan@example.com&#x27;),(&#x27;李四&#x27;, &#x27;lisi@example.com&#x27;);INSERT INTO orders (order_date, amount, customer_id) VALUES(&#x27;2023-10-01&#x27;, 100.50, 1), -- 订单属于客户ID为1的张三(&#x27;2023-10-02&#x27;, 200.75, 2); -- 订单属于客户ID为2的李四-- 测试外键约束INSERT INTO orders (order_date, amount, customer_id) VALUES(&#x27;2023-10-03&#x27;, 150.00, 99); -- 99 不存在于 customers 表中DELETE FROM customers WHERE id = 1;   -- 尝试删除 customers 表中被 orders 表引用的数据\r\n外键约束的级联操作\r\n可以通过 ON DELETE 和 ON UPDATE\r\n子句定义外键的级联行为。例如：\r\n\r\nON DELETE CASCADE：当主表中的记录被删除时，自动删除从表中的相关记录。\r\nON UPDATE CASCADE：当主表中的记录被更新时，自动更新从表中的相关记录。\r\n\r\n示例：使用\r\nON DELETE CASCADE\r\nCREATE TABLE orders (    order_id INT AUTO_INCREMENT PRIMARY KEY,    order_date DATE NOT NULL,    amount DECIMAL(10, 2) NOT NULL,    customer_id INT,    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE);\r\n测试：\r\n\r\n删除 customers 表中的一条记录：\r\nDELETE FROM customers WHERE id = 1;\r\n检查 orders 表：\r\nSELECT * FROM orders;\r\n结果：customer_id 为 1\r\n的订单也会被自动删除。\r\n\r\n外键约束的删除和更新行为\r\n\r\nNO ACTION：\r\n父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则不允许删除/更新\r\nRESTRICT\r\n：父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则不允许删除/更新\r\nNO\r\nACTION/RESTRICT（默认）会阻止执行会破坏引用完整性的操作\r\nCASCADE\r\n父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则也删除/更新外键在子表中的记录\r\nSET BULL\r\n父表中删除/更新对应记录时，先检查该记录是否有对应外键，有则设置子表中该外键值为null（外键允许null）\r\nSET DEFAULT\r\n：父表变更的时候，子表将外键设置成一个默认的值\r\nNO ACTION和RESTRICT是默认的\r\n\r\n如何设置\r\nALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE；\r\n约束实践\r\n学校管理系统约束\r\n\r\nstudents\r\n表：用于存储学生的基本信息，如学生编号、姓名、出生日期、所属专业编号等。学校可以通过该表管理学生档案，了解学生基本情况。\r\ncourses\r\n表：用于记录课程相关信息，包括课程代码、课程名称、学分、所属系部编号等。学校利用此表进行课程管理，如排课、课程信息维护等。\r\nenrollments\r\n表：用于记录学生的选课情况，包括选课记录编号、学生编号、课程代码、学期、成绩等。通过该表可以了解学生的选课动态，统计课程选修人数，核算学生成绩等。\r\n\r\nmysql语句：\r\nCREATE TABLE students (    student_id CHAR(10) PRIMARY KEY CHECK (student_id REGEXP &#x27;^[A-Z]&#123;2&#125;[0-9]&#123;8&#125;$&#x27;),    name VARCHAR(100) NOT NULL,    birth_date DATE NOT NULL CHECK (birth_date &lt;= DATE_SUB(CURRENT_DATE, INTERVAL 16 YEAR)),    major_id INT,    FOREIGN KEY (major_id) REFERENCES majors(major_id));\r\n\r\nstudent_id 列：数据类型为\r\nCHAR(10) ，作为学生的唯一标识。设置为主键，同时通过\r\nCHECK 约束确保其值符合正则表达式\r\n^[A-Z]&#123;2&#125;[0-9]&#123;8&#125;$ ，即学生编号必须是 2\r\n个大写字母开头，后面跟着 8 位数字。\r\nname 列：数据类型为\r\nVARCHAR(100) ，用于存储学生姓名，NOT NULL\r\n约束表示该字段不能为空。\r\nbirth_date 列：数据类型为\r\nDATE ，用于记录学生出生日期，NOT NULL\r\n约束要求不能为空。CHECK\r\n约束限定出生日期必须是当前日期往前推至少 16\r\n年以前，确保录入的出生日期符合正常入学年龄逻辑。\r\nmajor_id 列：数据类型为\r\nINT ，用于存储学生所属专业的编号。通过\r\nFOREIGN KEY 约束引用 majors 表中的\r\nmajor_id\r\n，建立与专业表的关联关系，保证学生所属专业编号在专业表中存在。\r\n\r\nCREATE TABLE courses (    course_code VARCHAR(10) PRIMARY KEY,    title VARCHAR(100) NOT NULL,    credit TINYINT NOT NULL CHECK (credit BETWEEN 1 AND 5),    department_id INT NOT NULL,    FOREIGN KEY (department_id) REFERENCES departments(department_id));\r\n\r\ncourse_code 列：数据类型为\r\nVARCHAR(10) ，作为课程的唯一标识，设置为主键。\r\ntitle 列：数据类型为\r\nVARCHAR(100) ，用于存储课程名称，NOT NULL\r\n约束表示不能为空。\r\ncredit 列：数据类型为\r\nTINYINT ，用于记录课程学分，NOT NULL\r\n约束要求不能为空。CHECK 约束限定学分在 1 到 5\r\n之间，符合常见课程学分设置范围。\r\ndepartment_id 列：数据类型为\r\nINT ，用于存储课程所属系部的编号，NOT NULL\r\n约束表示不能为空。通过 FOREIGN KEY 约束引用\r\ndepartments 表中的 department_id\r\n，建立与系部表的关联，保证课程所属系部编号在系部表中存在。\r\n\r\nCREATE TABLE enrollments (    enrollment_id INT AUTO_INCREMENT PRIMARY KEY,    student_id CHAR(10) NOT NULL,    course_code VARCHAR(10) NOT NULL,    semester VARCHAR(20) NOT NULL,    grade CHAR(2) CHECK (grade IN (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;F&#x27;, NULL)),    UNIQUE KEY (student_id, course_code, semester),    FOREIGN KEY (student_id) REFERENCES students(student_id),    FOREIGN KEY (course_code) REFERENCES courses(course_code));\r\n\r\nenrollment_id 列：数据类型为\r\nINT\r\n，设置为自增长（AUTO_INCREMENT），作为选课记录的唯一标识，是该表的主键。\r\nstudent_id 列：数据类型为\r\nCHAR(10) ，用于记录选课学生的编号，NOT NULL\r\n约束表示不能为空。通过 FOREIGN KEY 约束引用\r\nstudents 表中的 student_id\r\n，确保选课学生编号在学生表中存在。\r\ncourse_code 列：数据类型为\r\nVARCHAR(10) ，用于记录所选课程的代码，NOT NULL\r\n约束表示不能为空。通过 FOREIGN KEY 约束引用\r\ncourses 表中的 course_code\r\n，保证所选课程代码在课程表中存在。\r\nsemester 列：数据类型为\r\nVARCHAR(20) ，用于记录选课的学期，NOT NULL\r\n约束表示不能为空。\r\ngrade 列：数据类型为\r\nCHAR(2) ，用于记录学生该课程的成绩。CHECK\r\n约束限定成绩只能是\r\n'A'、'B'、'C'、'D'、'F'\r\n或空值，符合常见成绩记录规则。\r\nUNIQUE KEY (student_id, course_code, semester)：组合唯一键约束，确保每个学生在每个学期对每门课程的选课记录唯一，防止重复选课记录出现。\r\n\r\n","categories":["学习类","数据库","MySql","MySql基础"],"tags":["实用知识","数据库","MySql","常用知识","语言基础"]},{"title":"Python常用模块之正则表达式与时间日期模块","url":"/posts/24790.html","content":"Python的模块、包和库\r\n\r\n模块（Module）通常以.py为扩展名，可以被其他程序通过import语句导入使用。\r\n包（Package）包含多个模块，必须包含一个特殊的__init__.py文件，这个文件可以为空，但它的存在表明这个目录可以被作为一个包来使用。\r\n库（Library）是一组完成特定功能的模块或包的集合，第三方库是Python强大生态系统的重要组成部分，它们提供了各种各样的工具和框架，使得Python成为一个功能丰富的编程语言。\r\n\r\nre模块\r\n\r\n使用 re\r\n模块来处理正则表达式，正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。\r\n\r\n简单的正则\r\n\r\n.：匹配除换行符 外的任意一个字符。\r\n\r\n^：匹配字符串的开头。\r\n$：匹配字符串的结尾。\r\n*：匹配前一个字符的0次或多次重复。\r\n+：匹配前一个字符的1次或多次重复。\r\n?：匹配前一个字符的0次或1次重复。\r\n{}：指定匹配次数的范围。\r\n[]：匹配方括号内的任意一个字符。注意：^放在[]内部时表示取反。\r\n：转义字符，用于匹配特殊字符本身。\r\n|：逻辑或，匹配两个模式中的任意一个。\r\n()：分组，用于限定匹配范围或指定优先级。\r\n\r\n字符类正则\r\n\r\n匹配任何十进制数字，等价于字符类 [0-9] 。\r\n：匹配任何非数字字符，等价于字符类 [^0-9] 。\r\n：匹配任何空白字符（空格），等价于字符类 [ 。\r\n：匹配任何非空白字符（不是空格），等价于字符类 [^ 。\r\n：匹配任何字母、数字、下划线字符，等价于字符类 [a-zA-Z0-9_] 。\r\n：匹配任何非字母、数字、下划线字符，等价于字符类 [^a-zA-Z0-9_]\r\n。\r\n\r\n应用实例：\r\n\r\n用户名验证：要求用户名只包含字母、数字和下划线\r\n密码格式验证：要求密码长度为8-12个字符\r\n手机号码验证：要求中国大陆的手机号码格式\r\n\r\nimport reresult=re.match(r&#x27;\\w+&#x27;,&#x27;455hj5h6_&#x27;)print(result)result1=re.match(r&#x27;^.&#123;8,12&#125;$&#x27;,&#x27;455hj5456&#x27;)print(result1)result2=re.match(r&#x27;^1[3-9]\\d&#123;9&#125;$&#x27;,&#x27;13755452515&#x27;)print(result2)\r\n正则表达式的应用\r\n\r\n数据清理：通过删除或替换不需要的字符、空格或符号来清理数据集。\r\n文本规范化：将文本数据标准化为一致的格式，例如将日期转换为标准格式或统一数值的表示。\r\n特征提取：从文本中提取可用作 ML 模型特征的特定模式或标记。\r\n数据验证：确保输入数据在输入模型之前符合指定的格式。\r\n标记化：将文本分割成单词、短语、符号或其他称为标记的有意义的元素。\r\n文本分类预处理：文本分类的预处理步骤，例如从社交媒体帖子中提取主题标签或提及。\r\n命名实体识别\r\n(NER)：识别文本中的关键元素并将其分类为预定义的类别，例如人名、组织或位置的名称。\r\n情绪分析：识别可能表明情绪的特定短语或符号。\r\n自动响应的模式匹配：识别客户查询或反馈中的模式以生成自动响应。\r\n搜索和信息检索：增强数据集中的搜索算法，以根据模式匹配查找信息或对信息进行分类。\r\n\r\n正则表达式编译成对象\r\n\r\nre\r\n模块提供了正则表达式引擎的接口，可以让你将正则编译为对象，然后用它们来进行匹配。\r\n\r\nimport rep = re.compile(&#x27;abv?&#x27;)r=p.match(&#x27;abvvvccabvvvc&#x27;)print(r)\r\n正则表达式对象常用的方法-查找\r\n\r\nmatch()：从字符串的开头匹配，返回一个匹配成功的字符串\r\nimport rep = re.compile(&#x27;abv?&#x27;)m_m = p.match(&#x27;abvvvccabvvvc&#x27;)print(m_m)#相当于，等价于m_rm = re.match(&#x27;abv?&#x27;, &#x27;abvvccabvvvc&#x27;)print(m_rm)\r\nsearch()：扫描整个字符串，返回一个匹配成功的字符串。\r\nimport rep = re.compile(&#x27;abv?&#x27;)m_p = p.search(&#x27;vvccabvvvc&#x27;)print(m_p)#相当于，等价于m_rp = re.search(&#x27;abv?&#x27;, &#x27;vvccabvvvc&#x27;)print(m_rp)\r\nmatch和search的区别：\r\n\r\nmatch是从头开始匹配的，如果没有则匹配失败\r\nsearch是匹配整个字符串，没有位置限定\r\n\r\nfindall()：找到正则匹配的所有子字符串，返回字符串列表。\r\np1 = re.compile(r&#x27;\\d+&#x27;)m_f = p1.findall(&#x27;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#x27;)print(m_f)##相当于，等价于m_rf = re.findall(r&#x27;\\d+&#x27;, &#x27;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#x27;)print(m_rf)\r\nfinditer()：找到正则匹配的所有子字符串，并将它们返回为一个迭代器iterator。\r\n\r\niterator_f = p1.finditer(&#x27;12 drummers drumming, 11 ... 10 ...&#x27;)print(iterator_f)for m in iterator_f:    print(m.span())    #相当于，等价于    iterator_rf = re.finditer(r&#x27;\\d+&#x27;, &#x27;12 drummers drumming, 11 ... 10 ...&#x27;)print(iterator_rf)for mr in iterator_rf:    print(mr.span())\r\n正则表达式对象常用的方法-替换\r\n\r\nre.sub(pattern, repl, string, count=0,\r\nflags=0)：返回已替换的字符串中的匹配项。\r\nre.subn(pattern, repl, string, count=0,\r\nflags=0)：返回一个元组，元组的第一项为替换的字符串，第二项为替换了几处。\r\n\r\ntext = &quot;aBc,ABC,aBfD&quot;result = re.sub(&#x27;aBc?&#x27;, &#x27;***&#x27;, text)print(result)result_n = re.subn(&#x27;aBc?&#x27;, &#x27;***&#x27;, text)print(result_n)\r\n正则表达式对象常用的方法-分割\r\n\r\nre.split(pattern, string, maxsplit=0,\r\nflags=0)：返回根据指定的正则表达式分割后的字符串\r\n\r\nstext =  &#x27;and,  Act %  Bar。 fooD&#x27;result_s = re.split(r&#x27;\\s*[,%。]\\s*&#x27;, stext)print(result_s)\r\n输出正则表达式对象的值和位置\r\n\r\nm.group()：返回正则匹配的字符串\r\nm.start()：返回匹配的开始位置\r\nm.end()：返回匹配的结束位置\r\nm.span()：返回包含匹配 (start, end) 位置的元组\r\n\r\nm2 = m_m.group()print(m2)m22 = m_rm.group()print(m22)# m3 = m_m.start()# print(m3)\r\n正则表达式方法中的flags参数\r\n\r\nre.I(re.IGNORECASE)：忽略大小写。\r\nimport repattern = r&#x27;hello&#x27;text = &#x27;Hello, World!&#x27;match = re.search(pattern, text, flags=re.I)print(match.group())# Hello\r\nre.S(re.DOTALL)：使 . 匹配任意字符，包括换行符。\r\nimport repattern = r&#x27;hello.+world&#x27;text = &#x27;&#x27;&#x27;helloworld&#x27;&#x27;&#x27;match = re.search(pattern, text, flags=re.s)print(match.group()) # hello# world\r\nre.M(re.MULTILINE)：多行匹配，影响 ^ 和 $ 的行为。\r\nimport re# text = &#x27;123\\n456\\n789&#x27;text = &#x27;&#x27;&#x27;123456789&#x27;&#x27;&#x27;result = re.findall(r&#x27;^\\d+&#x27;, text, flags=re.MULTILINE)print(result)  # [&#x27;123&#x27;, &#x27;456&#x27;, &#x27;789&#x27;]\r\nre.X(re.VERBOSE)：忽略正则表达式中的空白和注释。\r\nimport repattern = re.compile(r&#x27;&#x27;&#x27;    \\d+  # 匹配数字    [a-z]+  # 匹配小写字母&#x27;&#x27;&#x27;, flags=re.VERBOSE)result = pattern.match(&#x27;123abc&#x27;)print(result.group())  # 123abc\r\n\r\n贪婪匹配和惰性匹配\r\n\r\n贪婪匹配（Greedy）是正则表达式默认的匹配方式，它尽可能地匹配最长的字符串。\r\n懒惰匹配（Lazy），也称为非贪婪匹配，它尽可能地匹配最短的字符串。\r\n\r\nimport rep = &quot;讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 https://xinghuo.xfyun.cn/ 2024-04-11 10:07:25&quot;#贪婪匹配G = re.match(r&#x27;讯飞.*大模型&#x27;, p)print(G.group())#懒惰匹配L = re.match(r&#x27;讯飞.*?大模型&#x27;, p)print(L.group())# 讯飞星火认知大模型-AI大语言模型-星火大模型# 讯飞星火认知大模型\r\n综合案例：\r\n处理数据集：用正则表达式将所有的文本数据中的逗号替换成空格，文本文件为‘re.txt’\r\nimport rewith open(input_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:    content = f.read()        # 使用正则表达式替换逗号processed_content = re.sub(r&#x27;,&#x27;, &#x27; &#x27;, content)        # 写入新文件with open(output_file, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f.write(processed_content)\r\n用正则式匹配身份证号\r\nimport re&#x27;&#x27;&#x27;各部分说明：[1-9]\\d&#123;5&#125;: 地区码，第一位不能为0(19|20): 年份前两位\\d&#123;2&#125;: 年份后两位(0[1-9]|1[0-2]): 月份01-12(0[1-9]|[12]\\d|3[01]): 日期01-31\\d&#123;3&#125;: 序号[0-9Xx]: 校验码&#x27;&#x27;&#x27;res=re.match(r&#x27;^[1-9]\\d&#123;5&#125;(19|20)\\d&#123;2&#125;(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;[0-9Xx]$&#x27;,&#x27;110101199003079833&#x27;)print(res)\r\ntime（时间）模块与\r\ndatetime（日期）模块\r\ntime（时间）模块\r\n\r\nUTC时间：世界时间\r\n本地时间：本地区的时间（东8区）\r\ntime模块：https://docs.python.org/3/library/time.html#module-time\r\ndatetime模块：https://docs.python.org/3/library/datetime.html#\r\n\r\nimport time#时间戳timestamp = time.time()print(timestamp) #1970年1月1日0时0分0秒（UTC时间）到当前时间的秒数\r\n时间戳一般用于计算时间差的\r\n#控制程序的执行速度或者模拟耗时操作print(&quot;某主播说：家人们，马上开始下福袋雨了啊！&quot;)time.sleep(3)print(&quot;福袋1发布&quot;)time.sleep(3)print(&quot;福袋2发布&quot;)time.sleep(3)print(&quot;福袋3发布&quot;)time.sleep(3)print(&quot;福袋4发布&quot;)\r\ndatetime（日期）模块\r\ndatetime 是 Python\r\n内置的用于处理日期和时间的模块，提供了多种类和方法来操作时间数据。\r\nfrom datetime import datetimet = datetime.now()print(t, type(t))   #注意这里的时间不是字符串，是一个datetime类型\r\n# 获取 datetime 对象的各个部分print(t.year)    # 年：2025print(t.month)   # 月：5print(t.day)     # 日：14print(t.hour)    # 时：14print(t.minute)  # 分：30print(t.second)  # 秒：22\r\ntimedelta 表示两个 datetime\r\n对象之间的时间差，可用于时间的加减运算。\r\nfrom datetime import datetime,timedeltav1 = datetime.now()print(v1, type(v1)) #时间的相加（datetime + timedelta）v2 = v1 + timedelta(days=15, minutes=5)print(v2, type(v2))\r\n\r\ndatetime类型可以相加吗？等于什么？ datetime 对象本身不能直接相加\r\n但可以和 timedelta 对象相加，结果是一个新的 datetime 对象\r\ndatetime类型可以相减吗？等于什么？ datetime 可以减去另一个\r\ndatetime，得到 timedelta 对象（表示时间差） datetime 也可以减去\r\ntimedelta，得到新的 datetime 对象\r\n\r\n使用\r\nstrftime 方法将 time 对象 和 datetime 对象格式化为字符串\r\n\r\n%Y：大写 Y 代表四位数的年份（例如，2023）； %y：小写 y\r\n代表两位数的年份（例如，23）。\r\n%m：小写 m 代表月份（01到12）。\r\n%d：小写 d 代表月份中的一天（01到31）。\r\n%H：大写 H 代表小时（24小时制，00到23）。\r\n%M：大写 M 代表分钟（00到59）。\r\n%S：大写 S 代表秒（00到59）。\r\n\r\nfrom datetime import datetime, timedeltad1 = datetime.now()print(d1) dstr = d1.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)print(dstr)import timecurrent_time = time.localtime()  # 获取当前时间print(current_time, type(current_time))tstr = time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;, current_time)print(tstr)\r\n日期解析（strptime）\r\n解析（str →\r\ndatetime）：\r\ndate_str = &quot;2025-05-14 14:30:22&quot;parsed = datetime.strptime(date_str, &quot;%Y-%m-%d %H:%M:%S&quot;)  # 转为 datetimeprint(parsed, type(parsed))  # 输出：2025-05-14 14:30:22 &lt;class &#x27;datetime.datetime&#x27;&gt;\r\n时区处理\r\n默认的 datetime\r\n对象是无时区信息的（tzinfo=None）。如需处理时区，可使用\r\npytz 或 Python 3.9+ 内置的 zoneinfo 模块：\r\nfrom datetime import datetimefrom zoneinfo import ZoneInfo  # Python 3.9+# 创建带时区的 datetime 对象now_utc = datetime.now(ZoneInfo(&quot;UTC&quot;))now_shanghai = datetime.now(ZoneInfo(&quot;Asia/Shanghai&quot;))print(now_utc.tzinfo)    # 输出：UTCprint(now_shanghai)      # 输出：2025-05-14 22:30:22+08:00\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的推导式、迭代器和生成器","url":"/posts/9954.html","content":"Python推导式\r\n\r\n列表推导式: [expression for item in iterable]\r\n集合推导式: &#123;expression for item in iterable&#125;\r\n字典推导式:\r\n&#123;key_expression: value_expression for item in iterable&#125;\r\nitem是一个变量，用于遍历iterable中的元素\r\n\r\n#列表推导式：list_com = [x**2 for x in range(10) if x**2 &lt; 40]list_com# [0, 1, 4, 9, 16, 25, 36]#集合推导式 ,代表什么意思set_com = &#123;x**2 if x**2 % 2==0 else x**2 + 1 for x in range(10)&#125;set_com# &#123;0, 2, 4, 10, 16, 26, 36, 50, 64, 82&#125;#字典推导式dict_com = &#123;x: x**2 for x in range(10) if x != 3&#125;dict_com# &#123;0: 0, 1: 1, 2: 4, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125;\r\n推导式中添加if判断的语法：\r\n在 Python\r\n推导式中，if判断有两种用法，分别用于过滤元素和条件赋值\r\n\r\nif condition 用于过滤元素\r\n语法：[expression for item in iterable if condition]\r\n作用：只保留满足condition的元素，类似筛选\r\n# 生成偶数列表evens = [x for x in range(10) if x % 2 == 0]# 等价于：[0, 2, 4, 6, 8]\r\nif-else 表达式用于条件赋值\r\n语法：[expression if condition else expr_else for item in iterable]\r\n作用：根据condition的结果，为每个元素选择不同的表达式值。\r\n# 将负数转换为 0，正数保持不变：nums = [-1, 2, -3, 4]result = [x if x &gt;= 0 else 0 for x in nums]# 等价于：[0, 2, 0, 4]\r\n\r\n# `L = [&#x27;Hello&#x27;, &#x27;World&#x27;, 18, &#x27;Apple&#x27;, None]`将字符串中字母变为小写，其余元素不变。L = [&#x27;Hello&#x27;, &#x27;World&#x27;, 18, &#x27;Apple&#x27;, None]#第一种解法：[L[i].lower() if type(L[i]) is str else L[i] for i in range(5)]#isinstance(x, str)#第二种解法[x.lower() if isinstance(x, str) else x for x in L]# `keys = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]` `values = [1, 2, 3]`，根据给出的keys和values，用字典推导式生成新字典。keys = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]values = [1, 2, 3]#第一种解法&#123;keys[i]: values[i] for i in range(len(keys))&#125;#第二种解法&#123;k: v for k, v in zip(keys, values)&#125;# `words = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;, &#x27;you&#x27;]`，用集合推导式求出words中的元素长度都有哪些。words = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;, &#x27;you&#x27;]&#123;len(x) for x in words&#125;\r\nPython迭代器和可迭代对象\r\n\r\n迭代器：它是一个对象，它实现了__iter__() 和\r\n__next__()方法。\r\n可迭代对象：只实现了__iter__() 方法。\r\n\r\n__iter__() 方法返回迭代器对象本身，而\r\n__next__()\r\n方法返回容器中的下一个值。当没有更多的元素时，__next__()方法则抛出一个\r\nStopIteration 异常。\r\n原来我们如何判断一个对象是不是可迭代对象呢？\r\nfrom collections.abc import Iterable, Iteratorprint(isinstance([1, 2, 3], Iterable))#  使用 isinstance() 函数检查列表 [1, 2, 3] 是否是可迭代对象print(isinstance([1, 2, 3], Iterator))#  检查这个对象是否是一个迭代器\r\n按照定义，我们分别自己创建①可迭代对象和②迭代器对象。\r\n#①class Color():    def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):        pass\r\n#②class Color(object):    def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):        return self    def __next__(self):        self.index += 1        if self.index &gt;= len(self.colors):            raise StopIteration        return self.colors[self.index]\r\n#用类实现__iter__方法class Color():        def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):        pass#         return self#创建对象c1_object = Color()# 判断是否为可迭代对象print(isinstance(c1_object, Iterable))       # True# 判断是否为迭代器print(isinstance(c1_object, Iterator))    # False\r\nclass Color():    def __init__(self):        self.colors = [&#x27;red&#x27;, &#x27;white&#x27;, &#x27;black&#x27;, &#x27;green&#x27;]    def __iter__(self):# 返回迭代器对象本身，使得Color类的实例成为一个迭代器         return self            def __next__(self):         self.index += 1         if self.index &gt;= len(self.colors):             raise StopIteration         return self.colors[self.index]    #创建对象c2_object = Color()# 判断是否为可迭代对象print(isinstance(c2_object, Iterable))        # True# 判断是否为迭代器print(isinstance(c2_object, Iterator))      # True\r\n列表、集合和字典迭代器：\r\n\r\n用内置函数iter()生成对应的迭代器\r\n再用内置函数next()迭代数据\r\n\r\nli = [1, 2, 3]   #&#123;1: &#x27;k&#x27;, 2: &#x27;l&#x27;, 3: &#x27;p&#x27;&#125; #iter_lio = iter(li)# for i in iter_lio:#     print(i)next(iter_lio)next(iter_lio)next(iter_lio)\r\n注意事项：\r\n\r\n迭代器或生成器遍历完一遍之后，不能再次遍历；若想再次遍历需要重新生成另外的迭代器或生成器。\r\n\r\n用for循环迭代输出列表和列表迭代器，输出的都是一样的吗？如果一样，那为什么还要使用迭代器呢？\r\n\r\n使用 for\r\n循环迭代列表和直接使用列表迭代器，其输出结果相同，但迭代器有其独特优势。迭代器支持懒加载，按需生成数据，节省内存，特别适用于处理大数据集。它们能够维护状态，记住迭代位置，实现多次迭代，并提供可扩展性，允许自定义迭代行为。迭代器在逐行读取大文件或处理流数据时尤为有用，因为它们不需要一次性加载所有数据。总之，迭代器是\r\nPython 中实现高效和灵活数据处理的关键工具。\r\n\r\nimport timestart = time.time()li = [x for x in range(1,10)]#[1,2,3,4,5] #[x for x in range(1,6)]for i in li:     print(i)print(f&quot;li:&#123;time.time() - start&#125; s&quot;)    start2 = time.time()my_li = iter(li)for j in my_li:     print(j)print(f&quot;my_li:&#123;time.time() - start2&#125; s&quot;)\r\n常用的迭代器函数\r\n\r\nrange(start, stop, step)\r\nzip(*iterables, strict=False)\r\nstrict默认匹配元素的最短长度，多余的自动忽略\r\nmap(function, iterable)\r\n将函数应用于一个或多个可迭代对象的每一项\r\nenumerate(iterable, start=0)\r\n返回一个枚举对象,start是默认的起始索引\r\nisinstance(z, Iterator) 的作用是判断变量 z\r\n是否是一个迭代器。如果是迭代器，返回 True；否则返回 False。\r\n\r\n#zip()迭代器li0 = [1, 2, 3]li1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]z = zip(li0, li1)z0 = zip(li0, li1)print(isinstance(z, Iterator), z)#直接用for循环遍历for i in z:    print(&#x27;i--:&#x27;, i)#或者把迭代器放到容器中lz = list(z0)for j in lz:    print(&#x27;j--:&#x27;, j)   # 使用zip将两个列表组合names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]ages = [25, 30, 35]for name, age in zip(names, ages):    print(f&quot;&#123;name&#125; is &#123;age&#125; years old.&quot;)\r\n#map()传一个可迭代对象# import mathnum = [4, 9, 1, 16, 7] #推导式def a(x):    return x**0.5num_map = map(a, num) #math.sqrtlist(num_map)#map()传多个可迭代对象num = [4, 9, 1, 16, 7]def mysquare():    for i in range(5):        yield i**2squa = mysquare() # 创建生成器对象squa，调用生成器函数mysquaredef add(x, y):    return x + yadd_map = map(add, num, squa)  #匿名函数 lambda x, y: x+ylist(add_map)\r\n#enumeratefrom collections.abc import Iterable, Iteratorseasons = [&#x27;Spring&#x27;, &#x27;Summer&#x27;, &#x27;Fall&#x27;, &#x27;Winter&#x27;]enu = enumerate(seasons)  # start = 1print(isinstance(enu, Iterator))for i in enu:    print(i)\r\n生成器和生成器表达式\r\n\r\n生成器是一种特殊的迭代器。\r\n生成器表达式就是推导式把外包围换成小括号。但推导式是一次生成数据，数据量太大的情况下，生成器表达式对内存更友好。\r\n\r\n#使用yield语句\\关键字，只能在函数内部定义def reverse(data):    # 使用 for 循环遍历 data 的索引，从最后一个元素开始向前遍历到第一个元素    for index in range(len(data)-1, -1, -1):        yield data[index]        for char in reverse(&#x27;Python！&#x27;):    print(char)\r\n#生成器例子：def generate_squares():    for i in range(4):        yield i**2 # 每次生成一个平方数，并暂停函数执行，直到下一次调用ge = generate_squares()# 检查ge是否是迭代器（Iterator），并打印生成器对象print(isinstance(ge, Iterator), ge)# 第一次运行生成器for i in ge:    print(i)# 第二次运行生成器ge = generate_squares()for i in ge:    print(i)#或者把迭代器放到容器中gg = list(ge)\r\n#生成器表达式la = (2**x for x in range(8))list(la)# 生成一个以3为底，5到60为幂次的生成器。xx = (3**x for x in range(5, 61))list(xx)  #生成器要显示输出结果，需要用构造函数转换输出\r\n练习：\r\n\r\nstr_p = ['xiAoMi', 'HUawEi', 'BaIdu', 'xUnFEi']，使用map()把列表中的字符串都变为小写字母。\r\nstr_p = [&#x27;xiAoMi&#x27;, &#x27;HUawEi&#x27;, &#x27;BaIdu&#x27;, &#x27;xUnFEi&#x27;]def ss(s):    return s.lower()p = list(map(ss, str_p))\r\ndic = &#123;'a': 11, 'b': 20, 'c': 99, 'd': 67&#125;，用enumerate()输出字典的索引（从1开始）和对应的键值对。\r\ndic = &#123;&#x27;a&#x27;: 11, &#x27;b&#x27;: 20, &#x27;c&#x27;: 99, &#x27;d&#x27;: 67&#125;for i, (key, value) in enumerate(dic.items(), start=1):    print(i, key, value)\r\na1 = [1, 0, 3, 5] a2 = [2, 10, 11, 4]\r\na3 = [3, 6, 7, 18]\r\n，要求返回三个列表元素的总和，使用map()和zip()。\r\na1 = [1, 0, 3, 5]a2 = [2, 10, 11, 4]a3 = [3, 6, 7, 18]# 使用zip()函数将三个列表组合成一个元组序列zipped = zip(a1, a2, a3)# 使用map()函数对每个元组中的所有元素求和summed = list(map(sum, zip(a1, a2, a3)))\r\ntup = (1,2,3,4,5,6,7)，要求把tup元组中所有偶数位置上的元素都改为0，返回处理后的新元组。\r\ntup = (1,2,3,4,5,6,7)tuple(0 if i%2==0 else j for i,j in enumerate(tup))\r\n\r\n总结\r\n\r\n什么情况下用推导式？\r\n\r\n\r\n基于现有序列的简单变换和过滤后创建新的序列：当你需要对一个序列进行简单的变换（如乘以2、取平方等）或过滤（如只选择大于某个值的元素）时，推导式可以提供一种更简洁、更易读的方式来创建新的序列。\r\n需要一次性生成整个序列：当你需要生成的序列不是特别大，且可以一次性加载到内存中时，推导式是一个好选择。\r\n\r\n\r\n什么情况下用生成器？\r\n\r\n\r\n处理大数据集：当你处理的数据集非常大，一次性加载到内存中不现实时，生成器可以按需生成数据，从而节省内存。\r\n需要一个按需生成元素的序列：生成器非常适合于那些元素生成过程复杂或耗时的情况，因为它可以延迟计算，直到元素实际需要时才生成。\r\n\r\n\r\n什么情况下用迭代器？\r\n\r\n\r\n需要遍历容器中的所有元素：当你需要遍历一个容器中的所有元素时，迭代器提供了一种高效的方法。\r\n尤其是不需要一次性将所有元素加载到内存中时：迭代器允许你逐个访问元素，而不需要将整个容器加载到内存中，这对于处理大型数据集特别有用。\r\n\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的数据类型","url":"/posts/58610.html","content":"Python的数据类型\r\n\r\n数值（Numbers）\r\n字符串（String）\r\n元组（Tuple）\r\n列表（List）\r\n集合（Set）\r\n字典（Dictionary）\r\n……\r\n其他数据类型\r\n\r\n字节类型（Bytes）：b’Hello’\r\n字节数组（Byte Arrays）： bytearray(b’Hello’)\r\n空类型（None）：没有返回的函数值\r\n未执行的（NotImplemented）：在运算时，对象不支持，返回该值\r\n省略号（Ellipsis）：用于Numpy的切片或者表示无限循环\r\n\r\n\r\nPython数据类型-数值型\r\nPython数值型介绍\r\n\r\n整型（int）：123\r\n布尔型（bool）：False(0)、True(1)\r\n浮点型（float）：123.04\r\n复数型（complex）：3 + 7j、real + imagj\r\n\r\n复数的一些常见应用场景包括：\r\n\r\n工程学：在电气工程中，复数用于分析交流电路，其中电压和电流随时间变化。复数使得可以轻松地处理电路中的电阻、电感、电容和它们的相位关系。\r\n物理学：在量子力学中，波函数通常是复数。复数用于描述粒子的位置和动量等物理量。\r\n数学：在纯数学中，复数用于解决不能在实数域内解决的问题，如在复平面上分析多项式方程的根。\r\n信号处理：在数字信号处理中，复数用于表示频率和相位信息，以及进行傅里叶变换等操作。\r\n计算机图形学：复数可以用于计算二维图形的旋转和平移。\r\n其中的虚部j表示乘以根号下-1（即虚数单位），这意味着这个复数在复平面上距离原点3个单位向右（实部），4个单位向上（虚部）。\r\n\r\n对象由identity、type和value标识\r\na = b = c = d = print(id(a), type(a), a)print(id(b), type(b), b)print(id(c), type(c), c)print(id(d), type(d), d)\r\n\r\n\r\nimage-20250513195950732\r\n\r\nPython整数的存储\r\n在内存中，变量存放到栈区，相对应的数据存放到常量区或堆区。\r\n整型有一个“小整数池”（small integer pool）\r\n\r\n这个区域是为了快速访问和存储小整数而设计的，它是一个固定的范围，用于缓存频繁使用的小整数。\r\n整型的缓存区范围通常为[-5,256]\r\n不同版本的python范围可能稍有不同\r\n\r\n如果变量值是整数且不在“小整数池”的范围呢？如果是浮点型、布尔型或复数型呢？\r\n新创建的变量和原来的id还会一样吗？\r\nx = 10 + 9jy = 10 + 9jprint(id(x))print(id(y))# del x# del yq = 10 + 9jprint(id(q))\r\ndef ppoi():    x = 980 + 23j    y = 980 + 23j    print(id(x))    print(id(y))    del x    del y    q = 980 + 23j    print(id(q))    ppoi()\r\ndef ppoi():    x = 287    y = 287    print(id(x))    print(id(y))#     del x#     del y    def ppo():    q = 287    print(id(q))    ppoi()ppo()\r\nPython的交互模式下，一行一行执行代码\r\n\r\n不会检查内存中是否存在相同的变量值，所以相同的变量值也可能会出现id值不同。\r\n\r\n若在同一个代码块中\r\n\r\n首先检查内存中是否存在当前变量值，若存在则直接指向；若不存在会重新分配空间。\r\n\r\n总结：\r\n\r\n常量区的数据范围为[-5,256]，此区域内的数据有驻留机制\r\n堆区的数据：在一个代码块中，数据的地址会暂时存储不被垃圾回收；不同代码块则会重新分配\r\n\r\n类型转换函数 （类似构造函数）\r\n\r\nint() int()函数主要用于将一个值转换为整数\r\n\r\n浮点数转换时，向下取整。\r\n布尔值转换时，True对应1，False对应0。\r\n复数只有当虚数部分为0时才能转换，例如3+0j。\r\n参数为字符串时，字符串内容必须为整数值。\r\nf1 = float(120)print(f1)f2 = float(True)print(f2)f3 = float(&#x27;120&#x27;)print(f3)f4 = float(&#x27;Infinity&#x27;)#无穷大print(f4)f5 = float(&#x27;NaN&#x27;)print(f5)\r\n\r\nbool()\r\n\r\n\r\nimage-20250513200511537\r\n\r\nfloat()\r\ncomplex()\r\n#布尔类型b1 = bool(0) # 0和1print(b1)b2 = bool(98)# &#x27;xyz123&#x27;print(b2)#复数类型c1 = complex(3, 5)print(c1)\r\n\r\n一些问题\r\n1.整型之间进行（加,减,乘,除,取余,幂次）运算，最后得到的是整型吗？\r\n2.浮点型之间进行（加,减,乘,除,取余,幂次）运算，最后得到的是浮点型吗?\r\n3.布尔型变量之间可以进行布尔运算，整型和浮点型变量之间可以吗？\r\n4.复数型的实部和虚部具体是什么数据类型？\r\nPython数据类型-字符串\r\nPython字符串介绍\r\n字符串是什么？\r\n\r\n字符串是一种以Unicode编码的序列，是一种\r\n有顺序 的 不可变 的序列。 Unicode\r\n规范https://www.unicode.org/\r\n旨在罗列人类语言所用到的所有字符，并赋予每个字符唯一的编码。该规范一直在进行修订和更新，不断加入新的语种和符号。\r\n\r\n字符串的创建\r\n\r\n用单引号、双引号或三引号包围起来创建字符串。\r\n\r\n单引号受限制的情况下，需要用双引号或三引号\r\n\r\n#单引号受限制的情况,字符串中包含单引号# str1 = &#x27;He&#x27;s a good boy.&#x27;#改成双引号：message = &quot;He&#x27;s a good boy.&quot;print(message)#改成三引号：三引号（&#x27;&#x27;&#x27; 或 &quot;&quot;&quot;）可以用来定义多行字符串，# 也可以用来避免单引号和双引号的冲突message = &quot;&quot;&quot;He&#x27;s a &quot;good&quot; boy.&quot;&quot;&quot;print(message)#长字符串中间有换行的可以用三引号word = &#x27;&#x27;&#x27;Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.&#x27;&#x27;&#x27;\r\n\r\n字符串中包含双引号则可以用单引号包围\r\n如下情况必须使用三引号\r\n\r\n字符串中既包含单引号又包含双引号时\r\n作为文档字符串时\r\n定义多行字符串时\r\n\r\n\r\n\r\n#1. 例如&quot;It&#x27;s my book.&quot;、    &quot;hello&#x27;p&#x27;ython&quot;、    &quot;o&#x27;&quot;str4 = &#x27;&#x27;&#x27;&quot;It&#x27;s my book.&quot;&#x27;&#x27;&#x27; print(str4)#2. 在Python中，函数、类的开头可以包含一个文档字符串，用于说明代码的用途和行为。def my_function():    &quot;&quot;&quot;这是一个文档字符串，用三引号包围，用于解释函数的用途。&quot;&quot;&quot;    pass#3. 多行的字符串：黄河之水天上来，奔流到海不复回。str5 = &quot;&quot;&quot;黄河之水天上来，奔流到海不复回。&quot;&quot;&quot;print(str5)\r\n\r\n用类型构造函数str()创建字符串\r\n#数值型转化为字符串a = 123print(a, type(a))str6 = str(a)print(str6, type(str6))\r\n\r\n转义字符\r\n\r\n以\\开头的字符叫转义字符，通过转义字符可以正确表示具有二义性的字符或无法显示的控制字符。\r\n例如：It's my book.中的'既是普通字符又是标识字符串的符号。\r\n在'前加上\\，可以使字符仅作为普通字符出现，避免二义性。\r\n\r\n#打印字符串&quot;Let&#x27;s go!&quot;print(&#x27;&quot;Let\\&#x27;s go!&quot;&#x27;)print(&quot;\\&quot;Let&#x27;s go!\\&quot;&quot;)\r\n常用的转义字符：\r\n\r\n\\n（换行符）\r\n\\t（Tab制表符）\r\n\\r（回车）\r\n\\'（单引号）\r\n\\\"（双引号）\r\n\\\\（反斜线）\r\n\r\nPEP8规范建议：\r\n为了增加代码的可读性，对于字符串内部的引号，尽量使用与内部不同的引号标识字符串，而不是使用转义字符。\r\n如果不想让转义字符生效，怎么办？\r\n#在字符串前面加r或Rprint(r&#x27;D:\\thedir\\one\\now&#x27;)print(R&#x27;D:\\thedir\\two\\now&#x27;)\r\n字符串的索引和切片\r\n1.通过索引获取字符串中的元素\r\n\r\n正索引：元素位置（下标）从左往右从0开始，依次递增。\r\n负索引：元素位置（下标）从右往左从-1开始，依次递减。\r\n\r\n\r\n\r\nimage-20250513201552242\r\n\r\n2.切片是一种高级索引\r\n切片可以灵活获取字符串的多个元素\r\n#切片操作尝试s = &quot;string&quot;s[1:3]#字符串的切片操作s = &quot;string&quot;#步长为正数的情况：print(s[::2])#步长为负数的情况：print(s[1::-1])\r\n切片的定义：\r\n切片是用于截取索引片段获得序列中元素的方法。\r\n切片的表示形式：\r\nsequence[start : end : step]\r\nstart→起始索引值，省略时代表索引值为0；\r\nend→结束索引值（不包含在内），省略时代表索引值为end+1；\r\nstep→步长，两个相邻元素间的步长为1，步长为1时可省略。步长为负数时，反转序列。\r\nstep的两个重要功能：\r\n\r\n跳过某些元素\r\n反转序列\r\n\r\n注意：\r\n字符串是不可变的，不能用索引和切片给字符串重新赋值。\r\n索引和切片总结：\r\n\r\n索引只能获取单个元素，切片可以获取多个元素。\r\n切片适用于所有序列，不仅仅是字符串。\r\n字符串不可变，不能用索引或切片给字符串重新赋值。\r\n\r\n字符串的拼接\r\n\r\n用 + 拼接\r\n用 * 拼接\r\n格式化拼接 %\r\n格式化拼接 format()\r\n格式化拼接 f-string（Python 3.6及更高版本）\r\njoin()方法\r\n\r\n#用+拼接两个字符串str1 = &quot;hello&quot;str2 = &quot;你好&quot;str3 = str1 + str2print(str3)#重复操作符（`*`）：用于将字符串重复指定次数str0 = &#x27;s+&#x27;str1 = str0 * 20print(&#x27;str1:&#x27;,str1)str2 = str0 * -2print(&#x27;str2:&#x27;,str2)#格式化拼接name = &#x27;Mary&#x27;city = &#x27;New York&#x27;age = &#x27;thirty years old&#x27;#%letter = &#x27;My name is %s, and I come from %s&#x27; % (name, city) print(letter)#format()answer = &#x27;Hi,&#123;&#125;, I also come from &#123;&#125;&#x27;.format(name, city)print(answer)#f-stringmessage = f&quot;Her name is &#123;name&#125;, and she is &#123;age&#125; years old.&quot;print(message)\r\nformat()更多用法：\r\n\r\nprint(\"My name is &#123;1&#125; and I am &#123;0&#125; years old.\".format(age, name))\r\n#位置索引占位符\r\nprint(\"My name is &#123;name&#125; and I am &#123;age&#125; years old.\".format(name=name, age=age))\r\n#指定变量名\r\nprint(\"The value of pi is approximately &#123;:.2f&#125;.\".format(num))\r\n#格式化数字： {:,}千位符\r\n\r\njoin()的语法格式：\r\nstr.join(iterable)\r\n其中str是分隔符，用于连接iterable中的元素。\r\nstr.join(iterable)s = &#x27; &#x27;  #使用空格做分隔符say1 = (&#x27;长路&#x27;, &#x27;漫漫&#x27;, &#x27;,&#x27;, &#x27;其修&#x27;, &#x27;远兮&#x27;)#[&#x27;长路&#x27;, &#x27;漫漫&#x27;, &#x27;，&#x27;, &#x27;其修&#x27;, &#x27;远兮&#x27;] say2 = s.join(say1)print(say2)def re(str1, str2):    str1 = str1[::-1]    str2 = str2[::-1]#     s0 = &#x27;Reverse:&#x27; + str1 + &#x27; &#x27; + str2    #用+拼接#     s1 = &#x27; &#x27;.join((str1, str2))#     ss1 = &#x27;Reverse:&#x27; + s1         #用join拼接法        #格式化拼接方法：    #     return f&#x27;Reverse:&#123;str1&#125; &#123;str2&#125;&#x27;   #     return &#x27;Reverse:%s %s&#x27; % (str1, str2)#     return &#x27;Reverse:&#123;&#125; &#123;&#125;&#x27;.format(str1, str2)    return ss1aa = re(&#x27;one&#x27;,&#x27;two&#x27;)\r\n总结：\r\n\r\n+拼接方法，常用于字符串变量之间的相加。\r\n\r\n格式化拼接方法，代码具有可读性和可维护性。\r\n\r\njoin()方法，适用于拼接的字符串较多时。\r\n\r\n成员关系操作符（in、not\r\nin）\r\n\r\n成员关系运算符用来判断一个字符串是否包含在另一个字符串中。\r\n\r\nv_str = &#x27;water.tif, app.jpg, wechat.png, google.gif, football.jfif&#x27;# print(&#x27;.psd&#x27; in v_str)# print(&#x27;.psd&#x27; not in v_str)#空字符串呢？print(&#x27;&#x27; not in v_str)print(&#x27;&#x27; in v_str)\r\n字符串对象的常用方法\r\n- 字符串类型判断\r\ns.isnumeric() #是否只包含数字字符s.isalpha()  #是否全为字母s.islower()  #字母是否全为小写s.isupper()  #字母是否全为大写\r\n\r\n字符串大小写转换\r\n\r\ns.lower()  #转为小写s.upper()  #转为大写s.swapcase()  #大小写呼唤s.capitalize() #在整个字符串中首字母大写，其余小写s.title()  #对每个字符串中的单词而言\r\n\r\n字符串拆分、组合及去空格\r\n\r\nsplit(sep=None, maxsplit=-1) #按sep（默认为空格）分割字符串，maxsplit是分割的最大次数，返回列表。strip()     #移除两端空格或指定字符lstrip()    #移除左端空格或指定字符rstrip()    #移除右端空格或指定字符\r\n# 函数接收一个任意字符串s，要求删除两侧的空白字符，把字符串中连续多个空格替换为1个空格，返回处理后的新字符串。例如，s为&#x27;a    bb   c &#x27;时返回&#x27;a bb c&#x27;。def stri(s):    s = s.strip()    s = s.split()    s = &#x27; &#x27;.join(s)    return ss = &#x27;a   bb   c  &#x27;s1 = stri(s)s1\r\n\r\n字符串的查找和替换\r\n\r\ns.find()     #查找指定字符串n，返回n的起始下标，没有则返回-1s.replace(old, new) #替换字符串中的指定子串,old为旧子串，new为新子串。enumerate(iterable)   #返回字符串元素的索引和对应的元素值,常用于for循环中\r\n# 函数接收一个表示日期时间的字符串s，格式为&#x27;2020-02-18 22:02:22&#x27;，要求删除每一部分的前导0，返回格式为&#x27;2020-2-18 22:2:22&#x27;的字符串。不能导入任何模块，注意年月日和时分秒之间有且只有一个空格。def main(s):    # 分割年月日和时分秒    date_part, time_part = s.split()    # 处理年月日部分    year, month, day = map(int, date_part.split(&#x27;-&#x27;))    date_formatted = f&#x27;&#123;year&#125;-&#123;month&#125;-&#123;day&#125;&#x27;    # 处理时分秒部分    hour, minute, second = map(int, time_part.split(&#x27;:&#x27;))    time_formatted = f&#x27;&#123;hour&#125;:&#123;minute&#125;:&#123;second&#125;&#x27;    # 输出格式化后的字符串    result = f&#x27;&#123;date_formatted&#125; &#123;time_formatted&#125;&#x27;    print(result)# 调用主函数s = &#x27;2020-02-18 22:02:22&#x27;ss = main(s)\r\nPython的数据类型之元组\r\n\r\n元组是一种有序的、不可变的序列。\r\n元组的创建方法：\r\n\r\n显式的直接创建\r\n使用类型构造函数创建\r\n\r\n\r\n1. 显式的直接创建元组\r\n\r\n使用 () 包围数据创建元组，各元素之间用逗号隔开。\r\n\r\n# 使用 () 创建一个空元组# 非空元组，元素可以是任意类型# 创建一个包含多个元素的元组my_tuple = (1, &quot;hello&quot;, 3.14, True)print(my_tuple) \r\n元组的两种特殊表示情况：\r\n\r\n元组只有一个元素的时候，不能省略逗号\r\n元组也可以没有圆括号包围\r\n\r\n# 元组元素只有一个时single_element_tuple = (10,)  # 注意逗号print(type(single_element_tuple)) \r\n没有原括号包围也可以创建元组（PEP8不推荐此方法，代码可读性较低）\r\n# 没有圆括号包围tuple_without_parentheses = 10, 20, 30print(type(tuple_without_parentheses)) print(tuple_without_parentheses)  # 输出：(10, 20, 30)\r\n2. 使用类型构造函数创建\r\n\r\n使用类型构造函数 tuple()\r\n将其他可迭代对象转换成元组类型。\r\n\r\ntuple(可迭代对象)#tuple()类型构造函数的实现\r\n可迭代对象\r\n\r\n实现了__iter__()方法\r\n是指可以在循环中逐一返回其元素的对象\r\n\r\n目前学到的可迭代对象：字符串、元组。\r\n判断一个对象是不是可迭代对象，可以用isinstance()函数，此函数的作用是类型检查。\r\nisinstance(判断对象, collections.abc.Iterable)\r\nIterable类型存在于collections.abc模块中\r\n# 定义一些测试对象import collectionstest_objects = [    [1, 2, 3],  # 列表    (1, 2, 3),  # 元组    &#123;1, 2, 3&#125;,  # 集合    &quot;hello&quot;,    # 字符串    &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;,  # 字典    123,        # 整数    45.67,      # 浮点数    True,       # 布尔值    None        # None]# 判断每个对象是否是可迭代对象for obj in test_objects:    if isinstance(obj, collections.abc.Iterable):        print(f&quot;&#123;repr(obj)&#125; 是可迭代对象&quot;)    else:        print(f&quot;&#123;repr(obj)&#125; 不是可迭代对象&quot;)\r\n元组的序列操作\r\n元组的序列操作\r\n\r\n索引访问\r\n\r\ntp1 = (1, 3, 5, 7, 9, 11, 13)tp1[0]tp1[3]\r\n\r\n切片操作\r\n\r\ntp1[2:5]  #5,7,9tp1[-3:]  # 9,11,13\r\n\r\n连接\r\n\r\ntp2 = (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)tp1 + tp2\r\n\r\n重复操作\r\n\r\ntp2 * 2\r\n\r\n成员关系操作\r\n\r\n2 in tp12 not in tp1\r\n\r\n比较运算操作(==、!=、&gt;、&gt;=、&lt;、&lt;=)\r\n\r\ntp1 == tp2tp1 != tp2\r\n元组解包\r\n\r\n将元组赋值给多个变量，这个过程被称作元组解包\r\n\r\na, b, c = (&#x27;1s&#x27;, &#x27;2s&#x27;, &#x27;3s&#x27;)print(a, b, c)#*c 是不定长的对象a, b, *c = (&#x27;1s&#x27;, &#x27;2s&#x27;, &#x27;3s&#x27;, &#x27;4s&#x27;, &#x27;5s&#x27;, &#x27;6s&#x27;)print(a, b, c)# 1s 2s [&#x27;3s&#x27;, &#x27;4s&#x27;, &#x27;5s&#x27;, &#x27;6s&#x27;]\r\npython数据类型之列表\r\n\r\n列表是一种有序的、可变的序列。\r\n创建方法：\r\n\r\n显式的直接创建\r\n使用类型构造函数\r\n\r\n\r\n显式的直接创建\r\n\r\n使用方括号（[]）创建列表，各元素之间用逗号隔开。\r\n# 创建一个空列表empty_list = []#非空列表，元素可以是任意类型# 创建一个包含整数的列表list_of_integers = [1, 2, 3, 4, 5]# 创建一个包含字符串的列表list_of_strings = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]# 创建一个包含不同数据类型的列表mixed_list = [1, &quot;hello&quot;, 3.14, True]\r\n\r\n列表的元素：\r\n\r\n列表的元素可以是不同类型（包括列表）\r\n列表中具有相同值的元素允许出现多次\r\n\r\n使用类型构造函数创建\r\n\r\n使用类型构造函数 list()\r\n将其他可迭代对象转换成列表类型。\r\n\r\n\r\nlist(可迭代对象)\r\n\r\n# 从字符串创建字符列表char_list = list(&quot;hello&quot;)print(char_list) \r\n用切片和索引修改列表的值\r\nls0 = [1, 2, 3, 4, 5, 6]ls0[3] = 0ls0[1:4] = [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;p&#x27;]#改变列表中元素的数据ls0 = [1, 2, 3, 4, 5, 6]ls0[3] = 0print(ls0)ls0[1:4] = [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;p&#x27;]print(ls0)\r\n\r\n字符串和元组不能改变切片的值，因为字符串和元组都是不可变的。列表是可变数据，所以可以通过更新切片，改变列表元素的值。\r\n\r\nindex 方法会返回元素第一次出现的下标\r\n# 查找列表中某元素的下标i = ls0.index(6)print(i)\r\n列表的添加和拼接\r\n\r\nls.append()\r\nls.extend(iterable)\r\nls.insert(index, object)\r\n+ 和 +=\r\n\r\n#append()ls1 = [1, 2, 3]ls1.append(4)print(ls1)#extend()方法需要一个可迭代对象作为参数。ls2 = [1, 2, 3, 5]#ls2.extend([4])ls2.extend((4,))print(ls2)#insert()ls3 = [1, 2]ls3.insert(8, [9])ls3\r\n# 函数main(lst)接收包含若干正整数的列表lst，要求返回所有奇数下标元素之和与所有偶数下标元素之和组成的元组，例如lst为[1234，5，13，65]时返回(70，1247)。def main(lst):    # 初始化奇数下标和偶数下标的和    sum_odd_index = 0    sum_even_index = 0        # 遍历列表，索引从0开始    for index, value in enumerate(lst):        # 判断索引是奇数还是偶数        if index % 2 == 0:            sum_even_index += value  # 偶数下标，累加到偶数下标和        else:            sum_odd_index += value  # 奇数下标，累加到奇数下标和        # 返回一个元组，包含奇数下标元素之和与偶数下标元素之和    return (sum_odd_index, sum_even_index)# 测试函数lst = [1234, 5, 13, 65]result = main(lst)print(result)  # 输出应该是 (70, 1247)\r\n列表的移除和删除\r\n\r\nls.pop()\r\nls.remove()\r\nls.clear()\r\n关键字del\r\n\r\n#pop：按照下标进行移除ls1 = [&#x27;a&#x27;, &#x27;b&#x27;, 3]ls1.pop(2)# remove：按照元素值进行删除ls2 = [&#x27;a&#x27;, &#x27;b&#x27;, (1, 2)]ls2.remove(&#x27;b&#x27;)# 清空列表元素ls3 = [0, 1, 2, 3]#删除整个列表ls3.clear()#关键字del：直接删除变量 或者 通过索引删除列表内的元素ls4 = [5, 6, 7]del ls4[1]\r\n列表的排序\r\n\r\n使用列表对象方法 sort()\r\n对原列表进行排序，改变原列表\r\n使用内置的排序函数 sorted()\r\n返回排好序的列表副本，原列表不变（也可用于元组和字典）\r\n这两种方式默认的排序都是升序的\r\n\r\n#降序的参数list.sort(*, key=None, reverse=False)sorted(iterable, key=None, reverse=False)\r\n# 现有一个列表# pt = [&quot;Python&quot;,&quot;C&quot;, &quot;Java&quot;, &quot;C++&quot;, &quot;Go&quot;, &quot;Rust&quot;]#给列表的元素排序，按照元素的长度从大到小排序，用两种方法分别实现。pt = [&quot;Python&quot;, &quot;C&quot;, &quot;Java&quot;, &quot;C++&quot;, &quot;Go&quot;, &quot;Rust&quot;]# 使用列表的 sort() 方法排序pt.sort(key=len, reverse=True)print(pt)# 使用 sorted() 函数排序sorted_pt = sorted(pt, key=len, reverse=True)print(sorted_pt)\r\n到目前为止，我们学到的可变的数据类型只有列表，接下来我们从列表内存角度来理解列表的可变性。\r\n\r\n\r\nimage-20250513203606483\r\n\r\nlist1 = [1, 2, 3, 4, 5, 6]print(list1, id(list1))#用切片或索引改变列表元素list1[0] = &#x27;a&#x27;print(list1, id(list1))#在原列表中做添加append、删除remove的操作list1.append(7)print(list1, id(list1))\r\n\r\n\r\nimage-20250513203630504\r\n\r\n总结：\r\n\r\n列表是可变序列，修改原列表的数据时，整个列表的id值不发生改变。\r\n一旦有新的列表产生，就会开辟新的内存地址，即使和原列表一模一样也会开辟新空间。\r\n\r\nPython数据类型之集合\r\n\r\n集合是一个无序的、不重复的元素集。\r\n创建方法：1.显式的直接创建 2.使用类型构造函数\r\n\r\n显式的直接创建\r\n\r\n使用大括号&#123;&#125;创建，各元素之间用逗号隔开。\r\n\r\n#创建空集合empty_set = set()  # 使用set()函数创建空集合\r\n用{}不能创建空集合，{}\r\n是Python中字典的语法，用于定义键值对。如果{}是空的,Python会默认它是一个空字典，而不是空集合。\r\n#错误创建非空集合set1 = &#123;1,(22,34,0),[33,90,0,&#x27;2&#x27;]&#125;set1\r\n用花括号创建的集合，其元素只能是可哈希的元素。\r\n\r\n可哈希对象（bool、int、float、complex、str、tuple、frozenset等）\r\n不可哈希的对象（list、set、dict）\r\n注意：也不能含有不可哈希对象\r\n\r\n使用类型构造函数创建\r\n\r\n使用类型构造函数 set()\r\n或frozenset()将其他类型转换成列表类型。\r\nset()和frozenset()的参数需要满足：是可迭代对象，并且该可迭代对象中都是可哈希对象。\r\n\r\n目前学到的可迭代对象：字符串、元组、列表、集合。\r\n\r\n创建空集合只能使用set()或frozenset()\r\nset() 是可变的，你可以对它进行添加、删除等操作。\r\nfrozenset() 是不可变的，一旦创建，不能修改。\r\n\r\n# 用set()创建空集合empty_set = set()print(empty_set)  print(type(empty_set))  #使用 frozenset() 创建空集合empty_frozenset = frozenset()print(empty_frozenset)  print(type(empty_frozenset)) ## 创建非空集合my_set = &#123;1, 2, 3, 4, 5&#125;print(my_set)  # 使用列表创建非空集合my_set = set([1, 2, 3, 4, 5])print(my_set)  # 使用元组创建非空集合my_set = set((1, 2, 3, 4, 5))print(my_set)  # 使用字符串创建非空集合（自动去重）my_set = set(&quot;hello&quot;)print(my_set)  # 使用列表创建非空 frozensetmy_frozenset = frozenset([1, 2, 3, 4, 5])print(my_frozenset)  # 使用字符串创建非空 frozensetmy_frozenset = frozenset(&quot;hello&quot;)print(my_frozenset)  #&#123;1, 2, 3, 4, 5&#125;#&#123;1, 2, 3, 4, 5&#125;#&#123;1, 2, 3, 4, 5&#125;#&#123;&#x27;h&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;l&#x27;&#125;#frozenset(&#123;1, 2, 3, 4, 5&#125;)#frozenset(&#123;&#x27;h&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;l&#x27;&#125;)\r\n总结：\r\n\r\n集合的创建方法有两种，一种是用&#123;&#125;创建，另一种是set()或frozenset()函数创建，其中frozenset()是不可变的集合。\r\nset()和frozenset()的参数必须是可迭代对象，且该对象中元素必须为可哈希对象。\r\n\r\n集合添加元素\r\n\r\nset.add() ——添加单个元素\r\nset.update() ——可添加多个元素\r\n\r\na = &#123;1, 2, 3&#125;a.add(&#x27;world&#x27;)  ##添加一个元素print(id(a),a)a.update(&#x27;world&#x27;)print(id(a),a)# a.update([99,22,33])# 顺序是随机的# print(a)\r\n集合删除元素\r\n\r\nset.remove() ——一次只能删除一个元素，若删除的元素不存在则会报错\r\nset.discard() ——一次只能删除一个元素，若删除的元素不存在不报错\r\nset.pop() ——默认删除第一个元素\r\nset.clear() ——清空集合元素\r\n\r\n#1.remove一次只能删除一个元素，删除的元素不存在则会报错r = &#123;&#x27;清风&#x27;,&#x27;明月&#x27;,20,28&#125;# r.remove(282)# print(&#x27;remove:&#x27;,r)#2.discard一次只能删除一个元素，删除的元素不存在不报错# r.discard(28)# print(&#x27;discard:&#x27;,r)#3.pop默认删除第一个元素p = &#123;90,1,2,3,5&#125;print(p)p.pop()print(p)#4.clear是清空集合元素a = &#123;&#x27;happy&#x27;,&#x27;new&#x27;,123&#125;a.clear()print(a)    #为什么返回的是一个set()呢，而不是&#123;&#125;呢？\r\n集合类型操作符（用于可变集合和不可变集合）\r\n\r\n集合等价/不等价： ==、!=\r\n（只要它们包含相同的元素，比较就会返回 True）\r\n子集/超集判定：\r\n&lt;、&lt;=、&gt;、&gt;=\r\n\r\n#1.集合的等价、不等价\r\n\r\nset(&#x27;book&#x27;) == frozenset(&#x27;book&#x27;)# True\r\n集合的数学操作\r\n\r\n交集 “&amp;” “set1.intersection(set2)”\r\n并集 “|” “set1.union(set2)”\r\n差集 “-” “set1.difference(set2)”\r\n对称差集 “^” “set1.symmetric_difference(set2)”\r\n\r\ns = set(&#x27;abcde&#x27;)t = frozenset(&#x27;defgh&#x27;)print(s &amp; t)print(s | t)print(s - t)#返回存在于s中但不在t中的元素print(s ^ t)#返回s和t中不同的元素，去除了重复元素s = set(&#x27;abcde&#x27;)t = frozenset(&#x27;defgh&#x27;)print(s.intersection(t))print(s.union(t))print(s.difference(t))print(s.symmetric_difference(t))\r\n其他的集合常用方法：\r\n\r\ns.issubset(t) # 如果s是t的子集，返回True\r\ns.issuperset(t) # 如果s是t的超集，返回True\r\n\r\n#如果集合 A 中的所有元素都在集合 B 中，那么集合 A 被称为集合 B 的子集。# 定义两个集合A = &#123;1, 2, 3&#125;B = &#123;1, 2, 3, 4, 5&#125;# 检查 A 是否是 B 的子集is_subset = A.issubset(B)print(is_subset)  # 输出：True#如果集合 B 中的所有元素都在集合 A 中，那么集合 A 被称为集合 B 的超集。# 定义两个集合A = &#123;1, 2, 3, 4, 5&#125;B = &#123;1, 2, 3&#125;# 检查 A 是否是 B 的超集is_superset = A.issuperset(B)print(is_superset)  # 输出：True\r\nPython数据类型之字典\r\n\r\n是一种以键值对为元素的无序组合，键和值之间用冒号隔开，字典元素之间以逗号隔开。\r\n创建方法：\r\n\r\n\r\n显式的直接创建\r\n使用类型构造函数\r\n\r\n字典是Python中一种映射数据结构，映射是根据键（key）查找其映射值（value）的过程。\r\n\r\n字典中的键（key）必须是可哈希对象\r\n可哈希对象：bool、int、float、complex、str、tuple、frozenset\r\n\r\n显式的直接创建\r\n\r\n使用花括号&#123;&#125;创建字典，各元素之间用逗号隔开。\r\n\r\n#1. 创建一个空字典,使用 dict() 函数创建空字典empty_dict_2 = dict()#2. 用&#123;&#125;创建，按照字典形式添加元素empty_dict_1 = &#123;&#125;#3. 键（key）必须是可哈希对象（数值型、字符串、元组(元素也必须为可哈希)、frozenset）# 数值型作为键num_dict = &#123;1: &#x27;one&#x27;, 2: &#x27;two&#x27;&#125;# 字符串作为键str_dict = &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;# 元组作为键（元组内的元素也必须为可哈希对象）tuple_dict = &#123;(1, 2): &#x27;pair&#x27;, (&#x27;a&#x27;, &#x27;b&#x27;): &#x27;another pair&#x27;&#125;# frozenset 作为键frozenset_dict = &#123;frozenset([1, 2]): &#x27;frozenset example&#x27;&#125;#4. 字典的键（key）出现多次的情况# 创建一个字典my_dict = &#123;&#125;# 添加一些键值对my_dict[&#x27;key1&#x27;] = &#x27;value1&#x27;my_dict[&#x27;key2&#x27;] = &#x27;value2&#x27;my_dict[&#x27;key1&#x27;] = &#x27;new value1&#x27;  # 这里的 &#x27;key1&#x27; 会覆盖之前的 &#x27;key1&#x27;\r\n字典中键的规则\r\n\r\n不允许一个键对应多个值\r\n键必须是可哈希的（列表、字典这样的可变类型是不可哈希的，所以不能作为键）\r\n所有不可变类型都是可哈希的（不可包含可变元素），都可以作为字典的键，但字典中的键通常是字符串\r\ndict(元组)、dict(列表)里面的元素必须为序列，且子序列中元素顺序要满足键值对的顺序。\r\n\r\nPython中的不可变数据类型默认是可哈希的，包括：\r\n\r\n整数（int）\r\n浮点数（float）\r\n布尔值（bool）\r\n字符串（str）\r\n元组（tuple）（注意，元组中的所有元素也必须是可哈希的）\r\n冰冻集合（frozenset）（冰冻集合本身是可哈希的，但它是不可变的集合类型）\r\n\r\n相反，以下数据类型是不可哈希的，因此不能用作字典的键或添加到字典中：\r\n\r\n列表（list）\r\n集合（set）\r\n字典（dict）\r\n\r\n类型构造函数dict()创建字典\r\n\r\ndict(键=值)\r\ndict(元组)\r\ndict(列表)\r\n\r\ndict_0 = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;# dict(键=值) dict_1 = dict(four=2)dict_0 = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;#dict(元组) dict_2 = dict((&#x27;o1&#x27;,&#x27;t2&#x27;,&#x27;h3&#x27;))print(dict_2)dict_0 = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;#dict(列表)dict_3 = dict([&#x27;o1&#x27;,&#x27;t2&#x27;,&#x27;h3&#x27;])print(dict_3)\r\n使用fromkeys() 创建字典\r\ndict.fromkeys(iterable, value)\r\n\r\n用一个可迭代对象作为字典的键\r\n第二个参数用来设置字典每个键值对的值，如果忽略的话值默认为None\r\n\r\ndict7 = &#123;&#125;.fromkeys((&#x27;x&#x27;, &#x27;y&#x27;), 1)  # 给所有key一个默认值dict8 = dict.fromkeys(&#123;&#x27;x&#x27;,1,2,3&#125;,2)print(dict7)print(dict8)\r\n# 现有一个列表list_1，要求把list_1的重复元素去掉，返回一个新列表list_2，新列表中的元素保持在原列表中首次出现的相对顺序。不要使用循环和推导式。def remove_duplicates(list_1):    return list(dict.fromkeys(list_1))#使用 dict.fromkeys() 方法来移除列表中的重复元素。这个方法利用了字典键的唯一性来自动移除重复的元素。list_1 = [1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]list_2 = remove_duplicates(list_1)print(list_2) \r\n字典元素的增加和修改\r\n\r\n字典变量名[key] = value\r\n如果key不存在则为字典增加一项，如果key存在则修改对应的value值。\r\n\r\n#元素增加dic = &#123;&quot;name&quot;:&quot;高山流水&quot;, &quot;age&quot;: &quot;2&quot;&#125;dic[&quot;sex&quot;]=&quot;girl&quot;print(dic)#元素修改dic[&quot;age&quot;]=3dic[&quot;sex&quot;]=&quot;boy&quot;print(dic)# &#123;&#x27;name&#x27;: &#x27;高山流水&#x27;, &#x27;age&#x27;: &#x27;2&#x27;, &#x27;sex&#x27;: &#x27;girl&#x27;&#125;# &#123;&#x27;name&#x27;: &#x27;高山流水&#x27;, &#x27;age&#x27;: 3, &#x27;sex&#x27;: &#x27;boy&#x27;&#125;\r\n删除指定key对应的value\r\n\r\ndel 字典变量名[key]\r\n\r\ndel dic[&quot;name&quot;]print(dic)# &#123;&#x27;age&#x27;: 3, &#x27;sex&#x27;: &#x27;boy&#x27;&#125;\r\n字典的查询\r\n\r\n根据键名查询\r\n查询所有的键名\r\n查询所有键的值\r\n查询所有键值对\r\n\r\n# 1.根据键名查询dic[&quot;age&quot;]print(dic[&quot;age&quot;])#2.查询所有的键名dic.keys()print(dic.keys())#3.查询所有键的值dic.values()print(dic.values())#4.dic.items() 返回的迭代器中的每个元素都是一个键值对，形式为 (key, value)dic_i = dic.items()print(dic_i)for key, value in dic_i:    print(key, value)\r\n函数接收一个任意字符串s，要求返回其中只出现了1次的字符组成的新字符串，每个字符保持原来的相对顺序。例如，s为’Beautiful\r\nis better than ugly.’时返回’Bfsbrhngy.’\r\ndef unique_chars(s):    char_count = &#123;&#125;    for char in s:        if char in char_count:            char_count[char] += 1        else:            char_count[char] = 1    result = &#x27;&#x27;    for char in s:        if char_count[char] == 1:            result += char    return results = &#x27;Beautiful is better than ugly.&#x27;print(unique_chars(s))  # 输出：&#x27;Bfsbrhngy.&#x27;\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的文件操作","url":"/posts/31408.html","content":"Python的文件操作\r\n\r\n文件的打开与关闭\r\n文件的读取与写入\r\n\r\n文件的打开\r\n\r\n内置函数：open(文件名, 模式)\r\nos模块的函数：os.open(文件名, 模式)\r\nwith open(文件名, 模式) as file\r\n\r\n文件的关闭\r\n\r\nfileobject.close() fileobject是文件对象\r\nos.close(file) 关闭文件\r\n\r\nfile_1 = open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;)print(&#x27;file_1---&#x27;, file_1, type(file_1))#关闭文件之后，python才能释放对该文件的控制，可以去尝试删除该文件file_1.close()\r\n默认的文件编码encoding一般依赖于系统的区域设置和Python的版本。\r\ncp936代表GBK编码\r\n标准编码参考：https://docs.python.org/3/library/codecs.html\r\nimport io    #io.open()是内置函数open的别名，本质是一样的file = io.open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;)print(&#x27;file---&#x27;, file, type(file))\r\nimport osfile_2 = os.open(&#x27;file_2.txt&#x27;, os.O_RDWR|os.O_CREAT) #os.O_RDONLYprint(&#x27;file_2--&#x27;, file_2, type(file_2))os.close(file_2)# os.remove(&#x27;file_2.txt&#x27;)\r\n区别：\r\n\r\nopen()函数返回的是一个文件对象，而os.open()函数返回的是一个文件描述符（即整数）。\r\npython内置的open()函数主要用于处理文本文件，而os.open()函数主要用于处理二进制文件和低级文件操作。\r\n\r\n使用with语句即python的上下文管理器，它可以自动关闭文件，而用open()函数则需要手动关闭文件。\r\nwith open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;rb+&#x27;) as f:    content = f.read()    print(content)\r\n文件的打开模式\r\n\r\n‘r’：只读模式\r\n‘w’：覆盖写模式，不存在则创建，存在则完全覆盖\r\n‘a’：追加写模式，不存在则创建，存在则在文件最后追加内容\r\n‘x’：排他性创建模式：如果文件不存在，创建并打开写模式的文件。如果文件已存在，操作将失败。\r\n‘b’：二进制文件模式\r\n‘+’：在原功能基础上增加同时读写功能，可与r/w/a组合。\r\n\r\n思考下列代码分别属于什么打开模式：\r\n\r\nopen(‘file.txt’, ‘w’) 写入模式\r\nopen(‘file.txt’, ‘w+’) 读写模式\r\nopen(‘file.txt’, ‘rb’) 二进制读取模式\r\nopen(‘file.txt’, ‘rb+’) 二进制读写模式\r\n\r\n文件的读取与写入\r\n\r\nread()读取文件内容\r\nreadline()返回文件的一行内容，格式为字符串\r\nreadlines()返回文件所有行内容，格式为列表\r\nwrite()写入文件内容\r\nwritelines()将一个字符串列表写入文件\r\n\r\n#read()读取文件内容with open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;) as f:    content = f.read()    print(content)\r\n#readline()读取一行内容f = open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;)print(f.readline(5))# while True:#     line = f.readline()  #f.readline(4) 读取前几个字符#     if not line:#         break#     print(line, type(line))\r\n#readlines()逐行读整个文件内容，包括换行符with open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;r&#x27;) as f:    fa = f.readlines()    print(fa, type(fa))\r\n# w覆盖写入，write()参数必须为字符串，如果想换行，必须加上换行符\\nwith open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;w&#x27;) as file:    file.write(&#x27;Hello, World!&#x27;)\r\n# 写入字符串列表，如果想换行，必须加上换行符\\nwith open(&#x27;F:\\\\file_1.txt&#x27;, &#x27;w&#x27;) as file:    lines = [&#x27;Hello,\\n&#x27;, &#x27;World2!&#x27;,&#x27;black Monkey&#x27;]  #\\n    file.writelines(lines)\r\n绝对路径和相对路径\r\n\r\n绝对路径是从根目录开始的完整路径。它提供了到达指定文件或目录的具体位置，不依赖于当前工作目录的位置。\r\n系统中的绝对路径E:\\jupyter\\python，python中的绝对路径r\"E:\\jupyter\\python\"或者E:/jupyter/python或者E:\\\\jupyter\\\\open\r\n相对路径是相对于当前工作目录的路径。它通过相对位置来指定文件或目录，简化了路径的表达，但其具体位置依赖于当前的工作目录。\r\n\r\nos模块常用的路径操作\r\n\r\n获取当前路径名\r\n#1.获取当前路径名import osprint(os.getcwd())print(os.path.abspath(os.curdir))  #返回绝对路径 os.path.abspath \r\n获取父目录路径名\r\nprint(os.path.dirname(&#x27;../python/6.1 Python的文件操作.ipynb&#x27;))print(os.path.dirname(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;, &#x27;op&#x27;, &#x27;file.txt&#x27;)))\r\n返回指定路径下的文件和目录列表\r\n#3. 返回指定路径下的文件和目录列表#&#x27;.&#x27;或&#x27;./&#x27;代表当前路径   #&#x27;..&#x27;或&#x27;../&#x27;代表上一级路径print(os.listdir(&#x27;..&#x27;))   \r\n创建目录\r\n#4.在当前文件夹下创建单层目录os.mkdir(&#x27;new1123&#x27;)\r\n合并两个或多个路径名组件\r\nimport os#5. 合并两个或多个路径名组件print(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;))#合并一个没有的目录，需要重新创建目录# os.mkdir(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;))print(os.path.join(&#x27;../&#x27;, &#x27;open&#x27;,&#x27;./&#x27;, &#x27;file.txt&#x27;))with open(&#x27;new1123&#x27;, &#x27;w&#x27;) as fs:    fs.write(&#x27;111222333&#x27;)\r\n统一规范化路径分隔符\r\n#6.统一规范化路径分隔符file_op = os.path.join(&#x27;../&#x27;, &#x27;open&#x27;,&#x27;./&#x27; , &#x27;file.txt&#x27;)uni_op = file_op.replace(os.sep, &#x27;/&#x27;)  #直接对字符串进行替换normalized_path = os.path.normpath(file_op)  #用方法规范化print(uni_op) print(normalized_path) \r\n判断文件是否存在\r\n#7.判断文件是否存在if os.path.exists(&#x27;F:\\\\file_2.txt&#x27;):    print(&#x27;yes&#x27;)else:    print(&#x27;no&#x27;)\r\n\r\n更多的os操作请查看官方文档：https://docs.python.org/3/library/os.html#module-os\r\ncsv格式文件的读取和写入\r\n\r\ncsv是逗号分隔符文本格式，常用于Excel和数据库的数据导入和导出。\r\ncsv的读取：csv.reader(csvfile, dialect='excel', **fmtparams)#csvfile文件对象；dialect指定csv格式；fmtparams用于指定特定格式覆盖dialect的格式\r\ncsv.reader()创建的是可迭代对象\r\n\r\n#csv的读取import csvwith open(&#x27;F:\\\\stu.csv&#x27;) as f:    f_csv = csv.reader(f)        for row in f_csv:        print(row)\r\n\r\ncsv的写入：csv.writer(csvfile, dialect='excel', **fmtparams)\r\ncsv文件.writerow(row) #写入一行\r\ncsv文件.writerows(rows) #写入多行\r\n\r\nheader = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;sex&#x27;, &#x27;work&#x27;]datas = [[&#x27;8090&#x27;, &#x27;juney&#x27;, &#x27;male&#x27;, &#x27;teacher&#x27;],[&#x27;8091&#x27;, &#x27;marry&#x27;, &#x27;female&#x27;, &#x27;nurse&#x27;]]with open(&#x27;F:\\\\stu.csv&#x27;, &#x27;w&#x27;) as f:    w_csv = csv.writer(f)    w_csv.writerow(header)    w_csv.writerows(datas)\r\n在Windows上的换行符为\\r\\n，而在Linux和MacOS上的换行符为\\n。\r\nopen()中有个参数’newline’控制如何处理换行符。\r\n可令newline=''\r\n此参数在不同操作系统间提供一致的换行符处理，避免了跨平台文本文件处理中的问题。\r\nnewline参数只对文本模式有效，对二进制模式无效。\r\nheader = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;sex&#x27;, &#x27;work&#x27;]datas = [[&#x27;8090&#x27;, &#x27;juney&#x27;, &#x27;male&#x27;, &#x27;teacher&#x27;],[&#x27;8091&#x27;, &#x27;marry&#x27;, &#x27;female&#x27;, &#x27;nurse&#x27;]]with open(&#x27;F:\\\\stocks1.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as f:    w_csv = csv.writer(f)    w_csv.writerow(header)    w_csv.writerows(datas)\r\n读取’green_red’文件夹下的’train’文件夹，然后读取里面的csv文件，把里面的前10行数据放到新的列表中。\r\nimport csvwith open(&#x27;green_red/train/Glass_train.csv&#x27;, &#x27;r+&#x27;) as fcsv:    fs = csv.reader(fcsv)    li_fs = list(fs)    li_csv = []    for i, v in enumerate(li_fs):        li_csv.append(li_fs[i])        if i == 9:            break        print(li_csv)  \r\n对象序列化和pickle模块\r\n\r\n序列化是Python对象转换为数据格式，以便在不同的环境中存储、传输和重建。\r\n反序列化是从磁盘文件或所接收到的数据形式恢复，得到相应对象的过程。\r\n对象序列化广泛用于各种分布式并行处理系统。\r\npickle模块可以实现对象的序列化。\r\n\r\nimport pickle#序列化data = &#123;&#x27;key&#x27;: &#x27;value&#x27;, &#x27;num&#x27;: 123&#125;# 对象转换为字节流，&#x27;b&#x27;代表二进制模式with open(&#x27;data.pickle&#x27;, &#x27;wb&#x27;) as file:    # 使用pickle的dump函数将数据序列化并保存到文件    pickle.dump(data, file)    #反序列化with open(&#x27;data.pickle&#x27;, &#x27;rb&#x27;) as file:    # 使用pickle的load函数从文件加载数据    data_loaded = pickle.load(file)print(data_loaded)\r\n应用实例：\r\n\r\n将一个整数列表[1, 2, 3, 4,\r\n5]序列化到一个名为numbers.pkl的文件中。\r\n从numbers.pkl文件中反序列化该列表，并将其打印出来。\r\n\r\nimport pickle# 要序列化的整数列表numbers_list = [1, 2, 3, 4, 5]# 序列化整数列表到文件 numbers.pkl 中with open(&#x27;numbers.pkl&#x27;, &#x27;wb&#x27;) as file:    # 使用 pickle.dump 函数将列表序列化并保存到文件    pickle.dump(numbers_list, file)    print(&quot;列表已序列化到文件 numbers.pkl 中。&quot;)# 从文件 numbers.pkl 中反序列化列表with open(&#x27;numbers.pkl&#x27;, &#x27;rb&#x27;) as file:    # 使用 pickle.load 函数从文件加载并反序列化列表    loaded_numbers_list = pickle.load(file)    print(&quot;列表已从文件 numbers.pkl 中反序列化。&quot;)    print(&quot;反序列化后的列表内容：&quot;, loaded_numbers_list)\r\n文件的筛选：\r\n\r\nfile.endswith() #以…结尾的文件名\r\nfile.startswith() #以…开始的文件名\r\n\r\n# 假设我们有一个文件名列表filenames = [&#x27;example.txt&#x27;, &#x27;data.csv&#x27;, &#x27;image.png&#x27;, &#x27;notes.txt&#x27;]# 筛选出所有以 &#x27;.txt&#x27; 结尾的文件text_files = [file for file in filenames if file.endswith(&#x27;.txt&#x27;)]print(text_files)\r\n# 假设我们有一个文件名列表filenames = [&#x27;report2024.txt&#x27;, &#x27;summary2024.csv&#x27;, &#x27;image2024.png&#x27;, &#x27;notes2024.txt&#x27;]# 筛选出所有以 &#x27;report&#x27; 开始的文件report_files = [file for file in filenames if file.startswith(&#x27;report&#x27;)]print(report_files) \r\nPython的异常捕获\r\n错误与异常\r\n错误\r\n\r\n错误（Error）可以分为语法错误和逻辑错误，当运行时出现报错信息，此时就产生了异常（Exception）。\r\n#语法错误在编译阶段就会报错def op(a): a = 1list([1,2,3)\r\n\r\n异常\r\n\r\n程序运行时检测到的错误称为异常，异常不一定导致严重的后果，而是显示错误信息。\r\n\r\nPython中常见的异常\r\n更多的内置异常类请参考官方文档：https://docs.python.org/3/library/exceptions.html#index-2\r\n\r\nNameError：尝试访问一个未声明的变量\r\nZeroDivisionError：除数为0\r\nSyntaxError：解释器语法错误\r\nIndexError：请求的索引超出序列范围\r\nTypeError：类型错误\r\nKeyError：请求一个不存在的字典键\r\nFileNotFoundError：请求不存在的文件或目录时\r\nFileExistsError：创建一个已经存在的文件或目录时\r\n\r\n异常处理\r\n\r\ntry-except语句\r\n\r\ntry:    try_suite   # 检测是否有异常except exceptiontype:    except_suite  # 异常处理代码\r\n\r\n首先，执行 try 子句，如果没有触发异常，则跳过 except 子句，try\r\n语句执行完毕。\r\n如果在执行 try\r\n子句时发生了异常，则跳过该子句中剩下的部分。判断异常类型与 except\r\n指定的异常是否匹配，若匹配则会执行 except\r\n子句。若不匹配，异常就会被递交至上一级，也就是由该段代码的调用者去处理。如果最后还是无法解决的话，就会出现错误，导致程序崩溃。\r\nexcept可以有不同的异常类型，但最多只有一个处理程序会被执行。第一个匹配到的异常类型将被处理，其他匹配到的异常类型将不会被处理。\r\n\r\nexcept (RuntimeError, TypeError, NameError):    pass\r\n\r\n如果想要处理所有匹配到的异常类型，并且在每个异常类型中执行不同的代码，可以使用多个except语句，每个语句处理一个特定的异常类型。\r\n\r\ntry:    passexcept RuntimeError:    return &quot;RuntimeError occurred&quot;except TypeError:    return &quot;TypeError occurred&quot;except NameError:    return &quot;NameError occurred&quot;\r\ntry:    import mathp    type_e = float(25)    s = math.sqrt(type_e)except (ImportError, TypeError):    print(&quot;发生了一个异常&quot;)    # import math# type_e = float(2)# s = math.sqrt(type_e)# print(s)#放到try-except里try:    import mathoo    type_e = float(2)    s = math.sqrt(type_e)except TypeError:    print(&#x27;🐖🐖🐖float-TypeError&#x27;)except ImportError:    print(&#x27;🐇🐇🐇import-ImportError&#x27;)    print(s)\r\n2.try-except-else语句\r\ntry:    try_suite   # 检测是否有异常except exceptiontype as name:    except_suite  # 异常处理代码else:    else_suite   #没有发生异常时执行\r\ndef divide(x, y):    try:        y -= 1        result = x / y    except Exception as e:        return e    else:        return result        print(divide(3, 1))print(divide(3, 3))\r\n\r\ntry-finally 语句\r\n\r\ntry:    ...finally:    ...\r\n\r\ntry-except-else-finally语句\r\n\r\ntry:    ...except MyException:    ...else:    ...finally:    ...\r\n无论异常是否发生，无论异常是否被捕捉到，finally后的语句块一定会被执行。\r\n#不管try返回了什么值，如果finally中也有返回值，则最终返回finally的。def bool_return():    try:        return True    finally:        return Falsebool_return()     \r\n#如果try语句要执行break、continue或return语句，finally子句将在break、continue或return语句执行之前执行try:    print(&quot;这是try块中的内容&quot;)    for i in range(5):        print(&#x27;i:&#x27;, i)        if i == 2:            break    except Exception as e:    print(&quot;发生了一个异常&quot;, e)    finally:    print(&quot;这是finally块中的内容&quot;)\r\n#如果try发生异常，执行完finally语句后，会重新抛出异常def divide(x, y):    try:        result = x / y    except ZeroDivisionError:        print(&quot;division by zero!&quot;)    else:        print(&quot;result is&quot;, result)    finally:        print(&quot;executing finally clause&quot;)# divide(2, 1)# divide(2, 0)divide(&quot;2&quot;, &quot;1&quot;)\r\n#如果finally子句执行break、continue或return语句，则不会重新引发异常def example():    try:        a = 1 / 0    except Exception as e:        print(&#x27;eeee:eeee&#x27;)        return e    finally:        print(&quot;...&quot;)        return &quot;finally&quot;                   result = example()print(result)\r\n抛出异常\r\n\r\n根据程序的运行状态或满足的条件，主动引发一个指定的异常，而不是等待Python解释器在执行过程中遇到错误时自动抛出异常。\r\n使用raise语句抛出异常，此异常可以是BaseException的子类、由BaseException派生的自定义类或异常类的实例。\r\n直接使用异常类raise ValueError；派生Exception类的自定义异常类class MyError(Exception): pass; raise MyError；使用异常类的实例raise ValueError('输入值有误')；\r\n\r\ntry:    raise NameError(&#x27;HiThere&#x27;)except NameError:    print(&#x27;An exception flew by!&#x27;)    raise\r\n异常链\r\n\r\nPython中的异常链是指显式地将异常链接在一起，将一个异常链接到另一个异常的能力。当一个异常作为另一个异常的直接后果而发生时，这个特性特别有用。通过链接异常，开发人员可以提供更多的上下文和更清晰的回溯，从而更容易调试。\r\n用from语句链接异常，并与raise语句合用形成基本结构：raise NewException from exception。\r\n在某些情况下，不想关注其他异常，可以使用from None。\r\n\r\n捕获所有类型的异常\r\n\r\nBaseException是所有异常的公共基类。\r\nBaseException的一个子类 Exception\r\n是所有非致命异常的基类，所有内置的、非系统退出的异常都派生自这个类。所有用户定义的异常也从这个类派生。\r\nSystemExit、KeyboardInterrupt是用户希望中断程序时的异常；GeneratorExit是生成器或协议中断时的异常。\r\n处理异常最常见的模式是 打印 或 记录异常。\r\n\r\n捕获BaseException可能会意外地捕获到SystemExit和KeyboardInterrupt等异常，这可能会导致程序在应该正常退出或响应用户中断的情况下继续运行。Exception确保不阻碍正常的程序退出，也能专注于处理程序中可能发生的错误。\r\n所以通常情况下我们使用Exception去捕获几乎所有的异常情况。\r\n使用Exception捕获异常时，通常后面加一个异常参数e（也可以是其他的变量名），它用于打印异常的具体细节。\r\n文件读取与异常捕获实例：\r\n编写一个Python脚本，尝试读取一个不存在的文件。\r\n使用try-except语句捕获并处理FileNotFoundError异常。\r\n使用else子句打印一条成功读取文件的消息。\r\n使用finally子句确保文件被正确关闭。\r\ntry:    # 尝试打开一个不存在的文件    with open(&#x27;non_existent_file.txt&#x27;, &#x27;r&#x27;) as file:        content = file.read()except FileNotFoundError:    # 如果文件不存在，捕获 FileNotFoundError 异常    print(&quot;文件未找到，请检查文件名是否正确。&quot;)else:    # 如果没有异常发生，打印成功读取文件的消息    print(&quot;文件读取成功！&quot;)    print(content)finally:    # 无论是否发生异常，都执行 finally 块中的代码    print(&quot;操作完成。&quot;)\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python的浅复制与深复制","url":"/posts/22323.html","content":"Python的浅复制与深复制\r\n\r\n对于不可变对象来说，因其值不可变，复制一个副本对它的作用不大。但对于可变对象来说，因其值可变，很多时候复制一个副本可以保存它未改变前的值，用来做对比或者做数据备份。\r\n创建一个副本，这里涉及到浅复制和深复制。\r\n\r\n浅复制与深复制的构造方法\r\n\r\n首先都需要导入copy模块\r\n浅复制：copy.copy(x)\r\n深复制：copy.deepcopy(x)\r\n\r\n其中浅复制还可以用切片实现：\r\n\r\n例如：a = [1,2,3] ; aa = a[:]\r\n\r\n浅复制与深复制的区别\r\n\r\n浅复制：复制内层容器时不会单独开辟空间，而是引用原来的地址。\r\n深复制：复制内层不可变的容器时不会单独开辟空间，引用其原地址；若是内层可变的容器，则会单独开辟空间\r\n\r\n容器：\r\n\r\n可以在里面装下多个元素的，可以用in, not\r\nin关键字判断元素是否包含在容器中的。\r\n常见的容器有：字符串、元组、列表、字典、集合。\r\n\r\nhttp://www.pythontutor.com\r\n是一个可以一边执行代码一边查看对象引用情况的网站。\r\n我们构造一个含有内层容器的对象[0,1,[2,99],4]，然后在线查看深、浅复制分别都是如何复制的。\r\n#构造对象，并进行浅复制和深复制import copy a = [0,1,(2,[9,8]),4]aa = copy.copy(a)    #切片也是浅复制a[:]aaa = copy.deepcopy(a)print(id(a[2][1]))print(id(aa[2][1]))print(id(aaa[2][1]))\r\n那么，改变原值时，浅复制和深复制的内容会如何改变？\r\n#构造含内层容器的对象import copy a = [0,1,[2,99],4]#aa = copy.copy(a)aaa = copy.deepcopy(a)#改变内层容器的值print(id(a))a[2][0] = 8print(id(a[2][0]))print(id(aa[2][0]))print(id(aaa[2][0]))# print(id(a[2][0]) == id(aa[2][0]))# print(id(a[2][0]) == id(aaa[2][0]))\r\n\r\n改变原值的内层容器里的值时，浅复制会随之改变，深复制则不会。\r\n\r\n理解深浅复制的区别：\r\n\r\n现给出一个列表lsa = [12, 'abc', [8, 0]]，对lsa分别进行浅复制赋值给lsb，进行深复制赋值给lsc，然后改lsa中的[8, 0]为[9, 0]，请问lsb和lsc中的值改变了吗？为什么？\r\nlist_a = [1, &quot;hello&quot;, [2, 3]]print(id(list_a[2]))list_b = copy.copy(list_a)print(id(list_b[2]))list_c = copy.deepcopy(list_a)print(id(list_c[2]))list_a[2] = [4,5]print(id(list_a[2]))print(id(list_b[2]))print(id(list_c[2]))\r\n在执行上述操作后，lsb中的子列表会随之改变，而lsc中的子列表则保持不变。具体分析如下：\r\n\r\nlsb = copy.copy(lsa)创建了列表的浅副本。浅复制会复制顶层对象，但嵌套的子对象（如列表[8, 0]）仍指向原对象。因此，lsb和lsa的顶层元素是独立的，但它们共享嵌套的子列表。\r\nlsc = copy.deepcopy(lsa)创建了列表的深副本。深复制会递归复制所有嵌套对象，生成完全独立的对象树。因此，lsc中的子列表是lsa中子列表的独立副本。\r\n\r\n所以执行当执行lsa[2] = [9, 0]时：\r\n\r\nlsb的变化：\r\nlsb的顶层结构与lsa分离，但共享子列表。修改lsa[2]只是替换了lsa的第三个元素的引用，而lsb[2]仍指向原嵌套列表[8, 0]。因此，lsb中的值不会改变。\r\nlsc的变化：\r\n深复制生成的lsc完全独立于lsa。修改lsa[2]不会影响lsc的任何元素。因此，lsc中的值保持不变。\r\n\r\n结论：\r\n\r\nlsb中的值：[8, 0]（未改变）\r\nlsc中的值：[8, 0]（未改变）\r\n原因：浅复制共享嵌套对象，而深复制完全独立。修改lsa的子列表引用不会传播到复制对象。\r\n\r\n\r\n","categories":["语言基础学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之函数之函数简介与参数","url":"/posts/21821.html","content":"函数\r\n\r\n单一功能的封装。\r\n实现代码复用。\r\n\r\nPython语言中使用函数分为两个步骤：定义函数和调用函数。\r\n\r\n定义函数，即根据函数的输入、输出和数据处理完成函数代码的编写。\r\n定义函数只是规定了函数会执行什么操作，但并不会真正去执行。\r\n调用函数，即真正去执行函数中的代码，是根据传入的数据完成特定的运算，并将运算结果返回到函数调用位置的过程。\r\n\r\n定义函数\r\ndef functionname([parameters]):    &quot;&quot;&quot;docstring    &quot;&quot;&quot;    function_suite    [return [expression]]\r\n函数命名规范和变量命名一样\r\n\r\n必须使用字母或者下划线_开头\r\n仅能含有字母、数字和下划线\r\n\r\n调用函数\r\n语法格式：函数名称(), 括号中传入参数值。\r\ndef print_things(name):    print(name , &#x27;hello,world!&#x27;)print_things(&quot;ppx&quot;)\r\n函数的返回值\r\n定义了函数之后，我们调用它来获得返回值\r\ndef square_new(x):    x * x    return   # 在执行return语句终止函数时没有伴随一条表达式print(square_new(3))\r\ndef square_new(x):    x * x    # 没有return语句print(square_new(3))\r\n函数调用过之后进行返回的值，就是返回值。\r\n\r\n如果不显式使用 return 语句或 return\r\n语句不使用表达式，那么函数返回None\r\n要从函数中返回多个值，只要简单地返回一个元组即可。\r\n\r\ndef division():    &quot;&quot;&quot;求商与余数    &quot;&quot;&quot;    a = 9 % 4    b = (9 - a) / 4    return b, ab, a = division()print(b)print(a)\r\n观察 return 语句，尽管看起来\r\ndivision()返回了多个值，但实际上它只创建了一个元组而已。实际上元组是通过逗号来组成的，不是圆括号。\r\n当调用的函数返回了元组，通常会将结果赋值给多个变量，实际上就是简单的元组解包。返回的值也可以赋给一个单独的变量\r\nx = division()print(x)  # x就代表整个元组\r\n函数是一等对象\r\n“一等对象”定义为满足下列条件的程序实体：\r\n\r\n在运行时创建\r\n能赋值给变量或数据结构中的元素\r\n能作为参数传给函数\r\n能作为函数的返回结果\r\n\r\n把函数视作对象\r\n# 创建并测试一个函数，然后读取它的__doc__属性，再检查它的类型def factorial(n):    &quot;&quot;&quot;return n!&quot;&quot;&quot;    print(f&quot;计算 &#123;n&#125; 的阶乘&quot;)    return 1 if n &lt; 2 else n * factorial(n - 1)\r\n每个函数都有一个 __doc__\r\n属性，用于存储函数的文档字符串（docstring）。文档字符串是对函数功能、参数、返回值等的描述，有助于代码的可读性和维护性。\r\nprint(factorial.__doc__)\r\n在我们定义的 factorial 函数中，文档字符串是\r\n\"return n!\"，打印 factorial.__doc__\r\n会输出这个字符串，帮助其他开发者（甚至是未来的自己）理解函数的功能。\r\n在 Python 中，函数是 function 类型的对象。我们可以使用\r\ntype 函数来检查一个函数的类型：\r\nprint(type(factorial))\r\n执行上述代码会输出 &lt;class 'function'&gt;，表明\r\nfactorial 是一个函数对象。\r\n还可以通过别的名称使用函数，再把函数作为参数传递\r\nfact = factorialfact(5)\r\n展示了函数对象的“一等”本性，我们可以把factorial函数赋值给变量fact，然后通过变量名调用。\r\n还可以把它作为参数传递：\r\n# map函数返回一个可迭代对象，里面的元素是把第一个参数（一个函数）应用到# 第二个参数（一个可迭代对象，这里是 range(11)）中各个元素上得到的结果map(factorial, range(5))# help(map)list(map(factorial, range(5)))\r\n高阶函数\r\n接受函数为参数，或者把函数作为结果返回的函数是高阶函数（higher-order\r\nfunction）\r\n示例1：根据单词长度给一个列表排序,只需把\r\nlen函数传给key参数。\r\nfruits = [&#x27;strawberry&#x27;, &#x27;fig&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;raspberry&#x27;, &#x27;banana&#x27;]sorted(fruits, key=len)help(sorted)\r\n任何单参数函数都能作为key参数的值。\r\n总结\r\n\r\n函数定义以 def 关键词开头，后接函数标识符、圆括号()和冒号\r\n圆括号之间用于定义输入参数（可选）\r\n函数体必须缩进，第一行可以使用文档字符串（用于存放函数说明）\r\n函数是一等对象\r\n调用函数时,Python\r\n会执行函数内部的代码，函数执行完之后，返回到主程序。\r\n\r\n函数的参数\r\n从函数定义和调用的角度可以将参数分为：\r\n\r\n形式参数\r\n实际参数\r\n\r\n从参数在函数中的具体使用可分为下面 4 种类型：\r\n\r\n位置参数：def func(a, b): pass\r\n关键字参数：def func(a, b=1): pass\r\n任意位置参数：def func(a, b=1, *c): pass\r\n任意关键字参数：def func(a, b=1, *c, **d): pass\r\n\r\n位置参数\r\n位置参数是 Python\r\n函数调用中最基础的参数传递方式，它通过参数的位置来确定实参与形参的对应关系。调用函数时，传入的实参顺序必须与函数定义时形参的顺序严格一致。\r\ndef add_numbers(a, b):    &quot;&quot;&quot;返回两个数的和&quot;&quot;&quot;    return a + bresult = add_numbers(3, 5)print(result)\r\n在上述代码中，add_numbers函数定义了两个形参a和b。调用函数时，实参3对应形参a，实参5对应形参b\r\n，这就是通过位置建立的参数对应关系。如果调用时改变实参顺序，如add_numbers(5, 3)，虽然也能正确执行，但传递的参数含义会发生变化。\r\n关键字参数\r\n关键字参数允许在调用函数时通过参数名指定对应的值，这样可以避免因位置顺序错误导致的参数传递混乱，并且实参顺序可以与函数定义时形参顺序不同。\r\ndef greet(name, message):    &quot;&quot;&quot;打印问候语&quot;&quot;&quot;    print(f&quot;&#123;name&#125;, &#123;message&#125;&quot;)# 正常顺序使用关键字参数greet(name=&quot;Alice&quot;, message=&quot;欢迎！&quot;)# 打乱顺序使用关键字参数greet(message=&quot;你好！&quot;, name=&quot;Bob&quot;)\r\n上述代码中，greet函数有name和message两个形参。调用时通过name=值、message=值的形式明确指定参数对应关系，即使交换实参顺序，也不影响参数的正确传递。\r\n位置参数和关键字参数还可以混合使用，但要遵循位置参数必须在前、关键字参数在后的原则。例如：\r\ndef divide(dividend, divisor):    &quot;&quot;&quot;返回除法结果&quot;&quot;&quot;    return dividend / divisor# 混合使用示例result = divide(10, divisor=2)print(result)\r\n这里10是位置参数对应dividend，divisor=2是关键字参数，位置和关键字参数各司其职，共同完成函数调用。\r\n默认参数\r\n默认参数是指在函数定义时，为形参指定一个默认值。当调用函数时，如果没有为该形参传递对应的实参，那么这个形参就会自动使用预先设定的默认值。\r\ndef say_hello(name=&quot;陌生人&quot;):    &quot;&quot;&quot;打印问候语，若未传入名字则使用默认值&quot;&quot;&quot;    print(f&quot;你好，&#123;name&#125;!&quot;)# 未传入参数，使用默认值say_hello()# 传入参数，覆盖默认值say_hello(&quot;Charlie&quot;)\r\n在say_hello函数中，name形参的默认值为\"陌生人\"。当直接调用say_hello()时，name使用默认值；而调用say_hello(\"Charlie\")时，name被赋值为\"Charlie\"，默认值被覆盖。\r\n任意位置参数\r\n任意位置参数可以接受任意数量的位置参数。\r\n将一组可变数量的位置参数集合成参数值的元组。\r\ndef calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    print(numbers)    return sumcalc(1, 2, 3, 4, 5, 6)calc(1, 2, 3, 4, 5, 6, 7, 8)\r\n任意关键字参数\r\n任意关键字参数允许传入0个或任意个含参数名的参数\r\n这些关键字参数在函数内部自动组装为一个字典。\r\ndef person(name, age, **kw):    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw) \r\n这时候你可以传入任意个数的关键字参数：\r\nperson(&#x27;Jane&#x27;, 6, city=&#x27;shijiazhuang&#x27;, gender=&#x27;F&#x27;, weight=&#x27;30kg&#x27;)\r\nname: Jane age: 6 other: &#123;&#x27;city&#x27;: &#x27;shijiazhuang&#x27;, &#x27;gender&#x27;: &#x27;F&#x27;, &#x27;weight&#x27;: &#x27;30kg&#x27;&#125;\r\n使用**可以将多个关键字参数收集到一个字典中，参数的名字是字典的键，值是字典的值。\r\n通常把 任意位置参数 和\r\n任意关键字参数 称为 可变参数 或\r\n不定长参数。\r\n一般不定长参数会写成 *args 和 **kwargs\r\n\r\n只有星号是必要的，args 和 kwargs 是约定俗成的\r\n\r\n拆分参数列表\r\n如果一个函数所需要的参数已经存储在了列表、元组或字典中，则可以直接从列表、元组或字典中拆分出来函数所需要的这些参数。\r\n列表、元组拆分出来的结果作为位置参数\r\ndef calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    print(numbers)    return sum\r\n# 参数已经存储在列表 l1 或元组 l2l1 = [1, 2, 3]l2 = (1, 2, 3, 4, 5, 6)# calc(l1[0], l1[1], l1[2])calc(*l2)\r\n\r\n注释掉的 calc(l1[0], l1[1], l1[2])\r\n是一种传统的函数调用方式，需要依次写出列表中的每个元素作为参数传入。但这种方式在列表元素较多时会很繁琐。\r\ncalc(*l2) 这里使用了 * 操作符对元组\r\nl2 进行解包（拆分）。* 操作符会将元组\r\nl2 中的元素逐一提取出来，作为位置参数传递给\r\ncalc 函数，等同于 calc(1, 2, 3, 4, 5, 6)\r\n。这样就实现了从元组中拆分参数来调用函数，避免了手动逐个列出参数的麻烦，当参数数量较多或者参数存储在列表、元组中时，这种方式更加简洁高效。\r\n\r\n字典拆分出来的结果作为关键字参数\r\ndef person(name, age, **kw):    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)    # 参数已经存储在字典 extra 中extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;person(&#x27;Jack&#x27;, 6, **extra)# name: Jack age: 6 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;\r\n函数的实参传递\r\nPython中“一切皆对象”，所有赋值操作都是“引用的赋值”。\r\nPython实参总是通过引用传递的(通过对象传递)。当函数调用提供一个实参时，Python\r\n将实参对象的*引用*(而不是对象本身)复制到相应的形参中。\r\n这将大大提高性能。函数经常对大型对象进行操作——频繁地复制它们将消耗大量计算机内存并显著降低程序性能。\r\n将对象传递给函数\r\n# 定义一个 cube 函数来显示其参数的标识，并返回该参数值的立方def cube(number):    print(&#x27;id(number):&#x27;, id(number))    return number ** 3# 首先创建整型变量 x,后续使用 x 作为函数实参；# x引用（指向）存储数值 7 的整数对象。x = 7# 获取对象标识id(x)# 使用参数 x 调用 cube, x指向存储数值 7 的整数对象。cube(x)# id(x): 4311131544# id(number): 4311131544# 343\r\ncube 的形参number的标识与前面 x\r\n显示的相同。因为每个对象都有唯一的标识，所以，在 cube 执行时，实参 x\r\n和形参 number 都引用同一个对象。因此，当 cube\r\n在计算中使用形参number时，它将从调用者中的原始对象中获取number值。\r\n# 还可以使用 Python 中的 is 操作符证明实参和形参引用相同的对象x = 7 # x是全局变量def cube(number):    print(&#x27;number is x:&#x27;, number is x)    return number ** 3cube(x)# number is x: True# 343\r\n从参数对象的类型来看可以将参数分为以下两类：\r\n\r\n传递可变对象的引用\r\n传递不可变对象的引用\r\n\r\n传递不可变对象的引用\r\n当一个函数接收一个不可变对象的引用作为参数时（例如整数、浮点数、字符串或元组），这意味着一旦它们被创建，其值就不能被修改。\r\n当把不可变对象作为参数传递给函数时，函数接收到的是该对象的引用。但即便在函数内部操作这个引用，也无法改变原始对象的值。\r\n例如，将一个整数传递给函数，在函数内对这个整数进行重新赋值等操作，不会影响到函数外部原始的整数变量。因为对不可变对象的操作，实际上是重新创建了一个新的对象，而不是修改原来的对象。\r\nb = 12print(id(b))def test0(m):    print(id(m))    m += 1     # 实际上创建了一个新对象，然后将新对象的引用赋值给形参 m    print(id(m))    print(m)test0(b)print(b)print(m)\r\n传递可变对象的引用\r\n列表、字典等在 Python 里是可变对象，它们的值可以被修改。\r\n当把可变对象作为参数传递给函数时，传递的同样是对象的引用。函数可以通过这个引用直接修改对象内部的值。\r\n传递参数是不论是可变对象还是不可变对象，实际传递的还是对象的引用。\r\n注意：在定义函数时，不要把可变的数据类型（列表、字典）当作关键字参数的参数值。\r\ndef test0(n, alist=[]):    alist.append(n)    return alistprint(test0(1))print(test0(2)) #[1, 2]print(test0(3)) #[1, 2, 3]\r\n如何避免这种情况\r\ndef test0(n, alist=None):    if alist is None:        alist = []    alist.append(n)    return alistprint(test0(1)) #[1]print(test0(2)) #print(test0(3))\r\n函数参数示例：\r\n现在有一个分类器，我们用它来解决二分类问题，现在在测试集上的测试结果如下：\r\npredicted_labels = [1, 0, 0, 1, 0, 1, 1, 0, 0, 0]\r\n真实标签为：\r\ntrue_labels = [1, 0, 1, 1, 0, 1, 0, 0, 0, 1]\r\n请设计一个函数，用来进行模型评估，输入为预测标签列表和真实标签列表，输出模型预测正确率，查准率和查全率。\r\ndef evaluate_classifier(predicted_labels, true_labels):    &quot;&quot;&quot;    评估二分类模型的性能        参数:    predicted_labels: 模型预测的标签列表    true_labels: 真实的标签列表        返回:    dict: 包含准确率(accuracy)、精确率(precision)和召回率(recall)的字典    &quot;&quot;&quot;    if len(predicted_labels) != len(true_labels):        raise ValueError(&quot;预测标签和真实标签的长度必须相同&quot;)        # 初始化计数器    true_positives = 0    # 真正例    false_positives = 0   # 假正例    false_negatives = 0   # 假负例    total_samples = len(true_labels)    correct_predictions = 0        # 计算各类样本数量    for pred, true in zip(predicted_labels, true_labels):        if pred == true:            correct_predictions += 1                if pred == 1 and true == 1:            true_positives += 1        elif pred == 1 and true == 0:            false_positives += 1        elif pred == 0 and true == 1:            false_negatives += 1        # 计算评估指标    accuracy = correct_predictions / total_samples        # 处理精确率的边界情况（避免除以零）    if (true_positives + false_positives) == 0:        precision = 0    else:        precision = true_positives / (true_positives + false_positives)        # 处理召回率的边界情况（避免除以零）    if (true_positives + false_negatives) == 0:        recall = 0    else:        recall = true_positives / (true_positives + false_negatives)        return &#123;        &quot;accuracy&quot;: accuracy,        &quot;precision&quot;: precision,        &quot;recall&quot;: recall    &#125;# 使用你提供的数据predicted_labels = [1, 0, 0, 1, 0, 1, 1, 0, 0, 0]true_labels = [1, 0, 1, 1, 0, 1, 0, 0, 0, 1]results = evaluate_classifier(predicted_labels, true_labels)print(f&quot;准确率 (Accuracy): &#123;results[&#x27;accuracy&#x27;]:.3f&#125;&quot;)print(f&quot;精确率 (Precision): &#123;results[&#x27;precision&#x27;]:.3f&#125;&quot;)print(f&quot;召回率 (Recall): &#123;results[&#x27;recall&#x27;]:.3f&#125;&quot;)\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之匿名函数，闭包与装饰器","url":"/posts/63235.html","content":"匿名函数\r\nlambda函数\r\n匿名函数（也称为lambda函数）是一种可以在需要时快速定义的小型函数。\r\nsq = lambda x: x * xsq(2)\r\n这里用到的 lambda\r\n表达式与下面的函数定义有着相同的功能：\r\ndef sq(x):    return(x * x)sq(2)print((lambda x: x * x)(2))\r\nlambda表达式的基本语法如下：\r\n         lambda arg1，arg2，arg3...: &lt;表达式&gt;\r\n                    \r\n   其arg1/arg2/arg3为函数的参数\r\n   &lt;表达式&gt;相当于函数体\r\n   函数返回值：表达式的计算结果\r\n注意：\r\n\r\nlambda实际生成了一个函数对象。\r\nlambda表达式只允许包含一个表达式。\r\n\r\nlambda函数的使用：\r\n可以作为另一个函数的参数传递，用于定制特定的行为。\r\nnums = [1, 2, 3, 4, 5]result = list(map(lambda x: x + 1, nums))print(result)\r\n参数中可以使用lambda作为参数的还有map()等。\r\n使用lambda表达式反转拼写，然后依此给单词列表排序\r\nfruits = [&#x27;strawberry&#x27;, &#x27;fig&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;raspberry&#x27;, &#x27;banana&#x27;]sorted(fruits, key=lambda word: word[::-1])\r\n除了作为参数传递给高阶函数之外，Python 很少使用匿名函数。\r\nlambda句法只是语法糖：与\r\ndef语句一样，lambda表达式会创建函数对象。\r\n总结：\r\n\r\n匿名函数是Python中的一种快速定义小型函数的方式\r\n它没有函数名，使用lambda关键字定义\r\n匿名函数可以简化代码、作为函数参数传递以及在列表推导中应用\r\n\r\n闭包\r\n\r\n闭包的定义\r\n在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。\r\n闭包的构成条件 在函数嵌套的前提下\r\n内部函数使用了外部函数的变量或者参数 外部函数返回了内部函数\r\n闭包的作用 可以保存外部函数内的变量，不会随着外部函数调用完而销毁\r\n由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。\r\n\r\n#在函数嵌套的前提下def outer():    num1=10     def inner():        re=num1+10 #内部函数使用了外部函数的变量或者参数        print(re)    return inner   #外部函数返回了内部函数,这个使用外部函数变量的内部函数称为闭包#获取闭包对象new_fun=outer() #这个new_fun就是闭包#执行闭包new_fun()\r\n举例：\r\n假如有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值。\r\n例如，商品历史周期内的平均价格，每天添加一个新的价格，目前为止均价的计算要考虑商品全部价格。\r\n# 计算移动平均值的类class Averager():    def __init__(self):        self.series = []    def __call__(self, new_value):         self.series.append(new_value)         total = sum(self.series)         return total/len(self.series)# 计算移动平均值的高阶函数。# 当调用make_averager函数时，返回的是averager函数对象。# 每次averager被调用时，它会将传递的参数追加到series，并计算当前的平均数。def make_averager():      total = 0    count = 0        def averager(new_value):                 count = count + 1  #本意想修改外部函数，其实是再闭包内定义了一个局部变量        total += new_value         return total/count    return averager# Averager的实例是可调用对象avg = Averager()print(avg(10))print(avg(11))print(avg(12))avg2 = make_averager()print(avg2(10))print(avg2(11))print(avg2(12))\r\naverager 是定义在 make_averager\r\n内部的函数，形成了闭包\r\n在averager内部，series是一个自由变量。\r\n这是一个技术术语，指未在本地作用域中绑定的变量。\r\n\r\n\r\nimage-20250514153301357\r\n\r\n&#x27;&#x27;&#x27;Python 在 __code__ 属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称。series 的绑定在返回的 avg 函数的 __closure__ 属性中。avg.__closure__ 中的各个元素对应于avg.__code__.co_freevars 中的一个名称。这些元素是 cell 对象，有个 cell_contents 属性，保存着真正的值。&#x27;&#x27;&#x27;print(avg.__code__.co_varnames)print(avg.__code__.co_freevars)print(avg.__closure__) # doctest: +ELLIPSISprint(avg.__closure__[0].cell_contents)\r\n示例：\r\n创建一个闭包实现计数器\r\n编写一个闭包函数，它应该提供一个计数器功能。每次调用该闭包时，它应返回下一个整数。\r\n例如，首次调用返回 1，下一次调用返回 2，依此类推。\r\n提示： 使用一个非局部变量来存储当前计数。\r\ncounter() 1counter() 2counter() 3\r\ndef create_counter():    count = 0  # 非局部变量，用于存储当前计数值    def counter():        nonlocal count  # 声明 count 是外层函数的变量        count += 1     # 每次调用时增加计数        return count   # 返回新的计数值    return counter  # 返回闭包函数# 创建计数器counter = create_counter()# 测试计数器print(counter())  # 输出 1print(counter())  # 输出 2print(counter())  # 输出 3\r\n总结\r\n\r\n闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。\r\n注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。\r\n\r\n装饰器\r\n装饰器是 Python\r\n中一种强大且灵活的语法结构，本质上是一个闭包函数。它可以在不改变原函数代码和调用方式的前提下，为函数增添新的功能。这就好比给一个物品添加装饰，在不改变物品本身核心功能的基础上，让它具备更多特性。\r\n装饰器在代码的可维护性、复用性和可读性方面都有很大帮助，广泛应用于日志记录、性能测试、权限验证等场景。\r\n\r\n是一种函数，有内置的装饰器，也可以自定义装饰器，本质上就是一个闭包函数。\r\n可以在不改变函数调用方式的情况下给函数增加对应功能\r\n通过@加上命名进行使用，作用在函数声明的前面，如下：\r\n\r\n@propertydef value(self):    return self._value\r\n简单来说，装饰器函数接收一个函数作为参数，然后返回一个新的函数。新函数通常会在执行原函数前后添加额外的逻辑，从而实现功能增强。\r\n内置装饰器示例\r\nPython 有一些内置装饰器，例如@property\r\n，它用于将类中的方法转换为属性调用的形式，让代码更加简洁直观。\r\nclass Person:    def __init__(self, age):        self._age = age    @property    def age(self):        return self._ageperson = Person(30)print(person.age)  # 像访问属性一样访问方法\r\n@property\r\n装饰器把age方法装饰成了一个属性，调用person.age时，实际上调用的是被装饰的age方法，但看起来就像在访问一个普通属性，提升了代码的易用性。\r\n自定义装饰器示例\r\n下面通过一个简单的例子来展示如何自定义装饰器，实现函数执行时间的计算功能。\r\nimport timedef timer(func):    def wrapper():        start_time = time.time()        func()        end_time = time.time()        print(f&quot;函数 &#123;func.__name__&#125; 执行耗时: &#123;end_time - start_time&#125; 秒&quot;)    return wrapper@timerdef say_hello():    time.sleep(2)    print(&quot;Hello!&quot;)say_hello()\r\n\r\n定义装饰器函数 timer\r\n\r\ntimer 函数接收一个函数 func\r\n作为参数，这是装饰器的基本形式，即接收被装饰的函数。\r\n内部定义了一个 wrapper 函数，wrapper\r\n函数就是闭包函数，它可以访问外部函数 timer 作用域内的\r\nfunc 变量。\r\n在 wrapper 函数中，首先记录开始时间\r\nstart_time = time.time() ，然后调用原函数\r\nfunc() ，再记录结束时间 end_time = time.time()\r\n，最后计算并打印函数执行的耗时。\r\ntimer 函数最后返回 wrapper 函数对象。\r\n\r\n使用装饰器\r\n\r\n@timer 语法将 timer 装饰器应用到\r\nsay_hello 函数上，这等同于执行\r\nsay_hello = timer(say_hello) 。\r\n调用 say_hello() 时，实际上调用的是\r\nwrapper 函数，wrapper 函数会在执行\r\nsay_hello 函数的前后添加计算时间的逻辑，从而实现了在不改变\r\nsay_hello\r\n函数本身代码和调用方式的情况下，为其增添了计算执行时间的功能。\r\n\r\n\r\n带参数的装饰器\r\n有时候我们需要给装饰器传递参数，来定制不同的装饰逻辑。下面是一个带参数的装饰器示例，用于根据不同的日志级别打印函数调用信息。\r\ndef logger(level):    def decorator(func):        def wrapper():            if level == &quot;DEBUG&quot;:                print(f&quot;DEBUG: 调用函数 &#123;func.__name__&#125;&quot;)            elif level == &quot;INFO&quot;:                print(f&quot;INFO: 调用函数 &#123;func.__name__&#125;&quot;)            func()        return wrapper    return decorator@logger(level=&quot;INFO&quot;)def greet():    print(&quot;Welcome!&quot;)greet()\r\n\r\n定义带参数的装饰器外层函数 logger\r\n\r\nlogger 函数接收一个参数 level\r\n，用于指定日志级别。\r\n它返回另一个函数 decorator ，decorator\r\n函数才是真正接收被装饰函数的装饰器函数。\r\n\r\ndecorator 函数\r\n\r\n接收被装饰的函数 func ，内部定义 wrapper\r\n函数。\r\nwrapper 函数根据传入的 level\r\n参数进行不同的日志打印，然后调用原函数 func 。\r\ndecorator 函数返回 wrapper 函数。\r\n\r\n使用带参数的装饰器\r\n\r\n@logger(level=\"INFO\") 这种形式先调用\r\nlogger 函数并传入 level\r\n参数，得到具体的装饰器函数，再将其应用到 greet\r\n函数上。这样就实现了根据不同参数定制装饰器行为的功能。\r\n\r\n\r\n总结：\r\n\r\n装饰器可以在不改变原函数的定义和调用方式的基础上，增强函数的功能。\r\n严格来说，装饰器只是语法糖。装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。\r\n装饰器能把被装饰的函数替换成其他函数。\r\n\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之变量的作用域","url":"/posts/10432.html","content":"变量的作用域\r\n局部变量和全局变量。\r\n变量的作用域是指变量的作用范围，即定义一个变量后，在哪些地方可以使用这个变量。\r\n按照作用域的不同，Python 中的变量可分为局部变量和全局变量。\r\n例：我们定义并测试一个函数，它读取两个变量的值。\r\n# 读取两个变量的值。变量a是函数的参数；变量b，这个函数没有定义它。def f1(a):    print(a)    print(b)b = 5f1(2)# 2# 5\r\n局部变量：在一个函数中定义的变量就是局部变量（包括形参），其作用域是从定义局部变量的位置至函数结束位置。\r\n全局变量：在所有函数外定义的变量就是全局变量，其在所有函数中都可以使用。\r\ndef f1(a):    print(a)    print(b)b = 6     #如果先给全局变量b赋值，然后再调用f1,就不会出错。f1(3)\r\nb = 6def f2(a):    print(a)    b = 7    print(b)    b = 9  # Python编译函数定义体时，判断b是局部变量，因为在函数中给它赋值了。f2(3)# 3# 7\r\n这不是缺陷，而是设计选择：Python\r\n不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\r\nglobal\r\n如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global\r\n声明：\r\nb = 6def f3(a):    global b    print(a)    print(b)    b = 9f3(3)b# 3# 6# 9\r\nnonlocal\r\n在Python\r\n中，函数的定义可以嵌套，即在一个函数的函数体中可以包含另一个函数的定义\r\n通过 nonlocal\r\n关键字，可以使内层的函数直接使用外层函数中定义的变量。\r\ndef outer_function():    counter = 0          def inner_function():        nonlocal counter  # 声明 counter 是非局部的        counter += 1        return counter    return inner_functionfunc = outer_function()func()print(func())# 2\r\n总结：\r\n\r\n局部变量与全局变量。\r\nPython\r\n不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\r\nglobal 和 nonlocal 关键字。\r\n\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之对象和类","url":"/posts/62472.html","content":"对象和类\r\n由对象说起\r\n对象与对象名称之间的区别\r\n把变量理解为附加在对象上的标注。创建对象之后才会把变量分配给对象\r\n例：变量 a 和 b 引用同一个列表，而不是那个列表的副本\r\na = [1, 2, 3]b = ab.append(4)b\r\n\r\n\r\nimage-20250514154637571\r\n\r\n类与实例\r\n在Python中通常使用class语句来定义一个类（类对象）\r\nclass定义的对象（类）可以用于产生新的对象（实例）。\r\nclass Person():    pass    someone = Person()print(id(someone), type(someone))\r\n上面的例子中Person是我们创建的一个新的类，通过调用Person()可以获得一个Person类型的实例对象，将其赋值为someone，就成功创建了一个与所有内置对象类型不同的对象someone，它的类型为__main__.Person。到这里，可以将Python中一切的对象分为两种：\r\n\r\n可以用来生成新对象的类，包括内置的int、str以及上面定义的Person等；\r\n由类生成的实例对象，包括内置类型的数字、字符串、以及上面定义的类型为__main__.Person的someone。\r\n\r\n类中的属性对应前面所学习的变量，而类中的方法对应前面所学习的函数。\r\n通过类，可以把数据和操作封装在一起，从而使得程序结构更加清晰，这也就是所谓的类的封装性。\r\n在类的内部，使用def关键字可以为类定义一个方法，\r\n与一般函数定义不同，方法必须包含参数self，且为第一个参数。\r\nclass Person():    name = &#x27;TZ&#x27;    sex = &#x27;F&#x27;    def jump(self):        print(&#x27;Jumping!&#x27;)tz = Person()tz.jump()tz.nametz.sex\r\n特殊的对象初始化方法__init__\r\n# 初始化一个 Person 类的 name 属性class Person():    def __init__(self, name):        self.name = namesomeone = Person(&#x27;小明&#x27;)print(someone)print(someone.name)  # 访问类属性\r\n上面代码执行流程：\r\n\r\n查看Person类的定义；\r\n在内存中实例化（创建）一个新的对象；\r\n调用对象的__init__方法，将这个新创建的对象作为self参数传入，并将另一个参数（‘小明’）作为name传入；\r\n将name的值存入对象；\r\n返回这个新的对象；\r\n将名字someone与这个对象关联。\r\n\r\n提示：每次创建对象时，系统都会在内存中选择一块区域分配给对象，每次选择的内存通常是不一样的。因此，实际运行时会看到一个不同的\r\nPerson 对象地址。\r\nclass Person():    def __init__(self, name, age):                self.name = name        self.age = age    def get_name(self):        return self.name    def set_name(self, name):        self.name = name    def get_age(self):        return self.age    def set_age(self, age):        self.age = age\r\n注意：在类的内部，使用def关键字可以为类定义一个方法，\r\n当调用一个特定对象的方法时，Python\r\n隐式地传递对该对象的引用作为方法的第一个参数。\r\n因此，在一个类中，所有方法必须包含参数self，且为第一个参数。\r\n类中的方法只能使用该引用（self）来访问对象的属性和其他方法。\r\n总结：\r\n\r\n对象既包含数据（称为特性/属性），也包含代码（称为方法）\r\n类是对象的模板，从类制作对象的过程，称为类的实例化\r\n在类的内部，方法定义时必须包含参数self，且为第一个参数\r\n__init__是初始化方法，当创建了实例时会调用该方法\r\n类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线,\r\n实例名和模块名都采用小写格式，并在单词之间加上下划线\r\n\r\n实例\r\n创建一个名为 BankAccount 的类, 要求：\r\n\r\n属性： balance（表示账户余额）\r\n方法： deposit(amount)，用于存款，返回账户余额。\r\nwithdraw(amount)，用于取款，返回账户余额，若余额不足则返回“余额不足”信息。\r\nget_balance()，用于返回当前余额。\r\n\r\n创建实例，并调用上述方法。\r\nclass BankAccount:    def __init__(self):        self.balance = 0  # 初始化账户余额为0    def deposit(self, amount):        if amount &gt; 0:            self.balance += amount            return self.balance        else:            print(&quot;存款金额必须大于0&quot;)            return self.balance    def withdraw(self, amount):        if amount &gt; 0:            if self.balance &gt;= amount:                self.balance -= amount                return self.balance            else:                return &quot;余额不足&quot;        else:            print(&quot;取款金额必须大于0&quot;)            return self.balance    def get_balance(self):        return self.balance# 创建BankAccount类的实例account = BankAccount()# 调用存款方法print(account.deposit(1000))# 调用取款方法print(account.withdraw(300))# 调用获取余额方法print(account.get_balance())\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Python面向对象之类的继承，类中封装和可管理属性","url":"/posts/49265.html","content":"类的继承\r\n从已有类中衍生出新的类，添加或修改部分功能，能提高代码复用。\r\n子类是从父类派生出来的新类。\r\n子类继承了父类的属性和方法，并且可以添加自己的属性和方法。\r\nclass A():    def foo(self):        print(&#x27;A.foo&#x27;)    def zoo(self):        print(&#x27;A.zoo&#x27;)        class B(A): #  B 类将继承 A 类的所有属性和方法。    def fooo(self):        super().foo() # 使用 super() 函数调用父类 A 的 foo方法。        print(&#x27;B.foo&#x27;)    def bar(self):        print(&#x27;B.bar&#x27;)        a = A()b = B()b.bar()a = A()b = B()# a.foo()# b.fooo()# b.zoo()   # 继承自类 A，可以直接使用类 A 的所有方法。# b.foo()# b.bar()\r\n使用super( )从父类得到帮助\r\nclass Person():    def __init__(self, name):        print(&quot;Initializing Person&quot;)        self.name = name    class EmailPerson(Person):    def __init__(self, name, email):        print(&quot;Initializing EmailPerson&quot;)        super().__init__(name)        self.email = email        zhangsan = EmailPerson(&quot;zhangsan&quot;, &quot;123@aaa.com&quot;)print(zhangsan.email)# Initializing EmailPerson# Initializing Person# 123@aaa.com\r\n\r\nclass EmailPerson(Person): 定义了\r\nEmailPerson 类，它继承自 Person 类，这意味着\r\nEmailPerson 类拥有 Person\r\n类的属性和方法。\r\n__init__ 是子类的构造方法，接收 name 和\r\nemail 两个参数。首先打印子类的初始化信息，然后使用\r\nsuper().__init__(name) 调用父类的 __init__\r\n方法，将 name\r\n参数传递给父类构造函数，完成父类部分的初始化工作，最后将\r\nemail 赋值给子类特有的实例属性 self.email\r\n。这里 super()\r\n函数的作用是获取父类的定义，从而调用父类的方法，避免在子类中重复编写父类已有的初始化逻辑。\r\n\r\n方法重写\r\n是指子类可以对从父类中继承过来的方法进行重新定义，从而使得子类对象可以表现出与父类对象不同的行为。\r\n例：创建一个名为”Person”的父类，具有属性”name”和”age”。添加一个名为”get_info”的方法，打印人的姓名和年龄。\r\n然后，创建一个名为”Student”的子类，继承自Person类，并添加一个额外的属性”grade”。在Student类中重写”get_info”方法，也打印出成绩。\r\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age    def get_info(self):        print(&quot;姓名:&quot;, self.name)        print(&quot;年龄:&quot;, self.age)class Student(Person):    def __init__(self, name, age, grade):        super().__init__(name, age)        self.grade = grade    def get_info(self):        super().get_info()        print(&quot;成绩:&quot;, self.grade)\r\n多态\r\n多态，是指在执行同样代码的情况下，系统会根据对象实际所属的类去调用相应类中的方法。\r\n在 Python\r\n中编写一个函数，传递实参前其参数的类型并不确定，在函数中使用形参进行操作时只要传入的对象能够支持该操作程序就能正常执行\r\n。\r\n例：鸭子类型\r\n在程序设计中，鸭子类型（duck\r\ntyping）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。支持“鸭子类型”的语言的解释器/编译器会在解释或编译时推断对象的类型。在鸭子类型中，关注的不是对象所属的类，而是一个对象能够如何使用。\r\nclass Person: # 定义 Person 类    def CaptureImage(self):  # 定义 CaptureImage 方法        print(&#x27;Person 类中的 CaptureImage 方法被调用!&#x27;)class Camera: # 定义 Camera 类    def CaptureImage(self): # 定义 CaptureImage 方法        print(&#x27;Camera 类中的 CaptureImage 方法被调用!&#x27;)def CaptureImageTest(arg): # 定义 CaptureImageTest 方法    arg.CaptureImage() # 通过 arg 调用 CaptureImagep = Person() # 定义 Person 类对象 pc = Camera() # 定义 Camera 类对象 cCaptureImageTest (p)CaptureImageTest (c)\r\n通过统一的方法接口，可以方便地调用不同类中的相同方法。\r\n实例\r\n创建两个不相关的类，分别命名为 ”Book” 和 “DVD”，它们都具有一个方法\r\nplay，但 Book 的 play 方法返回 “Reading the book” 而 DVD 的 play\r\n方法返回 “Playing the DVD”。创建一个函数\r\nstart_playing，接受一个对象并调用其 play 方法，展示鸭子类型。\r\nclass Book:    def play(self):        return &quot;Reading the book&quot;class DVD:    def play(self):        return &quot;Playing the DVD&quot;def start_playing(obj):    return obj.play()# 创建Book和DVD的实例book = Book()dvd = DVD()# 调用start_playing函数print(start_playing(book))print(start_playing(dvd))\r\n类中的封装\r\n在面向对象编程里，类的封装是一种重要特性。它一方面把属性和方法集合在一起，形成一个逻辑单元，让代码结构更清晰；另一方面，它还能把类里一些不希望被外部随意访问、只在类内部使用的属性和方法隐藏起来，提高代码的安全性和稳定性。\r\n\r\n集合了对应的属性和方法\r\n将类中私有的、只在内部使用的属性和方法进行隐藏\r\n\r\n第一是约定任何以单下划线_开头的名字都应该是内部实现。\r\nclass A():    def __init__(self):        self._internal = 0          self.public = 1      def public_method(self):        pass    def _internal_method(self):        passa = A()a._internal_method()\r\n\r\n属性和方法定义：在 A\r\n类中，_internal 是属性，_internal_method\r\n是方法，它们都以单下划线开头，表明是内部使用的。而 public\r\n属性和 public_method\r\n方法没有下划线，是供外部正常访问的。\r\n访问情况：虽然 Python\r\n不会从语法层面阻止外部访问这些带单下划线开头的属性和方法，像\r\na._internal_method()\r\n这样的调用是可以执行的，但这不符合规范。这只是一种约定，提醒开发者这些是类的内部实现细节，最好不要在外部调用，否则可能破坏类的设计逻辑，让代码变得脆弱、难以维护。而且这种约定不仅适用于类，模块名（如\r\n_private_module ）和模块级别函数（如\r\nsys._getframe() ）也适用，使用时要谨慎。\r\n\r\n第二，使用双下划线__开始\r\n当属性或方法以双下划线 __ 开头时，Python\r\n会对其名称进行特殊处理。\r\n会导致访问名称变成其他形式（名称改写／name mangling）。\r\nclass B():    def __init__(self):        self.__private = 0    def __private_method(self):        print(self.__private)    def public_method(self):        self.__private_method()        passb = B()b.__dict__  # Python会把属性名存入实例的__dict__属性中\r\n\r\n名称改写：在 B\r\n类中，__private 属性和 __private_method\r\n方法，Python 会将它们重命名为 _B__private 和\r\n_B__private_method 。查看实例 b 的\r\n__dict__\r\n属性（它存储了实例的属性信息），就能发现这种改写后的名称。\r\n目的：这种机制主要是为了在继承时防止子类意外覆盖父类的私有属性和方法。比如：\r\n\r\nclass C(B):    def __init__(self):        super().__init__()        self.__private = 1   # does not override B.__private    # does not override B.__private_method()            def __private_method(self):        passc = C()c.__dict__ # c._B__private_method()\r\n在子类 C 中，__private 和\r\n__private_method 同样会被改写，变成\r\n_C__private 和 _C__private_method ，和父类\r\nB\r\n中对应的名称不一样，所以不会覆盖父类的私有属性和方法。\r\nPython 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多\r\nPython 程序员严格遵守的约定，他们不会在类外部访问这种属性。\r\n当你定义的一个变量和某个保留关键字冲突，可以使用单下划线作为后缀：\r\n总结：\r\n\r\n_和__都可以定义私有属性\r\n使用__来定义的属性，调用时需要将命名方式调整为_ClassName__methodName\r\n__方法适用于需要在子类中进行隐藏的情况\r\n\r\n创建可管理属性\r\n可管理属性是Python面向对象编程中一个强大的特性，它允许你控制对类属性的访问、修改和删除操作。\r\n在面向对象编程中，我们有时需要对属性的访问进行控制：\r\n\r\n在设置属性时进行类型检查或验证\r\n在获取属性时进行计算或格式化\r\n防止某些属性被删除\r\n创建只读属性\r\n\r\n在对实例属性的获取和设定上，有时候我们希望增加一些额外的处理过程（比如类型检查或者验证）。这种机制可以用于对”私有”属性进行访问和修改。\r\n使用property\r\n要自定义对属性的访问，一种简单的方式是将其定义为\r\nproperty\r\nproperty把类中定义的函数当做一种属性来使用。\r\nproperty()函数可以创建一个属性，它允许你定义getter、setter和deleter方法。\r\nproperty(fget=None, fset=None, fdel=None, doc=None)\r\n\r\nfget: 获取属性值的函数\r\nfset: 设置属性值的函数\r\nfdel: 删除属性的函数\r\ndoc: 属性的文档字符串\r\n\r\n下面的示例代码定义了一个property，增加了对属性的验证。\r\nclass Person():    def __init__(self, first_name):        self.first_name = first_name  # 这里会调用setter方法    def get_first_name(self):        print(&quot;get_first_name is called.&quot;)        return self._first_name    def set_first_name(self, value):        print(&quot;set_first_name is called.&quot;)        if not isinstance(value, str):            raise TypeError(&#x27;Expected a string&#x27;)        self._first_name = value    def del_first_name(self):        print(&quot;del_first_name is called.&quot;)        raise AttributeError(&quot;Can&#x27;t delete attribute&quot;)    first_name = property(get_first_name, set_first_name, del_first_name, &quot;first_name property&quot;)    # 每次对 first_name 这个属性进行访问（获取值、设置值或删除属性）时，都会触发对应的方法。    # 实际的数据存储在 _first_name 属性中。a = Person(21)# print(a._first_name)# a.__dict__\r\n上例中，使用property()定义了一个属性first_name\r\n\r\nproperty()的第一个参数是getter方法，第二个参数是setter方法，第三个参数是deleter方法\r\nproperty\r\n的一个关键特征是它看上去跟普通的属性（attribute）没什么两样，但是访问它的时候会自动触发getter、setter、deleter方法。\r\n\r\n在实现一个 property\r\n的时候，底层数据（如果有的话）仍然需要存储在某个地方\r\n\r\n在getter和setter方法中，你会看到对_firse_name的操作，这也是实际数据保存的地方\r\n数据实际存储在_first_name中（注意前面的下划线表示这是内部属性）。\r\n\r\n为什么__init__()方法中设置了self.first_name而不是self._first_name\r\n\r\n在这个例子中，创建一个 property\r\n的目的就是在设置attribute的时候进行检查\r\n这样设置是为了在初始化的时候也进行这种类型检查\r\n通过设置self.first_name，自动调用setter方法，这个方法里面会进行参数的检查，否则就是直接访问self._first_name了\r\n在__init__方法中设置self.first_name而不是self._first_name，这样会调用setter方法进行验证。\r\n\r\n使用装饰器\r\n另一种定义属性的方法是使用装饰器\r\n装饰器语法提供了更简洁的方式来定义可管理属性。\r\nclass Person():    def __init__(self, first_name):        self.first_name = first_name              # 只有在`first_name`属性被创建后    # 后面的两个装饰器`@first_name.setter`和`@first_name.deleter`才能被定义    @property    def first_name(self):        return self._first_name    @first_name.setter    def first_name(self, value):        print(&quot;setter&quot;)        if not isinstance(value, str):            raise TypeError(&#x27;Expected a string&#x27;)        self._first_name = value    @first_name.deleter    def first_name(self):        raise AttributeError(&quot;Can&#x27;t delete attribute&quot;)a = Person(&quot;Mark&quot;)print(a.first_name)# a.first_name = 42\r\n\r\n装饰器顺序：\r\n\r\n必须先定义@property方法（getter）\r\n然后才能定义@xxx.setter和@xxx.deleter\r\n\r\n方法命名：\r\n\r\n所有相关方法必须使用相同的名称\r\n这是装饰器语法要求的\r\n\r\n文档字符串：\r\n\r\n可以在@property方法中添加文档字符串\r\n通过help(Person.first_name)可以查看\r\n\r\n\r\n上述代码中有三个相关联的方法，这三个方法的名字都必须一样。@property用于指示getter方法，它使得first_name成为一个属性。@first_name.setter用于指示setter方法，@first_name.deleter用于指示deleter方法。需要强调的是只有在first_name属性被创建后，后面的两个装饰器@first_name.setter和@first_name.deleter才能被定义。\r\n注意：不要写没有做任何其他额外操作的property。\r\n另外，property还可以用于创建动态计算的属性，这些属性不会实际存储，而是在访问时计算\r\nimport mathclass Circle():    def __init__(self, radius):        self.radius = radius    @property          # 实现只读，只能访问(get)，无法修改(set)    def area(self):        return math.pi * self.radius ** 2    @property    def perimeter(self):        return 2 * math.pi * self.radiusc = Circle(4.0)     # 创建一个 Circle 实例print(c.radius)     # 打印半径print(c.area)       # 注意这里没有（）print(c.perimeter)  # 注意这里没有（）\r\n特点\r\n\r\n只读属性：如果没有定义setter，属性就是只读的\r\n统一访问接口：无论是存储属性还是计算属性，访问方式都一样\r\n延迟计算：只在访问时计算，节省内存\r\n\r\n在这里，我们通过使用property，将所有的访问接口形式统一起来，对半径、周长和面积的访问都能够简单地以属性的形式进行访问，而不必将属性访问和方法调用混在一起使用了。\r\n如果你没有指定某一特性的*setter*属性（@area.setter），那么将无法在类的外部对它的值进行设置。这对于只读的特性非常有用：\r\n总结：\r\n\r\n类的定义中使用@property可以实现属性的获取（“getter”）\r\n类的定义中使用@setter可以实现属性的设置(“setter”)\r\n\r\n可管理属性是Python面向对象编程中非常强大的特性，它允许你：\r\n\r\n控制属性的访问、设置和删除行为\r\n添加验证逻辑和类型检查\r\n创建动态计算的属性\r\n实现只读属性\r\n保持统一的访问接口\r\n\r\n无论是使用property()函数还是装饰器语法，都能有效地增强类的封装性和安全性。选择哪种方式主要取决于个人偏好和代码的可读性，装饰器语法通常更为简洁明了。\r\n","categories":["语言学习","Python面向对象"],"tags":["学习类","Python","Python面向对象"]},{"title":"Servlet与http","url":"/posts/62509.html","content":"软件架构与网络通信\r\n软件架构：\r\n\r\nB/S：浏览器端-服务器端（JavaEE体系）\r\n客户端不用再去开发，开发更加快速\r\nC/S：客户端-服务器端\r\n\r\n资源分类：\r\n\r\n静态资源：所有用户访问后得到的结果是一样的，称为静态资源\r\n\r\n如html css js\r\n\r\n动态资源：每个用户访问相同资源后，得到的结构可能不一样，称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器\r\n\r\n如 servlet php jsp\r\n\r\n\r\n网络通信三要素：\r\n\r\nIP：电子设备在网络中的唯一标识\r\n端口:应用程序在计算机中的唯一标识\r\n传输协议：规定了通信的规则\r\n\r\n基础协议：tcp udp\r\n\r\n\r\n\r\n\r\nimage-20250413200701460\r\n\r\n\r\n\r\nimage-20250413200701460\r\n\r\nhttp概述\r\nhttp：超文本传输协议\r\n传输协议：定义了客户端和服务器端通信的时候发送数据的格式\r\n特点： - 基于TCP/IP的高级协议 - 默认端口号是80 -\r\n基于请求响应模型，一次请求对应一次响应 -\r\n无状态的，每次请求之间相互独立\r\nhttp的请求消息和请求行\r\n请求消息数据格式：\r\n\r\n请求行\r\n明确请求的基本信息（操作类型、目标资源、协议版本）\r\n请求方式 请求url 请求协议/版本\r\n请求方法：\r\n常见方法（Servlet 中常用）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n含义\r\n特点\r\n是否有请求体\r\n\r\n\r\n\r\n\r\nGET\r\n请求获取资源\r\n请求参数在请求行，数据通过 URL\r\n传递，明文可见，长度有限制（浏览器通常限制 8KB）\r\n无\r\n\r\n\r\nPOST\r\n提交数据（如表单）\r\n数据放在请求体中，适合传输大量数据，安全性较高\r\n有\r\n\r\n\r\nPUT\r\n更新资源（全量更新）\r\n需指定资源完整路径，幂等性（多次操作结果一致）\r\n有\r\n\r\n\r\nDELETE\r\n删除资源\r\n指定 URL 对应的资源，幂等性\r\n无\r\n\r\n\r\nHEAD\r\n获取资源头部信息\r\n仅返回响应头，不返回响应体，用于快速检查资源是否存在\r\n无\r\n\r\n\r\n\r\n请求url：协议://主机:端口/路径?查询参数#锚点\r\n\r\n协议：固定为http或https（如http://）\r\n主机：服务器域名（如www.example.com）或\r\nIP 地址（如192.168.1.1）\r\n端口：可选，默认80（HTTP）或443（HTTPS），如8080\r\n路径：资源在服务器上的路径（如/user/login）\r\n查询参数：可选，格式为key=value&amp;key2=value2，通过?与路径分隔\r\n锚点：客户端浏览器使用，用于定位页面内元素，服务器不处理\r\nServlet服务器接收的 URL 部分：不包含锚点，仅到查询参数为止\r\n\r\n请求头\r\n携带请求的附加信息（客户端环境、请求参数、安全信息等）\r\n请求头名称：请求头值\r\n通用头字段：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n字段名\r\n含义\r\n示例\r\nServlet 获取方法\r\n\r\n\r\n\r\n\r\nHost\r\n目标服务器的主机和端口（必传）\r\nlocalhost:8080\r\nrequest.getHeader(\"Host\")\r\n\r\n\r\nUser-Agent\r\n客户端信息（浏览器 / 操作系统）\r\nMozilla/5.0 (Windows NT 10.0) Chrome/110.0.0.0\r\nrequest.getHeader(\"User-Agent\")\r\n\r\n\r\nReferer\r\n来源页面 URL（防盗链，统计）\r\nhttp://example.com/login.html\r\nrequest.getHeader(\"Referer\")\r\n\r\n\r\nAccept\r\n客户端接受的响应内容类型\r\ntext/html,application/json\r\nrequest.getHeader(\"Accept\")\r\n\r\n\r\n\r\n可以在服务器端获取User-Agent该头的信息，解决浏览器端兼容性问题\r\n与请求体相关的头字段：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n字段名\r\n含义\r\n示例\r\nServlet 关联\r\n\r\n\r\n\r\n\r\nContent-Type\r\n请求体的数据格式和编码\r\napplication/x-www-form-urlencoded; charset=UTF-8（表单数据）\r\nmultipart/form-data; boundary=xxx（文件上传）\r\n通过request.getContentType()获取\r\n\r\n\r\nContent-Length\r\n请求体的字节长度\r\n1024\r\n通过request.getContentLength()获取\r\n\r\n\r\n\r\n请求空行\r\n作为请求头和请求体的分隔符，必须存在且仅包含一个换行符（\\r\\n）\r\n请求体\r\n封装POST请求消息的请求体的，GET请求没有请求体\r\n空行之后（可选，非必须），存放请求的具体数据（如表单提交的参数、上传文件内容等）\r\n\r\n数据格式\r\n\r\n\r\napplication/x-www-form-urlencoded：表单默认格式，键值对编码为key=value&amp;key2=value2，不支持文件上传\r\nmultipart/form-data：文件上传专用格式，通过boundary分隔不同字段，支持二进制数据\r\napplication/json：JSON\r\n格式数据，需在Content-Type头中声明\r\n\r\n\r\nServlet 中获取请求体数据\r\n\r\n\r\n普通表单数据：通过request.getParameter(\"参数名\")直接获取（自动解码）\r\nJSON\r\n数据：需通过request.getReader()或request.getInputStream()手动解析\r\n文件上传：需使用MultipartHttpServletRequest（需配置MultipartResolver）\r\n\r\n\r\n响应消息数据格式\r\nRequest请求原理\r\n\r\n\r\nimage-20250413202921595\r\n\r\n\r\n\r\nimage-20250413202921595\r\n\r\nrequest对象和response对象的原理：\r\n由服务器创建，我们仅使用\r\nrequest对象获取请求消息，response对象来设置响应消息\r\nrequest对象继承体系的结构\r\nServlet中的HttpServletRequest对象是处理HTTP请求的核心接口\r\n基本继承层次：\r\njavax.servlet.ServletRequest (接口)       ↑javax.servlet.http.HttpServletRequest (接口)       ↑org.apache.catalina.connector.RequestFacade (Tomcat实现类)\r\nServletRequest接口\r\n这是最基础的请求接口，定义了通用的请求方法，不限于HTTP协议：\r\n\r\n核心方法：\r\n\r\ngetParameter(String name) - 获取请求参数\r\ngetAttribute(String name) - 获取请求属性\r\nsetAttribute(String name, Object o) - 设置请求属性\r\ngetInputStream() - 获取输入流\r\ngetReader() - 获取字符读取器\r\ngetContentType() - 获取内容类型\r\ngetLocalAddr() - 获取服务器IP地址\r\n\r\n\r\nHttpServletRequest接口\r\n继承自ServletResponse接口，专门用来封装HTTP响应消息。\r\n由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。：\r\n\r\nHTTP相关方法：\r\n\r\ngetHeader(String name) - 获取请求头\r\ngetMethod() - 获取HTTP方法(GET/POST等)\r\ngetCookies() - 返回一个cookie对象数组\r\ngetSession() - 返回与这个请求相关的会话对象\r\ngetRequestURI() - 获取请求URI\r\ngetQueryString() - 返回请求URL中的查询字符串\r\ngetContextPath() - 返回请求上下文的请求URI部分\r\ngetServletPath() - 获取Servlet路径\r\n\r\n\r\n实现类 (以Tomcat为例)\r\nTomcat中的具体实现类结构：\r\nRequest (org.apache.catalina.connector.Request)       ↑RequestFacade (org.apache.catalina.connector.RequestFacade)\r\n\r\nRequest：Tomcat内部的实际实现类，包含大量内部方法\r\nRequestFacade：提供给Servlet开发者的门面类，遵循门面模式，隐藏了内部复杂实现\r\n\r\njavax.servlet.http包内容\r\nHttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：\r\npublic abstract class HttpServlet extends GenericServlet implements Serializable \r\nHttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\nHttpServlet抽象类\r\nHttpServlet 抽象类是继承于 GenericServlet 抽象类而来的。\r\n使用 HttpServlet 抽象类时，还需要借助分别代表 Servlet 请求和 Servlet\r\n响应的 HttpServletRequest 和 HttpServletResponse 对象。\r\nHttpServletRequest 接口扩展于 javax.servlet.ServletRequest\r\n接口，HttpServletResponse 接口扩展于javax.servlet.servletResponse\r\n接口。\r\npublic interface HttpServletRequest extends ServletRequest\r\npublic interface HttpServletResponse extends ServletResponse\r\n其中，HttpServlet 抽象类覆盖了 GenericServlet 抽象类中的Service(\r\n)方法，并且添加了一个自己独有的Service(HttpServletRequest\r\nrequest，HttpServletResponse方法。\r\n这是 GenericServlet 抽象类中定义的service方法：\r\npublic abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\r\nHttpServlet 实现的这个 service 方法\r\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    HttpServletRequest request;    HttpServletResponse response;    try &#123;        request = (HttpServletRequest)req;        response = (HttpServletResponse)res;    &#125; catch (ClassCastException var6) &#123;        throw new ServletException(&quot;non-HTTP request or response&quot;);    &#125;     this.service(request, response);&#125;\r\nHttpServlet 中的 service 方法把接收到的 ServletRequsest\r\n类型的对象转换成了 HttpServletRequest 类型的对象，把ServletResponse\r\n类型的对象转换成了 HttpServletResponse 类型的对象。\r\n之所以能够这样强制的转换，是因为在调用Servlet的Service方法时，Servlet容器总会传入一个\r\nHttpServletRequest 对象和 HttpServletResponse\r\n对象，预备使用HTTP。因此，转换类型当然不会出错了。\r\n转换之后，service方法把两个转换后的对象传入了另一个service方法\r\n// 参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String method = req.getMethod();    long lastModified;    // 解析HttpServletRequest中的方法参数，并调用以下方法之一，每一种方法都表示一个Http方法。doGet和doPost是最常用的    if (method.equals(&quot;GET&quot;)) &#123;        lastModified = this.getLastModified(req);        if (lastModified == -1L) &#123;            this.doGet(req, resp);        &#125; else &#123;            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if (ifModifiedSince &lt; lastModified) &#123;                this.maybeSetLastModified(resp, lastModified);                this.doGet(req, resp);            &#125; else &#123;                resp.setStatus(304);            &#125;        &#125;    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;        lastModified = this.getLastModified(req);        this.maybeSetLastModified(resp, lastModified);        this.doHead(req, resp);    &#125; else if (method.equals(&quot;POST&quot;)) &#123;        this.doPost(req, resp);    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;        this.doPut(req, resp);    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;        this.doDelete(req, resp);    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;        this.doOptions(req, resp);    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;        this.doTrace(req, resp);    &#125; else &#123;        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[]&#123;method&#125;;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    &#125;&#125;\r\n通过request获取内容\r\n通过request获得请求行\r\n请求行包含HTTP方法、URI和协议版本，例如：GET /test?name=value HTTP/1.1\r\n// 获取请求方法(GET/POST/PUT/DELETE等)String method = request.getMethod();// 获取请求URL(不包含协议、域名和端口)String requestURL = request.getRequestURL().toString(); // 获取请求URI(相对于Context Path的部分)String requestURI = request.getRequestURI();// 获取查询字符串(问号后面的部分)String queryString = request.getQueryString();// 获取协议和版本String protocol = request.getProtocol(); // HTTP/1.1// 获取上下文路径(web应用的根路径)String contextPath = request.getContextPath();// 获取Servlet路径String servletPath = request.getServletPath();\r\n获取请求头信息\r\n请求头包含了客户端环境和请求的附加信息\r\n// 获取指定请求头的值String userAgent = request.getHeader(&quot;User-Agent&quot;);String accept = request.getHeader(&quot;Accept&quot;);// 获取所有请求头名称的枚举Enumeration&lt;String&gt; headerNames = request.getHeaderNames();// 遍历所有请求头while(headerNames.hasMoreElements()) &#123;    String name = headerNames.nextElement();    String value = request.getHeader(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取Int类型的请求头值int contentLength = request.getIntHeader(&quot;Content-Length&quot;);// 获取日期类型的请求头值long date = request.getDateHeader(&quot;If-Modified-Since&quot;);// 获取多值请求头Enumeration&lt;String&gt; languages = request.getHeaders(&quot;Accept-Language&quot;);\r\n获取请求体\r\n请求体主要出现在POST、PUT等请求中，包含客户端发送的数据\r\n获取表单数据\r\n// 获取单个表单参数值String username = request.getParameter(&quot;username&quot;);// 获取多值参数(如复选框)String[] hobbies = request.getParameterValues(&quot;hobby&quot;);// 获取所有参数名的枚举Enumeration&lt;String&gt; paramNames = request.getParameterNames();// 获取所有参数的MapMap&lt;String, String[]&gt; paramMap = request.getParameterMap();// 遍历所有参数paramMap.forEach((key, values) -&gt; &#123;    System.out.print(key + &quot;: &quot;);    for(String value : values) &#123;        System.out.print(value + &quot; &quot;);    &#125;    System.out.println();&#125;);\r\n获取原始请求体\r\n// 获取输入流读取原始数据ServletInputStream inputStream = request.getInputStream();BufferedReader reader = request.getReader();// 示例：读取JSON请求体StringBuilder sb = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123;    sb.append(line);&#125;String jsonBody = sb.toString();\r\n获取其他请求信息\r\n// 获取客户端IP地址String clientIP = request.getRemoteAddr();// 获取客户端主机名String clientHost = request.getRemoteHost();// 获取客户端端口int clientPort = request.getRemotePort();// 获取服务器信息String serverName = request.getServerName();int serverPort = request.getServerPort();// 获取请求的会话HttpSession session = request.getSession();// 获取Cookie数组Cookie[] cookies = request.getCookies();// 获取内容类型String contentType = request.getContentType();// 获取字符编码String encoding = request.getCharacterEncoding();// 设置字符编码(处理中文乱码)request.setCharacterEncoding(&quot;UTF-8&quot;);\r\n示例\r\n处理JSON请求\r\nprotected void doPost(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 设置字符编码    request.setCharacterEncoding(&quot;UTF-8&quot;);        // 读取JSON请求体    StringBuilder sb = new StringBuilder();    try (BufferedReader reader = request.getReader()) &#123;        String line;        while ((line = reader.readLine()) != null) &#123;            sb.append(line);        &#125;    &#125;        // 解析JSON    JSONObject json = new JSONObject(sb.toString());    String username = json.getString(&quot;username&quot;);    // 处理业务逻辑...&#125;\r\nRequest乱码问题的解决方法\r\nServlet默认编码是ISO-8559-1，需要手动修改编码方式为UTF-8编码\r\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);  // 解决post提交方式的乱码parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);    //  解决get提交的方式的乱码\r\n通过Response设置响应\r\nHttpServletResponse对象是Servlet中用于构建HTTP响应的核心接口，它提供了丰富的方法来设置响应状态、响应头和响应体\r\n设置响应状态\r\n设置状态码\r\n// 设置成功状态码(200)response.setStatus(HttpServletResponse.SC_OK);// 设置404未找到response.setStatus(HttpServletResponse.SC_NOT_FOUND);// 设置500服务器错误response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);// 设置302重定向(已废弃，推荐使用sendRedirect)response.setStatus(HttpServletResponse.SC_FOUND);\r\n设置状态码和错误消息\r\n// 设置状态码和自定义错误消息response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;资源不存在&quot;);// 仅设置状态码(使用默认错误消息)response.sendError(HttpServletResponse.SC_FORBIDDEN);\r\n设置响应头\r\n基本响应头设置\r\n// 设置单个响应头response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 添加响应头(可设置多个同名头)response.addHeader(&quot;Set-Cookie&quot;, &quot;name=value&quot;);// 设置Int类型响应头response.setIntHeader(&quot;Content-Length&quot;, 1024);// 设置日期类型响应头response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis() + 3600000);\r\n常用响应头快捷方法\r\n// 设置内容类型和字符编码(等同于setHeader(&quot;Content-Type&quot;, ...))response.setContentType(&quot;text/html;charset=UTF-8&quot;);// 设置内容长度(等同于setIntHeader(&quot;Content-Length&quot;, ...))response.setContentLength(1024);// 设置字符编码(单独设置)response.setCharacterEncoding(&quot;UTF-8&quot;);\r\n设置响应体\r\n获取输出流\r\n// 获取字节输出流(用于二进制数据)// 获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。ServletOutputStream outputStream = response.getOutputStream();// 获取字符输出流(用于文本数据)// 获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。PrintWriter writer = response.getWriter();\r\n注意，其中response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。\r\n重定向相关\r\n302重定向\r\n// 简单重定向(相对路径)response.sendRedirect(&quot;newPage.html&quot;);// 重定向到绝对URLresponse.sendRedirect(&quot;http://example.com/newPath&quot;);// 重定向到上下文路径下的资源response.sendRedirect(request.getContextPath() + &quot;/secured/page.jsp&quot;);\r\n请求转发(服务器内部)\r\n// 获取转发器RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/target.jsp&quot;);// 转发请求和响应dispatcher.forward(request, response);\r\n示例\r\nRESTful API响应\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);        try (PrintWriter out = response.getWriter()) &#123;        JSONObject json = new JSONObject();        json.put(&quot;status&quot;, &quot;success&quot;);        json.put(&quot;data&quot;, new JSONObject()            .put(&quot;id&quot;, 123)            .put(&quot;name&quot;, &quot;张三&quot;)            .put(&quot;email&quot;, &quot;zhangsan@example.com&quot;));                out.print(json.toString());    &#125;&#125;\r\n文件下载\r\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        String fileName = &quot;example.pdf&quot;;    String filePath = &quot;/path/to/files/&quot; + fileName;        response.setContentType(&quot;application/pdf&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        try (InputStream in = new FileInputStream(filePath);         OutputStream out = response.getOutputStream()) &#123;                byte[] buffer = new byte[4096];        int length;        while ((length = in.read(buffer)) &gt; 0) &#123;            out.write(buffer, 0, length);        &#125;    &#125;&#125;\r\n乱码问题\r\nresponse缓冲区的默认编码也是iso8859-1\r\nresponse.setCharacterEncoding(&quot;utf-8&quot;);  // 更改response的编码方式为UTF-8\r\n更改response的编码方式为UTF-8，只是其中一步，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。\r\n// 通知浏览器使用utf8response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);\r\nresponse.setContentType(“text/html;charset=UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text/html;charset=UTF-8”)方法即可。\r\n\r\nServlet的工作流程\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n关于Web基础部分\r\nJavaWeb-http\r\n引用文章\r\nJavaWeb——HTTP详解\r\nJavaWeb——Servlet\r\n菜鸟教程Servlet部分\r\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Web","Servlet"]},{"title":"Servlet学习之核心接口,工作原理和配置","url":"/posts/4234.html","content":"什么是Servlet\r\n运行在服务器端的程序\r\nservlet是一个接口，定义了Java类被浏览器访问到的规则（接口）\r\nServlet是用java编写的服务器端的程序，主要是交互式的浏览和修改数据，生成动态Web内容，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上\r\nServlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\r\nStruts2的核心用的是Filter（过滤器），而SpringMVC的核心用的就是Servlet。\r\n// WebServlet注解表示这是一个Servlet，并映射到地址/:@WebServlet(urlPatterns = &quot;/&quot;)public class HelloServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;        // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;&#125;\r\n一个Servlet总是继承自HttpServlet，然后重写doGet()或doPost()方法。注意到doGet()方法传入了HttpServletRequest和HttpServletResponse两个对象，分别代表HTTP请求和响应。我们使用Servlet\r\nAPI时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为HttpServletRequest和HttpServletResponse就已经封装好了请求和响应\r\n工作模式\r\n\r\n客户端发送请求至服务器\r\n服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器\r\n服务器将响应返回客户端\r\n\r\nAPI预览\r\nServlet API 包含以下4个Java包：\r\n1.javax.servlet\r\n其中包含定义servlet和servlet容器之间契约的类和接口。\r\n2.javax.servlet.http 其中包含定义HTTP Servlet\r\n和Servlet容器之间的关系。\r\n3.javax.servlet.annotation\r\n其中包含标注servlet，Filter,Listener的标注。它还为被标注元件定义元数据。\r\n4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。\r\n使用Servlet\r\nServlet技术的核心是Servlet，它是所有Servlet类必须直接或者间接实现的一个接口。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。\r\n工作原理\r\n​\r\nServlet接口定义了Servlet与servlet容器之间的契约：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。\r\n​\r\n但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\r\n​\r\n用户请求致使Servlet容器调用Servlet的Service()方法,并传入一个ServletRequest对象和一个ServletResponse对象。\r\nServletRequest中封装了当前的Http请求,ServletResponse表示当前用户的Http响应.\r\n​\r\n对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。\r\n接口中定义的方法\r\npublic interface Servlet &#123;    // 这是 Servlet 的初始化方法，在 Servlet 实例被创建之后，容器会调用此方法对 Servlet 进行初始化操作。    void init(ServletConfig var1) throws ServletException; \t    // 用于获取 Servlet 的配置信息，会返回由Servlet容器传给init（ ）方法的ServletConfig对象    ServletConfig getServletConfig(); \t    // 用来处理客户端的请求并生成响应。当有客户端请求到达时，Servlet 容器会调用这个方法。    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; \t    // 用于返回 Servlet 的描述信息    String getServletInfo(); \t    // 这是 Servlet 的销毁方法，在 Servlet 实例被销毁之前，容器会调用此方法，用于释放 Servlet 占用的资源    void destroy();&#125;\r\n执行原理\r\n当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\r\n查找Web.xml文件，是否有对应的标签体的内容，如果有，则在对应的全类名\r\ntomcat会将其字节码加载进内存然后构建对象，调用其方法\r\nServlet的生命周期\r\n上述接口中定义的方法内，init( ),service( ),destroy(\r\n)是Servlet生命周期的方法。\r\nServlet容器（例如TomCat）会根据下面的规则来调用这三个方法：\r\n\r\n当Servlet第一次被请求时，Servlet容器就会开始调用 init()\r\n方法，初始化一个Servlet对象出来,这个方法在后续请求中不会在被Servlet容器调用。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。\r\nservice(\r\n)方法，每当请求Servlet时，Servlet容器就会调用这个方法，第一次请求时，Servlet容器会先调用init(\r\n)方法初始化一个Servlet对象出来，然后会调用它的service(\r\n)方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。\r\ndestory,当要销毁Servlet时，Servlet容器就会调用这个方法，一般在这个方法中会写一些清除代码，只有服务器正常关闭的时候，才会执行destory方法\r\n演示代码\r\n@Overridepublic void init(ServletConfig servletConfig) throws ServletException &#123;    System.out.println(&quot;Servlet正在初始化&quot;);&#125; @Overridepublic ServletConfig getServletConfig() &#123;    return null;&#125; @Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;    //专门向客服端提供响应的方法    System.out.println(&quot;Servlet正在提供服务&quot;); &#125; @Overridepublic String getServletInfo() &#123;    return null;&#125; @Overridepublic void destroy() &#123;    System.out.println(&quot;Servlet正在销毁&quot;);&#125;\r\n\r\n其中servlet的创建时期是可以被指定的\r\n&lt;!-- 指定servlet的创建时期，负数为第一次访问时期，0或正数为服务器启动时期--&gt;&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;\r\nServlet中的 init\r\n方法只执行一次，说明一个Servlet中只存在一个对象，是单例的，多个用户同时访问可能存在线程安全的隐患，所以尽量不要再其中定义成员变量，也不要对其赋值\r\nTomcat部分\r\n普通的Java程序是通过启动JVM，然后执行main()方法开始运行。但是Web应用程序有所不同，我们无法直接运行war文件，必须先启动Web服务器，再由Web服务器加载我们编写的HelloServlet，这样就可以让HelloServlet处理浏览器发送的请求。\r\nTomcat本身的目录层次结构\r\n\r\n\r\nimg\r\n\r\nTomcat提供了一个部署其服务器在你本地电脑上的功能\r\n​\r\n实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机\r\n​\r\n执行Tomcat的main()方法，然后由Tomcat负责加载我们的.war文件，并创建一个HelloServlet实例，最后以多线程的模式来处理HTTP请求。\r\n​\r\n如果Tomcat服务器收到的请求路径是/（假定部署文件为ROOT.war），就转发到HelloServlet并传入HttpServletRequest和HttpServletResponse两个对象。\r\n配置Servlet\r\nweb.xml配置\r\nweb.xml 文件是用于配置 Web 应用程序的核心文件，它能对\r\nServlet、过滤器、监听器等组件进行配置\r\nServlet 定义\r\n&lt;servlet&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.ergoutree.servletexpdemo.demo1.FastGo&lt;/servlet-class&gt;&lt;/servlet&gt;\r\n\r\n标签：该标签的作用是定义一个 Servlet。在一个\r\nweb.xml 文件中，可以定义多个 Servlet。\r\n标签：这里为 Servlet 指定一个名称，也就是\r\nServletExpDemo。这个名称属于逻辑名称，主要用于在\r\nweb.xml 文件的其他部分引用该 Servlet。\r\n标签：它指定了 Servlet 类的全限定名，即\r\norg.ergoutree.servletexpdemo.demo1.FastGo。当 Web\r\n容器启动时，会依据这个全限定名来加载并实例化该 Servlet 类。\r\n\r\nServlet 映射\r\n&lt;servlet-mapping&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\r\n\r\n标签：此标签的功能是将 Servlet 与一个或多个 URL\r\n模式进行映射。当客户端发送请求时，Web 容器会根据请求的 URL 找到对应的\r\nServlet。\r\n标签：这里引用了之前定义的 Servlet 的名称，也就是\r\nServletExpDemo。\r\n标签：它指定了与该 Servlet 关联的 URL 模式，即\r\n/demo1。当客户端请求的 URL 匹配这个模式时，Web\r\n容器就会将请求转发给 ServletExpDemo 所对应的 Servlet\r\n类（也就是org.ergoutree.servletexpdemo.demo1.FastGo）进行处理。\r\n\r\n原理及其示例\r\n原理说明\r\n当客户端向 Web 应用程序发送 HTTP 请求时，Web 容器（像 Tomcat\r\n这类）会按照以下步骤处理请求：\r\n\r\n解析请求 URL：Web 容器对客户端请求的 URL\r\n进行解析，从中提取出请求的路径部分。\r\n查找 Servlet 映射：Web 容器在 web.xml\r\n文件里查找与请求路径相匹配的 ``。\r\n定位 Servlet：若找到匹配的\r\n，Web 容器会根据对应的 找到之前定义的 Servlet。\r\n实例化并调用 Servlet：Web 容器加载并实例化该\r\nServlet 类，然后调用其 service() 方法来处理请求。\r\n返回响应：Servlet\r\n处理完请求后，将响应返回给客户端。\r\n\r\n示例\r\n假设客户端发送的请求 URL 为\r\nhttp://localhost:8080/yourApp/demo1，Web\r\n容器会进行如下操作：\r\n\r\n解析出请求路径为 /demo1。\r\n在 web.xml 文件中找到\r\n为 `/demo1` 的。\r\n根据\r\n`为ServletExpDemo，找到对应的 Servlet 类org.ergoutree.servletexpdemo.demo1.FastGo`。\r\n加载并实例化 FastGo 类，调用其 service()\r\n方法处理请求。\r\n将处理结果返回给客户端。\r\n\r\nSerlvet3.0的注解配置\r\n@WebServlet\r\n的属性列表：\r\n\r\n\r\nimage-20250412202207184\r\n\r\n核心注解@WebServlet\r\n取代  和 ，直接绑定 URL 模式与\r\nServlet 类。\r\n@WebServlet(    name = &quot;userServlet&quot;, // Servlet 名称（可选）    urlPatterns = &#123;&quot;/user&quot;, &quot;/api/user&quot;&#125;, // 支持多 URL 模式    loadOnStartup = 1, // 容器启动时立即加载（替代 &lt;load-on-startup&gt;）    initParams = &#123;        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;) // 初始化参数    &#125;,    asyncSupported = true // 启用异步支持（默认 false）)public class UserServlet extends HttpServlet &#123; ... &#125;\r\n\r\nurlPatterns：支持精确匹配\r\n(/user)、通配符 (/api/*)、后缀匹配\r\n(*.do)。\r\nloadOnStartup：值越小优先级越高，控制 Servlet\r\n初始化顺序。\r\nasyncSupported：异步处理开关，需配合\r\nAsyncContext 使用（后文详解）。\r\n\r\n@WebFilter：声明过滤器\r\n替代 \r\n和，定义请求预处理和后处理逻辑。\r\n@WebFilter(    filterName = &quot;auditFilter&quot;,    urlPatterns = &quot;/*&quot;, // 过滤所有请求    servletNames = &#123;&quot;userServlet&quot;&#125;, // 针对特定 Servlet    dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.ASYNC&#125;)public class AuditFilter implements Filter &#123; ... &#125;\r\n\r\ndispatcherTypes：控制过滤器作用的请求类型（如\r\nFORWARD、ERROR）。\r\n执行顺序问题：注解无法直接指定顺序，需通过类名自然排序或结合\r\nweb.xml 的 ``。\r\n\r\n@WebListener：事件监听器\r\n简化监听器的声明，覆盖 Servlet 上下文、会话、请求等生命周期事件。\r\n@WebListenerpublic class AppContextListener implements ServletContextListener &#123;    @Override    public void contextInitialized(ServletContextEvent sce) &#123;        // 应用启动逻辑    &#125;&#125;\r\n异步处理\r\n在 @WebServlet 或 @WebFilter 中设置\r\nasyncSupported = true。\r\n流程：\r\n\r\n开启异步上下文：AsyncContext asyncContext = request.startAsync()。\r\n提交耗时任务到其他线程（如数据库查询、远程调用）。\r\n任务完成时，通过 asyncContext.complete()\r\n或返回响应。\r\n\r\n@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)public class AsyncServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;        AsyncContext ctx = req.startAsync();        CompletableFuture.runAsync(() -&gt; &#123;            // 模拟耗时操作            ctx.getResponse().getWriter().write(&quot;Async Response&quot;);            ctx.complete();        &#125;);    &#125;&#125;\r\n模块化部署介绍\r\nServlet 3.0 模块化特性：\r\n\r\n允许将 Web 组件（Servlet、Filter、Listener）打包为 JAR 文件，置于\r\nWEB-INF/lib 目录。\r\n容器自动扫描 JAR 中的 META-INF/web-fragment.xml\r\n和注解，实现“即插即用”\r\n\r\n注意情况\r\n如果使用@WebServlet Annotation（注解）来配置Servlet，需要注意：\r\n① 不要在 web.xml 文件的根元素（&lt;web-app—/&gt;）中指定\r\nmetadata-complete=“true”； ② 不要在 web.xml 文件中再次配置该 Servlet\r\n相关属性\r\nServletRequest 和 ServletResponse 为\r\nServlet\r\n提供了处理客户端请求和发送响应的能力；ServletConfig 为\r\nServlet 提供了配置信息；ServletContext 为\r\nServlet 提供了整个 Web\r\n应用程序的上下文环境。它们共同协作，使得 Servlet\r\n能够正常运行并处理客户端的请求。\r\nServletRequset接口\r\nServlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice(\r\n)方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\r\nServletRequest接口的部分内容：\r\npublic interface ServletRequest &#123;    int getContentLength();//返回请求主体的字节数    String getContentType();//返回主体的MIME类型    String getParameter(String var1);//返回请求参数的值&#125;\r\nServletResponse接口\r\njavax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service(\r\n)方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service(\r\n)方法。\r\nServletResponse隐藏了向浏览器发送响应的复杂过程。在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。\r\nServletResponse内部定义的方法：\r\npublic interface ServletResponse &#123;    String getCharacterEncoding(); \t// 在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型,加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。    String getContentType(); \t// 发送二进制数据的    ServletOutputStream getOutputStream() throws IOException; \t// PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。    PrintWriter getWriter() throws IOException;     void setCharacterEncoding(String var1);     void setContentLength(int var1);     void setContentType(String var1);     void setBufferSize(int var1);     int getBufferSize();     void flushBuffer() throws IOException;     void resetBuffer();     boolean isCommitted();     void reset();     void setLocale(Locale var1);     Locale getLocale();&#125;\r\nServletConfig接口\r\n当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init(\r\n)方式传入一个ServletConfig对象。\r\n其中几个方法如下：\r\n\r\n\r\nimg\r\n\r\nServletContext对象\r\nServletContext对象表示Servlet应用程序，是Servlet的上下文对象。每个Web应用程序都只有一个ServletContext对象。\r\n在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。\r\n通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。\r\n有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中\r\nServletContext中的下列方法负责处理属性：\r\nObject getAttribute(String var1);  // 获取 ServletContext 中指定名称的属性值 // 用于获取 ServletContext 中所有属性的名称。返回的是一个 Enumeration 对象，通过它可以遍历所有属性的名称。Enumeration&lt;String&gt; getAttributeNames(); void setAttribute(String var1, Object var2);    // 向 ServletContext 中设置一个属性 void removeAttribute(String var1);    // 从 ServletContext 中移除指定名称的属性\r\nServlet是否为线程安全\r\n线程安全问题指的是多线程在并发执行时会不会出现问题。由于Web容器只会创建一个Servlet实例，所以多个用户发起请求时，会有多个线程处理Servlet代码，因此Servlet是线程不安全的。\r\n考虑以下代码：\r\n@WebServlet(name = &quot;ThreadSafeServlet&quot;, urlPatterns = &quot;/ThreadSafeServlet&quot;)public class ThreadSafeServlet extends HttpServlet &#123;    private String name;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        name = request.getParameter(&quot;name&quot;);        try &#123;            Thread.sleep(10000);//使线程沉睡10秒        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        response.getWriter().println(&quot;name:&quot; + name);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doPost(request, response);    &#125;&#125;\r\n10秒内在两个不同的浏览器窗口中的表单输入name并提交，假如在A浏览器中输入111，B浏览器中输入222，最后会发现A和B浏览器显示的name都是222。这是因为在第一个线程睡眠时，第二个线程修改了name的值，所有最后显示都是222，那么就产生了线程不安全问题。\r\n实际上Servlet，Context上下文作用域，HttpSession都是线程不安全的，只有request请求和局部变量是线程安全的。\r\n关于Servlet与http相关的应用，下一部分是这个\r\nServlet与http\r\n关于Web基础部分\r\nJavaWeb-http\r\n引用文章\r\nJavaWeb——HTTP详解\r\nJavaWeb——Servlet\r\n菜鸟教程Servlet部分\r\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Servlet"]},{"title":"Servlet与会话管理","url":"/posts/45466.html","content":"为什么进行会话管理\r\nWeb应用程序基于HTTP协议\r\n\r\nHTTP基于请求/响应模式\r\n\r\n所有请求都是相互独立的，无连续性的\r\n\r\nHTTP是无连接的协议\r\n\r\n限制每次连接只处理一个请求\r\n\r\nHTTP是无状态的协议\r\n\r\n协议对于事务处理没有记忆能力\r\n\r\n\r\n对于简单的页面浏览或信息获取，HTTP协议即可胜任，但是对于需要客户端和服务器端多次交互的网络应用，则必须记住客户端状态\r\n会话就是一个客户端连续不断地和服务器端进行请求/响应的一系列交互\r\n何为会话\r\n多次请求间建立关联的方式称为会话管理，或会话跟踪\r\n会话状态，指服务器与浏览器在会话过程中产生的状态信息\r\n会话管理是管理浏览器客户端和服务器端之间会话过程中产生的会话数据。\r\n会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话，主要有四种会话跟踪方法，设置隐藏表单字段，URL重写，Cookie和Session。常用的会话跟踪技术是Cookie和Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。\r\n浏览器客户端和服务器端的会话管理涉及的技术有Cookie技术与Session技术，两者的区别在于：\r\n- Cookie技术将会话数据保存在浏览器客户端 -\r\nSession技术将会话数据保存在服务器端\r\n会话的实现过程\r\nHTTP没有提供任何记住客户端的途径，服务器如何建立、维护与客户端的会话\r\n\r\n\r\nimage-20250415081247045\r\n\r\n\r\n\r\nimage-20250415081247045\r\n\r\nCookie技术\r\n如何理解Cookie技术\r\nCookie实际上是存放在客户端浏览器的一小块文本。\r\n客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来记录用户状态。\r\nCookie的工作原理主要的记录用户状态，客户端浏览器第一次请求服务器后，服务器会颁发一个Cookie(name\r\n=\r\nErgouTree，该Cookie就相当于那唯一的卡号)响应给客户端浏览器，以后客户端的每次请求都会带上这个Cookie，这样服务器就可以根据这唯一的Cookie识别不同的用户。\r\n特点\r\n\r\nCookie技术将会话数据保存在浏览器客户端。\r\nCookie数据只能是非中文的字符串类型的数据\r\n浏览器可以保存多个Cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie\r\n每个Cookie的大小限制为4KB\r\n\r\nCookie核心API\r\nCookie(String name, String value)   // 用户创建Cookie对象的构造函数void setPath(String uri)    // 设置cookie的有效访问路径，这个可以在浏览器内看，设置-&gt;内容设置-&gt;Cookie-&gt;查看所有Cookie和网站void setMaxAge(int expiry)    // 设置cokie的存活时间void setValue(String newValue)   // 设置cookie的值Cookie[] request.getCookies()    // 接收cookievoid response.addCookie(Cookie cookie)    // 发送cookie到浏览器端保存\r\nCookie的创建\r\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);response.addCookie(cookie);   // Cookie从servlet里发送到浏览器端\r\n创建Cookie对象，利用Cookie的构造函数来创建Cookie，Cookie的构造函数有两个参数，name和value，必须要有这两个参数，value固定为String类型的。\r\nCookie 是存放在浏览器端的，所以还需要把 Cookie 从 servlet\r\n里发送到浏览器端，利用response里的addCookie方法可以做到，原理是通过在响应中设置\r\nset-Cookie 标头，以 Key/Value 键值对的形式发送到浏览器\r\n你可以使用google浏览器查看响应头中的set-Cookie标头，你能看到你刚刚添加的Cookie和它的属性值\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n响应首部中黄色的部分就是从Servlet发送到浏览器的Cookie\r\n请求首部中红色划线部分是浏览器发回到服务器的Cookie，这个不是你刚创建的Cookie，因为你创建的Cookie刚发送到浏览器，之后你再请求一次就可以在请求首部看到你刚创建的Cookie。\r\nCookie的获取\r\n在Servlet中只能使用getCookies方法获取所有的Cookie，没有通过Cookie名来获取Cookie的方法。所以需要你自己来编写代码实现。\r\n&lt;%    // 如何获取Cookie    Cookie[] cookies = request.getCookies();   // 返回值类型为Cookie[]    if (cookies != null) &#123;        for (int i = 0; i &lt; cookies.length; i++) &#123;            System.out.println(cookies[i].getName() + &quot;: &quot; + cookies[i].getValue());        &#125;    &#125;%&gt;\r\nCookie的修改与删除　\r\nCookie并不提供修改，删除操作。\r\n如果要修改某个Cookie，需要新建一个同名的Cookie，并添加到response中就会覆盖原来的Cookie。\r\n下面的两行代码就可把username的value值 “kindleheart”改为”Hush”。\r\n// 修改Cookie的示例方法protected void modifyCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 假设我们要将用户名从旧值改为&quot;Hush&quot;    Cookie cookie = new Cookie(&quot;username&quot;, &quot;Hush&quot;);    cookie.setPath(&quot;/Demo&quot;);  // 设置与原始Cookie相同的路径    cookie.setMaxAge(7 * 24 * 60 * 60); // 保持相同的有效期    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已修改&quot;);&#125;\r\n删除Cookie的实现\r\n如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。\r\n// 删除Cookie的标准方法protected void deleteCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 1. 创建一个同名Cookie    Cookie cookie = new Cookie(&quot;username&quot;, &quot;&quot;);    // 设置值为空        // 2. 设置path与原始Cookie一致（重要！）    cookie.setPath(&quot;/Demo&quot;);        // 3. 设置生存期为0（立即失效）    cookie.setMaxAge(0);        // 4. 添加到响应中    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已删除&quot;);&#125;\r\n修改和删除Cookie时，新建的Cookie除value，maxAge之外的所有属性，例如name，path，domain等，都要与原Cookie完全一样。否则，浏览器会把这两个Cookie视为不同的Cookie，不允许覆盖，导致修改删除失败。\r\n服务的完整示例\r\n@Override   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       request.setCharacterEncoding(&quot;UTF-8&quot;);       // 获取表单数据       String username = request.getParameter(&quot;username&quot;);       String password = request.getParameter(&quot;pwd&quot;);       String rememberMe = request.getParameter(&quot;rememberMe&quot;);       // 简单的验证（实际项目中应该连接数据库验证）       if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;           // 登录成功           // 如果用户选择了&quot;记住我&quot;           if(&quot;true&quot;.equals(rememberMe)) &#123;               // 创建Cookie保存用户名               Cookie usernameCookie = new Cookie(&quot;username&quot;, username);               // 设置Cookie有效期为7天               usernameCookie.setMaxAge(7 * 24 * 60 * 60);               response.addCookie(usernameCookie);           &#125;else&#123;               // 用户没有选择记住我，删除可能存在的Cookie               Cookie usernameCookie = new Cookie(&quot;username&quot;, &quot;&quot;);               usernameCookie.setMaxAge(0); // 立即过期               response.addCookie(usernameCookie);           &#125;           // 创建会话           HttpSession session = request.getSession();           session.setAttribute(&quot;username&quot;, username);           // 重定向到欢迎页面           response.sendRedirect(&quot;&quot;);       &#125;else&#123;           // 登录失败           response.sendRedirect(&quot;index.jsp?error=1&quot;);       &#125;   &#125;\r\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 初始化变量    String name = &quot;&quot;;    boolean isRemembered = false;        // 获取Cookie    Cookie[] cookies = request.getCookies();    if (cookies != null) &#123;        for (Cookie cookie : cookies) &#123;            // 查找用户名Cookie            if(cookie.getName().equals(&quot;username&quot;))&#123;                name = cookie.getValue();                isRemembered = true;            &#125;        &#125;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;用户登录&lt;/h2&gt;    &lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;        账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;1&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;        记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;        登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\r\nCookie的属性\r\n除了name与value之外，Cookie还有其它的一些可选属性，比如注释、路径和域限定符、最大生存时间和版本号。\r\n每个属性对应着一个get方法和一个set方法。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n有效期\r\nCookie的maxAge决定着Cookie的有效期，单位为秒，默认值为-1。\r\nCookie中通过getMaxAge()方法与setMaxAge()方法来读写maxAge属性。\r\n\r\nmaxAge &gt; 0：表示Cookie会在 maxAge 秒之后自动失效。浏览器会将\r\nmaxAge\r\n为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在\r\nmaxAge 秒之前，登录网站时该Cookie仍然有效。\r\nmaxAge &lt; 0，则表示该Cookie仅仅在关闭窗口前有效。maxAge\r\n为负数的Cookie，为临时Cookie，不会被持久化，不会被写到Cookie文件中，而是保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。\r\nmaxAge =\r\n0，有效时间为0，就表示为删除Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除。\r\n\r\nCookie的域名\r\nCookie是不可跨域名的，同一个一级域名下的两个二级域名如\r\nwww.kindleheart.com 和 images.kindleheart.com\r\n也不能互相使用Cookie，因为二者的域名并不严格相同。如果想所有kindleheart.com名下的二级域名都可以使用该Cookie，可以设置domain参数。\r\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setDomain(&quot;.kindleheart.com&quot;);response.addCookie(cookie);\r\nCookie的路径\r\ndomain属性决定访问Cookie的域名，而path属性决定允许访问Cookie的路径(ContextPath)。\r\n如果只允许Demo工程下的程序使用Cookie，可以这么写：\r\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setPath(&quot;/Demo&quot;);response.addCookie(cookie);\r\nSeesion\r\n核心API\r\nHttpSession getSession()    ——    得到session对象HttpSession getSession(boolean create)    ——  当create参数为true时，如果获取不到对应session对象就为浏览器创建一个session对象；如果create参数为false时，如果获取不到对应session对象就返回null。   void setAttribute(String name, Object value)    ——    保存会话数据到session对象Object getAttribute(String name)    ——    从session对象中获取会话数据void removeAttribute(String name)    ——     清除session对象中对应的会话数据void setMaxInactiveInterval(int interval)    ——    设置session的有效时间，默认情况是30分钟void invalidate()    ——    销毁session对象String getId()    ——    得到session编号\r\n理解Session\r\nCookie可以让服务器跟踪每个客户端的访问，Cookie存放在客户端浏览器，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多，那么无形地会增加了客户端与服务器端的数据传输量，而Session正是解决这个问题的。\r\nSession存放在服务器端，同一个客户每次和服务器端进行交互时，不需要每次传回所有的Cookie值，而是只要传回一个ID，这个ID是客户端第一次访问时生成的，而且每个客户端都是唯一的，这样每个客户端都有了一个唯一的ID，客户端只需要传回这个ID就行了，这个ID通常是name为JSESSIONID的一个Cookie。\r\n实际上有以下三种方式使得Session正常工作。\r\n\r\n基于Cookie，如果没有修改Context容器的Cookies标识，则默认也是支持的。客户端每次请求的时候，Cookie会被返回到服务器，利用请求头中的Cookie标头。　　\r\n基于URL Path Parameter(URL重写)，默认支持。\r\n浏览器不支持Cookie或者用户把浏览器的Cookie功能关闭了，浏览器就会把该用户的Session的ID信息(JSESSIONID)重写到用户请求的URL参数中，服务器再从URL参数中解析出Session的ID。、\r\n首先我们把浏览器的Cookie关闭，再使用HttpServletRequest类提供的encodeURL(String url)实现地址重写，下面是一个计录浏览次数的小例子：\r\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       response.setContentType(&quot;text/html;charset=utf-8&quot;);       HttpSession session = request.getSession();       int count = 0;       if(session.getAttribute(&quot;count&quot;) != null) &#123;           int c = (int) session.getAttribute(&quot;count&quot;);           count = c + 1;       &#125;       session.setAttribute(&quot;count&quot;, count);       PrintWriter out = response.getWriter();       out.println(&quot;&lt;html&gt;&quot;);       out.println(&quot;&lt;body&gt;&quot;);       out.println(&quot;&lt;h1&gt;登入&quot; + count + &quot;次&lt;/h1&gt;&quot;);       //URL重写把JSESSIONID发送到服务器       out.println(&quot;&lt;a href=&#x27;&quot; + response.encodeURL(&quot;IndexServlet&quot;) + &quot;&#x27;&gt;click me&lt;/a&gt;&quot;);       out.println(&quot;&lt;/body&gt;&quot;);       out.println(&quot;&lt;/html&gt;&quot;);       out.close();   &#125;  \r\n在浏览器的地址栏URL里文件名后面URL参数前面可以看到 jsessionid =\r\nXXX。　\r\n注意：如果浏览器支持Cookie，那么Tomcat仍然会解析Cookie里的中的Session\r\nID，并会覆盖URL中的Session ID，也就是你在URL就中看不到 jsessionid =\r\nXXX了。\r\n基于SSL，默认不支持，只有connector.getAttribute(“SSLEnabled”)为TRUE时才支持。\r\n\r\nSession的生命周期\r\n\r\nSession的创建\r\n\r\n\r\nSession在用户第一次请求服务器的时候自动创建，只有访问Servlet，JSP等动态资源才会创建，访问HTML，IMAGE等静态资源并不会创建Session，如果没有创建成功，也可以使用request.getSession(true)强制创建Session。\r\n\r\n\r\nSession的获取\r\n\r\n\r\n通过HttpServletRequest对象的getSession方法获取一个HttpSession实例。\r\n//获取此会话HttpSession session = request.getSession();\r\n\r\n\r\nSession的撤销\r\nSession的撤销有三种可能的情况：\r\n\r\nSession超时，Session的默认有效期为30分钟，你如果30分钟内没有请求服务器，Session就会撤销，你30分钟内请求了服务器，服务器就认为你active了一次，重新计算有效期。\r\n可以在web.xml文件里或者使用setMaxInactiveInterval(20 *  60)方法设置Session的有效期，注意的是web.xml文件里参数以分为单位，15分钟，setMaxInactiveInterval(20 * 60)中的参数以秒为单位，这里是20分钟。\r\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;session-config&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;  &lt;/session-config&gt;&lt;/web-app&gt;\r\n//设置Session的有效期为20分钟session.setMaxInactiveInterval(20 * 60);\r\n通过会话对象使用invalidate方法使Session无效。\r\n//使此会话无效session.invalidate();\r\n程序结束\r\n\r\n\r\nSession的属性操作\r\n\r\nSession增加属性\r\nSession中的属性也是以键值对的形式存储的，用setAttibute(name, value)方法添加属性，value是Object对象的，所以value不限于String类型，可以是任何数据类型。\r\n//添加一个name为count的属性，值为250int count = 250;session.setAttribute(&quot;count&quot;, count);\r\nSession获取属性值\r\n//获取name为count的value值，需要强转int count = (int) session.getAttribute(&quot;count&quot;);\r\nSession修改属性\r\nSession修改属性，直接使用setAttibute(name, value)方法覆盖相同name的Session即可。\r\n//把name为count的属性值由250修改到520session.setAttribute(&quot;count&quot;, 250);session.setAttribute(&quot;count&quot;, 520);\r\nSession删除属性\r\nSession删除属性，使用removeAttribute(name)方法，删除对应name的属性。\r\n//删除name为count的属性session.removeAttribute(&quot;count&quot;);\r\n\r\n应用实例\r\n@Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;pwd&quot;);        String rememberMe = request.getParameter(&quot;rememberMe&quot;);        // 简单的登录验证        if(isValidUser(username, password)) &#123;            // 创建或获取session            HttpSession session = request.getSession();            // 存储登录状态            session.setAttribute(&quot;isLoggedIn&quot;, true);            session.setAttribute(&quot;username&quot;, username);            // 如果用户选择了&quot;记住我&quot;            if(&quot;true&quot;.equals(rememberMe)) &#123;                session.setAttribute(&quot;rememberMe&quot;, true);                // 设置session超时时间（7天）                session.setMaxInactiveInterval(7 * 24 * 60 * 60);            &#125;else &#123;                // 不记住则移除属性                session.removeAttribute(&quot;rememberMe&quot;);                // 使用默认的超时时间            &#125;            // 重定向到欢迎页面            response.sendRedirect(&quot;welcome.jsp&quot;);        &#125; else &#123;            // 登录失败            response.sendRedirect(&quot;index.jsp?error=1&quot;);        &#125;    &#125;\r\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 检查session中是否有记住的用户名    String name = &quot;&quot;;    boolean isRemembered = false;    HttpSession existingSession = request.getSession(false);    if (existingSession != null &amp;&amp; existingSession.getAttribute(&quot;rememberMe&quot;) != null) &#123;   \t    // 取出session中存储的用户名，一般只是取出，不修改        name = (String) existingSession.getAttribute(&quot;rememberMe&quot;);        isRemembered = true;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录(Session版)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;用户登录(Session版)&lt;/h2&gt;&lt;% if (&quot;1&quot;.equals(request.getParameter(&quot;error&quot;))) &#123; %&gt;&lt;p style=&quot;color:red;&quot;&gt;用户名或密码错误!&lt;/p&gt;&lt;% &#125; %&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;    账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;    记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;    登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\r\n比较ServletContext，HttpServletRequest和HttpSession\r\nServletContext\r\n\r\n范围最大,应用程序级别的,整个应用程序都能访问；\r\n是Servlet上下文对象，在服务器启动阶段解析web.xml文件创建ServletContext对象，在同一个web\r\napp中所有的Servlet对象共享同一个ServletContext对象。该对象一旦创建不会被销毁，除非将服务器停掉。\r\n一般存储在该对象中的数据首先是所有用户共享的，不会被修改的，少量数据。\r\nServletContext对象传递数据可以跨Servlet、跨请求、跨用户(跨会话)传递数据。\r\n\r\nHttpSession\r\n\r\n次之,会话级别的，在当前的浏览器中都能訪问，不论是在同一浏览器开多少窗体，都能够访问，可是换个浏览器就不行了，就必须又一次创建session；\r\n每一个用户都有一个这样的对象，是一个用户级别的对象，存储在该对象中的数据一般都是该用户专属的数据\r\nHttpSession对象传递数据可以跨Servlet、跨请求(这些请求必须属于同一个会话)、但是不能跨用户传递数据。\r\n\r\nHttpServletRequest\r\n\r\n范围最小,请求级别,请求结束,变量的作用域也结束（也就是仅仅是一次访问,访问结束，这个也结束）。\r\n是请求对象，一次请求一个对象，每一次请求都会新建一个请求对象，是一个请求级别的对象，存储该对象中的数据一般都是请求级别的数据，一次请求之后这个数据就不再使用的数据可以存储在该对象中\r\nHttpServletRequest对象传递数据可以跨Servlet，但是不能跨请求，更不能跨用户传递数据。\r\n\r\n尽量从小范围向大范围使用。(考虑原则：request&lt; session &lt;\r\napplication)\r\nServletContext、HttpSession、HttpServletRequest接口的对比：\r\n以上都是范围对象:\r\n\r\nServletContext application; 是应用范围\r\nHttpSession session; 是会话范围\r\nHttpServletRequest request; 是请求范围\r\n\r\n三个范围的排序：application &gt; session &gt; request\r\n\r\napplication完成跨会话共享数据\r\nsession完成跨请求共享数据，但是这些请求必须在同一个会话当中\r\nrequest完成跨Servlet共享数据，但是这些Servlet必须在同一个请求当中【转发】\r\n\r\n使用原则：有小到大尝试，优先使用小范围。例如：\r\n\r\n登录成功之后，已经登录的状态需要保存起来，可以将登录成功的这个状态保存到session对象中。\r\n登录成功状态不能保存到request范围中，因为一次请求对应一个新的request对象。\r\n登录成功状态也不能保存到application范围中，因为登录成功状态是属于会话级别的，不能所有用户共享。\r\n\r\nCookie与Session的比较\r\nCookie与Session都是为了保持用户访问的连续状态，之所以为了要保持这种状态，一方面是为了实现业务方便，另一方面就是简化服务器端的程序设计，提高访问性能。但是两者的实现原理不太一样，各自都有优点和缺陷，下面通过比较说明这两者的特点和适用场合。\r\n\r\n存取方式上\r\nCookie中只能保持ASCLL字符串，如果存取Unicode字符或者二进制数据，需要进行UTF-8，GBK，或者BASE64等方式的编码，而Session中可以存取任何类型的数据。\r\n隐私安全上\r\nCookie存放在客户端浏览器，对客户端是可见的，客户端的一些程序可能会窥探复制甚至修改Cookie中的内容。而Session存放在服务器端，对用户是透明的，不存在敏感信息泄露的危险。\r\n有效期上\r\nCookie可以设置长期有效，浏览器关闭也有效，虽然Session可以设置很长的有效期，但是Session依赖名为JSESSIONID的Cookie，该Cookie的maxAge默认为-1，浏览器关闭Cookie就失效，所以该Session也就失效了。\r\n服务器的负担上\r\nSession存放在服务器端，每个用户都会产生一个Session。如果并发非常大的网站，会产生大量的Session，消耗大量内存，因此像Baidu，Google这样并发量极高的网站是不会使用Session来追踪会话的，而Cookie保存在客户端，不占用服务器资源，对于并发量极高的网站Cookie是更好的选择。\r\n从浏览器支持上\r\nCookie是需要浏览器支持的，如果浏览器不支持Cookie，就需要使用Session以及URL地址重写。\r\n从跨域名上\r\nCookie支持跨域名访问，只要设置domain属性即可，但Session不能够跨域名访问，Session仅在他的域名下有效。\r\n\r\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Servlet"]},{"title":"Spring Framework part2--IoC容器之IoC原理","url":"/posts/undefined.html","content":"Spring Framework\r\npart2–IoC容器之IoC原理\r\n在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。\r\n什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。\r\n例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。\r\n通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。\r\nSpring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。\r\nIoC容器，主要关于Spring容器如何对组件进行生命周期管理和配置组装服务。\r\nIoC原理\r\nSpring提供的容器又称为IoC容器，什么是IoC？\r\nIoC全称Inversion of\r\nControl，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。\r\n控制翻转IoC\r\nIoC是一种设计思想，能够指导我们能设计出松耦合，更优良的程序，提高程序的扩展力\r\nSpring 通过\r\nIoC容器来管理所有Java对象的实例化和初始化，控制对象和对象之间的依赖关系，我们将由IoC容器管理的Java对象称为\r\nSpring Bean，他与使用关键字 new 创建的 Java 对象没有任何区别\r\n容器中存放我们的Bean（java中的对象），创建到销毁过程都是容器进行管理的\r\n控制反转，反转的是什么\r\n\r\n把对象的创建权力交出去，交给第三方容器\r\n将对象和对象之间的关系的维护权交出去，交给第三方容器负责\r\n\r\n控制反转如何实现\r\n\r\nDI 依赖注入\r\n\r\n容器放bean对象，使用的是 map 集合\r\nIoC容器过程示例图\r\n\r\n依赖注入\r\nDI 依赖注入 实现了控制反转的思想\r\n依赖注入\r\n\r\nSpring创建对象的过程中，将对象依赖属性通过配置进行注入\r\n\r\n常见方式包括以下两种\r\n\r\n第一种，set注入\r\n第二种，构造注入\r\n\r\n所以，IoC就是一直控制反转的思想，而 DI 是对IoC的一种具体实现\r\nBean管理说的是：Bean对象的创建，以及Bean对象中属性的值（Bean对象之间关系的维护）\r\nIoC容器在Spring的实现\r\nIoC容器中管理的组件也叫Bean，创建Bean之前，首先要创建IoC容器，Spring提供了IoC容器的两组实现方式\r\n\r\nBeanFactory\r\n顶层接口，IoC容器的基本实现，是Spring内部使用的接口，面向Spring本身，不提供给开发人员使用\r\nApplicationContext\r\nBeanFactory的子接口，提供了更多的高级特性\r\n主要实现类如下\r\n\r\n\r\n\r\n1\r\n\r\n\r\n\r\n\r\nimage-20250419180928366\r\n\r\n\r\n传统\r\nJava 组件协作 与 IoC 控制反转 的对比会在下述例子中体现\r\n一个电商系统需要处理订单，订单服务（OrderService）依赖支付服务（PaymentService）完成支付逻辑。\r\n传统方式：硬编码依赖\r\n// 支付服务实现public class PaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment...&quot;);    &#125;&#125;// 订单服务直接创建依赖对象public class OrderService &#123;    private PaymentService paymentService = new PaymentService(); // 硬编码依赖    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方代码public class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        orderService.createOrder();    &#125;&#125;\r\n紧耦合：OrderService 直接实例化\r\nPaymentService，若需替换支付实现（如改用支付宝或微信支付），必须修改\r\nOrderService 的代码。\r\n上述每个组件都采用了一种简单的通过new创建实例并持有的方式，但是这种方式有着很大的缺点：\r\n\r\n随着更多的组件被引入，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。\r\n没有必要让不同的两个类分别创建相同功能的实例，完全可以共享同一个，但谁负责创建，谁负责获取其他组件已经创建的，不好处理\r\n实例化一个组件其实很难，因为各种依赖关系可能存在\r\n测试某个组件，例如OrderService，是复杂的，因为必须要在支付环境下执行。\r\n\r\n从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\r\n因此，核心问题是：\r\n\r\n谁负责创建组件？\r\n谁负责根据依赖关系组装组件？\r\n销毁时，如何按依赖顺序正确销毁？\r\n\r\n解决这一问题的核心方案就是IoC。\r\nIoC 方式：通过依赖注入解耦\r\n// 定义支付接口（面向接口编程）public interface PaymentService &#123;    void processPayment();&#125;// 支付宝实现public class AlipayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;// 微信支付实现public class WechatPayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Wechat Pay...&quot;);    &#125;&#125;// 订单服务通过构造函数注入依赖public class OrderService &#123;    private PaymentService paymentService;    // 依赖由外部传入（控制权反转）    public OrderService(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方通过容器（如 Spring）管理依赖public class Main &#123;    public static void main(String[] args) &#123;        // 由容器决定具体实现（如配置为 AlipayService）        PaymentService paymentService = new AlipayService();        OrderService orderService = new OrderService(paymentService);        orderService.createOrder();    &#125;&#125;\r\n\r\n解耦：OrderService 不再关心\r\nPaymentService 的具体实现，只需依赖接口。\r\n灵活性：更换支付方式时，只需修改外部配置（如 Spring\r\n的 Bean 定义），无需改动 OrderService 代码。\r\n可测试性：在单元测试中，可以注入\r\nMockPaymentService 模拟不同场景。\r\n\r\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。\r\n为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如\r\nOrderService 自己并不会创建\r\npaymentService，而是等待外部通过createOrder方法来注入一个OrderService\r\npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;        System.out.println(&quot;Order created!&quot;);    &#125;&#125;\r\n不直接用 new，而是注入一个\r\npaymentService，带来了一系列好处\r\n\r\n可维护性显著提升\r\n\r\n在传统方式中，若要更换支付服务的实现，比如从当前的简单支付服务切换到支付宝支付服务，就需要直接修改\r\nOrderService 类的代码。而在 IoC\r\n模式下，由于采用了注入机制，OrderService\r\n类本身不需要做任何修改。\r\n假设我们有一个新的 AlipayPaymentService 类\r\npublic class AlipayPaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;\r\n在调用方代码中，我们只需要注入新的支付服务实例即可\r\npublic class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        AlipayPaymentService alipayPaymentService = new AlipayPaymentService();        orderService.createOrder(alipayPaymentService);    &#125;&#125;\r\n这样，当业务需求发生变化时，我们可以轻松地替换支付服务的实现，而不会影响到\r\nOrderService\r\n类的内部逻辑，大大提高了代码的可维护性。\r\n\r\n可测试性大幅增强\r\n\r\n在传统方式下，测试 OrderService\r\n类时，由于它直接依赖于\r\nPaymentService，必须在真实的支付环境下进行测试，这不仅增加了测试的复杂性，还可能带来不必要的风险\r\n而在 IoC 模式下，我们可以使用模拟对象（Mock\r\nObject）来进行测试。例如，使用 JUnit 和 Mockito\r\n框架，我们可以创建一个模拟的 PaymentService\r\n对象，并将其注入到 OrderService 中进行测试：\r\nimport org.junit.jupiter.api.Test;import static org.mockito.Mockito.*;public class OrderServiceTest &#123;    @Test    public void testCreateOrder() &#123;        // 创建模拟的 PaymentService 对象        PaymentService mockPaymentService = mock(PaymentService.class);        OrderService orderService = new OrderService();        // 调用 createOrder 方法并注入模拟对象        orderService.createOrder(mockPaymentService);        // 验证 PaymentService 的 processPayment 方法是否被调用        verify(mockPaymentService, times(1)).processPayment();    &#125;&#125;\r\n\r\n依赖关系管理更加清晰\r\n\r\n在 IoC 模式下，所有组件的创建和依赖关系的组装都由 IoC\r\n容器负责，应用程序只需要使用已经创建好并配置好的组件。在 IoC\r\n模式下,通过配置文件或注解的方式将这些依赖关系清晰地表达出来，由 IoC\r\n容器根据这些配置信息来创建和组装组件。这样，开发人员只需要关注组件的功能实现，而不需要关心组件之间的依赖关系，降低了系统的复杂度。\r\n\r\n\r\n因此，IoC又称为依赖注入（DI：Dependency\r\nInjection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\r\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现\r\n&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。\r\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\r\n依赖注入方式\r\n我们从上面的代码可以看到，依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。\r\n很多Java类都具有带参数的构造方法，如果我们把 OrderService\r\n改造为通过构造方法注入，那么实现代码如下：\r\npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;&#125;\r\nSpring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。\r\n无侵入容器\r\n在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\r\n\r\n应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\r\n测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Farmewrok part1-Spring生态介绍和入门","url":"/posts/26666.html","content":"Spring 和 Spring Framework\r\nSpring、Spring Framework、Spring Boot、Spring Cloud的区别。\r\n首先不少人乐意把 Spring Framework 叫做 spring，但是 spring framework\r\n只是 spring中的一个模型，核心是Ioc和aop，而spring是一个生态，spring\r\n是框架。\r\n\r\n\r\nimage-20250416143538464\r\n\r\n\r\n\r\nimage-20250416143538464\r\n\r\n\r\n\r\nimage-20250416143638910\r\n\r\n\r\n\r\nimage-20250416143638910\r\n\r\nSpring是一个生态体系（也可以说是技术体系），是集大成者，它包含了\r\nSpring Framework、Spring Boot、Spring Cloud 等（还包括Spring Cloud data\r\nflow、spring data、spring integration、spring batch、spring\r\nsecurity、spring hateoas），如下图所示（部分截图）：\r\n\r\nSpring Framework\r\nSpring\r\nFramework是整个spring生态的基石，它可是硬生生的消灭了Java官方主推的企业级开发标准EJB，从而实现一统天下。\r\nSpring Framework为基于现代企业应用提供了一个全面的编程和配置的模型 -\r\n在任何类型部署平台上\r\nSpring\r\nFramework为依赖注入、事务管理、WEB应用、数据访问等提供了核心的支持，专注于企业级应用程序的“管道”，以便开发团队可以专注于应用程序的业务逻辑。\r\nSpring Boot\r\n搭建项目的脚手架、黏合剂，整合周边生态\r\nSpring\r\nBoot这家伙简直就是对Java企业级应用开发进行了一场浩浩荡荡的革命。如果稍微有几年工作经验的老油条，应该都记得以前的Java\r\nWeb开发模式：Tomcat + WAR包。\r\nSpring Boot能够让你非常容易的创建一个单机版本、生产级别的基于spring\r\nframework的应用。然后，“just run”即可。Spring\r\nBoot默认集成了很多第三方包，让构建独立的生产级别的Spring应用变得简单，开箱即用，以便你能以最小的代价开始一个项目。\r\nSpring Cloud\r\nSpring Clound的出现真正简化了分布式架构的开发\r\nSpring Cloud事实上是一整套基于Spring\r\nBoot的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：配置管理、注册中心、服务发现、限流、网关、链路追踪等。\r\nSpring Boot是build anything，而Spring Cloud是coordinate\r\nanything，Spring Cloud的每一个微服务解决方案都是基于Spring\r\nBoot构建的：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\nSpring Cloud Alibaba\r\nSpring Cloud\r\nAlibaba为分布式应用开发提供一站式解决方案，它包含分布式应用程序开发所需的所有组件，使你可以轻松地使用Spring\r\nCloud开发应用程序。\r\n使用Spring Cloud\r\nAlibaba，你只需要增加一些注解和少量的配置，即可将Spring\r\nCloud应用连接到阿里巴巴的分布式解决方案，并可使用阿里巴巴的中间件构建分布式系统\r\nSpring Framework主要包括什么\r\nSpring Framework主要包括几个模块：\r\n\r\n支持IoC和AOP的容器；\r\n支持JDBC和ORM的数据访问模块；\r\n支持声明式事务的模块；\r\n支持基于Servlet的MVC开发；\r\n支持基于Reactive的Web开发；\r\n以及集成JMS、JavaMail、JMX、缓存等其他模块。\r\n\r\nSpring版本5.x 和 6.x的区别\r\n\r\n\r\nimage-20250416135252699\r\n\r\n\r\n\r\nimage-20250416135252699\r\n\r\nSpring官网是spring.io\r\n为什么要学Spring Framework\r\nSpring Framework 是其他 Spring 子项目的基础\r\n无论是传统企业应用还是云原生微服务，Spring Framework 的核心思想（如\r\nIoC、AOP）均贯穿始终\r\nSpring Framework 是整个 Spring 技术栈的基石，其他子项目（如 Spring\r\nBoot、Spring MVC、Spring Cloud\r\n等）均基于其核心功能扩展。它通过控制反转（IoC）、依赖注入（DI）和面向切面编程（AOP）等机制，为上层模块提供统一的基础设施支持\r\n而且S pring Framework 其分层架构（如 Core、AOP、Data Access、Web\r\n等模块）允许开发者按需选择功能，避免冗余依赖。这种灵活性使得 Spring\r\n能够适配从传统单体应用到现代微服务的多样化需求\r\nSpring Framework 提供与多种企业级技术（如\r\nJDBC、JPA、Hibernate、消息队列等）的无缝集成能力，简化了复杂系统的开发\r\n学习 Spring Framework 是掌握 Spring Boot（快速开发）、Spring\r\nCloud（微服务）等高级框架的前提。例如，Spring Boot\r\n的自动配置机制本质上是基于 Spring Framework 的条件化 Bean 加载实现\r\n\r\nSpring\r\nFramework 官方文档\r\nSpring\r\nFramework 源码\r\nSpring\r\n入门课程（W3CSchool）\r\n\r\nSpring Framework特点\r\n\r\n非侵入式：Spring Framework开发应用程序时，Spring\r\n对应用程序本身的结构影响特别小，应用代码基本不会被 Spring 特定的 API\r\n所束缚。开发者能够在不依赖 Spring\r\n框架的环境下对代码进行编译、测试和运行。当项目需要更换框架或者调整架构时，由于代码没有与\r\nSpring 框架深度绑定，迁移工作会相对轻松。开发者可以逐步移除 Spring\r\n相关的配置和依赖，而不会对业务逻辑代码造成重大影响。\r\n控制反转IoC：控制反转是 Spring\r\n框架的核心特性之一，它将对象的创建和依赖关系的管理从应用程序代码转移到了\r\nSpring\r\n容器中。通过控制反转，对象之间的依赖关系变得更加灵活，降低了组件之间的耦合度。\r\n面向切面编程AOP：面向切面编程允许开发者将横切关注点（如日志记录、事务管理、权限验证等）从业务逻辑中分离出来，以提高代码的可维护性和复用性。通过\r\nAOP，我们可以将通用的横切关注点代码封装到切面中，在多个业务模块中复用这些代码，减少了代码的重复编写。\r\n容器：Spring\r\n框架提供了强大的容器功能，用于管理对象的生命周期和依赖关系。IoC是一个容器，包含并且管理组件对象的生命周期，组件享受到了容器化的管理，屏蔽了大量的细节。Spring\r\n容器通过依赖注入的方式将对象之间的依赖关系注入到对象中，使得对象之间的协作更加灵活。\r\n组件化：Spring\r\n鼓励开发者将应用程序拆分成多个独立的组件，每个组件负责特定的功能。开发者可以将不同的业务功能封装成独立的组件，这些组件可以独立开发、测试和部署。组件化的开发方式使得代码结构更加清晰，易于维护和扩展。当需要添加新的功能时，只需要开发新的组件并将其集成到应用中即可。\r\n一站式：Spring\r\n框架提供了一站式的解决方案，涵盖了企业级应用开发的各个方面。可以整合各种企业应用的开源框架和优秀的第三方类库。\r\n\r\nSpring6 的模块组成\r\n\r\n\r\nimage-20250422090232709\r\n\r\n\r\n\r\nimage-20250422090232709\r\n\r\nSpring Framework 主要是围绕 Core 部分\r\n\r\n\r\nimage-20250416154223849\r\n\r\n\r\n\r\nimage-20250416154223849\r\n\r\nSpring Core：核心容器\r\n\r\n\r\nimage-20250416154542715\r\n\r\n\r\n\r\nimage-20250416154542715\r\n\r\nSpring AOP\r\n\r\n\r\nimage-20250416154553397\r\n\r\n\r\n\r\nimage-20250416154553397\r\n\r\nSpring Data Access\r\n\r\n\r\nimage-20250416154623457\r\n\r\n\r\n\r\nimage-20250416154623457\r\n\r\nSpring Web\r\n就是大家通常说的Spring MVC部分\r\n\r\n\r\nimage-20250416172213876\r\n\r\n\r\n\r\nimage-20250416172213876\r\n\r\nSpring Message 和 Spring test\r\n\r\n\r\nimage-20250416172240188\r\n\r\n\r\n\r\nimage-20250416172240188\r\n\r\n如何创建工程\r\n父工程 spring6 子工程 你自己项目名称\r\n开发步骤：\r\n\r\n引入spring相关依赖\r\n创建类，定义属性和方法\r\n按照spring要求创建配置文件 xml\r\nspring配置文件配置相关信息\r\n进行测试\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Boot中使用Hibernate框架","url":"/posts/9323.html","content":"在Spring\r\nBoot项目中使用Hibernate\r\nSpring Data JPA是Spring框架提供的简化JPA(Java Persistence\r\nAPI)操作的模块，而Hibernate是最流行的JPA实现之一\r\nHibernate是一个流行的ORM（对象关系映射）框架，它可以将Java对象映射到数据库表，从而方便地进行持久化操作。\r\n在Spring\r\nBoot项目中，集成Hibernate可以帮助我们更轻松地进行数据库操作。\r\n在Spring\r\nBoot项目中如何使用这两者，先写一个例子，我会在项目中，边写边用详细的注释来分析\r\n项目示例\r\n依赖导入\r\n&lt;dependencies&gt;    &lt;!-- Spring Boot Starter Data JPA (包含Hibernate) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;!-- 数据库驱动，这里以MySQL为例 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- 其他你可能需要的依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n进行配置文件的配置\r\n# 应用名称，建议与项目模块名一致spring.application.name=SpringAndHibernate # 数据库连接配置（HikariCP 连接池）spring.datasource.url=jdbc:mysql://localhost:3306/hibernate_demo?createDatabaseIfNotExist=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai# 说明：# - createDatabaseIfNotExist=true：开发环境自动创建数据库（生产环境需删除）# - serverTimezone=Asia/Shanghai：使用中国标准时区，避免时间转换问题spring.datasource.username=root # 数据库用户名（生产环境建议使用独立权限用户）spring.datasource.password=zjm10086 # 数据库密码（敏感信息，生产环境建议通过环境变量注入）spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # MySQL 8.0+ 驱动类spring.datasource.hikari.maximum-pool-size=10 # 最大连接数（开发环境默认 10，生产环境可调整为 20-50）spring.datasource.hikari.minimum-idle=5 # 最小空闲连接数（默认与 max 一致，可按需调整）spring.datasource.hikari.idle-timeout=30000 # 空闲连接超时时间（毫秒，默认 60000）# Hibernate 配置（JPA 标准）spring.jpa.hibernate.ddl-auto=update   # 开发环境自动更新表结构（生产环境用 validate）spring.jpa.show-sql=true    # 开发环境显示 SQL（生产环境关闭）spring.jpa.properties.hibernate.format_sql=true     # 格式化 SQL 输出，便于阅读spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect # MySQL 8.0+ 方言# 以下为可选配置（按需启用）：# spring.jpa.properties.hibernate.cache.use_second_level_cache=true # 二级缓存# spring.jpa.properties.hibernate.generate_statistics=true # 生成性能统计信息# 日志配置（Logback 级别控制）logging.level.org.hibernate.SQL=DEBUG    # 显示执行的 SQL 语句logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE   # 显示 SQL 参数绑定细节# 生产环境建议配置：# logging.level.org.hibernate.SQL=INFO# logging.level.org.hibernate.type.descriptor.sql.BasicBinder=INFO\r\n参数说明：\r\n\r\nspring.datasource.*：配置数据源的基本信息。\r\nspring.jpa.hibernate.ddl-auto：控制Hibernate的DDL操作（如update、create、none）。\r\nspring.jpa.show-sql：是否显示SQL语句。\r\nspring.jpa.properties.hibernate.*：Hibernate的高级配置。\r\n\r\n这里使用了MySQL数据库，可以根据实际情况进行修改。其中，spring.jpa.hibernate.ddl-auto属性指定了Hibernate如何自动生成数据库表，create-drop表示每次启动应用程序时都会创建表，并在关闭应用程序时删除表。\r\nddl-auto选项说明：\r\n\r\ncreate:\r\n每次启动都重新创建表结构，数据会丢失\r\ncreate-drop:\r\n加载hibernate时创建，退出时删除表结构\r\nupdate:\r\n加载hibernate自动更新数据库结构，保留数据\r\nvalidate:\r\n加载hibernate时，验证创建数据库表结构，会和数据库中的表进行比较，不会创建新表，但是会插入新值\r\nnone`: 不执行任何操作。 永远以数据表字段为准\r\n\r\n创建实体类\r\n使用JPA注解定义实体类，用于映射到数据库表：\r\npackage edu.software.ergoutree.springandhibernate.model;import jakarta.persistence.*;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * 学生实体类 - 映射数据库中的学生表 * 该类使用JPA注解定义了与数据库表的映射关系， * 并通过Lombok注解简化了JavaBean的常规代码。 * * @Entity 声明该类为JPA实体类 * @Table 指定对应数据库表名为&quot;students&quot; * @Data 自动生成getter/setter、toString、equals和hashCode方法 * @NoArgsConstructor 自动生成无参构造函数 * @AllArgsConstructor 自动生成包含所有字段的构造函数 */@Entity@Data@Table(name = &quot;students&quot;)@NoArgsConstructor@AllArgsConstructorpublic class Student &#123;    /**     * 学生唯一标识     * @Id 声明该字段为主键     * @GeneratedValue 指定主键生成策略为自增（对应数据库自增字段）     */    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    /**     * 学生姓名     * @Column 定义字段映射属性：     * - nullable = false: 不允许为空     * - length = 100: 最大长度100字符     */    @Column(name = &quot;name&quot;, nullable = false, length = 100)    private String name;    /**     * 学生邮箱     * @Column 定义字段映射属性：     * - unique = true: 要求邮箱地址唯一     */    @Column(name = &quot;email&quot;, unique = true)    private String email;    /**     * 学生年龄     * 使用包装类Integer允许值为null     */    @Column(name = &quot;age&quot;)    private Integer age;    /**     * 用于创建新学生的构造函数     * 不包含id字段，因为id由数据库自动生成     * @param name 学生姓名（必填）     * @param email 学生邮箱（必填且唯一）     * @param age 学生年龄（可选）     */    public Student(String name, String email, Integer age) &#123;        this.name = name;        this.email = email;        this.age = age;    &#125;&#125;\r\n其中@Entity表示这是一个JPA实体类，@Table(name =\r\n“students”)指定实体类对应数据库表名为students，@Id表示数据库的标识字段，也就是主键，@GeneratedValue注解指定了主键的生成策略，@Column指定对应数据库字段。\r\n创建DAO层\r\n创建一个简单的Repository，用于访问数据库：\r\nDAO层需要继承JpaRepository接口，这样才能根据方法名自动获得基本的CRUD操作，该接口有两个参数化类型，第一个表示实体类的类型，第二个表示主键的类型，也就是@Id注解标注的字段的类型，这里是Long。\r\n需要在启动类上面使用@EnableJpaRepositories注解\r\npackage edu.software.ergoutree.springandhibernate.repository;import edu.software.ergoutree.springandhibernate.model.Student;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 学生数据访问层 * 继承JpaRepository，自动获得基本的CRUD操作 */@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;    /**     * 方法名约定查询：根据名字模糊匹配学生     * 等效SQL：SELECT * FROM students WHERE name LIKE %?%     */    List&lt;Student&gt; findByNameContaining(String name);    /**     * 方法名约定查询：根据年龄范围查询学生     * 等效SQL：SELECT * FROM students WHERE age BETWEEN ? AND ?     */    List&lt;Student&gt; findByAgeBetween(Integer minAge, Integer maxAge);    /**     * JPQL查询：根据邮箱模式查询学生     * @Param 注解绑定命名参数到JPQL中的:email     */    @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)    List&lt;Student&gt; findStudentsByEmailPattern(@Param(&quot;email&quot;) String email);    /**     * 原生SQL查询：查询年龄大于指定值的学生，并按名字排序     * nativeQuery=true：启用原生SQL（直接操作数据库表）     */    @Query(value = &quot;SELECT * FROM students WHERE age &gt; :age ORDER BY name&quot;, nativeQuery = true)    List&lt;Student&gt; findStudentsOlderThanAge(@Param(&quot;age&quot;) Integer age);    /**     * 分页查询：根据名字模糊匹配学生，并支持分页和排序     * @param name 搜索关键词     * @param pageable 分页和排序参数     * @return 分页结果（包含总页数、总记录数等信息）     */    Page&lt;Student&gt; findByNameContaining(String name, Pageable pageable);    /**     * 自定义更新操作：修改学生年龄     * @Modifying 注解：标识该查询为修改操作     * @Transactional 需在调用层声明事务     */    @Modifying    @Query(&quot;UPDATE Student s SET s.age = :age WHERE s.id = :id&quot;)    int updateStudentAge(@Param(&quot;id&quot;) Long id, @Param(&quot;age&quot;) Integer age);&#125;\r\n在Repository上使用@Repository注解，表示这是一个Spring组件，并且用于访问数据库。PersonRepository继承自JpaRepository，这个接口提供了许多通用的数据库操作方法，如save、findById等。\r\n接口整体注解与继承\r\n@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;\r\n\r\n@Repository：\r\n\r\n声明该接口为 Spring 数据访问组件，自动注册为 Bean。\r\n作用：\r\n\r\n将数据访问层的异常（如 SQLException）转换为 Spring 的\r\nDataAccessException。\r\n支持组件扫描，无需在 XML 中手动配置 Bean。\r\n\r\n\r\nJpaRepository：\r\n\r\nSpring Data JPA 提供的核心接口，继承关系\r\nJpaRepository ← PagingAndSortingRepository ← CrudRepository\r\n内置方法\r\n// CrudRepository 提供的基础方法&lt;S extends T&gt; S save(S entity);Optional&lt;T&gt; findById(ID id);boolean existsById(ID id);Iterable&lt;T&gt; findAll();void deleteById(ID id);long count();// PagingAndSortingRepository 扩展的分页排序方法Page&lt;T&gt; findAll(Pageable pageable);Iterable&lt;T&gt; findAll(Sort sort);// JpaRepository 特有的方法void flush();&lt;S extends T&gt; S saveAndFlush(S entity);List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);\r\n\r\n\r\n方法名约定查询\r\n\r\n模糊查询（Containing）\r\n\r\nList&lt;Student&gt; findByNameContaining(String name);\r\n\r\n解析规则：\r\n\r\nfindBy：固定前缀，表示查询操作。\r\nNameContaining：字段名（Name） +\r\n匹配方式（Containing）。\r\n等效 SQL：WHERE name LIKE %?%。\r\n\r\n参数处理：\r\n\r\n传入 name=\"John\" 时，生成\r\nSQL：WHERE name LIKE '%John%'。\r\n\r\n其他常用匹配方式：\r\n\r\n\r\n\r\n关键字\r\nSQL 等效\r\n示例方法名\r\n\r\n\r\n\r\n\r\nContaining\r\nLIKE %?%\r\nfindByNameContaining\r\n\r\n\r\nStartingWith\r\nLIKE ?%\r\nfindByNameStartingWith\r\n\r\n\r\nEndingWith\r\nLIKE %?\r\nfindByNameEndingWith\r\n\r\n\r\nIsNotNull\r\nIS NOT NULL\r\nfindByNameIsNotNull\r\n\r\n\r\nGreaterThan\r\n&gt;\r\nfindByAgeGreaterThan\r\n\r\n\r\n\r\n\r\n\r\n范围查询（Between）\r\n\r\nList&lt;Student&gt; findByAgeBetween(Integer minAge, Integer maxAge);\r\n\r\n解析规则：\r\n\r\nfindBy：查询前缀。\r\nAgeBetween：字段名（Age） +\r\n范围操作（Between）。\r\n等效 SQL：WHERE age BETWEEN ? AND ?。\r\n\r\n参数顺序：\r\n\r\n第一个参数对应下限（minAge），第二个对应上限（maxAge）。\r\n\r\n\r\n\r\nJPQL 查询（@Query 注解）\r\n\r\n@Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)List&lt;Student&gt; findStudentsByEmailPattern(@Param(&quot;email&quot;) String email);\r\n\r\n@Query 注解：\r\n\r\n使用 JPA 查询语言（JPQL），语法类似\r\nSQL，但操作对象是实体类而非表。\r\n``` %:email%     - `:` 表示命名参数（对应 `@Param(&quot;email&quot;)`）。    - `%` 是 JPQL 的模糊匹配符（等效 SQL 的 `LIKE`）。- **命名参数绑定**：  - `@Param(&quot;email&quot;)`：将方法参数 `email` 绑定到 JPQL 中的 `:email`。- **替代方案：位置参数**：    ```java  @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %?1%&quot;)  List&lt;Student&gt; findStudentsByEmailPattern(String email);\r\n?1 表示第一个参数（从 1\r\n开始），但命名参数更易维护。\r\n\r\n\r\n\r\n原生 SQL\r\n查询（nativeQuery = true）\r\n\r\n@Query(value = &quot;SELECT * FROM students WHERE age &gt; :age ORDER BY name&quot;, nativeQuery = true)List&lt;Student&gt; findStudentsOlderThanAge(@Param(&quot;age&quot;) Integer age);\r\n\r\nnativeQuery = true：\r\n\r\n启用原生 SQL 查询，直接执行数据库 SQL 语句。\r\n表名 students\r\n和字段名需与数据库一致（而非实体类名和属性名）。\r\n\r\n适用场景：\r\n\r\nJPQL 无法表达复杂查询（如存储过程、函数调用）。\r\n需利用特定数据库特性（如 MySQL 的 GROUP_CONCAT）。\r\n\r\n风险提示：\r\n\r\n失去数据库无关性（如切换到 Oracle 可能需要修改 SQL）。\r\n字段名与实体属性映射需严格匹配（可通过\r\nSELECT s.id AS id, s.name AS name 显式映射）。\r\n\r\n\r\n\r\n分页与排序\r\n\r\n分页查询示例\r\n\r\n\r\n// 在接口中添加分页方法Page&lt;Student&gt; findByNameContaining(String name, Pageable pageable);// 调用示例Pageable pageable = PageRequest.of(0, 10, Sort.by(&quot;name&quot;).ascending());Page&lt;Student&gt; result = studentRepository.findByNameContaining(&quot;John&quot;, pageable);\r\n\r\nPageable 参数：\r\n\r\n``` PageRequest.of(page, size, sort)     - `page`：页码（从 0 开始）。    - `size`：每页数量。    - `sort`：排序规则（如 `Sort.by(&quot;name&quot;).ascending()`）。- **返回类型 `Page`**：  - 包含分页信息（总页数、总记录数、当前页数据）：    ```java    long totalElements = result.getTotalElements(); // 总记录数    int totalPages = result.getTotalPages();         // 总页数    List&lt;Student&gt; content = result.getContent();     // 当前页数据\r\n\r\n\r\n\r\n排序查询示例\r\n\r\n// 方法名中添加排序关键词List&lt;Student&gt; findByAgeGreaterThan(Integer age, Sort sort);// 调用示例Sort sort = Sort.by(&quot;name&quot;).descending().and(Sort.by(&quot;age&quot;).ascending());List&lt;Student&gt; result = studentRepository.findByAgeGreaterThan(18, sort);\r\n\r\nSort 参数\r\n\r\n支持多字段排序（如 name DESC, age ASC）。\r\n\r\n\r\n\r\n自定义方法实现\r\n\r\n若默认方法和查询注解无法满足需求，可通过以下方式扩展：\r\n\r\n自定义 Repository 实现\r\n\r\n// 1. 定义扩展接口interface StudentRepositoryCustom &#123;    List&lt;Student&gt; findStudentsByCustomCriteria(String criteria);&#125;// 2. 实现扩展接口class StudentRepositoryImpl implements StudentRepositoryCustom &#123;    @PersistenceContext    private EntityManager entityManager;        @Override    public List&lt;Student&gt; findStudentsByCustomCriteria(String criteria) &#123;        // 使用 EntityManager 实现自定义查询        String jpql = &quot;SELECT s FROM Student s WHERE ...&quot;;        return entityManager.createQuery(jpql, Student.class).getResultList();    &#125;&#125;// 3. 让主 Repository 继承扩展接口public interface StudentRepository extends JpaRepository&lt;Student, Long&gt;, StudentRepositoryCustom &#123;    // 现有方法保持不变&#125;\r\n\r\n使用 @Modifying 注解执行更新操作\r\n\r\n@Modifying@Query(&quot;UPDATE Student s SET s.age = :age WHERE s.id = :id&quot;)int updateStudentAge(@Param(&quot;id&quot;) Long id, @Param(&quot;age&quot;) Integer age);\r\n\r\n注意事项\r\n\r\n需配合 @Transactional 使用（在 Service 层声明）。\r\n返回值为受影响的行数。\r\n\r\n\r\nService层的编写\r\n先写接口\r\npackage edu.software.ergoutree.springandhibernate.service;import edu.software.ergoutree.springandhibernate.model.Student;import org.springframework.data.domain.Pageable;import java.util.List;import java.util.Optional;/** * 学生服务接口 * 定义学生相关的业务逻辑方法，通过 Spring Data JPA 间接使用 Hibernate 实现数据持久化 */public interface StudentService &#123;    /**     * 保存或更新学生（新增/修改）     * - 新增：学生 ID 为空时，Hibernate 生成 INSERT 语句     * - 更新：学生 ID 存在时，Hibernate 通过脏检查生成 UPDATE 语句     * @param student 学生实体（瞬时态或脱管态）     * @return 持久态学生对象（含数据库生成的 ID 或更新后的状态）     * @transactional 该方法需在事务内执行（由 Service 实现类注解控制）     */    Student saveStudent(Student student);    /**     * 根据 ID 查找学生（优先从一级缓存获取）     * @param id 学生 ID     * @return Optional 包装的持久态学生对象（若存在）     * @hibernate 操作：调用 StudentRepository.findById(id)，触发 Session.get() 查询     * @二级缓存扩展：可通过 @Cacheable 注解启用二级缓存     */    Optional&lt;Student&gt; findStudentById(Long id);    /**     * 查询所有学生（支持分页优化）     * @return 学生列表（持久态对象集合）     * @建议：实际开发中添加 Pageable 参数，避免全量加载：List&lt;Student&gt; findAllStudents(Pageable pageable)     * @hibernate 操作：生成 JPQL SELECT s FROM Student s，支持排序和分页     */    List&lt;Student&gt; findAllStudents();    /**     * 根据 ID 更新学生信息（需先查询原实体以确保处于持久态）     * @param student 包含更新字段的脱管态实体（需携带 ID）     * @return 更新后的持久态学生对象     * @hibernate 操作：     * 1. 通过 repository.findById(student.getId()) 将实体重新关联到 Session     * 2. 对比字段差异，生成 UPDATE 语句（仅更新变更字段）     */    Student updateStudent(Student student);    /**     * 根据 ID 删除学生（级联处理关联对象，如 @OneToMany(cascade = REMOVE)）     * @param id 学生 ID     * @throws EmptyResultDataAccessException 若 ID 不存在     * @hibernate 操作：调用 repository.deleteById(id)，生成 DELETE 语句     */    void deleteStudentById(Long id);    /**     * 根据名字模糊查询学生（方法名解析查询）     * @param name 姓名关键词（如 &quot;李&quot;）     * @return 匹配的持久态学生列表     * @hibernate 生成：JPQL SELECT s FROM Student s WHERE s.name LIKE %?%     */    List&lt;Student&gt; findStudentsByName(String name);    /**     * 根据年龄范围查询学生（方法名解析范围查询）     * @param minAge 最小年龄（包含）     * @param maxAge 最大年龄（包含）     * @return 符合条件的持久态学生列表     * @hibernate 生成：JPQL SELECT s FROM Student s WHERE s.age BETWEEN ? AND ?     */    List&lt;Student&gt; findStudentsByAgeRange(Integer minAge, Integer maxAge);    /**     * 根据邮箱模式查询学生（JPQL 自定义查询）     * @param email 邮箱关键词（支持 %，如 &quot;admin@&quot;）     * @return 匹配的持久态学生列表     * @hibernate 操作：执行 @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)     */    List&lt;Student&gt; findStudentsByEmailPattern(String email);    /**     * 根据年龄阈值查询学生（原生 SQL 示例）     * @param age 年龄阈值     * @return 符合条件的持久态学生列表     * @hibernate 操作：执行 @Query(value = &quot;SELECT * FROM students WHERE age &gt; :age&quot;, nativeQuery = true)     * @注意：表名 students 需与数据库一致（通过 @Table(name = &quot;students&quot;) 映射）     */    List&lt;Student&gt; findStudentsOlderThan(Integer age);&#125;\r\n再写实现类\r\npackage edu.software.ergoutree.springandhibernate.service.impl;import edu.software.ergoutree.springandhibernate.model.Student;import edu.software.ergoutree.springandhibernate.repository.StudentRepository;import edu.software.ergoutree.springandhibernate.service.StudentService;import jakarta.transaction.Transactional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;/** * 学生服务实现类 * 实现 StudentService 接口，基于 Spring Data JPA 和 Hibernate 完成数据操作 * Hibernate 核心： * 1. 通过 StudentRepository 间接调用 Hibernate 的 Session 方法 * 2. 事务管理由 Spring 整合 Hibernate 的 Transaction 机制实现 * 3. 实体对象状态自动管理（持久态、脱管态转换） */@Service // 标记为 Spring 服务组件，纳入依赖注入容器public class StudentServiceImpl implements StudentService &#123;    // 注入数据访问层接口（由 Spring 自动装配实现类）    private final StudentRepository studentRepository;    @Autowired // 构造函数注入，保证依赖不可变    public StudentServiceImpl(StudentRepository studentRepository) &#123;        this.studentRepository = studentRepository;    &#125;    /**     * 保存学生（新增或更新）     * - 新增：当 student.getId() 为 null 时，Hibernate 执行 INSERT     * - 更新：当 student.getId() 存在时，Hibernate 执行 UPDATE（基于脏检查）     * @param student 学生实体（瞬时态或脱管态）     * @return 持久态学生对象（数据库操作后状态）     * @Transactional 注解：     * - 开启事务，Hibernate 在事务提交时同步数据到数据库     * - 等效于 Hibernate 的 session.beginTransaction() 和 session.commit()     */    @Override    @Transactional // 声明式事务控制    public Student saveStudent(Student student) &#123;        return studentRepository.save(student); // 调用 JpaRepository.save()，触发 Hibernate 持久化    &#125;    /**     * 根据 ID 查询学生     * @param id 学生 ID     * @return Optional&lt;Student&gt; 包含持久态对象（若存在）     * @Hibernate 操作：     * 1. 调用 studentRepository.findById(id)     * 2. 内部通过 session.get(Student.class, id) 查询，使用一级缓存     */    @Override    public Optional&lt;Student&gt; findStudentById(Long id) &#123;        return studentRepository.findById(id); // 调用 JpaRepository.findById()    &#125;    /**     * 查询所有学生     * @return 持久态学生列表（由 Hibernate 维护对象状态）     * @Hibernate 生成 SQL：SELECT * FROM students（通过实体映射规则）     */    @Override    public List&lt;Student&gt; findAllStudents() &#123;        return studentRepository.findAll(); // 调用 JpaRepository.findAll()    &#125;    /**     * 更新学生信息（需验证学生存在）     * @param student 脱管态学生实体（必须包含 ID）     * @return 持久态学生对象（更新后状态）     * @Hibernate 步骤：     * 1. existsById() 检查实体是否存在（调用 session.contains()）     * 2. save() 执行 merge 操作，合并脱管态对象到持久化上下文     */    @Override    @Transactional    public Student updateStudent(Student student) &#123;        // 校验 ID 有效性（防止更新不存在的记录）        if (student.getId() != null &amp;&amp; studentRepository.existsById(student.getId())) &#123;            return studentRepository.save(student); // 执行更新操作        &#125;        throw new IllegalArgumentException(&quot;学生 ID 无效或记录不存在&quot;);    &#125;    /**     * 删除学生记录     * @param id 学生 ID     * @Hibernate 操作：     * 1. 调用 studentRepository.deleteById(id)     * 2. 生成 DELETE FROM students WHERE id = ? 语句     * @注意：若存在关联实体，需配置级联删除（如 @OneToMany(cascade = REMOVE)）     */    @Override    @Transactional    public void deleteStudentById(Long id) &#123;        studentRepository.deleteById(id); // 调用 JpaRepository.deleteById()    &#125;    /**     * 按姓名模糊查询（方法名解析查询）     * @param name 姓名关键词（如 &quot;王&quot;）     * @Hibernate 自动生成：SELECT s FROM Student s WHERE s.name LIKE %name%     */    @Override    public List&lt;Student&gt; findStudentsByName(String name) &#123;        return studentRepository.findByNameContaining(name); // 方法名映射为 LIKE 查询    &#125;    /**     * 按年龄范围查询（方法名解析范围查询）     * @param minAge 最小年龄（包含）     * @param maxAge 最大年龄（包含）     * @Hibernate 自动生成：SELECT s FROM Student s WHERE s.age BETWEEN minAge AND maxAge     */    @Override    public List&lt;Student&gt; findStudentsByAgeRange(Integer minAge, Integer maxAge) &#123;        return studentRepository.findByAgeBetween(minAge, maxAge); // BETWEEN 查询    &#125;    /**     * 按邮箱模式查询（JPQL 自定义查询）     * @param email 邮箱关键词（如 &quot;%@qq.com&quot;）     * @Hibernate 执行：@Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)     */    @Override    public List&lt;Student&gt; findStudentsByEmailPattern(String email) &#123;        return studentRepository.findStudentsByEmailPattern(email); // 调用自定义 JPQL 查询    &#125;    /**     * 按年龄阈值查询（原生 SQL 查询）     * @param age 年龄阈值     * @Hibernate 执行：@Query(value = &quot;SELECT * FROM students WHERE age &gt; :age&quot;, nativeQuery = true)     */    @Override    public List&lt;Student&gt; findStudentsOlderThan(Integer age) &#123;        return studentRepository.findStudentsOlderThanAge(age); // 调用原生 SQL 查询    &#125;&#125;\r\n依赖注入与构造函数\r\nprivate final StudentRepository studentRepository; // 注入数据访问层接口@Autowired // 自动装配 StudentRepository 的实现类（由 Spring 管理）public StudentServiceImpl(StudentRepository studentRepository) &#123;    this.studentRepository = studentRepository;&#125;\r\n\r\n与 Hibernate 的关联：\r\nStudentRepository 继承自\r\nJpaRepository，其底层实现由 Spring Data JPA 提供，内部通过\r\nHibernate 的 SessionFactory 创建 Session\r\n操作数据库。\r\n\r\n核心方法\r\n保存学生（新增 / 更新）\r\n\r\nHibernate 实现\r\nreturn studentRepository.save(student); // 调用 JpaRepository.save()\r\n会根据实体是否有 ID 判断操作类型：\r\n\r\n无 ID（瞬时态）：调用 Session.persist(student)，生成\r\nINSERT 语句。\r\n有 ID（脱管态）：调用 Session.merge(student)，生成\r\nUPDATE 语句（仅更新变更字段）。\r\n脏检查（Dirty Checking）：Hibernate\r\n自动对比实体属性与数据库记录，仅生成必要的 SQL。\r\n\r\n\r\n根据 ID 查询学生\r\n/** * 根据 ID 查询学生 * @param id 学生 ID * @return Optional&lt;Student&gt; 包含持久态对象（若存在） * * @Hibernate 操作： * 1. 调用 StudentRepository.findById(id) * 2. 内部通过 Session.get(Student.class, id) 查询，优先使用一级缓存 * @缓存机制： * - 一级缓存（Session 级）：同一事务内多次查询直接从缓存获取 * - 二级缓存（需配置 @Cacheable）：跨事务/请求缓存数据 */@Overridepublic Optional&lt;Student&gt; findStudentById(Long id) &#123;    return studentRepository.findById(id); // 调用 JpaRepository.findById()&#125;\r\n\r\nHibernate 实现\r\n\r\nfindById(id) 内部调用\r\nSession.get()，该方法会立即查询数据库（与\r\nSession.load() 的延迟加载不同）。\r\n若启用二级缓存（如 Ehcache），需在实体类添加\r\n@Cacheable(true)，并配置缓存提供者。\r\n\r\n\r\n查询所有学生\r\nreturn studentRepository.findAll(); // 调用 JpaRepository.findAll()\r\n\r\nHibernate 实现\r\n\r\nfindAll() 生成\r\nSELECT * FROM students（假设表名为\r\nstudents）。\r\n结果集中的对象自动转为持久态，纳入当前 Session\r\n管理。\r\n\r\n\r\n更新学生信息\r\nreturn studentRepository.save(student); // 执行更新\r\n\r\nHibernate 实现\r\n\r\nmerge(student)\r\n会创建新的持久态副本，原脱管态对象不会被修改。\r\n若实体已存在于当前\r\nSession（持久态），merge\r\n会将脱管态对象的属性复制到持久态对象，触发脏检查。\r\n\r\n\r\n删除学生\r\nstudentRepository.deleteById(id); // 调用 JpaRepository.deleteById()\r\n\r\nHibernate 实现\r\n\r\n直接执行 DELETE\r\n语句，若实体有关联对象且未配置级联删除，会抛出外键约束异常。\r\n实体类中通过 @OneToMany(cascade = CascadeType.ALL)\r\n自动处理关联删除。\r\n\r\n\r\n业务查询方法（以姓名模糊查询为例）\r\nreturn studentRepository.findByNameContaining(name); // 调用方法名解析查询\r\n\r\nHibernate 实现\r\n\r\n方法名中的 Containing 对应\r\nLIKE %name%，Hibernate 自动处理参数拼接，防止 SQL\r\n注入。\r\n生成的 JPQL 会通过 Session.createQuery()\r\n执行，结果集对象自动转为持久态。\r\n对 @OneToMany 关联，使用 FetchType.LAZY\r\n延迟加载，避免 SELECT N+1 问题\r\n@OneToMany(mappedBy = &quot;student&quot;, fetch = FetchType.LAZY)\r\n\r\n\r\n事务管理与 Hibernate 集成\r\n@Transactional // 类级别或方法级别声明事务\r\n\r\n作用范围\r\n\r\n类上声明 @Transactional，对所有 public 方法生效（可通过\r\n@Transactional(propagation = ...) 覆盖）。\r\n方法上声明 @Transactional，优先级高于类级别配置。\r\n\r\nHibernate 事务机制\r\n\r\n事务开始时，Hibernate 创建 Session\r\n并绑定到当前线程（ThreadLocal）。\r\n事务中所有 Repository 方法共享同一\r\nSession，确保数据一致性。\r\n事务提交时，Hibernate 执行\r\nSession.flush()，将缓存中的变更同步到数据库。\r\n事务回滚时，Session 清空，所有未提交变更被撤销。\r\n\r\n\r\nController层的编写\r\n创建REST控制器，用于处理HTTP请求：\r\npackage edu.software.ergoutree.springandhibernate.controller;import edu.software.ergoutree.springandhibernate.model.Student;import edu.software.ergoutree.springandhibernate.service.StudentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import java.util.List;/** * 学生控制器 * 提供 RESTful API 接口，处理 HTTP 请求与响应 * * - Spring MVC：处理路由、参数绑定、序列化 * - Hibernate：通过 Service 层间接实现数据持久化 * - REST 规范：使用 HTTP 方法和状态码表示资源操作 */@RestController // 声明为 REST 控制器，返回值自动序列化为 JSON@RequestMapping(&quot;/api/students&quot;) // 基础 URL 路径public class StudentController &#123;    private final StudentService studentService; // 注入服务层    @Autowired // 构造函数注入（推荐方式）    public StudentController(StudentService studentService) &#123;        this.studentService = studentService;    &#125;    /**     * 创建学生资源     * @param student 学生实体（JSON 请求体）     * @return 新创建的学生（含数据库生成的 ID）     * @HTTP 201 Created - 资源创建成功     * @Hibernate 操作：     * 1. Service 层调用 repository.save(student)     * 2. Hibernate 执行 INSERT 语句     * 3. 返回持久态对象（包含生成的 ID）     */    @PostMapping    public ResponseEntity&lt;Student&gt; createStudent(@RequestBody Student student) &#123;        Student savedStudent = studentService.saveStudent(student);        return new ResponseEntity&lt;&gt;(savedStudent, HttpStatus.CREATED);    &#125;    /**     * 获取所有学生列表     * @return 学生列表（JSON 数组）     * @HTTP 200 OK - 请求成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findAll()     * 2. Hibernate 生成 SQL：SELECT * FROM students     * @注意：未分页，可能导致大数据量性能问题     */    @GetMapping    public ResponseEntity&lt;List&lt;Student&gt;&gt; getAllStudents() &#123;        List&lt;Student&gt; students = studentService.findAllStudents();        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 根据 ID 获取单个学生     * @param id 学生 ID     * @return 学生对象（JSON）或 404 Not Found     * @HTTP 200 OK - 资源存在 | 404 Not Found - 资源不存在     * @Hibernate 操作：     * 1. Service 层调用 repository.findById(id)     * 2. Hibernate 通过一级缓存或数据库查询实体     */    @GetMapping(&quot;/&#123;id&#125;&quot;) // 修正：原代码缺少路径变量    public ResponseEntity&lt;Student&gt; getStudentById(@PathVariable Long id) &#123;        return studentService.findStudentById(id)                .map(student -&gt; new ResponseEntity&lt;&gt;(student, HttpStatus.OK))                .orElse(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));    &#125;    /**     * 更新学生信息     * @param id 学生 ID（路径参数）     * @param student 学生实体（JSON 请求体，需包含 ID）     * @return 更新后的学生或 404 Not Found     * @HTTP 200 OK - 更新成功 | 404 Not Found - 学生不存在     * @Hibernate 操作：     * 1. Service 层验证学生存在性     * 2. 调用 repository.save(student) 触发 Hibernate 的 merge()     * 3. 基于脏检查生成 UPDATE 语句     */    @PutMapping(&quot;/&#123;id&#125;&quot;) // 修正：原代码路径格式错误（//&#123;id&#125;）    public ResponseEntity&lt;Student&gt; updateStudent(@PathVariable(&quot;id&quot;) Long id, @RequestBody Student student) &#123;        try &#123;            student.setId(id); // 确保路径 ID 与请求体 ID 一致            Student updatedStudent = studentService.updateStudent(student);            return new ResponseEntity&lt;&gt;(updatedStudent, HttpStatus.OK);        &#125; catch (IllegalArgumentException e) &#123;            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;    &#125;    /**     * 删除学生资源     * @param id 学生 ID     * @return 204 No Content - 删除成功（无返回体）     * @HTTP 204 No Content - 删除成功 | 500 Internal Server Error - 删除失败     * @Hibernate 操作：     * 1. Service 层调用 repository.deleteById(id)     * 2. Hibernate 执行 DELETE 语句     * @注意：若 ID 不存在，Hibernate 抛出 EmptyResultDataAccessException（Spring 自动处理为 500）     */    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Void&gt; deleteStudent(@PathVariable(&quot;id&quot;) Long id) &#123;        studentService.deleteStudentById(id);        return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);    &#125;    /**     * 根据姓名模糊查询学生     * @param name 姓名关键词（如 &quot;张&quot;）     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findByNameContaining(name)     * 2. Hibernate 生成 JPQL：SELECT s FROM Student s WHERE s.name LIKE %:name%     */    @GetMapping(&quot;/search/name&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByName(@RequestParam String name) &#123;        List&lt;Student&gt; students = studentService.findStudentsByName(name);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 根据年龄范围查询学生     * @param minage 最小年龄（包含）     * @param maxage 最大年龄（包含）     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findByAgeBetween(minage, maxage)     * 2. Hibernate 生成 JPQL：SELECT s FROM Student s WHERE s.age BETWEEN :minage AND :maxage     */    @GetMapping(&quot;/search/age&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByAge(@RequestParam Integer minage, @RequestParam Integer maxage) &#123;        List&lt;Student&gt; students = studentService.findStudentsByAgeRange(minage, maxage);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 根据邮箱模式查询学生     * @param pattern 邮箱关键词（如 &quot;%@gmail.com&quot;）     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findStudentsByEmailPattern(pattern)     * 2. Hibernate 执行自定义 JPQL：SELECT s FROM Student s WHERE s.email LIKE %:email%     */    @GetMapping(&quot;/search/email&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByEmailPattern(@RequestParam String pattern) &#123;        List&lt;Student&gt; students = studentService.findStudentsByEmailPattern(pattern);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;    /**     * 查询年龄大于指定值的学生     * @param age 年龄阈值     * @return 匹配的学生列表     * @HTTP 200 OK - 查询成功     * @Hibernate 操作：     * 1. Service 层调用 repository.findStudentsOlderThanAge(age)     * 2. Hibernate 执行原生 SQL：SELECT * FROM students WHERE age &gt; :age     */    @GetMapping(&quot;/search/older-than&quot;)    public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsOlderThan(@RequestParam Integer age) &#123;        List&lt;Student&gt; students = studentService.findStudentsOlderThan(age);        return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);    &#125;&#125;\r\n在控制器上使用@RestController注解，表示这是一个Spring组件，并且用于处理HTTP请求。\r\n控制器整体架构与 REST\r\n设计\r\n/** * 学生控制器 * 提供 RESTful API 接口，处理 HTTP 请求与响应 * 架构层次： * 1. 接收客户端请求（HTTP 协议） * 2. 调用 Service 层处理业务逻辑 * 3. 返回标准化 JSON 响应（含 HTTP 状态码） * Hibernate 集成点： * - 通过 Service 层间接使用 Hibernate 持久化能力 * - 处理 Hibernate 可能抛出的异常（如 EntityNotFoundException） */@RestController // 声明为 REST 控制器，自动将返回值序列化为 JSON@RequestMapping(&quot;/api/students&quot;) // 基础路径public class StudentController &#123;\r\n\r\nREST 规范：\r\n\r\n使用 HTTP\r\n方法映射操作：POST（创建）、GET（查询）、PUT（更新）、DELETE（删除）。\r\n路径设计遵循资源导向：/api/students/&#123;id&#125;\r\n表示学生资源。\r\n返回标准 HTTP 状态码（如\r\n201 Created、404 Not Found）\r\n\r\n\r\n依赖注入与服务层调用\r\nprivate final StudentService studentService;@Autowiredpublic StudentController(StudentService studentService) &#123;    this.studentService = studentService;&#125;\r\n\r\nHibernate 操作 ： StudentService\r\n内部通过 StudentRepository 调用 Hibernate 的\r\nSession 方法，实现数据库操作。\r\n设计模式：\r\n依赖注入（DI）遵循单一职责原则，控制器专注于请求处理，业务逻辑委托给\r\nService 层。\r\n\r\n核心方法注释与 Hibernate\r\n集成**\r\n创建学生（POST）\r\n/** * 创建学生资源 * @param student 学生实体（JSON 格式请求体） * @return 新创建的学生（含数据库生成的 ID） * @HTTP 201 Created - 资源创建成功 * @Hibernate 操作： * 1. Service 层调用 repository.save(student) * 2. Hibernate 执行 INSERT 语句，生成自增 ID * 3. 返回持久态对象（包含数据库生成的 ID） */@PostMappingpublic ResponseEntity&lt;Student&gt; createStudent(@RequestBody Student student) &#123;    Student savedStudent = studentService.saveStudent(student);    return new ResponseEntity&lt;&gt;(savedStudent, HttpStatus.CREATED);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n实体对象通过 @RequestBody 从 JSON\r\n反序列化，初始为瞬时态（Transient）。\r\nrepository.save(student)\r\n将其转换为持久态（Persistent），触发 Hibernate 的\r\nINSERT 操作。\r\n返回的 savedStudent 包含数据库生成的\r\nID（如自增主键）。\r\n\r\n\r\n查询所有学生（GET）\r\n/** * 获取所有学生列表 * @return 学生列表（JSON 数组） * @HTTP 200 OK - 请求成功 * @Hibernate 操作： * 1. Service 层调用 repository.findAll() * 2. Hibernate 生成 SQL：SELECT * FROM students * 3. 结果集映射为持久态对象列表 * @注意： * - 未分页，可能导致内存溢出（生产环境建议添加分页） */@GetMappingpublic ResponseEntity&lt;List&lt;Student&gt;&gt; getAllStudents() &#123;    List&lt;Student&gt; students = studentService.findAllStudents();    return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n返回的 students\r\n列表中每个对象均为持久态，处于 Hibernate 的\r\nSession 管理下。\r\n若实体存在懒加载关联（如 @OneToMany(fetch = LAZY)），在\r\nSession 关闭后访问会触发\r\nLazyInitializationException。\r\n\r\n\r\n更新学生（PUT）\r\n/** * 更新学生信息 * @param id 学生 ID（路径参数） * @param student 学生实体（JSON 请求体，需包含 ID） * @return 更新后的学生或 404 Not Found * @HTTP 200 OK - 更新成功 | 404 Not Found - 学生不存在 * @Hibernate 操作： * 1. Service 层验证学生存在性 * 2. 调用 repository.save(student) 触发 Hibernate 的 merge() * 3. Hibernate 执行 UPDATE 语句（基于脏检查） */@PutMapping(&quot;/&#123;id&#125;&quot;) // 修正：原代码路径格式错误（//&#123;id&#125;）public ResponseEntity&lt;Student&gt; updateStudent(@PathVariable(&quot;id&quot;) Long id, @RequestBody Student student) &#123;    try &#123;        student.setId(id); // 确保 ID 一致        Student updatedStudent = studentService.updateStudent(student);        return new ResponseEntity&lt;&gt;(updatedStudent, HttpStatus.OK);    &#125; catch (IllegalArgumentException e) &#123;        return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);    &#125;&#125;\r\n\r\nHibernate 集成体现：\r\n\r\n传入的 student\r\n是脱管态（Detached）对象（已存在但不在当前\r\nSession 中）。\r\nrepository.save(student) 调用 Hibernate 的\r\nSession.merge()，将脱管态对象合并到当前\r\nSession，生成 UPDATE 语句。\r\n脏检查机制：Hibernate 仅更新实际变更的字段（通过\r\n@DynamicUpdate 可进一步优化）。\r\n\r\n\r\n删除学生（Delete）\r\n/** * 删除学生资源 * @param id 学生 ID * @return 204 No Content - 删除成功（无返回体） * @HTTP 204 No Content - 删除成功 | 500 Internal Server Error - 删除失败 * @Hibernate 操作： * 1. Service 层调用 repository.deleteById(id) * 2. Hibernate 执行 DELETE FROM students WHERE id = ? * @注意： * - 若 ID 不存在，Hibernate 抛出 EmptyResultDataAccessException（Spring 自动处理为 500） * - 建议在 Service 层添加 existsById() 校验，返回 404 */@DeleteMapping(&quot;/&#123;id&#125;&quot;)public ResponseEntity&lt;Void&gt; deleteStudent(@PathVariable(&quot;id&quot;) Long id) &#123;    studentService.deleteStudentById(id);    return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n直接执行 DELETE 语句，无需先查询实体。\r\n若存在关联实体（如 Student 关联\r\nCourse），需确保配置了级联删除（如\r\n@OneToMany(cascade = CascadeType.REMOVE)），否则会触发外键约束异常。\r\n\r\n\r\n业务查询方法（以姓名模糊查询为例）\r\n/** * 根据姓名模糊查询学生 * @param name 姓名关键词（如 &quot;张&quot;） * @return 匹配的学生列表 * @HTTP 200 OK - 查询成功 * @Hibernate 操作： * 1. Service 层调用 repository.findByNameContaining(name) * 2. Hibernate 解析方法名生成 JPQL：SELECT s FROM Student s WHERE s.name LIKE %:name% */@GetMapping(&quot;/search/name&quot;)public ResponseEntity&lt;List&lt;Student&gt;&gt; getStudentsByName(@RequestParam String name) &#123;    List&lt;Student&gt; students = studentService.findStudentsByName(name);    return new ResponseEntity&lt;&gt;(students, HttpStatus.OK);&#125;\r\n\r\nHibernate 集成体现：\r\n\r\n方法名中的 Containing 自动映射为\r\nLIKE %name% 查询，由 Hibernate 动态生成 SQL。\r\n返回的 students\r\n列表为持久态，若包含懒加载关联，需确保在事务内访问。\r\n\r\n\r\n异常处理\r\n显式异常处理（如更新不存在的学生）\r\ntry &#123;    student.setId(id);    Student updatedStudent = studentService.updateStudent(student);    return new ResponseEntity&lt;&gt;(updatedStudent, HttpStatus.OK);&#125; catch (IllegalArgumentException e) &#123;    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#125;\r\n\r\nHibernate 集成体现\r\n\r\n当 studentService.updateStudent()\r\n发现学生不存在时，抛出\r\nIllegalArgumentException，控制器捕获后返回\r\n404 Not Found。\r\n避免将 Hibernate 底层异常（如\r\nEntityNotFoundException）直接暴露给客户端。\r\n\r\n\r\nSpring 自动异常处理\r\n\r\n默认行为\r\n\r\n若删除不存在的学生，Hibernate 抛出\r\nEmptyResultDataAccessException，Spring 自动返回\r\n500 Internal Server Error。\r\n\r\n优化： 在 Service\r\n层添加存在性检查，并抛出业务异常（如\r\nStudentNotFoundException），由全局异常处理器统一返回\r\n404：\r\n\r\n@ExceptionHandler(StudentNotFoundException.class)public ResponseEntity&lt;Void&gt; handleNotFoundException() &#123;    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#125;\r\n启动应用\r\n启动Spring Boot应用后，Spring Data\r\nJPA会自动配置Hibernate，并根据实体类的定义生成表结构（取决于spring.jpa.hibernate.ddl-auto的值）。\r\npackage edu.software.ergoutree.springandhibernate;import edu.software.ergoutree.springandhibernate.entity.Student;import edu.software.ergoutree.springandhibernate.repository.StudentRepository;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;/** * Spring Boot 应用程序入口类 *  * @SpringBootApplication 注解是一个组合注解，它包含了： * - @Configuration: 标记该类为配置类 * - @EnableAutoConfiguration: 启用Spring Boot的自动配置机制 * - @ComponentScan: 启用组件扫描，自动发现和注册Bean */@SpringBootApplicationpublic class SpringAndHibernateApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringAndHibernateApplication.class, args);    &#125;        /**     * 应用启动后初始化一些测试数据     * CommandLineRunner 是Spring Boot提供的一个接口，用于在应用启动后执行一些初始化操作     */    @Bean    public CommandLineRunner initData(StudentRepository studentRepository) &#123;        return args -&gt; &#123;            // 检查数据库中是否已有数据            if (studentRepository.count() == 0) &#123;                System.out.println(&quot;初始化学生数据...&quot;);                                // 创建并保存几个学生实体                studentRepository.save(new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20));                studentRepository.save(new Student(&quot;李四&quot;, &quot;lisi@example.com&quot;, 22));                studentRepository.save(new Student(&quot;王五&quot;, &quot;wangwu@example.com&quot;, 21));                studentRepository.save(new Student(&quot;赵六&quot;, &quot;zhaoliu@example.com&quot;, 23));                                System.out.println(&quot;数据初始化完成！&quot;);            &#125; else &#123;                System.out.println(&quot;数据库中已有数据，跳过初始化步骤。&quot;);            &#125;                        // 显示所有学生信息            System.out.println(&quot;学生列表：&quot;);            studentRepository.findAll().forEach(student -&gt;                 System.out.println(student.getId() + &quot;: &quot; + student.getName() + &quot;, &quot; +                                    student.getEmail() + &quot;, &quot; + student.getAge() + &quot;岁&quot;));        &#125;;    &#125;&#125;\r\n总结这个项目的集成\r\nHibernate 的要点\r\nSpring Boot 通过 Spring Data JPA 自动集成了\r\nHibernate，这种集成方式非常优雅且简化了大量配置工作。\r\n依赖关系\r\n在pom.xml中，我们添加了以下关键依赖：\r\n\r\n```xml spring-boot-starter-data-jpa   这个启动器包含了 Spring Data JPA 和 Hibernate 核心依赖- ```xml  mysql-connector-j\r\nMySQL 数据库驱动\r\n```xml spring-boot-starter-web   Web 应用支持**自动配置机制**Spring Boot 的核心优势在于其自动配置机制。通过 `@SpringBootApplication`注解，它会：- 自动配置 Hibernate 的 `SessionFactory`- 自动配置事务管理器- 自动配置数据源- 自动扫描实体类并映射到数据库表**配置文件**在 `application.properties`中，我们配置了：```propertiespropertiesCopyInsert# 数据库连接配置spring.datasource.url=jdbc:mysql://localhost:3306/hibernate_demo?createDatabaseIfNotExist=true&amp;useSSL=false&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root# Hibernate配置spring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.jpa.properties.hibernate.format_sql=truespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\r\n\r\n这些配置告诉 Spring Boot：\r\n\r\n使用 MySQL 数据库\r\n自动创建/更新表结构 ddl-auto=update\r\n显示 SQL 语句以便调试\r\n使用 MySQL 方言\r\n\r\n实体类映射\r\n我们使用 JPA 注解来定义实体类与数据库表的映射关系：\r\njavaCopyInsert@Entity@Table(name = &quot;students&quot;)public class Student &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;name&quot;, nullable = false, length = 100)    private String name;        // 其他字段...&#125;\r\n这些注解是 JPA 规范的一部分，Hibernate 作为 JPA\r\n的实现，会解析这些注解并将实体类映射到数据库表。\r\nRepository 层\r\nSpring Data JPA 提供了强大的 Repository\r\n接口，大大简化了数据访问层的开发：\r\njavaCopyInsert@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;    // 方法名约定查询    List&lt;Student&gt; findByNameContaining(String name);        // JPQL 查询    @Query(&quot;SELECT s FROM Student s WHERE s.email LIKE %:email%&quot;)    List&lt;Student&gt; findStudentsByEmailPattern(@Param(&quot;email&quot;) String email);        // 原生 SQL 查询    @Query(value = &quot;SELECT * FROM students WHERE age &gt; :age&quot;, nativeQuery = true)    List&lt;Student&gt; findStudentsOlderThanAge(@Param(&quot;age&quot;) Integer age);&#125;\r\n这里展示了三种查询方式：\r\n\r\n方法名约定查询：通过方法名自动生成查询语句\r\nJPQL 查询：使用面向对象的查询语言\r\n原生 SQL 查询：直接使用 SQL 语句\r\n\r\n事务管理\r\nSpring Boot 自动配置了事务管理器，我们只需使用\r\n@Transactional注解即可：\r\njavaCopyInsert@Servicepublic class StudentServiceImpl implements StudentService &#123;    @Override    @Transactional    public Student saveStudent(Student student) &#123;        return studentRepository.save(student);    &#125;        // 其他方法...&#125;\r\n数据初始化\r\n在启动类中，我们使用\r\nCommandLineRunner来初始化测试数据：\r\njavaCopyInsert@Beanpublic CommandLineRunner initData(StudentRepository studentRepository) &#123;    return args -&gt; &#123;        if (studentRepository.count() == 0) &#123;            // 创建并保存几个学生实体            studentRepository.save(new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20));            // 更多学生...        &#125;    &#125;;&#125;\r\nSpring Boot 与 Hibernate 的集成主要通过 Spring Data JPA\r\n实现，具有以下优势：\r\n\r\n简化配置：无需编写大量 XML 配置文件\r\n约定优于配置：遵循默认约定，减少配置量\r\n自动化：自动创建表结构、自动生成查询语句\r\n类型安全：编译时类型检查，减少运行时错误\r\n声明式事务：使用注解简化事务管理\r\n多种查询方式：支持方法名约定、JPQL 和原生 SQL\r\n\r\n这种集成方式大大提高了开发效率，让开发者可以专注于业务逻辑而非底层数据访问细节。\r\n要运行此应用程序，只需确保 MySQL 服务已启动，然后运行 Spring Boot\r\n应用程序即可。应用启动后，将自动创建数据库表并初始化测试数据。\r\n","categories":["Java学习","Spring系列","Spring Boot"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识","Spring Data JPA","JavaEE","Spring系列","Spring Boot","Java框架"]},{"title":"Spring Framework part3-IoC基于XML管理Bean下篇","url":"/posts/55768.html","content":"接着上篇进行\r\n\r\np 命名空间\r\n引入 p 命名空间\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util       http://www.springframework.org/schema/util/spring-util.xsd       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\r\n引入p命名空间后，可以通过以下方式为bean的各个属性赋值\r\n&lt;!-- p命名空间方式 --&gt;    &lt;bean id=&quot;student1&quot; class=&quot;com.ergoutree.di.Student&quot;          p:stu_id=&quot;1411&quot; p:name=&quot;李四&quot; p:listLessons-ref=&quot;lesson1&quot; p:mapTeachers-ref=&quot;mapTeachers&quot;&gt;    &lt;/bean&gt;\r\n测试后依旧成立\r\n\r\n引入外部属性文件\r\n在Spring框架中，引入外部属性文件是一种管理应用程序配置的有效方法。当我们在Spring的\r\nXML\r\n配置文件中直接编写大量的固定配置信息（如数据库用户名、密码、URL，或是服务器IP地址、端口号等），这些信息如果频繁变动，将会使得配置文件变得难以维护，而且每当配置信息发生变化时，开发人员就需要打开源代码去修改XML配置文件，然后再重新打包部署项目，这是一个繁琐的过程。\r\n为了解决这个问题，Spring\r\n支持将这些容易变化的配置项提取出来，存放在单独的 properties\r\n文件中，如database.properties 或 application.properties\r\n。这些文件通常包含键值对的形式，例如\r\ndatabase.properties文件\r\ndb.username=admindb.password=secretpassworddb.url=jdbc:mysql://localhost:3306/mydatabase\r\n接下来，在Spring的XML配置文件中，我们可以使用PropertyPlaceholderConfigurer（在较旧版本中）或&lt;context:property-placeholder&gt;（在Spring\r\n3.1及以上版本推荐使用）来引入和解析这些外部属性文件：\r\n&lt;!-- Spring 3.1+ 使用context命名空间简化引入 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;...&quot;&gt;          &lt;!-- 引入外部属性文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;    &lt;!-- 使用外部属性文件中的值注入Bean --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;       &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;       &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;\r\n这样一来，当数据库的连接信息需要变更时，我们只需要修改database.properties文件，而不需要碰触到Spring的XML配置文件或Java代码。这样既实现了配置的模块化，又增强了配置的可维护性，同时降低了因配置变更导致的应用程序整体重新部署的频率。\r\n此外，这种模式还可以方便地根据不同的环境（如开发、测试、生产）切换不同的配置文件，实现灵活部署。\r\n\r\nbean作用域/生命周期\r\n作用域\r\n在Spring框架中，Bean（Java对象）的作用域指的是在应用程序的整个生命周期中，对于某个特定的Bean对象，Spring容器是如何管理和创建其实例的。Bean\r\n的作用域决定了容器在何时以及如何创建Bean实例，以及这些实例之间的关系。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n取值\r\n含义\r\n创建对象\r\n\r\n\r\n\r\n\r\nsingleton（默认）单实例\r\n在IOC容器中，这个bean的对象始终为单实例\r\nIOC容器初始化时\r\n\r\n\r\nprototype 多实例\r\n这个bean在IOC容器中有多个实例\r\n获取bean时\r\n\r\n\r\n\r\n如果实在 WebApplicationContext 环境下还有几个作用域\r\n\r\n\r\n\r\n取值\r\n含义\r\n\r\n\r\n\r\n\r\nrequest\r\n在一个请求范围内有效\r\n\r\n\r\nsession\r\n在一个会话范围内有效\r\n\r\n\r\n\r\nsingleton 作用域：\r\n\r\n含义：当指定一个Bean为singleton时，Spring容器会在启动时创建该Bean的一个实例，并在整个容器的生命周期内，任何对该Bean的请求都将返回同一个共享的实例。这意味着不论有多少个地方请求该Bean，始终只会有一个Bean实例存在。\r\n创建对象的时机：\r\nSpring容器在初始化时（加载配置文件并创建Bean的过程中），就会创建singleton作用域的Bean实例。\r\n\r\nprototype 作用域：\r\n\r\n含义：\r\n当指定一个Bean为prototype时，每次客户端请求一个Bean时，Spring容器都会创建一个新的Bean实例，也就是说，每次getBean()方法被调用时都会产生一个新的对象实例。\r\n创建对象的时机：\r\nprototype作用域的Bean实例是在客户端请求时创建的，即每次调用ApplicationContext.getBean()方法请求一个prototype类型的Bean时，Spring容器才会创建新的实例。\r\n\r\n示例：\r\n新建 Order 类\r\npublic class Order &#123;&#125;\r\n新建 bean-scope.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--单实例对象演示 通过 scope 属性配置单实例还是多实例--&gt;    &lt;bean id=&quot;order&quot; class=&quot;com.ergoutree.scope.Order&quot; scope=&quot;singleton&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n新建 TestOrder\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestOrder &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-scope.xml&quot;);        // 单实例对象，输出地址相同        Order order = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order);        Order order2 = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order2);    &#125;&#125;\r\n可以发现输出地址是一样的，单实例对象\r\n然而带上多实例对象，发现并非是一个实例化的对象\r\npublic class TestOrder &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-scope.xml&quot;);        // 单实例对象，输出地址相同        Order order = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order);        Order order2 = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order2);        // 多实例对象        Order order3 = context.getBean(&quot;order2&quot;, Order.class);        System.out.println(order3);        Order order4 = context.getBean(&quot;order2&quot;, Order.class);        System.out.println(order4);    &#125;&#125;\r\n输出结果\r\ncom.ergoutree.scope.Order@7b8b43c7com.ergoutree.scope.Order@7b8b43c7com.ergoutree.scope.Order@44c73c26com.ergoutree.scope.Order@41005828\r\n\r\n生命周期\r\n关于Bean的生命周期：\r\n除了Bean的作用域之外，Bean还有一个完整的生命周期，它包括以下几个阶段：\r\n\r\n实例化（Instantiation）：\r\n\r\n这是Bean生命周期的起点，类似于开始备料，即调用Bean的无参构造函数创建Bean实例。Spring容器通过反射机制找到合适的构造函数并创建Bean对象。\r\n\r\n依赖注入（Dependency Injection，DI）：\r\n\r\n类似于加入必要的调料，Spring容器根据配置信息，通过setter方法、构造函数注入或其他注解方式（如@Autowired）将Bean依赖的其他对象注入到当前Bean中。\r\n\r\nBean的后置处理器（Post Processor Before Initialization）：\r\n\r\n在Bean初始化之前，Spring容器会对Bean进行一系列额外的处理。例如，Spring的BeanPostProcessor接口提供了两个方法postProcessBeforeInitialization()和postProcessAfterInitialization()，在这一步骤中，Spring会调用postProcessBeforeInitialization()方法对Bean进行自定义的预处理。\r\n\r\n初始化（Initialization）：\r\n\r\n此阶段相当于烹饪前的准备工作，如预热烤箱。Spring容器在完成所有依赖注入后，会检查Bean是否实现了InitializingBean接口，若实现了则调用afterPropertiesSet()方法；或者在配置文件中通过init-method属性指定了初始化方法，此时Spring容器会调用该方法对Bean进行初始化。\r\n\r\nBean的后置处理器（Post Processor After Initialization）：\r\n\r\n初始化完成后，Spring容器会调用postProcessAfterInitialization()方法进一步处理Bean。这一阶段可用于在Bean正式投入使用前进行一些补充性的定制化工作。\r\n\r\n使用（Use）：\r\n\r\n到了这个阶段，Bean就如同完成烹饪的菜肴一样，已经准备好供客户（应用程序）使用。通过Spring容器的getBean()方法，可以在应用程序中任意位置获取并使用这个Bean实例。\r\n\r\n销毁（Destruction）：\r\n\r\n当Bean不再需要时，比如应用程序关闭或容器被销毁时，Spring容器会触发Bean的销毁过程。如果Bean实现了DisposableBean接口，则调用destroy()方法；或者在配置文件中通过destroy-method属性指定了销毁方法，Spring容器会调用该方法释放资源，如关闭数据库连接、清除缓存等，这就好比客人用餐结束后清理餐具、打扫卫生。\r\n\r\nIOC容器关闭：\r\n\r\n当整个IoC容器需要关闭时，所有处于singleton作用域的Bean都会经历销毁阶段，以确保相关资源得到妥善释放，整个容器生命周期结束。\r\n\r\n\r\n总的来说，在Spring框架中，Bean的作用域是指Bean实例的创建策略，而生命周期则是指Bean实例从创建到销毁的过程。通过理解并合理配置Bean的作用域和生命周期，可以更好地管理和控制Bean实例的行为，提高应用效率和资源利用率。\r\n示例：\r\n创建 Applyskd 类\r\npublic class Applyskd &#123;    private String name;    //初始化方法    public void init() &#123;        System.out.println(&quot;生命周期：3、初始化~&quot;);    &#125;    //销毁方法    public void destroy() &#123;        System.out.println(&quot;生命周期：5、销毁~&quot;);    &#125;    public Applyskd() &#123;        System.out.println(&quot;生命周期：1、创建对象~&quot;);    &#125;    public Applyskd(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;生命周期：2、依赖注入~&quot;);        this.name = name;    &#125;    public String toString() &#123;        return &quot;User&#123;name = &quot; + name + &quot;&#125;&quot;;    &#125;&#125;\r\n创建 xml 配置文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个名为&quot;user&quot;的Bean，对应于com.ergoutree.liferoutine.Applyskd类 --&gt;    &lt;!-- 该Bean的生命周期由Spring容器管理 --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.ergoutree.liferoutine.Applyskd&quot;          scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;sakura&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 注解解释：    id属性：为Bean定义一个唯一标识符；    class属性：指定Bean的实现类；    scope属性：定义Bean的作用域，此处为&quot;singleton&quot;，表示该Bean在容器中只存在一个实例；    init-method属性：指定Bean初始化时要执行的方法，此处为&quot;init&quot;；    destroy-method属性：指定Bean销毁时要执行的方法，此处为&quot;destroy&quot;。 --&gt;&lt;/beans&gt;\r\n测试结果\r\npublic class Test &#123;    @org.junit.jupiter.api.Test    public void test() &#123;        //想要实现bean生命周期的销毁，需要使用ClassPathXmlApplicationContext        //而不是用ApplicationContext，它里面没有destroy方法        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-lifeRoutine.xml&quot;);        Applyskd bean = context.getBean(Applyskd.class);        System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用~&quot;);        bean.destroy();    &#125;&#125;/*生命周期：1、创建对象~生命周期：2、依赖注入~生命周期：3、初始化~生命周期：4、通过IOC容器获取bean并使用~生命周期：5、销毁~*/\r\n\r\n基于 xml 自动装配\r\n自动装配：\r\n\r\n根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值\r\n\r\nSpring 自动装配：\r\n\r\n它能在背后悄悄帮你处理Bean之间的关联关系。当你定义了一些Bean，并告诉Spring使用自动装配时，Spring会在创建这些Bean时，自动找出并填充它们所需要的依赖对象。\r\n打个比方，假设你在装修房子，有电工、木工和油漆工三个工种。如果没有自动装配，你需要亲自安排电工去做电线安装，木工去做家具组装，油漆工去做刷漆工作。而有了自动装配功能，你只需要告诉Spring哪个房间需要装修，Spring会根据每个工人的技能（电工擅长电，木工擅长木工活，油漆工擅长刷漆）自动分配任务，不需要你一一指定谁去做什么。\r\n在Spring中，不同的自动装配策略相当于不同的分工规则，比如按名字找合适的工人（byName）、按工种找合适的工人（byType）等。这样，你就可以更加专注于整体的设计和规划，而无需过于关注每个细小环节的具体实施。\r\n\r\n主要有如下几种自动装配的策略：\r\n\r\nbyName\r\n\r\nSpring容器会根据Bean的属性名查找IoC容器中ID（或name）与该属性名相同的Bean进行注入。\r\nSpring会看你的Bean缺少什么“工具”，然后去查找名字一样的工具。\r\n\r\nbyType:\r\n\r\nSpring容器会查找IoC容器中类型与待注入属性类型匹配的Bean进行注入。如果有多个类型匹配的Bean，则会抛出异常，除非其中一个被标记为主Bean。\r\nSpring会根据你的Bean需要的工具类型，去找仓库里拥有同样类型的工具。\r\n\r\nconstructor\r\n\r\n类似于byType，但专门针对构造函数参数，根据构造函数参数类型查找并注入Bean。\r\n当你创建Bean时，Spring会检查构造函数需要哪些工具，然后自动提供正确的工具。\r\n\r\ndefault / no\r\n\r\n这是默认策略，表示不进行自动装配，所有依赖都需要显式配置。\r\n如果关闭自动装配，那就得你自己一个个地把工具交给Bean。\r\n\r\n\r\n通过启用自动装配功能，Spring可以帮助开发者减少大量手动配置依赖注入的工作，提高开发效率，同时保持代码结构清晰。不过，过度依赖自动装配可能会导致问题不易排查，因此在实际项目中应合理权衡是否使用自动装配以及选择哪种装配策略。\r\n总之，自动装配就是Spring帮你自动完成对象间的依赖关系建立，让你编写代码时更轻松，不过要注意避免因自动装配带来的不确定性，适当地结合显式配置更为稳健。\r\n代码示例：\r\n做一个UserController、UserService、UserDao三层之间的实际场景模拟\r\n创建UserController\r\npublic class UserController &#123;    //生成service层对象    private UserService userService;    //设置service属性set方法    public void setUserService(UserService userService)    &#123;        this.userService = userService;    &#125;    public void conMethod()&#123;        //调用service层方法        userService.setMethod();        System.out.println(&quot;UserController方法执行了~&quot;);    &#125;&#125;\r\n创建 UserDao 接口 和 UserDaoImpl 实现类\r\npublic interface UserDao &#123;    public void method();&#125;\r\npublic class UserDaoImpl implements UserDao &#123;    @Override    public void method() &#123;        System.out.println(&quot;UserDao方法执行了~&quot;);    &#125;&#125;\r\n创建UserService 接口 和 UserServiceImpl 实现类\r\npublic interface UserService &#123;    public void setMethod();&#125;\r\npublic class UserServiceImpl implements UserService &#123;    //生成dao层对象    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void setMethod() &#123;        //调用dao层方法        userDao.method();        System.out.println(&quot;UserService方法执行了~&quot;);    &#125;&#125;\r\n上面的都还是准备工作，现在就实现真正的自动装配\r\n使用bean标签的autowire属性设置自动装配效果\r\n根据类型进行自动装配–byType\r\n若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null\r\n若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常\r\nNoUniqueBeanDefinitionException\r\n配置spring bean xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;controller&quot; class=&quot;com.ergoutree.user.UserController&quot; autowire=&quot;byType&quot;&gt;    &lt;/bean&gt;    &lt;bean id=&quot;service&quot; class=&quot;com.ergoutree.user.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;            &lt;/bean&gt;    &lt;bean id=&quot;dao&quot; class=&quot;com.ergoutree.user.UserDaoImpl&quot; autowire=&quot;byType&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n根据属性名进行自动装配–byName\r\n配置spring bean\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;controller&quot; class=&quot;com.ergoutree.user.UserController&quot; autowire=&quot;byName&quot;&gt;    &lt;/bean&gt;    &lt;bean id=&quot;service&quot; class=&quot;com.ergoutree.user.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;            &lt;/bean&gt;    &lt;bean id=&quot;dao&quot; class=&quot;com.ergoutree.user.UserDaoImpl&quot; autowire=&quot;byName&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试结果\r\nclass autoTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-user.xml&quot;);        UserController controller = (UserController) context.getBean(&quot;controller&quot;);        controller.conMethod();    &#125;&#125;\r\n\r\n\r\nimage-20250422160019960\r\n\r\n\r\n\r\nimage-20250422160019960\r\n\r\nApplicationContext\r\n我们从创建Spring容器的代码：\r\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-user.xml&quot;);\r\n可以看到，Spring容器就是ApplicationContext，它是一个接口，有很多实现类，这里我们选择ClassPathXmlApplicationContext，表示它会自动从classpath中查找指定的XML配置文件。\r\n获得了ApplicationContext的实例，就获得了IoC容器的引用。从ApplicationContext中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：\r\nUserService userService = context.getBean(UserService.class);\r\nSpring还提供另一种IoC容器叫BeanFactory，使用方式和ApplicationContext类似\r\nBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));MailService mailService = factory.getBean(MailService.class);\r\nBeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework Part3-IoC基于XML管理Bean上篇","url":"/posts/17876.html","content":"基于XML管理bean\r\n搭建基本环境\r\n在这之前，建议在父工程中的pom文件里导入我们需要的依赖，这样其里面的子工程会自动添加，会方便许多\r\n父工程(Spring6)的pom.xml文件，导入相关依赖\r\n&lt;!-- 依赖关系定义 --&gt;    &lt;dependencies&gt;                &lt;!--log4j2的依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.19.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;            &lt;version&gt;2.19.0&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 引入Spring Context依赖，它是Spring框架的基础模块，提供了环境配置、Bean生命周期管理、事件传播等功能 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;6.0.2&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 引入JUnit5测试框架，用于编写和运行单元测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;            &lt;version&gt;5.3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\r\n设置成功刷新后，Maven里应该是这样子的\r\n\r\n\r\nimage-20250419201336427\r\n\r\n搭建子模块spring6-ioc-xml\r\n在Spring6父工程中创建子模块，在子模块中的resources文件夹下创建配置文件–bean.xml\r\n创建相关的User类，以便后续测试使用，注意有分包的好习惯\r\npackage com.sakurapaid.spring.iocxml; public class User &#123;    private String name;    private int age;     public void test() &#123;        System.out.println(&quot;这是一个test测试输出~(￣▽￣)／&quot;);    &#125;&#125;\r\n获取bean实例\r\n首先在bean.xml配置文件中进行配置\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean id=&quot;user&quot; class=&quot;com.sakurapaid.spring.iocxml.User&quot;&gt;        &lt;/bean&gt;&lt;/beans&gt;\r\n在Spring的XML配置文件中，&lt;bean&gt;元素用于定义一个Bean实例。id\r\n属性为 Bean 定义一个唯一标识符，可以通过这个标识符在其他地方引用这个\r\nBean 。class 属性指定了创建 Bean 实例时使用的类，它告诉 Spring\r\n容器要实例化哪个类。\r\n例如，在示例中，&lt;bean id=\"user\" class=\"com.sakurapaid.spring.iocxml.User\"&gt;表示Spring将实例化一个com.sakurapaid.spring.iocxml.User类的\r\nBean，并将其标识符设置为”user”。（这样就省去了自己手动创建实例化对象相关的操作）\r\n其中与XML\r\nSchema相关的部分格式是固定的，我们只关注&lt;bean&gt;的配置\r\n\r\n每个`都有一个id`标识，相当于Bean的唯一ID；\r\n在userServiceBean中，通过``注入了另一个Bean；\r\nBean的顺序不重要，Spring根据依赖关系会自动正确初始化。\r\n\r\n只不过Spring容器是通过读取XML文件后使用反射完成的。\r\n如果注入的不是Bean，而是boolean、int、String这样的数据类型，则通过value注入，例如，创建一个HikariDataSource：\r\n&lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt;    &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt;    &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;\r\n再创建一个相关的测试类UserTest.Java\r\npackage com.sakurapaid.spring.iocxml; public class UserTest &#123;    public static void main(String[] args) &#123;     &#125;&#125;\r\n根据id获取\r\n// 方式一：根据Bean的id获取实例User user1 = (User) context.getBean(&quot;user&quot;);System.out.println(user1);\r\n根据Bean的类型获取实例\r\n// 方式二：根据Bean的类型获取实例User user2 = (User) context.getBean(User.class);System.out.println(user2);\r\n根据Bean的id和类型获取实例\r\n//方式三：根据Bean的id和类型获取实例User user3 = context.getBean(&quot;user&quot;, User.class);System.out.println(user3);\r\n输出都是一样的\r\n/** * UserTest类用于演示通过XML配置文件进行Spring IOC（Inverse of Control）的简单示例。 */package com.sakurapaid.spring.iocxml; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserTest &#123;    /**     * 主函数入口，演示了三种方式从Spring容器中获取Bean实例。     */    public static void main(String[] args) &#123;        // 创建Spring容器，使用ClassPathXmlApplicationContext加载名为&quot;bean.xml&quot;的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);         // 方式一：根据Bean的id获取实例        User user1 = (User) context.getBean(&quot;user&quot;);        System.out.println(user1);         // 方式二：根据Bean的类型获取实例        User user2 = (User) context.getBean(User.class);        System.out.println(user2);         // 方式三：根据Bean的id和类型获取实例        User user3 = context.getBean(&quot;user&quot;, User.class);        System.out.println(user3);    &#125;&#125;// 输出/*com.ergoutree.User@48793befcom.ergoutree.User@48793befcom.ergoutree.User@48793bef*/\r\n在传统的编程方式中，我们通常需要在代码中通过 new\r\n关键字创建对象实例，同时还需要手动管理对象之间的依赖关系。然而，在这段Spring的IoC示例中：\r\n我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：\r\n通过 ClassPathXmlApplicationContext 加载了名为 “bean.xml”\r\n的Spring配置文件，这个配置文件中定义了Bean（这里是 User\r\n类的实例）的创建方式和依赖关系。\r\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);\r\n然后，我们通过三种不同的方式从Spring容器中获取 User 类的实例：\r\n\r\n直接通过Bean的id（“user”）获取。\r\n根据Bean的类型（User.class）获取唯一匹配的Bean。\r\n同时指定Bean的id和类型获取实例。\r\n\r\n从Spring容器中“取出”装配好的Bean然后使用它\r\n// 获取Bean:UserService userService = context.getBean(UserService.class);// 正常调用:User user = userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);\r\n在以上每步中，都没有直接执行 new User() 来创建对象，而是由Spring\r\nIoC容器负责创建并管理这些对象。这就是所谓的“控制反转”：对象的创建控制权从应用代码转移到了Spring容器，从而实现了对象的生命周期管理、依赖关系注入等高级功能，减少了代码之间的耦合度，增强了系统的可维护性和可扩展性。\r\n注意点\r\n当在Spring的IoC容器中配置了两个相同类型的Bean，会怎么样？\r\n当在Spring的IoC容器中配置了两个相同类型的Bean时，例如：\r\n&lt;bean id=&quot;user1&quot; class=&quot;com.ergoutree.spring.iocxml.User&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.ergoutree.spring.iocxml.User&quot;&gt;&lt;/bean&gt;\r\n这时，如果你试图仅根据类型(User.class)来获取Bean，Spring容器会因为无法确定具体应该返回哪个Bean实例而抛出异常。当Spring容器中存在多个同类型Bean定义时，若仅根据类型来查找，容器无法唯一确定应该返回哪一个Bean实例，因为按照类型查找期望得到的是唯一的匹配Bean。\r\n如果需要根据类型获取Bean，需要确保容器中对应类型的Bean只有一个，或者通过Bean的id来明确指定要获取的Bean。\r\n\r\n\r\n如果一个实现类实现了接口，根据接口类型可以获取 bean\r\n吗？\r\n\r\nUserDao 接口\r\npublic interface UserDao &#123;    public void test();&#125;\r\nUserDaoImpl 实现类\r\npublic class UserDaoImpl implements UserDao &#123;    @Override    public void test()&#123;        System.out.println(&quot;UserDao01 test&quot;);    &#125;&#125;\r\nUserTest 添加\r\nUserDao bean = context.getBean(UserDao.class);        System.out.println(bean);        bean.test();\r\n最后运行抛出异常 因为 bean.xml 中没有进行配置\r\nException in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#x27;com.ergoutree.interf.UserDao&#x27; available\r\n因为UserDao是一个接口，接口是不能有自己的对象，只能由实现它的类userDaoImp01来创建对象，所以下面\r\n&lt;bean id=&quot;userDaoImp01&quot;   class=&quot;com.sakurapaid.spring.iocxml.interf.UserDaoImp01&quot;&gt;&lt;/bean&gt;\r\n&lt;bean&gt; 元素是用来声明和定义Spring\r\nIoC容器中托管的一个Bean实例。\r\nid=“userDaoImp01”：这部分指定了在Spring容器中的Bean的唯一标识符，通过这个ID，你可以从容器中获取或引用这个Bean实例。\r\nclass=\"com.sakurapaid.spring.iocxml.interf.UserDaoImp01\"：这部分定义了Bean的实现类，即当\r\nSpring 容器创建这个Bean 时，会使用这个类的信息来生成 Bean\r\n的实例。尽管UserDao是个接口，但在实际应用中，我们需要通过其实现类UserDaoImp01\r\n来创建对象，因为接口不能实例化，只有具体的实现类才能生成对象实例。\r\n此配置意味着Spring IoC容器将在启动时根据 UserDaoImp01\r\n类的无参构造函数来创建一个Bean实例，并将其注册到容器中，之后在任何需要\r\nUserDao 接口的地方，都可以通过 Spring 容器自动注入或通过 getBean\r\n方法根据 Bean 的 ID（这里是”userDaoImp01”）来获取到这个实现了 UserDao\r\n接口的具体实例。这就是Spring框架中的依赖注入（DI）机制。\r\n所以回答最上面的问题，如果就一个实现类实现了接口，根据接口类型可以获取\r\nbean 吗？\r\n是的，如果只有一个实现类实现了接口，并且这个实现类已经在Spring的IoC容器中配置为一个Bean，那么根据接口类型是可以成功获取到对应的Bean实例的。\r\n前提条件：\r\n\r\n实现类已经在Spring配置文件（如：bean.xml）中被正确配置为一个Bean。\r\n配置时指定了实现类的全限定名作为class属性的值。\r\n在IoC容器中根据接口类型获取Bean时，容器中没有其他同样实现了该接口的Bean定义，即接口的实现类在容器中是唯一的。\r\n\r\n\r\n\r\n如果一个接口有多个实现类，这些实现类都配置了\r\nbean，根据接口类型可以获取 bean 吗？\r\n\r\n不可以，如果一个接口有多个实现类，并且这些实现类都被配置成了Spring容器中的Bean，那么直接根据接口类型来获取Bean将会抛出NoUniqueBeanDefinitionException异常，因为Spring容器无法确定应该返回哪个Bean实例。\r\n例如，有两个实现类UserDaoImp01和UserDaoImp02都实现了UserDao接口，并且都在Spring配置文件中配置为Bean：\r\n&lt;bean id=&quot;userDaoImp01&quot; class=&quot;com.ergoutree.interf.UserDaoImp01&quot;/&gt;&lt;bean id=&quot;userDaoImp02&quot; class=&quot;com.ergoutree.interf.UserDaoImp02&quot;/&gt;\r\n相当于在Spring的IoC容器中配置了两个相同类型的Bean\r\n依赖注入之 setter 注入\r\n总体结构\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n创建学生类Student\r\npublic class Student &#123;    private String name;    private int age;        public Student() &#123;&#125;     public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;     public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;     public int getAge() &#123;        return age;    &#125;     public void setAge(int age) &#123;        this.age = age;    &#125;     public String toString() &#123;        return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;&#125;&quot;;    &#125;&#125;\r\nbean-di.xml 配置文件\r\n这里的******元素对应于****Student****类中的setter方法**\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置student的name属性为&quot;ergoutree&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;ergoutree&quot;&gt; &lt;/property&gt;        &lt;!-- 设置student的age属性为18 --&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt; &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试类\r\n当Spring容器读取并解析bean-di.xml配置文件时，会创建一个Student实例，并通过调用对应的setter方法（setName\r\n和setAge），将值”ergoutree”注入到name属性，将值18注入到age属性，从而完成依赖注入。\r\npublic class StudentTest &#123;    @Test    public void test() &#123;        // 创建ClassPathXmlApplicationContext实例，并加载名为&quot;bean-di.xml&quot;的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        // 通过上下文对象获取名为&quot;student&quot;的Bean实例，其类型为Student类        Student student = context.getBean(&quot;student&quot;, Student.class);        // 打印学生对象的信息        System.out.println(student);    &#125;&#125;\r\n\r\n\r\n依赖注入之构造器注入\r\n在Student类中添加有参构造\r\npublic Student(String name) &#123;&#125;\r\n配置bean-di.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置student的name属性为&quot;ergoutree&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;ergoutree&quot;&gt; &lt;/property&gt;        &lt;!-- 设置student的age属性为18 --&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt; &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;studentcon&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 通过构造器参数name传入值&quot;ergou&quot; --&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;ergou&quot;&gt; &lt;/constructor-arg&gt;        &lt;!-- 通过构造器参数age传入值&quot;19&quot; --&gt;        &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt; &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n这里使用了&lt;constructor-arg&gt;标签来指定构造函数的参数。根据注释，我们知道\r\nStudent\r\n类应该有一个带有两个参数（name和age）的构造函数，类似于下面的Java代码：\r\npublic class Student &#123;    private String name;    private int age;     // 构造函数注入    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    // 省略其他代码...&#125;\r\nconstructor-arg标签还有两个属性可以进一步描述构造器参数：\r\nindex属性：指定参数所在位置的索引（从0开始）\r\nname属性：指定参数名\r\n测试方法\r\n@Test    public void test2() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        // 通过上下文对象获取名为&quot;student&quot;的Bean实例，其类型为Student类        Student student = context.getBean(&quot;studentcon&quot;, Student.class);        // 打印学生对象的信息        System.out.println(student);    &#125;\r\n当Spring容器加载并解析XML配置文件时，它会找到studentcon这个bean，并根据&lt;constructor-arg&gt;标签提供的信息，调用\r\nStudent\r\n类的相应构造函数，传入”ergou”作为name参数，传入19作为age参数，从而创建并初始化Student实例。\r\n最终，通过context.getBean(\"studentcon\", Student.class)获取到了通过构造器注入生成的Student实例，并将其打印出来。\r\n特殊值处理\r\n某些XML配置片段在Spring框架中的意义\r\n\r\n字面量赋值\r\n\r\n&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;\r\n在Spring的XML配置中，&lt;property&gt;标签是用来设置Bean属性值的。这里的value=\"张三\"就是将字面量“张三”赋给名为”name”的属性。这意味着当你在Bean中引用该属性时，它的值就是字符串”张三”，而不是一个变量或者表达式的结果。\r\n\r\n设置null值\r\n\r\n&lt;property name=&quot;name&quot;&gt;    &lt;null /&gt;&lt;/property&gt;\r\n这种方式是用来给Bean的属性设置 null\r\n值的。与直接使用value=\"null\"不同，后者会被当作字符串”null”而非实际的Java\r\nnull值处理。\r\n&lt;null /&gt;标签告诉Spring容器将此属性值设为空引用。\r\n注意下面的这样写法\r\n&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;\r\n这样的写法，为name所赋的值是字符串null\r\n\r\nXML实体\r\n\r\n&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;\r\n在XML中，“&lt;” 和 “&gt;”\r\n等特殊字符有特殊的含义，它们分别表示标签的开始和结束。如果你想在属性值中包含这样的字符，需要使用XML实体来转义。\r\n例如，XML实体如 &amp;lt 代替小于号 &lt;\r\n，这样解析器就会知道这是一个小于符号，而不是标签的起始。XML实体如\r\n&amp;gt代替大于号 &gt;\r\n\r\nCDATA节\r\n\r\nCDATA(Characters\r\nData)是一种在XML文档中嵌入大段文本的方式，其中的内容不会被XML解析器解析为标记或实体。在这里，如果你的属性值可能包含大量的特殊字符或者需要包含XML语法结构，为了防止解析错误，可以将这部分内容放在&lt;![CDATA[ ... ]]&gt;之中。因此，&lt;![CDATA[a &lt; b]]&gt;意味着a&lt; b被当作纯文本对待，里面的\r\n\"&lt;\"字符不会被解析成标签开始。\r\n为对象类型属性赋值\r\n示例\r\n准备工作\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n部门类\r\npackage com.ergoutree.diobj;public class Department &#123;    private String name;    public void sout() &#123;        System.out.println(&quot;部门名: &quot; + name);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\r\n员工类\r\npackage com.ergoutree.diobj;public class Employee &#123;    private Department department;    private String name;    private int age;    public void work() &#123;        System.out.println(&quot;员工: &quot; + name + &quot;，年龄: &quot; + age);        department.sout();    &#125;    public Department getDepartment() &#123;        return department;    &#125;    public void setDepartment(Department department) &#123;        this.department = department;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\r\n引用外部bean，配置 bean-diobj.xml\r\n&lt;property name=\"department\" ref=\"department\"/&gt;这一行表示：当Spring容器初始化\r\n“employee” 这个 Bean\r\n时，会自动查找ID为”department”的Bean，并将该Bean的实例注入到 Employee\r\n类的 department 属性上，实现了依赖注入。\r\n   &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;   &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;       &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;       &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;   &lt;/bean&gt;&lt;!--外部bean使用ref指定依赖所注入的对象--&gt;   &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;   &lt;bean id=&quot;employee&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;       &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;       &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;       &lt;!-- 设置员工年龄为 20 --&gt;       &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;       &lt;!--通过ref属性指定依赖注入的对象--&gt;       &lt;!-- 将该员工所属部门设置为 &quot;department&quot;，实现依赖注入 --&gt;       &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;   &lt;/bean&gt;\r\n测试输出\r\n在测试类EmployeeTest中，我们通过Spring应用上下文加载XML配置文件，然后获取”employee”这个Bean的实例，并调用其work方法。由于依赖注入已经完成，此时调用employee.work()方法时，不仅会输出员工的基本信息，还会通过注入的department对象输出部门名称。\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;employee&quot;, Employee.class);        employee.work();    &#125;&#125;\r\n总结起来，这种引用外部 bean 的方式就是在配置文件中通过 ref\r\n属性指定了依赖对象，Spring\r\n容器负责自动装配这些依赖关系，使得类之间的耦合度降低，提高了程序的可维护性和灵活性。\r\n内部bean\r\n内部bean（Inner\r\nBean）是在Spring配置文件中直接定义并初始化的一个Bean，它不是顶级Bean（Root\r\nBean），而是作为另一个Bean的属性值出现。在给出的示例中，我们展示了如何通过内部bean的方式来注入Employee类的department属性。\r\n在bean配置上和内部bean有所区别，但能达到一样的效果\r\n在XML配置文件中，对于employee2这个Bean的定义，我们不再通过ref属性引用已经定义好的外部Bean，而是直接在其department属性内部定义一个新的Department\r\nBean。\r\n这里的新Department\r\nBean没有显式定义ID，因为它是一个内部Bean，由Spring容器自动生成一个唯一的ID。同时，它拥有自己的属性设置，如name属性被设置为”开发部”。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;!--外部bean方式--&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;employee1&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;    &lt;/bean&gt;        &lt;!--内部bean方式--&gt;    &lt;bean id=&quot;employee2&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot;&gt;               &lt;bean class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;                   &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;               &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;  &lt;/beans&gt;\r\n当Spring容器加载配置文件并初始化 employee2 这个Bean时，它会发现\r\ndepartment 属性需要注入一个 Department 类型的 Bean\r\n。于是，它会在当前上下文中查找匹配的 Bean 定义，发现内部定义的\r\nDepartment Bean，然后创建并初始化这个内部 Bean，并将其实例注入到\r\nemployee2 的 department 属性上。\r\n在测试类 EmployeeTest 中，我们仅获取并操作了使用内部 bean 方式注入的\r\nEmployee 实例（employee2），同样能够达到与外部 bean\r\n方式相同的效果，即输出员工基本信息以及所属部门名称。\r\n内部 bean 方式的优势在于可以在同一个配置块内清晰地展示和组织 Bean\r\n之间的依赖关系，简化配置文件结构。但在某些场景下，如果某个 Bean\r\n会被多个其他 Bean 共享，使用外部 bean 并通过 ref 引用则更为合适。\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;employee2&quot;, Employee.class);        employee.work();    &#125;&#125;\r\n级联属性赋值\r\n不常用\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;!--外部bean方式--&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;employee1&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;    &lt;/bean&gt;        &lt;!--内部bean方式--&gt;    &lt;bean id=&quot;employee2&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot;&gt;               &lt;bean class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;                   &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;               &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!--级联属性赋值--&gt;    &lt;bean id=&quot;department3&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;employee3&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!-- 级联属性赋值，直接为 employee3 的属性赋值 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;department3&quot;/&gt;        &lt;property name=&quot;department.name&quot; value=&quot;测试部&quot;/&gt;    &lt;/bean&gt; &lt;/beans&gt;\r\n级联属性赋值是针对对象类型属性的进一步操作，当一个 Bean\r\n的属性是另一个对象类型时，我们不仅可以为这个对象属性赋值，还可以直接为该对象属性的内部属性进行赋值。\r\n在单独的 &lt;bean&gt;标签中，把 bean 对象所依赖的类通过\r\n&lt;property&gt; 中标出，也是使用 ref\r\n级联属性赋值时，要确保被赋值的对象属性已经正确实例化\r\n级联属性赋值的优先级高于直接在被引用的 Bean\r\n中设置的属性值，即后配置的值会覆盖前面已配置的值。\r\n\r\n为数组类型属性赋值\r\n修改Employee员工类\r\n主要是新增了数组成员和及其输出\r\npublic class Employee &#123;    private Department department;    private String name;    private int age;    private String[] hobby;    public Employee() &#123;&#125;    public Employee(Department department, String name, int age, String[] hobby) &#123;        this.department = department;        this.name = name;        this.age = age;        this.hobby = hobby;    &#125;    public void work() &#123;        System.out.println(&quot;员工: &quot; + name + &quot;，年龄: &quot; + age);        department.sout();        // 遍历数组        System.out.println(Arrays.toString(hobby));    &#125;    public Department getDepartment() &#123;        return department;    &#125;    public void setDepartment(Department department) &#123;        this.department = department;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String[] getHobby() &#123;        return hobby;    &#125;    public void setHobby(String[] hobby) &#123;        this.hobby = hobby;    &#125;    public String toString() &#123;        return &quot;Employee&#123;department = &quot; + department + &quot;, name = &quot; + name + &quot;, age = &quot; + age + &quot;, hobby = &quot; + hobby + &quot;&#125;&quot;;    &#125;&#125;\r\n编辑 spring 配置文件\r\n&lt;property&gt;标签用于设置 Employee\r\n类中对应的属性值。对于数组类型的\"hobby\"属性，我们使用了&lt;array&gt;标签来进行嵌套注入。在&lt;array&gt;标签内部，通过多个&lt;value&gt;标签来分别指定数组中的每个元素值。\r\n所以当Spring容器创建\"employee\"这个 Bean\r\n时，它会自动将这些值注入到 Employee 对象的 “hobby”\r\n数组属性中，最终得到的数组内容即为 [“吃饭”, “睡觉”, “打gal”] 。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;    &lt;bean id=&quot;employee&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置员工年龄为 20 --&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!--通过ref属性指定依赖注入的对象--&gt;        &lt;!-- 将该员工所属部门设置为 &quot;department&quot;，实现依赖注入 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;                &lt;property name=&quot;hobby&quot;&gt;            &lt;array&gt;                &lt;value&gt;吃饭&lt;/value&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;打gal&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试输出\r\n\r\n\r\nimage-20250420202752367\r\n\r\n\r\n\r\nimage-20250420202752367\r\n\r\n\r\n为集合类型属性赋值\r\n为 List 集合类型属性赋值\r\n修改Department部门类\r\n多了个List集合，一个部门有很多人，再定义个输出方法\r\nimport java.util.List;public class Department &#123;    //一个部门有很多人    private List&lt;Employee&gt; employees;    //部门名称    private String name;    public void sout() &#123;        System.out.println(&quot;部门名: &quot; + name);        for (Employee emp : employees)&#123;            System.out.println(emp.getName());        &#125;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public List&lt;Employee&gt; getEmployees() &#123;        return employees;    &#125;    public void setEmployees(List&lt;Employee&gt; employees) &#123;        this.employees = employees;    &#125;&#125;\r\n定义 Spring 配置文件\r\n两个员工 bean 和一个部门 bean\r\n在 XML 配置文件中，首先定义了两个 Employee 类型的\r\nBean（emp1和emp2），它们分别具有不同的属性值，包括名字、年龄和兴趣爱好列表（hobby）。这里的\r\nhobby\r\n属性是一个列表类型，使用&lt;list&gt;标签进行配置，通过多个&lt;value&gt;子标签为列表添加元素。\r\n然后，定义了一个 Department 类型的\r\nBean（dept），它具有一个名字属性和一个 employees 集合属性。employees\r\n属性也是一个列表类型，用于存放 Department 下的多个 Employee\r\n对象。这里使用&lt;list&gt;标签，并通过&lt;ref&gt;子标签引用前面定义好的\r\nEmployee Bean（emp1和emp2），从而将这两个 Employee 对象注入到 Department\r\n的 employees 集合属性中。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;    &lt;bean id=&quot;emp1&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置员工年龄为 20 --&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!--通过ref属性指定依赖注入的对象--&gt;        &lt;!-- 将该员工所属部门设置为 &quot;dept&quot;，实现依赖注入 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;dept&quot;/&gt;        &lt;property name=&quot;hobby&quot;&gt;            &lt;array&gt;                &lt;value&gt;吃饭&lt;/value&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;打gal&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 定义另一个员工对象，员工2 --&gt;    &lt;bean id=&quot;emp2&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 员工的名字 --&gt;        &lt;property name=&quot;name&quot; value=&quot;Lucy&quot; /&gt;        &lt;!-- 员工的年龄 --&gt;        &lt;property name=&quot;age&quot; value=&quot;21&quot; /&gt;        &lt;!-- 员工的爱好，以列表形式 --&gt;        &lt;property name=&quot;hobby&quot;&gt;            &lt;list&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;学习&lt;/value&gt;                &lt;value&gt;吃饭&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 定义一个部门对象 --&gt;    &lt;bean id=&quot;dept&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 部门的名字 --&gt;        &lt;property name=&quot;name&quot; value=&quot;财政部&quot; /&gt;        &lt;!-- 部门下的员工列表 --&gt;        &lt;property name=&quot;employees&quot;&gt;            &lt;list&gt;                &lt;!-- 引用员工1对象 --&gt;                &lt;ref bean=&quot;emp1&quot; /&gt;                &lt;!-- 引用员工2对象 --&gt;                &lt;ref bean=&quot;emp2&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试输出\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;emp1&quot;, Employee.class);        employee.work();        Department dept = context.getBean(&quot;dept&quot;, Department.class);        dept.sout();    &#125;&#125;\r\n\r\n\r\nimage-20250420203805345\r\n\r\n\r\n\r\nimage-20250420203805345\r\n\r\n为Map集合类型赋值\r\n修改 student 类，添加一个 Map\r\n类型的属性，用于存储学生的课程和对应的成绩\r\npackage com.ergoutree.di;import java.util.Map;public class Student &#123;    private String name;    private int age;    private Map&lt;String, Integer&gt; scores;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student(String name) &#123;&#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Map&lt;String, Integer&gt; getScores() &#123;        return scores;    &#125;    public void setScores(Map&lt;String, Integer&gt; scores) &#123;        this.scores = scores;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, scores=&quot; + scores + &quot;&#125;&quot;;    &#125;&#125;\r\n修改 bean-di.xml\r\n&lt;bean id=&quot;student2&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置学生姓名 --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置学生的成绩 Map --&gt;        &lt;property name=&quot;scores&quot;&gt;            &lt;map&gt;                &lt;!-- 键值对：课程名和对应的成绩 --&gt;                &lt;entry key=&quot;数学&quot; value=&quot;90&quot;/&gt;                &lt;entry key=&quot;英语&quot; value=&quot;85&quot;/&gt;                &lt;entry key=&quot;语文&quot; value=&quot;88&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;\r\n\r\n&lt;map&gt; 标签：用于定义一个\r\nMap 集合，在 标签内部使用 标签来定义\r\nMap 中的键值对。\r\n&lt;entry&gt; 标签：key\r\n属性指定键，value\r\n属性指定值。这里的键和值都是基本数据类型（字符串和整数）\r\n键和值的类型：在 &lt;entry&gt;\r\n标签中，key 和 value 属性的值会根据 Bean\r\n属性的类型自动进行类型转换。如果键或值是复杂对象，你可以使用\r\nkey-ref 和 value-ref 引用其他 Bean。\r\n\r\n测试\r\n@Test    public void test3() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        Student student = context.getBean(&quot;student2&quot;, Student.class);        System.out.println(student);    &#125;// 输出// Student&#123;name=&#x27;张三&#x27;, scores=&#123;数学=90, 英语=85, 语文=88&#125;&#125;\r\n引用集合类型的 bean\r\n修改学生类\r\n新增一个 List 集合，管理课程\r\npackage com.ergoutree.di;import java.util.*;public class Student &#123;    private String name;    private int age;    private Map&lt;String, Integer&gt; scores;    private int stu_id;    private List&lt;Lesson&gt; listLessons;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void sout()&#123;        // 输出学生的基本信息        System.out.println(&quot;学生id : &quot; + stu_id + &quot;, &quot; +                &quot;学生姓名 : &quot; + name);        System.out.println();        // 输出课程集合        System.out.print(&quot;课程集合 : &quot;);        for(Lesson lesson : listLessons)&#123;            System.out.print(lesson.getLessonName() + &quot; &quot;);        &#125;    &#125;    public Student(String name) &#123;&#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Map&lt;String, Integer&gt; getScores() &#123;        return scores;    &#125;    public void setScores(Map&lt;String, Integer&gt; scores) &#123;        this.scores = scores;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, scores=&quot; + scores + &quot;&#125;&quot;;    &#125;&#125;\r\n对应的Lesson类\r\npublic class Lesson &#123;    private String lessonName;    public String getLessonName() &#123;        return lessonName;    &#125;    public void setLessonName(String lessonName) &#123;        this.lessonName = lessonName;    &#125;&#125;\r\n配置Spring文件\r\n使用util:list、util:map标签必须引入相应的命名空间\r\n代码样式放在上的，需要用时直接复制粘贴即可\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util    http://www.springframework.org/schema/util/spring-util.xsd    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\r\n&lt;bean id=&quot;studentcon&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;!-- 通过构造器参数name传入值&quot;ergou&quot; --&gt;       &lt;constructor-arg name=&quot;name&quot; value=&quot;ergou&quot;&gt; &lt;/constructor-arg&gt;       &lt;!-- 通过构造器参数age传入值&quot;19&quot; --&gt;       &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt; &lt;/constructor-arg&gt;   &lt;/bean&gt;   &lt;bean id=&quot;student2&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;!-- 设置学生姓名 --&gt;       &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;       &lt;!-- 设置学生的成绩 Map --&gt;       &lt;property name=&quot;scores&quot;&gt;           &lt;map&gt;               &lt;!-- 键值对：课程名和对应的成绩 --&gt;               &lt;entry key=&quot;数学&quot; value=&quot;90&quot;/&gt;               &lt;entry key=&quot;英语&quot; value=&quot;85&quot;/&gt;               &lt;entry key=&quot;语文&quot; value=&quot;88&quot;/&gt;           &lt;/map&gt;       &lt;/property&gt;   &lt;/bean&gt;   &lt;bean id=&quot;student3&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;property name=&quot;stu_id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;name&quot; value=&quot;王昊&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;listLessons&quot; ref=&quot;listlessons&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!--新建的lesson bean--&gt;   &lt;bean id=&quot;lesson1&quot; class=&quot;com.ergoutree.di.Lesson&quot;&gt;       &lt;property name=&quot;lessonName&quot; value=&quot;liang_zi_qi&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;bean id=&quot;lesson2&quot; class=&quot;com.ergoutree.di.Lesson&quot;&gt;       &lt;property name=&quot;lessonName&quot; value=&quot;wanghao&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!--课程列表包含bean--&gt;   &lt;util:list id=&quot;listlessons&quot;&gt;       &lt;ref bean=&quot;lesson1&quot;&gt;&lt;/ref&gt;       &lt;ref bean=&quot;lesson2&quot;&gt;&lt;/ref&gt;   &lt;/util:list&gt;\r\n测试\r\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class MapAndListTest &#123;    @Test    public void test()&#123;        // 加载名为&quot;bean-diMapAndList.xml&quot;的XML配置文件，创建ApplicationContext上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diMapAndList.xml&quot;);        // 从上下文中获取名为&quot;student&quot;的Bean实例，其类型为Student        Student student = context.getBean(&quot;student&quot;, Student.class);        // 调用Student实例的sout方法，输出相关信息        student.sout();    &#125;&#125;\r\n\r\n\r\nimage-20250421163559144\r\n\r\n\r\n\r\nimage-20250421163559144\r\n\r\n\r\n由于篇幅太长，转到 下篇\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework Part5-Spring中的AOP面向切面编程","url":"/posts/50477.html","content":"什么是\r\nAOP，如何理解面向切面编程\r\nAOP,\r\nAspect Oriented Programming\r\n，即面向切面编程。\r\n通过预编译方法和运行期间动态代理的方式实现，在不修改源代码的方式下，给程序动态统一添加额外功能的一种技术。\r\n\r\nAOP是对面向对象编程OOP的一个补充。\r\n它的目的是将复杂的需求分解为不同的切面，将散布在系统中的公共功能集中解决。\r\n它的实际含义是在运行时将代码切入到类的指定方法、指定位置上，将不同方法的同一个位置抽象为一个切面对象，并对该对象进行编程。\r\n\r\n\r\nAOP 的目的是为了解耦 其次是简化开发，AOP 是 Spring 的核心\r\n面向切面编程\r\n他是一套规范，通过预编译方式和运行期间动态代理实现程序的统一维护\r\n核心概念 就是\r\n将分散在各个业务逻辑代码中的相同的代码通过横向切割的方式抽取到一个独立的模块中\r\n\r\n\r\nimg\r\n\r\nAOP的优点\r\n\r\n降低模块之间的耦合度\r\n使系统更容易扩展\r\n更好的代码复用\r\n非业务代码更加集中，不分散，便于统一管理\r\n业务代码更加简洁纯粹，不掺杂其他的代码的影响\r\n\r\nAOP中出现的一些概念\r\n\r\n切面：横切关注点，从每个方法中抽取的非核心业务，被模块化的抽象对象，横切关注点的模块化，比如下标提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为在哪干和干什么集合；\r\n通知：切面对象完成的工作（非业务代码），在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before\r\nadvice）、后置通知(after advice)、环绕通知（around\r\nadvice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为干什么；\r\n目标：被通知的对象（即被横切的对象），需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；由于Spring\r\nAOP\r\n通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为对谁干；\r\n代理：切面、通知、目标混合之后的对象。封装通知方法的类\r\nAOP代理：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。在AOP中表示为怎么实现的一种典型方式；\r\n连接点：通知要插入业务代码的具体位置，表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为spring允许你使用通知的地方；（如Spring实现中的JoinPoint）\r\n切入点：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为在哪里干的集合；\r\n织入：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java\r\nAOP框架一样，在运行时完成织入。在AOP中表示为怎么实现的；\r\n引入：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）,\r\n在AOP中表示为干什么（引入什么）；\r\n\r\n\r\n\r\nimg\r\n\r\nAOP 的核心是连接点\r\n连接点是我们需要关注的程序拓展点\r\n可能是类初始化 方法执行 方法调用 字段调用 异常处理等\r\nSpring 支持的连接点是方法执行点\r\n切入点是一系列连接点的集合，Spring默认使用AspectJ语法，在AOP中抽象表示为可以进行操作的集合\r\n之后就是通知\r\n通知就是我们在连接点上执行的行为\r\n连接点 切入点 通知组合在一起 就是一个切面\r\n把切面映入到其他应用程序或者对象上，创建一个被通知的对象，这些就是织入，Spring\r\n在运行时完成织入 ，在 AOP 中表示为怎么实现的，实现方式\r\n通知类型：\r\n\r\n前置通知（Before advice）：\r\n在被代理的目标方法之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\r\n后置通知（After returning advice）：\r\n在被代理的目标方法后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\r\n异常通知（After throwing advice）：\r\n在被代理的目标方法抛出异常退出时执行的通知。\r\n最终通知（After (finally) advice）：\r\n当被代理的目标方法最终说明的时候执行的通知（不论是正常返回还是异常退出）。\r\n环绕通知（Around Advice）：\r\n包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\r\n\r\n环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知，推荐你使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成同样的事情。用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要在JoinPoint上调用用于环绕通知的proceed()方法，就不会有调用的问题。\r\nSpring AOP和 AspectJ\r\n是什么关系\r\nAspectJ 是一个更加强大的 AOP 框架 是一个 AOP 标准\r\n如果只是简单的业务 可以使用 AOP\r\nAOP 一个重要的原则就是无侵入性\r\nAspectJ 重要的是 一般在编译期进行 即静态织入\r\n在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。\r\n动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java\r\nJDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring\r\nAOP采用的就是基于运行时增强的代理技术。 \r\nSpring AOP更易用，AspectJ更强大\r\nJava中的代理模式实现AOP\r\n创建一个计算器接口，定义四个方法\r\npackage edu.software.ergoutree.spring6aop.example;public interface Calculator &#123;    public int add(int a, int b);    public int subtract(int a, int b);    public int multiply(int a, int b);    public int divide(int a, int b);&#125;\r\n创建一个带日志输出的实现类\r\n高耦合的写法，每次打印日志都要手动完成\r\npackage edu.software.ergoutree.spring6aop.example;// 带日志的实现类// 发现日志功能对核心功能没有影响，但是混合到一起了，既要关心核心业务逻辑，还要关注日志，维护困难public class CalculatirLogImpl implements Calculator&#123;    @Override    public int add(int a, int b) &#123;        System.out.println(&quot;[日志] add 方法开始&quot;);        int result = a + b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] add 方法结束&quot;);        return result;    &#125;    @Override    public int subtract(int a, int b) &#123;        System.out.println(&quot;[日志] sub 方法开始&quot;);        int result = a - b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] sub 方法结束&quot;);        return result;    &#125;    @Override    public int multiply(int a, int b) &#123;        System.out.println(&quot;[日志] mul 方法开始&quot;);        int result = a * b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] mul 方法结束&quot;);        return result;    &#125;    @Override    public int divide(int a, int b) &#123;        System.out.println(&quot;[日志] div 方法开始&quot;);        int result = a / b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] div 方法结束&quot;);        return result;    &#125;&#125;\r\n使用静态代理进行优化\r\n上方代码中，日志信息和业务逻辑的耦合性很高，不利于代码的维护。\r\n关于静态代理和动态代理的部分，可以看我的另一篇文章，这里只做简单讲解\r\n介绍：代理是一种设计模式，提供一个代理类，调用方法的时候使用代理类间接调用，让不属于目标方法核心方法中的代码解耦出来，减少对目标方法的调用和打扰，同时让功能更加集中统一更利于维护\r\n静态代理是通过创建一个代理类来实现对目标对象的访问控制。下面是计算器例子改为静态代理的实现方式\r\npackage edu.software.ergoutree.spring6aop.example;// 代理类public class CalculatorProxy implements Calculator &#123;    // 传递被代理的目标对象    private final Calculator target;      public CalculatorProxy(Calculator target) &#123;        this.target = target;    &#125;    @Override    public int add(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行add方法&quot;);   // 关于代理的日志仅仅是记录操作，不代表没有实现代理        // 调用目标对象的方法实现核心业务的实现        int result = target.add(a, b);        System.out.println(&quot;代理: add方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int subtract(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行subtract方法&quot;);        int result = target.subtract(a, b);        System.out.println(&quot;代理: subtract方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int multiply(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行multiply方法&quot;);        int result = target.multiply(a, b);        System.out.println(&quot;代理: multiply方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int divide(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行divide方法&quot;);        try &#123;            int result = target.divide(a, b);            System.out.println(&quot;代理: divide方法执行完成，结果=&quot; + result);            return result;        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;代理: divide方法执行出错 - &quot; + e.getMessage());            throw e;        &#125;    &#125;&#125;\r\n测试类\r\npackage edu.software.ergoutree.spring6aop.example;public class Main &#123;    public static void main(String[] args) &#123;        // 创建目标对象        Calculator target = new CalculatorImpl();                // 创建代理对象，传入目标对象        Calculator proxy = new CalculatorProxy(target);                // 通过代理对象调用方法        System.out.println(&quot;10 + 5 = &quot; + proxy.add(10, 5));        System.out.println(&quot;10 - 5 = &quot; + proxy.subtract(10, 5));        System.out.println(&quot;10 * 5 = &quot; + proxy.multiply(10, 5));        System.out.println(&quot;10 / 5 = &quot; + proxy.divide(10, 5));                // 测试除法异常        try &#123;            System.out.println(&quot;10 / 0 = &quot; + proxy.divide(10, 0));        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n使用动态代理优化\r\n静态代理没有实现对日志的统一管理，实际上并没有进行多少的优化\r\n\r\n\r\nimage-20250422204359251\r\n\r\n定义计算器接口和实现类都不变，我们添加一个日志处理器，实现\r\nInvocationHandler 接口\r\n// 日志处理器，实现 InvocationHandler 接口class LogHandler implements InvocationHandler &#123;    private final Object target;    public LogHandler(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        String methodName = method.getName();        System.out.println(&quot;[日志] &quot; + methodName + &quot; 方法开始&quot;);        Object result = method.invoke(target, args);        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] &quot; + methodName + &quot; 方法结束&quot;);        return result;    &#125;&#125;\r\n// 测试类public class DynamicProxyExample &#123;    public static void main(String[] args) &#123;        // 创建目标对象        Calculator calculator = new CalculatorImpl();        // 创建日志处理器        LogHandler logHandler = new LogHandler(calculator);        // 创建代理对象        Calculator proxyCalculator = (Calculator) Proxy.newProxyInstance(                calculator.getClass().getClassLoader(),                calculator.getClass().getInterfaces(),                logHandler        );        // 调用代理对象的方法        proxyCalculator.add(2, 3);        proxyCalculator.subtract(5, 2);        proxyCalculator.multiply(3, 4);        proxyCalculator.divide(10, 2);    &#125;&#125;\r\n在上述动态代理的例子中，我们通过 InvocationHandler\r\n实现了日志功能的增强。然而，当项目变得复杂时，手动编写代理逻辑会变得繁琐，并且难以维护。这时候，Spring\r\nAOP（面向切面编程）就可以发挥作用了。\r\nSpring AOP 是 Spring\r\n框架的一个重要特性，它允许我们在不修改原有代码的情况下，对程序进行增强。Spring\r\nAOP\r\n基于动态代理实现，提供了一种更加简洁、灵活的方式来实现横切关注点（如日志、事务管理等）。\r\n动态代理的工厂类\r\npackage edu.software.ergoutree.spring6aop.example;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyFactory &#123;    // 目标对象    private Object target;    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    // 返回代理对象    public Object getProxy() &#123;        /*        Proxy.newProxyInstance() 方法有三个参数        第一个参数 ClassLoader：加载动态生成代理类的加载器        第二个参数 class&lt;?&gt;[] interfaces:目标对象实现的所有接口的class类型的数组        第三个参数 InvocationHandler 设置代理对象实现目标对象方法的过程         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() &#123;            // 第一个参数 代理对象            // 第二个参数 需要重写的目标对象的方法            // 第三个参数 method方法里面的参数            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                // 方法调用前的日志输出                System.out.println(&quot;[动态代理日志] 开始执行 &quot; + method.getName() + &quot; 方法，参数: &quot; +                        java.util.Arrays.toString(args));                // 调用目标的方法                Object result = method.invoke(target, args);                // 方法调用后的日志输出                System.out.println(&quot;[动态代理日志] &quot; + method.getName() + &quot; 方法执行完毕，结果: &quot; + result);                System.out.println(&quot;----------------------------------&quot;);                return result;            &#125;        &#125;;        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);    &#125;&#125;\r\n测试\r\npackage edu.software.ergoutree.spring6aop.example;public class CalcutorTestProxy &#123;    public static void main(String[] args) &#123;        Calculator target = new CalculatorImpl();        // 创建代理工厂        ProxyFactory proxyFactory = new ProxyFactory(target);        // 获取代理对象        Calculator proxy = (Calculator) proxyFactory.getProxy();        // 通过代理对象调用方法        System.out.println(&quot;===== 测试加法 =====&quot;);        int addResult = proxy.add(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + addResult);        System.out.println(&quot;\\n===== 测试减法 =====&quot;);        int subtractResult = proxy.subtract(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + subtractResult);        System.out.println(&quot;\\n===== 测试乘法 =====&quot;);        int multiplyResult = proxy.multiply(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + multiplyResult);        System.out.println(&quot;\\n===== 测试除法 =====&quot;);        int divideResult = proxy.divide(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + divideResult);        // 测试异常情况        try &#123;            System.out.println(&quot;\\n===== 测试除法异常 =====&quot;);            proxy.divide(10, 0);        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getClass().getName());        &#125;    &#125;&#125;\r\n基于注解的 AOP\r\n技术说明\r\n动态代理分类：JDK动态代理 和 cglib动态代理\r\n有接口，使用 JDK\r\n动态代理，生成接口实现类的代理对象，代理对象和目标对象都实现同样的接口\r\n无接口，使用 cglib 动态代理，生成子类的代理对象，继承目标类\r\n\r\n\r\nimage-20250423163635376\r\n\r\n动态代理分为JDK动态代理和glib动态代理\r\n当目标类有接口的情况使用JDK动态代理和cglib动态代理，\r\n没有接口时只能使用cgib动态代理\r\nJDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1,和目标类实现相同的接口●cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类\r\n动态代理(InvocationHandler) :\r\nJDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求*“代理对象和目标对象实现同样的接口**\r\n(兄弟两个拜把子模式)。\r\ncglib:\r\n通过继承被代理的目标类(认干爹模式)实现代理，所以不需要目标类实现接口。\r\nAspectJ:是AOP思想的一种实现。本质上是静态代理，将代理逻辑”织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。\r\nSpring只是借用了 AspectJ中的注解。\r\n使用注解配置AOP\r\nSpring AOP允许使用基于注解的方式实现AOP，这样做可以简化Spring配置文件的臃肿代码。\r\n\r\n\r\nimage-20250423163517236\r\n\r\n步骤：\r\n\r\n引入 AOP 相关依赖\r\n创建目标资源\r\n\r\n接口\r\n实现类\r\n\r\n创建切面类\r\n\r\n切入点\r\n通知类型\r\n\r\n\r\n实例\r\n所以先创建 LogAspect 切面类\r\npackage edu.software.ergoutree.spring6aop.anoaop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;// 切面类@Component  // IoC容器中进行管理@Aspect   // 表示是一个切面类public class LogAspect &#123;    // 定义切入点表达式，匹配Calculator接口的所有方法    @Pointcut(&quot;execution(* edu.software.ergoutree.spring6aop.anoaop.Calculator.*(..))&quot;)    public void calculatorPointcut() &#123;&#125;    // 设置切入点和通知类型    // 通知类型  前置 返回 异常 后置 环绕    // 前置  @Before(value=&quot;切入点表达式配置切入点&quot;)    // 单独写切入点表达式@Before(value=&quot;execution(public int edu.software.ergoutree.spring6aop.anoaop.CalculatorImpl.add(..))&quot;)    @Before(&quot;calculatorPointcut()&quot;)    public void beforeMethod(JoinPoint joinPoint) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;前置通知，方法名&quot; + methodName + &quot; 参数 &quot; + args);    &#125;    // 后置通知（最终通知）    @After(&quot;calculatorPointcut()&quot;)    public void afterMethod(JoinPoint joinPoint) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;后置通知，方法名&quot; + methodName + &quot; 参数 &quot; + args);    &#125;    // 返回通知    // 返回  @AfterReturning(value = &quot;切入点表达式&quot;, returning = &quot;增强的目标方法返回值（和方法中的Object一样）&quot;)    @AfterReturning(value = &quot;calculatorPointcut()&quot;, returning = &quot;result&quot;)    public void afterReturningMethod(JoinPoint joinPoint, Object result) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;返回通知，方法名&quot; + methodName + &quot; 参数 &quot; + args + &quot;目标方法的返回值&quot; + result);    &#125;    // 异常通知，目标方法出现了异常，这个通知会执行    // @AfterThrowing(value = &quot;切入点表达式&quot;, throwing = &quot;目标方法的异常信息&quot;)    @AfterThrowing(value = &quot;calculatorPointcut()&quot;, throwing = &quot;ex&quot;)    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;异常通知 方法 &quot; + methodName + &quot; 参数 &quot; + args + &quot; 执行抛出异常: &quot; + ex.getMessage());    &#125;    // 环绕通知    @Around(&quot;calculatorPointcut()&quot;)    public Object aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123;        String methodName = joinPoint.getSignature().getName();        Object[] args = joinPoint.getArgs();        System.out.println(&quot;Logger-&gt;环绕通知-前 方法 &quot; + methodName + &quot; 开始执行，参数: &quot; + Arrays.toString(args));        try &#123;            System.out.println(&quot;Logger-&gt;环绕通知-目标方法之前执行&quot;);            // 执行目标方法            Object result = joinPoint.proceed();            System.out.println(&quot;Logger-&gt;环绕通知-目标方法之后执行 方法 &quot; + methodName + &quot; 执行成功，结果: &quot; + result);            return result;        &#125; catch (Exception e) &#123;            System.out.println(&quot;Logger-&gt;环绕通知-异常 方法 &quot; + methodName + &quot; 执行失败，异常: &quot; + e.getMessage());            throw e;        &#125; finally &#123;            System.out.println(&quot;Logger-&gt;环绕通知-最终 方法 &quot; + methodName + &quot; 执行结束&quot;);        &#125;    &#125;    // 环绕通知另一个应用，计算执行时间    @Around(&quot;calculatorPointcut()&quot;)    public Object timingAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;        long start = System.currentTimeMillis();        try &#123;            return joinPoint.proceed();        &#125; finally &#123;            long end = System.currentTimeMillis();            System.out.println(&quot;方法 &quot; + joinPoint.getSignature().getName()                    + &quot; 执行耗时: &quot; + (end - start) + &quot;ms&quot;);        &#125;    &#125;&#125;\r\n关于切入点表达式\r\n语法细节：\r\n\r\n用号代替”权限修饰符”和“返回值”部分表示”权限修饰符”和“返回值”不限\r\n在包名的部分，一个*号只能代表包的层次结构中的一层，表示这一层是任意的。\r\n例如: *.Hello匹配com.Hello, 不匹配com.atguigu.Hello\r\n在包名的部分，使用\r\n*..表示包名任意，包的层次深度任意\r\n在类名的部分，类名部分整体用 * 号代替,表示类名任意\r\n在类名的部分，可以使用 * 号代替类名的一部分\r\n\r\n例如:\r\n*Service匹配所有名称以Service结尾的类或接口\r\n\r\n在方法名部分，可以使用 * 号表示方法名任意\r\n在方法名部分，可以使用 * 号代替方法名的一部分\r\n\r\n例如: *Operation匹配所有方法名以Operation结尾的方法\r\n\r\n在方法参数列表部分，使用(..)表示参数列表任意\r\n在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头\r\n在方法参数列表部分，基本数据类型和对应的包装类型是不一-样的\r\n\r\n切入点表达式中使用int和实际方法中Integer 是不匹配的\r\n\r\n在方法返回值部分，如果想要明确指定一个返回值类型，\r\n那么必须同时写明楫限修饰符。\r\n\r\n例如: execution(public int ..Service,(..,int))正确\r\n例如: execution( int ..Service.*(..,int))错误\r\n\r\n\r\n完整例子：\r\nexecution(访问修饰符 增强方法的返回类型 增强方法所在类全路径.方法名)\r\n\r\n\r\nimage-20250423165621177\r\n\r\n关于 环绕通知\r\n环绕通知的特点\r\n\r\n功能最强大的通知类型：可以控制目标方法是否执行、何时执行、如何执行\r\n唯一能控制方法执行的切入点：可以决定是否调用proceed()方法来执行目标方法\r\n可以修改返回值：在方法执行前后对返回值进行处理\r\n可以处理异常：捕获并处理目标方法抛出的异常\r\n\r\naroundMethod 的方法参数说明\r\n需要注意的是，环绕通知必须接收一个类型为ProceedingJoinPoint的参数，返回值也必须是Object类型，且必须抛出异常\r\n\r\nProceedingJoinPoint：继承自JoinPoint，新增了proceed()方法\r\n\r\nproceed()：执行目标方法，返回目标方法的返回值\r\nproceed(Object[] args)：使用新参数执行目标方法\r\n\r\n\r\n与其他通知的执行顺序\r\n当环绕通知与其他通知共存时，执行顺序为：\r\n\r\n环绕通知的前半部分\r\n前置通知\r\n目标方法\r\n返回通知/异常通知\r\n后置通知\r\n环绕通知的后半部分\r\n\r\n重用切入表达式\r\n关于 @Pointcut\r\n@Pointcut 是 Spring AOP\r\n里的一个注解，其作用是定义一个切入点（Pointcut）\r\npublic void calculatorPointcut() &#123;&#125;\r\n这是一个空方法，其作用是为切入点命名。通过这种方式，可以在其他通知注解（如\r\n@Before、@After 等）中引用这个切入点\r\n创建 bean.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6aop.anoaop&quot;&gt;    &lt;/context:component-scan&gt;    &lt;!--开启Aspectj自动代理，为目标类自动生成代理--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\r\n当然也可以用注解类\r\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@ComponentScan(&quot;edu.software.ergoutree.spring6aop.anoaop&quot;)@EnableAspectJAutoProxy // 启用AOP自动代理public class AppConfig &#123;&#125;\r\n基于 XML 的AOP实现\r\n因为Spring AOP的代理对象由IoC容器自动生成，所以开发者无须过多关注代理对象生成的过程，只需选择连接点、创建切面、定义切点并在XML文件中添加配置信息即可。\r\n\r\n\r\nimage-20250423174728711\r\n\r\n配置切面\r\n在Spring的配置文件中，配置切面使用的是&lt;aop:aspect&gt;元素，该元素会将一个已定义好的Spring Bean转换成切面Bean，因此，在使用&lt;aop:aspect&gt;元素之前，要在配置文件中先定义一个普通的Spring Bean。Spring Bean定义完成后，通过&lt;aop:aspect&gt;元素的ref属性即可引用该\r\nBean。\r\n配置&lt;aop:aspect&gt;元素时，通常会指定 id 和 ref\r\n这两个属性 \r\n配置切入点\r\n在Spring的配置文件中，切入点是通过&lt;aop:pointcut&gt;元素来定义的，表示该切入点是全局切入点，它可被多个切面共享；当&lt;aop:pointcut&gt;元素作为&lt;aop:aspect&gt;元素的子元素时，表示该切入点只对当前切面有效。\r\n在定义&lt;aop:aspect&gt;元素时，通常会指定 id 和\r\nexpression 这两个属性\r\n\r\n\r\n\r\n属性名称\r\n描述\r\n\r\n\r\n\r\n\r\nid\r\n用于指定切入点的唯一标识\r\n\r\n\r\nexpression\r\n用于指定切入点关联的切入点表达式\r\n\r\n\r\n\r\n配置通知\r\n在Spring的配置文件中，使用&lt;aop:aspect&gt;元素配置了5种常用通知，如表所示，5种通知分别为前置通知、后置通知、环绕通知、返回通知和异常通知，&lt;aop:aspect&gt;元素的常用属性如表4所示。\r\n\r\n\r\nimage-20250423175046604\r\n\r\n实例\r\n文件结构\r\nsrc/├── main/│   ├── java/│   │   └── edu.software.ergoutree.spring6aop.xmlaop/│   │       ├── Calculator.java          # 接口│   │       ├── CalculatorImpl.java      # 实现类│   │       └── LogAspect.java           # 切面类│   └── resources/│       └── bean-aopxml.xml                     # XML配置└── test/    └── java/        └── CalculatorAOPTest.java          # 测试类\r\n导入AspectJ框架相关JAR包的依赖，在pom.xml中添加的代码如下：\r\n&lt;dependency&gt;\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t&lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;\t&lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\t&lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt;\r\n计算器的接口和实现类依旧用上面的那个\r\n切面类，定义了5种通知\r\n// LogAspect.javapackage edu.software.ergoutree.spring6aop.xmlaop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;public class LogAspect &#123;    // 前置通知    public void beforeAdvice(JoinPoint joinPoint) &#123;        System.out.println(&quot;[前置] 方法名: &quot; + joinPoint.getSignature().getName());    &#125;    // 后置通知（无论是否异常都会执行）    public void afterAdvice(JoinPoint joinPoint) &#123;        System.out.println(&quot;[后置] 方法执行完毕&quot;);    &#125;    // 返回通知    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;        System.out.println(&quot;[返回] 结果: &quot; + result);    &#125;    // 异常通知    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) &#123;        System.out.println(&quot;[异常] 错误信息: &quot; + ex.getMessage());    &#125;    // 环绕通知    public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable &#123;        System.out.println(&quot;[环绕前] 参数: &quot; + pjp.getArgs()[0] + &quot;, &quot; + pjp.getArgs()[1]);        Object result = pjp.proceed(); // 执行目标方法        System.out.println(&quot;[环绕后] 结果: &quot; + result);        return result;    &#125;&#125;\r\nxml 配置 bean-aopxml.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6aop.xmlaop&quot;/&gt;    &lt;!-- 定义切面Bean --&gt;    &lt;bean id=&quot;logAspect&quot; class=&quot;edu.software.ergoutree.spring6aop.xmlaop.LogAspect&quot;/&gt;    &lt;!-- AOP配置 --&gt;    &lt;aop:config&gt;        &lt;aop:aspect ref=&quot;logAspect&quot;&gt;            &lt;!-- 定义切入点表达式 --&gt;            &lt;aop:pointcut id=&quot;calculatorMethods&quot;                          expression=&quot;execution(* edu.software.ergoutree.spring6aop.xmlaop.Calculator.*(..))&quot;/&gt;            &lt;!-- 五种通知绑定到切入点 --&gt;            &lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;            &lt;aop:after method=&quot;afterAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;            &lt;aop:after-returning method=&quot;afterReturningAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot; returning=&quot;result&quot;/&gt;            &lt;aop:after-throwing method=&quot;afterThrowingAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot; throwing=&quot;ex&quot;/&gt;            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;!-- 显式声明Calculator类型的Bean --&gt;    &lt;bean id=&quot;calculator&quot; class=&quot;edu.software.ergoutree.spring6aop.xmlaop.CalculatorImpl&quot;/&gt;&lt;/beans&gt;\r\n测试\r\npackage edu.software.ergoutree.spring6aop;import edu.software.ergoutree.spring6aop.xmlaop.Calculator;import edu.software.ergoutree.spring6aop.xmlaop.CalculatorImpl;import org.junit.jupiter.api.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class CalculatroAOPTest &#123;    @Test    public void Test1() &#123;        try (ClassPathXmlApplicationContext context =                     new ClassPathXmlApplicationContext(&quot;bean-aopxml.xml&quot;)) &#123;            CalculatorImpl calculator = context.getBean(&quot;calculator&quot;, CalculatorImpl.class);            // 正常测试            System.out.println(&quot;=== 正常测试 ===&quot;);            calculator.add(5, 3);            calculator.divide(6, 2);            // 异常测试（除数为0）            System.out.println(&quot;\\n=== 异常测试 ===&quot;);            try &#123;                calculator.divide(6, 0);            &#125; catch (ArithmeticException ignored) &#123;&#125;        &#125;    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"SpringFrameworkPart4-IoC基于注解管理bean","url":"/posts/29786.html","content":"IoC 基于注解方式操作 Bean\r\n管理\r\n使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。\r\n使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。\r\n我们可以使用Annotation配置\r\n基于注解配置 Bean\r\n在Spring中，基于注解方式配置Bean，主要应用于项目开发中的组件，eg :\r\nController, Service, DAO.\r\n常用的组件注解的形式有——\r\n\r\n@Component :\r\n表示当前注解标识的是一个组件，相当于定义了一个Bean，它有一个可选的名称，默认是mailService，即小写开头的类名。\r\n@Controller :\r\n表示当前注解标识的是一个控制器，通常用于Servlet\r\n@Service :\r\n表示当前注解标识的是一个处理业务逻辑的类，通常用于Service。\r\n@Repository :\r\n表示当前注解标识的是一个持久化层的类，通常用于DAO类。\r\n\r\n应用实例\r\n首先，在已有jar包的基础上，各种依赖\r\n我们依旧根据“Web层调用Service层，Service层调用DAO层”的分层设计思想，分别在web,\r\nservice, dao包下新建PotUserServlet, PotUserServiceImpl,\r\nPotUserDAOImpl类；并在component包下新建一个CyanComponent类\r\nPotUserServlet类代码如下 :\r\n（使用@Controller注解标记）\r\nimport org.springframework.stereotype.Controller;@Controllerpublic class PotUserServlet &#123;&#125;\r\nPotUserServiceImpl类代码如下 :\r\n(使用@Service注解标记)\r\nimport org.springframework.stereotype.Service;@Servicepublic class PotUserServiceImpl &#123;&#125;\r\nPotUserDAOImpl类代码如下 :\r\n(使用@Repository注解标记)\r\nimport org.springframework.stereotype.Repository;@Repositorypublic class PotUserDAOImpl &#123;&#125;\r\n新建一个配置文件beans_annotation.xml，在配置文件中通过context命名空间配置自动扫描，格式如下\r\n&lt;context:component-scan base-package=\"...\"/&gt; 其中\r\n\r\ncontext:component-scan表示配置对指定包的自动扫描，并创建对象到容器；\r\n属性base-package表示被扫描的包；\r\n配置达到的效果是：Spring\r\n容器创建时，就会扫描base-package对应包下所有的用@Controller, @Service, @Repository, @Component注解标记的类，并将其实例化，放入到IOC容器中。\r\n\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.web&quot;/&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.service&quot;/&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.dao&quot;/&gt;&lt;/beans&gt;\r\n接着，新建一个测试类，用于定义进行单元测试的方法。\r\nTestBeanByAnnotation类代码如下\r\n@SpringBootTestclass SpringNoteBeanApplicationTests &#123;    @Test    public void annotationIntro() &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans_annotation.xml&quot;);        /*            PS :            基于注解配置创建的Bean对象，默认id是类名首字母小写。            eg : PotUserServlet类Bean对象的id = potUserServlet.         */        PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);        PotUserServiceImpl potUserServiceImpl = ioc.getBean(&quot;potUserServiceImpl&quot;, PotUserServiceImpl.class);        PotUserDAOImpl potUserDAOImpl = ioc.getBean(&quot;potUserDAOImpl&quot;, PotUserDAOImpl.class);        System.out.println(&quot;potUserServlet = &quot; + potUserServlet);        System.out.println(&quot;potUserServiceImpl = &quot; + potUserServiceImpl);        System.out.println(&quot;potUserDAOImpl = &quot; + potUserDAOImpl);    &#125;&#125;/*输出如下potUserServlet = edu.software.ergoutree.springnotebean.web.PotUserServlet@fe87dddpotUserServiceImpl = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@4eea94a4potUserDAOImpl = edu.software.ergoutree.springnotebean.dao.PotUserDAOImpl@7c281eb */\r\n注意后面@之后的内容\r\n注意事项：\r\n\r\n若想配置自动扫描一个包下所有的子包，可以使用通配符 * 来指定。eg\r\n:&lt;context:component-scan base-package=\"com.cyan.spring.*\"/&gt;，表示会自动扫描com.cyan.spring包下所有的子包。即使不使用通配符\r\n* ，Spring\r\nIOC容器也会默认扫描base-package所指定包的全部子包。\r\n**Spring的IOC容器不能检测一个使用了@Controller注解的类究竟是否为一个控制器（其他注解同理），即注解的名称只是用于程序员自己识别当前标识的组件类型，Spring\r\nIOC容器只要扫描到注解标识的类就会创建其对象，并不会去识别注解的含义。\r\ncontext:component-scan亦可支持只扫描满足特定要求的类，需要用到resource-pattern属性，格式为:\r\nresource-pattern=“特定要求”/&gt;.\r\neg：\r\n表示只扫描com.cyan.spring.web包下的以”Pot”开头的类。\r\nSpring IOC容器还支持扫描时指定过滤某些类 以及\r\n在扫描时指定扫描某些类。\r\n\r\n指定过滤某些类 :\r\n通过&lt;context:exclude-filter/&gt;标签来指定（该标签要放在&lt;context:component-scan&gt;标签内），其中，type属性表示根据什么规则来进行过滤，expression属性则表示具体要过滤的类型。\r\n&lt;!--    (1) context:component-scan表示配置自动扫描，        base-package=&quot;com.cyan.spring&quot;表示扫描com.cyan.spring下的所有子包。    (2) context:exclude-filter表示配置过滤的类，        type=&quot;annotation&quot;表示以注解类型为规则进行过滤，        expression=&quot;org.springframework.stereotype.Service&quot;表示以该注解标记的类会被过滤掉，不会被扫描。--&gt;&lt;context:component-scan base-package=&quot;com.cyan.spring&quot;&gt;    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt;\r\n指定扫描某些类 :\r\n通过&lt;context:include-filter/&gt;标签来指定（该标签要放在&lt;context:component-scan&gt;标签内），其中，type\r\n属性表示根据什么规则来进行扫描，expression\r\n属性则表示具体要扫描的类型。可见，&lt;context:include-filter/&gt;标签\r\n和\r\n上文的&lt;context:exclude-filter/&gt;标签在格式上非常类似，不过需要注意的一点是，&lt;context:include-filter/&gt;标签在使用时还需要在&lt;context:include-filter/&gt;标签中额外标识一个属性use-default-filters=\"false\"，表示不再使用默认扫描机制。\r\n&lt;!--    表示指定扫描com.cyan.spring包及其所有子包下的————使用了@Service注解标记的类。--&gt;&lt;context:component-scan base-package=&quot;com.cyan.spring&quot; use-default-filters=&quot;false&quot;&gt;    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt;\r\n\r\n使用注解标记后，默认情况下所创建的Bean对象的id =\r\n类名首字母小写；但也可以借助注解的value属性手动指定id值，且value可以省略。注解的value属性（注解中定义的方法实际上对应的是注解的属性，而不是传统意义上的方法。），如下图所示\r\n:\r\n\r\n\r\nimg\r\n\r\n我们可以在配置注解时，给出指定的id值\r\n\r\n\r\nimg\r\n\r\n进入Debug界面，在IOC容器的beanFactory –&gt;\r\nsingletonObjects下，可以看到bean对象的id值已经变成了我们在配置@Service注解时给出的value\r\n= “…” 的值。如下图所示 :\r\n\r\n\r\nimg\r\n\r\n\r\n全注解开发\r\n如果完全不使用 XML 来配置 Spring 的 IoC 容器，我们可以使用 Java\r\n配置类来替代。下面是对之前例子的更改\r\n我们保持之前定义的类不变，即\r\nPotUserServlet、PotUserServiceImpl 和\r\nPotUserDAOImpl，这些类依然使用相应的注解进行标记。\r\n// PotUserServlet.javaimport org.springframework.stereotype.Controller;@Controllerpublic class PotUserServlet &#123;&#125;// PotUserServiceImpl.javaimport org.springframework.stereotype.Service;@Servicepublic class PotUserServiceImpl &#123;&#125;// PotUserDAOImpl.javaimport org.springframework.stereotype.Repository;@Repositorypublic class PotUserDAOImpl &#123;&#125;\r\n我们需要创建一个 Java 配置类来替代 beans_annotation.xml\r\n文件。使用 @Configuration\r\n注解标记该类，表示这是一个配置类，使用 @ComponentScan\r\n注解来指定要扫描的包\r\n@Configuration\r\n\r\n作用：该注解用于标记一个类为 Spring\r\n的配置类，类似于 XML 配置文件。配置类中可以定义 Bean\r\n的创建和依赖关系。\r\n\r\n@ComponentScan\r\n\r\n作用：该注解用于指定 Spring 容器要扫描的包，Spring\r\n会自动扫描这些包及其子包下使用\r\n@Controller、@Service、@Repository、@Component\r\n等注解标记的类，并将它们注册为\r\nBean，并根据@Autowired进行装配。\r\n属性\r\n\r\nbasePackages：指定要扫描的包的名称，可以是一个数组，用于指定多个包。\r\nbasePackageClasses：指定要扫描的包下的某个类，Spring\r\n会扫描该类所在的包及其子包。\r\nincludeFilters 和\r\nexcludeFilters：用于指定扫描时的过滤规则，类似于 XML 中的\r\n和。\r\n\r\n\r\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &#123;    &quot;edu.software.ergoutree.springnotebean.web&quot;,    &quot;edu.software.ergoutree.springnotebean.service&quot;,    &quot;edu.software.ergoutree.springnotebean.dao&quot;&#125;)public class AppConfig &#123;&#125;\r\n测试类也需要进行相应的修改，使用\r\nAnnotationConfigApplicationContext 来加载 Java 配置类\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.junit.jupiter.api.Test;public class TestBeanByAnnotation &#123;    @Test    public void annotationIntro() &#123;        // 使用 AnnotationConfigApplicationContext 加载 Java 配置类        // AnnotationConfigApplicationContext\t   //作用：这是一个 Spring 容器的实现类，用于加载 Java 配置类。通过它可以创建一个基于 Java 配置的 Spring 应用上下文。        ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);        PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);        PotUserServiceImpl potUserServiceImpl = ioc.getBean(&quot;potUserServiceImpl&quot;, PotUserServiceImpl.class);        PotUserDAOImpl potUserDAOImpl = ioc.getBean(&quot;potUserDAOImpl&quot;, PotUserDAOImpl.class);        System.out.println(&quot;potUserServlet = &quot; + potUserServlet);        System.out.println(&quot;potUserServiceImpl = &quot; + potUserServiceImpl);        System.out.println(&quot;potUserDAOImpl = &quot; + potUserDAOImpl);    &#125;&#125;\r\n使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：\r\n\r\n每个Bean被标注为@Component并正确使用@Autowired注入；\r\n配置类被标注为@Configuration和@ComponentScan；\r\n所有Bean均在指定包以及子包内。\r\n\r\n使用@ComponentScan非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置AppConfig位于自定义的顶层包（例如com.itranswarp.learnjava），其他Bean按类别放入子包。\r\n自动装配\r\nSpring\r\n基于注解配置和管理Bean也可实现自动装配，使用的注解主要是两种，分别是@AutoWired和@Resource。\r\n@Autowired自动装配：根据属性类型进行自动装配\r\n使用@Autowired就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，@Autowired大幅简化了注入，因为它不但可以写在set()方法上，还可以直接写在字段上，甚至可以写在构造方法中\r\n@Componentpublic class UserService &#123;    MailService mailService;    public UserService(@Autowired MailService mailService) &#123;        this.mailService = mailService;    &#125;    ...&#125;\r\n当类中的某个属性上使用@Autowired注解标识时，会在IOC容器中查找待装配的组件的类型，如果有唯一的bean对象与之匹配，则使用该bean对象进行装配。\r\n若待装配的属性在IOC容器中对应有多个同类型的bean对象，则使用待装配的属性的属性名作为id值再进行查找，若找到就进行装配，若找不到就抛出异常。\r\n若想在使用@Autowired注解时也指定id值，可以配合@Qualifier注解，@Qualifier：根据名称进行注入，目的在于区别同一接口下有多个实现类，根据类型就无法选择，如下图所示\r\n:\r\n\r\n\r\nimg\r\n\r\n@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）\r\n//@Resource //根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao;\r\n@Value：注入普通类型属性\r\n@Value(value = &quot;abc&quot;)private String name\r\n示例\r\n新建一个beans_Auto.xml配置文件，在配置文件中配置要扫描的包\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.*&quot;/&gt;&lt;/beans&gt;\r\n以PotUserServlet和PotUserServiceImpl类为例，在PotUserServlet类中维护一个PotUserServiceImpl类的属性，使用@Autowired对其进行自动装配。\r\nPotUserServlet类代码如下 :\r\n（在register()方法中打印出属性potUserService，与测试类中获取到的Bean对象进行比较）\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PotUserService &#123;    //Web层调用Service层    @Autowired    private PotUserServiceImpl potUserService;    // 定义用户注册方法的 demo    public void register()&#123;        System.out.println(&quot;PotUserServlet &#x27;s register() is invoked~~~&quot;);        System.out.println(&quot;potUserService = &quot; + potUserService);        potUserService.register();    &#125;&#125;\r\nPotUserServiceImpl类代码如下 :\r\n（注意，此处给出了指定的id值[value=“potUserServiceImpl01”]）\r\nimport org.springframework.stereotype.Service;@Service(value=&quot;potUserServiceImpl01&quot;)public class PotUserServiceImpl &#123;    //定义注册用户的方法    public void register() &#123;        System.out.println(&quot;PotUserServiceImpl &#x27;s register() is invoked~&quot;);    &#125;&#125;\r\n在测试类中定义单元测试方法，在测试类中单独通过 id\r\n获取到PotUserServiceImpl类的 Bean 对象，与\r\nPotUserServlet的register方法中打印出的Bean对象进行对比，查看是否为同一个对象。testAutoAssembleByAutoWired()方法代码如下\r\n@Testpublic void testAutoAssembleByAutoWired() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean_Auto.xml&quot;);    PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);    potUserServlet.register();    PotUserServiceImpl potUserServiceImpl01 = ioc.getBean(&quot;potUserServiceImpl01&quot;, PotUserServiceImpl.class);    System.out.println(&quot;potUserServiceImpl01 = &quot; + potUserServiceImpl01);&#125;/*PotUserServlet &#x27;s register() is invoked~~~potUserService = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@ebda593PotUserServiceImpl &#x27;s register() is invoked~potUserServiceImpl01 = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@ebda593 */\r\n可以看到，由于此时我们在bean_Auto.xml中配置了自动扫描，而使用@Service注解时，我们又给出了value = \"potUserServiceImpl01\"的指定id。所以最终IOC容器中只有一个PotUserServiceImpl类型的\r\nbean\r\n对象[根据类型进行自动装配]，并且其id = potUserServiceImpl01。因此，在测试方法中，我们通过id = potUserServiceImpl01获取到的Bean对象就是自动装配的Bean对象。\r\n\r\n@Resource自动装配\r\n@Resource有两个属性比较重要，分别是name\r\n和\r\ntype；Spring将@Resource注解的name属性解析为bean对象的id值，而将type属性解析为bean对象的类型。\r\n当使用name属性时，采取byName的自动注入策略；当使用type属性时，采取byType的自动注入策略。\r\n若@Resource注解未指定name 和\r\ntype，则优先使用byName注入策略，若匹配不上再采取byType注入策略，若仍然匹配不上，报错。\r\nJDK17.0不支持@Resource注解。\r\n将 Resource 改为 by Type 策略\r\n\r\n\r\nimg\r\n\r\n此时，由于IOC容器中只有唯一一个PotUserServiceImpl类型的Bean对象，所以可以装配成功。\r\n\r\n\r\nimg\r\n\r\n但是，如果此时我们在beans_Auto.xml中再配置一个以上PotUserServiceImpl类型的bean对象\r\n[注意：基于注解配置Bean和基于XML配置Bean，两者配置的Bean对象是互不干扰的，但容器中总共存在的Bean对象的数量会发生改变]\r\n那么再次运行testAutoAssembleByResource()方法，就会报错\r\n当@Resource注解采取“**byType”注入策略时，同样要求当前IOC容器中只有唯一一个该类型的Bean对象。\r\n泛型依赖注入\r\n\r\nSpring提供了基于泛型依赖的注入机制，以更好地管理有继承和相互依赖的Bean的自动装配。\r\n泛型依赖注入需要用到@Autowired注解。\r\n泛型依赖注入，本质是利用了OOP的多态机制。eg :\r\nBasicService中维护有一个使用了泛型的BasicDAO类的属性。\r\n\r\n实例：\r\n首先需要创建下面这五个类，如下图所示 :\r\n（最终要实现——将OrderDAO类型的Bean对象装配给BasicService中维护的BasicDAO类型的属性[多态]）\r\n\r\n\r\nimg\r\n\r\nOrder类代码如下 : （作为JavaBean类）\r\npublic class Order &#123;&#125;\r\nBasicDAO类代码如下 : （定义了save()抽象方法）\r\npublic abstract class BasicDAO&lt;T&gt; &#123;    public abstract void save();&#125;\r\nOrderDAO类代码如下 :\r\n(继承自BasicDAO，并重写BasicDAO的save方法)\r\nimport org.springframework.stereotype.Repository;@Repositorypublic class OrderDAO extends BasicDAO&lt;Order&gt; &#123;    @Override    public void save()&#123;        System.out.println(&quot;OrderDAO &#x27;s save() is invoked~&quot;);    &#125;&#125;\r\nBasicService类代码如下 :\r\n(注意，针对basicDAO属性使用了@Autowire自动装配，最终会将OrderDAO类型的对象引用给basicDAO属性，构成多态)\r\nimport org.springframework.beans.factory.annotation.Autowired;public class BasicService&lt;T&gt; &#123;    @Autowired    private BasicDAO&lt;T&gt; basicDAO;    public void save() &#123;        basicDAO.save();    &#125;&#125;\r\nOrderService类代码如下 : (继承自BasicService)\r\n@Servicepublic class OrderService extends BasicService&lt;Order&gt;&#123;&#125;\r\n然后配置文件 xml 配置一下\r\n测试输出发现 OrderService 被装配，且 bean 对象是\r\nbasicDAO属性，形成了多态\r\n@Test    public void testParameterizedTypeDependencyInjection() &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean_parame.xml&quot;);        OrderService orderService = ioc.getBean(&quot;orderService&quot;, OrderService.class);        orderService.save();    &#125;    // OrderDAO &#x27;s save() is invoked~\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringFrameworkPart6-Spring Framework常用注解","url":"/posts/undefined.html","content":"Spring框架核心注解\r\nSpring的一个核心功能是IOC，就是将Bean初始化加载到容器中，Bean是如何加载到容器的，可以使用Spring注解方式或者Spring\r\nXML配置方式。\r\nSpring注解方式减少了配置文件内容，更加便于管理，并且使用注解可以大大提高了开发效率！\r\n注解本身是没有功能的，和xml一样，注解和xml都是一种元数据，元数据即解释数据的数据，也就是所谓的配置。\r\n我们可以通过\r\norg.springframework.beans.factory.annotation 和\r\norg.springframework.context.annotation 包中的注解来使用\r\nSpring DI 引擎的功能。\r\n\r\nxml用来管理bean；\r\n注解只负责完成属性的注入；\r\n\r\n使用注解需要开启对注解的支持\r\n&lt;context:component-scan base-package=&quot;com.guo&quot;&gt;&lt;/context:component-scan&gt;&lt;context:annotation-config/&gt;\r\n\r\n常用注解\r\n给容器中注入组件\r\n包扫描+组件标注注解\r\n\r\n@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean\r\n\r\n作用：是一个泛化的组件注解，用于标记一个类作为 Spring\r\n容器中的一个组件，让 Spring 能够自动扫描并将其纳入容器管理。\r\n使用：当一个类不属于特定的层（如控制层、业务层、数据访问层），但又需要被\r\nSpring\r\n容器管理时，就可以使用@Component注解。例如，一些工具类、配置类等可以使用该注解。\r\n@Controller、@Service、@Repository都可以称为@Component。@Controller、@Service、@Reponsitory都组合了 @Component注解。为了区分三层不同的作用，因此分别为三层起了不同的名字。\r\n\r\n@Controller：应用在控制层\r\n\r\n作用：用于标记控制层的组件，主要处理用户的请求和视图的展示。它负责接收客户端的请求，调用相应的业务逻辑方法，并将结果返回给客户端。\r\n使用场景：在 Web 应用中，通常用于处理 HTTP\r\n请求的控制器类上。比如，处理用户登录、注册请求，或者根据用户的操作返回相应页面的控制器。\r\n\r\n@Service：应用在service层（业务逻辑层）\r\n\r\n作用：用于标记业务层的组件，主要包含应用的业务逻辑。它通常会调用数据访问层的方法来完成数据库操作，并对数据进行处理和业务规则的应用。\r\n使用场景：在处理复杂业务逻辑的服务类上使用，如用户服务、订单服务等。例如，在电商应用中，计算订单总价、处理库存更新等业务逻辑就可以放在@Service注解标记的类中。\r\n\r\n@Repository：应用在dao层（实现类）（数据访问层）\r\n\r\n作用：用于标记数据访问层的组件，主要负责与数据库进行交互，执行数据库的增删改查操作。它提供了一种将数据访问逻辑封装起来的方式，使得业务层可以方便地调用数据访问方法。\r\n使用场景：在与数据库交互的 DAO（Data Access\r\nObject）类上使用。比如，在用户管理系统中，实现用户数据的存储、查询、更新和删除操作的类就可以使用@Repository注解。\r\n\r\n\r\n配置相关注解\r\n配置管理\r\n\r\n@Configuration\r\n\r\n作用：标记类为配置类，替代XML配置文件。配置类中可以声明@Bean方法，Spring容器会将其作为Bean定义的来源。\r\n使用：\r\n@Configurationpublic class AppConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new HikariDataSource();    &#125;&#125;\r\n\r\n@ComponentScan\r\n\r\n作用：自动扫描指定包路径下的组件（如@Component,\r\n@Service, @Repository等），并将其注册为Spring\r\nBean。\r\n属性：\r\n\r\nbasePackages：指定扫描的包路径（支持多个）\r\nexcludeFilters：排除不需要扫描的组件\r\n\r\n使用\r\n@Configuration@ComponentScan(basePackages = &quot;com.example.service&quot;,               excludeFilters = @ComponentScan.Filter(type=FilterType.ANNOTATION, classes=Controller.class))public class AppConfig &#123;&#125;\r\n\r\n@AliasFor\r\n\r\n作用：为注解属性声明别名（用于元注解组合）主要用于元注解组合时实现属性覆盖\r\n\r\n@PropertySource\r\n\r\n作用：加载外部属性文件到Spring Environment\r\n特性：\r\n\r\n支持classpath:、file:等前缀\r\n支持多个文件（Spring 4+使用@PropertySources）\r\n\r\n使用：\r\n@Configuration@PropertySource(&quot;classpath:app.properties&quot;)@PropertySource(value = &quot;file:/etc/config/override.properties&quot;, ignoreResourceNotFound = true)public class AppConfig &#123; ... &#125;\r\n扩展：@PropertySources\r\n\r\n可以使用此注解指定多个 @PropertySource 配置：\r\n@Configuration@PropertySources(&#123;     @PropertySource(&quot;classpath:/annotations.properties&quot;),    @PropertySource(&quot;classpath:/vehicle-factory.properties&quot;)&#125;)class VehicleFactoryConfig &#123;&#125;\r\n注意，自 Java 8\r\n以来，可以通过上述重复注解的特性来实现同样的功能。\r\n\r\n\r\n\r\nBean管理\r\n\r\n@Bean：导入第三方包里面的注解\r\n\r\n作用：@Bean注解通常用于在 Java 配置类中定义\r\nBean。当你需要将第三方库中的类或者你自己编写的但不适合用组件扫描注解标注的类纳入\r\nSpring\r\n容器管理时，就可以使用@Bean注解。它允许你以编程的方式创建和配置\r\nBean。\r\n特性：\r\n\r\n方法名默认作为Bean名称\r\n支持initMethod/destroyMethod配置生命周期方法\r\n\r\n使用\r\n@Configurationpublic class DataSourceConfig &#123;    @Bean(name = &quot;primaryDataSource&quot;, initMethod = &quot;init&quot;)    public DataSource dataSource() &#123;        return new HikariDataSource();    &#125;&#125;\r\n\r\n@Conditional：\r\n\r\n作用：这是一个元注解，用于自定义条件化创建\r\nBean。可以根据指定的条件决定是否创建某个 Bean。基于条件决定是否注册\r\nBean（自定义条件逻辑）。它需要配合一个条件类（Condition\r\nClass）使用，条件类通过实现Condition接口，定义了Bean加载的条件逻辑。\r\n使用：\r\n@Component@Conditional(MyCondition.class)public class MyConditionalComponent &#123;    public void doSomething() &#123;        System.out.println(&quot;Conditional component...&quot;);    &#125;&#125;\r\n在上述代码中，MyConditionalComponent类仅在MyCondition条件满足时才会被加载。这种方式使得开发者可以根据运行时环境或配置动态决定Bean的加载，增强了应用的灵活性。通过这种方式，开发者可以实现按需加载Bean，从而优化应用的性能和资源利用率。\r\n\r\n@ConditionalOnProperty（Spring\r\nBoot特有）\r\n\r\n作用：根据配置文件中的属性值来决定是否创建 Bean。\r\n```java import\r\norg.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\r\nimport org.springframework.context.annotation.Bean; import\r\norg.springframework.context.annotation.Configuration;\r\n@Configuration public class\r\nPropertyConfig { @Bean\r\n@ConditionalOnProperty(name =\r\n“myapp.feature.enabled”, havingValue = “true”) public MyFeature\r\nmyFeature() { return new MyFeature(); } }     在这个例子中，只有当配置文件（如`application.properties`）中`myapp.feature.enabled`属性的值为`true`时，`myFeature` Bean 才会被创建。  - @Order  - 作用：定义Bean的加载/执行顺序（数值越小优先级越高）  - **应用场景**：    - 多个Bean实现同一接口时指定注入顺序    - AOP切面的执行顺序  - 使用：    ```java    @Component    @Order(1)    public class ValidationFilter implements Filter &#123; ... &#125;\r\n\r\n@ApplicationScope\r\n\r\n作用：定义 Bean 的作用域为 ServletContext 级别\r\n\r\n@Scope：Bean作用域注解\r\n\r\n作用：@Scope注解用于定义Bean的作用域。它支持以下几种作用域：\r\n取值\r\n\r\nSingleton：单例作用域，Spring容器中只有一个实例（默认值）。\r\nPrototype：原型作用域，每次请求都会创建一个新的实例。\r\nSession：会话作用域，每个用户会话对应一个实例。\r\nRequest：请求作用域，每个HTTP请求对应一个实例。\r\n\r\n使用：\r\n@Component@Scope(&quot;prototype&quot;)public class MyComponent &#123;    public void doSomething() &#123;        System.out.println(&quot;Doing something...&quot;);    &#125;&#125;\r\n在上述代码中，MyComponent类被标记为原型作用域。这意味着每次请求该Bean时，Spring都会创建一个新的实例。这种方式适用于需要独立实例的场景，例如工具类或状态管理类。通过@Scope注解，开发者可以灵活地控制Bean的生命周期，从而更好地满足应用的需求。\r\n扩展：\r\n@RequestScope\r\n/ @SessionScope\r\n/ @ApplicationScope\r\n\r\n作用：Web作用域的快捷注解（Spring 4+）\r\n等价于：@Scope(\"request\"),\r\n@Scope(\"session\"), @Scope(\"application\")\r\n\r\n\r\n@PostConstruct\r\n\r\n作用：@PostConstruct注解用于定义Bean初始化后的方法。被标记的方法会在Bean实例化并注入依赖后自动执行，通常用于执行初始化逻辑。\r\n使用：\r\n@Componentpublic class MyComponent &#123;    @PostConstruct    public void init() &#123;        System.out.println(&quot;Bean initialized...&quot;);    &#125;&#125;\r\nMyComponent类的init()方法被标记为初始化后执行。这意味着在Bean实例化并注入依赖后，Spring会自动调用该方法。这种方式使得开发者可以在Bean初始化阶段执行必要的逻辑，例如资源分配或状态初始化。通过这种方式，开发者可以确保Bean在使用前处于正确的状态。\r\n\r\n@PreDestroy\r\n\r\n作用：@PreDestroy注解用于定义Bean销毁前的方法。被标记的方法会在Bean销毁前自动执行，通常用于执行清理逻辑。\r\n使用和@PostConstruct类似\r\n\r\n@DependsOn：依赖关系管理\r\n\r\n作用：强制指定当前Bean的依赖项，确保依赖项先初始化\r\n使用\r\n@Bean@DependsOn(&quot;databaseInitializer&quot;)public DataSource dataSource() &#123; ... &#125;\r\n\r\n@Description\r\n\r\n作用：为Bean添加描述信息（通常用于JMX等管理场景）\r\n\r\n@Value\r\n\r\n作用：在Spring应用中，配置文件（如application.properties）通常用于存储应用的配置信息。通过@Value注解，开发者可以将配置文件中的属性值注入到Bean中。\r\n\r\n$&#123;&#125;：从Environment中取值\r\n#&#123;&#125;：SpEL表达式\r\n\r\n使用：\r\n@Componentpublic class MyComponent &#123;    @Value(&quot;$&#123;my.property&#125;&quot;)    private String property;&#125;\r\n在上述代码中，@Value注解将配置文件中的my.property属性值注入到property字段中。这种方式使得开发者可以灵活地从配置文件中读取配置信息，而无需手动解析配置文件。通过这种方式，开发者可以实现配置的动态化管理，从而增强应用的灵活性。\r\n\r\n@Profile\r\n\r\n作用：在多环境开发中，某些Bean可能仅在特定环境下需要被加载。通过@Profile注解，开发者可以定义Bean所属的环境，例如开发环境（dev）、测试环境（test）或生产环境（prod）。\r\n\r\n\r\nImport组件导入\r\n\r\n@Import：导入其他配置类或组件（如@Configuration类）\r\n\r\n作用：将配置类、普通类或其他组件导入到当前 Spring\r\n容器中，支持导入 @Configuration\r\n类、ImportSelector 实现类和\r\nImportBeanDefinitionRegistrar 实现类\r\n使用：\r\n@Import(SomeService.class)@Configurationpublic class AppConfig &#123;    // ...&#125;\r\n这样，SomeService 类就会被注册为 Spring 容器中的一个\r\nbean。\r\n使用ImportSelector动态导入\r\nImportSelector\r\n是一个接口，可以实现动态选择要导入的类：\r\npublic class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        // 根据条件动态返回要导入的类        return new String[] &#123;            &quot;com.example.ServiceA&quot;,            &quot;com.example.ServiceB&quot;        &#125;;    &#125;&#125;@Import(MyImportSelector.class)@Configurationpublic class AppConfig &#123;    // ...&#125;\r\n\r\n@ImportResource\r\n\r\n作用：导入 XML 配置文件\r\n使用：\r\n@Configuration@ImportResource(&quot;classpath:legacy-config.xml&quot;)public class HybridConfig &#123; ... &#125;\r\n\r\n\r\n依赖注入注解\r\n\r\n@Autowired\r\n\r\n作用：自动注入依赖（默认按类型匹配），@Autowired 是\r\nSpring 中最常用的依赖注入注解，其主要功能是自动装配\r\nBean。它可以作用于构造函数、字段、方法之上。默认情况下，它会依据类型进行自动装配，如果存在多个相同类型的\r\nBean，就会抛出异常。\r\n\r\n@Qualifier\r\n\r\n作用：当存在多个相同类型的 Bean 时，@Autowired\r\n仅依据类型注入会产生歧义，此时就需要使用 @Qualifier\r\n注解来指定要注入的 Bean 的名称，以此解决歧义问题。\r\n使用场景：\r\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;interface MyComponent &#123;&#125;class MyComponentImpl1 implements MyComponent &#123;&#125;class MyComponentImpl2 implements MyComponent &#123;&#125;@Servicepublic class MyService &#123;    private MyComponent myComponent;    @Autowired    @Qualifier(&quot;myComponentImpl1&quot;)    public MyService(MyComponent myComponent) &#123;        this.myComponent = myComponent;    &#125;    // 其他方法&#125;\r\n\r\n@Resource\r\n\r\n作用：它默认按照名称进行注入，如果找不到匹配的名称，就会按照类型进行注入。是Java标准注解，用于按名称注入依赖关系。与@Autowired类似，@Resource也可以用于字段、构造函数或方法。不同之处在于，@Resource支持通过name属性指定注入的Bean名称，这在存在多个同类型Bean时非常有用。\r\n\r\n@Inject\r\n\r\n作用：@Inject是Java标准注解，用于声明依赖注入。它与@Autowired功能类似都是依据类型进行注入，但遵循Java标准规范。不过，@Inject\r\n没有 required 属性，即默认情况下注入的 Bean\r\n必须存在。在Spring环境中，@Inject和@Autowired可以互换使用，但在某些情况下（例如与Java\r\nEE集成时），@Inject可能是更好的选择。\r\n\r\n@Value\r\n\r\n作用：@Value 注解主要用于将外部配置的值注入到 Bean\r\n的字段中，这些外部配置可以来自属性文件、环境变量等。（如@Value(\"$&#123;key&#125;\")或\r\nSpEL 表达式）\r\n\r\n@Primary\r\n\r\n作用：当容器中存在多个相同类型的 Bean 时，使用\r\n@Autowired 进行依赖注入会产生歧义。@Primary\r\n注解的作用就是指定在这种情况下优先注入被该注解标记的 Bean。\r\n\r\n@Required\r\n\r\n作用：@Required 注解用于标记 Bean\r\n的属性为必需的，即要求在配置 Bean 时必须为该属性注入值。不过，从 Spring\r\n5.1\r\n开始，该注解已被标记为过时，推荐使用构造器注入来确保依赖的必需性。\r\n使用：构造器注入能在对象创建时就确保依赖的注入，避免了在运行时出现依赖未注入的问题，提高了代码的健壮性。\r\nimport org.springframework.stereotype.Component;@Componentclass MyBean &#123;    private final String requiredProperty;    public MyBean(String requiredProperty) &#123;        this.requiredProperty = requiredProperty;    &#125;&#125;\r\n\r\n@Lookup\r\n\r\n作用：@Lookup\r\n注解用于声明查找方法，主要用于获取原型作用域的 Bean。在 Spring 中，单例\r\nBean\r\n默认会在容器启动时创建，并且在整个应用生命周期中只有一个实例。而原型作用域的\r\nBean 每次被请求时都会创建一个新的实例。当单例 Bean 需要使用原型作用域的\r\nBean 时，使用 @Lookup 注解可以确保每次获取到的都是新的原型\r\nBean 实例。\r\n\r\n\r\nAOP与切面编程\r\n\r\n@Aspect\r\n\r\n作用：该注解用于把一个类标记为切面类。切面类里包含了切入点和通知，这些可以对特定的方法进行增强。\r\n\r\n@Pointcut\r\n\r\n作用：@Pointcut\r\n注解用于定义切点表达式，以此指定切入点。切入点明确了在哪些方法执行时会触发通知。\r\n\r\n@Before\r\n\r\n作用：@Before\r\n注解定义的是前置通知，它会在目标方法执行之前执行。\r\n\r\n@After\r\n\r\n作用：@After\r\n注解定义的是后置通知，无论目标方法是否抛出异常，它都会在目标方法执行之后执行。\r\n\r\n@AfterReturning\r\n\r\n作用：@AfterReturning\r\n注解定义的是返回通知，它会在目标方法成功返回后执行。\r\n\r\n@AfterThrowing\r\n\r\n作用：@AfterThrowing\r\n注解定义的是异常通知，它会在目标方法抛出异常后执行\r\n\r\n@Around\r\n\r\n作用：@Around\r\n注解定义的是环绕通知，它能够完全控制目标方法的执行，既可以在目标方法执行前后添加额外的逻辑，还能决定是否执行目标方法。\r\n\r\n@EnableAspectJAutoProxy\r\n\r\n作用：@EnableAspectJAutoProxy 注解用于启用 AspectJ\r\n自动代理功能，它需要和 @Configuration 注解一起使用，这样\r\nSpring 就能自动识别并应用切面类。\r\n\r\n@DeclareParents\r\n\r\n作用：@DeclareParents\r\n注解用于引入其他接口到目标类，从而实现接口增强。通过这个注解，目标类可以在不修改原有代码的情况下拥有新的接口和实现。\r\n使用：\r\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;import org.springframework.stereotype.Component;interface NewFeature &#123;    void performNewFeature();&#125;class NewFeatureImpl implements NewFeature &#123;    @Override    public void performNewFeature() &#123;        System.out.println(&quot;Performing new feature&quot;);    &#125;&#125;@Aspect@Componentpublic class IntroductionAspect &#123;    @DeclareParents(value = &quot;com.example.service.*+&quot;, defaultImpl = NewFeatureImpl.class)    public static NewFeature newFeature;&#125;\r\n在这个例子中，IntroductionAspect 切面类使用\r\n@DeclareParents 注解将 NewFeature 接口引入到\r\ncom.example.service 包下的所有类中，默认实现为\r\nNewFeatureImpl 类。\r\n\r\n\r\nJSON常用注解\r\n\r\n@JsonIgnoreProperties\r\n\r\n作用：此注解是类注解，作用是json序列化时将java\r\nbean中的一些属性忽略掉，序列化和反序列化都受影响。\r\n使用：\r\n//生成json时将name和age属性过滤@JsonIgnoreProperties(&#123;&quot;name&quot;&#125;,&#123;&quot;age&quot;&#125;)public class  user &#123;     private  String name;    private int age;&#125;\r\n\r\n@JsonIgnore\r\n\r\n作用：此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。\r\n\r\n@JsonFormat\r\n\r\n作用：此注解用于属性或者方法上（最好是属性上），格式化日期/时间类型字段\r\n参数：\r\n\r\nshape：数据类型（如Shape.STRING）\r\npattern：自定义格式（如\"yyyy-MM-dd HH:mm\"）\r\n\r\n使用：\r\npublic class Event &#123;    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy/MM/dd&quot;)    private LocalDate eventDate;&#125;\r\n\r\n@JsonInclude\r\n\r\n作用：控制序列化时包含属性的规则\r\n取值：\r\n\r\nInclude.NON_NULL：排除null值\r\nInclude.NON_EMPTY：排除空值/空集合\r\n\r\n\r\n@JsonSerialize\r\n\r\n作用：@JsonSerialize 注解通常用在属性或者\r\ngetter 方法上，其主要作用是在对象序列化为 JSON\r\n格式时，嵌入自定义的序列化逻辑。在处理一些特殊类型的数据或者需要对数据进行特定格式转换时，这个注解就非常有用\r\n\r\n@JsonDeserialize\r\n\r\n作用：@JsonDeserialize 注解用于属性或者\r\nsetter 方法上，它的作用是在将 JSON 数据反序列化为 Java\r\n对象时，嵌入自定义的反序列化逻辑。当 JSON 数据的格式和 Java\r\n对象的属性类型不完全匹配，或者需要对数据进行一些预处理时，就可以使用这个注解。\r\n\r\n@Transient\r\n\r\n作用：在使用对象关系映射（ORM）框架（如 Hibernate）时，如果一个 Java\r\n类的属性并非对应数据库表中的字段，就需要使用 @Transient\r\n注解来标记这个属性。如果不标记，ORM\r\n框架默认会将其视为数据库表字段，可能会导致错误。\r\n\r\n@JsonIgnoreType\r\n\r\n作用：@JsonIgnoreType\r\n注解标注在类上，当其他类将该类作为属性时，这个属性在序列化过程中会被忽略，不会出现在生成的\r\nJSON 数据中\r\n\r\n\r\n事件，异步与定时任务\r\n\r\n@EnableAsync\r\n\r\n作用：配置类中通过此注解开启对异步任务的支持；当你在配置类上添加了这个注解后，Spring\r\n会自动扫描带有 @Async\r\n注解的方法，并将这些方法的执行交给线程池来处理，从而实现异步执行。\r\n\r\n@Async：\r\n\r\n作用：@Async\r\n注解用于标记一个方法为异步方法。当调用这个方法时，Spring\r\n会将该方法的执行从当前线程中分离出来，放到线程池中异步执行，调用者线程不会被阻塞，可以继续执行后续的代码。\r\n使用：\r\nimport org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService &#123;    @Async    public void asyncMethod() &#123;        try &#123;            // 模拟耗时操作            Thread.sleep(3000);            System.out.println(&quot;异步方法执行完成&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n在调用 asyncMethod\r\n时，调用者线程不会等待该方法执行完毕，而是会继续执行后续代码。\r\n\r\n@EnableScheduling\r\n\r\n作用：此注解同样用在配置类上，用于开启 Spring\r\n的定时任务调度功能。添加该注解后，Spring 会自动扫描带有\r\n@Scheduled\r\n注解的方法，并按照指定的时间规则定时执行这些方法。\r\n\r\n@Scheduled：\r\n\r\n作用：@Scheduled\r\n注解用于标记一个方法为定时任务方法，它可以指定方法的执行时间规则。该注解支持多种时间表达式，常见的有\r\nfixedRate、fixedDelay 和 cron\r\n等。\r\n属性：\r\n\r\nfixedRate：指定方法执行的时间间隔，单位为毫秒。无论方法执行时间长短，下一次执行都会在上一次开始后的指定时间间隔后启动。\r\nfixedDelay：指定方法执行完成后，下一次执行的延迟时间，单位为毫秒。即上一次方法执行完毕后，等待指定的时间再执行下一次。\r\ncron：使用 Cron\r\n表达式来指定方法的执行时间，Cron\r\n表达式可以更灵活地定义执行时间规则。\r\n\r\n\r\n\r\nEnable***注解\r\n这些注解主要是用来开启对xxx的支持：\r\n\r\n@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；\r\n@EnableAsync：开启异步方法的支持；\r\n@EnableScheduling：开启计划任务的支持；\r\n@EnableWebMvc：开启web\r\nMVC的配置支持；\r\n@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；\r\n@EnableJpaRepositories：开启对SpringData\r\nJPA Repository的支持；\r\n@EnableTransactionManagement：开启注解式事务的支持；\r\n@EnableCaching：开启注解式的缓存支持；\r\n\r\n测试相关\r\n\r\n@RunWith\r\n\r\n作用：运行器，Spring中通常用于对JUnit的支持\r\n\r\n@ContextConfiguration\r\n\r\n作用：用来加载配置配置文件，其中classes属性用来加载配置类。\r\n使用\r\n@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath*:/*.xml&quot;&#125;)public class CDPlayerTest &#123;&#125;\r\n@ContextConfiguration这个注解通常与@RunWith(SpringJUnit4ClassRunner.class)联合使用用来测试。\r\n@ContextConfiguration括号里的locations\r\n=\r\n{“classpath:/.xml”}就表示将classpath路径里所有的xml文件都包括进来，自动扫描的bean就可以拿到，此时就可以在测试类中使用@Autowired注解来获取之前自动扫描包下的所有bean。\r\n\r\n@SpringBootTest\r\n\r\n作用：启动完整Spring应用上下文\r\n参数：\r\n\r\nwebEnvironment：定义Web环境模式\r\nclasses：显式指定配置类\r\n\r\n示例：\r\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)class ApplicationIntegrationTests &#123; ... &#125;\r\n\r\n@MockBean\r\n\r\n作用：向应用上下文注入Mock对象（替换现有Bean）\r\n示例：\r\n\r\n@SpringBootTestclass UserServiceTest &#123;    @MockBean    private UserRepository userRepository;        @Autowired    private UserService userService;&#125;\r\n@SpyBean\r\n\r\n作用：对现有Bean进行部分Mock（保留原始实现）\r\n示例：\r\n\r\n@SpyBeanprivate EmailService emailService;\r\n@TestConfiguration\r\n\r\n作用：定义测试专用的配置类\r\n示例\r\n@TestConfigurationstatic class TestConfig &#123;    @Bean    public Clock testClock() &#123;        return Clock.fixed(Instant.now(), ZoneId.systemDefault());    &#125;&#125;\r\n\r\n\r\n其他注解\r\n\r\n@EqualsAndHashCode（Lombok）\r\n\r\n作用：自动生成 equals() 和 hashCode()\r\n方法，避免手动编写冗余代码。\r\n参数：\r\n\r\ncallSuper：是否包含父类的字段（默认false）。若为true，生成的方法会调用super.equals()。\r\nexclude/of：排除或指定参与计算的字段。\r\n\r\n注意：需添加 Lombok 依赖\r\n使用\r\n@EqualsAndHashCode(callSuper = true, exclude = &quot;age&quot;)public class Person extends Human &#123;    private String name;    private int age;&#125;\r\n\r\n@XmlAccessorType (JAXB)\r\n\r\n作用：控制 JAXB 如何将 Java 对象与 XML\r\n互相转换，指定字段/属性的访问方式。类级别的注解，定义这个类中何种类型需要映射到XML。\r\n属性：\r\n\r\nXmlAccessType.FIELD：映射这个类中的所有字段到XML\r\nXmlAccessType.PROPERTY：映射这个类中的属性（get/set方法）到XML\r\nXmlAccessType.PUBLIC_MEMBER：将这个类中的所有public的field或property同时映射到XML（默认）\r\nXmlAccessType.NONE：不映射\r\n\r\n\r\n\r\n引用自Spring Framework\r\n的详细注解大全的注解表格\r\n核心容器与配置\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Configuration\r\n标记类为配置类，替代 XML 配置\r\n\r\n\r\n@Bean\r\n在配置类中声明一个 Bean，由 Spring 容器管理\r\n\r\n\r\n@Component\r\n通用组件注解，标记类为 Spring 管理的 Bean\r\n\r\n\r\n@ComponentScan\r\n自动扫描并注册指定包下的组件（如@Component、@Service等）\r\n\r\n\r\n@Import\r\n导入其他配置类或组件（如@Configuration类）\r\n\r\n\r\n@PropertySource\r\n加载外部属性文件（如.properties或.yml）\r\n\r\n\r\n@Lazy\r\n延迟初始化 Bean\r\n\r\n\r\n@Scope\r\n定义 Bean 的作用域（如singleton\r\n、prototype 、request等）\r\n\r\n\r\n@DependsOn\r\n指定当前 Bean 依赖的其他 Bean，确保初始化顺序\r\n\r\n\r\n@Profile\r\n指定 Bean\r\n或配置仅在特定环境下生效（如dev、prod）\r\n\r\n\r\n@Conditional\r\n基于条件决定是否注册 Bean（自定义条件逻辑）\r\n\r\n\r\n@Service\r\n标记服务层组件（@Component的特化）\r\n\r\n\r\n@Repository\r\n标记数据访问层组件（@Component的特化），支持异常转换\r\n\r\n\r\n@Controller\r\n标记 MVC 控制器组件（@Component的特化）\r\n\r\n\r\n@Role\r\n定义 Bean 的角色（如ROLE_APPLICATION\r\n、ROLE_INFRASTRUCTURE）\r\n\r\n\r\n@Description\r\n为 Bean 添加描述信息（通常用于监控或文档）\r\n\r\n\r\n@PropertySources\r\n组合多个@PropertySource\r\n\r\n\r\n@ImportResource\r\n导入 XML 配置文件\r\n\r\n\r\n@Order\r\n定义 Bean 的加载顺序（值越小优先级越高）\r\n\r\n\r\n@AliasFor\r\n为注解属性声明别名（用于元注解组合）\r\n\r\n\r\n@RequestScope\r\n定义 Bean 的作用域为 HTTP 请求级别\r\n\r\n\r\n@SessionScope\r\n定义 Bean 的作用域为 HTTP 会话级别\r\n\r\n\r\n@ApplicationScope\r\n定义 Bean 的作用域为 ServletContext 级别\r\n\r\n\r\n\r\n依赖注入（DI）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Autowired\r\n自动注入依赖（默认按类型匹配）\r\n\r\n\r\n@Qualifier\r\n按名称指定注入的 Bean，配合@Autowired使用\r\n\r\n\r\n@Primary\r\n当存在多个同类型 Bean 时，优先注入被标记的 Bean\r\n\r\n\r\n@Value\r\n注入属性值（如@Value(\"$&#123;key&#125;\")或 SpEL 表达式）\r\n\r\n\r\n@Required\r\n标记 Bean 属性为必需（已过时，推荐使用构造器注入）\r\n\r\n\r\n@Lookup\r\n声明查找方法，用于获取原型作用域的 Bean\r\n\r\n\r\n@Resource\r\nJSR-250 注解，按名称注入依赖（类似@Autowired +\r\n@Qualifier）\r\n\r\n\r\n@Inject\r\nJSR-330\r\n注解（需引入javax.inject），功能类似@Autowired\r\n\r\n\r\n\r\nAOP 与切面编程\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Aspect\r\n标记类为切面类\r\n\r\n\r\n@Pointcut\r\n定义切点表达式，指定切入点\r\n\r\n\r\n@Before\r\n在目标方法执行前执行\r\n\r\n\r\n@After\r\n在目标方法执行后执行（无论是否抛出异常）\r\n\r\n\r\n@AfterReturning\r\n在目标方法成功返回后执行\r\n\r\n\r\n@AfterThrowing\r\n在目标方法抛出异常后执行\r\n\r\n\r\n@Around\r\n环绕通知，可完全控制目标方法执行\r\n\r\n\r\n@EnableAspectJAutoProxy\r\n启用 AspectJ 自动代理（需配合@Configuration）\r\n\r\n\r\n@DeclareParents\r\n引入其他接口到目标类（实现接口增强）\r\n\r\n\r\n\r\n数据访问与事务\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Transactional\r\n声明事务管理（类或方法级别），可配置隔离级别、传播行为等\r\n\r\n\r\n@Repository\r\n标记数据访问层（DAO）组件，支持异常转换（如将 SQL 异常转换为 Spring\r\n异常）\r\n\r\n\r\n@PersistenceContext\r\n注入 JPA 的EntityManager\r\n\r\n\r\n@PersistenceUnit\r\n注入 JPA 的EntityManagerFactory\r\n\r\n\r\n@Sql\r\n在测试方法执行前 / 后运行 SQL 脚本\r\n\r\n\r\n@SqlMergeMode\r\n控制测试类与方法的@Sql注解合并方式\r\n\r\n\r\n\r\nWeb/MVC 相关\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Controller\r\n标记类为 MVC 控制器\r\n\r\n\r\n@RequestMapping\r\n映射 HTTP 请求路径（支持method\r\n、produces等属性）\r\n\r\n\r\n@RequestParam\r\n绑定请求参数到方法参数\r\n\r\n\r\n@PathVariable\r\n绑定 URL 路径变量到方法参数\r\n\r\n\r\n@RequestBody\r\n将请求体反序列化为对象（如 JSON/XML）\r\n\r\n\r\n@ResponseBody\r\n将方法返回值序列化为响应体（如 JSON）\r\n\r\n\r\n@ModelAttribute\r\n绑定请求参数到模型对象，或添加模型数据\r\n\r\n\r\n@SessionAttributes\r\n将模型属性存储到 HTTP Session 中\r\n\r\n\r\n@CookieValue\r\n绑定 Cookie 值到方法参数\r\n\r\n\r\n@RequestHeader\r\n绑定请求头到方法参数\r\n\r\n\r\n@ExceptionHandler\r\n处理控制器内的异常\r\n\r\n\r\n@ControllerAdvice\r\n全局异常处理类，可结合@ExceptionHandler\r\n\r\n\r\n@InitBinder\r\n自定义请求参数绑定逻辑\r\n\r\n\r\n@CrossOrigin\r\n允许跨域请求（Spring 4.2 + 支持）\r\n\r\n\r\n@RestController\r\n组合@Controller和@ResponseBody（Spring\r\n4.0+）\r\n\r\n\r\n@GetMapping/@PostMapping\r\n@RequestMapping的快捷方式（如@GetMapping(\"/path\")）\r\n\r\n\r\n@PutMapping\r\n@RequestMapping(method = PUT)的快捷方式\r\n\r\n\r\n@DeleteMapping\r\n@RequestMapping(method = DELETE)的快捷方式\r\n\r\n\r\n@PatchMapping\r\n@RequestMapping(method = PATCH)的快捷方式\r\n\r\n\r\n@MatrixVariable\r\n绑定 URL 矩阵变量（如/users;id=1）\r\n\r\n\r\n@RestControllerAdvice\r\n组合@ControllerAdvice和@ResponseBody\r\n\r\n\r\n@ResponseStatus\r\n定义 HTTP\r\n响应状态码（如@ResponseStatus(HttpStatus.NOT_FOUND)）\r\n\r\n\r\n\r\n测试相关\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@ContextConfiguration\r\n指定测试类的 Spring 配置（如 XML 或配置类）\r\n\r\n\r\n@WebAppConfiguration\r\n标记测试类需要加载 Web 应用上下文\r\n\r\n\r\n@DirtiesContext\r\n标记测试后需要重置 Spring 上下文\r\n\r\n\r\n@TestExecutionListeners\r\n自定义测试执行监听器\r\n\r\n\r\n@TestPropertySource\r\n为测试类指定属性文件或键值对\r\n\r\n\r\n@DynamicPropertySource\r\n动态注册测试属性（如集成测试中的数据库端口）\r\n\r\n\r\n@Sql\r\n在测试方法执行前 / 后运行 SQL 脚本\r\n\r\n\r\n\r\n事件与异步\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@EventListener\r\n标记方法为事件监听器（监听 Spring 事件）\r\n\r\n\r\n@Async\r\n标记方法为异步执行（需启用@EnableAsync）\r\n\r\n\r\n@EnableAsync\r\n启用异步方法执行支持\r\n\r\n\r\n@Scheduled\r\n定义定时任务（需启用@EnableScheduling）\r\n\r\n\r\n@EnableScheduling\r\n启用定时任务支持\r\n\r\n\r\n\r\n消息与 WebSocket\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@MessageMapping\r\n映射消息到处理方法（如 WebSocket 消息）\r\n\r\n\r\n@SubscribeMapping\r\n处理订阅请求（如 STOMP 协议）\r\n\r\n\r\n@SendTo\r\n指定方法返回值的发送目标（如广播消息）\r\n\r\n\r\n@DestinationVariable\r\n绑定消息目标路径中的变量\r\n\r\n\r\n@MessageExceptionHandler\r\n处理消息处理过程中的异常\r\n\r\n\r\n\r\n缓存相关\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Cacheable\r\n缓存方法结果（需启用@EnableCaching）\r\n\r\n\r\n@CachePut\r\n更新缓存\r\n\r\n\r\n@CacheEvict\r\n清除缓存\r\n\r\n\r\n@Caching\r\n组合多个缓存操作\r\n\r\n\r\n@CacheConfig\r\n在类级别统一配置缓存属性\r\n\r\n\r\n@EnableCaching\r\n启用缓存支持\r\n\r\n\r\n\r\n校验与格式化\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@Valid\r\n触发 Bean 验证（JSR-303/JSR-349 规范，需引入 Hibernate\r\nValidator）\r\n\r\n\r\n@Validated\r\nSpring 的校验注解，支持分组校验\r\n\r\n\r\n@DateTimeFormat\r\n格式化日期时间字段（如@DateTimeFormat(pattern = \"yyyy-MM-dd\")）\r\n\r\n\r\n@NumberFormat\r\n格式化数字字段\r\n\r\n\r\n\r\nJSR 标准注解支持\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@PostConstruct\r\nJSR-250 注解，标记 Bean 初始化后执行的方法\r\n\r\n\r\n@PreDestroy\r\nJSR-250 注解，标记 Bean 销毁前执行的方法\r\n\r\n\r\n@Resource\r\nJSR-250 注解，按名称注入依赖（类似@Autowired +\r\n@Qualifier）\r\n\r\n\r\n@Inject\r\nJSR-330\r\n注解（需引入javax.inject），功能类似@Autowired\r\n\r\n\r\n@Named\r\nJSR-330\r\n注解，功能类似@Component或@Qualifier\r\n\r\n\r\n\r\n空安全注解\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@NonNull\r\n标记字段、参数或返回值不可为null（编译时检查）\r\n\r\n\r\n@Nullable\r\n标记字段、参数或返回值可为null\r\n\r\n\r\n@NonNullApi\r\n包级别注解，默认所有参数和返回值不可为null\r\n\r\n\r\n@NonNullFields\r\n包级别注解，默认所有字段不可为null\r\n\r\n\r\n\r\n响应式编程（WebFlux）\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@WebFluxTest\r\n针对 WebFlux 控制器的切片测试\r\n\r\n\r\n@EnableWebFlux\r\n启用 WebFlux 配置（替代@EnableWebMvc）\r\n\r\n\r\n\r\n国际化与资源\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n注解\r\n说明\r\n\r\n\r\n\r\n\r\n@MessageSource\r\n注入国际化消息源（需配置ResourceBundleMessageSource）\r\n\r\n\r\n\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"SpringFrameworkPart7-JDBCTemplate事务-上","url":"/posts/58016.html","content":"什么是 JdbcTemplate\r\nSpring 框架对 JDBC 进行封装，使用 JdbcTemplate\r\n方便实现对数据库操作。\r\nJdbcTemplate 是 Spring 框架 提供的一个核心 JDBC\r\n工具类，位于 org.springframework.jdbc.core\r\n包中。它简化了 JDBC 数据库操作，避免了繁琐的 JDBC\r\n代码编写，提高了开发效率。\r\n在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。\r\n作用：\r\n\r\n执行 SQL 语句：JdbcTemplate 提供了多种方法来执行 SQL\r\n语句，包括查询、更新、插入、删除等。\r\n\r\n处理结果集：JdbcTemplate 可以自动将查询结果转换为 Java\r\n对象，简化了结果集的处理。\r\n\r\n管理数据库连接：JdbcTemplate\r\n自动管理数据库连接的获取和释放，避免了资源泄漏。\r\n\r\n处理异常：JdbcTemplate 将 JDBC 异常转换为 Spring\r\n的统一数据访问异常，方便进行异常处理。\r\n\r\n支持事务：JdbcTemplate 可以与 Spring\r\n的事务管理机制集成，实现事务控制。\r\n\r\nJava程序使用JDBC接口访问关系数据库的时候，需要以下几步：\r\n\r\n创建全局DataSource实例，表示数据库连接池；\r\n在需要读写数据库的方法内部，按如下步骤访问数据库：\r\n\r\n从全局DataSource实例获取Connection实例；\r\n通过Connection实例创建PreparedStatement实例；\r\n执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。\r\n\r\n\r\n正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务。\r\n实现CURD 增删改查\r\n我们可以将 JdbcTemplate 的创建权交给 Spring，将数据源 DataSource\r\n的创建权也交给 Spring\r\n在Spring容器内部将数据源 DataSource 注入到 JdbcTemplate\r\n模版对象中,然后通过 Spring 容器获得 JdbcTemplate 对象来执行操作\r\n准备工作\r\n新建子模块，引入如下依赖\r\n&lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;         &lt;scope&gt;runtime&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifactId&gt;lombok&lt;/artifactId&gt;         &lt;optional&gt;true&lt;/optional&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;\r\n创建 jdbc.properties，配置数据库连接池\r\n将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护\r\nspring.application.name=spring6-jdbcspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/SpringJDBCTemple?serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=truespring.datasource.username=spring.datasource.password=\r\n配置 Spring 的配置文件\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 开启组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6jdbc&quot;/&gt;    &lt;!-- 引入外部属性文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;spring.datasource.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;spring.datasource.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;spring.datasource.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置JdbcTemplate, 注入 DataSource--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启事务注解 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n创建需要连接的数据库\r\nCREATE DATABASE IF NOT EXISTS SpringJDBCTemple;USE SpringJDBCTemple;CREATE TABLE IF NOT EXISTS t_user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(50) NOT NULL,    age INT,    email VARCHAR(100)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \r\n进行测试\r\npackage edu.software.ergoutree.spring6jdbc;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass Spring6JdbcApplicationTests &#123;    @Test    public void testJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //通过接口来获取数据源对象        DataSource dataSource = ioc.getBean(&quot;dataSource&quot;, DataSource.class);        Connection connection = dataSource.getConnection();        System.out.println(&quot;dataSource&#x27;s class = &quot; + dataSource.getConnection());        System.out.println(&quot;connection = &quot; + connection);        connection.close();    &#125;&#125;\r\n通过 JDBCTemplate\r\n实现数据的添加，修改，删除\r\n实例\r\n向表中新增两条记录，用两种方法实现\r\n// 数据添加@Testpublic void InsertJdbcTemplate() throws SQLException &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    DataSource dataSource = ioc.getBean(&quot;dataSource&quot;, DataSource.class);    Connection connection = dataSource.getConnection();    System.out.println(&quot;dataSource&#x27;s class = &quot; + dataSource.getConnection());    System.out.println(&quot;connection = &quot; + connection);    JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);    String sql1 = &quot;INSERT INTO t_user VALUE (1113, &#x27;zjmd&#x27;, 23, &#x27;3783489@qq.com&#x27;);&quot;;    String sql2 = &quot;INSERT INTO t_user VALUE (?, ?, ?, ?);&quot;;    // 添加方式1  通过execute的方式    jdbcTemplate.execute(sql1);    //添加方式二 ：通过update方法添加，按照顺序传递参数    int affectedRows = jdbcTemplate.update(sql2, 221, &quot;wh&quot;, 34, &quot;234e3434@email.com&quot;);    System.out.println(&quot;affected rows = &quot; + affectedRows);    connection.close();&#125;\r\n测试通过，发现可以插入数据\r\n注意的是 excute()是 JDBC\r\n原生方法的简单封装，用于执行完整 SQL 字符串\r\n// 注意：需手动转义参数值，避免安全问题！int id = 111;String name = &quot;zjm&quot;;int age = 23;String unsafeSql = String.format(&quot;INSERT INTO t_user VALUES (%d, &#x27;%s&#x27;, %d)&quot;, id, name, age);jdbcTemplate.execute(unsafeSql); // 仅用于演示，生产环境禁止！// 只能做到静态sql语句的插入\r\n修改和删除的方法类\r\n// 数据修改    @Test    public void UpdateJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);        // 方式1：直接执行静态SQL        String sql1 = &quot;UPDATE t_user SET name=&#x27;zjm_updated&#x27;, age=25 WHERE id=1113&quot;;        jdbcTemplate.execute(sql1);        // 方式2：使用参数化SQL（推荐）        String sql2 = &quot;UPDATE t_user SET name=?, age=? WHERE id=?&quot;;        int affectedRows = jdbcTemplate.update(sql2, &quot;wh_updated&quot;, 35, 221);        System.out.println(&quot;Updated rows: &quot; + affectedRows);    &#125;\r\n// 数据删除    @Test    public void DeleteJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);        // 方式1：直接执行静态SQL        String sql1 = &quot;DELETE FROM t_user WHERE id=1113&quot;;        jdbcTemplate.execute(sql1);        // 方式2：使用参数化SQL（推荐）        String sql2 = &quot;DELETE FROM t_user WHERE id=?&quot;;        int affectedRows = jdbcTemplate.update(sql2, 221);        System.out.println(&quot;Deleted rows: &quot; + affectedRows);    &#125;\r\nupdate方法详解\r\n可以看到，JDBCTemplate对数据库的增删改操作都是update方法，执行最终的效果只根据语句有关系\r\nupdate 方法的主要作用是执行 SQL\r\n语句并返回受影响的行数。它可以执行的 SQL 语句包括\r\nINSERT、UPDATE 和 DELETE\r\n语句。\r\n返回值：update 方法的返回值是一个整数，表示 SQL\r\n语句执行后受影响的行数\r\n\r\n\r\nimage-20250427171122032\r\n\r\n其中方法的重载形式：\r\nint update(String sql)\r\n\r\n参数说明：\r\n\r\nsql：要执行的 SQL 语句。\r\n\r\n使用场景：当 SQL\r\n语句中不包含参数时，可以使用这个方法。例如，删除表中所有数据：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;DELETE FROM users&quot;;int rows = jdbcTemplate.update(sql);System.out.println(&quot;删除的行数: &quot; + rows);\r\nint update(String sql, @Nullable Object... args)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL 语句，其中可以包含占位符\r\n?。\r\nargs：SQL\r\n语句中占位符对应的参数值，参数的顺序要和占位符的顺序一致。\r\n\r\n使用场景：当 SQL\r\n语句中包含参数时，可以使用这个方法。例如，插入一条新记录：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;;Object[] args = &#123;&quot;John&quot;, 25&#125;;int rows = jdbcTemplate.update(sql, args);System.out.println(&quot;插入的行数: &quot; + rows);\r\nint update(String sql, PreparedStatementSetter pss)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL 语句，其中可以包含占位符\r\n?。\r\npss：一个 PreparedStatementSetter\r\n接口的实现类，用于设置 PreparedStatement 对象的参数。\r\n\r\n使用场景：当需要更复杂的参数设置逻辑时，可以使用这个方法。例如：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.PreparedStatementSetter;import java.sql.PreparedStatement;import java.sql.SQLException;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;UPDATE users SET age = ? WHERE name = ?&quot;;int age = 26;String name = &quot;John&quot;;int rows = jdbcTemplate.update(sql, new PreparedStatementSetter() &#123;    @Override    public void setValues(PreparedStatement ps) throws SQLException &#123;        ps.setInt(1, age);        ps.setString(2, name);    &#125;&#125;);System.out.println(&quot;更新的行数: &quot; + rows);\r\n异常处理\r\nupdate 方法可能会抛出 DataAccessException\r\n及其子类的异常，例如 SQLException\r\n等。在实际使用中，建议捕获这些异常并进行相应的处理。例如：\r\nimport org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;DELETE FROM users&quot;;try &#123;    int rows = jdbcTemplate.update(sql);    System.out.println(&quot;删除的行数: &quot; + rows);&#125; catch (DataAccessException e) &#123;    System.err.println(&quot;数据库操作出错: &quot; + e.getMessage());&#125;\r\n通过 JDBCTemplate\r\n实现数据的查询\r\n案例\r\n// 数据查询    @Test    public void SelectJdbcTemplate() throws SQLException &#123;        String sql = &quot;SELECT * FROM t_user WHERE id=?&quot;;        // 查询返回 Map        Map&lt;String, Object&gt; userMap = jdbcTemplate.queryForMap(sql, 1113);        System.out.println(&quot;User as Map: &quot; + userMap);        // 查询返回对象        // 写法1        User user = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; &#123;            User u = new User();            u.setId(rs.getInt(&quot;id&quot;));            u.setName(rs.getString(&quot;name&quot;));            u.setAge(rs.getInt(&quot;age&quot;));            u.setEmail(rs.getString(&quot;email&quot;));            return u;        &#125;, 1113);        System.out.println(&quot;User as Object: &quot; + user);        // 写法2        User user2 = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 1113);        System.out.println(&quot;User as Object: &quot; + user2);        // 返回集合        // 返回List&lt;User&gt;        List&lt;User&gt; users = jdbcTemplate.query(sql, (rs, rowNum) -&gt; &#123;            User u = new User();            u.setId(rs.getInt(&quot;id&quot;));            u.setName(rs.getString(&quot;name&quot;));            u.setAge(rs.getInt(&quot;age&quot;));            u.setEmail(rs.getString(&quot;email&quot;));            return u;        &#125;, 20);        System.out.println(&quot;Users as Objects: &quot; + users);        // 返回List&lt;Map&gt;        List&lt;Map&lt;String, Object&gt;&gt; userMaps = jdbcTemplate.queryForList(sql, 20);        System.out.println(&quot;Users as Maps: &quot; + userMaps);        // 返回单个值，查询有多少记录        String sql2 = &quot;select count(*) from t_user&quot;;        Integer count = jdbcTemplate.queryForObject(sql2, Integer.class);        System.out.println(&quot;Count of users: &quot; + count);    &#125;\r\nqueryForObject方法详解\r\n可以看到，JDBCTemplate对数据库的增删改操作都是queryForObject方法，执行的结果跟这个方法重载的各种类型有关系。\r\n在queryForObject()方法中，传入SQL以及SQL参数后，JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，我们提供的RowMapper需要做的事情就是把ResultSet的当前行映射成一个JavaBean并返回。整个过程中，使用Connection、PreparedStatement和ResultSet都不需要我们手动管理。\r\nJdbcTemplate 中的 queryForObject\r\n方法主要用于执行 SQL 查询语句，并期望返回单个结果对象（集合）.\r\nqueryForObject\r\n方法用于执行查询操作，且预期查询结果为单个对象。当你确定查询只会返回一条记录时，就可以使用这个方法将结果映射到指定的对象类型中。\r\n常见重载形式\r\nT queryForObject(String sql, Class requiredType)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL\r\n查询语句，此语句一般用于查询单个值，如查询某一列的总和、平均值等。\r\n\r\nrequiredType：期望返回结果的类型，比如\r\nInteger、String 等。\r\n使用场景：当查询结果是单个值时使用。例如，查询\r\nusers 表中的用户总数：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT COUNT(*) FROM users&quot;;Integer userCount = jdbcTemplate.queryForObject(sql, Integer.class);System.out.println(&quot;用户总数: &quot; + userCount);\r\nT queryForObject(String sql, Object[] args, Class requiredType)\r\n\r\n参数说明\r\n\r\nsql：包含占位符 ? 的 SQL 查询语句。\r\n\r\nargs：SQL\r\n语句中占位符对应的参数值数组，参数顺序需与占位符顺序一致。\r\n\r\nrequiredType：期望返回结果的类型。\r\n\r\n使用场景：当查询语句包含参数且结果为单个值时使用。例如，查询名为\r\nJohn 的用户的年龄：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT age FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;John&quot;&#125;;Integer age = jdbcTemplate.queryForObject(sql, args, Integer.class);System.out.println(&quot;John 的年龄: &quot; + age);\r\nT queryForObject(String sql, RowMapper rowMapper)\r\n\r\n参数说明\r\n\r\nsql：要执行的 SQL 查询语句，用于查询完整的记录。\r\n\r\nrowMapper：RowMapper\r\n接口的实现类，用于将查询结果集中的每一行数据映射到指定类型的对象。\r\n使用场景：当查询结果是一条完整的记录，需要将其映射到自定义对象时使用。例如，查询\r\nid 为 1 的用户信息\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT * FROM users WHERE id = 1&quot;;User user = jdbcTemplate.queryForObject(sql, new RowMapper&lt;User&gt;() &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        return user;    &#125;&#125;);System.out.println(user);\r\nT queryForObject(String sql, Object[] args, RowMapper rowMapper)\r\n\r\n参数说明\r\n\r\nsql：包含占位符 ? 的 SQL 查询语句。\r\n\r\nargs：SQL 语句中占位符对应的参数值数组。\r\n\r\nrowMapper：RowMapper\r\n接口的实现类，用于将查询结果集中的每一行数据映射到指定类型的对象。\r\n\r\n使用场景：当查询语句包含参数，且需要将查询结果映射到自定义对象时使用。例如，查询名为\r\nJohn 的用户信息：\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT * FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;John&quot;&#125;;User user = jdbcTemplate.queryForObject(sql, args, new RowMapper&lt;User&gt;() &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        return user;    &#125;&#125;);System.out.println(user);\r\n返回值\r\nqueryForObject\r\n方法的返回值是一个指定类型的对象。如果查询结果为空，该方法可能会抛出\r\nEmptyResultDataAccessException\r\n异常；如果查询结果有多条记录，也会抛出异常。\r\n异常处理\r\n在使用 queryForObject\r\n方法时，需要注意处理可能抛出的异常，如\r\nEmptyResultDataAccessException 和\r\nIncorrectResultSizeDataAccessException。\r\nimport org.springframework.dao.EmptyResultDataAccessException;import org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT age FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;NonExistentUser&quot;&#125;;try &#123;    Integer age = jdbcTemplate.queryForObject(sql, args, Integer.class);    System.out.println(&quot;年龄: &quot; + age);&#125; catch (EmptyResultDataAccessException e) &#123;    System.err.println(&quot;未找到符合条件的记录: &quot; + e.getMessage());&#125;\r\n更进阶的使用\r\n数据批量处理\r\nJdbcTemplate 提供 batchUpdate()\r\n方法实现批量操作，适合一次性处理大量数据，提升性能。\r\n参数说明：\r\n\r\nbatchUpdate(String sql, List batchArgs)：\r\n\r\nbatchArgs 中每个 Object[] 对应 SQL\r\n中的一组参数。\r\n\r\n\r\n@Testpublic void BatchInsertJdbcTemplate() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (?, ?, ?)&quot;;        // 批量数据：参数为 Object 数组的集合    List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();    batchArgs.add(new Object[]&#123;&quot;Alice&quot;, 28, &quot;alice@example.com&quot;&#125;);    batchArgs.add(new Object[]&#123;&quot;Bob&quot;, 32, &quot;bob@example.com&quot;&#125;);    batchArgs.add(new Object[]&#123;&quot;Charlie&quot;, 25, &quot;charlie@example.com&quot;&#125;);    // 执行批量插入    int[] affectedRows = jdbcTemplate.batchUpdate(sql, batchArgs);    System.out.println(&quot;插入行数统计: &quot; + Arrays.toString(affectedRows));&#125;\r\n查询到的数据封装到 Bean 对象\r\n通过 RowMapper 或 BeanPropertyRowMapper\r\n将结果集自动映射到 Java 对象。\r\n自定义 RowMapper\r\npublic class UserRowMapper implements RowMapper&lt;User&gt; &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        user.setEmail(rs.getString(&quot;email&quot;));        return user;    &#125;&#125;// 使用示例@Testpublic void QueryWithCustomRowMapper() &#123;    String sql = &quot;SELECT * FROM t_user WHERE age &gt; ?&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         new UserRowMapper(),         20  // 参数：age &gt; 20    );    System.out.println(&quot;Users: &quot; + users);&#125;\r\n使用 BeanPropertyRowMapper\r\nSpring 提供的自动映射工具，要求数据库字段名与 Java 对象属性名一致（如\r\nuser_name → userName）。\r\n@Testpublic void QueryWithBeanPropertyRowMapper() &#123;    String sql = &quot;SELECT * FROM t_user&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         new BeanPropertyRowMapper&lt;&gt;(User.class)    );    System.out.println(&quot;Users: &quot; + users);&#125;\r\n查询到的数据以Bean对象的形式封装到集合中\r\n直接使用 query() 方法返回\r\nList，适用于查询多条记录。\r\n@Testpublic void QueryAllUsersAsBeanList() &#123;    String sql = &quot;SELECT * FROM t_user&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         (rs, rowNum) -&gt; &#123;            User user = new User();            user.setId(rs.getInt(&quot;id&quot;));            user.setName(rs.getString(&quot;name&quot;));            user.setAge(rs.getInt(&quot;age&quot;));            user.setEmail(rs.getString(&quot;email&quot;));            return user;        &#125;    );    System.out.println(&quot;All Users: &quot; + users);&#125;\r\n查询单行单列的具体字段\r\n使用 queryForObject() 直接返回基本类型值（如\r\nInteger, String）。\r\n@Testpublic void QuerySingleValue() &#123;    // 查询最大年龄    String sqlMaxAge = &quot;SELECT MAX(age) FROM t_user&quot;;    Integer maxAge = jdbcTemplate.queryForObject(sqlMaxAge, Integer.class);    System.out.println(&quot;最大年龄: &quot; + maxAge);    // 查询特定用户的邮箱    String sqlEmail = &quot;SELECT email FROM t_user WHERE name = ?&quot;;    String email = jdbcTemplate.queryForObject(        sqlEmail,         String.class,         &quot;Alice&quot;    );    System.out.println(&quot;Alice 的邮箱: &quot; + email);&#125;\r\n使用具名参数添加数据\r\n以往我们使用SQL语句时，总是用到占位符 ?\r\n，就像我们上面刚刚用到的SQL语句\r\n这么做有个问题——除非我们知道对应表的结构，不然就无法确定这个占位符?\r\n应该传入什么参数。\r\n使用具名参数可以很好的解决这个问题。\r\n通过 NamedParameterJdbcTemplate 支持具名参数（如\r\n:name），提升 SQL 可读性。\r\n首先在之前的 xml 配置文件下新配置一个 NamedParameterJdbcTemplate\r\n对象，如下\r\n&lt;bean id=&quot;namedParameterJdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;\r\n@Testpublic void InsertWithNamedParameters() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    NamedParameterJdbcTemplate namedTemplate = ioc.getBean(        &quot;namedParameterJdbcTemplate&quot;,         NamedParameterJdbcTemplate.class    );    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (:name, :age, :email)&quot;;        // 使用 Map 传递参数    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();    params.put(&quot;name&quot;, &quot;David&quot;);    params.put(&quot;age&quot;, 29);    params.put(&quot;email&quot;, &quot;david@example.com&quot;);    int affectedRows = namedTemplate.update(sql, params);    System.out.println(&quot;插入行数: &quot; + affectedRows);&#125;\r\n使用 SqlParameterSource\r\n更灵活的传参方式（支持 Bean 对象自动映射）：\r\n@Testpublic void InsertWithSqlParameterSource() &#123;    NamedParameterJdbcTemplate namedTemplate = ...; // 获取 Bean    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (:name, :age, :email)&quot;;        // 使用 BeanPropertySqlParameterSource    User newUser = new User();    newUser.setName(&quot;Eva&quot;);    newUser.setAge(27);    newUser.setEmail(&quot;eva@example.com&quot;);        SqlParameterSource params = new BeanPropertySqlParameterSource(newUser);    int affectedRows = namedTemplate.update(sql, params);    System.out.println(&quot;插入行数: &quot; + affectedRows);&#125;\r\n总结\r\n我们总结一下JdbcTemplate的用法，那就是：\r\n\r\n针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper；\r\n针对更新操作，优选update()，因为只需提供SQL语句和参数；\r\n任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。\r\n\r\n实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。\r\n例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下\r\nSELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringFrameworkPart7-JDBCTemplate事务-下","url":"/posts/8801.html","content":"声明式事务控制\r\n关于事务\r\n理解事务\r\n事务是一组操作的执行单元，相对于数据库操作来讲，事务管理的是一组SQL指令，比如增加，修改，删除等\r\n事务的一致性，要求，这个事务内的操作必须全部执行成功，如果在此过程种出现了差错，比如有一条SQL语句没有执行成功，那么这一组操作都将全部回滚\r\n事务由事务开始和事务结束之间执行的全部数据库操作组成。\r\n事务四大特性\r\n原子性A：事务是不可分割的最小操作单元，要么全成功，要么全失败\r\n一致性C：事务完成时，必须所据都保持一致状态\r\n隔离性I：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下进行\r\n持久性D：事务一旦提交或回滚，他对数据库的改变是永久的\r\n声明式事务控制\r\n理解声明式事务\r\nSpring\r\n对事务逻辑的代码有封装，在配置文件中或者注解管理即可实现相关操作\r\nSpring\r\n的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在Spring\r\n配置文件中声明式的处理事务来代替代码式的处理事务\r\n声明式事务处理的作用\r\n\r\n事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可\r\n在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便\r\n\r\nSpring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。如果手写事务代码，使用try...catch如下\r\nTransactionStatus tx = null;try &#123;    // 开启事务:    tx = txManager.getTransaction(new DefaultTransactionDefinition());    // 相关JDBC操作:    jdbcTemplate.update(&quot;...&quot;);    jdbcTemplate.update(&quot;...&quot;);    // 提交事务:    txManager.commit(tx);&#125; catch (RuntimeException e) &#123;    // 回滚事务:    txManager.rollback(tx);    throw e;&#125;\r\nSpring为啥要抽象出PlatformTransactionManager和TransactionStatus？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java\r\nTransaction\r\nAPI）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。\r\nSpring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager。因为我们的代码只需要JDBC事务，因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：\r\n@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\r\nSpring 声明式事务控制底层就是AOP\r\n编程式：自己写代码实现功能\r\n声明式：通过配置让框架实现框架实现\r\n编程式事务控制\r\n相关对象\r\nPlatformTransactionManager\r\nPlatformTransactionManager 接口是 spring\r\n的事务管理器，它里面提供了我们常用的操作事务的方法。例如获取事务状态、提交事务和回滚事务等。\r\n\r\n\r\nimg\r\n\r\nPlatformTransactionManager是接口类型，不同的 Dao\r\n层技术则有不同的实现类\r\n例如：\r\n\r\nDao 层技术是jdbc 或 mybatis\r\n时：org.springframework.jdbc.datasource.DataSourceTransactionManager\r\nDao\r\n层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager\r\n\r\nTransactionDefinition\r\nTransactionDefinition\r\n是事务的定义信息对象，包含了事务的隔离级别、传播行为、超时时间和是否只读等信息。\r\n\r\n\r\n在这里插入图片描述\r\n\r\nTransactionStatus\r\nTransactionStatus\r\n接口提供的是事务具体的运行状态，方法介绍如下。\r\n在 Spring 的编程式事务管理里，TransactionStatus 对象由\r\nPlatformTransactionManager 的 getTransaction()\r\n方法返回。它记录了事务的当前状态，例如事务是否为新开启的、是否已完成等，并且能让开发者对事务进行控制，比如提交或者回滚事务。\r\n常用方法\r\n\r\nisNewTransaction()\r\n\r\n\r\n功能：判断当前事务是否为新开启的事务。若返回\r\ntrue，表示该事务是在此次调用 getTransaction()\r\n方法时新开启的；若返回\r\nfalse，则说明当前事务是已存在事务的一部分（比如在事务传播行为是\r\nREQUIRED 时，加入了已有的事务）。\r\n\r\n\r\nhasSavepoint()\r\n\r\n\r\n功能：判断当前事务是否有保存点。保存点是事务中的一个标记，可让事务部分回滚到该标记处，而非整个事务回滚。\r\n\r\n\r\nsetRollbackOnly()\r\n\r\n\r\n功能：将当前事务标记为仅回滚。一旦调用此方法，事务在结束时会被强制回滚，即便后续代码尝试提交事务也不会生效。\r\n\r\n\r\nisRollbackOnly()\r\n\r\n\r\n功能：检查当前事务是否已被标记为仅回滚。\r\n\r\n\r\nisCompleted()\r\n\r\n\r\n功能：判断事务是否已经完成，即是否已经提交或者回滚。\r\n\r\n声明式事务控制说明\r\n使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：\r\n@Configuration@ComponentScan@EnableTransactionManagement // 启用声明式@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;\r\n然后，对需要事务支持的方法，加一个@Transactional注解：\r\n@Componentpublic class UserService &#123;    // 此public方法自动具有事务支持:    @Transactional    public User register(String email, String password, String name) &#123;       ...    &#125;&#125;\r\n或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：\r\n@Component@Transactionalpublic class UserService &#123;    ...&#125;\r\n事务隔离级别\r\nSQL 标准定义了四种隔离级别，MySQL\r\n全都支持。这四种隔离级别分别是：\r\n\r\n读未提交（READ UNCOMMITTED）\r\n读提交 （READ COMMITTED）\r\n可重复读 （REPEATABLE READ）\r\n串行化 （SERIALIZABLE）\r\n\r\n从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是\r\nMySQL 的默认级别。\r\n事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了\r\n4 种隔离级别对这三个问题的解决程度\r\n\r\n\r\nimg\r\n\r\n事务传播行为\r\n\r\nREQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）\r\nSUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）\r\nMANDATORY：使用当前的事务，如果当前没有事务，就抛出异常\r\nREQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。\r\nNOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\r\nNEVER：以非事务方式运行，如果当前存在事务，抛出异常\r\nNESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行\r\nREQUIRED 类似的操作\r\n超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置\r\n是否只读：建议查询时设置为只读\r\n\r\n示例\r\n假设我们有一个简单的用户账户表，需要进行转账操作。\r\n我们需要配置 Spring 的上下文和数据源\r\n&lt;!-- applicationContext.xml --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置 JdbcTemplate --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置业务服务 --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.example.AccountService&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n然后，我们创建一个 AccountService 类来处理转账业务：\r\npackage com.example;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.TransactionDefinition;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.DefaultTransactionDefinition;public class AccountService &#123;    private JdbcTemplate jdbcTemplate;    private PlatformTransactionManager transactionManager;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;        this.transactionManager = transactionManager;    &#125;    public void transferMoney(int fromAccountId, int toAccountId, double amount) &#123;        // 定义事务属性        TransactionDefinition def = new DefaultTransactionDefinition();        // 获取事务状态        TransactionStatus status = transactionManager.getTransaction(def);        try &#123;            // 减少转出账户的余额            jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, amount, fromAccountId);            // 模拟异常            // int result = 1 / 0;            // 增加转入账户的余额            jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, amount, toAccountId);            // 提交事务            transactionManager.commit(status);        &#125; catch (Exception e) &#123;            // 回滚事务            transactionManager.rollback(status);            e.printStackTrace();        &#125;    &#125;&#125;\r\n最后，我们可以编写一个测试类来调用 AccountService 的\r\ntransferMoney 方法\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123;    public static void main(String[] args) &#123;        // 加载 Spring 上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        // 获取 AccountService 实例        AccountService accountService = (AccountService) context.getBean(&quot;accountService&quot;);        // 执行转账操作        accountService.transferMoney(1, 2, 100.0);    &#125;&#125;\r\n在这个示例中，我们使用 PlatformTransactionManager 和\r\nTransactionDefinition 来手动管理事务。在\r\ntransferMoney\r\n方法中，我们首先获取事务状态，然后执行数据库操作，如果操作过程中出现异常，我们会回滚事务，否则提交事务。\r\n基于 XML 的声明式事务控制\r\nSpring\r\n的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在\r\nSpring 配置文件中声明式的处理事务来代替代码式的处理事务。\r\n声明式事务控制明确事项：\r\n\r\n谁是切点？\r\n谁是通知？\r\n配置切面？\r\n\r\n配置事务管理器与命名空间\r\n在 applicationContext.xml\r\n中添加事务相关命名空间及事务管理器配置：\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;           http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd           http://www.springframework.org/schema/tx           http://www.springframework.org/schema/tx/spring-tx.xsd           http://www.springframework.org/schema/aop           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 数据源配置（同上） --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- JdbcTemplate 配置（同上） --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 业务服务 --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.example.AccountService&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 声明式事务配置 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 配置事务属性：方法名匹配规则 --&gt;            &lt;tx:method name=&quot;transferMoney&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;                        timeout=&quot;-1&quot; read-only=&quot;false&quot; rollback-for=&quot;Exception&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- AOP 切面配置 --&gt;    &lt;aop:config&gt;        &lt;!-- 定义切点：匹配业务层方法 --&gt;        &lt;aop:pointcut id=&quot;servicePointcut&quot;                       expression=&quot;execution(* com.example.AccountService.*(..))&quot;/&gt;        &lt;!-- 将事务通知与切点关联 --&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\r\n\r\n\r\n\r\n配置项\r\n作用\r\n\r\n\r\n\r\n\r\n&lt;tx:advice&gt;\r\n定义事务通知，指定事务管理器和事务属性\r\n\r\n\r\n&lt;tx:method&gt;\r\n配置具体方法的事务规则（如传播行为、隔离级别）\r\n\r\n\r\n&lt;aop:pointcut&gt;\r\n定义切点，匹配需要事务管理的方法\r\n\r\n\r\n&lt;aop:advisor&gt;\r\n将事务通知与切点关联，实现声明式事务控制\r\n\r\n\r\n\r\n移除 AccountService 中的\r\nPlatformTransactionManager 依赖和手动事务管理代码：\r\npackage com.example;import org.springframework.jdbc.core.JdbcTemplate;public class AccountService &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public void transferMoney(int fromAccountId, int toAccountId, double amount) &#123;        // 减少转出账户的余额        jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, amount, fromAccountId);        // 模拟异常（测试回滚）        // int result = 1 / 0;        // 增加转入账户的余额        jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, amount, toAccountId);    &#125;&#125;\r\n事务属性详解\r\n在 &lt;tx:method&gt; 标签中配置事务规则：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n属性\r\n说明\r\n\r\n\r\n\r\n\r\nname\r\n匹配的方法名（支持通配符，如 * 表示所有方法）\r\n\r\n\r\npropagation\r\n事务传播行为（默认 REQUIRED）\r\n\r\n\r\nisolation\r\n事务隔离级别（默认\r\nDEFAULT，使用数据库默认隔离级别）\r\n\r\n\r\ntimeout\r\n事务超时时间（单位秒，默认 -1 表示不超时）\r\n\r\n\r\nread-only\r\n是否只读事务（默认 false，查询操作建议设为\r\ntrue）\r\n\r\n\r\nrollback-for\r\n触发回滚的异常类型（如 Exception\r\n表示所有异常均回滚）\r\n\r\n\r\nno-rollback-for\r\n不触发回滚的异常类型\r\n\r\n\r\n\r\n编写测试类验证事务是否生效\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        AccountService accountService = (AccountService) context.getBean(&quot;accountService&quot;);        try &#123;            // 正常转账（事务提交）            accountService.transferMoney(1, 2, 100.0);                        // 模拟异常（事务回滚）            // accountService.transferMoney(1, 2, 100.0); // 内部有 int result = 1 / 0;        &#125; catch (Exception e) &#123;            System.err.println(&quot;事务回滚：&quot; + e.getMessage());        &#125;    &#125;&#125;\r\n基于注解的声明式事务控制\r\n注解的方式，只需在方法上面加一个@Transaction注解，那么方法执行之前spring会自动开启一个事务，方法执行完毕之后，会自动提交或者回滚事务，而方法内部没有任何事务相关代码，用起来特别的方便。\r\n将会通过如下完整示例进行说明\r\n首先创建数据库表\r\n-- 银行账户表CREATE TABLE IF NOT EXISTS t_account (    id INT PRIMARY KEY AUTO_INCREMENT,    account_no VARCHAR(20) NOT NULL UNIQUE,    account_name VARCHAR(50) NOT NULL,    balance DECIMAL(10,2) NOT NULL DEFAULT 0.00,    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- 交易记录表CREATE TABLE IF NOT EXISTS t_transaction (    id INT PRIMARY KEY AUTO_INCREMENT,    from_account_id INT NOT NULL,    to_account_id INT NOT NULL,    amount DECIMAL(10,2) NOT NULL,    transaction_time DATETIME DEFAULT CURRENT_TIMESTAMP,    status VARCHAR(20) NOT NULL,    remark VARCHAR(200),    FOREIGN KEY (from_account_id) REFERENCES t_account(id),    FOREIGN KEY (to_account_id) REFERENCES t_account(id)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\r\n创建实体类\r\n// 实体类 账户package edu.software.ergoutree.spring6jdbc.affairs.entity;import lombok.Data;import java.math.BigDecimal;import java.time.LocalDateTime;@Datapublic class Account &#123;    private Integer id;    private String accountNo;    private String accountName;    private BigDecimal balance;    private LocalDateTime createTime;    private LocalDateTime updateTime;&#125;\r\n// 实体类 表示一次交易package edu.software.ergoutree.spring6jdbc.affairs.entity;import lombok.Data;import java.math.BigDecimal;import java.time.LocalDateTime;@Datapublic class Transaction &#123;    private Integer id;    private Integer fromAccountId;    private Integer toAccountId;    private BigDecimal amount;    private LocalDateTime transactionTime;    private String status;    private String remark;&#125;\r\n创建 DAO 层\r\npackage edu.software.ergoutree.spring6jdbc.affairs.dao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import java.math.BigDecimal;// 账户数据访问对象的接口public interface AccountDao &#123;    Account findById(Integer id);   // 根据账户 ID 查询账户信息    Account findByAccountNo(String accountNo);   // 根据账户号码查询账户信息    void updateBalance(Integer id, BigDecimal balance);   // 更新指定账户的余额    void save(Account account);   // 保存新的账户信息到数据库&#125;\r\n// 实现了 AccountDao 接口，使用 JdbcTemplate 与数据库进行交互。package edu.software.ergoutree.spring6jdbc.affairs.dao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.math.BigDecimal;@Repositorypublic class AccountDaoImpl implements AccountDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public Account findById(Integer id) &#123;        String sql = &quot;SELECT * FROM t_account WHERE id = ?&quot;;        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), id);    &#125;    @Override    public Account findByAccountNo(String accountNo) &#123;        String sql = &quot;SELECT * FROM t_account WHERE account_no = ?&quot;;        // 将查询结果映射到 Account 实体类。        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), accountNo);    &#125;    @Override    public void updateBalance(Integer id, BigDecimal balance) &#123;        String sql = &quot;UPDATE t_account SET balance = ? WHERE id = ?&quot;;        jdbcTemplate.update(sql, balance, id);    &#125;    @Override    public void save(Account account) &#123;        String sql = &quot;INSERT INTO t_account (account_no, account_name, balance) VALUES (?, ?, ?)&quot;;        jdbcTemplate.update(sql, account.getAccountNo(), account.getAccountName(), account.getBalance());    &#125;&#125;\r\n创建 Service 层\r\npackage edu.software.ergoutree.spring6jdbc.affairs.service;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import java.math.BigDecimal;// 定义了账户服务的接口public interface AccountService &#123;    void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount);  // 转账    Account createAccount(Account account);   // 新建账户    Account getAccount(String accountNo);   // 根据账户号码查询账户信息&#125; \r\npackage edu.software.ergoutree.spring6jdbc.affairs.service;import edu.software.ergoutree.spring6jdbc.affairs.dao.AccountDao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.math.BigDecimal;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao accountDao;    @Override    // @Transactional 用于声明事务的属性    @Transactional(        propagation = Propagation.REQUIRED,        rollbackFor = Exception.class,   // 任何异常都会触发回滚。        timeout = 30    )    public void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;        // 查询转出账户        Account fromAccount = accountDao.findByAccountNo(fromAccountNo);        if (fromAccount == null) &#123;            throw new RuntimeException(&quot;转出账户不存在&quot;);        &#125;        // 查询转入账户        Account toAccount = accountDao.findByAccountNo(toAccountNo);        if (toAccount == null) &#123;            throw new RuntimeException(&quot;转入账户不存在&quot;);        &#125;        // 检查余额是否足够        if (fromAccount.getBalance().compareTo(amount) &lt; 0) &#123;            throw new RuntimeException(&quot;账户余额不足&quot;);        &#125;        // 执行转账        BigDecimal fromBalance = fromAccount.getBalance().subtract(amount);        BigDecimal toBalance = toAccount.getBalance().add(amount);        // 更新账户余额        accountDao.updateBalance(fromAccount.getId(), fromBalance);        accountDao.updateBalance(toAccount.getId(), toBalance);    &#125;    @Override    @Transactional(propagation = Propagation.REQUIRED)    public Account createAccount(Account account) &#123;        accountDao.save(account);        return account;    &#125;    @Override    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)    public Account getAccount(String accountNo) &#123;        return accountDao.findByAccountNo(accountNo);    &#125;&#125; \r\n我们对需使用事务的目标上加@Transaction注解\r\n\r\n@Transaction放在接口上，那么接口的实现类中所有public都被spring自动加上事务\r\n@Transaction放在类上，那么当前类以及其下无限级子类中所有pubilc方法将被spring自动加上事务\r\n@Transaction放在public方法上，那么该方法将被spring自动加上事务\r\n注意：@Transaction只对public方法有效\r\n\r\n下面我们看一下@Transactional源码：\r\n@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Transactional &#123;     /**     * 指定事务管理器的bean名称，如果容器中有多事务管理器PlatformTransactionManager，     * 那么你得告诉spring，当前配置需要使用哪个事务管理器     */    @AliasFor(&quot;transactionManager&quot;)    String value() default &quot;&quot;;     /**     * 同value，value和transactionManager选配一个就行，也可以为空，如果为空，默认会从容器中按照类型查找一个事务管理器bean     */    @AliasFor(&quot;value&quot;)    String transactionManager() default &quot;&quot;;     /**     * 事务的传播属性     */    Propagation propagation() default Propagation.REQUIRED;     /**     * 事务的隔离级别，就是制定数据库的隔离级别，数据库隔离级别大家知道么？不知道的可以去补一下     */    Isolation isolation() default Isolation.DEFAULT;     /**     * 事务执行的超时时间（秒），执行一个方法，比如有问题，那我不可能等你一天吧，可能最多我只能等你10秒     * 10秒后，还没有执行完毕，就弹出一个超时异常吧     */    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;     /**     * 是否是只读事务，比如某个方法中只有查询操作，我们可以指定事务是只读的     * 设置了这个参数，可能数据库会做一些性能优化，提升查询速度     */    boolean readOnly() default false;     /**     * 定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常及其子类异常的时候，spring会让事务回滚     * 如果不配做，那么默认会在 RuntimeException 或者 Error 情况下，事务才会回滚      */    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;     /**     * 和 rollbackFor 作用一样，只是这个地方使用的是类名     */    String[] rollbackForClassName() default &#123;&#125;;     /**     * 定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常的时候，事务不会回滚     */    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;     /**     * 和 noRollbackFor 作用一样，只是这个地方使用的是类名     */    String[] noRollbackForClassName() default &#123;&#125;; &#125;\r\n参数介绍\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数\r\n描述\r\n\r\n\r\n\r\n\r\nvalue\r\n指定事务管理器的bean名称，如果容器中有多事务管理器PlatformTransactionManager，那么你得告诉spring，当前配置需要使用哪个事务管理器\r\n\r\n\r\ntransactionManager\r\n同value，value和transactionManager选配一个就行，也可以为空，如果为空，默认会从容器中按照类型查找一个事务管理器bean\r\n\r\n\r\npropagation\r\n事务的传播属性，下篇文章详细介绍\r\n\r\n\r\nisolation\r\n事务的隔离级别，就是制定数据库的隔离级别，数据库隔离级别大家知道么？不知道的可以去补一下\r\n\r\n\r\ntimeout\r\n事务执行的超时时间（秒），执行一个方法，比如有问题，那我不可能等你一天吧，可能最多我只能等你10秒\r\n10秒后，还没有执行完毕，就弹出一个超时异常吧\r\n\r\n\r\nreadOnly\r\n是否是只读事务，比如某个方法中只有查询操作，我们可以指定事务是只读的\r\n设置了这个参数，可能数据库会做一些性能优化，提升查询速度\r\n\r\n\r\nrollbackFor\r\n定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常及其子类异常的时候，spring会让事务回滚\r\n如果不配做，那么默认会在 RuntimeException 或者 Error\r\n情况下，事务才会回滚\r\n\r\n\r\nrollbackForClassName\r\n同 rollbackFor，只是这个地方使用的是类名\r\n\r\n\r\nnoRollbackFor\r\n定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常的时候，事务不会回滚\r\n\r\n\r\nnoRollbackForClassName\r\n同 noRollbackFor，只是这个地方使用的是类名\r\n\r\n\r\n\r\n通过 @Transactional 注解，Spring\r\n会自动管理事务的开始、提交和回滚。在@Transaction标注类或者目标方法上执行业务操作，此时这些方法会自动被spring进行事务管理\r\n在 transfer\r\n方法中，如果在转账过程中出现任何异常，事务会自动回滚，确保数据的一致性\r\n下面讲解一些出现的注解：\r\n\r\n@Transactional注解 ：用于声明事务的属性。\r\n\r\npropagation：事务传播行为\r\n\r\nPropagation.REQUIRED\r\n表示如果当前没有事务，则创建一个新事务；如果已经存在一个事务，则加入该事务。\r\nPropagation.SUPPORTS\r\n表示如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行。\r\n\r\nrollbackFor：指定哪些异常会触发事务回滚，这里指定为\r\nException.class 表示任何异常都会触发回滚。\r\ntimeout：指定事务的超时时间，单位为秒。\r\nreadOnly：指定事务是否为只读事务，用于提高查询性能。\r\nisolation ：指定事务的隔离级别\r\n\r\n\r\n扩展事务功能\r\n嵌套事务与传播行为 REQUIRES_NEW\r\n场景: 日志记录操作需要独立事务，不受主事务回滚影响。\r\n@Servicepublic class LogService &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    // 独立事务：即使转账失败，日志仍需记录    @Transactional(propagation = Propagation.REQUIRES_NEW)    public void logTransaction(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;        String sql = &quot;INSERT INTO t_transaction (from_account_id, to_account_id, amount, status) VALUES (?, ?, ?, ?)&quot;;        jdbcTemplate.update(sql, fromAccountNo, toAccountNo, amount, &quot;PROCESSING&quot;);    &#125;&#125;// 修改 AccountServiceImpl 的转账方法@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;    // ...原有逻辑...    // 记录交易日志（独立事务）    logService.logTransaction(fromAccountNo, toAccountNo, amount);    // 模拟异常（主事务回滚，但日志记录成功）    // int a = 1 / 0;&#125;\r\n控制隔离级别和只读事务的配置\r\n// 控制隔离级别解决脏读问题@Transactional(isolation = Isolation.READ_COMMITTED)public BigDecimal getAccountBalance(String accountNo) &#123;    return accountDao.findByAccountNo(accountNo).getBalance();&#125;// 只读事务优化查询@Transactional(readOnly = true)public List&lt;Transaction&gt; getTransactionHistory(String accountNo) &#123;    return accountDao.getTransactionHistory(accountNo);&#125;\r\n注解优先级和类级的配置\r\n@Service@Transactional(isolation = Isolation.READ_COMMITTED, timeout = 10) // 类级默认配置public class AccountServiceImpl implements AccountService &#123;    @Override    @Transactional(isolation = Isolation.SERIALIZABLE, timeout = 30) // 方法级覆盖    public void highConcurrencyTransfer(...) &#123; ... &#125;&#125;\r\n若容器中存在多个事务管理器，需通过 transactionManager\r\n指定：\r\n@Transactional(transactionManager = &quot;orderTransactionManager&quot;)public void createOrder(...) &#123; ... &#125;\r\n新建一个测试类测试上述代码能否正常执行\r\npackage edu.software.ergoutree.spring6jdbc.affairs;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import edu.software.ergoutree.spring6jdbc.affairs.service.AccountService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import java.math.BigDecimal;import static org.junit.jupiter.api.Assertions.*;@SpringBootTest@Transactionalpublic class AccountServiceTest &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer() &#123;        // 创建两个账户        Account account1 = new Account();        account1.setAccountNo(&quot;1001&quot;);        account1.setAccountName(&quot;张三&quot;);        account1.setBalance(new BigDecimal(&quot;1000.00&quot;));        accountService.createAccount(account1);        Account account2 = new Account();        account2.setAccountNo(&quot;1002&quot;);        account2.setAccountName(&quot;李四&quot;);        account2.setBalance(new BigDecimal(&quot;500.00&quot;));        accountService.createAccount(account2);        // 执行转账        accountService.transfer(&quot;1001&quot;, &quot;1002&quot;, new BigDecimal(&quot;200.00&quot;));        // 验证转账结果        Account updatedAccount1 = accountService.getAccount(&quot;1001&quot;);        Account updatedAccount2 = accountService.getAccount(&quot;1002&quot;);        assertEquals(new BigDecimal(&quot;800.00&quot;), updatedAccount1.getBalance());        assertEquals(new BigDecimal(&quot;700.00&quot;), updatedAccount2.getBalance());    &#125;    @Test    public void testTransferWithInsufficientBalance() &#123;        // 创建两个账户        Account account1 = new Account();        account1.setAccountNo(&quot;1003&quot;);        account1.setAccountName(&quot;王五&quot;);        account1.setBalance(new BigDecimal(&quot;100.00&quot;));        accountService.createAccount(account1);        Account account2 = new Account();        account2.setAccountNo(&quot;1004&quot;);        account2.setAccountName(&quot;赵六&quot;);        account2.setBalance(new BigDecimal(&quot;500.00&quot;));        accountService.createAccount(account2);        // 尝试转账超过余额的金额        assertThrows(RuntimeException.class, () -&gt; &#123;            accountService.transfer(&quot;1003&quot;, &quot;1004&quot;, new BigDecimal(&quot;200.00&quot;));        &#125;);        // 验证余额未改变        Account updatedAccount1 = accountService.getAccount(&quot;1003&quot;);        Account updatedAccount2 = accountService.getAccount(&quot;1004&quot;);        assertEquals(new BigDecimal(&quot;100.00&quot;), updatedAccount1.getBalance());        assertEquals(new BigDecimal(&quot;500.00&quot;), updatedAccount2.getBalance());    &#125;&#125; \r\n另外可以操作如下测试方法\r\n@Testpublic void testNestedTransaction() &#123;    // 创建账户    Account account1 = accountService.createAccount(...);    Account account2 = accountService.createAccount(...);    try &#123;        // 转账并记录日志（主事务抛异常）        accountService.transfer(&quot;1001&quot;, &quot;1002&quot;, new BigDecimal(&quot;200.00&quot;));    &#125; catch (Exception e) &#123;        // 验证主事务回滚        Account updatedAccount1 = accountService.getAccount(&quot;1001&quot;);        assertEquals(1000.00, updatedAccount1.getBalance());        // 验证日志记录事务提交        List&lt;Transaction&gt; logs = logService.getTransactionHistory(&quot;1001&quot;);        assertFalse(logs.isEmpty());    &#125;&#125;\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework part8-Spring Resources接口与资源访问","url":"/posts/54991.html","content":"Resource接口和实现类\r\nResource接口\r\nJDK提供的访问资源的类(如java.NET.URL,File)等并不能很好很方便的满足各种底层资源的访问需求。Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。\r\nSpring的Resource接口位于org.sprigframework.core.io中。旨在实现一个更強大的接口，用于抽象对低级资源的方向。以下演示了Resource接口定义的方法\r\n/** * 用于描述资源的接口，该接口抽象了底层资源的实际类型，如文件或类路径资源。 * * &lt;p&gt;对于每个资源，如果它在物理形式上存在，都可以打开一个输入流，但只有某些资源才能返回 URL 或文件句柄。具体行为取决于其实现。 */public interface Resource extends InputStreamSource &#123;    /**     * 判断此资源是否在物理形式上真正存在。     */    boolean exists();    /**     * 指示是否可以通过 &#123;@link #getInputStream()&#125; 读取此资源的非空内容。     * 实际的内容读取可能仍然失败。     */    default boolean isReadable() &#123;        return exists();    &#125;    /**     * 指示此资源是否代表一个打开的流的句柄。     * 如果为 true，则输入流不能被多次读取，并且在读取后必须被关闭，以避免资源泄露。     */    default boolean isOpen() &#123;        return false;    &#125;    /**     * 判断此资源是否代表文件系统中的文件。     */    default boolean isFile() &#123;        return false;    &#125;    /**     * 返回此资源的 URL 句柄。     */    URL getURL() throws IOException;    /**     * 返回此资源的 URI 句柄。     */    URI getURI() throws IOException;    /**     * 返回此资源的文件句柄。     */    File getFile() throws IOException;    /**     * 返回一个 &#123;@link ReadableByteChannel&#125;。     */    default ReadableByteChannel readableChannel() throws IOException &#123;        return Channels.newChannel(getInputStream());    &#125;    /**     * 确定此资源的内容长度。     */    long contentLength() throws IOException;    /**     * 确定此资源的最后修改时间戳。     */    long lastModified() throws IOException;    /**     * 创建相对于此资源的资源。     */    Resource createRelative(String relativePath) throws IOException;    /**     * 返回此资源的文件名。     */    @Nullable    String getFilename();    /**     * 返回此资源的描述，用于在处理资源时的错误输出。     */    String getDescription();&#125;\r\nResource接口継承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。\r\nInputStreamSource接口，只有一个方法:\r\n/** * 表示可以提供输入流的资源或对象的接口。 */public interface InputStreamSource &#123;\t/**\t * 返回基础资源内容的 InputStream。\t * 期望每次调用都会创建一个新的流。\t * @return 基础资源的输入流（不能为 null）\t * @throws java.io.FileNotFoundException 如果基础资源不存在\t * @throws IOException 如果无法打开内容流\t */\tInputStream getInputStream() throws IOException;&#125;\r\nResource的实现类\r\nResource接口是Spring资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成，每个实现类代表-一种资源访问策略。Resource-一般包括这些实现类:\r\nUrlResource，ClassPathResource，FilsSystemResource，ServletContextResource，InputStreamResource，ByteArrayResource\r\nUrlResource\r\n用于访问通过 URL 表示的资源，比如 http://\r\n开头的网络资源（如网页、远程文件等），也可以是 file://\r\n开头的本地文件资源。它会根据 URL\r\n的协议来决定如何获取资源。例如，当你需要访问一个远程服务器上的文件时，就可以使用\r\nUrlResource。代码示例如下\r\nimport org.springframework.core.io.UrlResource;import java.net.URL;public class UrlResourceExample &#123;    public static void main(String[] args) throws Exception &#123;        URL url = new URL(&quot;http://example.com/somefile.txt&quot;);        UrlResource resource = new UrlResource(url);        // 这里可以进行资源的读取等操作，比如获取输入流        java.io.InputStream inputStream = resource.getInputStream();        // 处理输入流        inputStream.close();    &#125;&#125;\r\nClassPathResource\r\n用于访问类路径下的资源文件。在 Java 项目中，类路径通常包含\r\nsrc/main/resources（在 Maven 或 Gradle\r\n项目结构中）这样的目录。它会从类加载器的类路径中查找资源。例如，如果你有一个配置文件\r\napplication.properties 放在 src/main/resources\r\n目录下，你可以通过 ClassPathResource\r\n来获取它。示例代码：\r\npackage edu.software.ergoutree.springresources;import org.springframework.core.io.ClassPathResource;import java.io.IOException;import java.io.InputStream;// 访问类路径下的资源public class ClassPathDemo &#123;    public static void main(String[] args) &#123;        loadClassPathResources(&quot;test&quot;);    &#125;    public static void loadClassPathResources(String path)&#123;        // 创建对象 ClassPathResource        ClassPathResource resource = new ClassPathResource(path);        System.out.println(resource.getFilename());        System.out.println(resource.getDescription());        try &#123;            InputStream in = resource.getInputStream();            byte[] bytes = new byte[in.available()];            while (in.read(bytes) != -1)&#123;                System.out.println(new String(bytes));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\r\nFileSystemResource\r\n用于访问本地文件系统中的资源。它通过文件路径来定位资源，不管是绝对路径还是相对路径（相对于当前工作目录）。比如你要访问本地磁盘上的一个文件，就可以使用\r\nFileSystemResource。\r\npackage edu.software.ergoutree.springresources;import org.springframework.core.io.FileSystemResource;import java.io.IOException;import java.io.InputStream;// 访问系统资源public class FileSystemResourceDemo &#123;    public static void loadFileResource(String fileName) &#123;        // 创建对象        FileSystemResource resource = new FileSystemResource(fileName);        System.out.println(resource.getFilename());        System.out.println(resource.getDescription());        try &#123;            InputStream in = resource.getInputStream();            byte[] bytes = new byte[in.available()];            while (in.read(bytes) != -1)&#123;                System.out.println(new String(bytes));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        loadFileResource(&quot;Spring Framework\\\\Spring6Exp\\\\spring-resources\\\\src\\\\main\\\\resources\\\\test&quot;);    &#125;&#125;\r\nServletContextResource\r\n\r\n主要用于在 Web 应用（基于 Servlet 的应用）中访问\r\nServletContext 相关的资源。它根据\r\nServletContext 来解析资源路径，通常用于访问 Web\r\n应用根目录下的资源，比如 WEB-INF 目录下的文件。在 Spring\r\nWeb 应用中使用较多。例如：\r\nimport org.springframework.web.context.ServletContextAware;import org.springframework.web.context.support.ServletContextResource;import javax.servlet.ServletContext;public class ServletContextResourceExample implements ServletContextAware &#123;    private ServletContext servletContext;    @Override    public void setServletContext(ServletContext servletContext) &#123;        this.servletContext = servletContext;    &#125;    public void accessResource() &#123;        ServletContextResource resource = new ServletContextResource(servletContext, &quot;/WEB-INF/somefile.txt&quot;);        try &#123;            java.io.InputStream inputStream = resource.getInputStream();            // 处理输入流            inputStream.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\nInputStreamResource\r\n允许你将一个已有的 InputStream 包装成\r\nResource\r\n对象。当你已经通过其他方式获取到了一个输入流，但是又想将其作为\r\nResource\r\n来使用时，就可以使用这个类。比如从数据库中读取二进制数据得到了一个\r\nInputStream，然后可以将其包装为\r\nInputStreamResource。示例：\r\nimport org.springframework.core.io.InputStreamResource;import java.io.ByteArrayInputStream;import java.io.IOException;public class InputStreamResourceExample &#123;    public static void main(String[] args) throws IOException &#123;        String data = &quot;Some sample data&quot;;        ByteArrayInputStream inputStream = new ByteArrayInputStream(data.getBytes());        InputStreamResource resource = new InputStreamResource(inputStream);        // 这里可以对 resource 进行操作，比如获取输入流        java.io.InputStream actualInputStream = resource.getInputStream();        // 处理输入流        actualInputStream.close();    &#125;&#125;\r\nByteArrayResource\r\n用于将字节数组包装成 Resource\r\n对象。它适用于将内存中的字节数据当作一种资源来处理。例如，如果你在程序中生成了一些字节数据，然后想要以\r\nResource 的形式使用它，就可以使用\r\nByteArrayResource。示例代码：\r\nimport org.springframework.core.io.ByteArrayResource;import java.io.IOException;public class ByteArrayResourceExample &#123;    public static void main(String[] args) throws IOException &#123;        byte[] byteArray = &quot;Hello, World!&quot;.getBytes();        ByteArrayResource resource = new ByteArrayResource(byteArray);        // 可以获取输入流来读取字节数组内容        java.io.InputStream inputStream = resource.getInputStream();        // 处理输入流        inputStream.close();    &#125;&#125;\r\n这些 Resource 接口的实现类，为在 Spring\r\n应用中访问不同类型的资源提供了方便和统一的方式，使得开发者可以根据具体的资源来源选择合适的实现类来进行资源操作。\r\n\r\nResourceLoader接口\r\nSpring提供了如下两个标志性接口\r\nResourceLoader：该接口的实现类实例可以获得一个Resource实例\r\nResourceLoaderAware:该接口的实现类实例可以获得一个ResourceLoader的引用\r\norg.springframework.core.io.ResourceLoader 是 Spring\r\n框架中的一个关键接口，它定义了如何获取资源（例如类路径资源、文件系统资源或网页资源）的策略。这个接口是\r\nSpring\r\n资源加载抽象的核心，使得应用程序可以从不同的资源位置以统一的方式加载资源。\r\nSpring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是\r\nFileSystemXmlApplicationContext, res\r\n就是FileSystemResource实例;如果ApplicationContext是\r\nClassPathXmIApplicationContext, res\r\n就是ClassPathResource实例\r\n当Spring应用需要进行资源访问时，实际上并不需要直接使用 Resource\r\n实现类，而是调用 ResourceLoader 实例的\r\ngetResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策\r\n略，从而将应用程序和具体的资源访问策略分离开来\r\n另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、\r\nFileSystemResource等实现类.（多态）\r\nResource res = ctx.getResource(&quot;classpath:bean.xml&quot;);Resource res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;https://localhost8080.bean.xml&quot;);\r\n主要功能\r\n\r\n统一资源加载 ResourceLoader\r\n提供了一个标准化的方法来加载资源，不论资源是存放在类路径、文件系统、网络URL还是其他位置。\r\n资源位置解析 根据提供的资源字符串位置（如 “classpath:”, “file:”,\r\n“http:”），ResourceLoader 可以确定资源的类型，并为其创建相应的 Resource\r\n实例。\r\n返回 Resource 实例 通过 Resource getResource(String location)\r\n方法，ResourceLoader 返回一个 Resource\r\n对象，代表了指定位置的资源。这使得读取和操作资源变得简单且统一。\r\n与 ClassLoader 的交互 ResourceLoader 通过 ClassLoader\r\ngetClassLoader() 方法返回与其关联的\r\nClassLoader。这使得资源加载策略可以与特定的类加载器关联。\r\n扩展性 ResourceLoader\r\n是一个接口，这意味着我们可以实现自己的资源加载策略，或者扩展默认的策略以满足特定需求。\r\n内置实现与整合\r\nSpring 提供了默认的 ResourceLoader 实现，如\r\nDefaultResourceLoader。但更重要的是，org.springframework.context.ApplicationContext\r\n也实现了 ResourceLoader，这意味着 Spring\r\n上下文本身就是一个资源加载器。\r\n\r\n接口源码\r\nResourceLoader 接口为 Spring\r\n框架定义了资源加载策略。它提供了获取资源的方法，并公开了其使用的\r\nClassLoader。通过这种策略，资源可以从各种来源（如类路径、文件系统等）以统一方式加载。这提供了资源加载的灵活性和一致性，并支持各种资源描述符，如\r\nURL、类路径等。此外，它还允许对资源句柄进行多次重新使用和读取。\r\n/** * 用于加载资源（例如类路径或文件系统资源）的策略接口。 * 一个 ApplicationContext 需要提供此功能以及扩展的 ResourcePatternResolver 支持。 *  * DefaultResourceLoader 是一个独立的实现，可在 ApplicationContext 外部使用，并被 ResourceEditor 使用。 *  * 当在 ApplicationContext 中运行时，类型为 Resource 和 Resource[] 的 Bean 属性可以从字符串中填充，使用特定上下文的资源加载策略。 * * @author Juergen Hoeller * @since 10.03.2004 */public interface ResourceLoader &#123;\t/** 用于从类路径加载的伪 URL 前缀：&quot;classpath:&quot;。 */\tString CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\t/**\t * 返回指定资源位置的 Resource 句柄。\t * 该句柄应始终是一个可重用的资源描述符，允许进行多次 Resource#getInputStream() 调用。\t * 必须支持完全限定的 URLs，例如 &quot;file:C:/test.dat&quot;。\t * 必须支持类路径伪-URLs，例如 &quot;classpath:test.dat&quot;。\t * 应支持相对文件路径，例如 &quot;WEB-INF/test.dat&quot;。\t * （这将是实现特定的，通常由 ApplicationContext 实现提供。）\t * 请注意，Resource 句柄并不意味着资源存在；我们需要调用 Resource#exists 来检查其存在性。\t *\t * @param location 资源位置\t */\tResource getResource(String location);\t/**\t * 公开此 ResourceLoader 使用的 ClassLoader。\t * 需要直接访问 ClassLoader 的客户端可以与 ResourceLoader 以统一的方式这样做，而不是依赖线程上下文 ClassLoader。\t *\t * @return ClassLoader（仅当连系统 ClassLoader 都不可访问时为 null）\t */\t@Nullable\tClassLoader getClassLoader();&#125;\r\npublic class ResourceLoaderDemo &#123;        public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext();        Resource resource = context.getResource(&quot;test&quot;);                ApplicationContext ctx = new FileSystemXmlApplicationContext();        Resource resource2 = context.getResource(&quot;test&quot;);    &#125;&#125;\r\n主要实现\r\n\r\nDefaultResourceLoader\r\n\r\n这是基本的资源加载器实现。它可以处理 “classpath:”\r\n前缀的资源，如果没有提供这样的前缀，它会尝试使用类加载器或文件系统来加载资源。\r\n\r\n使用 DefaultResourceLoader\r\n从不同的资源（类路径和文件系统）加载内容。\r\n示例\r\npublic class DefaultResourceLoaderDemo &#123;    public static void main(String[] args) &#123;        DefaultResourceLoader loader = new DefaultResourceLoader();        // 从类路径加载资源        Resource classpathResource = loader.getResource(&quot;classpath:application.properties&quot;);        try (InputStream is = classpathResource.getInputStream()) &#123;            // 读取和处理资源内容            System.out.println(&quot;Classpath = &quot;+ new String(is.readAllBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 加载文件系统中的资源        Resource fileResource = loader.getResource(&quot;file:/idea-work-space-xcs/spring-reading/spring-resources/spring-resource-resourceLoader/myfile1.txt&quot;);        try (InputStream is = fileResource.getInputStream()) &#123;            // 读取和处理资源内容            System.out.println(&quot;File = &quot;+ new String(is.readAllBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\r\n\r\n运行结果发现\r\n从类路径上，我们加载了一个文件：application.properties。这意味着在我们的项目的类路径中，有这个文件。\r\n从文件系统上，我们加载了一个文件：myfile1.txt。这些文件位于我们之前在代码中硬编码的文件路径\r\n/idea-work-space-xcs/spring-reading/spring-resources/spring-resource-resourceLoader/\r\n下。\r\n与其他组件的关系\r\n\r\nApplicationContext\r\n所有的 Spring ApplicationContext 都实现了\r\nResourceLoader。这意味着我们可以使用 Spring\r\n上下文本身来加载资源。\r\nResource\r\nResourceLoader 返回 Resource\r\n对象，它代表实际的资源，可以是文件系统中的文件、类路径资源、URLs\r\n等。Resource 提供了访问和读取资源内容的方法。\r\nResourcePatternResolver 这是 ResourceLoader\r\n的扩展，可以解析给定的位置模式以加载多个资源。PathMatchingResourcePatternResolver\r\n是它的主要实现。\r\nResourceEditor 这是一个属性编辑器，用于将字符串转换为 Resource\r\n对象。它内部使用 ResourceLoader 来执行转换。\r\nResourceLoaderAware\r\n这是一个特殊的接口，任何 bean\r\n如果实现了它，那么它就可以在被创建时获得对 ResourceLoader\r\n的引用，这样它就可以自己加载资源。\r\nEmbeddedValueResolverAware\r\n一些组件，如属性占位符处理器，可能需要解析值中的动态部分。它们可以使用\r\nResourceLoader\r\n作为解析这些值的一部分，特别是当值代表资源位置时。\r\nPathMatchingResourcePatternResolver\r\n它是 ResourcePatternResolver 的一个实现，它扩展了 ResourceLoader\r\n来处理以 “classpath*:”\r\n开头的资源模式，这允许加载所有匹配的资源，而不仅仅是第一个找到的资源。\r\n\r\n常见问题\r\n\r\n加载类路径资源 使用前缀\r\n“classpath:”，例如：loader.getResource(“classpath:myconfig.xml”)。\r\n加载文件系统资源\r\n使用前缀\r\n“file:”，例如：loader.getResource(“file:/path/to/myconfig.xml”)。\r\n加载URL资源\r\n直接使用\r\nURL，例如：loader.getResource(“http://www.example.com/config.xml”)。\r\n资源不存在 使用 Resource.exists()\r\n方法检查资源是否存在。确保路径或位置正确，并且资源真的存在于预期的位置。\r\n如何读取资源内容 从 Resource 对象中获取\r\nInputStream，例如：resource.getInputStream()。\r\n从 Resource 获取到文件路径 使用\r\nResource.getFile()。但请注意，这并不总是有效的，例如当资源实际上是一个类路径资源或URL资源时。\r\n自动注入 ResourceLoader 实现 ResourceLoaderAware 接口，Spring\r\n将自动为我们的 bean 提供 ResourceLoader 的引用。\r\n扩展或自定义资源加载机制 我们可以实现自己的 ResourceLoader\r\n或继承现有的实现，如 DefaultResourceLoader\r\n加载资源时考虑环境或属性占位符 使用 PropertyPlaceholderConfigurer\r\n或 PropertySourcesPlaceholderConfigurer 与 @Value 注解可以解析属性值中的资源路径\r\n\r\n\r\nResourceLoaderAware 接口\r\n在 Spring 中，ResourceLoaderAware\r\n接口是一个回调接口，它提供了一个用于设置 Bean 所在的ResourceLoader\r\n的方法。当一个 Bean 实现了 ResourceLoaderAware 接口时，在该 Bean\r\n实例被实例化后，Spring 容器会调用 setResourceLoader 方法，并将该 Bean\r\n所在的 ResourceLoader 作为参数传递进去。\r\n源码\r\n\r\n\r\nimg\r\n\r\nResourceLoaderAware 主要用于获取加载当前 Bean 的\r\nResourceLoader，使得 Bean\r\n能够在运行时获取到关于资源加载的能力。\r\n使用\r\n要让一个Bean实现 ResourceLoaderAware\r\n接口，需要按以下步骤进行\r\n\r\n\r\nimg\r\n\r\npackage org.example.cheney;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import java.io.InputStream;public class DemoBean implements ResourceLoaderAware &#123;    private ResourceLoader resourceLoader;    @Override    public void setResourceLoader(ResourceLoader resourceLoader) &#123;        this.resourceLoader = resourceLoader;        System.out.println(&quot;【ResourceLoaderAware】: 通过 ResourceLoader 创建 Bean&quot;);    &#125;    public void loadResource(String resourceName) throws Exception &#123;        // 使用 ResourceLoader 加载资源        System.out.println(&quot;加载的文件名是: &quot; + resourceName);        Resource resource = resourceLoader.getResource(resourceName);        InputStream inputStream = resource.getInputStream();        // 读取资源内容        byte[] contentBytes = new byte[inputStream.available()];        inputStream.read(contentBytes);        String content = new String(contentBytes);        System.out.println(&quot;文件内容:\\n&quot; + content);    &#125;&#125;\r\n配置bean\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;       &gt;    &lt;bean id=&quot;demoBean&quot; class=&quot;org.example.cheney.DemoBean&quot;/&gt;&lt;/beans&gt;\r\n测试输出\r\npackage org.example.cheney;import org.springframework.context.support.AbstractXmlApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123;    public static void main(String[] args) throws Exception &#123;        String location = &quot;applicationContext.xml&quot;;        try (AbstractXmlApplicationContext context = new ClassPathXmlApplicationContext(location)) &#123;            DemoBean demo = (DemoBean) context.getBean(&quot;demoBean&quot;);            demo.loadResource(&quot;classpath:demo.txt&quot;);            System.out.println(&quot;End.&quot;);        &#125;    &#125;&#125;\r\nResourceLoaderAware 接口通常用于以下场景：\r\n\r\n加载资源：\r\n当一个 Bean 需要在运行时加载外部资源时，可以使用 ResourceLoaderAware\r\n获取 ResourceLoader 并使用它加载资源\r\n处理资源相关逻辑： 当一个 Bean\r\n与资源相关的操作时，例如读取配置文件、加载模板文件等，可以使用\r\nResourceLoaderAware 获取 ResourceLoader\r\n\r\n\r\n使用Resource作为属性\r\n前面介绍了Spring提供的资源访问策略，但这些依赖访问策略要么需要使用Resource实现类，要么需要使用\r\nApplicationContext来获取资源。实际上，当应用程序中的Bean实例需要访问资源时，Spring有更好的解决方\r\n法：直接利用依赖注入。从这个意义上来看，Spring框架不仅充分利用了策略模式来简化资源访问，而且还将策\r\n略模式和IoC进行充分地结合，最大程度地简化了Spring资源访问。\r\n归纳起来，如果Bean实例需要访问资源，有如下两种解决方案：\r\n\r\n代码中获取Resource实例。\r\n使用依赖注入\r\n\r\n对于第一种方式，当程序获取Resource实例时，总需要提供Resource所在的位置，不管通过FileSystemResource创建实例，还是通过ClassPathResource创建实例，或者通过ApplicationContext的getResource()方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让Spring为Bean实例依赖注入资源。\r\n示例\r\npackage edu.software.ergoutree.springresources.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestBean &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        RescoureBean rescoureBean = context.getBean(RescoureBean.class);        rescoureBean.pares();    &#125;&#125;\r\nbean配置\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--解耦合--&gt;    &lt;bean id=&quot;rescoureBean&quot; class=&quot;edu.software.ergoutree.springresources.di.RescoureBean&quot;&gt;        &lt;property name=&quot;resource&quot; value=&quot;classpath*:test&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n测试\r\npackage edu.software.ergoutree.springresources.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestBean &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        RescoureBean rescoureBean = context.getBean(RescoureBean.class);        rescoureBean.pares();    &#125;&#125;\r\n\r\n应用程序上下文和资源路径–Resource\r\n指定访问策略\r\n在 Spring\r\n框架中，应用程序上下文（ApplicationContext）不仅负责管理\r\nBean 的生命周期，还提供了资源加载的能力。通过\r\nApplicationContext，开发者可以方便地访问不同类型的资源，而无需关心底层的资源访问细节。ApplicationContext\r\n本身实现了 ResourceLoader\r\n接口，因此可以直接通过上下文加载资源。\r\n资源路径的指定方式\r\nSpring\r\n支持多种资源路径的指定方式，开发者可以通过不同的前缀来强制使用特定的资源访问策略。以下是常见的资源路径前缀及其对应的访问策略：\r\n\r\nclasspath:\r\n表示从类路径下加载资源。例如：\r\nResource resource = context.getResource(&quot;classpath:config.properties&quot;);\r\n这会从类路径（如 src/main/resources）中查找\r\nconfig.properties 文件。\r\nfile:\r\n表示从文件系统中加载资源。例如：\r\nResource resource = context.getResource(&quot;file:/path/to/config.properties&quot;);\r\n这会从文件系统的指定路径加载文件。\r\nhttp: 或 https:\r\n表示从网络 URL 加载资源。例如：\r\nResource resource = context.getResource(&quot;https://example.com/config.properties&quot;);\r\n这会通过 HTTP 或 HTTPS 协议从远程服务器加载资源。\r\n无前缀\r\n如果没有指定前缀，ApplicationContext\r\n会根据上下文类型决定默认的资源访问策略：\r\n\r\n对于\r\nClassPathXmlApplicationContext，默认从类路径加载资源。\r\n对于\r\nFileSystemXmlApplicationContext，默认从文件系统加载资源。\r\n\r\n\r\n示例代码\r\n以下是一个完整的示例，展示如何通过 ApplicationContext\r\n加载不同类型的资源：\r\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import java.io.IOException;import java.io.InputStream;public class ResourceLoadingDemo &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext();        // 从类路径加载资源        Resource classpathResource = context.getResource(&quot;classpath:application.properties&quot;);        printResourceContent(classpathResource);        // 从文件系统加载资源        Resource fileResource = context.getResource(&quot;file:/path/to/myfile.txt&quot;);        printResourceContent(fileResource);        // 从网络 URL 加载资源        Resource urlResource = context.getResource(&quot;https://example.com/data.json&quot;);        printResourceContent(urlResource);    &#125;    private static void printResourceContent(Resource resource) &#123;        try (InputStream inputStream = resource.getInputStream()) &#123;            byte[] bytes = inputStream.readAllBytes();            System.out.println(&quot;Resource content: &quot; + new String(bytes));        &#125; catch (IOException e) &#123;            System.err.println(&quot;Failed to read resource: &quot; + e.getMessage());        &#125;    &#125;&#125;\r\n资源路径的通配符支持\r\nSpring 还支持使用通配符加载多个资源，例如：\r\n\r\nclasspath*:：从所有类路径下匹配的资源加载。加载多个\r\nfile: 或 classpath:\r\n结合通配符：匹配符合模式的文件。\r\n\r\nResource[] resources = context.getResources(&quot;classpath*:config/*.properties&quot;);for (Resource res : resources) &#123;    System.out.println(&quot;Found resource: &quot; + res.getFilename());&#125;\r\n通过 ApplicationContext\r\n加载资源时，开发者可以通过前缀指定资源的访问策略，从而实现灵活的资源管理。这种方式不仅简化了代码，还提高了应用程序的可维护性和可扩展性。无论是类路径资源、文件系统资源还是网络资源，Spring\r\n都提供了统一的访问接口，使得资源加载变得简单而高效。\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"Spring中使用Hibernate整合","url":"/posts/48924.html","content":"Spring中使用Hibernate\r\nHibernate是最流行的ORM框架之一，而Spring提供了对Hibernate的出色集成支持。\r\n本文介绍如何在传统Spring框架(非Spring Boot)中集成Hibernate。\r\n项目搭建结构\r\n我们先写一个例子，来看看 Spring 中如何使用和体现 Hibernate\r\n项目结构\r\n典型的Spring框架集成Hibernate的项目目录结构（Maven项目）：\r\nsrc/├── main/│   ├── java/│   │   └── com/│   │       └── yourcompany/│   │           └── yourapp/│   │               ├── config/               # Spring配置类│   │               │   └── HibernateConfig.java│   │               ├── controller/           # 控制器层│   │               │   └── EmployeeController.java│   │               ├── service/              # 服务层│   │               │   ├── EmployeeService.java│   │               │   └── impl/│   │               │       └── EmployeeServiceImpl.java│   │               ├── dao/                  # 数据访问层│   │               │   ├── EmployeeDao.java│   │               │   └── impl/│   │               │       └── EmployeeDaoImpl.java│   │               ├── model/                # 实体类│   │               │   ├── Employee.java│   │               │   ├── Department.java│   │               │   └── enums/            # 枚举类型│   │               │       └── EmployeeStatus.java│   │               ├── dto/                  # 数据传输对象│   │               │   └── EmployeeDTO.java│   │               └── AppMain.java          # 主启动类│   ├── resources/│   │   ├── application.properties           # 应用配置│   │   ├── hibernate.cfg.xml                # Hibernate配置(可选)│   │   ├── messages/                        # 国际化资源│   │   │   └── messages.properties│   │   └── META-INF/│   │       └── persistence.xml              # JPA配置(可选)│   └── webapp/                              # Web相关资源(如果是Web应用)│       ├── WEB-INF/│       │   ├── views/                       # 视图文件│       │   │   └── employees.jsp│       │   └── web.xml                      # Web部署描述符│       └── resources/                       # 静态资源│           ├── css/│           ├── js/│           └── images/└── test/                                    # 测试代码    └── java/        └── com/            └── yourcompany/                └── yourapp/                    ├── service/                    │   └── EmployeeServiceTest.java                    └── dao/                        └── EmployeeDaoTest.java\r\n但是本次演示，还是打算写成简单一些的方式\r\n添加依赖\r\n&lt;dependencies&gt;    &lt;!-- Spring核心依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.20&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- Spring ORM (包含对Hibernate的支持) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.20&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- Hibernate核心 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;        &lt;version&gt;5.6.10.Final&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 数据库驱动 (以MySQL为例) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.29&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 连接池 (HikariCP推荐) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;        &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;        &lt;version&gt;5.0.1&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- JTA API (可选，需要事务管理时) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;        &lt;artifactId&gt;javax.transaction-api&lt;/artifactId&gt;        &lt;version&gt;1.3&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\r\n配置 Spring 配置文件\r\n创建Spring配置文件applicationContext.xml，application.properties，或者使用Java配置类：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 启用注解驱动 --&gt;    &lt;context:annotation-config/&gt;    &lt;!--配置了组件扫描路径，Spring 会自动扫描指定包下的 @Component、@Service 等注解的类--&gt;    &lt;context:component-scan base-package=&quot;com.yourpackage&quot;/&gt;        &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot; destroy-method=&quot;close&quot;&gt;        &lt;!--配置 MySQL 数据库连接信息，包括驱动类、URL、用户名和密码--&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;your_username&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;your_password&quot;/&gt;        &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 配置Hibernate SessionFactory --&gt;    &lt;!-- 指定扫描实体类的包路径 --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;        &lt;!--设置 Hibernate 的方言、SQL 显示、格式化和 DDL 自动更新等属性--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;                &lt;!-- 其他Hibernate属性 --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!-- 配置事务管理器 --&gt;    &lt;!-- 配置 Hibernate 事务管理器，启用注解驱动的事务管理 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 启用注解驱动的事务管理 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;\r\nproperties 貌似是给 spring boot 用的，纯framework貌似都用xml\r\n我感觉这个更方便\r\n# 数据源配置spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;serverTimezone=UTCspring.datasource.username=your_usernamespring.datasource.password=your_passwordspring.datasource.hikari.maximum-pool-size=10# Hibernate配置spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialectspring.jpa.show-sql=truespring.jpa.properties.hibernate.format_sql=truespring.jpa.hibernate.ddl-auto=update# 扫描实体类的包路径spring.jpa.hibernate.packages-to-scan=com.yourpackage.model\r\n确保主应用类上有 @SpringBootApplication\r\n注解，它包含了 @ComponentScan 功能\r\nJava 配置方式\r\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.orm.hibernate5.HibernateTransactionManager;import org.springframework.orm.hibernate5.LocalSessionFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;import java.util.Properties;@Configuration@EnableTransactionManagementpublic class HibernateConfig &#123;    @Bean    public DataSource dataSource() &#123;        HikariDataSource dataSource = new HikariDataSource();        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;serverTimezone=UTC&quot;);        dataSource.setUsername(&quot;your_username&quot;);        dataSource.setPassword(&quot;your_password&quot;);        dataSource.setMaximumPoolSize(10);        return dataSource;    &#125;    @Bean    public LocalSessionFactoryBean sessionFactory() &#123;        LocalSessionFactoryBean sessionFactory = new LocalSessionFactoryBean();        sessionFactory.setDataSource(dataSource());        sessionFactory.setPackagesToScan(&quot;com.yourpackage.model&quot;);        sessionFactory.setHibernateProperties(hibernateProperties());        return sessionFactory;    &#125;    private Properties hibernateProperties() &#123;        Properties properties = new Properties();        properties.setProperty(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQL8Dialect&quot;);        properties.setProperty(&quot;hibernate.show_sql&quot;, &quot;true&quot;);        properties.setProperty(&quot;hibernate.format_sql&quot;, &quot;true&quot;);        properties.setProperty(&quot;hibernate.hbm2ddl.auto&quot;, &quot;update&quot;);        // 其他Hibernate属性        return properties;    &#125;    @Bean    public PlatformTransactionManager transactionManager() &#123;        HibernateTransactionManager transactionManager = new HibernateTransactionManager();        transactionManager.setSessionFactory(sessionFactory().getObject());        return transactionManager;    &#125;&#125;\r\n创建实体类\r\n使用Hibernate注解定义实体类\r\nimport javax.persistence.*;import java.util.Date;/** * 员工实体类，映射数据库中的 employees 表 * 包含员工的基本信息和所属部门关联 */@Entity@Table(name = &quot;employees&quot;)    // 映射到 employees 表public class Employee &#123;        /**     * 员工ID，主键，自增长     * 使用 GenerationType.IDENTITY 依赖数据库的自增机制     */    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        /**     * 员工名，不可为空，最大长度50     */    @Column(name = &quot;first_name&quot;, nullable = false, length = 50)    private String firstName;        /**     * 员工姓，不可为空，最大长度50     */    @Column(name = &quot;last_name&quot;, nullable = false, length = 50)    private String lastName;        /**     * 员工邮箱，不可为空，必须唯一     * 通常用于系统登录或联系信息     */    @Column(nullable = false, unique = true)    private String email;        /**     * 雇佣日期，仅存储日期部分（忽略时间）     * 使用 TemporalType.DATE 映射到数据库的 DATE 类型     */    @Column(name = &quot;hire_date&quot;)    @Temporal(TemporalType.DATE)    private Date hireDate;        /**     * 所属部门，多对一关联     * 使用 FetchType.LAZY 实现延迟加载，避免查询员工时立即加载部门信息     * 通过 department_id 外键关联 departments 表     */    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name = &quot;department_id&quot;)    private Department department;        // 构造函数    public Employee() &#123; &#125;        public Employee(String firstName, String lastName, String email, Date hireDate) &#123;        this.firstName = firstName;        this.lastName = lastName;        this.email = email;        this.hireDate = hireDate;    &#125;&#125;\r\n创建DAO层\r\n传统Hibernate DAO实现\r\n这里使用了大量 session 的方法和 query 等常用 api 的方法，体现了\r\nHibernate 的使用\r\nimport org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 员工数据访问对象（DAO） * 负责与数据库进行交互，处理 Employee 实体的持久化操作 */@Repository@Transactionalpublic class EmployeeDao &#123;        /**     * Hibernate SessionFactory，由 Spring 容器注入     * 用于获取与数据库的会话（Session）     */    @Autowired    private SessionFactory sessionFactory;        /**     * 获取当前线程绑定的 Hibernate Session     * 在 @Transactional 注解的事务上下文中，Spring 会自动管理 Session 的生命周期     */    protected Session getCurrentSession() &#123;        return sessionFactory.getCurrentSession();    &#125;        /**     * 根据 ID 查询员工     * @param id 员工 ID     * @return 对应的 Employee 对象，若不存在则返回 null     */    public Employee findById(Long id) &#123;        return getCurrentSession().get(Employee.class, id);    &#125;        /**     * 保存或更新员工信息     * - 若员工 ID 为空（null），则执行插入操作     * - 若员工 ID 已存在，则执行更新操作     * @param employee 要保存或更新的 Employee 对象     */    public void save(Employee employee) &#123;        getCurrentSession().saveOrUpdate(employee);    &#125;        /**     * 删除员工记录     * @param employee 要删除的 Employee 对象     */    public void delete(Employee employee) &#123;        getCurrentSession().delete(employee);    &#125;        /**     * 查询所有员工     * @return 包含所有 Employee 对象的列表     */    @SuppressWarnings(&quot;unchecked&quot;)    public List&lt;Employee&gt; findAll() &#123;        return getCurrentSession().createQuery(&quot;from Employee&quot;).list();    &#125;        /**     * 根据姓氏查询员工     * @param lastName 要查询的姓氏     * @return 包含匹配 Employee 对象的列表     */    public List&lt;Employee&gt; findByLastName(String lastName) &#123;        return getCurrentSession()                .createQuery(&quot;from Employee where lastName = :lastName&quot;, Employee.class)                .setParameter(&quot;lastName&quot;, lastName)                .list();    &#125;&#125;\r\n主要注解解析\r\n\r\n@Repository\r\n\r\n\r\n作用\r\n\r\n声明该类为 Spring 的数据访问组件（DAO），是 @Component\r\n的特殊化版本。\r\n自动将 DAO 类注册为 Spring Bean，并支持 Spring\r\n的数据访问异常转换（将 Hibernate/JPA 异常转换为 Spring 的\r\nDataAccessException 体系）。\r\n\r\n\r\n\r\n@Transactional\r\n\r\n\r\n作用\r\n\r\n声明该类的所有公共方法都在事务管理下执行。\r\n默认配置下：\r\n\r\n事务传播行为为\r\nPROPAGATION_REQUIRED（若当前无事务，则创建新事务；否则加入当前事务）。\r\n事务隔离级别为数据库默认级别。\r\n所有 RuntimeException 会触发事务回滚，受检异常（如\r\nIOException）不会触发回滚。\r\n\r\n\r\n\r\n\r\n@Autowired\r\n\r\n\r\n作用\r\n\r\n通过类型自动注入依赖的 Bean（此处注入\r\nSessionFactory）。\r\nSpring 会在容器中查找 SessionFactory 类型的 Bean\r\n并注入。\r\n\r\n\r\n方法解析\r\n\r\ngetCurrentSession()\r\n\r\n\r\n功能：获取当前线程绑定的\r\nSession。\r\n关键点\r\n\r\n在 @Transactional\r\n注解的事务上下文中，Session 由 Spring\r\n自动管理，无需手动关闭。\r\n若不在事务中调用此方法，会抛出异常。\r\n\r\n\r\n\r\nfindById(Long id)\r\n\r\n\r\n功能：根据 ID 查询员工。\r\nHibernate 方法\r\n\r\nSession.get(Class, id)：立即查询数据库，若记录不存在返回\r\nnull。\r\n\r\n\r\n\r\nsave(Employee employee)\r\n\r\n\r\n功能：保存或更新员工。\r\nHibernate 方法\r\n\r\n``` Session.saveOrUpdate(Object)     - 若对象的 ID 为 `null` 或未持久化状态，执行 `INSERT`。    - 若对象的 ID 已存在，执行 `UPDATE`。4. `delete(Employee employee)`- **功能**：删除员工记录。- Hibernate 方法  - `Session.delete(Object)`：将对象从持久化状态变为删除状态，事务提交时执行 `DELETE` 语句。5. `findAll()`- **功能**：查询所有员工。- Hibernate 查询  - `Session.createQuery(&quot;from Employee&quot;)`：使用 HQL（Hibernate Query Language）查询，等价于 SQL 的 `SELECT * FROM employees`。  - `@SuppressWarnings(&quot;unchecked&quot;)`：抑制原始类型警告（Hibernate 5.2 前的 `createQuery()` 返回未泛型化的 `Query` 对象）。6. `findByLastName(String lastName)`- **功能**：根据姓氏查询员工。- Hibernate 查询  - `createQuery(&quot;from Employee where lastName = :lastName&quot;, Employee.class)`：使用具名参数的 HQL 查询，防止 SQL 注入。  - `setParameter(&quot;lastName&quot;, lastName)`：绑定参数值。### 服务层实现```javaimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * 员工服务层 * 处理员工相关的业务逻辑，调用 DAO 层完成数据持久化操作 */@Servicepublic class EmployeeService &#123;        /**     * 员工数据访问对象     * 由 Spring 容器自动注入，用于执行数据库操作     */    @Autowired    private EmployeeDao employeeDao;        /**     * 根据 ID 获取员工信息     * @param id 员工 ID     * @return 对应的员工对象，若不存在则返回 null     */    @Transactional(readOnly = true)    public Employee getEmployeeById(Long id) &#123;        return employeeDao.findById(id);    &#125;        /**     * 保存或更新员工信息     * - 新增员工：当员工对象 ID 为空时     * - 更新员工：当员工对象 ID 已存在时     * @param employee 员工对象     */    @Transactional    public void saveEmployee(Employee employee) &#123;        employeeDao.save(employee);    &#125;        /**     * 删除员工信息     * @param employee 要删除的员工对象     */    @Transactional    public void deleteEmployee(Employee employee) &#123;        employeeDao.delete(employee);    &#125;        /**     * 获取所有员工列表     * @return 包含所有员工的列表     */    @Transactional(readOnly = true)    public List&lt;Employee&gt; getAllEmployees() &#123;        return employeeDao.findAll();    &#125;        /**     * 根据姓氏搜索员工     * @param lastName 姓氏     * @return 匹配的员工列表     */    @Transactional(readOnly = true)    public List&lt;Employee&gt; searchByLastName(String lastName) &#123;        return employeeDao.findByLastName(lastName);    &#125;&#125;\r\n\r\n\r\n主要注解解析\r\n\r\n@Service\r\n\r\n\r\n作用\r\n\r\n声明该类为 Spring 的服务层组件，是 @Component\r\n的特殊化版本。\r\n用于标识业务逻辑层，提高代码可读性和可维护性。\r\n\r\nSpring 容器行为\r\n\r\n自动扫描并注册为 Bean，可通过依赖注入使用。\r\n\r\n\r\n\r\n@Autowired\r\n\r\n\r\n作用\r\n\r\n通过类型自动注入依赖的 Bean（此处注入\r\nEmployeeDao）。\r\n\r\n依赖注入方式\r\n\r\n字段注入：简洁但不利于单元测试（建议使用构造器注入，Spring 4.3+\r\n支持单参构造器省略 @Autowired）。\r\n\r\n\r\n\r\n@Transactional\r\n\r\n\r\n作用\r\n\r\n声明方法在事务管理下执行，确保数据操作的原子性、一致性、隔离性和持久性（ACID）。\r\n\r\n关键属性\r\n\r\n```java readOnly = true     - 标记为只读事务，优化查询性能（如禁用缓存刷新、数据库优化等）。    - 仅用于查询方法，不可用于增删改操作。- 默认配置  - 传播行为：`PROPAGATION_REQUIRED`（若当前无事务，则创建新事务；否则加入当前事务）。  - 隔离级别：使用数据库默认级别（如 MySQL 的 `REPEATABLE READ`）。  - 回滚规则：默认对 `RuntimeException` 和 `Error` 回滚，对受检异常（如 `IOException`）不回滚。#### **方法解析**1. `getEmployeeById(Long id)`- **功能**：根据 ID 查询员工。- 事务特性  - `readOnly = true`：优化查询性能。- 业务逻辑  - 直接委派给 DAO 层执行数据库查询。2. `saveEmployee(Employee employee)`- **功能**：保存或更新员工信息。- 事务特性  - 读写事务，确保操作的原子性。- 业务逻辑  - 调用 DAO 层的 `save` 方法，可能触发 `INSERT` 或 `UPDATE`。3. `deleteEmployee(Employee employee)`- **功能**：删除员工信息。- 事务特性  - 读写事务，确保操作的原子性。- 业务逻辑  - 调用 DAO 层的 `delete` 方法执行物理删除。4. `getAllEmployees()`- **功能**：获取所有员工列表。- 事务特性  - `readOnly = true`：优化查询性能。- 业务逻辑  - 直接委派给 DAO 层查询所有记录。5. `searchByLastName(String lastName)`- **功能**：根据姓氏搜索员工。- 事务特性  - `readOnly = true`：优化查询性能。- 业务逻辑  - 直接委派给 DAO 层执行条件查询。#### **服务层设计原则**1. **单一职责**：   - 专注业务逻辑处理，不涉及数据访问细节（由 DAO 负责）。2. **事务边界**：   - 在服务层控制事务边界，确保业务操作的原子性（如转账需同时更新两个账户）。3. **数据校验**：   - 可在此层添加参数校验逻辑（示例中未体现，实际项目需添加）。4. **异常处理**：   - 可捕获 DAO 层异常并转换为业务异常（示例中未体现，实际项目需添加）。5. **事务传播**：   - 若方法间存在调用关系，需注意事务传播行为（默认 `REQUIRED` 可满足多数场景）。#### **注意事项**1. **事务嵌套**：   - 若服务层方法相互调用，需注意事务传播行为可能导致的意外结果（如内层方法异常导致整个事务回滚）。2. **只读事务**：   - 确保 `readOnly = true` 仅用于纯查询方法，否则可能导致数据无法持久化。3. **异常类型**：   - 业务异常建议继承 `RuntimeException`，确保事务自动回滚。### 事务管理Spring提供了声明式事务管理，可以通过注解轻松配置：```javaimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.hibernate.Hibernate; // Hibernate 特定 API@Service@Transactionalpublic class DepartmentService &#123;        @Autowired    private DepartmentDao departmentDao;        @Autowired    private EmployeeDao employeeDao;        /**     * 获取部门及其所有员工（包含延迟加载的员工集合）     * @param deptId 部门 ID     * @return 包含完整员工列表的部门对象     */    @Transactional(readOnly = true)    public Department getDepartmentWithEmployees(Long deptId) &#123;        // 1. 通过 DAO 查询部门（此时员工集合为延迟加载的代理对象）        Department dept = departmentDao.findById(deptId);                // 2. 强制初始化延迟加载的员工集合        // Hibernate 特定方法，在事务未关闭前触发 SQL 查询        Hibernate.initialize(dept.getEmployees());                // 3. 返回已初始化员工集合的部门对象        return dept;    &#125;        /**     * 批量转移员工到新部门     * @param fromDeptId 源部门 ID     * @param toDeptId   目标部门 ID     * @param employeeIds 待转移员工 ID 列表     */    @Transactional(rollbackFor = Exception.class)    public void transferEmployees(Long fromDeptId, Long toDeptId, List&lt;Long&gt; employeeIds) &#123;        // 1. 获取源部门和目标部门        Department fromDept = departmentDao.findById(fromDeptId);        Department toDept = departmentDao.findById(toDeptId);                // 2. 遍历员工 ID 列表，逐个转移        for (Long empId : employeeIds) &#123;            Employee emp = employeeDao.findById(empId);                        // 3. 从源部门移除员工（业务逻辑由实体类方法实现）            fromDept.removeEmployee(emp);                        // 4. 添加到目标部门（业务逻辑由实体类方法实现）            toDept.addEmployee(emp);                        // 5. 保存员工（更新部门关联）            employeeDao.save(emp);        &#125;                // 6. 保存部门变更（可选，取决于实体关系配置）        departmentDao.save(fromDept);        departmentDao.save(toDept);    &#125;&#125;\r\n\r\n\r\n主要注解解析\r\n\r\n@Service\r\n\r\n\r\n作用\r\n\r\n声明该类为 Spring 的服务层组件，负责业务逻辑处理。\r\n\r\nSpring 容器行为\r\n\r\n自动扫描并注册为 Bean，支持依赖注入。\r\n\r\n\r\n\r\n@Transactional（类级别）\r\n\r\n\r\n作用\r\n\r\n为所有公共方法提供默认事务配置。\r\n\r\n默认配置\r\n\r\n传播行为：PROPAGATION_REQUIRED（必要时创建新事务）。\r\n隔离级别：使用数据库默认级别。\r\n回滚规则：仅对 RuntimeException 和 Error\r\n回滚。\r\n\r\n\r\n\r\n@Transactional(readOnly = true)（方法级别）\r\n\r\n\r\n作用\r\n\r\n覆盖类级别的事务配置，标记方法为只读事务。\r\n\r\n优化点\r\n\r\nHibernate 会优化查询执行（如禁用脏检查）。\r\n数据库可优化只读事务的锁策略。\r\n\r\n\r\n\r\n@Transactional(rollbackFor = Exception.class)（方法级别）\r\n\r\n\r\n作用\r\n\r\n覆盖类级别的回滚规则，指定所有异常（包括受检异常）都触发事务回滚。\r\n\r\n适用场景\r\n\r\n确保业务异常（如\r\nValidationException）也能触发回滚。\r\n\r\n\r\n方法解析\r\n\r\ngetDepartmentWithEmployees(Long deptId)\r\n\r\n\r\n功能：获取部门及其所有员工。\r\nHibernate 集成点\r\n\r\n延迟加载处理\r\n\r\ndepartmentDao.findById(deptId) 返回的\r\nDepartment 对象中，employees 集合是 Hibernate\r\n代理对象（未初始化）。\r\nHibernate.initialize(dept.getEmployees()) 强制触发 SQL\r\n查询，在事务未关闭前加载员工数据。\r\n\r\nSession 生命周期\r\n\r\n方法在事务内执行，Session 保持打开状态，允许延迟加载初始化。\r\n\r\n\r\n\r\n\r\ntransferEmployees(...)\r\n\r\n\r\n功能：批量转移员工到新部门。\r\nHibernate 集成点\r\n\r\n实体状态管理\r\n\r\n通过 DAO 获取的 Department 和 Employee\r\n对象处于持久化状态。\r\n修改持久化对象的关联关系（如\r\nremoveEmployee、addEmployee）会被 Hibernate\r\n自动跟踪。\r\n\r\n级联操作\r\n\r\nemployeeDao.save(emp) 可能无需调用（取决于实体类的\r\ncascade 配置）。\r\n若 Department 实体配置了\r\ncascade = CascadeType.ALL，则直接保存部门即可同步员工关联。\r\n\r\n事务一致性\r\n\r\n整个方法在单个事务中执行，确保数据一致性（要么全部转移成功，要么全部失败）。\r\n\r\n\r\n\r\nHibernate 集成关键点\r\n\r\n延迟加载（Lazy Loading）处理：\r\n\r\n通过 Hibernate.initialize()\r\n强制初始化延迟集合，避免在事务外访问时抛出\r\nLazyInitializationException。\r\n依赖 @Transactional 保持 Session 打开状态。\r\n\r\n实体状态管理：\r\n\r\nHibernate 跟踪持久化对象的状态变化，事务提交时自动生成 SQL。\r\n示例中通过 removeEmployee 和 addEmployee\r\n修改实体关系，无需手动编写 SQL。\r\n\r\n级联操作：\r\n\r\n实体类的 @OneToMany 或 @ManyToOne\r\n注解可能配置了 cascade 属性（如\r\nCascadeType.PERSIST、CascadeType.MERGE），决定关联对象的自动持久化行为。\r\n\r\nSession 生命周期：\r\n\r\nSpring 的 @Transactional 管理 Hibernate Session\r\n的打开、关闭和刷新。\r\n方法执行期间 Session 保持打开，允许多次数据库操作。\r\n\r\n\r\n注意事项\r\n\r\nN+1 查询问题：\r\n\r\ngetDepartmentWithEmployees 方法通过\r\nHibernate.initialize() 解决了 N+1\r\n查询问题（先查部门，再查所有员工）。\r\n更优方案：使用 JOIN FETCH 优化查询（如\r\nSELECT d FROM Department d JOIN FETCH d.employees WHERE d.id = :id）。\r\n\r\n事务边界：\r\n\r\ntransferEmployees\r\n方法必须在单个事务内执行，否则可能导致数据不一致（如部分员工转移成功，部分失败）。\r\n\r\n异常处理：\r\n\r\nrollbackFor = Exception.class\r\n确保所有异常都触发回滚，但需谨慎使用，避免掩盖业务问题。\r\n\r\n实体关系维护：\r\n\r\n示例假设 Department 实体的 removeEmployee\r\n和 addEmployee 方法同时维护双向关联（即更新\r\nEmployee 的 department 字段）。\r\n若未正确维护双向关联，可能导致数据库与对象状态不一致。\r\n\r\n\r\n高级配置\r\n二级缓存配置\r\n为什么配置二级缓存，什么时候配置\r\n\r\n减少数据库访问压力\r\n\r\n\r\n原理：将常用数据存储在应用服务器内存或分布式缓存中（如\r\nEhcache），避免重复查询数据库。\r\n场景：高并发读场景（如商品详情、字典表），减少数据库\r\nI/O 负载，提升系统吞吐量。\r\n\r\n\r\n提升查询性能\r\n\r\n\r\n原理：直接从缓存中读取数据，响应速度远快于数据库查询（内存访问速度比磁盘快\r\n10 万倍以上）。\r\n场景：频繁查询但不常更新的数据（如用户档案、配置信息），降低延迟，改善用户体验。\r\n\r\n\r\n减轻应用层压力\r\n\r\n\r\n原理：缓存分担了应用层的数据处理压力，尤其在复杂关联查询（如Department关联Employee）时，避免重复执行\r\nHibernate 的对象关系映射（ORM）操作。\r\n\r\n\r\n降低资源消耗\r\n\r\n\r\n原理：减少数据库连接的创建和释放频率，降低 JDBC\r\n操作的资源开销（如连接池压力）。\r\n\r\n添加Ehcache依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;    &lt;version&gt;5.6.10.Final&lt;/version&gt;&lt;/dependency&gt;\r\n在Hibernate配置中添加\r\nprivate Properties hibernateProperties() &#123;    Properties properties = new Properties();    // 其他配置...    properties.setProperty(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;true&quot;);    properties.setProperty(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;);    properties.setProperty(&quot;hibernate.javax.cache.provider&quot;, &quot;org.ehcache.jsr107.EhcacheCachingProvider&quot;);    properties.setProperty(&quot;hibernate.cache.use_query_cache&quot;, &quot;true&quot;);    return properties;&#125;\r\n在实体类上添加缓存注解\r\n@Entity@Cacheable // 声明实体类可缓存@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) // 配置缓存策略public class Department &#123;    // 使用READ_WRITE策略：支持读写操作，通过数据库事务保证缓存与数据库一致性    // 适用于读多写少、需要事务安全的场景&#125;\r\n延迟加载与缓存\r\npublic Department getDepartmentWithEmployees(Long deptId) &#123;    Department dept = departmentDao.findById(deptId);    Hibernate.initialize(dept.getEmployees()); // 手动初始化懒加载集合    return dept;&#125;\r\n若Department的employees集合使用二级缓存，初始化时会直接从缓存加载数据，避免执行SELECT * FROM employees WHERE department_id = ?的\r\nSQL 查询\r\n集成测试\r\nimport org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.transaction.annotation.Transactional;@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;HibernateConfig.class&#125;)@Transactionalpublic class EmployeeServiceTest &#123;        @Autowired    private EmployeeService employeeService;        @Test    public void testSaveAndFindEmployee() &#123;        Employee emp = new Employee();        emp.setFirstName(&quot;John&quot;);        emp.setLastName(&quot;Doe&quot;);        emp.setEmail(&quot;john.doe@example.com&quot;);        emp.setHireDate(new Date());                employeeService.saveEmployee(emp);                Employee found = employeeService.getEmployeeById(emp.getId());        assertNotNull(found);        assertEquals(&quot;John&quot;, found.getFirstName());    &#125;&#125;\r\n与传统Hibernate的区别\r\n在纯Hibernate应用中，你需要手动管理：\r\n\r\nSessionFactory的创建和关闭\r\nSession的生命周期\r\n事务边界\r\n异常处理\r\n\r\n而在Spring集成Hibernate中：\r\n\r\nSpring管理SessionFactory的生命周期\r\n通过HibernateTemplate或@Transactional自动管理Session\r\n声明式事务管理\r\nSpring的统一异常体系转换Hibernate异常\r\n\r\n关于配置 SessionFactory\r\n\r\n本部分感谢\r\nhttps://www.cnblogs.com/jwen1994/p/11299355.html，个人做出完善和修改\r\n\r\n使用 Hibernate\r\n框架的首要工作是编写Hibernate的配置文件，其次是如何使用这些配置文件实例化\r\nSessionFactory，创建 Hibernate 的基础设施。\r\nSpring 为创建 SessionFactory 提供了一个好用的 FactoryBean\r\n工厂类：org.springframework.orm.hibernateX.LocalSessionFactoryBean，通过配置一些必要的属性，就可以获取一个SessionFactoryBean。\r\nLocalSessionFactoryBean配置灵活度很高，支持开发者的不同习惯，让开发者拥有充分的选择权——这是Spring一贯的风格。\r\n贴合Hibernate的配置方式\r\n使用 HibernateAPI 创建一个 SessionFactory 的过程\r\n\r\n首先编写好对象关系的映射文件 xxx.hbm.xml；\r\n然后通过 Hibernate 的配置文件 hibernate.cfg.xml 将所有的\r\nxxx.hbm.xml 映射文件组装起来；\r\n最后通过以下经典的代码得到 SessionFactory 的实例：\r\nConfiguration cfg = new Configuration().configure(&quot;hibernate.cfg.xml&quot;)：SessionFactory sessionFactory = cfg.buildSessionFactory()；\r\n\r\nhibernate.cfg.xml 配置文件拥有创建 Hibernate\r\n基础设施所需的配置信息，来看一个最简单的 Hibernate 配置文件\r\n&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;property name=&quot;connection.driver_class&quot;&gt;            com.mysql.jdbc.Driver        &lt;/property&gt;        &lt;property name=&quot;connection.url&quot;&gt;            jdbc:mysql://localhost:3306/sampledb        &lt;/property&gt;        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;connection.password&quot;&gt;1234&lt;/property&gt;        &lt;property name=&quot;dialect&quot;&gt;            org.hibernate.dialect.MySQLDialect        &lt;/property&gt;        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;        &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;        &lt;mapping resource=&quot;com/smart/domain/Forum.hbm.xml&quot; /&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;\r\n这个配置文件定义了3个方面的信息：数据源、映射文件及 Hibernate\r\n控制属性。\r\n既然在 Hibernate 中可以使用一个配置文件创建一个\r\nSessionFactory 实例，在 Spring\r\n中也可以顺理成章地通过指定一个Hibernate配置文件，利用\r\nLocalSessionFactoryBean 来达到相同的目的。\r\n&lt;!-- 直接使用hibernate配置 --&gt;&lt;bean id=&quot;sessionFactory&quot;　　class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;　　p:configLocation=&quot;classpath:hibernate.cfg.xml&quot;/&gt;①      &lt;!--对应我上述xml文件中，也是使用了这种方式--&gt;&lt;!-- 配置Hibernate SessionFactory --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;\r\n如①处所示，通过 configLocation\r\n属性指定了一个Hibernate 配置文件。如果有多个\r\nHibernate 配置文件，则可以通过 configLocations\r\n属性指定，多个文件之间用逗号分隔。\r\nLocalSessionFactoryBean 将利用 Hibernate\r\n配置文件创建一个 SessionFactory 代理对象，以便和 Spring\r\n的事务管理机制配合工作：当数据访问代码使用 SessionFactory\r\n时，可以获取线程绑定的\r\nSession，不管工作在本地或全局的事务，都能正确参与到当前的\r\nSpring 事务管理中去。\r\n更具 Spring\r\n风格的配置\r\nSpring 对 ORM\r\n技术的一个重要支持就是提供统一的数据源管理机制，也许更多的开发者更愿意使用\r\nSpring 配置数据源，即在 Spring 容器中定义数据源、指定映射文件、设置\r\nHibernate 控制属性等信息，完成集成组装的工作，完全抛开 hibernate.cfg.xml\r\n配置文件，如下面代码所示。\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;    &lt;!-- 1. 加载外部属性文件 --&gt;    &lt;!--加载类路径下的 jdbc.properties 文件，使配置中可使用 $&#123;key&#125; 占位符引用属性值。--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;        &lt;!-- 2. 配置数据源 (使用 DBCP 连接池) --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;          p:driverClassName=&quot;$&#123;jdbc.driverClassName&#125;&quot;          p:url=&quot;$&#123;jdbc.url&#125;&quot;          p:username=&quot;$&#123;jdbc.username&#125;&quot;          p:password=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;!-- 3. 配置 Hibernate SessionFactory --&gt;    &lt;!-- 数据源注入：通过 p:dataSource-ref=&quot;dataSource&quot; 关联数据源 --&gt;    &lt;bean id=&quot;sessionFactory&quot;          class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;          p:dataSource-ref=&quot;dataSource&quot;&gt; &lt;!-- 注入数据源 --&gt;                  &lt;!-- ②指定实体类映射文件位置 --&gt;        &lt;property name=&quot;mappingLocations&quot;&gt;            &lt;list&gt;                &lt;value&gt;classpath*:/com/smart/orm/domain/Forum.hbm.xml&lt;/value&gt;                &lt;value&gt;classpath*:/com/smart/orm/domain/Topic.hbm.xml&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;                &lt;!-- 配置 Hibernate 核心属性 --&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;                    org.hibernate.dialect.MySQLDialect &lt;!-- 指定数据库方言 --&gt;                &lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;                    true &lt;!-- 显示执行的 SQL 语句 --&gt;                &lt;/prop&gt;                &lt;!-- 其他可配置属性:                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;!-- 自动更新数据库表结构 --&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;!-- 格式化 SQL 输出 --&gt;                &lt;prop key=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/prop&gt; &lt;!-- 添加 SQL 注释 --&gt;                &lt;prop key=&quot;hibernate.connection.autocommit&quot;&gt;false&lt;/prop&gt; &lt;!-- 禁用自动提交 --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!-- 4. 配置事务管理器 --&gt;    &lt;!--集成 Hibernate 事务管理--&gt;    &lt;bean id=&quot;transactionManager&quot;           class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;        &lt;!-- 5. 启用注解驱动的事务管理 --&gt;    &lt;!--启用 @Transactional 注解支持--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;        &lt;!-- 6. 其他 Bean 配置 (示例) --&gt;    &lt;bean id=&quot;forumService&quot; class=&quot;com.smart.service.ForumServiceImpl&quot;&gt;        &lt;property name=&quot;forumDao&quot; ref=&quot;forumDao&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;forumDao&quot; class=&quot;com.smart.dao.hibernate.ForumDaoHibernate&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n数据源、映射文件及 Hibernate 控制属性这三方面的信息在\r\nLocalSessionFactoryBean 中得到了完美集成，完全替代了\r\nhibernate.cfg.xml 的作用，但这种配置对于 Spring 开发者而言更加亲切。\r\n首先\r\n&lt;bean id=&quot;sessionFactory&quot;      class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;      p:dataSource-ref=&quot;dataSource&quot;&gt; &lt;!-- 注入数据源 --&gt;\r\n处指定的数据源是 Spring 容器中的数据源，不管是直接在 Spring\r\n容器中配置，还是通过  从 EJB\r\n容器中获取，对引用者而言是完全透明的。\r\n其次，凭借 Spring 资源处理的强大功能，指定 Hibernate\r\n映射文件变得相当灵活。在②&lt;property name=\"mappingLocations\"&gt;处采用了逐个指定映射文件的方法，其实这个方法是最笨拙的。由于\r\nmappingLocations 属性的类型是\r\nResource[]，因此它还支持以下简洁的配置方式：\r\n通过 Ant 风格的通配符\r\n批量加载指定包下的所有映射文件，避免逐个罗列。\r\n示例配置：\r\n&lt;property name=&quot;mappingLocations&quot;&gt;    &lt;list&gt;        &lt;!-- 扫描 com.smart.orm.domain 包及其所有子包下的所有 hbm.xml 文件 --&gt;        &lt;value&gt;classpath*:/com/smart/orm/domain/**/*.hbm.xml&lt;/value&gt;        &lt;!-- 扫描 classpath 根目录下的所有 hbm.xml 文件 --&gt;        &lt;value&gt;classpath*:/*.hbm.xml&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;\r\n若使用 JPA 注解（如 @Entity） 替代传统\r\n.hbm.xml 映射文件，可通过 packagesToScan\r\n属性自动扫描实体类所在包，彻底摆脱手动配置映射路径的繁琐。\r\n&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt;    &lt;!-- 数据源注入 --&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 自动扫描实体类所在包（替代 mappingLocations） --&gt;    &lt;property name=&quot;packagesToScan&quot;&gt;        &lt;list&gt;            &lt;value&gt;com.smart.orm.domain&lt;/value&gt; &lt;!-- 扫描单个包 --&gt;            &lt;value&gt;com.other.module.entity&lt;/value&gt; &lt;!-- 支持多包 --&gt;        &lt;/list&gt;    &lt;/property&gt;        &lt;!-- Hibernate 属性配置 --&gt;    &lt;property name=&quot;hibernateProperties&quot;&gt;        &lt;props&gt;            &lt;!-- 启用 JPA 注解驱动 --&gt;            &lt;prop key=&quot;hibernate.archive.autodetection&quot;&gt;class, hbm&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\r\n\r\nSpring 会扫描 packagesToScan 指定的包，自动识别标注\r\n@Entity、@MappedSuperclass 等注解的类。\r\n无需手动维护映射文件列表，完全契合 “约定优于配置” 原则。\r\n\r\n若厌倦 XML 配置，可改用纯 Java 代码配置 SessionFactory：\r\n@Configuration@EnableTransactionManagementpublic class HibernateConfig &#123;    @Bean    public LocalSessionFactoryBean sessionFactory(DataSource dataSource) &#123;        LocalSessionFactoryBean factory = new LocalSessionFactoryBean();        factory.setDataSource(dataSource);        factory.setPackagesToScan(&quot;com.smart.orm.domain&quot;); // 包扫描        Properties hibernateProps = new Properties();        hibernateProps.put(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQLDialect&quot;);        factory.setHibernateProperties(hibernateProps);        return factory;    &#125;&#125;\r\n对应了我上面java配置类配置 SessionFactory 的部分\r\n使用\r\nHibernateTemplate\r\n基于模板类使用 Hibernate 是最简单的方式，它可以在不牺牲 Hibernate\r\n强大功能的前提下，以一种更简洁的方式使用 Hibernate，极大地降低了\r\nHibernate 的使用难度。按照 Spring 的风格，它提供了使用模板的支持类\r\nHibernateDaoSupport，并通过\r\ngetHibernateTemplate()方法向子类开放模板类实例的调用。\r\n把我的Dao类拿过来作为分析\r\nimport org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;@Repository@Transactionalpublic class EmployeeDao &#123;        @Autowired    private SessionFactory sessionFactory;        protected Session getCurrentSession() &#123;      // 获取 Session        return sessionFactory.getCurrentSession();    &#125;        public Employee findById(Long id) &#123;        return getCurrentSession().get(Employee.class, id);   // 获取实体对象    &#125;        public void save(Employee employee) &#123;        getCurrentSession().saveOrUpdate(employee);    //①保存实体对象    &#125;        public void update(Employee employee) &#123;         getCurrentSession().update(employee);//②更改实体对象    &#125;        public void delete(Employee employee) &#123;        getCurrentSession().delete(employee);    &#125;        @SuppressWarnings(&quot;unchecked&quot;)    public List&lt;Employee&gt; findAll() &#123;        return getCurrentSession().createQuery(&quot;from Employee&quot;).list();    &#125;        public List&lt;Employee&gt; findByLastName(String lastName) &#123;        // 使用 hql 查询        return getCurrentSession()                .createQuery(&quot;from Employee where lastName = :lastName&quot;, Employee.class)                .setParameter(&quot;lastName&quot;, lastName)                .list();    &#125;&#125;\r\nHibernateTemplate 代理了 HibernateSession\r\n的大多数持久化操作，并以一种更简洁的方式提供调用。 HibernateTemplate\r\n所提供的大部分方法对于 Hibernate\r\n开发者来说都是熟悉亲切的，模板类的方法大都可以在 Session\r\n接口中找到镜像。\r\n基于\r\nHibernateTemplate 的 DAO 重构\r\n传统方式通过 SessionFactory.getCurrentSession() 获取\r\nSession，而使用 HibernateTemplate 时，需继承\r\nHibernateDaoSupport 类，该类提供模板实例\r\nhibernateTemplate，并自动管理 Session\r\n的生命周期（包括事务和异常处理）。\r\nimport org.springframework.orm.hibernate5.support.HibernateDaoSupport;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class EmployeeDao extends HibernateDaoSupport &#123; // 继承 HibernateDaoSupport        // 无需手动注入 SessionFactory，由父类通过 setSessionFactory 方法自动注入        public Employee findById(Long id) &#123;        return getHibernateTemplate().get(Employee.class, id); // 直接使用模板方法    &#125;        public void save(Employee employee) &#123;        getHibernateTemplate().saveOrUpdate(employee); // 模板方法替代原生 Session    &#125;        public void update(Employee employee) &#123;        getHibernateTemplate().update(employee); // 等效于原生 Session.update()    &#125;        public void delete(Employee employee) &#123;        getHibernateTemplate().delete(employee); // 模板方法替代原生 Session    &#125;        public List&lt;Employee&gt; findAll() &#123;        return getHibernateTemplate().find(&quot;from Employee&quot;); // 简化 HQL 查询    &#125;        public List&lt;Employee&gt; findByLastName(String lastName) &#123;        // 使用命名参数的简化写法        return getHibernateTemplate().findByNamedParam(            &quot;from Employee where lastName = :lastName&quot;,             &quot;lastName&quot;,             lastName        );    &#125;&#125;\r\n\r\n继承 HibernateDaoSupport：\r\n\r\n父类提供 hibernateTemplate 模板实例，通过\r\ngetHibernateTemplate() 访问。\r\n自动处理 Session 的打开、关闭和异常转换（如将 Hibernate\r\n异常转为 Spring DataAccessException）。\r\n\r\n简化的 API 调用：\r\n\r\ngetHibernateTemplate().get(...) 替代\r\nsessionFactory.getCurrentSession().get(...)。\r\nfindByNamedParam(...)\r\n方法直接处理命名参数，无需手动创建 Query 对象。\r\n\r\n无需手动管理事务：\r\n\r\n事务由 Spring 的 @Transactional 注解统一管理（需在\r\nService 层或 DAO 层方法上声明）。\r\n\r\n\r\n常用的API方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方法\r\n说明\r\n\r\n\r\n\r\n\r\nget(Class entityClass, Serializable id)\r\n根据 ID 获取实体（等效 Session.get()）。\r\n\r\n\r\nload(Class entityClass, Serializable id)\r\n根据 ID 加载实体（支持延迟加载，等效\r\nSession.load()）。\r\n\r\n\r\nsave(Object entity)\r\n保存新实体（等效 Session.save()）。\r\n\r\n\r\nupdate(Object entity)\r\n更新现有实体（等效 Session.update()）。\r\n\r\n\r\nsaveOrUpdate(Object entity)\r\n自动判断保存或更新（等效\r\nSession.saveOrUpdate()）。\r\n\r\n\r\ndelete(Object entity)\r\n删除实体（等效 Session.delete()）。\r\n\r\n\r\nfind(String hql)\r\n执行 HQL 查询，返回结果列表（等效\r\nSession.createQuery(...).list()）。\r\n\r\n\r\nfindByNamedParam(String hql, String paramName, Object value)\r\n使用命名参数的 HQL 查询，防止 SQL 注入。\r\n\r\n\r\nexecute(HibernateCallback action)\r\n执行自定义回调逻辑，支持原生 Session 操作。\r\n\r\n\r\n\r\n使用回调接口（HibernateCallback）\r\n一般情况下，使用模板类的简单代理方法就可以满足要求了，如果希望使用更多\r\nHibernate 底层的功能，则可以使用回调接口。Spring\r\n定义了一个回调接口org.springframework.orm.hibernate5.HibernateCallback，该接口拥有唯一的方法，如下：\r\nT dolnHibernate(org.hibernate.Session session) throws HibernateException,SQLException\r\n该接口配合 HibernateTemplate 进行工作，它无须关心 HibernateSession\r\n的打开/关闭等操作，仅需定义数据访问逻辑即可。可以通过该接口返回结果，结果可以是一个实体对象或一个实体对象的\r\nList。回调接口中抛出的异常将传播到模板类中并被转换成 Spring DAO\r\n异常体系的对应类。\r\nHibernateTemplate 定义了两个使用 HibernateCallback\r\n回调接口的方法。\r\n\r\n&lt;T&gt; T execute(HibernateCallback\r\naction)：一般使用该方法执行数据更新、新增等操作。\r\nList executeFind(HibernateCallback&lt;?&gt;\r\naction)：一般使用该方法执行数据查询操作，返回的结果是一个List。\r\n\r\npublic long getEmployeeNum() &#123;    Long EmployeeNum = getHibernateTemplate().execute(            new HibernateCallback&lt;Long&gt;() &#123;                public Long doInHibernate(Session session) throws HibernateException&#123;                    Object obj = session.createQuery(&quot;select count(e.EmployeeId) from Employee e&quot;)                            .list()                            .iterator()                            .next();                    return (Long) obj;                &#125;            &#125;);    return EmployeeNum;&#125;\r\n当需要执行模板类未封装的原生操作（如分页查询、存储过程调用）时，可通过\r\nexecute 方法传入 HibernateCallback\r\n回调接口，在其中使用原生 Session API。\r\npublic List&lt;Employee&gt; findByPage(int pageNum, int pageSize) &#123;    int firstResult = (pageNum - 1) * pageSize;    return getHibernateTemplate().execute(session -&gt; &#123;        Query&lt;Employee&gt; query = session.createQuery(&quot;from Employee&quot;, Employee.class);        query.setFirstResult(firstResult);        query.setMaxResults(pageSize);        return query.getResultList();    &#125;);&#125;\r\n关键点：\r\n\r\n回调接口中的 session 是当前事务绑定的\r\nSession，无需手动关闭。\r\n可直接使用原生 Query 对象，实现复杂查询逻辑（如\r\nsetParameter()、setLockMode() 等）。\r\n\r\n在 Spring 中配置 DAO\r\n在编写好基于 HibernateTemplate的DAO 类后，接下来要做的就是在 Spring\r\n中进行具体配置，使该 DAO 生效\r\n为 HibernateDaoSupport 注入\r\nSessionFactory HibernateDaoSupport\r\n父类需要 SessionFactory 来创建\r\nHibernateTemplate，可通过 XML 中\r\n`的sessionFactory` 属性注入。\r\n\t&lt;!-- 启用注解驱动和组件扫描 --&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.yourpackage&quot;/&gt; &lt;!-- 扫描 DAO、Service 等组件 --&gt;    &lt;!-- 配置 Hibernate SessionFactory --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt; &lt;!-- 扫描实体类包 --&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;!-- 开发环境自动更新表结构 --&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置 DAO：为 HibernateDaoSupport 注入 sessionFactory --&gt;    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.yourpackage.dao.EmployeeDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;!-- 关键配置 --&gt;    &lt;/bean&gt;&lt;/beans&gt;\r\n\r\n&lt;bean id=\"employeeDao\"&gt;中的\r\nsessionFactory 属性： 必须为\r\nHibernateDaoSupport 子类注入\r\nSessionFactory，否则 hibernateTemplate\r\n无法初始化。\r\n组件扫描： context:component-scan\r\n会自动扫描标注 @Repository 的\r\nEmployeeDao，无需手动注册 Bean（若 XML 中显式声明\r\nBean，则以 XML 配置为准）。\r\n这样 Dao 类的 @Repository 及 @Autowired 注解就可以起作用，将\r\nForumHibernateDao 装配为 Spring 容器中的 Bean。\r\n\r\n注解配置的详解\r\n和 Spring 类似，Hibernate 不但可以使用 XML 提供 ORM\r\n的配置信息，也可以直接在领域对象类中通过注解定义 ORM 映射信息。Hibernate\r\n不但自已定义了一套注解，还支持 JPA 注解。这种方式比传统的 XML\r\n映射文件更加直观、简洁，并且将映射信息直接与实体类关联在一起。\r\nimport javax.persistence.*;import java.util.Date;@Entity@Table(name = &quot;employees&quot;)public class Employee &#123;        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;first_name&quot;, nullable = false, length = 50)    private String firstName;        @Column(name = &quot;last_name&quot;, nullable = false, length = 50)    private String lastName;        @Column(nullable = false, unique = true)    private String email;        @Column(name = &quot;hire_date&quot;)    @Temporal(TemporalType.DATE)  // @Temporal：定义日期类型的精度    private Date hireDate;        @ManyToOne(fetch = FetchType.LAZY)   // 定义多对一关联,fetch = FetchType.LAZY：启用延迟加载    @JoinColumn(name = &quot;department_id&quot;)  // @JoinColumn：指定外键列名    private Department department;        // 构造函数、getter和setter    // ...&#125;\r\nHibemate 通过 AnnotationConfiguration 的\r\naddAnnotatedClass()或 addPackage()方法加载使用\r\nJPA 注解的实体类，获取映射的元数据信息，并在此基础上创建\r\nSessionFactory 实例。\r\n需要特别注意的是，使用 addPackage 并不是加载类包下所有标注了 ORM\r\n注解的实体类，而是加载类包下 package-info.java 文件中定义的\r\nAnnotation，而该类包下的所有持久化类仍然需要通过 addAnnotatedClass()\r\n方法加载。\r\nSpring 专门提供了一个配套的\r\nAnnotationSessionFactoryBean，用于创建基于 JPA 注解的\r\nSessionFactory。\r\n&lt;bean id=&quot;sessionFactory&quot;       class=&quot;org.springframework.orm.hibernate5.annotation.AnnotationSessionFactoryBean&quot;  p:dataSource—ref=&quot;dataSource&quot;&gt;    &lt;property name=&quot;annotatedClasses&quot;&gt;②        &lt;list&gt;            &lt;value&gt;com.smart.orm.domain.Forum&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--或--&gt;    &lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/prop&gt;            &lt;!-- 其他Hibernate配置 --&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\r\nAnnotationSessionFactoryBean 扩展了 LocalSessionFactoryBean\r\n类，增强的功能是：可以根据实体类的注解获取 ORM\r\n的配置信息。也可以混合使用 XML 配置和注解配置对象关系映射，Hibernate\r\n内部自动将这些元数据信息进行整合，并不会产生冲突。\r\nannotatedCIasses 属性指定使用 JPA\r\n注解的实体类名，如②处所示。如果实体类比较多，不要想当然地以为通过annotatedPackages\r\n属性指定实体类所在包名就可以了，annotatedPackages\r\n在内部通过调用 Hibernate 的 AnnotationConfiguration 的\r\naddPackage() 方法加载包中package-info.java\r\n文件定义的 Annotation，而非包中标注注解的实体类。\r\nSpring 为了通过扫描方式加载带注解的实体类，提供了一个易用的\r\npackagesToScan 属性，可以指定一系列包名，Spring\r\n将扫描并加载这些包路径（包括子包）的所有带注解实体类。\r\npackagesToScan 属性可接收多个类包路径，用逗号分隔即可，例如：\r\n&lt;property name=&quot;packagesToScan&quot; value=&quot;com.yourpackage.model&quot;/&gt;\r\n事务处理\r\nSpring 的通用事务管理模型对 Hibernate\r\n是完全适用的，包括编程式事务、基于 TransactionProxyFactoryBean、基于\r\naop/tx 及基于 @Transaction\r\n注解的事务管理。在这里，仅给出基于 @Transaction 注解的事务管理。\r\n@Service@Transactionalpublic class DepartmentService &#123;        @Autowired    private DepartmentDao departmentDao;        @Autowired    private EmployeeDao employeeDao;        // 类级别的事务配置适用于所有方法    // 方法级别的事务配置会覆盖类级别的配置        @Transactional(readOnly = true)    public Department getDepartmentWithEmployees(Long deptId) &#123;       ...    &#125;        @Transactional(rollbackFor = Exception.class)    public void transferEmployees(Long fromDeptId, Long toDeptId, List&lt;Long&gt; employeeIds) &#123;      ...    &#125;&#125;\r\n其次，在 Spring 配置文件中配置 Hibernate\r\n事务管理器，并启用注解驱动事务。\r\n &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;        &lt;!--为事务管理器指定sessionFactory--&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;        &lt;!--②默认查找名为transactionManager的事务管理器，因此可以不显示指定--&gt;\t\t&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 启用注解驱动的事务管理 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;\r\nHibernate 的事务管理器需要注入一个 sessionFactory\r\n实例，将其命名为 transactionManager 后，在\r\n&lt;tx:annotation-driven/&gt; 中就无须通过\r\ntransaction-manager 默认显式指定了。不管\r\nDepartmentServiceImpl所用的 DAO 是基于 HibernateTemplate\r\n还是基于 Hibernate 原生的API，DepartmentServiceImpl\r\n中的所有方法都具有事务性。\r\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识","Spring Data JPA","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"Hello World","url":"/posts/16107.html","content":"常用命令\r\nQuick Start\r\nCreate a new post\r\n$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\nWrite Drafts\r\nhexo n draft draft1\r\n在source\\目录下创建_drafts目录，并生成一个draft1.md文件\r\n当你编辑完草稿后，可以把文章推送到_posts目录下\r\n$ hexo publish &lt;file_name&gt;\r\n或\r\nhexo --draft\r\nDeploy In Github\r\n# 清理旧文件hexo clean# 生成新文件hexo g# 部署到 GitHub Pageshexo dhexo server\r\n引用图片\r\n![alt](path [title])\r\npath是必选的，表示图片的路径，可使用绝对或相对路径。\r\nalt是可选的，是图片无法加载时的替代描述文本。\r\ntitle是可选的，是图片的标题\r\n将所有文章的图片放到source/images\r\n文件夹中，然后使用markdown语句引用图片\r\n或\r\n为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：\r\n\r\n在博客根目录打开_config.yml文件做如下修改：\r\nyaml post_asset_folder: true\r\n然后使用hexo n text命令后创建一个使用post布局名为text的文章，你将发现hexo在\\source\\_post文件夹下创建了一个\\text文件夹以及同名的.md文件：\r\n最后就可以打开text.md文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。注意：请不要自作聪明将text.md文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用\r\n\r\nhexo插入图片的原生语法\r\n使用 Hexo 的 asset_img 标签\r\n&#123;% asset_img 文件名.后缀 图片描述 %&#125;\r\n\r\n需要将图片放在 source/images/ 目录下（或\r\n_config.yml 中 post_asset_folder: true\r\n时与文章同名的文件夹中）\r\n文件名需要包含后缀（如 .jpg, .png\r\n等）\r\n\r\n使用 HTML 的 标签\r\n&lt;img src=&quot;图片路径&quot; alt=&quot;图片描述&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;\r\n插入视频\r\n&lt;video width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;source src=video_path&gt;&lt;/video&gt;\r\n\r\nvideo_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。\r\nwidth和height是视频区块的宽度和高度，可自定义。\r\n\r\n引用和代码区块\r\n&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content...&#123;% endblockquote %&#125;\r\n例如：\r\nQuick Start\r\nluzhengli hello-worldluzhengli.github.io/2020/04/10/hello-world\r\n还有一种简单的引用语法：\r\n&gt; 这也是引用&gt;&gt; 引用1&gt;&gt; 饮用2\r\n\r\n这也是引用\r\n引用1\r\n饮用2\r\n\r\n代码用Hexo的太麻烦了\r\n用markdown原来的```得了\r\nMermaid画流程图\r\n语法\r\n\n    内容\n  \r\nbutterfly主题的标签外挂语法\r\n&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;&#123;% note [class] [no-icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125;\r\nbutterfly主题下的tag-hide\r\n如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。\r\ninline 在文本里面添加按钮隐藏内容，只限文字\r\n( content 不能包含英文逗号，可用 &amp;sbquo;)\r\n&#123;% hideInline content,display,bg,color %&#125;\r\n参数 解释 content 文本内容 display 【可选】按钮显示的文字 bg\r\n【可选】按钮的背景颜色 color 【可选】按钮文字的颜色\r\n哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人? &#123;% hideInline ErgouTree %&#125;\r\n哪个英文字母最酷？ 查看答案因为西装裤(C装酷)\r\n门里站着一个人? ClickErgouTree\r\nbutterfly主题下的tabs\r\n&#123;% tabs Unique name, [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\n\r\n\r\nimage-20250415170911049\r\n\r\n\r\n\r\nimage-20250415170911049\r\n\r\n&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\ntest1 1test1 2test1 3This is Tab 1.This is Tab 2.This is Tab 3.\r\n&#123;% tabs test4 %&#125;&lt;!-- tab 第一个Tab --&gt;**tab 名字为第一个 Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有 Tab 名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\r\n第一个Tab炸弹tab 名字为第一个 Tab只有图标 没有 Tab 名字名字+icon\r\n文章写完之后\r\n编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。\r\n生成/删除静态文件\r\n\r\n生成静态文件命令：hexo generate或 hexo g\r\n删除静态文件命令：hexo clean\r\n\r\n正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果\r\npublic 目录存在，那么 hexo g\r\n只会重新生成改动的文件。\r\n如果发生了一些错误，可以先删除静态文件，然后再重新生成。hexo g命令还提供了一个参数-f提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。\r\n启动本地端口\r\n\r\n命令：hexo server或 hexo s\r\n\r\n"},{"title":"docker和WSL2的安装","url":"/posts/61013.html","content":"Docker简介\r\n简而言之，Docker\r\n是一个可供开发者通过容器(container)来构建，运行和共享应用(application)的平台。用容器来部署应用被称为集装箱化(containerization)。\r\n\r\nDocker\r\n就像一个盒子，里面可以装很多物件，如果需要某些物件，可以直接将该盒子拿走，而不需要从该盒子中一件一件的取。\r\nDocker中文社区、Docker中文文档\r\n\r\nDocker 包括三个基本概念:\r\n\r\n镜像（Image）\r\n\r\nDocker的镜像概念类似于虚拟机里的镜像(比如.ISO文件)，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。\r\n例如：一个镜像可以包含一个完整的 ubuntu\r\n操作系统环境，里面仅安装了MySQL或用户需要的其它应用程序。\r\n这里的镜像就如下方虚拟机创建时候使用的镜像类似。这个镜像便于移动,并且这个镜像我们可以交给任何人使用,其他人使用的时候也很方便,只需要将其实例化即可。\r\n\r\n\r\n容器（Container）\r\n\r\nDocker容器是由Docker镜像创建的运行实例，类似VM虚拟机，支持启动，停止，删除等。\r\n每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。\r\n容器就类似与虚拟机中我们创建好的虚拟机系统,之后我们所有的操作都是在容器中进行的,我们的程序也是运行在容器中。\r\n\r\n\r\n仓库（Repository）\r\n\r\n镜像便于传播,而仓库就是专门用来传播这些镜像的地方,他有点类似与Github,或者你可以把他看成一个存放各种镜像的镜像商店\r\nDocker官方的仓库:\r\n他的服务器处于国外,所以下载速度较慢,不过我们可以通过换源解决。\r\ndaocloud国内仓库:\r\n国内也有一些优秀的商店，他和Docker官方的仓库的区别类似与Github和Gitee的区别。\r\n网易云镜像中心\r\n\r\n\r\n本博客主要解决在Windows环境下,快速上手使用Docker的问题,主要会介绍在Windows系统下Docker\r\nDesktop的安装,Docker\r\n基础命令,比如说下载镜像、实例化镜像、使用容器、关闭容器、删除容器、使用仓库、创建镜像等模块的使用。其他系统应该除了安装外其他操作都可以通用。\r\nDocker安装(Winodws)\r\n开启 Hyper-V\r\n程序与功能中，启用或关闭 Windows 功能\r\n\r\n\r\nimage-20250428162725009\r\n\r\n\r\n\r\necb02f08-dae6-486f-a04d-59bb367bc266\r\n\r\n下载 Docker Desktop\r\nGet Started with\r\nDocker\r\n\r\n\r\nimage-20250428163024009\r\n\r\n打开安装包加载一会后一般会弹出两个选项,在较旧的Windows10或之前的系统会出现如下所示的相关提示。我们把第一个选上,第二个根据需求选择即可。\r\n\r\n\r\n在这里插入图片描述\r\n\r\n而较新的Windows则会出现一个使用wsl2的提示(最少是1903以上,推荐为2004或更高版本),如果使用wsl2则docker的性能会发挥更好。如下图,这里推荐使用WSL2,如果之后安装完成后发生报错可能是WSL2版本比较老,需要更新导致的\r\n\r\n\r\nimage-20250428163938231\r\n\r\n换源，使用阿里云\r\n注册一个阿里云阿里云账号。进入管理控制台界面。\r\n进入控制台\r\n\r\n\r\nimage-20250428164255993\r\n\r\n进入产品与服务\r\n\r\n\r\nimage-20250428164322730\r\n\r\n进入镜像加速器中，获取加速器地址\r\n\r\n\r\nimg\r\n\r\n打开安装好的docker的主界面：在设置界面找到Docker\r\nEngin，将复制好的加速器地址填入即可\r\n\r\n\r\nimage-20250428164537614\r\n\r\n&#123;  &quot;registry-mirrors&quot;:[    &quot;仓库地址&quot;  ],  &quot;builder&quot;: &#123;    &quot;gc&quot;: &#123;      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,      &quot;enabled&quot;: true    &#125;  &#125;,  &quot;experimental&quot;: true&#125;\r\ngithub上有个项目:docker_mirror，可以自动检测在你的网络环境下哪个源是最快的\r\n启动Docker\r\nwindows下启动docker打开桌面的docker图标启动即可。\r\n启动成功后，在Win + R\r\n输入cmd进入windows命令行界面， 输入docker\r\n-v，查看docker版本：\r\n\r\n\r\nimage-20250428164845950\r\n\r\n首先我们输入docker run hello-world是否会出现下图所示的提示,如果出现报错,环境配置可能出现了问题。\r\n我在配置时候出现了Docker无法拉取镜像并提示网络超时的问题，这里以我为例子解决一下\r\n\r\n\r\nimage-20250428165752120\r\n\r\n命令docker images显示说明images镜像中没有helloworld这个文件\r\n\r\n\r\nimage-20250429082113700\r\n\r\n这时我们只需要创建一个daemon.json文件，然后进入这个文件中添加如下内容：\r\n&#123;  &quot;registry-mirrors&quot;: [&quot;https://alzgoonw.mirror.aliyuncs.com&quot;]  &#125;\r\n然后保存退出，并重启docker\r\n另一个错误\r\n\r\n\r\nimage-20250429081800880\r\n\r\n未运行Docker\r\nDesktop，要运行了之后再跑Docker的命令才行！\r\n安装完成Docker后,默认每次开机的时候都会自动启动,但我们也可以手动启动,关闭或者重启Docker\r\n# 启动dockersudo service docker start# 重启dockersudo service docker restart# 停止dockersudo service docker stop\r\n汉化 Docker Desktop\r\n下载对应版本的中文语言包\r\n访问 GitHub，下载适用于 Docker Desktop 的中文语言包，链接地址为：DockerDesktop-CN\r\n选择对应你的版本\r\n\r\n\r\nimage-20250429084714943\r\n\r\n导航至 Docker 的安装目录，路径默认为：\r\nC:\\Program Files\\Docker\\Docker\\frontend\\resources\r\n在该目录下找到 app.asar\r\n文件，建议先备份原文件，然后将复制的中文语言包中的 app.asar\r\n文件粘贴并替换原有文件。\r\n\r\n\r\nimage-20250429084926061\r\n\r\n完成替换后，请关闭 Docker Desktop，然后重新启动该程序。此时，Docker\r\nDesktop 应该以中文界面显示。\r\n\r\n\r\nimage-20250429085059211\r\n\r\nWSL2安装\r\nWSL（Windows Subsystem for\r\nLinux）是微软开发的一项技术，允许用户在Windows系统中直接运行完整的Linux环境，无需虚拟机。通过操作系统级虚拟化，WSL将Linux子系统无缝嵌入Windows，提供原生Linux命令行工具、软件包管理器及应用程序支持。它具有轻量化、文件系统集成、良好的交互性及开发效率提升等优点，消除了Windows与Linux之间的隔阂，尤其适合开发者和需在Windows平台上使用Linux工具的用户。\r\n启用 WSL 功能\r\n\r\n打开开始菜单，在开始菜单中点击应用与程序\r\n在应用与程序选项里面，鼠标滚到最底下，点击程序与功能\r\n点击选项启用或关闭 Windows 功能\r\n在弹出的窗口中勾选 虚拟机平台（Virtual Machine Platform） 和 适用于\r\nLinux 的 Windows 子系统。\r\n\r\n\r\n\r\nimage-20250428171228273\r\n\r\ndos命令自动安装\r\n对于 windows10 版本2004（内部版本19041或更高）及更新版本或者\r\nwindows11，可以直接用 dos命令安装\r\n管理员打开 cmd 或者 powershell，依次\r\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\r\n\r\n\r\nimage-20250428172741625\r\n\r\n启用虚拟机功能\r\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\r\n将 WSL\r\n2 设置为默认版本\r\nwsl --set-default-version 2\r\n更新 wsl 内核\r\nwsl --update\r\n列出发行版本并且选择一个安装\r\nwsl --list --online\r\nwsl --install -d Ubuntu-24.04\r\n\r\n\r\nimage-20250428172805603\r\n\r\n之后使用 wsl.exe -d Ubuntu-24.04 启动\r\n\r\n\r\nimage-20250428173029325\r\n\r\n下次想要使用 wsl 的话，在 cmd 或者 powershell 内输入 wsl\r\n命令即可：\r\n\r\n\r\nimg\r\n\r\nWindows 下的所有文件都被挂载在了 /mnt 下，在Windows\r\n终端中的任意目录下输入 wsl，即可进入 Linux 对应的路径。\r\n错误修复：\r\n无法访问。你可能没有权限使用网络资源。请与这台服务器的管理员联系以查明你是否有访问权限\r\n\r\n\r\nimage-20250429075311855\r\n\r\nWSL报告”请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化”\r\n在 启用或关闭windows\r\n功能中，查看是否勾选虚拟机平台\r\n将注册表HKEY_LOCAL_MACHINE\r\n和HKEY_LOCAL_MACHINE\r\n两个键值中ProviderOrder的值从\r\ncbfs6,P9NP,RDPNP,LanmanWorkstation,webclient改为\r\nP9NP,RDPNP,LanmanWorkstation,webclient \r\n在资源管理器中的\r\n「地址栏」输入：\\\\wsl.localhost 或者\r\n\\\\wsl.localhost\\ 也有概率直接就好了\r\n导出到D盘\r\n注意接下来的操作需要使用 管理员权限的 cmd或pw\r\n首先，查看可用的 WSL 发行版\r\nwsl --list --online\r\n查看你的版本\r\nwsl -l -v \r\n关闭ubuntu\r\nwsl --shutdown Ubuntu-24.04\r\n导出Ubuntu到指定位置\r\nwsl --export Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04\\Ubuntu-24.04.tar\r\n取消注册原有的 Ubuntu,注销\r\nwsl --unregister Ubuntu-24.04\r\n导入虚拟机到指定位置\r\nwsl --import Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04\\Ubuntu-24.04.tar --version 2\r\n现在在目录下，WSL2 发行版的文件存储在一个\r\n虚拟磁盘映像文件（ext4.vhdx） 中，该文件用于存储整个\r\nUbuntu-20.04 文件系统，如下图所示：\r\n\r\n\r\nimage-20250429152524713\r\n\r\n导入完成后，你可以启动 WSL\r\nwsl -d Ubuntu-24.04\r\n添加新用户并设置其管理员权限，需要 root 权限\r\n切换到 root 用户\r\n在 WSL 的 Ubuntu 系统中，使用 su 命令切换到 root\r\n用户：\r\nsu -\r\n执行该命令后，系统会提示你输入 root 用户的密码。如果你之前没有设置过\r\nroot 密码，可以使用以下命令设置：\r\nsudo passwd root\r\n按照提示输入当前用户的密码，然后设置新的 root 密码。\r\n添加新用户\r\nsudo adduser --allow-bad-names yourname\r\n赋予新用户管理员权限\r\n在 Ubuntu 系统中，管理员权限通常通过将用户添加到 sudo\r\n组来实现。使用以下命令将 ErgouTree 用户添加到\r\nsudo 组：\r\nsudo usermod -aG sudo ErgouTree\r\n验证\r\n# 切换到新用户su - ErgouTree# 验证管理员权限sudo ls /root\r\n","categories":["实用","教程","配置教程"],"tags":["Docker","Linux","虚拟机技术","容器技术","配置相关","教程类","实用技术"]},{"title":"butterfly配置文件速读-自查用","url":"/posts/62149.html","content":"转自 Butterfly\r\n文档(三) 主题配置\r\n\r\n_config.butterfly.yml\r\n# --------------------------------------# 导航设置# --------------------------------------nav:  # 导航栏 Logo 图片  logo:  # 是否显示标题  display_title: true  # 是否固定导航栏  fixed: falsemenu:  # 首页: / || fas fa-home  # 列表||fas fa-list:  #   音乐: /music/ || fas fa-music  #   电影: /movies/ || fas fa-video# --------------------------------------# 代码块设置# --------------------------------------code_blocks:  # 代码块主题: darker / pale night / light / ocean / false  theme: light  # 是否使用 Mac 风格  macStyle: false  # 代码块高度限制（单位: px）  height_limit: false  # 是否自动换行  word_wrap: false  # 工具栏  # 是否显示复制按钮  copy: true  # 是否显示语言标签  language: true  # true: 收缩代码块 | false: 展开代码块 | none: 展开代码块并隐藏按钮  shrink: false  # 是否显示全屏显示代码块按钮  fullpage: false# 社交媒体链接# 格式:#   icon: 链接 || 描述 || 颜色social:# --------------------------------------# 图片设置# --------------------------------------# 网站的 favicon 图标favicon: /img/favicon.png# 头像设置avatar:  # 头像图片链接  img: https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png  # 是否启用头像效果  effect: false# 禁用所有横幅图片disable_top_img: false# 如果页面未设置横幅，则显示默认的横幅图片default_top_img:# 主页的横幅图片index_img:# 归档页的横幅图片archive_img:# 注意: 是标签页（单个标签），不是标签页面（所有标签）tag_img:# 标签页的横幅图片，可以为每个标签设置横幅图片# 格式:#  - 标签名: 图片链接tag_per_img:# 注意: 是分类页（单个分类），不是分类页面（所有分类）category_img:# 分类页的横幅图片，可以为每个分类设置横幅图片# 格式:#  - 分类名: 图片链接category_per_img:# 页脚的背景图片footer_img: false# 网站背景# 可以设置为颜色或图片# 图片格式: url(http://xxxxxx.com/xxx.jpg)background:# 封面设置cover:  # 是否禁用封面  index_enable: true  aside_enable: true  archives_enable: true  # 主页封面的位置  # 选择: left/right/both  position: both  # 当未设置封面时，显示默认封面  default_cover:    # - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg# 替换损坏的图片error_img:  # 友链页面的错误图片  flink: /img/friend_404.gif  # 文章页面的错误图片  post_page: /img/404.jpg# 简单的 404 页面error_404:  # 是否启用 404 页面  enable: false  # 404 页面的副标题  subtitle: &#x27;Page Not Found&#x27;  # 404 页面的卡片背景图片  background: https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png# 文章元数据设置post_meta:  # 主页页面  page:    # 日期类型: created / updated / both    date_type: created    # 日期格式: date / relative    date_format: date    # 是否显示分类    categories: true    # 是否显示标签    tags: false    # 是否显示文字标签    label: true  # 文章页面  post:    # 元数据位置: left / center    position: left    # 日期类型: created / updated / both    date_type: both    # 日期格式: date / relative    date_format: date    # 是否显示分类    categories: true    # 是否显示标签    tags: true    # 是否显示文字标签    label: true# --------------------------------------# 首页设置# --------------------------------------# 首页头图的设置# 默认: 头图全屏，站点信息在中间# 站点信息的位置，例如: 300px/300em/300rem/10%index_site_info_top:# 头图的高度，例如: 300px/300em/300remindex_top_img_height:# 首页的副标题设置subtitle:  # 是否启用副标题  enable: false  # 是否启用打字机效果  effect: true  # 自定义 typed.js  # https://github.com/mattboldt/typed.js/#customization  typed_option:  # 来源 - 调用第三方服务 API（仅限中文）  # 它将首先显示来源，然后显示副标题内容  # 选择: false/1/2/3  # false - 禁用此功能  # 1 - hitokoto.cn  # 2 - yijuzhan.com  # 3 - jinrishici.com  source: false  # 如果关闭打字机效果，副标题将仅显示 sub 的第一行内容  sub:# 首页文章佈局# 1: 行佈局# 2: 列布局index_layout: 1# 在首页显示文章简介# 1: 描述# 2: 两者（如果存在描述，将显示描述，否则显示自动摘要）# 3: 自动摘要（默认）# false: 不显示文章简介index_post_content:  method: 3  # 如果设置 method 为 2 或 3，需要配置长度  length: 500# --------------------------------------# 文章设置# --------------------------------------toc:  # 是否在文章中显示目录  post: true  # 是否在页面中显示目录  page: false  # 是否显示目录编号  number: true  # 是否默认展开目录  expand: false  # 是否使用简洁风格（仅适用于文章）  style_simple: false  # 是否显示滚动百分比  scroll_percent: truepost_copyright:  # 是否启用版权声明  enable: true  # 是否进行文章 URL 解码  decode: false  # 作者链接  author_href:  # 许可证类型  license: CC BY-NC-SA 4.0  # 许可证链接  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/# 贊助/打赏reward:  # 是否启用打赏  enable: false  # 打赏案例文本  text:  QR_code:    # - img: /img/wechat.jpg    #   link:    #   text: 微信    # - img: /img/alipay.jpg    #   link:    #   text: 支付宝# 文章编辑# 轻鬆在线浏览和编辑博客源代码post_edit:  # 是否启用在线编辑  enable: false  # url: https://github.com/用户名/仓库名/edit/分支名/子目录名/  # 例如: https://github.com/jerryc127/butterfly.js.org/edit/main/source/  url:# 相关文章related_post:  # 是否显示相关文章  enable: true  # 显示的文章数量  limit: 6  # 选择: created / updated  date_type: created# 选择: 1 / 2 / false# 1: “下一篇文章”将链接到旧文章# 2: “下一篇文章”将链接到新文章# false: 禁用分页post_pagination: 1# 显示文章过期通知noticeOutdate:  # 是否启用过期通知  enable: false  # 样式: simple / flat  style: flat  # 多少天后显示通知  limit_day: 365  # 位置: top / bottom  position: top  message_prev: 已经过了  message_next: 天自上次更新，文章内容可能已过时。# --------------------------------------# 页脚设置# --------------------------------------footer:  owner:    # 是否启用所有者显示    enable: true    # 网站创建年份    since: 2019  # 自定义文本  custom_text:  # 主题和框架的版权声明  copyright: true# --------------------------------------# 侧边栏设置# --------------------------------------aside:  # 是否启用侧边栏  enable: true  # 是否默认隐藏侧边栏  hide: false  # 是否在右下角显示隐藏侧边栏的按钮  button: true  # 移动设备上是否启用侧边栏  mobile: true  # 侧边栏位置：left / right  position: right  display:    # 归档页面是否显示侧边栏    archive: true    # 标签页面是否显示侧边栏    tag: true    # 分类页面是否显示侧边栏    category: true  card_author:    # 是否显示作者信息卡片    enable: true    # 作者描述    description:    button:      # 是否显示按钮      enable: true      # 按钮图标      icon: fab fa-github      # 按钮文本      text: Follow Me      # 按钮链接      link: https://github.com/xxxxxx  card_announcement:    # 是否显示公告卡片    enable: true    # 公告内容    content: This is my Blog  card_recent_post:    # 是否显示最近文章卡片    enable: true    # 显示文章数量，0 表示显示所有    limit: 5    # 排序方式：date / updated    sort: date    sort_order:  card_newest_comments:    # 是否显示最新评论卡片    enable: false    sort_order:    # 显示评论数量    limit: 6    # 单位：分钟，保存数据到 localStorage    storage: 10    # 是否显示头像    avatar: true  card_categories:    # 是否显示分类卡片    enable: true    # 显示分类数量，0 表示显示所有    limit: 8    # 选择：none / true / false    expand: none    sort_order:  card_tags:    # 是否显示标签卡片    enable: true    # 显示标签数量，0 表示显示所有    limit: 40    # 是否启用颜色    color: false    # 标签排序方式：random/name/length    orderby: random    # 排序顺序：1 表示升序，-1 表示降序    order: 1    sort_order:  card_archives:    # 是否显示归档卡片    enable: true    # 归档类型：monthly / yearly    type: monthly    # 日期格式，例如：YYYY年MM月    format: MMMM YYYY    # 排序顺序：1 表示升序，-1 表示降序    order: -1    # 显示归档数量，0 表示显示所有    limit: 8    sort_order:  card_post_series:    # 是否显示系列文章卡片    enable: true    # 标题显示系列名称    series_title: false    # 排序方式：title 或 date    orderBy: &#x27;date&#x27;    # 排序顺序：1 表示升序，-1 表示降序    order: -1  card_webinfo:    # 是否显示网站信息卡片    enable: true    # 是否显示文章数量    post_count: true    # 是否显示最后推送日期    last_push_date: true    sort_order:    # 发佈日期与当前日期的时间差    # 格式：Month/Day/Year Time 或 Year/Month/Day Time    # 如果不启用此功能，请留空    runtime_date:# --------------------------------------# 右下角按钮设置# --------------------------------------# 右下角按钮与底部的距离（默认单位：px）rightside_bottom:# 简繁转换设置translate:  # 是否启用简繁转换  enable: false  # 按钮文本  default: 繁  # 网站语言（1 - 繁体中文 / 2 - 简体中文）  defaultEncoding: 2  # 转换延迟  translateDelay: 0  # 按钮在简体中文时的文本  msgToTraditionalChinese: &#x27;繁&#x27;  # 按钮在繁体中文时的文本  msgToSimplifiedChinese: &#x27;简&#x27;# 閲读模式readmode: true# 暗黑模式设置darkmode:  # 是否启用暗黑模式  enable: true  # 切换暗黑/明亮模式的按钮  button: true  # 是否自动切换暗黑/明亮模式  # autoChangeMode: 1  跟随系统设置，如果系统不支持暗黑模式，则在晚上 6 点到早上 6 点之间切换暗黑模式  # autoChangeMode: 2  在晚上 6 点到早上 6 点之间切换暗黑模式  # autoChangeMode: false  不自动切换  autoChangeMode: false  # 设置明亮模式时间，值在 0 到 24 之间。如果未设置，默认值为 6 和 18  start:  end:# 在返回顶部按钮中显示滚动百分比rightside_scroll_percent: false# 不要修改以下设置，除非你知道它们的工作原理# 选择：readmode,translate,darkmode,hideAside,toc,chat,comment# 不要重复相同的值rightside_item_order:  # 是否启用右侧项目顺序  enable: false  # 隐藏的默认项目：readmode,translate,darkmode,hideAside  hide:  # 显示的默认项目：toc,chat,comment  show:# --------------------------------------# 全局设置# --------------------------------------# 锚点设置anchor:  # 滚动时，URL 将根据标题 ID 更新  auto_update: false  # 点击标题滚动并更新锚点  click_to_scroll: false# 图片标题photofigcaption: false# 复制设置copy:  # 是否启用复制功能  enable: true  # 在复制的内容后添加版权信息  copyright:    enable: false    # 当复制字符数超过 limit_count 时添加版权信息    limit_count: 150# 需要安装 hexo-wordcount 插件wordcount:  # 是否启用字数统计  enable: false  # 在文章元信息中显示字数统计  post_wordcount: true  # 在文章元信息中显示閲读时间  min2read: true  # 在侧边栏网站信息中显示总字数  total_wordcount: true# 不蒜子 PV / UV 统计busuanzi:  # 网站 UV 统计  site_uv: true  # 网站 PV 统计  site_pv: true  # 页面 PV 统计  page_pv: true# --------------------------------------# 数学公式设置# --------------------------------------# 关于 per_page# 如果设置为 true，将在每个页面加载 mathjax/katex 脚本# 如果设置为 false，将根据你的设置加载 mathjax/katex 脚本（在页面的 front-matter 中添加 &#x27;mathjax: true&#x27; 或者 &#x27;katex: true&#x27;）math:  # 选择：mathjax, katex  # 如果不需要数学公式，保持为空  use:  per_page: true  hide_scrollbar: false  mathjax:    # 启用上下文菜单    enableMenu: true    # 选择：all / ams / none，这控制是否对公式编号以及如何编号    tags: none  katex:    # 启用复制 KaTeX 公式    copy_tex: false# --------------------------------------# 搜索设置# --------------------------------------search:  # 选择：algolia_search / local_search / docsearch  # 如果不需要搜索功能，保持为空  use:  placeholder:  # Algolia 搜索  algolia_search:    # 每页搜索结果数量    hitsPerPage: 6  # 本地搜索  local_search:    # 页面加载时预加载搜索数据    preload: false    # 每篇文章显示的顶部 n 个搜索结果，设置为 -1 显示所有结果    top_n_per_article: 1    # 将 HTML 字符串反转义为可读内容    unescape: false    CDN:  # Docsearch  # https://docsearch.algolia.com/  docsearch:    appId:    apiKey:    indexName:    option:# --------------------------------------# 分享系统# --------------------------------------share:  # 选择：sharejs / addtoany  # 如果不需要分享功能，保持为空  use: sharejs  # Share.js  # https://github.com/overtrue/share.js  sharejs:    sites: facebook,twitter,wechat,weibo,qq  # AddToAny  # https://www.addtoany.com/  addtoany:    item: facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link# --------------------------------------# 评论系统# --------------------------------------comments:  # 最多两个评论系统，第一个将作为默认显示  # 如果不需要评论功能，保持为空  # 选择：Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk  # 两个评论系统的格式：Disqus,Waline  use:  # 按钮旁边显示评论系统名称  text: true  # 懒加载：评论系统将在评论元素进入浏览器视口时加载  # 如果设置为 true，评论计数将无效  lazyload: false  # 在文章顶部图片中显示评论计数  count: false  # 在主页显示评论计数  card_post_count: false# Disqus 评论插件配置# 官方文档：https://disqus.com/disqus:  # Disqus 的 shortname  shortname:  # 最新评论小部件的 API 密钥  apikey:# 使用 Disqus API 渲染评论的替代方案# 官方文档：https://github.com/SukkaW/DisqusJSdisqusjs:  # Disqus 的 shortname  shortname:  # API 密钥  apikey:  # 其他可选配置  option:# Livere 评论插件配置# 官方文档：https://www.livere.com/livere:  # Livere 的用户 ID  uid:# Gitalk 评论插件配置# 官方文档：https://github.com/gitalk/gitalkgitalk:  # GitHub 应用的客户端 ID  client_id:  # GitHub 应用的客户端密钥  client_secret:  # 存储评论的仓库名称  repo:  # 仓库拥有者的用户名  owner:  # 管理员用户名列表  admin:  # 其他可选配置  option:# Valine 评论插件配置# 官方文档：https://valine.js.orgvaline:  # LeanCloud 应用的 appId  appId:  # LeanCloud 应用的 appKey  appKey:  # 评论者头像样式  avatar: monsterid  # 该配置适用于国内自定义域名用户，海外版本将自动检测（无需手动填写）  serverURLs:  # 评论框背景图片  bg:  # 使用 Valine 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# Waline 评论插件配置，一个简单的评论系统，基于 Valine 开发，支持后端# 官方文档：https://waline.js.org/waline:  # 服务器 URL  serverURL:  # 评论框背景图片  bg:  # 使用 Waline 的访客计数作为页面的访客量  pageview: false  # 其他可选配置  option:# Utterances 评论插件配置# 官方文档：https://utteranc.es/utterances:  # 存储评论的 GitHub 仓库  repo:  # 问题映射方式，可选值：pathname/url/title/og:title  issue_term: pathname  # 浅色主题，可选值：github-light  light_theme: github-light  # 深色主题，可选值：photon-dark  dark_theme: photon-dark# Facebook 评论插件配置# 官方文档：https://developers.facebook.com/docs/plugins/comments/facebook_comments:  # 应用 ID  app_id:  # 用户 ID，可选  user_id:  # 每页显示评论数  pageSize: 10  # 评论排序方式，可选值：social / time / reverse_time  order_by: social  # 语言设置  lang: zh_TW# Twikoo 评论插件配置# 官方文档：https://github.com/imaegoo/twikootwikoo:  # 环境 ID  envId:  # 区域  region:  # 使用 Twikoo 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# Giscus 评论插件配置# 官方文档：https://giscus.app/giscus:  # 仓库地址  repo:  # 仓库 ID  repo_id:  # 分类 ID  category_id:  # 主题配置，light 为浅色主题，dark 为深色主题  theme:    light: light    dark: dark  # 其他可选配置  option:# Remark42 评论插件配置# 官方文档：https://remark42.com/docs/configuration/frontend/remark42:  # 服务器地址  host:  # 站点 ID  siteId:  # 其他可选配置  option:# Artalk 评论插件配置# 官方文档：https://artalk.js.org/guide/frontend/config.htmlartalk:  # 服务器地址  server:  # 站点名  site:  # 使用 Artalk 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# --------------------------------------# 聊天服务配置# --------------------------------------chat:  # 聊天服务类型，可选值：chatra/tidio/crisp，如果不需要聊天功能则留空  use:  # 推荐使用聊天按钮，会在网站右下角创建一个按钮，并隐藏原始按钮  rightside_button: false  # 原始聊天按钮在向上滚动时显示，向下滚动时隐藏  button_hide_show: false# Chatra 聊天服务配置# 官方网站：https://chatra.io/chatra:  # Chatra 服务 ID  id:# Tidio 聊天服务配置# 官方网站：https://www.tidio.com/tidio:  # Tidio 公钥  public_key:# Crisp 聊天服务配置# 官方网站：https://crisp.chat/en/crisp:  # Crisp 网站 ID  website_id:# --------------------------------------# 分析服务配置# --------------------------------------# 百度统计配置# 官方网站：https://tongji.baidu.com/web/welcome/loginbaidu_analytics:# 谷歌分析配置# 官方网站：https://analytics.google.com/analytics/web/google_analytics:# Cloudflare 分析配置# 官方网站：https://www.cloudflare.com/zh-tw/web-analytics/cloudflare_analytics:# Microsoft Clarity 分析配置# 官方网站：https://clarity.microsoft.com/microsoft_clarity:# --------------------------------------# 广告配置# --------------------------------------# Google Adsense 广告配置google_adsense:  # 是否启用  enable: false  # 是否自动投放广告  auto_ads: true  # 广告脚本 URL  js: https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js  # 客户 ID  client:  # 是否启用页面级广告  enable_page_level_ads: true# 手动插入广告配置，如果不需要广告则留空ad:  # 在首页每三个帖子后插入广告  index:  # 在侧边栏插入广告  aside:  # 在文章分页前插入广告  post:# --------------------------------------# 站点验证配置# --------------------------------------site_verification:  # 示例：  # - name: google-site-verification  #   content: xxxxxx  # - name: baidu-site-verification  #   content: xxxxxxx# --------------------------------------# 美化 / 效果# --------------------------------------# 主题颜色自定义# 注意：颜色值必须用双引号，如 &quot;#000&quot;，否则可能会导致错误！# 主题颜色配置# theme_color:#   是否启用主题颜色#   enable: true#   主颜色#   main: &quot;#49B1F5&quot;#   分页器颜色#   paginator: &quot;#00c4b6&quot;#   按钮悬停颜色#   button_hover: &quot;#FF7242&quot;#   文本选择颜色#   text_selection: &quot;#00c4b6&quot;#   链接颜色#   link_color: &quot;#99a9bf&quot;#   元数据颜色#   meta_color: &quot;#858585&quot;#   水平线颜色#   hr_color: &quot;#A4D8FA&quot;#   代码前景色#   code_foreground: &quot;#F47466&quot;#   代码背景色#   code_background: &quot;rgba(27, 31, 35, .05)&quot;#   目录颜色#   toc_color: &quot;#00c4b6&quot;#   引用块填充颜色#   blockquote_padding_color: &quot;#49b1f5&quot;#   引用块背景颜色#   blockquote_background_color: &quot;#49b1f5&quot;#   滚动条颜色#   scrollbar_color: &quot;#49b1f5&quot;#   浅色模式下的主题颜色#   meta_theme_color_light: &quot;ffffff&quot;#   深色模式下的主题颜色#   meta_theme_color_dark: &quot;#0d0d0d&quot;# 分类和标签页面的用户界面设置# 选择：index - 与主页 UI 相同 / default - 与归档 UI 相同# 留空或设置为 indexcategory_ui:tag_ui:# 拉伸行使每行宽度相等text_align_justify: false# 为页眉和页脚添加遮罩mask:  header: true  footer: true# 加载动画preloader:  # 是否启用加载动画  enable: false  # 资源  # 1. 全屏加载  # 2. 进度条  source: 1  # pace 主题 (参见 https://codebyzach.github.io/pace/)  pace_css_url:# 页面过渡效果enter_transitions: true# 默认显示模式 - light (默认) / darkdisplay_mode: light# 美化文章内容的配置beautify:  # 是否启用美化  enable: false  # 指定美化的范围 (site 或 post)  field: post  # 指定标题前缀图标，如 &#x27;\\f0c1&#x27;  title-prefix-icon:  # 指定标题前缀图标的颜色，如 &#x27;#F47466&#x27;  title-prefix-icon-color:# 全局字体设置# 除非您知道它们的工作原理，否则不要修改以下设置font:  global-font-size:  code-font-size:  font-family:  code-font-family:# 网站标题和副标题的字体设置blog_title_font:  font_link:  font-family:# 分隔符图标的设置hr_icon:  # 是否启用分隔符图标  enable: true  # Font Awesome 图标的 unicode 值，如 &#x27;\\3423&#x27;  icon:  icon-top:# 打字机效果# https://github.com/disjukr/activate-power-modeactivate_power_mode:  # 是否启用打字机效果  enable: false  # 是否启用彩色效果  colorful: true  # 是否启用震动效果  shake: true  # 是否在移动设备上启用  mobile: false# 背景效果# --------------------------------------# canvas_ribbon# 参见: https://github.com/hustcc/ribbon.jscanvas_ribbon:  # 是否启用 canvas_ribbon  enable: false  # ribbon 的大小  size: 150  # ribbon 的不透明度 (0 ~ 1)  alpha: 0.6  zIndex: -1  # 是否点击更改颜色  click_to_change: false  # 是否在移动设备上启用  mobile: false# Fluttering Ribboncanvas_fluttering_ribbon:  # 是否启用 Fluttering Ribbon  enable: false  # 是否在移动设备上启用  mobile: false# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest:  # 是否启用 canvas_nest  enable: false  # 线条颜色，默认: &#x27;0,0,0&#x27;; RGB 值: (R,G,B).(注意: 使用 &#x27;,&#x27; 分隔.)  color: &#x27;0,0,255&#x27;  # 线条的不透明度 (0~1)  opacity: 0.7  # 背景的 z-index 属性  zIndex: -1  # 线条数量  count: 99  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 烟花fireworks:  # 是否启用烟花效果  enable: false  zIndex: 9999  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 心形符号click_heart:  # 是否启用心形符号效果  enable: false  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 文字clickShowText:  # 是否启用文字效果  enable: false  text:    # - I    # - LOVE    # - YOU  fontSize: 15px  # 是否随机显示文字  random: false  # 是否在移动设备上启用  mobile: false# --------------------------------------# 灯箱设置# --------------------------------------# 选择: fancybox / medium_zoom# https://github.com/francoischalifour/medium-zoom# https://fancyapps.com/fancybox/# 如果不需要灯箱效果，请留空lightbox:# --------------------------------------# 标签外挂设置# --------------------------------------# 系列series:  # 是否启用系列  enable: false  # 按标题或日期排序  orderBy: &#x27;title&#x27;  # 排序方式。1, asc 为升序; -1, desc 为降序  order: 1  # 是否显示编号  number: true# ABCJS - ABC 音乐符号插件# https://github.com/paulrosen/abcjsabcjs:  # 是否启用 ABCJS  enable: false  # 是否每页启用  per_page: true# Mermaid# https://github.com/mermaid-js/mermaidmermaid:  # 是否启用 Mermaid  enable: false  # 使用代码块编写 Mermaid 图表  code_write: false  # 内置主题: default / forest / dark / neutral  theme:    light: default    dark: dark# chartjs# 参见 https://www.chartjs.org/docs/latest/chartjs:  enable: false  # 除非你了解它们的工作原理，否则不要修改。  # 默认设置仅在未指定 MD 语法时使用。  # 图表的字体颜色  fontColor:    light: &quot;rgba(0, 0, 0, 0.8)&quot;    dark: &quot;rgba(255, 255, 255, 0.8)&quot;  # 图表的边框颜色  borderColor:    light: &quot;rgba(0, 0, 0, 0.1)&quot;    dark: &quot;rgba(255, 255, 255, 0.2)&quot;  # 雷达图和极区图的刻度标签背景颜色  scale_ticks_backdropColor:    light: &quot;transparent&quot;    dark: &quot;transparent&quot;# Note - Bootstrap 提示框note:  # Note 标签样式值:  #  - simple    bs-callout 旧警告样式。默认。  #  - modern    bs-callout 新 (v2-v3) 警告样式。  #  - flat      扁平提示框样式，带背景，如 Mozilla 或 StackOverflow。  #  - disabled  禁用所有 Note 标签的 CSS 样式。  style: flat  # 是否显示图标  icons: true  # 边框半径  border_radius: 3  # 背景颜色偏移百分比 (modern: -12 | 12; flat: -18 | 6)。  # 也应用于标签变量。此选项可与禁用的 Note 标签一起使用。  light_bg_offset: 0# --------------------------------------# 其他设置# --------------------------------------# https://github.com/MoOx/pjaxpjax:  # 是否启用 pjax  enable: false  # 排除指定页面不使用 pjax，如 &#x27;/music/&#x27;  exclude:    # - /xxxxxx/# 注入 CSS 和脚本 (aplayer/meting)aplayerInject:  # 是否启用注入  enable: false  # 是否每页启用  per_page: true# Snackbar - Toast 通知# https://github.com/polonel/SnackBar# 位置: top-left / top-center / top-right / bottom-left / bottom-center / bottom-rightsnackbar:  # 是否启用 Snackbar  enable: false  # 通知位置  position: bottom-left  # 浅色模式和深色模式下的通知背景颜色  bg_light: &#x27;#49b1f5&#x27;  bg_dark: &#x27;#1f1f1f&#x27;# Instant.page# https://instant.page/instantpage: false# Lazyload# https://github.com/verlok/vanilla-lazyloadlazyload:  # 是否启用 Lazyload  enable: false  # 使用浏览器的原生 lazyload 而不是 vanilla-lazyload  native: false  # 指定使用 Lazyload 的范围 (site 或 post)  field: site  placeholder:  blur: false# PWA# 参见 https://github.com/JLHwung/hexo-offline# ---------------pwa:  # 是否启用 PWA  enable: false  # PWA manifest 文件路径  manifest:  # Apple Touch 图标路径  apple_touch_icon:  # 32x32 像素的 favicon 图标路径  favicon_32_32:  # 16x16 像素的 favicon 图标路径  favicon_16_16:  # mask 图标路径  mask_icon:# Open graph meta tags# 参见 https://hexo.io/docs/helpers#open-graphOpen_Graph_meta:  # 是否启用 Open Graph meta 标签  enable: true  option:    # twitter_card:    # twitter_image:    # twitter_id:    # twitter_site:    # google_plus:    # fb_admins:    # fb_app_id:# 结构化数据# https://developers.google.com/search/docs/guides/intro-structured-datastructured_data: true# 添加供应商前缀以确保兼容性# 是否启用 CSS 前缀css_prefix: true# Inject# 插入代码到 head（在 &#x27;&lt;/head&gt;&#x27; 标签之前）和底部（在 &#x27;&lt;/body&gt;&#x27; 标签之前）inject:  head:    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;  bottom:    # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;# CDN 设置# 除非你知道它们的工作原理，否则不要修改以下设置CDN:  # 内部和第三方脚本的 CDN 提供商  # 两者的选项：local/jsdelivr/unpkg/cdnjs/custom  # 注意： Dev 版本只能使用 &#x27;local&#x27; 作为内部脚本  # 注意：将第三方脚本设置为 &#x27;local&#x27; 时，需要安装 hexo-butterfly-extjs  internal_provider: local  third_party_provider: jsdelivr  # 是否在 URL 中添加版本号，true 或 false  version: false  # 自定义格式  # 例如：https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125;  custom_format:  option:\r\n","categories":["实用","配置相关"],"tags":["其他","实用类","配置文件","Hexo"]},{"title":"markdown中编写数学公式相关语法","url":"/posts/63908.html","content":"使用Markdown语法编写数学公式\r\n在Markdown中使用LaTeX语法编写数学公式起始是一个乍一看很费劲不方便的事情，但是貌似没有别的更好更优秀的通用数学显示了，所以来学习一下这个语法\r\n\r\n插入公式的基本语法\r\n\r\n行内公式\r\n$ 公式内容 $，在这两个美元符号之间输入LaTex语法，即可实现在行内插入公式。\r\n质能公式：E = mc2\r\n二次方程根：$x = \\frac{-b \\pm \\sqrt{b^2 -\r\n4ac}}{2a}$\r\n质能公式：$E = mc^2$  二次方程根：$x = \\frac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125;$\r\n质能公式：$E = mc^2$  二次方程根：$x = \\frac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125;$\r\n公式块：$$ +\r\n回车，会出现一对$$ $$的符号，在这一对符号之间输入LaTex语法，即可实现在行间插入公式。\r\n牛顿第二定律：\r\nF = ma\r\n或\r\n[ F = ma ]\r\n  牛顿第二定律：    $$ F = ma $$    或  \\[ F = ma \\]\r\n\r\n貌似 \\[...\\]\r\n包裹，也可以，但是typora是解析不出来的，就不用了\r\n\r\n\r\n美元符号需在英文输入法下进行输入。中文输入法是\r\n￥\r\n\r\n插入希腊字母\r\n希腊字母的LaTex语法见下图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n希腊字母/希伯来字母\r\n读音（LaTeX 表示）\r\n希腊字母/希伯来字母\r\n读音（LaTeX 表示）\r\n希腊字母/希伯来字母\r\n读音（LaTeX 表示）\r\n\r\n\r\n\r\n\r\nα\r\n\r\nκ\r\n\r\nψ\r\n\r\n\r\n\r\nβ\r\n\r\nλ\r\n\r\nρ\r\n\r\n\r\n\r\nχ\r\n\r\nμ\r\n\r\nσ\r\n\r\n\r\n\r\nδ\r\n\r\nν\r\n\r\nτ\r\n\r\n\r\n\r\nε\r\n\r\nο\r\no\r\nθ\r\n\r\n\r\n\r\nη\r\n\r\nω\r\n\r\nυ\r\n\r\n\r\n\r\nγ\r\n\r\nϕ\r\n\r\nξ\r\n\r\n\r\n\r\nι\r\n\r\nπ\r\n\r\nζ\r\n\r\n\r\n\r\nF\r\n\r\nε\r\n\r\nΔ\r\n\r\n\r\n\r\nϰ\r\n\r\nϖ\r\n\r\nΓ\r\n\r\n\r\n\r\nφ\r\n\r\nϱ\r\n\r\nΛ\r\n\r\n\r\n\r\nΩ\r\n\r\nϕ\r\n\r\nΘ\r\n\r\n\r\n\r\nΥ\r\n\r\nΠ\r\n\r\nΞ\r\n\r\n\r\n\r\nΨ\r\n\r\nΣ\r\n\r\nא\r\n\r\n\r\n\r\nב\r\n\r\nד\r\n\r\nג\r\n\r\n\r\n\r\n\r\nα β γ δ ϵ ζ α\r\n$\\alpha$$\\beta$$\\gamma$$\\delta$$\\epsilon$$\\zeta$  $$ \\alpha $$\r\n唉 4k 吃。。。。\r\n\r\n插入定界符号\r\n总览图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n|\r\n\r\n竖线，可用于表示绝对值、矩阵元素分隔等\r\n\r\n\r\n{\r\n{\r\n左花括号，常用于集合、分段函数定义等\r\n\r\n\r\n⌊\r\n\r\n左向下取整符号，用于表示向下取整函数\r\n\r\n\r\n/\r\n/\r\n除号或表示斜向的分隔\r\n\r\n\r\n⇑\r\n\r\n大向上箭头\r\n\r\n\r\n⌞\r\n\r\n左下直角符号\r\n\r\n\r\n∥\r\n\r\n表示平行，如两直线平行\r\n\r\n\r\n}\r\n}\r\n右花括号\r\n\r\n\r\n⌋\r\n\r\n右向下取整符号\r\n\r\n\r\n∖\r\n\r\n反斜杠，在数学中有时用于集合运算表示差集等\r\n\r\n\r\n↑\r\n\r\n向上箭头\r\n\r\n\r\n⌟\r\n\r\n右下直角符号\r\n\r\n\r\n‖\r\n\r\n双竖线，可用于表示范数等\r\n\r\n\r\n⟨\r\n\r\n左尖括号，常用于表示内积等\r\n\r\n\r\n⌈\r\n\r\n左向上取整符号，用于表示向上取整函数\r\n\r\n\r\n[\r\n[\r\n左方括号，常用于区间表示等\r\n\r\n\r\n⇓\r\n\r\n大向下箭头\r\n\r\n\r\n⌜\r\n\r\n左上直角符号\r\n\r\n\r\n⌝\r\n\r\n右下直角符号\r\n\r\n\r\n]\r\n]\r\n] 右方括号\r\n\r\n\r\n\r\n举例\r\n∖ ∥\r\n$$\\backslash$$$$\\|$$\r\n括号之间可以更改大小以实现嵌套\r\n\r\n\r\nimg\r\n\r\n插入矩阵\r\n矩阵中的各元素通过用$来分隔，\\\\来换行。\r\n$$\r\n\\begin{matrix}\r\n0&amp;1&amp;2\\\\\r\n3&amp;4&amp;5\\\\\r\n6&amp;7&amp;8\\\\\r\n\\end{matrix}\r\n$$\r\n $$ \\begin&#123;matrix&#125; 0&amp;1&amp;2\\\\ 3&amp;4&amp;5\\\\ 6&amp;7&amp;8\\\\ \\end&#123;matrix&#125;$$\r\n$$\r\n\\begin{Vmatrix}\r\n0&amp;1&amp;2\\\\\r\n3&amp;4&amp;5\\\\\r\n6&amp;7&amp;8\\\\\r\n\\end{Vmatrix}\r\n$$\r\n\\begin&#123;Vmatrix&#125;0&amp;1&amp;2\\\\3&amp;4&amp;5\\\\6&amp;7&amp;8\\\\\\end&#123;Vmatrix&#125;\r\n输出分段函数\r\n用\\begin&#123;cases&#125;和\\end&#123;cases&#125;来构造分段函数，中间则用\\\\来分段:\r\n$$\r\nf(x) =\r\n\\begin{cases}\r\n2x,\\,\\,x&gt;0\\\\\r\n3x,\\,\\,x\\le0\\\\\r\n\\end{cases}\r\n$$\r\nf(x) = \\begin&#123;cases&#125;2x,\\,\\,x&gt;0\\\\3x,\\,\\,x\\le0\\\\\\end&#123;cases&#125;\r\n输出方程组\r\n使用\r\n\\begin&#123;cases&#125; ... \\end&#123;cases&#125;，中间则用\\\\来分段:\r\n$$\r\nf(x) = \\begin{cases}\r\n0, &amp; x &lt; 0 \\\\\r\n1, &amp; x \\geq 0\r\n\\end{cases}\r\n$$\r\nf(x) = \\begin&#123;cases&#125;0, &amp; x &lt; 0 \\\\1, &amp; x \\geq 0\\end&#123;cases&#125;\r\n匹配内容\r\n将上述定界符与\\left和right组合使用可以使得定界符匹配其内容的高度。\r\n比如要构建一个如下的矩阵的行列式： $$\r\n\\left|\r\n\\begin{matrix}\r\n    a &amp; b &amp; c &amp; 1 \\\\\r\n    d &amp; e &amp; f &amp; \\epsilon\\\\\r\n    g &amp; h &amp; i &amp; n\r\n   \\end{matrix}\r\n   \\right|\r\n$$\r\n\\left|  \\begin&#123;matrix&#125;   a &amp; b &amp; c &amp; 1 \\\\   d &amp; e &amp; f &amp; \\epsilon\\\\   g &amp; h &amp; i &amp; n  \\end&#123;matrix&#125;  \\right|\r\n\r\n插入运算符号\r\n总览图\r\n\r\n\r\nimg\r\n\r\n×、*、÷、±、∓、≤、≥、≶\r\n$\\times$、$\\ast$、$\\div$、$\\pm$、$\\mp$、$\\leq$、$\\geq$、$\\lessgtr$\r\n这里我挑出一些常用的给大家列出来：\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n+\r\n+\r\n加法运算符号\r\n\r\n\r\n−\r\n-\r\n减法运算符号\r\n\r\n\r\n×\r\n\r\n乘法运算符号\r\n\r\n\r\n÷\r\n\r\n除法运算符号\r\n\r\n\r\n⋅\r\n\r\n点乘符号，用于乘法、函数复合等\r\n\r\n\r\n±\r\n\r\n正负号\r\n\r\n\r\n∓\r\n\r\n与±相反的符号\r\n\r\n\r\n∩\r\n\r\n集合交集运算符号\r\n\r\n\r\n∪\r\n\r\n集合并集运算符号\r\n\r\n\r\n≡\r\n\r\n恒等于、同余（数论）\r\n\r\n\r\n≅\r\n\r\n同构（代数）、全等（几何）\r\n\r\n\r\n≠\r\n\r\n不等于\r\n\r\n\r\n≈\r\n\r\n约等于\r\n\r\n\r\n∼\r\n\r\n相似（几何）、等价（代数）等\r\n\r\n\r\n∈\r\n\r\n属于（集合论）\r\n\r\n\r\n∉\r\n\r\n不属于（集合论）\r\n\r\n\r\n⊆\r\n\r\n子集关系\r\n\r\n\r\n⊇\r\n\r\n超集关系\r\n\r\n\r\n⊊\r\n\r\n真子集关系\r\n\r\n\r\n⊋\r\n\r\n真超集关系\r\n\r\n\r\n≤\r\n\r\n小于等于\r\n\r\n\r\n≥\r\n\r\n大于等于\r\n\r\n\r\n&lt;\r\n\r\n小于\r\n\r\n\r\n&gt;\r\n\r\n大于\r\n\r\n\r\n∥\r\n\r\n平行（几何等）\r\n\r\n\r\n⟂\r\n\r\n垂直、正交（向量等）\r\n\r\n\r\n∨\r\n\r\n逻辑或、格论并运算\r\n\r\n\r\n∧\r\n\r\n逻辑与、格论交运算\r\n\r\n\r\n⊗\r\n\r\n张量积（线性代数等）\r\n\r\n\r\n⊕\r\n\r\n直和（线性代数）、异或（逻辑）\r\n\r\n\r\n∫\r\n\r\n积分符号\r\n\r\n\r\n∑\r\n\r\n求和符号\r\n\r\n\r\n∏\r\n\r\n求积符号\r\n\r\n\r\nlim \r\n\r\n极限符号\r\n\r\n\r\n∞\r\n\r\n无穷大\r\n\r\n\r\n$\\sqrt{}$\r\n\r\n平方根符号\r\n\r\n\r\n$\\sqrt[n]{}$\r\n\r\nn次方根符号\r\n\r\n\r\n≈\r\n\r\n近似等于\r\n\r\n\r\n≐\r\n\r\n近似等于、定义为\r\n\r\n\r\n∝\r\n\r\n成正比\r\n\r\n\r\n|\r\n\r\n竖线，可表示绝对值等\r\n\r\n\r\n⟨\r\n\r\n左尖括号，用于内积等\r\n\r\n\r\n⟩\r\n\r\n右尖括号，用于内积等\r\n\r\n\r\n⌊\r\n\r\n向下取整符号\r\n\r\n\r\n⌋\r\n\r\n向下取整符号\r\n\r\n\r\n⌈\r\n\r\n向上取整符号\r\n\r\n\r\n⌉\r\n\r\n向上取整符号\r\n\r\n\r\n\r\n\r\n插入数学结构\r\n总览图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n$\\frac{abc}{xyz}$\r\n\r\n表示分数，分子为abc，分母为xyz\r\n\r\n\r\n$\\overline{abc}$\r\n\r\n在abc上方加一条横线，常用于表示平均值等\r\n\r\n\r\n$\\overrightarrow{abc}$\r\n\r\n在abc上方加向右箭头，常表示向量\r\n\r\n\r\nf′\r\nf’\r\n表示函数f的一阶导数\r\n\r\n\r\n$\\underline{abc}$\r\n\r\n在abc下方加一条横线\r\n\r\n\r\n$\\overleftarrow{abc}$\r\n\r\n在abc上方加向左箭头\r\n\r\n\r\n$\\sqrt{abc}$\r\n\r\n表示abc的平方根\r\n\r\n\r\n$\\widehat{abc}$\r\n\r\n在abc上方加帽状符号，常用于表示傅里叶变换等中的符号\r\n\r\n\r\n$\\overbrace{abc}$\r\n\r\n在abc上方加花括号\r\n\r\n\r\n$\\sqrt[n]{abc}$\r\n\r\n表示abc的n次方根\r\n\r\n\r\n$\\widetilde{abc}$\r\n\r\n在abc上方加波浪线，常用于表示一些变换后的符号\r\n\r\n\r\n$\\underbrace{abc}$\r\n\r\n在abc下方加花括号\r\n\r\n\r\n\r\n分式结构\r\n\r\n分式：\\frac&#123;分子&#125;&#123;分母&#125;\r\n$\\frac{a}{b}$ → $\\frac{a}{b}$\r\n$\\frac{\\partial f}{\\partial x}$ → $\\frac{\\partial f}{\\partial x}$\r\n\\frac&#123;a&#125;&#123;b&#125; → \\frac&#123;a&#125;&#123;b&#125;  \\frac&#123;\\partial f&#125;&#123;\\partial x&#125; → \\frac&#123;\\partial f&#125;&#123;\\partial x&#125;\r\n\r\n根式结构\r\n\r\n根式：\\sqrt[n]&#123;表达式&#125;\r\n$\\sqrt{2}$ → $\\sqrt{2}$\r\n$\\sqrt[3]{x+y}$ → $\\sqrt[3]{x+y}$\r\n\\sqrt&#123;2&#125; → \\sqrt&#123;2&#125;\\sqrt[3]&#123;x+y&#125; → \\sqrt[3]&#123;x+y&#125;\r\n\r\n上下标结构\r\n\r\n上标：用 ^，如 x^2 →\r\nx2x2\r\n下标：用 _，如 x_1 →\r\nx1x1\r\n复合上下标：用 &#123;&#125;\r\n包裹多字符内容与作用范围，注意其间的连接\r\nxn + 1\r\n→ xn + 1\r\n$\\sum_{i=1}^n i^2$ → $\\sum_{i=1}^n i^2$\r\nϵ&lt;! − −swig￼42 − −&gt;\r\nX23γ(n϶233)\r\n$$\r\n\\lim\\limits_{x\\to\\infty}\\exp(-x) = 0\r\n$$\r\n$x^&#123;n+1&#125;$ → $x^&#123;n+1&#125;$    $\\sum_&#123;i=1&#125;^n i^2$ → $\\sum_&#123;i=1&#125;^n i^2$  $\\epsilon^&#123;&#123;(n+1)&#125;^\\sqrt&#123;2&#125;&#125;$  $X_&#123;23\\gamma&#125;(&#123;n_&#123;\\backepsilon_&#123;233&#125;&#125;&#125;)$  $$  \\lim\\limits_&#123;x\\to\\infty&#125;\\exp(-x) = 0  $$\r\n\r\n其他的也是都一样用，按照图上的查就行了\r\n\r\n插入函数名称\r\n所有符号都可以跟数学结构混合使用，包括数学结构也可以\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n函数名\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\narccos \r\n\r\n反余弦函数，是余弦函数cos 的反函数\r\n\r\n\r\narcsin \r\n\r\n反正弦函数，是正弦函数sin 的反函数\r\n\r\n\r\narctan \r\n\r\n反正切函数，是正切函数tan 的反函数\r\n\r\n\r\narg \r\n\r\n复数的辐角，在复变函数中用于表示复数的角度\r\n\r\n\r\ncos \r\n\r\n余弦函数，三角函数的一种\r\n\r\n\r\ncosh \r\n\r\n双曲余弦函数，双曲函数的一种\r\n\r\n\r\ncot \r\n\r\n余切函数，三角函数中tan 的倒数\r\n\r\n\r\ncoth \r\n\r\n双曲余切函数，双曲函数的一种\r\n\r\n\r\ncsc \r\n\r\n余割函数，是正弦函数sin 的倒数\r\n\r\n\r\ndeg \r\n\r\n表示角度的度数\r\n\r\n\r\ndet \r\n\r\n行列式，用于方阵，是一个数值\r\n\r\n\r\ndim \r\n\r\n维数，用于表示向量空间等的维度\r\n\r\n\r\nexp \r\n\r\n指数函数，通常以e为底，即exp (x) = ex\r\n\r\n\r\ngcd \r\n\r\n最大公约数，用于求两个或多个整数的最大公因数\r\n\r\n\r\nhom \r\n\r\n同态，在抽象代数中用于表示两个代数结构之间的同态映射\r\n\r\n\r\ninf \r\n\r\n下确界，集合的最大下界\r\n\r\n\r\nker \r\n\r\n核，在线性代数中表示线性变换的核空间\r\n\r\n\r\nlg \r\n\r\n常用对数，即以10为底的对数\r\n\r\n\r\nlim \r\n\r\n极限，用于表示函数或数列在某点的极限值\r\n\r\n\r\nliminf \r\n\r\n下极限，是数列极限相关概念\r\n\r\n\r\nlimsup \r\n\r\n上极限，是数列极限相关概念\r\n\r\n\r\nln \r\n\r\n自然对数，即以e为底的对数\r\n\r\n\r\nlog \r\n\r\n对数函数，默认底数不定，可根据上下文确定\r\n\r\n\r\nmax \r\n\r\n最大值，用于求一组数中的最大值\r\n\r\n\r\nmin \r\n\r\n最小值，用于求一组数中的最小值\r\n\r\n\r\nPr \r\n\r\n概率，在概率论中表示事件发生的概率\r\n\r\n\r\nsec \r\n\r\n正割函数，是余弦函数cos 的倒数\r\n\r\n\r\nsin \r\n\r\n正弦函数，三角函数的一种\r\n\r\n\r\nsinh \r\n\r\n双曲正弦函数，双曲函数的一种\r\n\r\n\r\nsup \r\n\r\n上确界，集合的最小上界\r\n\r\n\r\ntan \r\n\r\n正切函数，三角函数的一种\r\n\r\n\r\ntanh \r\n\r\n双曲正切函数，双曲函数的一种\r\n\r\n\r\n\r\n$$\r\n\\tan(at-n\\pi)\\\\\r\n\\sin\\\\\r\n\\cos\\\\\r\n\\log\\\\\r\n$$\r\n\\tan(at-n\\pi)\\\\\\sin\\\\\\cos\\\\\\log\\\\\r\n\r\n插入可变符号\r\n总览图\r\n\r\n\r\nimg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n∑\r\n\r\n求和符号，用于表示对一系列数求和\r\n\r\n\r\n∫\r\n\r\n积分符号，用于表示积分运算\r\n\r\n\r\n⨄\r\n\r\n不相交并集符号，用于表示集合的不相交并运算\r\n\r\n\r\n⨁\r\n\r\n直和符号，常用于线性代数等领域表示向量空间的直和\r\n\r\n\r\n⋁\r\n\r\n逻辑或（在格论等中表示并运算）符号\r\n\r\n\r\n∏\r\n\r\n求积符号，用于表示对一系列数求乘积\r\n\r\n\r\n∮\r\n\r\n闭合曲线积分符号，用于表示在闭合曲线上的积分\r\n\r\n\r\n⋂\r\n\r\n交集符号，用于表示集合的交集运算\r\n\r\n\r\n⨂\r\n\r\n张量积符号，用于表示张量之间的乘积运算\r\n\r\n\r\n⋀\r\n\r\n逻辑与（在格论等中表示交运算）符号\r\n\r\n\r\n∐\r\n\r\n余积符号，在范畴论等中有应用\r\n\r\n\r\n∬\r\n\r\n二重积分符号，用于表示对二元函数的积分\r\n\r\n\r\n⋃\r\n\r\n并集符号，用于表示集合的并集运算\r\n\r\n\r\n⨀\r\n\r\n一种广义的乘法运算符号\r\n\r\n\r\n⨆\r\n\r\n无交并集符号，强调集合元素不相交的并集\r\n\r\n\r\n\r\n补充说明：\r\n\r\n第一列为原图左侧符号，第三列为原图右侧符号\r\n\\text&#123;&#125;包裹的内容为原图自定义标签，非标准LaTeX符号\r\n标准符号已用$$...$$标记确保在Markdown中正确显示大小\r\n原图第三行存在排版混乱，已按原始内容保留\r\n\r\n⋂⋃⨁⨂∑∫∮∬\r\n$$\\bigcap\\bigcup\\bigoplus\\bigotimes\\sum\\int\\oint\\iint$$\r\n积分\r\n积分：\\int_&#123;下限&#125;^&#123;上限&#125; $$\r\n\\int_{0}^{\\infty} e^{-x} dx = 1$ → $\\int_{0}^{\\infty} e^{-x} dx = 1\r\n$$\r\n$\\int_&#123;0&#125;^&#123;\\infty&#125; e^&#123;-x&#125; dx = 1$ → $\\int_&#123;0&#125;^&#123;\\infty&#125; e^&#123;-x&#125; dx = 1$\r\n求和，连乘积\r\n求和/连乘积：\\sum 和 \\prod\r\n$$\r\n\\sum_{i=1}^n i = \\frac{n(n+1)}{2} → \\sum_{i=1}^n i = \\frac{n(n+1)}{2}\r\n$$\r\n$\\sum_&#123;i=1&#125;^n i = \\frac&#123;n(n+1)&#125;&#123;2&#125;$ → $\\sum_&#123;i=1&#125;^n i = \\frac&#123;n(n+1)&#125;&#123;2&#125;$\r\n$$\r\n\\prod_{\\alpha = 2}^n \\alpha\r\n$$\r\n\\prod_&#123;\\alpha = 2&#125;^n \\alpha\r\n\r\n插入箭头符号\r\n总表\r\n\r\n\r\nimg\r\n\r\n这里我挑出一些常用的给大家，方便查找：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n←\r\n\r\n向左箭头，常用于表示映射方向、数列极限趋近方向等\r\n\r\n\r\n⇐\r\n\r\n向左双箭头，在逻辑中可表示逻辑蕴含的反向\r\n\r\n\r\n→\r\n\r\n向右箭头，用于表示函数映射方向、趋向等\r\n\r\n\r\n⇒\r\n\r\n向右双箭头，在逻辑中表示逻辑蕴含\r\n\r\n\r\n↔︎\r\n\r\n双向箭头，可表示双向映射、等价关系等\r\n\r\n\r\n⇔\r\n\r\n双向双箭头，在逻辑中表示等价关系\r\n\r\n\r\n↑\r\n\r\n向上箭头，可用于表示递增、上极限方向等\r\n\r\n\r\n↓\r\n\r\n向下箭头，可用于表示递减、下极限方向等\r\n\r\n\r\n↕\r\n\r\n上下双向箭头，可表示某种上下变化或可逆的过程\r\n\r\n\r\n↦\r\n\r\n映射符号，用于表示函数中元素的对应关系\r\n\r\n\r\n↦\r\n\r\n长映射符号，强调映射关系，常用于更正式的数学定义中\r\n\r\n\r\n↗\r\n\r\n向右上箭头，可表示方向、趋势等\r\n\r\n\r\n↘\r\n\r\n向右下箭头，可表示方向、趋势等\r\n\r\n\r\n↙\r\n\r\n向左下箭头，可表示方向、趋势等\r\n\r\n\r\n↖\r\n\r\n向左上箭头，可表示方向、趋势等\r\n\r\n\r\n\r\n\r\n插入其他符号\r\n\r\n\r\nimg\r\n\r\n♡、∞、∭、∂\r\n$\\heartsuit$、$\\infty$、$\\iiint$、$\\partial$\r\n这个我也挑出一些常用的给大家，方便查找：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n符号\r\nLaTeX代码\r\n解释\r\n\r\n\r\n\r\n\r\n∞\r\n\r\n无穷大，在极限、集合基数等概念中常用\r\n\r\n\r\n∇\r\n\r\nnabla算子，在向量分析中表示梯度、散度、旋度等\r\n\r\n\r\n∂\r\n\r\n偏导数符号，用于多元函数求偏导\r\n\r\n\r\n∀\r\n\r\n全称量词，表示“对于所有的”\r\n\r\n\r\n∃\r\n\r\n存在量词，表示“存在”\r\n\r\n\r\n∅\r\n\r\n空集符号，表示不含任何元素的集合\r\n\r\n\r\n∠\r\n\r\n角的符号，用于表示角度\r\n\r\n\r\n∡\r\n\r\n用于强调角度测量的符号\r\n\r\n\r\n⋯\r\n\r\n省略号，用于表示序列等的延续\r\n\r\n\r\n⋮\r\n\r\n垂直省略号，常用于矩阵、数列等表示\r\n\r\n\r\n⋱\r\n\r\n斜向省略号，常见于矩阵表示中\r\n\r\n\r\nℑ\r\n\r\n表示复数的虚部\r\n\r\n\r\nℜ\r\n\r\n表示复数的实部\r\n\r\n\r\n△\r\n\r\n三角形符号，可用于表示三角形相关概念\r\n\r\n\r\n′\r\n\r\n撇号，常用于表示导数、转置等\r\n\r\n\r\n♮\r\n\r\n自然符号，在音乐理论等领域有应用，在数学中有时用于特定结构\r\n\r\n\r\n\r\n\r\n字体\r\n字体风格\r\n更多详见：Font\r\nsizes, families, and styles\r\n\r\n\r\nimg\r\n\r\n数学字体\r\n\r\n罗马字体（Roman） \\mathrm\r\nsin(x) + cos(x)\r\n\r\n$\\mathrm&#123;sin&#125;(x) + \\mathrm&#123;cos&#125;(x)$\r\n\r\n粗体（Bold） \\mathbf\r\nA ⋅ x = b\r\n$\\mathbf&#123;A&#125; \\cdot \\mathbf&#123;x&#125; = \\mathbf&#123;b&#125;$\r\n斜体 \\mathit\r\n在 LaTeX\r\n中，数学公式默认使用斜体字体。但如果你想明确指定为斜体，可以使用\r\n\\mathit 命令。\r\nabc\r\n$\\mathit&#123;abc&#125;$\r\n花体\r\n使用 \\mathcal\r\n命令可以将公式中的部分内容设置为花体字体，常用于表示集合、范畴等。\r\nℱ\r\n$\\mathcal&#123;F&#125;$\r\n黑板粗体（Blackboard bold）\r\n使用 \\mathbb\r\n命令可以将公式中的部分内容设置为黑板粗体，常用于表示数集\r\nℝ, ℕ, ℤ\r\n$\\mathbb&#123;R&#125;, \\mathbb&#123;N&#125;, \\mathbb&#123;Z&#125;$\r\n哥特体\r\n使用 \\mathfrak\r\n命令可以将公式中的部分内容设置为哥特体字体，常用于表示李代数、理想等。\r\n𝔤, 𝔥\r\n$\\mathfrak&#123;g&#125;, \\mathfrak&#123;h&#125;$\r\n\r\n更多详见：Mathematical\r\nfonts\r\n字体大小\r\n在 LaTeX\r\n中，可以使用不同的命令来调整字体的大小，以下是一些常用的字体大小调整命令\r\n\r\n\r\n\r\n命令\r\n字体大小\r\n\r\n\r\n\r\n\r\n\\tiny\r\n极小号字体\r\n\r\n\r\n\\scriptsize\r\nscriptsize 号字体\r\n\r\n\r\n\\footnotesize\r\nfootnotesize 号字体\r\n\r\n\r\n\\small\r\n小号字体\r\n\r\n\r\n\\normalsize\r\n正常大小字体\r\n\r\n\r\n\\large\r\n大号字体\r\n\r\n\r\n\\Large\r\n更大号字体\r\n\r\n\r\n\\LARGE\r\n非常大号字体\r\n\r\n\r\n\\huge\r\n巨大号字体\r\n\r\n\r\n\\Huge\r\n超级巨大号字体\r\n\r\n\r\n\r\n$\\tiny x + y$$\\scriptsize x + y$$\\footnotesize x + y$$\\small x + y$$\\normalsize x + y$$\\large x + y$$\\Large x + y$$\\LARGE x + y$$\\huge x + y$$\\Huge x + y$\r\n$\\tiny x + y$ $\\scriptsize x + y$ $\\small x + y$ $\\normalsize x + y$ $\\large x + y$ $\\Large x + y$ $\\LARGE x + y$ $\\huge x + y$ $\\Huge x + y$\r\n\r\n对齐\r\n多行公式对齐（align环境）\r\n使用\\begin&#123;align&#125;和\\end&#123;align&#125;，&amp;指定对齐位置：\r\n$$\r\n\\begin{align}\r\nf(x) &amp;= (x+1)^2 \\\\\r\n     &amp;= x^2 + 2x + 1 \\\\\r\n\\int f(x)dx &amp;= \\frac{1}{3}x^3 + x^2 + x + C\r\n\\end{align}\r\n$$\r\n\\begin&#123;align&#125;f(x) &amp;= (x+1)^2 \\\\     &amp;= x^2 + 2x + 1 \\\\\\int f(x)dx &amp;= \\frac&#123;1&#125;&#123;3&#125;x^3 + x^2 + x + C\\end&#123;align&#125;\r\n多公式居中（gather环境）\r\n$$\r\n\\begin{gather}\r\na = b + c \\\\\r\nd = e^f + g \\\\\r\n\\lim_{x\\to0}\\frac{\\sin x}{x} = 1\r\n\\end{gather}\r\n$$\r\n\\begin&#123;gather&#125;a = b + c \\\\d = e^f + g \\\\\\lim_&#123;x\\to0&#125;\\frac&#123;\\sin x&#125;&#123;x&#125; = 1\\end&#123;gather&#125;\r\n分段函数对齐（cases环境）\r\n$$\r\nf(x) = \\begin{cases}\r\nx^2 &amp; \\text{if } x \\geq 0 \\\\\r\n-{\\color{red}x^3} &amp; \\text{if } x &lt; 0\r\n\\end{cases}\r\n$$\r\nf(x) = \\begin&#123;cases&#125;x^2 &amp; \\text&#123;if &#125; x \\geq 0 \\\\-&#123;\\color&#123;red&#125;x^3&#125; &amp; \\text&#123;if &#125; x &lt; 0\\end&#123;cases&#125;\r\n矩阵对齐（array环境）\r\n$$\r\n\\left[\r\n\\begin{array}{cc|c}\r\n1 &amp; 2 &amp; 3 \\\\\r\n\\hline\r\n4 &amp; \\color{blue}5 &amp; 6 \\\\\r\n7 &amp; 8 &amp; 9\r\n\\end{array}\r\n\\right]\r\n$$\r\n$$\\left[\\begin&#123;array&#125;&#123;cc|c&#125; 1 &amp; 2 &amp; 3 \\\\ \\hline4 &amp; \\color&#123;blue&#125;5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end&#123;array&#125;\\right]$$\r\n拆分、对齐方程\r\n用 &amp; 指定对齐位置，\\\\ 换行： $$\r\n\\begin{align}\r\nf(x) &amp;= (x+1)^2 + 3 \\label{eq1} \\\\\r\n     &amp;= x^2 + 2x + 4 \\label{eq2} \\\\\r\n\\int f(x)dx &amp;= \\frac{1}{3}x^3 + x^2 + 4x + C \\label{eq3}\r\n\\end{align}\r\n$$\r\n$$\\begin&#123;align&#125;f(x) &amp;= (x+1)^2 + 3 \\label&#123;eq1&#125; \\\\     &amp;= x^2 + 2x + 4 \\label&#123;eq2&#125; \\\\\\int f(x)dx &amp;= \\frac&#123;1&#125;&#123;3&#125;x^3 + x^2 + 4x + C \\label&#123;eq3&#125;\\end&#123;align&#125;$$\r\n多列对齐 $$\r\n\\begin{align}\r\na &amp;= b &amp; x &amp;= y \\\\\r\nc &amp;= d &amp; z &amp;= w\r\n\\end{align}\r\n$$\r\n$$\\begin&#123;align&#125;a &amp;= b &amp; x &amp;= y \\\\c &amp;= d &amp; z &amp;= w\\end&#123;align&#125;$$\r\n居中显示方程（不以等号对齐）\r\ngather 环境 $$\r\n\\begin{gather}\r\na = b + c \\\\\r\nd = e^f + g \\notag \\\\  \r\n\\lim_{x\\to0}\\frac{\\sin x}{x} = 1\r\n\\end{gather}\r\n$$\r\n\\begin&#123;gather&#125;a = b + c \\\\d = e^f + g \\notag \\\\  % 取消单行编号\\lim_&#123;x\\to0&#125;\\frac&#123;\\sin x&#125;&#123;x&#125; = 1\\end&#123;gather&#125;\r\n单行居中\r\n$$ \\boxed{E = mc^2} $$\r\n$$ \\boxed&#123;E = mc^2&#125; $$\r\n综合对齐\r\n$$\r\n\\begin{align}\r\n\\color{red}\\nabla \\cdot \\mathbf{E} &amp;= \\frac{\\rho}{\\epsilon_0} \\\\\r\n\\color{blue}\\nabla \\times \\mathbf{E} &amp;= -\\frac{\\partial\r\n\\mathbf{B}}{\\partial t} \\\\\r\n\\color{green}\\int_{\\partial \\Omega} \\omega &amp;= \\int_\\Omega d\\omega\r\n\\quad \\text{(Stokes定理)}\r\n\\end{align}\r\n$$\r\n$$\\begin&#123;align&#125;\\color&#123;red&#125;\\nabla \\cdot \\mathbf&#123;E&#125; &amp;= \\frac&#123;\\rho&#125;&#123;\\epsilon_0&#125; \\\\\\color&#123;blue&#125;\\nabla \\times \\mathbf&#123;E&#125; &amp;= -\\frac&#123;\\partial \\mathbf&#123;B&#125;&#125;&#123;\\partial t&#125; \\\\\\color&#123;green&#125;\\int_&#123;\\partial \\Omega&#125; \\omega &amp;= \\int_\\Omega d\\omega \\quad \\text&#123;(Stokes定理)&#125;\\end&#123;align&#125;$$\r\n\r\n间距控制\r\n\r\n\r\nimg\r\n\r\n1. 水平间距\r\n\r\n\r\n\r\n命令\r\n间距大小\r\n示例\r\n\r\n\r\n\r\n\r\n\\,\r\n小空格 (3/18em)\r\n$x\\,y$ → x yxy\r\n\r\n\r\n\\:\r\n中空格 (4/18em)\r\n$x\\:y$ → x yxy\r\n\r\n\r\n\\;\r\n大空格 (5/18em)\r\n$x\\;y$ → x  yxy\r\n\r\n\r\n\\quad\r\n1em\r\n$x\\quad y$ → xyxy\r\n\r\n\r\n\\qquad\r\n2em\r\n$x\\qquad y$ → xyxy\r\n\r\n\r\n\\!\r\n负间距 (-3/18em)\r\n$x\\!y$ → x ⁣yxy\r\n\r\n\r\n\r\n2. 垂直间距\r\n在换行时添加间距（仅在某些环境中有效）： $$\r\n\\begin{align}\r\nf(x) &amp;= x^2 \\\\[5pt]     \r\nf'(x) &amp;= 2x \\\\[10pt]     \r\nf''(x) &amp;= 2\r\n\\end{align}\r\n$$\r\n\\begin&#123;align&#125;f(x) &amp;= x^2 \\\\[5pt]      % 增加5pt间距f&#x27;(x) &amp;= 2x \\\\[10pt]     % 增加10pt间距f&#x27;&#x27;(x) &amp;= 2\\end&#123;align&#125;\r\n3. 矩阵间距调整\r\n$$\r\n\\begin{pmatrix}\r\n1 &amp; \\frac{1}{2} \\\\[6pt]  \r\n3 &amp; \\frac{1}{4}\r\n\\end{pmatrix}\r\n$$\r\n\\begin&#123;pmatrix&#125;1 &amp; \\frac&#123;1&#125;&#123;2&#125; \\\\[6pt]  3 &amp; \\frac&#123;1&#125;&#123;4&#125;\\end&#123;pmatrix&#125;\r\n\r\n颜色\r\n基础颜色语法\r\n在LaTeX数学公式中使用\\color&#123;颜色名&#125;命令设置颜色： x + y = z\r\n$$ \\color&#123;red&#125; x + \\color&#123;blue&#125; y = \\color&#123;green&#125; z $$\r\n常用颜色名称\r\n\r\n\r\n\r\n颜色名\r\n示例\r\n\r\n\r\n\r\n\r\nred\r\n\\color&#123;red&#125; text\r\n\r\n\r\nblue\r\n\\color&#123;blue&#125; text\r\n\r\n\r\ngreen\r\n\\color&#123;green&#125; text\r\n\r\n\r\nyellow\r\n\\color&#123;yellow&#125; text\r\n\r\n\r\ncyan\r\n\\color&#123;cyan&#125; text\r\n\r\n\r\nmagenta\r\n\\color&#123;magenta&#125; text\r\n\r\n\r\nblack\r\n\\color&#123;black&#125; text\r\n\r\n\r\nwhite\r\n\\color&#123;white&#125; text\r\n\r\n\r\ngray\r\n\\color&#123;gray&#125; text\r\n\r\n\r\ndarkred\r\n\\color&#123;darkred&#125; text\r\n\r\n\r\n\r\nRGB自定义颜色\r\n使用\\color[rgb]&#123;R,G,B&#125;格式（值范围0-1）： $$\r\n\\color[rgb]{0.5,0.2,0.8} f(x) = \\sqrt{x}\r\n$$\r\n$$\\color[rgb]&#123;0.5,0.2,0.8&#125; f(x) = \\sqrt&#123;x&#125;$$\r\n局部着色\r\n用花括号限定作用范围： x + y&lt;! − −swig￼43 − −&gt;\r\n$$&#123;\\color&#123;red&#125;x&#125; + &#123;\\color&#123;blue&#125;y&#125;^&#123;&#123;\\color&#123;green&#125;2&#125;&#125;$$\r\n\r\n注意事项\r\n\r\n空格处理：LaTeX 默认忽略空格，需用\r\n\\, 或 \\quad 添加空格，如 x\\,y →\r\nx yxy。\r\n转义字符：在公式中直接书写 #,\r\n%, _ 等符号需用 \\ 转义，如\r\n\\# → ##, \\% → %%。\r\n多行对齐：使用 aligned\r\n环境实现公式对齐：\r\n$$\r\n\\begin{aligned}\r\nf(x) &amp;= (x + 1)^2 \\\\\r\n     &amp;= x^2 + 2x + 1\r\n\\end{aligned}\r\n$$\r\n\\begin&#123;aligned&#125;f(x) &amp;= (x + 1)^2 \\\\     &amp;= x^2 + 2x + 1\\end&#123;aligned&#125;\r\n\r\n\r\n之后再有用到的再补充，感觉够多了\r\n","categories":["实用","语言相关"],"tags":["实用知识","语法知识","语言方面","常用知识","数学","LateX","markdown"]},{"title":"markdown常用语法","url":"/posts/43275.html","content":"markdown常用语法\r\n标题\r\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\r\n#后必须要有空格 还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。Heading level 1===============Heading level 2--------------- 在实际渲染中，‘#’\r\n号数量对应标题级别，一个 ‘#’ 是一级标题，两个 ‘#’\r\n是二级标题，以此类推。\r\n#的叠加可以很多，但是当过多之后，会变的比正常字体还要小，可以利用这个特性\r\n ## 段落和换行 #### 换行\r\n句子末尾双空格代表换行。或者多个空格进行换行\r\n 貌似也可以\r\n#### 段落 处理段落就是用空白行将一行或多行文本进行分割\r\n注意：不要用空格（spaces）或制表符（ tabs）缩进段落。\r\n ## 强调 *斜体文本*   前后各添加一个星号或下划线  _斜体文本_**粗体文本**   前后各添加两个星号或下划线  __粗体文本__***加粗斜体文本***~~删除线文本~~ 粗体和斜体可以混合用\r\n ## 代码块 行内代码：用反引号\r\n包裹代码片段，如System.out.println(“Hello World”);\r\n代码块：使用三个反引号\r\n包裹代码块，并可在其后指定语言（可选，用于语法高亮）\r\n​```代码语言内部代码注意```需要闭合   貌似三个波浪号也可以~~~ ~~~\r\n### 链接- **行内式链接**：`[链接文本](链接地址 &quot;可选标题&quot;)`，例如：[百度](https://www.baidu.com &quot;百度首页&quot;)- **参考式链接**： [链接文本][链接标识][链接标识]: 链接地址 &quot;可选标题&quot;  ## 引用 &gt; 这是一段引用文本&gt; 引用可以有多行&gt; 若有多段引用，可在每段前加 &gt; 符号。&gt; 嵌套块引用\r\n块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。\r\n块引用可以包含其他 Markdown 格式的元素。但并非所有元素都可以使用\r\n我已经验证了强调和段落换行表格可以用\r\n​```markdown &gt; 这是一段引用文本 &gt; 引用可以嵌套 &gt; &gt; 我继续引用\r\n&gt; &gt; &gt; &gt; &gt; 我还引用 &gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用  &gt; &gt; &gt;&gt; &gt; &gt; ***## 分割 — *** ___ 以上三种写法都可生成一条分隔线。  ***## 列表### 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。  数字不必按数学顺序排列，但是列表应当以数字 1 起始。  ​```markdown1. 列表项12. 列表项2   1. 子列表项1   2. 子列表项23. 列表项3\r\n### 无序列表 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*)\r\n或加号 (+) 。 缩进一个或多个列表项可创建嵌套列表。 - 列表项1  - 子列表项1  - 子列表项2+ 列表项2* 列表项3 ###\r\n列表中来回嵌套的问题\r\n在如果需要列表中嵌套其他元素，基本所有都可以，甚至图片，拿代码块举例子\r\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符\r\n1.  列表行12.  下面是代码        &amp;&lt;html&gt;          &amp;lt;head&gt;            &amp;lt;title&gt;Test&amp;lt;/title&gt;          &amp;lt;/head&gt;3.  同样的，列表也可以嵌套列表 1. 列表行1 2. 下面是代码\r\n    &lt;html&gt;\r\n      &lt;head&gt;\r\n        &lt;title&gt;Test&amp;lt;/title&gt;\r\n      &lt;/head&gt;\r\n\r\n同样的，列表也可以嵌套列表 *** ## 表格 ### 基本表格语法\r\n表头与内容分隔：使用 | 来分隔表格的列，表头与表格内容之间通过 — 分隔，—\r\n还可用于指定列的对齐方式。\r\n| 表头1 | 表头2 | 表头3 || :---: | :-- | --: || 居中内容 | 左对齐内容 | 右对齐内容 || 第二行数据1 | 第二行数据2 | 第二行数据3 | | 表头1 | 表头2 | 表头3 | | :—: | :– | –: | | 居中内容 |\r\n左对齐内容 | 右对齐内容 | | 第二行数据1 | 第二行数据2 | 第二行数据3 |\r\n### 表格内容换行 如果表格内容需要换行，可以直接在 Markdown 源文件中使用\r\nHTML 的  标签。\r\n支持扩展语法的编辑器中，也可以通过在单元格内容中按回车键进行换行，然后适当缩进以保持格式。\r\n| 列1 | 列2 || ---- | ---- || 长内容 &lt;br&gt; 换行显示 | 其他内容 | | 列1 | 列2 | | —- | —- | | 长内容  换行显示 |\r\n其他内容 | ### 合并单元格 标准 Markdown\r\n语法本身不支持直接合并单元格。\r\n不过，在一些特定的 Markdown 渲染器（如在 Markdown 中嵌入 HTML\r\n时），可以使用 HTML 的\r\n\r\n标签来实现。\r\n ## 图片 行内式图片：\r\n例如：，换成你自己的图片链接\r\n参考式图片： ![替代文本][图片标识][图片标识]: 图片地址 &quot;可选标题&quot;  ## 任务列表\r\n任务列表可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。\r\n在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。\r\n要选择一个复选框，请在方括号[x]之间添加 x 。\r\n\r\n- [x] Write the press release- [ ] Update the website- [ ] Contact the media\r\n\r\nWrite the press\r\nrelease\r\nUpdate the website\r\nContact the media *** ## 转义字符\r\n在字符前面添加反斜杠字符  ，这样markdown会识别不去执行该符号\r\n例如\r\n* Without the backslash, this would be a bullet in an unordered\r\nlist.\r\n\r\nWithout the backslash, this would be a bullet in an unordered list.\r\n不加就会被识别成列表\r\n ## 内嵌html代码 对于 Markdown\r\n涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。\r\n如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML\r\n标签添加到Markdown 文本中即可\r\nhtml里面咋用，在这里就可以咋用\r\n ## 插入表情符号 可以简单地从Emojipedia\r\n等来源复制表情符号并将其粘贴到文档中。\r\n许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。\r\n\r\n目录导航\r\n[[TOC]] \r\n隐藏注释\r\n\r\n数学公式\r\n本质上就是插入latex代码，但是在markdown中插入latex代码需要用两个$符号\r\n行内公式：$E=mc^2$块级公式：$$\\begin&#123;bmatrix&#125;1 &amp; 0 \\\\0 &amp; 1\\end&#123;bmatrix&#125;$$\r\n流程图（需渲染器支持）\r\n```mermaid\r\ngraph TD\r\nA[开始] –&gt; B(处理逻辑)\r\nB –&gt; C{判断}\r\nC –&gt;|是| D[结果1]\r\nC –&gt;|否| E[结果2]\r\n```\r\ngraph TD\n    A[开始] --&gt; B(处理逻辑)\n    B --&gt; C&#123;判断&#125;\n    C --&gt;|是| D[结果1]\n    C --&gt;|否| E[结果2]\r\n","categories":["实用","语言方面"],"tags":["语言方面","常用知识","实用工具"]},{"title":"个人向galgame原声带或相关音乐整理及其资源","url":"/posts/40344.html","content":"也是一直以来打算整理一下自己爱听的galgame ost\r\n或者其他galgame相关的音乐，按照专辑的方式进行整理，同时我有的也会扒下来上传\r\n就借助这个机会，好好的搞一下吧\r\n顺序随缘\r\n持续更新\r\n\r\n\r\n【FLAC+MP3】AIR ORIGINAL\r\nSOUNDTRACK\r\n神尾观铃镇楼\r\n\r\n\r\n\r\nAIR ORIGINAL SOUNDTRACK\r\n\r\n通过网盘分享的文件：AIR ORIGINAL SOUNDTRACK.zip\r\n13XeUCWQxV19snaDqzz48uA?pwd=1174 提取码: 1174 解压 10086\r\n\r\n【WAV】ゲーム「水葬銀貨のイストリア」Sound\r\nTrack／ウグイスカグラ\r\n\r\n\r\n【WAV】ゲーム「水葬銀貨のイストリア」Sound\r\nTrack／ウグイスカグラ\r\n\r\n【WAV】ゲーム「水葬銀貨のイストリア」Sound Track／ウグイスカグラ.zip\r\n百度网盘\r\n提取码: 1174\r\n\r\n【FLAC】さよならアーリーサマー／やなぎなぎ、麻枝准\r\n\r\n\r\nimg\r\n\r\n百度网盘\r\n提取码: 1174 需要改后缀\r\n解压码www.summerpockets.com 因为是鸟白岛演绎厅的资源\r\n\r\n【WAV】ゲーム「Summer\r\nPockets REFLECTION BLUE」EDM Arrange Album「De-Stress Summer」／Key\r\nSounds Label\r\n\r\n\r\n【WAV】ゲーム「Summer Pockets REFLECTION\r\nBLUE」EDM Arrange Album「De-Stress Summer」／Key Sounds\r\nLabel\r\n\r\n百度网盘\r\n1174\r\n解压码www.summerpockets.com 因为是鸟白岛演绎厅的资源\r\n\r\n【WAV】ゲーム「HEAVEN\r\nBURNS RED」Original Sound Track Vol.2／Key Sounds Label\r\n /1zGCb-DbVtiZw7OEhjtrEAw?pwd=1174 提取码: 1174\r\n\r\n【FLAC】オーガスト歴代ボーカル\r\nピアノアレンジ集「SPROUT AUGUST」／AUGUST.zip\r\n\r\n\r\n【WAV】オーガスト歴代ボーカル\r\nピアノアレンジ集「SPROUT AUGUST」／AUGUST\r\n\r\n通过网盘分享的文件：【FLAC】オーガスト歴代ボーカル\r\nピアノアレンジ集「SPROUT AUGUST」／AUGUST.zip\r\n/s/18sbtkuMKA4Y0pCgZnt9Vug?pwd=1174 提取码: 1174\r\n\r\n【WAV】Symphony\r\nSounds Request 3／Symphony Sounds.zip\r\n\r\ns/1egfV1odE2EYjNly2zOHSOw?pwd=1174 提取码: 1174\r\n\r\n【FLAC】アニメ「この世の果てで恋を唄う少女YU-NO」Original\r\nSound Track Vol.1+Vol.2／MAGES\r\n\r\n\r\nimg\r\n\r\n/s/11H4oSdj7eLC8DnjLczy3OA?pwd=1174 提取码: 1174\r\n解压密码：www.summerpockets.com\r\n\r\n【WAV／MP4】ゲーム「Kanon」16bit\r\nArrangements／Key Sounds Label\r\n \\1c6qn8xBuPZKcZa7r48aeig?pwd=1174 提取码: 1174\r\n解压密码：www.summerpockets.com\r\n\r\n【MP3+FLAC】White\r\nEternity of AstralAir ORIGINAL SOUNDTRACK PLUS\r\n\r\n\r\nimage-20250508091102092\r\n\r\n通过网盘分享的文件：White Eternity of AstralAir ORIGINAL SOUNDTRACK\r\nPLUS 解10086.zip 链接:\r\nhttps://pan.baidu.com/s/1n67xwWghZ6AHxl3x5UwXlg?pwd=1174 提取码:\r\n1174\r\n解压10086\r\n\r\n【MP3+FLAC】Key+Lia Best\r\n2001-2010\r\n\r\n\r\n\r\nimage-20250507203048688\r\n\r\n通过网盘分享的文件：【FLAC】Key+Lia Best 2001-2010.zip\r\n1uQsB0IOIx3WiV-alVB30Hg?pwd=1174 提取码: 1174\r\n\r\n【FLAC+MP3】Kanon\r\nAIR Piano Arrange Album Re-feel\r\n\r\n\r\nKanon AIR Piano Arrange Album Re-feel\r\n1esxDlcRiuVKFVnSHSehd7A?pwd=1174 提取码: 1174\r\n\r\n【FLAC+MP3】CLANNAD ORIGINAL\r\nSOUNDTRACK\r\n1e-8hP1MQxodUMCvR3AYw5g?pwd=1174 提取码: 1174\r\n\r\n【WAV】ゲーム「夢と色でできている」USB\r\nMemory with Digital Contents／feng\r\n\r\n\r\n【WAV】ゲーム「夢と色でできている」USB\r\nMemory with Digital Contents／feng\r\n\r\n通过网盘分享的文件：【WAV】ゲーム「夢と色でできている」USB Memory\r\nwith Digital Contents／feng 链接:\r\nhttps://pan.baidu.com/s/1KFY7ByNth5tp9VPDyBglkw?pwd=1174 提取码:\r\n1174\r\n\r\n【WAV】fengコンプリートボーカルアルバム／feng\r\n\r\n\r\nimg\r\n\r\n通过网盘分享的文件：feng Complete Vocal Album.zip 链接:\r\nhttps://pan.baidu.com/s/1NtXdmhhizF9JlCR4qTFi7g?pwd=1174 提取码:\r\n1174\r\n解压10086\r\n\r\n【FLAC+MP3】FAVORITE\r\n15th ANNIVERSARY VOCAL COLLECTION\r\n\r\n\r\nimage-20250508100048280\r\n\r\nMP3: 1lJbEcMMquJ3XgJ7UI003uQ?pwd=1174 提取码: 1174\r\nFLAC:\r\n解压10086\r\n通过网盘分享的文件：FAVORITE 15th ANNIVERSARY VOCAL COLLECTION 链接:\r\nhttps://pan.baidu.com/s/12PkkRzwkNPo71vxaaH5HnA?pwd=1174 提取码:\r\n1174\r\n\r\n【FLAC】鍵音祭\r\n(セットリスト)／Key Sounds Labe\r\n\r\n\r\nimg\r\n\r\n来自鸟白岛放映厅的资源\r\n通过网盘分享的文件：【FLAC】鍵音祭 (セットリスト)／Key Sounds Labe\r\n1DdJwmZ1DvbJ0erWJN1ZMqQ?pwd=1174 提取码: 1174\r\n解压 www.summerpockets.com\r\n\r\n【WAV】ゲーム「フレラバ\r\n～Friend to Lover～」Mini Fandisc &amp; Full Sound Track／SMEE\r\n\r\n\r\nimg\r\n\r\n通过网盘分享的文件：【WAV】ゲーム「フレラバ ～Friend to Lover～」Mini\r\nFandisc &amp; Full Sound Track／SMEE 1SI5G8FG2tSenoIdsm5wDBw?pwd=1174\r\n提取码: 1174\r\n解压 鸟白岛演绎厅-www.summerpockets.com\r\n\r\n【FLAC】向日葵の教会と長い夏休み\r\nサウンドトラック Himawari no Kyoukai to Nagai Natsuyasumi Soundtrack\r\nCD\r\n\r\n\r\nimage-20250508100956196\r\n\r\n通过网盘分享的文件：Himawari no Kyoukai to Nagai Natsuyasumi\r\nSoundtrack CD.zip 1sH6YwII1vADiQQ95ho4Y7Q?pwd=1174 提取码: 1174\r\n解压 10086\r\n\r\n【WAV】Key\r\nORCHESTRA CONCERT 2018／Key Sounds Label\r\n\r\n\r\nimg\r\n\r\n通过网盘分享的文件：【WAV】Key ORCHESTRA CONCERT 2018／Key Sounds\r\nLabel 17JZcyCw6nE2–xxXU2dSOA?pwd=1174 提取码: 1174\r\n解压 鸟白岛演绎厅-www.summerpockets.com\r\n\r\n","categories":["其他","galgame相关"],"tags":["galgame","其他","音乐"]},{"title":"个人总结的Java技术栈路线-持续更新","url":"/posts/14621.html","content":"Java SE部分\r\n\r\n基础语法\r\n\r\n变量与数据类型：基本数据类型（byte、short、int、long、float、double、char、boolean），引用数据类型（类、接口、数组、字符串等），变量的声明、初始化和作用域。\r\n运算符：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符等。\r\n流程控制：顺序结构、选择结构（if - else、switch -\r\ncase）、循环结构（for、while、do - while），以及 break、continue\r\n关键字的使用。\r\n方法：方法的定义、参数传递、返回值，方法的重载和递归调用。\r\n数组：一维数组和多维数组的声明、初始化、遍历和常用操作。\r\n\r\n面向对象编程\r\n\r\n类与对象：类的定义，对象的创建和使用，构造方法，this\r\n关键字。\r\n封装：访问修饰符（public、private、protected、默认），成员变量的封装和访问控制。\r\n继承：继承的概念，extends 关键字，方法重写，super\r\n关键字，继承的层次结构和多态性。\r\n多态：对象的多态性，方法的动态绑定，向上转型和向下转型。\r\n抽象类与接口：抽象类的定义和使用，抽象方法，接口的定义和实现，接口的多实现和默认方法。\r\n\r\n常用类\r\n\r\nString\r\n类：字符串的创建、操作（拼接、截取、替换等），字符串的比较，不可变特性。\r\nStringBuilder 与\r\nStringBuffer：可变字符串，两者的区别和适用场景。\r\n包装类：基本数据类型的包装类（Integer、Double、Boolean\r\n等），自动装箱和拆箱。\r\nMath\r\n类：数学运算相关的方法，如随机数生成、三角函数、指数运算等。\r\nDate 与 Calendar\r\n类：日期和时间的处理，获取当前日期和时间，日期的格式化和解析。\r\nFile\r\n类：文件和目录的操作，文件的创建、删除、读取、写入，目录的创建和遍历。\r\n\r\n内部类和包装类\r\n\r\n内部类\r\n\r\n成员内部类：定义在另一个类的内部，作为外部类的一个成员，可以访问外部类的所有成员。\r\n静态内部类：使用 static\r\n修饰的内部类，只能访问外部类的静态成员。\r\n局部内部类：定义在方法内部，只能在该方法内部使用。\r\n匿名内部类：没有显式的类名，通常用于创建一次性的对象，常用于实现接口或继承抽象类。\r\n\r\n包装类\r\n\r\n基本数据类型对应的包装类：Byte、Short、Integer、Long、Float、Double、Character、Boolean。\r\n自动装箱和拆箱：Java\r\n提供了自动将基本数据类型转换为包装类对象（装箱）和将包装类对象转换为基本数据类型（拆箱）的功能。\r\n\r\n\r\n注解\r\n\r\n内置注解：如 @Override\r\n用于标识方法重写；@Deprecated\r\n用于标记已过时的元素；@SuppressWarnings\r\n用于抑制编译器警告。\r\n元注解：用于定义注解的注解，如\r\n@Retention\r\n用于指定注解的保留策略（SOURCE、CLASS、RUNTIME）；@Target\r\n用于指定注解可以应用的目标元素类型。\r\n自定义注解：可以通过 @interface\r\n关键字定义自己的注解，并使用元注解进行配置。\r\n\r\n动态代理\r\n\r\n概念：在运行时动态创建代理类和代理对象，无需手动编写代理类的代码。\r\nJava 中的动态代理实现\r\n\r\n基于接口的动态代理：使用\r\njava.lang.reflect.Proxy 类和\r\njava.lang.reflect.InvocationHandler 接口实现。\r\n基于类的动态代理：使用第三方库如 CGLIB\r\n实现，它可以为没有实现接口的类创建代理。\r\n\r\n\r\n枚举\r\n\r\n基本概念：枚举是一种特殊的类，用于定义一组固定的常量。\r\n枚举的定义和使用：使用 enum\r\n关键字定义枚举类型，枚举常量默认是 public static final\r\n的。\r\n枚举的方法：枚举类型可以有自己的构造方法、成员变量和方法，还可以实现接口。\r\n\r\n集合框架\r\n\r\nList 接口：有序、可重复的集合，常用实现类有\r\nArrayList、LinkedList，列表的添加、删除、查找等操作。\r\nSet 接口：无序、不可重复的集合，常用实现类有\r\nHashSet、TreeSet，集合的交、并、差等操作。\r\nMap 接口：键值对形式的集合，常用实现类有\r\nHashMap、TreeMap、Hashtable，映射的添加、获取、遍历等操作。\r\nQueue\r\n接口：队列，先进先出（FIFO）的数据结构，常用实现类有\r\nLinkedList、PriorityQueue。\r\n迭代器（Iterator）：用于遍历集合元素，统一的遍历方式，避免对集合内部结构的暴露。\r\n\r\n异常处理\r\n\r\n异常体系：Throwable 类，Error 和 Exception\r\n的区别，受检异常和非受检异常。\r\ntry - catch - finally 语句：捕获和处理异常，finally\r\n块的作用，多个 catch 块的使用。\r\nthrow 与 throws\r\n关键字：手动抛出异常，声明方法可能抛出的异常。\r\n自定义异常：创建自定义异常类，用于特定业务场景下的异常处理。\r\n\r\n多线程\r\n\r\n线程基础：线程的概念，进程与线程的区别，线程的生命周期（新建、就绪、运行、阻塞、死亡）。\r\n创建线程的方式：继承 Thread 类，实现 Runnable\r\n接口，使用 Callable 接口和 Future 获取线程执行结果。\r\n线程同步：synchronized\r\n关键字，同步方法和同步块，解决线程安全问题。\r\n线程通信：wait ()、notify ()、notifyAll ()\r\n方法，生产者 - 消费者模型。\r\n线程池：Executor\r\n框架，线程池的创建和使用，常见的线程池类型（如\r\nFixedThreadPool、CachedThreadPool 等）。\r\n\r\n并发编程\r\n\r\n原子操作：Atomic 类（如\r\nAtomicInteger、AtomicBoolean 等），利用 CAS（Compare and\r\nSwap）实现原子操作。\r\n并发集合：ConcurrentHashMap、CopyOnWriteArrayList\r\n等，支持高并发访问的集合类。\r\nLock\r\n接口：可重入锁（ReentrantLock），读写锁（ReentrantReadWriteLock），用于更灵活的线程同步控制。\r\n并发工具类：CountDownLatch、CyclicBarrier、Semaphore\r\n等，用于协调多个线程的执行。\r\n\r\nJava I/O\r\n\r\n字节流：InputStream 和 OutputStream 及其子类，如\r\nFileInputStream、FileOutputStream，用于读写字节数据。\r\n字符流：Reader 和 Writer 及其子类，如\r\nFileReader、FileWriter，用于读写字符数据，字符编码的转换。\r\n缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter，提高读写效率。\r\n对象流：ObjectInputStream 和\r\nObjectOutputStream，用于对象的序列化和反序列化。\r\nNIO（New\r\nI/O）：通道（Channel）、缓冲区（Buffer）、选择器（Selector），基于非阻塞的\r\nI/O 模型，提高 I/O 性能。\r\n\r\n反射机制\r\n\r\nClass 类：获取类的 Class 对象，通过 Class\r\n对象获取类的构造方法、成员变量、成员方法等信息。\r\n反射的应用：动态创建对象，调用对象的方法，访问和修改对象的成员变量，在框架开发和插件化开发中有广泛应用。\r\n\r\n泛型\r\n\r\n泛型的定义：在类、接口、方法中使用类型参数，提高代码的复用性和类型安全性。\r\n泛型的通配符：？、？extends T、？super T\r\n的含义和使用场景。\r\n泛型擦除：泛型在编译后的类型擦除机制，以及带来的一些限制和注意事项。\r\n\r\n网络编程\r\n\r\nHTTP协议：深入理解请求头/响应头结构、状态码、Cookie/Session机制\r\nNIO进阶：Selector多路复用、ByteBuffer内存池优化、Netty底层原理\r\nWebSocket：实现即时通讯功能，对比HTTP长轮询方案\r\n实战案例：开发简易HTTP服务器（支持GET/POST）、实现文件断点续传\r\n\r\nJUnit和断言\r\n新特性\r\n\r\nJava 8+：Lambda表达式、Stream\r\nAPI、Optional空安全处理\r\nJava\r\n11+：ZGC低延迟垃圾回收器、var局部变量类型推断\r\nJava 17+：密封类（sealed class）、模式匹配（Pattern\r\nMatching）\r\n实战案例：用Stream重构集合处理代码，实现并行数据清洗\r\n\r\n\r\nJava进阶部分\r\n\r\n高并发\r\n\r\n并发工具进阶：\r\n\r\nLongAdder vs AtomicLong性能对比\r\nStampedLock乐观锁实现高吞吐量场景\r\n\r\n并发模式：\r\n\r\nFork/Join框架实现分治算法\r\nDisruptor无锁队列在金融交易系统中的应用\r\n\r\n实战案例：设计百万级QPS的抢购系统（库存防超卖）\r\n\r\n分布式\r\n\r\n一致性协议：Raft选举机制、ZAB协议在ZooKeeper中的应用\r\n分布式存储：Ceph对象存储原理、MinIO私有云部署\r\n实战案例：基于Paxos算法实现分布式锁服务\r\n\r\n微服务\r\n\r\nService Mesh：Istio流量管理、链路加密（mTLS）\r\nServerless：Spring Cloud\r\nFunction实现无服务器架构\r\n实战案例：将单体应用改造为Serverless微服务集群\r\n\r\nJVM\r\n内存分析：\r\n\r\nMAT工具分析堆内存泄漏\r\nJProfiler定位CPU热点方法\r\n\r\nGC调优：\r\n\r\nG1回收器Region划分策略\r\n大对象分配优化（-XX:PretenureSizeThreshold）\r\n\r\n\r\n数据库部分\r\n关系型数据库：MySQL PostgreSQL\r\nNoSQL：MongoDB Redis\r\n缓存：\r\n搜索引擎：\r\n\r\nElasticsearch：\r\n\r\nWeb前端部分\r\n\r\n前端基础 HTML/ CSS/ JavaScript AJAX jQuery\r\n有精力可以学一下 TypeScript 很像js\r\n前端框架\r\n\r\nReact：组件化开发、Hooks、状态管理（Redux/Context\r\nAPI）27。\r\nVue.js：Vue 3组合式API、Pinia/Vuex状态管理37。\r\n\r\n工程化工具\r\n\r\nWebpack模块打包、Babel转译、NPM/Yarn依赖管理8。\r\n\r\n前后端协作：\r\n\r\nRESTful API设计\r\n\r\n使用Swagger/OpenAPI生成文档，Postman调试接口8。\r\n\r\nSSR与静态站点\r\n\r\n学习Next.js（React）或Nuxt.js（Vue）实现服务端渲染57。\r\n\r\n\r\n\r\nJavaEE与Web后端部分\r\nJ2EE基础\r\n\r\nServlet\r\nTomcat（Web服务器）\r\nJSP /\r\nNginx\r\n\r\n常用框架\r\n\r\nSpring部分\r\nMyBatis\r\nNetty\r\n工作流\r\n实用工具类库\r\n\r\n高性能和高可用\r\n\r\nCDN\r\n消息队列\r\n负载均衡\r\n\r\nDevOps与云原生\r\n1. 容器化与编排\r\n\r\nDocker：镜像构建、Docker Compose多容器管理28。\r\nKubernetes：Pod部署、Service暴露、Ingress路由管理710。\r\n\r\n2. CI/CD与监控\r\n\r\nJenkins/GitLab\r\nCI：自动化构建、测试与部署流水线810。\r\n云服务：AWS\r\nEC2/S3、阿里云容器服务，实现弹性伸缩与负载均衡28。\r\n\r\n其他内容\r\n构建工具\r\n\r\nMaven\r\nGradle\r\n\r\n版本控制\r\n\r\nGit\r\nGithub\r\n\r\n测试部分\r\nLinux与服务器部分\r\n远程调用\r\n设计模式\r\n\r\n\r\nJava 后端学习路线概览-1\r\n\r\nSpring部分\r\n第一阶段：Spring核心原理与基础框架\r\n1. Spring Framework\r\nCore\r\n\r\n核心目标：理解IoC/DI、AOP设计思想\r\n重点内容：\r\n\r\nIoC容器：Bean生命周期、@Component/@Bean注解、XML配置与JavaConfig对比\r\n依赖注入：@Autowired原理、构造器注入 vs\r\nSetter注入、解决循环依赖\r\nAOP编程：\r\n\r\nJDK动态代理与CGLIB区别\r\n实现日志记录/事务管理（@Around、@Before等切面注解）\r\n\r\nSpring\r\nJDBC：JdbcTemplate使用，对比原生JDBC的优势\r\n\r\n实践项目：实现一个银行转账系统，手动模拟事务管理（不依赖Spring事务注解）\r\n\r\n2. Spring MVC\r\n\r\n核心目标：从Servlet过渡到MVC框架\r\n关键衔接：对比Servlet开发模式 →\r\nDispatcherServlet工作原理\r\n重点内容：\r\n\r\n请求处理流程：HandlerMapping → Controller → ViewResolver\r\n注解驱动开发：@Controller/@RequestMapping/@RequestBody\r\n参数绑定：@RequestParam/@PathVariable/@ModelAttribute\r\n视图技术：Thymeleaf模板引擎集成（替代JSP）\r\n\r\n实践项目：开发博客系统的文章管理模块（CRUD+分页）\r\n\r\n\r\n第二阶段：现代Spring开发范式\r\n3. Spring Boot\r\n\r\n核心目标：掌握自动化配置与生产级应用构建\r\n重点内容：\r\n\r\nStarter机制：分析spring-boot-starter-web的自动配置过程\r\n外部化配置：多环境配置（application-{profile}.yml）、@ConfigurationProperties\r\n嵌入式容器：Tomcat vs Undertow性能对比\r\nActuator：健康检查、Metrics监控端点配置\r\n测试：@SpringBootTest集成测试、MockMVC模拟HTTP请求\r\n\r\n实践项目：改造第一阶段项目为Spring\r\nBoot版本，增加Swagger API文档\r\n\r\n4. Spring Security\r\n\r\n核心目标：构建安全认证体系\r\n学习路径：\r\n\r\n基础认证：内存认证 → JDBC认证 → 自定义UserDetailsService\r\n表单登录 vs JWT认证：实现无状态认证（搭配JJWT库）\r\n权限控制：方法级安全（@PreAuthorize）、ACL权限模型\r\nOAuth2.0：授权码模式实现（整合GitHub登录）\r\n\r\n实践项目：为博客系统增加RBAC权限管理，支持JWT+OAuth2混合认证\r\n\r\n\r\n第三阶段：企业级整合与深度优化\r\n5. 数据持久化整合\r\n\r\nSpring Data JPA：\r\n\r\nRepository动态代理机制\r\n@Query注解实现复杂查询\r\n审计功能（@CreatedDate）\r\n\r\nMyBatis Plus：\r\n\r\n通用Mapper与条件构造器\r\n分页插件原理分析\r\n\r\n多数据源配置：AbstractRoutingDataSource动态切换\r\n性能优化：\r\n\r\n二级缓存整合（Ehcache/Redis）\r\n批处理优化（JdbcTemplate批量插入）\r\n\r\n\r\n6. 响应式编程\r\n\r\nSpring WebFlux：\r\n\r\nReactor编程模型（Flux/Mono）\r\n对比Servlet阻塞模型的性能优势\r\n整合MongoDB Reactive驱动\r\n\r\n\r\n\r\n第四阶段：微服务架构进阶\r\n7. Spring Cloud\r\n\r\n基础组件：\r\n\r\n服务注册发现：Eureka vs Nacos注册中心对比\r\n配置中心：Spring Cloud Config + Bus动态刷新\r\n服务调用：OpenFeign声明式客户端 + Hystrix熔断\r\n\r\n进阶方案：\r\n\r\n网关：Spring Cloud Gateway动态路由配置\r\n链路追踪：Sleuth + Zipkin全链路监控\r\n分布式事务：Seata AT模式实现\r\n\r\n实践项目：拆解博客系统为微服务架构（用户服务/内容服务/评论服务）\r\n\r\n\r\n\r\n必读文档：\r\n\r\nSpring\r\nFramework官方文档\r\nSpring\r\nBoot Reference Guide\r\n\r\n深度书籍：\r\n\r\n《Spring揭秘》（深入理解设计思想）\r\n《Spring Boot编程思想》（核心原理剖析）\r\n\r\n\r\n按照这个路径学习，建议每完成一个阶段就进行知识图谱绘制（如用XMind整理技术点关联），遇到问题优先查阅官方文档，同时结合Github优质开源项目（如spring-petclinic）进行对比学习。\r\n","categories":["Java学习","技术栈路线与知识总结"],"tags":["其他","Java学习","计算机理论知识","知识总结"]},{"title":"为Hexo博客绑定你的自定义域名","url":"/posts/12190.html","content":"前言\r\n发现之前用来搞 galgame\r\n网盘转存网站的被我废弃掉之后，多出来一个闲置的域名\r\n就打算把我的 Hexo 博客绑定到上面，要不然每次都要\r\nergou10086.github.io来访问自己的博客，域名太长了。\r\n\r\n购买域名\r\n这里笔者使用的是阿里云，可能别的更便宜，我的 .cn 后缀域名现在一年要\r\n42 块，有点贵。。。\r\n另外还有很多人推荐的godaddy也可以。本篇以阿里云为例。\r\n\r\n首先注册阿里云账号，如果有淘宝账号的，可以直接登录。\r\n登录以后，先进行实名认证（购买域名要用到，但是域名申请备案时候还要搞一遍，那个是工信部申请备案的模板，关于如何实名验证，这里就跳过了）。\r\n\r\n"},{"title":"使用ABCjs在hexo博客中显示五线谱的测试","url":"/posts/37962.html","content":"本文展示了如何在Hexo博客中使用ABC记谱法显示五线谱。如果您能看到下方的五线谱示例，则说明您的abcjs插件已成功安装并配置。\r\n简单旋律示例\r\n下面是一个简单的C大调音阶示例：\r\nX: 1T: C大调音阶M: 4/4L: 1/8K: CC D E F | G A B c | c B A G | F E D C |\r\n一首经典的生日快乐 X: 2T: Happy BirthdayM: 3/4L: 1/4K: C|&quot;Happy &quot;G2 G | A G C2 | &quot;birth-&quot;G2 G | A G D2 ||&quot;day &quot;G2 G | G4 | &quot;to &quot;E2 E | D C2 C |\r\n\n\n\n\n\n  .abcjs-container {\n    margin: 20px 0;\n    padding: 15px;\n    background-color: #f8f9fa;\n    border-radius: 5px;\n    overflow-x: auto;\n  }\n\n\n\n\n\n  \n  \nX:1\nT:欢乐颂\nC:贝多芬\nM:4/4\nL:1/4\nK:C\nE E F G | G F E D | C C D E | E D D- | E E F G |\n  \n\n\n\n\n\n  \n  \nX:2\nT:测试曲目\nM:3/4\nK:G\nD E G | A B d | B A G | E D :|\n  \n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  // 渲染所有ABC乐谱\n  document.querySelectorAll('.abc-source').forEach((abcEl, index) => {\n    const targetId = `score${index + 1}`;\n    const target = document.getElementById(targetId);\n    ABCJS.renderAbc(target, abcEl.textContent, {\n      staffwidth: 650,\n      responsive: \"resize\",\n      paddingbottom: 15,\n      paddingtop: 15,\n      add_classes: true\n    });\n  });\n});\n\n\r\n","categories":["技术"],"tags":["音乐","前端"]},{"title":"为Hexo页脚添加网站运行时间","url":"/posts/26887.html","content":"前言\r\n该教程基于 butterfly 的主题进行配置\r\n因为自己也想弄一个这种东西，结果一搜发现全都是 next 主题的\r\n于是打算根据\r\nhttps://blog.hikariyo.net/js/hexo-realtime-duration-footer/index.html\r\n大佬的教程重新编写整理一个教程，因为我根据他的方法并没有成功弄好））\r\n配置文件修改\r\n本文用 Dayjs 来处理日期。当然，完全可以用原生\r\nDate，但是 js\r\n代码的编写在时间处理上会多出很多需要注意的细节\r\n我使用的是 butterfly\r\n主题。如果读者正在使用别的主题，请查阅对应官方文档寻找如何插入自定义标签与自定义页脚信息。\r\n在主题配置文件（即_config.butterfly.yml）中引入：\r\ninject:  bottom:    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/dayjs@1.11.7/plugin/duration.min.js&quot;&gt;&lt;/script&gt;    - &lt;script src=&quot;/scripts/realtime.js&quot;&gt;&lt;/script&gt;\r\n注意是 bottom 部分\r\n在自定义页脚中加入一个 span 元素提供显示日期的位置\r\nfooter:  custom_text:     - &#x27;&lt;span id=&quot;realtime_duration&quot;&gt;&lt;/span&gt;&#x27; # 注意要带引号\r\n接下来主要通过 setInterval\r\n实现这样一个实时更新的功能。\r\n实现功能\r\n在 source 目录下创建\r\nscripts/realtime.js，写入以下代码：\r\n(() =&gt; &#123;  dayjs.extend(window.dayjs_plugin_duration)  const el = document.getElementById(&#x27;realtime_duration&#x27;)  // 改成自己的时间  const date = dayjs(&#x27;2022-05-19&#x27;)  setInterval(() =&gt; &#123;    const dur = dayjs.duration(dayjs().diff(date))    const days = String(Math.floor(dur.asDays()))    el.innerHTML = &#x27;已运行&#x27; + days + dur.format(&#x27;天HH时mm分ss秒&#x27;)  &#125;, 1000)&#125;)()\r\n注意是 文件路径为\r\nyour_hexo_blog/source/scripts/realtime.js\r\n如果 source 下没有\r\nscripts，直接新建一个就行\r\n\r\n不成功的额外修改\r\n如果到这里你顺利显示了，就是正常的情况了，接下来都是我自己摸索的额外的不成功的话该如何配置\r\n如果没有成功加载，先去看看你的 public 中存放 js\r\n的文件夹看看有没有成功加载 realtime.js\r\n这里会有一个问题，切换页面，日期显示就会消失？？？\r\n其实就是 Pjax 兼容的问题，你开了 Pjax就会这样，这个官方文档里也说了\r\nPjax 会导致部分 js 失效\r\n改一下就行了\r\ndocument.addEventListener(&#x27;DOMContentLoaded&#x27;, initRuntime)document.addEventListener(&#x27;pjax:complete&#x27;, initRuntime) // 添加Pjax支持function initRuntime() &#123;  dayjs.extend(window.dayjs_plugin_duration)    const el = document.getElementById(&#x27;realtime_duration&#x27;)  if (!el) return // 确保元素存在  const startDate = dayjs(&#x27;2022-05-19T00:00:00+08:00&#x27;)    const updateTime = () =&gt; &#123;    const now = dayjs()    const duration = dayjs.duration(now.diff(startDate))        // 手动拼接时间部分    const days = duration.days()    const hours = duration.hours().toString().padStart(2, &#x27;0&#x27;)    const minutes = duration.minutes().toString().padStart(2, &#x27;0&#x27;)    const seconds = duration.seconds().toString().padStart(2, &#x27;0&#x27;)    el.innerHTML = `网站正常或不正常的运行了$&#123;days&#125;天$&#123;hours&#125;时$&#123;minutes&#125;分$&#123;seconds&#125;秒`  &#125;  updateTime()  setInterval(updateTime, 1000)&#125;\r\n这个 CSS 样式根据需要添加\r\n/* 消除默认间距 */#footer-wrap .footer-separator &#123;  display: none;&#125;/* 时间显示样式 */#realtime_duration &#123;  font-size: 0.9em;  color: #666;  letter-spacing: 0.5px;  white-space: nowrap; /* 防止换行 */&#125;\r\n","categories":["教程","配置教程"],"tags":["配置相关","实用技术","实用类","配置文件","Hexo","教程","错误解决"]},{"title":"无偏估计性与估计有效程度比较的例题解析","url":"/posts/20606.html","content":"\r\n问题重述\r\n我们需要证明样本方差 $S^2 = \\frac{1}{n-1}\r\n\\sum_{i=1}^{n} (X_i - \\overline{X})^2$ 是总体方差 σ2 = D(X)\r\n的无偏估计量。即证明 E[S2] = σ2。\r\n证明步骤\r\n\r\n设定和已知条件：\r\n\r\n总体 X 的均值 E(X) = μ，方差\r\nD(X) = σ2 &lt; ∞。\r\n样本 X1, X2, …, Xn\r\n是独立同分布（i.i.d.）的，与 X\r\n同分布。\r\n样本均值 $\\overline{X} = \\frac{1}{n}\r\n\\sum_{i=1}^{n} X_i$。\r\n\r\n展开样本方差：\r\n$$\r\nS^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline{X})^2\r\n$$\r\n我们首先将 $(X_i - \\overline{X})$\r\n表示为 $(X_i - \\mu) - (\\overline{X} -\r\n\\mu)$：\r\n$$\r\n(X_i - \\overline{X}) = (X_i - \\mu) - (\\overline{X} - \\mu)\r\n$$\r\n然后平方：\r\n$$\r\n(X_i - \\overline{X})^2 = (X_i - \\mu)^2 - 2(X_i - \\mu)(\\overline{X} -\r\n\\mu) + (\\overline{X} - \\mu)^2\r\n$$\r\n求和并取期望：\r\n$$\r\n\\sum_{i=1}^{n} (X_i - \\overline{X})^2 = \\sum_{i=1}^{n} (X_i - \\mu)^2 -\r\n2\\sum_{i=1}^{n} (X_i - \\mu)(\\overline{X} - \\mu) + n(\\overline{X} -\r\n\\mu)^2\r\n$$\r\n现在对两边取期望：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} (X_i - \\overline{X})^2 \\right] = \\sum_{i=1}^{n}\r\nE\\left[ (X_i - \\mu)^2 \\right] - 2E\\left[ \\sum_{i=1}^{n} (X_i -\r\n\\mu)(\\overline{X} - \\mu) \\right] + nE\\left[ (\\overline{X} - \\mu)^2\r\n\\right]\r\n$$\r\n计算各项期望：\r\n\r\n第一项：\r\nE[(Xi − μ)2] = D(Xi) = σ2  对所有\r\ni\r\n所以：\r\n$$\r\n\\sum_{i=1}^{n} E\\left[ (X_i - \\mu)^2 \\right] = n\\sigma^2\r\n$$\r\n第二项： 注意到 $\\overline{X} - \\mu =\r\n\\frac{1}{n} \\sum_{j=1}^{n} (X_j - \\mu)$，所以：\r\n$$\r\n\\sum_{i=1}^{n} (X_i - \\mu)(\\overline{X} - \\mu) = \\sum_{i=1}^{n} (X_i -\r\n\\mu) \\cdot \\frac{1}{n} \\sum_{j=1}^{n} (X_j - \\mu) = \\frac{1}{n} \\left(\r\n\\sum_{i=1}^{n} (X_i - \\mu) \\right)^2\r\n$$\r\n因此：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} (X_i - \\mu)(\\overline{X} - \\mu) \\right] =\r\n\\frac{1}{n} E\\left[ \\left( \\sum_{i=1}^{n} (X_i - \\mu) \\right)^2 \\right]\r\n= \\frac{1}{n} \\cdot n\\sigma^2 = \\sigma^2\r\n$$\r\n（因为 $\\sum_{i=1}^{n} (X_i - \\mu)$\r\n的方差是 nσ2）\r\n第三项：\r\n$$\r\nE\\left[ (\\overline{X} - \\mu)^2 \\right] = D(\\overline{X}) =\r\n\\frac{\\sigma^2}{n}\r\n$$\r\n\r\n代入期望值：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} (X_i - \\overline{X})^2 \\right] = n\\sigma^2 -\r\n2\\sigma^2 + n \\cdot \\frac{\\sigma^2}{n} = n\\sigma^2 - 2\\sigma^2 +\r\n\\sigma^2 = (n-1)\\sigma^2\r\n$$\r\n因此：\r\n$$\r\nE[S^2] = E\\left[ \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline{X})^2\r\n\\right] = \\frac{1}{n-1} \\cdot (n-1)\\sigma^2 = \\sigma^2\r\n$$\r\n这表明 S2 是\r\nσ2\r\n的无偏估计。\r\n\r\n矩估计 Ŝ2 的有偏性\r\n矩估计 $\\hat{S}^2 = \\frac{1}{n}\r\n\\sum_{i=1}^{n} (X_i - \\overline{X})^2$ 的期望：\r\n$$\r\nE[\\hat{S}^2] = E\\left[ \\frac{n-1}{n} S^2 \\right] = \\frac{n-1}{n} E[S^2]\r\n= \\frac{n-1}{n} \\sigma^2\r\n$$\r\n因此，Ŝ2\r\n是有偏的，偏差为 $-\\frac{\\sigma^2}{n}$。但当 n → ∞，E[Ŝ2] → σ2，所以它是渐近无偏的。\r\n无偏估计的多样性\r\n对于总体均值 μ\r\n的无偏估计，任何形如 $\\sum_{i=1}^{n} c_i\r\nX_i$ 且 $\\sum_{i=1}^{n} c_i = 1$\r\n的估计量都是无偏的：\r\n$$\r\nE\\left[ \\sum_{i=1}^{n} c_i X_i \\right] = \\sum_{i=1}^{n} c_i E[X_i] = \\mu\r\n\\sum_{i=1}^{n} c_i = \\mu\r\n$$\r\n这表明无偏估计不唯一，样本均值 $\\overline{X}$ 是其中一种特例（$c_i = \\frac{1}{n}$）。\r\n结论\r\n\r\n样本方差 S2\r\n是总体方差 σ2\r\n的无偏估计。\r\n矩估计 Ŝ2\r\n是有偏的，但渐近无偏。\r\n无偏估计不唯一，可以通过不同方式构造。\r\n\r\n\r\n","categories":["学习类","数学","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计","定理证明"]},{"title":"关于Lombok在高版本IDEA中注解处理不生效的问题解决","url":"/posts/42179.html","content":"环境：\r\nIntelliJ IDEA 2024.1 + Spring Boot + Maven\r\n\r\n问题描述\r\n使用Lombok中的@Data注解标注其中实体类的时候，依旧会出现找不到\r\nget set 方法的问题\r\n\r\n解决方案\r\n先从通用的解决方案说起\r\n再说到比较针对性的解决方案\r\n\r\n方式1：\r\n\r\n检查是否安装 Lombok 插件\r\n\r\n\r\nimage-20250515093928330\r\n\r\n\r\n\r\n方式2\r\n是否打开注解自动加载运行\r\n\r\n\r\nimage-20250515094349492\r\n\r\n不止默认模块，项目对应模块也要开启\r\n\r\n\r\nimage-20250515094425419\r\n\r\n\r\n方式3：\r\n修改其中的存储相对于下列位置生成的源\r\n\r\n\r\nimage-20250515094502710\r\n\r\n把需要启用注解处理的模块和默认模块中的，存储相对于下列位置生成的源，调整为模块内容根\r\n\r\n方式4：\r\n不要在项目创建时引入，而是项目创建后直接在pom.xml以&lt;dependency&gt;的方式引入\r\n&lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.30&lt;/version&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;\r\n\r\n方式5\r\n调整 Lombok 的版本\r\n给lombok注解加入1.18.30的版本号，并删除下方build中所有和lombok有关的配置。\r\n注意版本一定得是1.18.30，并且不要忘记刷新maven仓库。\r\n\r\n\r\nimage-20250515094809800\r\n\r\n\r\n方式6\r\n删除 &lt;build&gt;下所有关于 Lombok 的\r\n&lt;plugins&gt;\r\n&lt;build&gt;        &lt;plugins&gt;            &lt;!--            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;annotationProcessorPaths&gt;                        &lt;path&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/path&gt;                    &lt;/annotationProcessorPaths&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            --&gt;            &lt;!--            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            --&gt;        &lt;/plugins&gt;    &lt;/build&gt;\r\n\r\n差不多这样问题就解决了\r\nLombok 插件与版本有关那个部分，我没有看到 Lombok\r\n插件有提到限定版本，反之就 1.18.30 是可以的，高了不行，低了不行\r\n","categories":["教程","错误解决"],"tags":["实用知识","Java技术","常用知识","学习类","教程","错误解决","Maven"]},{"title":"对书上证明样本方差是总体方差的无偏估计量的解析","url":"/posts/6458.html","content":"问题描述\r\n设总体服从区间 [0, θ]\r\n上的均匀分布，(X1, X2, ⋯, Xn)\r\n为取自该总体的容量为 n\r\n的样本。对未知参数 θ\r\n的两个估计量：\r\n$$\r\n\\hat{\\theta}_1 = 2\\bar{X}, \\quad \\hat{\\theta}_2 = \\frac{n+1}{n} \\max_{1\r\n\\leq i \\leq n} \\{ X_i \\}.\r\n$$\r\n\r\n验证 θ̂1 和\r\nθ̂2 均为 θ 的无偏估计；\r\n\r\n指出哪个更有效。\r\n\r\n\r\n(1) 验证无偏性\r\n1.1 验证 θ̂1 = 2X̄\r\n的无偏性\r\n\r\n步骤 1：计算总体均值\r\n\r\n总体 $ X U[0, ] ，其期望为：$\r\nE(X) = = $$\r\n所以对于总体 X ∼ U[0, θ]，有\r\n$E(X) = \\frac{\\theta}{2}$。\r\n\r\n步骤 2：计算样本均值的期望\r\n\r\n样本均值 $\\bar{X} = \\frac{1}{n}\r\n\\sum_{i=1}^{n} X_i$，其期望为：\r\n\r\n\r\n$$\r\nE(\\bar{X}) = \\frac{1}{n} \\sum_{i=1}^{n} E(X_i) = \\frac{1}{n} \\cdot n\r\n\\cdot \\frac{\\theta}{2} = \\frac{\\theta}{2}.\r\n$$\r\n\r\n步骤 3：计算 θ̂1 的期望：\r\n\r\n由题意，θ̂1 = 2X̄，因此\r\n\r\n$$\r\nE(\\hat{\\theta}_1) = 2E(\\bar{X}) = 2 \\cdot \\frac{\\theta}{2} = \\theta.\r\n$$\r\n\r\n这表明 θ̂1 是\r\nθ 的无偏估计。\r\n\r\n\r\n1.2 验证 $\\hat{\\theta}_2 = \\frac{n+1}{n} X_{(n)}$\r\n的无偏性\r\n\r\n可知，X(n) = max1 ≤ i ≤ n{Xi}\r\n是样本的最大次序统计量。\r\n\r\n背景知识：\r\n\r\n次序统计量：对于样本 X1, X2, …, XnX1, X2, …, Xn，将其按从小到大排列为\r\nX(1) ≤ X(2) ≤ … ≤ X(n)X(1) ≤ X(2) ≤ … ≤ X(n)，其中\r\nX(n) = max⁡XiX(n) = maxXi。\r\n均匀分布性质：Xi ∼ U[0, θ]Xi ∼ U[0, θ]，其累积分布函数（CDF）为\r\n$F_{X}(x)= \\frac xθ$ （当$\r\n0≤x≤θ$）。\r\n\r\n\r\n步骤 1：推导最大次序统计量 X(n)\r\n的密度函数\r\n\r\n每个样本Xi\r\n的累积分布函数（CDF）为：\r\n\r\n$$\r\nF_X(x) = \\begin{cases}\r\n    0, &amp; x &lt; 0, \\\\\r\n    \\frac{x}{\\theta}, &amp; 0 \\leq x \\leq \\theta, \\\\\r\n    1, &amp; x &gt; \\theta.\r\n  \\end{cases}\r\n$$\r\n\r\n最大值 X(n) = maxX1, X2, …, Xn\r\n的 CDF 为：\r\n\r\n$$\r\nF_{X_{(n)}}(x) = P(X_{(n)} \\leq x) = [F_X(x)]^n =\r\n\\left(\\frac{x}{\\theta}\\right)^n \\quad (0 \\leq x \\leq \\theta).\r\n$$\r\n\r\n对 CDF 求导得到概率密度函数（PDF）：\r\n\r\n$$\r\nf_{X_{(n)}}(x) = \\frac{d}{dx} F_{X_{(n)}}(x) = \\frac{n\r\nx^{n-1}}{\\theta^n} \\quad (0 \\leq x \\leq \\theta).\r\n$$\r\n\r\n所以，X(n)\r\n的概率密度函数（PDF）为：\r\n\r\n$$\r\nf_{X_{(n)}}(x) = \\frac{n x^{n-1}}{\\theta^n}, \\quad 0 \\leq x \\leq \\theta.\r\n$$\r\n步骤 2：计算 E(X(n))\r\n$$\r\n\\begin{aligned}\r\nE(X_{(n)}) &amp;= \\int_{0}^{\\theta} x \\cdot \\frac{n x^{n-1}}{\\theta^n}\r\n\\, dx \\\\\r\n&amp;= \\frac{n}{\\theta^n} \\int_{0}^{\\theta} x^n \\, dx \\\\\r\n&amp;= \\frac{n}{\\theta^n} \\left[ \\frac{x^{n+1}}{n+1} \\bigg|_{0}^{\\theta}\r\n\\right] \\\\\r\n&amp;= \\frac{n}{\\theta^n} \\cdot \\frac{\\theta^{n+1}}{n+1} \\\\\r\n&amp;= \\frac{n}{n+1} \\theta.\r\n\\end{aligned}\r\n$$\r\n步骤 3：计算 θ̂2 的期望\r\n由题意可知$\\quad \\hat{\\theta}_2 =\r\n\\frac{n+1}{n} \\max_{1 \\leq i \\leq n} \\{ X_i \\}.$ $$\r\nE(\\hat{\\theta}_2) = \\frac{n+1}{n} E(X_{(n)}) = \\frac{n+1}{n} \\cdot\r\n\\frac{n}{n+1} \\theta = \\theta.\r\n$$ 这表明 θ̂2\r\n也是 θ 的无偏估计。\r\n\r\n\r\n(2) 比较有效性\r\n估计量的有效性通过方差衡量：方差越小，估计量越有效。\r\n2.1 计算θ̂1的方差 D(θ̂1)\r\n\r\n步骤 1：总体方差\r\n均匀分布的方差为：(均匀分布的性质) $$\r\nD(X) = \\frac{(\\theta - 0)^2}{12} = \\frac{\\theta^2}{12}.\r\n$$\r\n步骤 2：样本均值的方差\r\n\r\n$$\r\nD(\\bar{X}) = \\frac{D(X)}{n} = \\frac{\\theta^2}{12n}.\r\n$$\r\n\r\n步骤 3：θ̂1 的方差：\r\n$$\r\nD(\\hat{\\theta}_1) = 4 D(\\bar{X}) = 4 \\cdot \\frac{\\theta^2}{12n} =\r\n\\frac{\\theta^2}{3n}.\r\n$$\r\n\r\n2.2 计算 D(θ̂2)\r\n方差的定义\r\n对于任何随机变量 Y，其方差为： D(Y) = E(Y2) − [E(Y)]2\r\n因此，计算 D(X(n))\r\n需要：\r\n\r\n计算 E(X(n))\r\n一阶矩）。\r\n计算 E(X(n)2)\r\n（二阶矩）。\r\n\r\n\r\n首先计算 E(X(n)2)：\r\n$$\r\n\\begin{aligned}E(X_{(n)}^2) &amp;= \\int_{0}^{\\theta} x^2 \\cdot \\frac{n\r\nx^{n-1}}{\\theta^n} \\, dx \\\\&amp;= \\frac{n}{\\theta^n} \\int_{0}^{\\theta}\r\nx^{n+1} \\, dx \\\\&amp;= \\frac{n}{\\theta^n} \\left[ \\frac{x^{n+2}}{n+2}\r\n\\bigg|_{0}^{\\theta} \\right] \\\\&amp;= \\frac{n}{\\theta^n} \\cdot\r\n\\frac{\\theta^{n+2}}{n+2} \\\\&amp;= \\frac{n}{n+2} \\theta^2.\\end{aligned}\r\n$$ 详细的过程\r\n利用 PDF fX(n)(x)：\r\n$$\r\nE(X_{(n)}) = \\int_{0}^{\\theta} x \\cdot f_{X_{(n)}}(x) \\, dx =\r\n\\int_{0}^{\\theta} x \\cdot \\frac{n x^{n-1}}{\\theta^n} \\, dx =\r\n\\frac{n}{\\theta^n} \\int_{0}^{\\theta} x^n \\, dx.\r\n$$ 积分结果： $$\r\nE(X_{(n)}) = \\frac{n}{\\theta^n} \\cdot \\left. \\frac{x^{n+1}}{n+1}\r\n\\right|_{0}^{\\theta} = \\frac{n}{n+1} \\theta.\r\n$$ 类似地 $$\r\nE(X_{(n)}^2) = \\int_{0}^{\\theta} x^2 \\cdot f_{X_{(n)}}(x) \\, dx =\r\n\\int_{0}^{\\theta} x^2 \\cdot \\frac{n x^{n-1}}{\\theta^n} \\, dx =\r\n\\frac{n}{\\theta^n} \\int_{0}^{\\theta} x^{n+1} \\, dx.\r\n$$ 积分结果 $$\r\nE(X_{(n)}^2) = \\frac{n}{\\theta^n} \\cdot \\left. \\frac{x^{n+2}}{n+2}\r\n\\right|_{0}^{\\theta} = \\frac{n}{n+2} \\theta^2.\r\n$$\r\n然后计算方差 D(X(n))：\r\n$$\r\n\\begin{aligned}D(X_{(n)}) &amp;= E(X_{(n)}^2) - [E(X_{(n)})]^2 \\\\&amp;=\r\n\\frac{n}{n+2} \\theta^2 - \\left( \\frac{n}{n+1} \\theta \\right)^2 \\\\&amp;=\r\n\\theta^2 \\left( \\frac{n}{n+2} - \\frac{n^2}{(n+1)^2} \\right) \\\\&amp;=\r\n\\theta^2 \\cdot \\frac{n(n+1)^2 - n^2(n+2)}{(n+2)(n+1)^2} \\\\&amp;=\r\n\\theta^2 \\cdot \\frac{n(n^2 + 2n + 1) - n^3 - 2n^2}{(n+2)(n+1)^2}\r\n\\\\&amp;= \\theta^2 \\cdot \\frac{n^3 + 2n^2 + n - n^3 - 2n^2}{(n+2)(n+1)^2}\r\n\\\\&amp;= \\theta^2 \\cdot \\frac{n}{(n+2)(n+1)^2}.\\end{aligned}\r\n$$\r\n因此： $$\r\nD(\\hat{\\theta}_2) = \\left( \\frac{n+1}{n} \\right)^2 D(X_{(n)}) =\r\n\\frac{(n+1)^2}{n^2} \\cdot \\frac{n \\theta^2}{(n+2)(n+1)^2} =\r\n\\frac{\\theta^2}{n(n+2)}.\r\n$$\r\n其中\r\n\r\n最大值的分布需要考虑所有样本不超过某个值的联合概率，因此 CDF 是单个\r\nCDF 的 n 次方。\r\n最大值的 PDF：因为所有样本必须小于等于 x，且其中一个样本“支撑”在 x 附近\r\nPDF 是 CDF 的导数，直接反映了概率密度的变化率。\r\n\r\n\r\n2.3 比较 D(θ̂1) 和 D(θ̂2)\r\n\r\nθ̂1方差 $$\r\nD(\\hat{\\theta}_1) = \\frac{\\theta^2}{3n}\r\n$$\r\nθ̂2方差 $$\r\nD(\\hat{\\theta}_2) = \\frac{\\theta^2}{n(n+2)}\r\n$$\r\n对于 n ≥ 2，有 n(n + 2) &gt; 3n\r\n\r\n因为 n2 + 2n &gt; 3n\r\n即 n2 − n &gt; 0 对\r\nn ≥ 2 成立，且 n = 1 时 1 ⋅ 3 = 3 等于 3 ⋅ 1 = 3。\r\n\r\n因此： $$\r\n\\frac{\\theta^2}{n(n+2)} &lt; \\frac{\\theta^2}{3n}, \\quad \\text{当} \\ n\r\n\\geq 2.\r\n$$ 对于 n = 1，两者方差相等： $$\r\nD(\\hat{\\theta}_1) = \\frac{\\theta^2}{3}, \\quad D(\\hat{\\theta}_2) =\r\n\\frac{\\theta^2}{3}.\r\n$$\r\n\r\n结论\r\n\r\n当 n ≥ 2 时，D(θ̂2) &lt; D(θ̂1)，因此\r\nθ̂2 更有效。\r\n当 n = 1\r\n时，两者方差相同，有效性相同。\r\n\r\n\r\n补充说明\r\n\r\n无偏性：两个估计量都无偏，但 θ̂2\r\n利用了样本的最大值信息，更直接反映了 θ 的上界。\r\n有效性：θ̂2 的方差更小，因为 max {Xi} 是\r\nθ 的充分统计量，包含了更多关于\r\nθ 的信息。\r\n直观理解：θ̂1\r\n基于样本均值，而均匀分布的均值对 θ 的估计不够敏感；θ̂2\r\n直接修正了最大值的偏差，更精确。\r\n\r\n","categories":["学习类","数学","概率论与数理统计"],"tags":["学习类","数学","概率论与数理统计","定理证明"]},{"title":"把Hexo博客配置到Github Pages下","url":"/posts/53748.html","content":"使用 Hexo+GitHub 搭建个人博客\r\n前情提要\r\n你需要自己去安装nodejs和git的环境，因为Hexo 基于\r\nNode.js，搭建过程中还需要使用 npm（Node.js 已带） 和\r\ngit，因此先搭建本地操作环境，安装 Node.js 和 Git。\r\n这种教程csdn一搜一大堆啊，基本照着做都是下一步和最后的配置环境变量\r\n\r\nNode.js：https://nodejs.org/zh-cn\r\nGit：https://git-scm.com/downloads\r\n\r\n安装完成后，Win+R 输入 cmd 并打开，依次输入\r\nnode -v、npm -v 和 git --version\r\n并回车，出现程序版本号即可。\r\n然后你需要自己去注册一个GitHub账号，这里强烈建议设置SSH密钥\r\n安装Hexo\r\n新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog\r\n安装Hexo\r\n使用 npm 一键安装 Hexo 博客程序：\r\n注意：建议之后所有使用命令行安装操作都使用 管理员模式下的cmd\r\nnpm install -g hexo-cli\r\n比较难绷的是安装时候界面没有任何反应，而且时间还不短\r\n初始化Hexo\r\n初始化并安装所需组件\r\nhexo init      # 初始化npm install    # 安装组件\r\n完成后依次输入下面命令，启动本地服务器进行预览：\r\nhexo g   # 生成页面hexo s   # 启动预览\r\n访问\r\nhttp://localhost:4000，出现 Hexo\r\n默认页面，本地博客安装成功！\r\n\r\n\r\nimage-20250413155631935\r\n\r\n如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行\r\nhexo server -p 5000 更改端口号后重试。\r\n博客文件目录结构\r\n\r\n\r\nimg\r\n\r\n创建一个Github仓库来存放你的静态页面\r\nGitHub 主页右上角加号 -&gt; New repository：\r\n​ 注意，这里的仓库名字是 用户名.github.io 最好选上 “Initialize this\r\nrepository with a README”\r\n此时如果你在这个仓库上配置博客的话，博客地址为：https://用户名.github.io\r\n部署到Github Pages\r\n本地博客测试成功后，就是上传到 GitHub\r\n进行部署，使其能够在网络上访问。\r\n首先安装 hexo-deployer-git：\r\nnpm install hexo-deployer-git --save\r\n然后**修改博客根目录下的 _config.yml** 文件末尾的 Deployment\r\n部分，修改成如下：\r\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: main\r\n这里说一下yml文件的格式，yml缩进有严格的格式要求，而且每个字段后的冒号之后必须有空格才能输入有效\r\n完成后运行 hexo d 将网站上传部署到 GitHub Pages。\r\n完成！这时访问我们的 GitHub 域名\r\nhttps://用户名.github.io 就可以看到 Hexo 网站了。\r\n绑定域名\r\n博客搭建完成使用的是 GitHub 的子域名（用户名.http://github.io），我们可以为\r\nHexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于\r\nSEO。\r\n建议这里使用免实名的域名，实名一个域名比较麻烦，而且要等\r\n域名注册和解析\r\n\r\n域名注册和解析教程：Namesilo\r\n域名购买及使用教程\r\n\r\n按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加\r\nCNAME 记录将 www 域名解析指向 用户名.github.io。\r\n\r\n\r\nimg\r\n\r\n绑定域名到 Hexo 博客\r\n进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如\r\nhttp://www.example.com，保存名称为 “CNAME”，格式为 “所有文件”（无 .txt\r\n后缀）。\r\n清除缓存等文件并重新发布网站：\r\nhexo clean   # 清除缓存文件等hexo g       # 生成页面hexo s       # 启动预览\r\n现在就可以使用自己的域名访问 Hexo 博客了。\r\n开启HTTPS\r\n配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub\r\n仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce\r\nHTTPS。\r\n\r\n\r\nimg\r\n\r\nHTTPS\r\n证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS\r\n配置完成！\r\n关于使用\r\n发布文章\r\n进入博客所在目录，右键打开 Git Bash Here，创建博文：\r\nhexo new &quot;My New Post&quot;\r\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用\r\nMarkdown 编辑器在该文件中撰写文章了。\r\n写完后运行下面代码将文章渲染并部署到 GitHub Pages\r\n上完成发布。以后每次发布文章都是这两条命令。\r\nhexo g   # 生成页面hexo d   # 部署发布\r\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式\r\nFront-matter 即可，写完后运行 hexo g 和 hexo d\r\n发布。\r\n---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文\r\n常用命令\r\nhexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助\r\n我的另一篇博客也提到了hexo命令的基本用法，可以看看\r\nHexo命令的基本用法\r\n","categories":["教程","配置教程"],"tags":["Hexo相关","教程","部署"]},{"title":"操作系统之处理机的死锁部分概述","url":"/posts/27893.html","content":"死锁概述\r\n死锁（Deadlock）：是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。\r\n资源问题\r\n\r\n可重用性资源和消耗性资源：\r\n\r\n可重用性资源：\r\n\r\n是一种可供用户重复使用多次的资源。每一个可重用性资源只能分配给一个进程使用，不允许多个进程共享。\r\n资源的单元数目是相对固定的，在运行期间既不能创建也不能删除它\r\n\r\n消耗性资源：\r\n\r\n在进程运行期间，由进程动态地创建和消耗。\r\n资源的单元数目在进程运行期间可以不断变化的。进程可以请求若干个可消耗性资源单元。\r\n可消耗性资源通常由生产者创建，消费者消耗。\r\n\r\n\r\n可抢占性资源和不可抢占性资源。\r\n\r\n可抢占性资源：\r\n\r\n某进程获得该资源后，该资源可以再被其他进程或系统抢占。\r\n不会引起死锁。\r\n\r\n不可抢占性资源是指资源一旦被分配给进程，只能在进程用完后自行释放。\r\n\r\n\r\n### 计算机中的死锁\r\n\r\n竞争不可抢占性资源引起死锁。\r\n\r\n两进程分别保持一个临界资源，而又分别因请求对方所保持的资源被阻塞。\r\n\r\n竞争可消耗性资源引起死锁。\r\n\r\n一进程需接受到对方发送的消息a后才能发送消息b，而另一进程需接受到对方发送的消息b后才能发送消息a。\r\n\r\n进程推进顺序不当引起死锁。\r\n\r\n同样是请求和保持原因。\r\n\r\n\r\n死锁的定义：\r\n如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的时间，那么该组进程是死锁的。\r\n产生死锁的必要条件\r\n互斥条件：指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。\r\n请求和保持条件：指进程已经保持了至少一个资源，但又提出了\r\n新的资源请求（该资源又被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放）。\r\n不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放\r\n环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。即进程集合{P0,P1,P2,…,Pn}中的P0正在等待一个P1占用的资源；P1正在等待一个P2占用的资源，……，Pn正在等待一个已被P0占用的资源。\r\n死锁处理方法\r\n预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件的一个或几个，来预防发生死锁。\r\n避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁\r\n检测死锁：通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当的措施，从系统中将已发生的死锁清除掉\r\n解除死锁：当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源\r\n预防死锁\r\n由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏其它三个条件。\r\n破坏“请求和保持”条件\r\n第一种协议：\r\n​\r\n规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。在整个运行期间便不会再提出资源要求，从而破坏了请求条件。\r\n​\r\n在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需的各资源都空闲，也不分配给该进程，即在该进程的等待期间，它并未占有任何资源，因而也破坏了保持条件。\r\n第二种协议：\r\n​ 允许进程只获得运行初期所需的资源后，便开始运行。\r\n​\r\n进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再去请求新的所需资源\r\n破坏不可抢占条件\r\n当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。\r\n这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被抢占了，从而破坏了“不可抢占”条件。\r\n破坏 循环等待条件\r\n系统将所有类型资源进行线性排队，并赋予不同的序号。规定每个进程必须按序号递增的顺序请求资源。\r\n假如某进程已请求到一些序号较高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源\r\n在采用这种策略后不可能再出现环路，因而破坏了“循环等待”条件。\r\n避免死锁\r\n系统安全状态：\r\n系统在进行资源分配之前，应先计算此次资源分配的安全性。\r\n安全状态，是指系统能按某种进程顺序（ P0, P1, P2, …, Pn\r\n）来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态\r\n安全状态下不会产生死锁，但是不安全状态不一定产生死锁\r\n利用银行家算法避免死锁\r\n描述资源的数据结构\r\n在系统中必须设置四种数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。\r\n（设系统中有m类资源，n个进程）\r\n\r\n可利用资源向量 Available：\r\n\r\n这是一个含有 m\r\n个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。\r\n如果 Available[j]=K，则表示系统中现有 R j类资源K 个。\r\n\r\n最大需求矩阵 Max：\r\n\r\n这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m\r\n类资源的最大需求。\r\n\r\n分配矩阵 Allocation：\r\n\r\n这也是一个 n×m\r\n的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。\r\n如果 Allocation[i,j]=K，则表示进程 i 当前已分得 R j类资源的数目为\r\nK。\r\n\r\n需求矩阵 Need。这也是一个 n×m\r\n的矩阵，用以表示每一个进程尚需的各类资源数。\r\n\r\n如果 Need[i,j]=K，则表示进程 i 还需要 R j类资源 K\r\n个，方能完成其任务。\r\n\r\n\r\n上述三个矩阵间存在下述关系：Need[i, j] = Max[i, j] - Allocation[i,\r\nj]\r\n银行家算法：\r\n设 Request[i] 是进程 P i 的请求向量，如果 Request[i][j]=K，表示进程 P\r\ni需要 K 个 R j 类型的资源。当 P\r\ni发出资源请求后，系统按下述步骤进行检查：\r\n\r\n如果\r\nRequest[i][j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值\r\n如果\r\nRequest[i][j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi\r\n须等待。\r\n系统试探着把资源分配给进程 P i，并修改下面数据结构中的数值：\r\n\r\nAvailable[j] = Available[j]-Request[i][j]； 更新可用资源数目\r\nAllocation[i,j] = Allocation[i,j]+Request[i][j]；\r\n更新分配给该进程的资源数\r\nNeed[i,j] = Need[i,j]-Request[i][j]； 更新该进程需要的资源数\r\n\r\n\r\n安全性算法：\r\n\r\n设置两个向量：\r\n\r\n工作向量\r\nWork，它表示系统可提供给进程继续运行所需的各类资源数目，它含有\r\nm个元素，在执行安全算法开始时，Work=Available。\r\nFinish:\r\n含n个元素的一维数组，表示系统是否有足够的资源分配给n个进程，使之运行完成。开始时先令Finish[i]:=false\r\n(i=1..n); 当有足够资源分配给进程i时，再令Finish[i]:=true。\r\n\r\n从进程集合中找到一个能满足下述条件的进程：\r\n\r\nFinish[i]=false;\r\nNeed[i,j]≤Work[j]；\r\n若找到，执行步骤(3)，否则，执行步骤(4)。\r\n\r\n当进程\r\nPi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：\r\n\r\nWork[j] = Work[j]+Allocation[i,j]；\r\nFinish[i] = true；\r\ngo to step 2；\r\n\r\n如果所有进程的 Finish[i]=true\r\n都满足，则表示系统处于安全状态；否则，系统处于不安全状态。\r\n\r\n死锁的检测和解除\r\n\r\n当系统为进程分配资源时，若未采取任何限制性措施，则系统必须提供检测和解除死锁的手段，为此系统必须：\r\n\r\n保存有关资源的请求和分配信息；\r\n提供一种算法，以利用这些信息来检测系统是否已进入死锁状态。\r\n\r\n资源分配图：\r\n\r\n系统死锁可利用资源分配图来描述：\r\n该图由表示进程的圆圈和表示一类资源的方框组成\r\n其中方框中的一个点代表一个该类资源，请求边是由进程指向方框中的rj，而分配边则应始于方框中的一个点。如图所示。\r\n\r\n\r\nimage-20250429200304004\r\n\r\n\r\n死锁定理：\r\n\r\n在资源分配图中找出一个既不阻塞又非独立的进程结点Pi，在顺利的情况下运行完毕，释放其占有的全部资源。\r\n由于释放了资源，这样能使其它被阻塞的进程获得资源继续运行。\r\n在经过一系列简化后若能消去图中的所有的边，使所有进程结点都孤立，则称该图是可完全简化的，反之是不可完全简化的。\r\nS 状态为死锁状态的充分条件是当且仅当 S\r\n状态的资源分配图是不可完全简化的\r\n\r\n死锁的解除：\r\n\r\n剥夺资源：从其他进程剥夺足够数量的资源给死锁进程以解除死锁状态。\r\n撤销进程：最简单的是让全部进程都死掉；温和一点的是按照某种顺序逐个撤销进程，直至有足够的资源可用，使死锁状态消除为止。\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之处理机的调度","url":"/posts/58087.html","content":"处理机调度的层次和调度算法的目标\r\n在多道程序环境下，进程数目往往多于处理机数目。\r\n这就要求系统能够按某种算法，动态的把处理机分配给就绪队列中的一个进程，使之执行\r\n分配处理机的任务是由处理机调度程序完成的\r\n处理机调度的层次\r\n高级调度：\r\n用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后将新创建的进程排在就绪队列上，准备执行\r\n又称长程调度或作业调度。它的调度对象为作业，只适用于多道批处理系统中，不适合实时和分时系统。\r\n低级调度：\r\n用来决定就绪队列中的哪个进程应获得处理机，然后再由分派程序把处理机分配给该进程。为最基本的一种调度\r\n又称进程调度或短程调度。它的调度对象为进程或内核级线程，适用于所有类型的操作系统。\r\n中级调度：\r\n又称内存调度。主要目的是为了提高内存利用率和系统吞吐量。\r\n使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。\r\n进程调度可采用下述两种调度方式：\r\n\r\n非抢占方式（Non-preemptive Mode）\r\n一旦把处理机分配给某进程后，便让该进程一直执行，直至该进程完成或发生某事件而被阻塞时，才把处理机分配给其他进程\r\n抢占方式（Preemptive Mode）\r\n允许调度程序根据某种原则，去暂停某个正在执行的进程，将处理机重新分配给另一进程。\r\n\r\n队列调度模型\r\n仅有进程调度的调度队列模型\r\n在分时系统中，通常仅设置进程调度。系统可以把处于就绪状态的进程组织成栈、树或一个无序链表，形式取决于OS类型和所采用的调度算法。\r\n\r\n\r\nimage-20250506101611187\r\n\r\n具有高级和低级调度的调度队列模型\r\n\r\n\r\nimage-20250506101650937\r\n\r\n同时具有三级调度的调度队列模型\r\n当在OS中引入中级调度后，可以把进程的就绪状态分为内存就绪和外存就绪。也可以把阻塞状态分为内存阻塞和外存阻塞两种状态。\r\n\r\n\r\nimage-20250506101806356\r\n\r\n处理机调度算法的目标\r\n共同目标：\r\n\r\n资源利用率\r\n\r\n\r\nimage-20250506101946057\r\n\r\n公平性\r\n公平性是指应使诸进程都获得合理的CPU\r\n时间，不会发生进程饥饿现象。公平性是相对的。\r\n平衡性\r\n应尽可能保持系统资源使用的平衡性。\r\n策略强制执行\r\n包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。\r\n\r\n批处理系统的目标：\r\n平均周转时间短：所谓周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔\r\n带权周转时间：作业的周转时间 T 与系统为它提供服务的时间 Ts 之比\r\n系统吞吐量高：吞吐量是指在单位时间内系统所完成的作业数。如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。\r\n处理机利用率高：如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行\r\n分时系统的目标：\r\n响应时间快。所谓响应时间，是从用户通过键盘提交一个请求开始，直至屏幕上显示出处理结果为止的一段时间间隔。\r\n均衡性。指系统响应时间的快慢应与用户所请求服务的复杂性相适应。\r\n实时系统的目标\r\n截止时间的保证。是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。\r\n可预测性。 例如在多媒体系统中，可实现第 i 帧的播放和第 i+1\r\n帧的读取并行处理，进而提高其实时性。\r\n作业和作业调度\r\n作业控制块 JCB\r\n是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。\r\n每当一个作业进入系统时，便由“作业注册”程序为该作业建立一个\r\nJCB，再根据作业类型将它插入相应的作业后备队列中等待调度。\r\n在每次执行作业调度时，都须作出两个决定：\r\n\r\n接纳多少作业\r\n接纳哪些作业\r\n\r\n作业运行的三个阶段和三种状态\r\n\r\n收容阶段。\r\n把作业输入到硬盘上，再为作业建立 JCB\r\n并把它放入作业后备队列中。此时作业状态为“后备状态”。\r\n运行阶段。\r\n此时作业状态为“运行状态”。\r\n完成阶段。\r\n此时作业状态为“完成状态”。系统中的“终止作业”程序将会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。\r\n\r\n作业调度算法\r\n先来先服务调度算法 FCFS。\r\n当在作业调度中采用FCFS算法时，每次调度都是从后备作业队列中，选择一个或多个最先进入该队列的作业\r\n优先考虑在系统中最先进入（等待时间最长）的作业。\r\n比较有利于长作业（进程），而不利于短作业（进程）。有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业（进程）\r\n短作业（进程）优先调度算法 SJF\r\nSJF算法是以作业的长短来计算优先级的，作业的长短是以作业所要求的运行时间来衡量的。\r\n从后备队列中选择一个或若干个估计运行时间最短的作业\r\n优点是有效降低作业的平均等待时间，提高系统吞吐量。\r\n缺点是可能使长作业等待时间过长，出现饥饿现象。\r\n高优先权优先调度算法：\r\n优先权调度算法的类型\r\n为照顾紧迫性作业，使之在进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法\r\n分为：\r\n\r\n非抢占式优先权算法\r\n抢占式优先权调度算法\r\n\r\n静态优先权：在创建进程时确定的，在进程的整个运行期间保持不变\r\n动态优先权：在创建进程时所赋予的优先权可以随进程的推进或随其等待时间的增加而改变。\r\n高相应比优先调度算法\r\n高响应比优先调度算法是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长。\r\n为每个作业引入一个动态优先级，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加\r\n\r\n\r\nimage-20250506102556129\r\n\r\n于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先权又相当于响应比\r\nRP。\r\n\r\n\r\nimage-20250506102707862\r\n\r\n例子：\r\n\r\n\r\nimage-20250506104042611\r\n\r\n进程调度\r\n进程调度的任务：\r\n\r\n保存处理机的现场信息。\r\n按某种算法选取进程。\r\n把处理器分配给进程。\r\n\r\n进程调度可采用下述两种调度方式：\r\n\r\n非抢占式\r\n抢占式\r\n抢占的原则：\r\n\r\n优先权原则：优先权高的可以抢占优先级低的进程的处理机。\r\n短作业（进程）优先原则：短作业（进程）可以抢占长作业（进程）的处理机。\r\n时间片原则：各进程按时间片运行，一个时间片用完时，停止该进程执行重新进行调度。\r\n\r\n\r\n轮转调度算法：RR\r\n系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给首进程，并令其执行一个时间片。\r\n进程切换时机：\r\n\r\n若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，并为新进程启动一个新的时间片。\r\n在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。\r\n\r\n例题：\r\n​ \r\n过程：\r\n\r\n(q = 1) 时的调度过程\r\n\r\n0 时刻：进程 A 到达，进入就绪队列，此时就绪队列只有\r\nA，A 开始运行。运行 1 个时间片后（到 1 时刻），A 还需服务时间 (4 - 1=3)\r\n，A 被暂停，放入就绪队列队尾 。\r\n1 时刻：进程 B 到达，加入就绪队列，此时队首是 B，B\r\n开始运行 1 个时间片，B 还需服务时间 (3 - 1 = 2) ，B\r\n被暂停，放入队尾。然后队首是 A，A 运行 1 个时间片，如此循环。\r\n随着时间推进，不断按照每个进程运行 1\r\n个时间片后放入队尾的规则调度，直到所有进程完成。比如 D 进程在 3\r\n时刻到达，加入队尾，按序调度运行。\r\n计算周转时间：周转时间 = 完成时间 - 到达时间，例如 A 的周转时间 (=\r\n12 - 0 = 12) 。\r\n计算带权周转时间：带权周转时间 = 周转时间 / 服务时间，A\r\n的带权周转时间 (=12 / 4 = 3) 。\r\n\r\n(q = 4) 时的调度过程\r\n\r\n原理类似，但时间片变长。0 时刻 A 到达运行，运行 4 个时间片到 4\r\n时刻，A 服务时间 4 刚好完成，离开就绪队列 。\r\n之后按序调度其他进程，每个进程运行 4\r\n个时间片，若未完成则放入队尾等待下次调度。例如 B 进程 1 时刻到达，在 A\r\n完成后开始运行，运行 4 个时间片到 7 时刻，B 还需 (3 - 4=-1) （已完成）\r\n。\r\n同样计算周转时间和带权周转时间，如 A 的周转时间 (= 4 - 0 = 4)\r\n，带权周转时间 (= 4 / 4 = 1) 。\r\n\r\n\r\n优先级调度算法\r\n类型：\r\n\r\n非抢占式优先级调度算法。\r\n抢占式优先级调度算法，实时性高\r\n\r\n多级反馈队列调度算法：\r\n\r\n调度机制：\r\n\r\n设置多个就绪队列：\r\n每个队列赋予不同的优先级，第一个最高，依次逐渐降低；时间片设置也不同，优先级越高，时间片越小。\r\n每个队列都采用FCFS算法：\r\n当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度，依次\r\n按队列优先级调度：\r\n调度程序首先调度最高优先级队列中的诸进程运行，仅当第 1～(i-1)\r\n所有队列均空时，才会调度第 i 队列中的进程运行。\r\n如果处理机正在第i队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程\r\n\r\n\r\n基于公平原则的调度算法\r\n保证调度算法:\r\n针对进程而言，处理机时间分配的公平性。\r\n公平分享调度算法:\r\n针对用户而言，使所有用户能获得相同的处理机时间，或要求的时间比例。\r\n实时调度\r\n实时系统中包含两种任务\r\n硬实时任务指必须满足最后期限的限制，否则会给系统带来不可接受的破坏或者致命错误。\r\n软实时任务也有一个与之关联的最后期限，并希望能满足这个期限的要求，但这并不是强制的，即使超过了最后期限，调度和完成这个任务仍然是有意义的。\r\n实现实时调度的基本条件\r\n提供必要的信息：\r\n\r\n就绪时间\r\n开始截止事件，完成截止时间\r\n处理时间\r\n资源要求\r\n优先级\r\n\r\n系统处理能力强\r\n\r\n\r\nimage-20250506111055024\r\n\r\n采用抢占式调度机制\r\n具有快速切换机制\r\n实时调度算法的分类：\r\n根据实时任务性质的不同，分为硬实时调度算法和软实时调度算法；\r\n按调度方式的不同，分为非抢占调度算法和抢占调度算法；\r\n根据调度程序调度时间的不同，分为静态调度算法和动态调度算法。\r\n多处理机环境下，可分为集中式调度和分布式调度两种算法。\r\n非抢占调度算法\r\n该算法较简单，用于一些小型实时系统或要求不太严格的实时系统中。又可分为两种\r\n\r\n非抢占式轮转调度算法：\r\n要求不高的实时控制系统\r\n非抢占式优先调度算法：\r\n有一定要求的实时控制系统\r\n\r\n\r\n\r\nimage-20250506111216521\r\n\r\n抢占调度算法：\r\n用于要求较严格的实时系统中，（t约为数十ms），采用抢占式优先权调度算法。根据抢占发生时间的不同可分为两种：\r\n基于时钟的抢占式优先权调度算法：\r\n\r\n在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务。\r\n\r\n立即抢占的优先权调度算法：一旦出现外部中断，只要当前任务未处于临界区，就立即抢占处理机。\r\n\r\n\r\nimage-20250506142129979\r\n\r\n最早截止时间EDF算法：\r\n根据任务的截止时间确定任务的优先级，截止时间越早，优先级越高，最早截止时间的排在队首\r\n非抢占式调度方式用于非周期实时任务：\r\n\r\n在非抢占式 EDF\r\n算法中，一旦一个任务开始执行，它就会一直运行直到完成，不会被其他任务中途抢占。\r\n调度器会在每个任务到达时，根据其截止时间来分配优先级，截止时间越早的任务优先级越高。\r\n在任务执行过程中，即使有更高优先级的任务到达，当前正在执行的任务也不会被打断，而是继续执行直到结束。\r\n\r\n\r\n\r\nimage-20250506142736352\r\n\r\n抢占式调度方式用于周期实时任务：\r\n有两个周期任务A和B，周期时间分别为20ms和50ms，每个周期的处理时间分别为10ms和25ms。\r\n首先判断系统的处理能力：10/20 + 25/50 = 1 —–可行\r\n\r\n\r\nimage-20250506142749061\r\n\r\n最低松弛度优先 LLF 算法\r\n任务紧急程度愈高即松弛程度愈低，赋予该任务的优先级就愈高，以使之优先执行。\r\n该算法主要用于可抢占调度方式。\r\n松弛度 = 完成截止时间 - 还需要的执行时间 -\r\n当前时间。\r\n在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在队列最前面。松弛度是动态变化的，所以优先级也是动态的\r\n任务的抢占时机：当某后到任务的松弛度为0时，即获得最高优先级，立即抢占\r\nCPU。其它时间就算发现后到任务的松弛度比之正在执行任务的松弛度要低但不为0，也不进行抢占。\r\n例子\r\n\r\n\r\nimage-20250506142813148\r\n\r\n优先级倒置\r\n“优先级倒置”现象：高优先级进程被低优先级进程延迟或阻塞。\r\n优先级倒置的解决方法。\r\n1）当进程进入临界区后，CPU就不能被剥夺。\r\n2）优先级继承\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之进程的描述与控制","url":"/posts/35167.html","content":"前驱图和程序执行\r\n前趋图\r\n前趋图(Precedence Graph)\r\n是一个有向无循环图，可记为DAG，用于描述程序/进程之间执行的先后顺序。\r\n\r\n\r\nimage-20250505172730924\r\n\r\n图中每个结点可用来表示一个进程或程序段，结点间的有向边表示两个结点之间存在的偏序或前趋关系\r\n如P1与 P2存在前趋关系，记作P1 -&gt;\r\nP2，表示在P2开始执行之前P1必须完成，此时称P1是P2的直接前趋，P2是P1的直接后继。没有前趋的结点称为初始结点，没有后继的结点称为终止结点，每个结点还有一个重量，用于表示该结点所含有的程序量或程序的执行时间。\r\n注意：前趋图中必须不存在循环\r\n\r\n\r\nimage-20250505172727388\r\n\r\n程序的顺序执行：\r\n在计算机系统中只有一个程序在运行，这个程序独占系统中所有资源，其执行不受外界影响。\r\n一道程序执行完后另一道才能开始\r\n程序顺序执行的特征\r\n\r\n顺序性：处理机的操作严格按照程序所规定的顺序执行。\r\n封闭性：程序一旦开始执行，其计算结果不受外界因素的影响\r\n\r\n-可再现性：程序执行的结果与它的执行速度无关(即与时间无关)，而只与初始条件有关。\r\n程序并发执行的特征\r\n\r\n间断(异步)性：“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；\r\n失去封闭性：共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征。\r\n失去可再现性：失去封闭性 -&gt;\r\n失去可再现性；外界环境在程序的两次执行期间发生变化，失去原有的可重复特征。并发程序执行的结果与其执行的相对速度有关，是不确定的\r\n\r\n进程的描述\r\n进程的定义与特征\r\n进程的引入：为了使多道程序能够并发执行，且为了能对并发执行程序加以描述和控制,以提高资源利用率和系统效率。\r\n进程的定义\r\n\r\n进程是具有独立功能的程序关于某个数据集合在计算机系统中的一次执行过程。是系统进行资源分配和调度的一个单位\r\n系统进行资源分配和调度的、一个可并发执行的独立单位。\r\n进程是程序的一个实例，是程序的一次执行\r\n\r\n进程和程序的比较\r\n\r\n程序是静态的，在外存中，进程是动态的，在内存中\r\n程序可长期保存；而进程是有生命周期的。\r\n程序是指令的有序集合；而进程则是由程序、数据和进程控制块三部分组成。\r\n进程和程序之间不是一一对应的：一个进程可以执行一个或多个程序，一个程序可以同时被多个进程执行。\r\n进程是一个独立运行的单位，也是系统进行资源分配和调度的独立单位，能与其他进程并发执行；而程序不能并发执行。\r\n\r\n进程的特征\r\n\r\n结构特征：由程序段、数据段及进程控制块（PCB）三部分构成，总称“进程映像”。进程控制块(PCB)\r\n+ 程序 + 数据 = 进程实体\r\n动态性：进程的实质是程序的一次执行过程，因而是动态的；进程具有生命周期。\r\n并发性：多个进程可以并发地执行。\r\n独立性：独立运行，独立获得资源。\r\n异步性：间断性。\r\n\r\n进程的基本状态与转换\r\n三种基本状态及其转换\r\n一个进程从创建、运行至消亡的整个生命周期，可以用一组状态加以刻画。\r\n一般来说,进程在执行过程中至少经历三种不同的进程状态：\r\n运行态（running）：占有处理机正在运行。\r\n就绪态（ready）：具备运行条件，等待系统分配处理机以便运行。\r\n阻塞态（blocked）：不具备运行条件，正在等待某个事件的发生\r\n三种基本状态的转换\r\n\r\n\r\nimage-20250505173410831\r\n\r\n创建状态和终止状态\r\n创建状态:\r\n\r\n为一个新进程创建PCB，并填写必要的管理信息；\r\n分配必要的资源，再把该进程转入就绪状态并插入就绪队列\r\n\r\n终止状态：\r\n\r\n等待操作系统进行善后处理；\r\n将其PCB清零，并将PCB空间返回系统\r\n\r\n挂起操作和进程状态的转换\r\n当该操作作用于某个进程时，该进程将被挂起，这意味这此时进程处于静止状态。\r\n挂起操作的引入：\r\n\r\n终端用户的请求\r\n父进程请求\r\n负荷调节的需要\r\n操作系统的需要\r\n\r\n\r\n\r\nimage-20250505173530843\r\n\r\n若原本处于就绪状态，则挂起后不接受调度\r\n阻塞变就绪需要释放资源，反过来就是请求资源\r\n静止变活动需要激活，反之就是挂起\r\n进程管理中的数据结构\r\nOS中用于管理资源和控制进程的数据结构\r\nOS管理的这些控制表一般可以分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，进程表又称为PCB。\r\nPCB的作用\r\nPCB的作用：\r\n​\r\n为了便于系统描述和管理进程的运行，在os的核心位每个进程定义了一个数据结构—PCB作为进程实体的一部分\r\n​\r\nPCB记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息\r\nPCB的作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位\r\n\r\n作为独立运行基本单位的标志。\r\n当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位了，即具有了取得OS服务的权利。\r\n系统是通过PCB来感知进程的存在的。也就是说，PCB已成为进程存在于系统中的唯一标志。\r\n实现间断性运行方式。\r\n系统就可以将CPU现场信息保存在被中断进程的PCB中，供该进程再次被调度运行而须恢复CPU现场信息时使用。\r\n提供进程管理所需要的信息。\r\n在进程的整个生命期中，OS总是根据PCB来实施对进程的控制和管理的\r\n提供进程调度所需要的信息。\r\n实现与其他进程的同步与通信。\r\n\r\nPCB中的信息\r\nPCB中的信息：\r\n\r\n进程标识符PID\r\n进程标识符用于唯一地标志一个进程。一个进程通常有两种标识符。\r\n\r\n\r\n外部标识符。为了方便用户（进程）对进程的访问\r\n内部标识符。为了方便系统对进程的使用\r\n\r\n\r\n处理机状态\r\n处理机状态信息，也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。\r\n\r\n\r\n通用寄存器，可被用户程序访问，用于暂存信息\r\n指令计数器，其中存放了要访问的下一条指令的地址；\r\n程序状态字寄存器，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；\r\n用户栈指针寄存器，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放进程和系统的调用参数及调用地址。\r\n\r\n\r\n进程调度信息\r\nOS在进行进程调度时，必须了解进程的状态以及有关进程调度的信息，这些信息包括：\r\n\r\n\r\n进程状态，指明进程的当前状态，作为进程调度和对换时的依据；\r\n进程优先级，描述进程使用处理机的优先级别（用一个整数表示），优先级高的进程应优先获得处理机；\r\n进程调度所需要的其他信息，如进程已等待CPU的时间总和、进程已执行时间总和等，它们与所采用的进程调度算法有关；\r\n事件，指进程由执行状态转换为阻塞状态所等待发生的事件，即阻塞原因。\r\n\r\n\r\n进程控制信息\r\n进程控制信息是指用于进程控制所必需的信息，包括：\r\n\r\n\r\n程序和数据的地址，即进程中程序和数据的内存或外存起始地址，便于再调度到该进程执行时，能从PCB中快速找到其程序和数据；\r\n进程同步和通信机制，这是实现进程同步和进程通信时所必需的机制，如消息队列指针、信号量等，它们可能会全部或部分放在PCB中；\r\n资源清单，在该清单中列出了进程在运行期间所需的全部资源（除CPU外）；\r\n链接指针，它给出了本进程所在队列中的下一个进程的PCB的始址。\r\n\r\nPCB的组成方式\r\n\r\n线性方式。将系统中所有的PCB都组织在一张线性表中，将该表的起始地址存放在内存的一个专用区域中。该方式实现简单且开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。\r\n链接方式。通过PCB中的链接字，将具有相同状态的进程的PCB分别链接成一个队列。\r\n索引方式。系统根据所有进程状态的不同，建立几张索引表，如就绪索引表、阻塞索引表等，并把各索引表在内存中的起始地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。\r\n\r\n进程控制\r\n进程控制是进程管理中最基本的功能，其负责创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、转换运行中进程的状态等，进程控制就是要实现进程状态转换\r\n进程控制一般是由OS内核中的原语（原子性操作，一旦开始不能停止）实现的\r\nOS内核主要功能\r\nOS内核：\r\n\r\n支撑功能\r\n\r\n中断处理：最基本功能\r\n时钟管理：\r\n原语操作\r\n\r\n资源管理功能\r\n\r\n进程的创建\r\n进程的层次结构：\r\n在OS中，允许一个进程创建另一个进程，子进程可以继续创建其自己的子进程（即父进程的孙进程），由此便形成了进程的层次结构\r\n引起进程创建的事件\r\n\r\n用户登录：在分时系统中，若登录成功，则系统将会为该用户创建一个进程，并把它插入就绪队列中。\r\n作业调度：在多道批处理系统中，当作业调度程序按一定的算法调度到某个（或某些）作业时，便会将它（们）装入内存、为它（们）创建进程，并把它（们）插入就绪队列中。\r\n提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来为用户提供其所需要的服务\r\n应用请求：由用户进程自己创建新进程，以使新进程以同创建进程并发执行的方式完成特定任务。\r\n\r\n操作系统发现要求创建新进程的事件后，调用进程创建原语Creat()创建新进程。\r\n进程的创建过程：\r\n申请空白PCB 为新进程分配资源 初始化进程控制块\r\n将新进程插入就绪队列\r\n进程的终止\r\n引起进程终止的事件\r\n（1）正常结束\r\n（2）异常结束\r\n（3）外界干预\r\n终止过程：\r\n①PCB集合中检索出该进程的PCB：并从该进程的PCB中读出该进程的状态\r\n②若被终止进程正处于执行状态，立即剥夺CPU\r\n③终止其所有子孙进程：以防止它们成为不可控的进程；\r\n④将被终止的进程所拥有的全部资源，或归还给其父进程，或归还给系统；\r\n⑤将被终止进程的PCB从所在队列（或链表）中移出：等待其他程序来搜集信息\r\n进程的阻塞与唤醒\r\n引起进程阻塞与唤醒的事件\r\n\r\n向系统请求共享资源失败\r\n等待某种操作的完成\r\n新数据尚未到达\r\n等待新任务的到达\r\n\r\n阻塞过程：\r\n\r\n调用阻塞原语block阻塞自己；\r\n将PCB中的状态改为阻塞，并加入阻塞队列；\r\n转调度程序进行重新调度\r\n\r\n进程的唤醒：\r\n\r\n调用wakeup原语唤醒等待该事件的进程\r\n阻塞进程从等待该事件的阻塞队列中移出；\r\n置进程状态为就绪态，将PCB插入到就绪队列中\r\n\r\n进程的挂起与激活\r\n进程的挂起过程：\r\n当出现引起进程挂起的事件时，系统利用挂起原语suspend将指定进程或处于阻塞的进程挂起。\r\n先检查被挂起进程的状态：\r\n\r\n若处于活动就绪，则改为静止就绪\r\n若处于活动阻塞，则改为静止阻塞；\r\n若挂起的进程正在执行，则重新进行进程调度\r\n\r\n进程的激活过程：\r\n\r\n当发生激活进程的事件时，系统利用激活原语active将指定进程激活\r\n激活原语先将进程从外存调入内存；\r\n然后检查该进程的状态：\r\n\r\n若为静止就绪，则改为活动就绪；\r\n若处于静止阻塞，则改为活动阻塞\r\n\r\n\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之进程同步","url":"/posts/17351.html","content":"进程同步\r\n进程同步机制\r\n进程同步机制：利用他们保证程序执行的可再现性\r\n进程同步的基本概念：某进程未获得合作进程发来的消息之前应该进程等待，消息到来之后方可继续合作关系\r\n进程间两种形式的制约关系\r\n\r\n间接相互制约关系 — 源于资源共享\r\n直接相互制约关系 — 源于进程合作\r\n\r\n临界资源：互斥访问\r\n进程间采取互斥方式，实现对资源的共享\r\n生产者消费者问题：\r\n生产者进程和消费者进程都以异步方式运行，但它们之间必须保持同步。\r\n把一次仅允许一个进程访问的资源叫做临界资源\r\n临界区\r\n每个进程中访问临界资源的那段代码\r\n对欲访问的临界资源进行检查\r\n\r\n若此刻未被访问，设正在访问的标志 ……进入区\r\n访问临界资源 ……临界区\r\n将正在访问的标志恢复为未被访问的标志 ……退出区\r\n其余部分 ……剩余区\r\n\r\n进程互斥：两进程不能同时进入访问同一临界资源的临界区\r\n同步机制应遵循的规则\r\n\r\n空闲让进\r\n忙则等待\r\n有限等待\r\n让权等待\r\n\r\n信号量机制\r\n整型信号量\r\n定义：整型量，除初始化外，仅能通过两个原子操作来访问\r\n\r\nP操作 wait(S):\r\n​ While (S&lt;=0) do no-op;\r\n​ S–;\r\nV操作 signal(S):\r\n​ S++;\r\nP、V操作是原子操作，不可中断。\r\n\r\n\r\n\r\nimage-20250505180943586\r\n\r\n记录型信号量\r\n引入整型变量value(代表资源数目)、进程链表List (链接所有等待进程)\r\n用S.value的初值表示系统中某种资源的数目。\r\n记录型数据结构：\r\ntypedef  struct&#123;\t              int value;\t              struct process_control_block * list;\t       &#125; semaphore;\r\n对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此S.value–，表示资源数减1，当S.value＜0时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞，主动放弃处理机，并插入该类资源的等待队列S.L中。\r\n对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行\r\nS.value++，表示该资源数加1，若加1后仍是\r\nS.value≤0，表示依然有进程在等待该类资源，因此应调用wakeup原语幻想等待队列中的第一个进程。\r\n信号量&gt;0，代表可用资源的数量\r\n信号量&lt;0，代表由于申请信号量，代表的资源而阻塞的进程数量\r\n遵循了“让权等待”原则，不会出现“忙等”现象\r\n\r\n\r\nimage-20250505181419736\r\n\r\nAND型信号量\r\nADN型信号量主要针对的是一个进程需要获取两个或更多的共享资源执行任务时的问题。\r\n基本思想：对若干个临界资源的分配采取原子操作的方式\r\n\r\n要么把它所请求的资源全部分配到进程，要么一个也不分配。为此，在wait中加入了一个“AND”条件，故称为AND同步，或称为同时wait操作，即\r\nSwait\r\n\r\n\r\n\r\nimage-20250505181219188\r\n\r\n信号量集\r\n信号量集主要针对的是执行进程时一次需要N个单位的某类临界资源的问题\r\n对AND型信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源量需求，在一次P、V原语操作中完成申请或释放。\r\n进程对信号量Si的测试值不再是1，而是该资源的分配下限ti，即要求Si&gt;=ti。一旦允许分配，进程对该资源的需求值为di，即表示资源占用量，进行Si:=Si-di的操作，对应的Swait和Ssignal格式为：\r\n\r\nSwait(S1,t1,d1,...,Sn,tn,dn);\r\nSsignal(S1,d1,...,Sn,dn);\r\n\r\nSwait(S,d,d)：此时信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数量少于d时，不予分配。\r\nSwait(S,1,1)：此时信号量集已蜕化为一般的记录型信号量（S&gt;1时）或互斥信号量（S=1）。\r\nSwait(S,1,0)：当S&gt;=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区，相当于一个可控开关。\r\n信号量的应用\r\n\r\n\r\nimage-20250505181502608\r\n\r\n实现进程互斥：\r\n设置mutex为互斥信号量，初值为1，取值范围为（-1,0，1）。\r\n\r\n当mutex = 1 时，表示两个进程皆未进入互斥的临界区\r\n当mutex = 0\r\n时，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列\r\n当mutex = -1\r\n时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。\r\n\r\nwait(mutex)和signal(mutex)操作必须成对出现，缺少P（mutex）将会导致系统混乱，不能保证对临界资源的访问，缺少V（mutex）将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程永远不能被唤醒。\r\n\r\n信号量机制实现前驱关系\r\n每一对前驱关系都是一个进程同步问题\r\n\r\n要为每一对前驱关系各设置一个同步变量\r\n在“前操作”之后对相应的同步变量执行V操作\r\n在“后操作”之前对相应的同步变量执行P操作\r\n\r\n例如：\r\n实现S1执行后执行S2\r\n进程P1：S1； signal（S）； (S为P1,P2共用的信号量)\r\n进行P2：wait(S); S2；\r\n信号量机制实现同步关系：\r\np1，p2两进程因合作完成一项任务而共用一个变量x。进程p2将处理结果送入x；进程p1将x的结果打印。\r\n\r\n\r\nimage-20250505181649390\r\n\r\n经典的进程同步问题\r\n生产者消费者问题\r\n相互合作关系的一种抽象\r\n问题描述：\r\n一组生产者进程和一组消费者进程共享一个初始为空、大小为 n\r\n的缓冲区，只有缓冲区没满时，生产者才把消息放入缓冲区，否则必须等待；\r\n只有缓冲区不空时，消费者才能从中读取消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。\r\n\r\n\r\nimage-20250505181909726\r\n\r\n可利用记录型信号量解决生产者—消费者问题：\r\n\r\n可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用，初值为1；\r\n信号量 full 用于记录当前缓冲池中的“满”缓冲区数，初值为 0；\r\n信号量 empty 用于记录当前缓冲池中“空”的缓冲区数，初值为 n；\r\n\r\n描述如下：\r\n\r\n\r\nimage-20250505181941754\r\n\r\n加锁信号量的顺序不能打乱，否则容易出现死锁，也就是P(mutex)需要跟在P(full);前面\r\n利用AND信号量解决生产者—消费者问题：\r\n使用Swait(empty,mutex)代替wait(empty)，wait(mutex)，Ssignal(empty,mutex)代替signal(empty)，signal(mutex)\r\nfull和mutex也是一样\r\n\r\n\r\nimage-20250505182155964\r\n\r\n\r\n\r\nimage-20250505182159102\r\n\r\n例题：\r\n描述：\r\n桌子上有一个盘子，每次只能向其中放入一个水果。\r\n爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专吃盘子中的橘子，女儿专等吃盘子中的苹果。\r\n只有盘子为空时，爸爸或妈妈才可以向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。\r\n分析：\r\n爸爸和妈妈是互斥关系，爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行。\r\n信号量 plate 表示互斥信号量，用于确定是否可以往盘子中放水果，初值为 1\r\n表示允许放入一个；\r\n信号量 apple 表示盘中是否还有苹果，初值为 0表示没有不许取；orange\r\n表示盘中是否有橘子，初值同样为 0，orange=1 表示盘子中由橘子允许取\r\n\r\n\r\nimage-20250505182232376\r\n\r\n哲学家进餐问题\r\n问题描述：\r\n一张圆桌上坐着5名哲学家，每两名哲学家之间的桌子上摆着一根筷子，两根筷子之间是一碗米饭。\r\n哲学家倾注毕生精力于思考和进餐，哲学家思考时不影响其他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子——一根一根地拿起。\r\n若筷子已在他人手上，则需要等待。饥饿地哲学家只有同时拿到了两根筷子才能开始进餐，进餐完毕，放下筷子继续思考\r\n分析：\r\n5 名哲学家与左右邻座对其中间的筷子的访问时互斥关系。\r\n显而易见，5 个哲学家对应5\r\n个进程，问题解决的关键就是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象\r\n解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。\r\n信号量设置：互斥信号量数组 chopstick[5]={1,1,1,1,1}，用于对 5\r\n个筷子的互斥访问；哲学家编号顺序：0~4，哲学家 I 左边筷子的编号为\r\ni，哲学家右边筷子的编号为(i+1)%5。\r\n使用记录型信号量：\r\n\r\n\r\nimage-20250505182332395\r\n\r\n使用AND信号量\r\n\r\n\r\nimage-20250505182358757\r\n\r\nbasicSwait(chopstick[(i+1) % 5], chopstick[i]);EatSginal(chopstick[(i+1) % 5], chopstick[i]);\r\n读者写者问题\r\n问题描述与分析\r\n一个数据文件或记录可被多个进程共享。\r\n只要求读文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，但不允许一个Writer进程和其他Reader进程或Writer进程同时访问共享对象\r\n“读者——写者问题”是保证一个 Writer\r\n进程必须与其他进程互斥地访问共享对象的同步问题。\r\n\r\n\r\nimage-20250505182701688\r\n\r\n互斥信号量wmutex: 实现 Reader 与 Writer\r\n进程间在读或写时的互斥\r\n整型变量Readcount：表示正在读的进程数目;\r\n以Readcount为例：\r\n由于只要有一个 Reader 进程在读，便不允许 Writer 进程写。\r\n∴仅当Readcount=0，即无 Reader 进程在读时，Reader\r\n才需要执行Wait(wmutex)操作。若Wait(wmutex)操作成功，Reader\r\n进程便可去读，相应地，做Readcount+1操作。\r\n使用记录型信号量解决读者写者问题\r\n\r\n\r\nimage-20250505182748649\r\n\r\n\r\n\r\nimage-20250505182808622\r\n\r\n使用信号量集机制解决读者写者问题\r\n\r\n\r\nimage-20250505182825856\r\n\r\nSwait(mx, 1, 1; L, RN,\r\n0)语句表示仅当既无writer进程在写(mx=1)，又无reader进程在读(L=RN)，writer进程才能进入临界区写。\r\nSwait(mx, 1,\r\n0)语句起着开关的作用。只要无writer进程进入写，mx=1，reader进程就都可以进入读。但只要一旦有writer进程进入写时，mx=0，则任何reader进程就都无法进入读。\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"数据库相关概念与DBMS特色","url":"/posts/42089.html","content":"\r\n数据库相关概念\r\n数据管理\r\n\r\n\r\nimage-20250512195115041\r\n\r\n数据：能够被记录且具有实际含义的已知事实\r\n大数据\r\n元数据：描述数据的数据\r\n数据库管理系统 DBMS\r\n\r\n\r\nimage-20250512195253000\r\n\r\n数据库与文件系统的对比：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n文件系统\r\n数据库\r\n\r\n\r\n\r\n\r\n定义\r\n管理存储磁盘上数据的存储、访问和管理方式的过程\r\n可以轻松存储、访问、管理和更新的有组织的数据集合\r\n\r\n\r\n数据一致性\r\n数据不一致性高\r\n维护数据一致性\r\n\r\n\r\n结构\r\n简单\r\n复杂\r\n\r\n\r\n数据共享\r\n困难\r\n容易\r\n\r\n\r\n冗余\r\n冗余度高\r\n冗余度低\r\n\r\n\r\n安全性\r\n不是很安全\r\n更加安全\r\n\r\n\r\n备份与恢复\r\n没有备份和恢复过程\r\n有备份恢复过程\r\n\r\n\r\n\r\n数据库系统 DBS\r\n数据库系统是高效组织和管理数据的系统，由数据库、数据库管理系统和应用程序三部分构成。\r\n\r\n应用程序：应用程序提供了用户与数据库系统的交互界面。\r\n数据库管理系统：DBMS\r\n是一种通用的系统软件，可促进各种用户和应用程序之间数据库的组织、存储、控制和维护。\r\n数据库：数据库是一组经过组织、共享和持久化的相关数据。\r\n\r\nDBMS特色\r\nDBMS特色—数据独立性\r\n数据模型：数据模型是完成数据抽象的工具，即，用来描述数据、数据联系、数据语义以及一致性约束的一套概念工具。\r\n\r\n模型：模型是对研究对象进行抽象的工具，抽象的结果通常是可视化的图形。\r\n建模：建模是对研究对象进行抽象的过程。抽象就是对事物进行简化、提取特征或共性，实现模型和事物之间的映射或投影，等操作\r\n\r\n数据库设计过程：概念设计 逻辑设计 物理设计\r\n数据模型分类：\r\n\r\n概念模型：E-R 模型，UML 类模型\r\n逻辑模型：\r\n物理模型：Heap File 模型，ISAM 模型\r\n\r\n模式：模式是数据的定义和描述\r\n实例：实例则是模式在某一时刻的具体数据\r\n\r\n模式是元数据\r\n数据是变化的，模式是不变的\r\n数据库设计，数据库建模，实体 - &gt;模式\r\n数据库使用，创建数据库，模式 -&gt; 元组\r\n模式的层次，属性模式?:关系模式，数据库模式\r\n模式= 类型 + 约束 + 联系\r\n\r\n关系型数据库 ( SQL )\r\n\r\nMySQL , Oracle , SQL Server , SQLite , DB2 , …\r\n关系型数据库以表格形式组织数据，通过行和列存储信息，并且利用外键关联来建立表与表之间的关系。这种结构化的数据存储方式使得数据的查询、更新和管理变得高效且有组织。\r\n常见的关系型数据库有 MySQL、Oracle、SQL Server、SQLite、DB2 等\r\n\r\n非关系型数据库 ( NOSQL ) not only\r\n\r\nRedis , MongoDB , …\r\n非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定\r\n与关系型数据库的对比\r\n\r\n数据模型：关系型数据库采用表格形式，非关系型数据库有键值对、文档、列族、图等多种数据模型。\r\n扩展性：非关系型数据库更容易进行水平扩展，适合处理海量数据和高并发场景。\r\n一致性：关系型数据库强调强一致性，非关系型数据库通常采用最终一致性，以换取更高的性能和可扩展性。\r\n\r\n\r\nDBMS特色——数据库语言\r\n编程语言：SQL\r\n\r\nSQL的分类：\r\n\r\nDDL：数据定义语言 定义了不同的数据库，表，视图，索引等数据库对象\r\n还可以创建修改删除等操作数据库表的结构 CREATE  ALTER  DROP  RENAME\r\n TRUMCATE\r\nDML：数据操作语言 增删改查数据库记录 INSERT  DELETE  UPDATE\r\n SELECT\r\nDCL：数据控制语言 定义数据库，表，字段，用户访问权限和安全级别的\r\nCOMMIT  ROLLBACK  SAVEPOINT\r\nDQL：数据库查询语言 查询数据库中表的记录\r\n\r\n\r\n数学语言：关系代数\r\n\r\n关系的描述称为关系模式。它可以形式化地表示为\r\nR = (A, D, DOM, F)\r\n其中：\r\nR 为关系名\r\nA 为组成该关系的属性名集合\r\nD 为 A 中属性所来自的域\r\nDOM 为属性向域的映像集合\r\nF 为属性间数据的依赖关系集合\r\n关系代数的作用：\r\n\r\n为关系数据模型提供了操作的形式化语言\r\n\r\n能够用来做查询优化\r\n\r\n关系代数的运算和思想已经融入 SQL\r\n关系代数运算是评价 RDBMS 软件是否完备的标准\r\n关系代数明确的给出了查询的执行过程\r\n关系代数通常作为 DBMS 查询的内部实现\r\n\r\n\r\n设计语言：E - R图\r\n关系型数据库模式的评估：数据库的规范性设计需要分析关系中的属性在取值方面有什么依存关系?数据库设计过程中应遵循什么样的原则\r\n数据库设计理论\r\n\r\n数据依赖理论\r\n关系范式理论\r\n模式分解理论\r\n\r\n数据依赖：数据之间存在的各种联系和约束\r\n\r\n\r\nimage-20250512204835354\r\n\r\n\r\n定义：设 R(U) 是属性集 U 上的关系模式，X⊆U, Y⊆U。对于 R(U)\r\n的任意关系实例中的任意两个元组 t1 和 t2，如果由 t1[X] = t2[X] 可 以推出\r\nt1[Y]= t2[Y]，则称 X 函数决定 Y，或 Y 函数依赖于 X，记作 X→Y。\r\n关系模式 SDC(Sno, Sname, Sdept, Sdean, Cno, Grade)\r\n中的函数依赖：\r\n\r\nSno → Sname：一个学号只对应一个学生姓名\r\nSno → Sdept：一名学生只属于一个系\r\nSdept → Sdean：一个系只有一名系主任\r\nSno → Sdean：一名学生只对应一名系主任\r\n(Sno, Cno) → Grade：一名学生学习一门课程只有一个成绩\r\n\r\n函数依赖的关系：\r\n\r\n部分函数依赖：在关系模式 R(U) 中，如果 X → Y，且存在 X’ÌX，使得 X’ →\r\nY，则称 Y 部分函数依赖于 X，记作 X → Y\r\n\r\nØ传递函数依赖：在关系模式 R(U) 中，如果 X → Y，Y → Z，且 Y⊆X，Y →\r\nX，则称 Z 传递函数依赖于 X，记作 X → Z\r\n\r\n关系模式的范式：\r\n\r\n范式：在关系数据库规范化理论中，根据关系模式的规范化程度不同，把关系模式划分为若干类，称作范式（normal\r\nform）\r\n范式的级别：\r\n\r\n\r\nimage-20250512203705344\r\n\r\n在函数依赖的范畴内，我们只讨论 1NF、2NF、3NF\r\n\r\n第一范式：如果关系模式 R 的每个属性都是不可分的，则称 R\r\n为第一范式关系模式，记作R∈1NF\r\n第二范式：如果关系模式 R∈1NF，且 R 的每个非主属性都完全函数依赖于 R\r\n的候选键，则称 R 为第二范式关系模式，记作 R∈2NF\r\n\r\n关系模式出现问题解决方法：消除非主属性对候选键的部分函数依赖\r\n\r\n第三范式：如果关系模式 R∈2NF，且 R 的每个非主属性都不传递函数依赖于\r\nR 的候选键，则称 R 为第三范式关系模式，记作 R∈3NF\r\n\r\n关系模式出现问题解决方法：消除非主属性对候选键的传递函数依赖\r\n\r\n\r\n\r\n设计语言：E - R图\r\nE-R模型：\r\n实体-联系模型中主要有三个概念：实体集，属性，联系集\r\n一个实体集对应数据库中的一个表，一个实体则对应数据库表中的一行，一个属性对应数据表中的一列\r\n实体 - 联系模型（E - R\r\n模型）是一种用于数据库设计的概念模型，主要有三个核心概念：实体集、属性和联系集。\r\n\r\n实体集：对应数据库中的一个表，代表一类具有相同属性的实体。例如，在一个学校管理系统中，“学生”\r\n是一个实体集，它包含了所有学生的信息。\r\n属性：对应数据表中的一列，用于描述实体的特征。对于\r\n“学生” 实体集，“学号”、“姓名”、“年龄” 等都是属性。\r\n联系集：表示实体集之间的关系。例如，“学生”\r\n实体集和 “课程” 实体集之间存在 “选课” 联系。\r\n\r\nE-R图：\r\n\r\n实体-联系模型：是概念数据库设计阶段使用的一种重要模型，用于将现实世界抽象为实体及实体间的联系\r\nE-R 模型提供了数据建模所需的多种概念\r\n\r\n与实体（entity）相关的概念：\r\n\r\n实体 属性 键 实体型 实体集 弱实体型\r\n实体：数据库中表示的现实世界中的具体对象或事物\r\n属性：用于刻画实体的特性\r\n\r\n简单属性：具有原子属性值的属性，其属性值不可再分\r\n复合属性：由多个成分构成的属性\r\n多值属性：一个实体可具有多个值的属性\r\n派生属性：由其他属性派生出来的属性\r\n键属性：同一实体型的任意实体都具有不同值的属性\r\n复合属性和多值属性可以是相互嵌套的\r\n\r\n\r\n与联系（relationship）相关的概念\r\n\r\n联系：一个联系表示多个实体之间有意义的关联关系\r\n联系型：同一类联系共同具有的类型\r\n联系 联系型 联系集 联系型的约束 联系型的属性 多元联系\r\n\r\n\r\n实体型的 E-R 图表示：\r\n\r\n实体型表示为矩形\r\n属性表示为椭圆\r\n\r\n简单属性表示为实线椭圆\r\n多值属性表示为双实线椭圆\r\n派生属性表示为虚线椭圆\r\n键属性的属性名加下划线\r\n\r\n实体型与其属性用线连接起来\r\n\r\n\r\n\r\nimage-20250512201853388\r\n\r\n联系型的 E-R 图表示：\r\n\r\n联系型表示为菱形\r\n\r\n\r\nimage-20250512201842310\r\n\r\n联系型可以具有属性\r\n用直线将联系型与参与到联系型中的实体型连接起来\r\n在 E-R 图中，用直线将联系型与联系型的属性连接起来\r\n\r\n\r\nimage-20250512202121852\r\n\r\n多对一举例：\r\n\r\n\r\nimage-20250512201940249\r\n\r\n多对多举例：\r\n\r\n\r\nimage-20250512201959282\r\n\r\n\r\n实体型的转换：\r\n\r\n转换规则\r\n实体型的名称 → 关系名\r\n实体型的属性集 → 关系的属性集（多值属性除外）\r\n实体型的主键 → 关系的主键\r\n实体 → 元组\r\n\r\n\r\nimage-20250512202417693\r\n\r\nM-N二元联系型的转换：\r\n转换规则：为联系型创建一个新的关系模式\r\n​ 关系模式的属性集包括：与该联系相关的两个实体型的主键（如图中\r\nemployee 的主键 SSN 和 project\r\n的主键 Number ） ，以及联系型本身的属性（图中\r\nworks_on 联系型的属性 Hours ）。\r\n​ 新关系模式的主键由两个实体型的主键组合而成（图中\r\nworks_on 关系模式的主键为 SSN 和\r\nNumber\r\n\r\n\r\nimage-20250512202844414\r\n\r\n\r\n\r\nimg\r\n\r\n1:1 二元联系型的转换\r\n\r\n\r\nimage-20250512203251603\r\n\r\n\r\n\r\nimage-20250512204048887\r\n\r\nN:1 二元联系型的转换\r\n\r\n\r\nimage-20250512203008930\r\n\r\n\r\n\r\nimage-20250512204227234\r\n\r\n\r\n\r\n关系数据模型\r\n关系模型三要素：\r\n\r\n关系数据结构\r\n完整性约束\r\n关系操作\r\n\r\n\r\n\r\nimage-20250512205709773\r\n\r\n\r\n\r\nimage-20250512205715465\r\n\r\n码：关系中某些属性集合具有区分不同元组的作用，称为码\r\n\r\n超码：如果关系的某一组属性的值能唯一标识每个元组，则称该组属性为超码（super\r\nkey）。\r\n候选码：如果一个超码的任意真子集都不是超码，则称该超码为候选码。候选码是极小的超码。\r\n主键：每个关系都有至少一个候选码，人为指定其中一个作为主键\r\n外码：设 F 是关系 R 的属性子集。若 F 与关系 S 的主键 K\r\n相对应，则称 F 是 R 的外键（foreign key）。\r\n\r\nDBMS特色——事务处理\r\n事务是一组操作的组合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销，这些操作要么同时成功要么同时失败\r\n事务四大特性：\r\n\r\n原子性A：事务是不可分割的最小操作单元，要么全成功，要么全失败\r\n一致性C：事务完成时，必须所有数据都保持一致状态\r\n隔离性I：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下进行\r\n持久性D：事务一旦提交或回滚，他对数据库的改变是永久的\r\n\r\n","categories":["计算机理论","数据库理论"],"tags":["数据库","学习类","计算机理论知识","计算机理论技术"]},{"title":"正确使用Markdown语法进行排版的示例","url":"/posts/1878.html","content":"教程\r\n这是一篇讲解如何正确使用 Markdown\r\n的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。\r\n\r\n引用文本：Markdown is a text formatting syntax.\r\n\r\n语法指导\r\n普通内容\r\n这段内容展示了在内容里面一些排版格式，比如：\r\n\r\n加粗 - **加粗**\r\n倾斜 - *倾斜*\r\n删除线 - ~~删除线~~\r\nCode 标记 - `Code 标记`\r\n超级链接 -\r\n[超级链接](https://lddgo.net)\r\nusername@gmail.com -\r\n[username@gmail.com](mailto:username@gmail.com)\r\n\r\n大标题 - Heading 3\r\n你可以选择使用 H1 至 H6，使用 ##(N) 打头。\r\n\r\nNOTE: 别忘了 # 后面需要有空格！\r\n\r\nHeading 4\r\nHeading 5\r\nHeading 6\r\n图片\r\n![alt 文本](http://image-path.png)![alt 文本](http://image-path.png &quot;图片 Title 值&quot;)\r\n代码块\r\n普通\r\n*emphasize*    **strong**_emphasize_    __strong__var a = 1\r\n语法高亮支持\r\n如果在 ``` 后面跟随语言名称，可以有语法高亮的效果哦，比如:\r\n演示 Go 代码高亮\r\npackage mainimport &quot;fmt&quot;func main() &#123;\tfmt.Println(&quot;Hello, 世界&quot;)&#125;\r\n演示 Java 高亮\r\npublic class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;\r\n\r\nTip: 语言名称支持下面这些: ruby, python,\r\njs, html, erb, css,\r\ncoffee, bash, json,\r\nyml, xml …\r\n\r\n有序、无序、任务列表\r\n无序列表\r\n\r\nJava\r\n\r\nSpring\r\n\r\nIoC\r\nAOP\r\n\r\n\r\nGo\r\n\r\ngofmt\r\nWide\r\n\r\nNode.js\r\n\r\nKoa\r\nExpress\r\n\r\n\r\n有序列表\r\n\r\nNode.js\r\n\r\nExpress\r\nKoa\r\nSails\r\n\r\nGo\r\n\r\ngofmt\r\nWide\r\n\r\nJava\r\n\r\nLatke\r\nIDEA\r\n\r\n\r\n任务列表\r\n\r\n发布 Sym\r\n发布 Solo\r\n预约牙医\r\n\r\n表格\r\n如果需要展示数据什么的，可以选择使用表格。\r\n\r\n\r\n\r\nheader 1\r\nheader 2\r\n\r\n\r\n\r\n\r\ncell 1\r\ncell 2\r\n\r\n\r\ncell 3\r\ncell 4\r\n\r\n\r\ncell 5\r\ncell 6\r\n\r\n\r\n\r\n隐藏细节\r\n\r\n\r\n这里是摘要部分。\r\n\r\n这里是细节部分。\r\n\r\n段落\r\n空行可以将内容进行分段，便于阅读。（这是第一段）\r\n使用空行在 Markdown 排版中相当重要。（这是第二段）\r\n链接引用\r\n链接文本\r\nLDDGO.NET\r\n[链接文本](链接地址)\r\n数学公式\r\n多行公式块：\r\n$$\r\n\\frac{1}{\r\n  \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\r\n  \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {\r\n    1+\\frac{e^{-6\\pi}}\r\n    {1+\\frac{e^{-8\\pi}}{1+\\cdots}}\r\n  }\r\n}\r\n$$\r\n行内公式：\r\n公式 a2 + b2 = colorredc2\r\n是行内。\r\n脑图\r\n- 教程- 语法指导  - 普通内容  - 大标题 - Heading 3    - Heading 4      - Heading 5        - Heading 6  - 图片  - 代码块    - 普通    - 语法高亮支持      - 演示 Go 代码高亮      - 演示 Java 高亮  - 有序、无序、任务列表    - 无序列表    - 有序列表    - 任务列表  - 表格  - 隐藏细节  - 段落  - 链接引用  - 数学公式  - 脑图  - 流程图  - 时序图  - 甘特图  - 图表  - 五线谱  - Graphviz  - 脚注\r\n流程图\r\ngraph TB\n    c1--&gt;a2\n    subgraph one\n    a1--&gt;a2\n    end\n    subgraph two\n    b1--&gt;b2\n    end\n    subgraph three\n    c1--&gt;c2\n    end\r\n时序图\r\nsequenceDiagram\n    Alice-&gt;&gt;John: Hello John, how are you?\n    loop Every minute\n        John--&gt;&gt;Alice: Great!\n    end\r\n甘特图\r\ngantt\n    title A Gantt Diagram\n    dateFormat  YYYY-MM-DD\n    section Section\n    A task           :a1, 2019-01-01, 30d\n    Another task     :after a1  , 20d\n    section Another\n    Task in sec      :2019-01-12  , 12d\n    another task      : 24d\r\n状态图\r\nstateDiagram\n    [*] --&gt; s1\n    s1 --&gt; [*]\r\n类图\r\n语法解释：&lt;|-- 表示继承，+ 表示\r\npublic，- 表示 private，学过 Java\r\n的应该都知道。\r\nclassDiagram\n      Animal &lt;|-- Duck\n      Animal &lt;|-- Fish\n      Animal &lt;|-- Zebra\n      Animal : +int age\n      Animal : +String gender\n      Animal: +isMammal()\n      Animal: +mate()\n      class Duck&#123;\n          +String beakColor\n          +swim()\n          +quack()\n      &#125;\n      class Fish&#123;\n          -int sizeInFeet\n          -canEat()\n      &#125;\n      class Zebra&#123;\n          +bool is_wild\n          +run()\n      &#125;\r\n饼图\r\n饼图使用 pie\r\n表示，标题下面分别是区域名称及其百分比。\r\npie\n    title Key elements in Product X\n    &quot;Calcium&quot; : 42.96\n    &quot;Potassium&quot; : 50.05\n    &quot;Magnesium&quot; : 10.01\n    &quot;Iron&quot; :  5\r\n\r\n以下的需要特定方法才能解析，typora和大部分markdown编辑器不能解析\r\n图表\r\n&#123;  &quot;title&quot;: &#123; &quot;text&quot;: &quot;最近 30 天&quot; &#125;,  &quot;tooltip&quot;: &#123; &quot;trigger&quot;: &quot;axis&quot;, &quot;axisPointer&quot;: &#123; &quot;lineStyle&quot;: &#123; &quot;width&quot;: 0 &#125; &#125; &#125;,  &quot;legend&quot;: &#123; &quot;data&quot;: [&quot;帖子&quot;, &quot;用户&quot;, &quot;回帖&quot;] &#125;,  &quot;xAxis&quot;: [&#123;      &quot;type&quot;: &quot;category&quot;,      &quot;boundaryGap&quot;: false,      &quot;data&quot;: [&quot;2019-05-08&quot;,&quot;2019-05-09&quot;,&quot;2019-05-10&quot;,&quot;2019-05-11&quot;,&quot;2019-05-12&quot;,&quot;2019-05-13&quot;,&quot;2019-05-14&quot;,&quot;2019-05-15&quot;,&quot;2019-05-16&quot;,&quot;2019-05-17&quot;,&quot;2019-05-18&quot;,&quot;2019-05-19&quot;,&quot;2019-05-20&quot;,&quot;2019-05-21&quot;,&quot;2019-05-22&quot;,&quot;2019-05-23&quot;,&quot;2019-05-24&quot;,&quot;2019-05-25&quot;,&quot;2019-05-26&quot;,&quot;2019-05-27&quot;,&quot;2019-05-28&quot;,&quot;2019-05-29&quot;,&quot;2019-05-30&quot;,&quot;2019-05-31&quot;,&quot;2019-06-01&quot;,&quot;2019-06-02&quot;,&quot;2019-06-03&quot;,&quot;2019-06-04&quot;,&quot;2019-06-05&quot;,&quot;2019-06-06&quot;,&quot;2019-06-07&quot;],      &quot;axisTick&quot;: &#123; &quot;show&quot;: false &#125;,      &quot;axisLine&quot;: &#123; &quot;show&quot;: false &#125;  &#125;],  &quot;yAxis&quot;: [&#123; &quot;type&quot;: &quot;value&quot;, &quot;axisTick&quot;: &#123; &quot;show&quot;: false &#125;, &quot;axisLine&quot;: &#123; &quot;show&quot;: false &#125;, &quot;splitLine&quot;: &#123; &quot;lineStyle&quot;: &#123; &quot;color&quot;: &quot;rgba(0, 0, 0, .38)&quot;, &quot;type&quot;: &quot;dashed&quot; &#125; &#125; &#125;],  &quot;series&quot;: [    &#123;      &quot;name&quot;: &quot;帖子&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#d23f31&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 3,      &quot;data&quot;: [&quot;18&quot;,&quot;14&quot;,&quot;22&quot;,&quot;9&quot;,&quot;7&quot;,&quot;18&quot;,&quot;10&quot;,&quot;12&quot;,&quot;13&quot;,&quot;16&quot;,&quot;6&quot;,&quot;9&quot;,&quot;15&quot;,&quot;15&quot;,&quot;12&quot;,&quot;15&quot;,&quot;8&quot;,&quot;14&quot;,&quot;9&quot;,&quot;10&quot;,&quot;29&quot;,&quot;22&quot;,&quot;14&quot;,&quot;22&quot;,&quot;9&quot;,&quot;10&quot;,&quot;15&quot;,&quot;9&quot;,&quot;9&quot;,&quot;15&quot;,&quot;0&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;用户&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#f1e05a&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 2,      &quot;data&quot;: [&quot;31&quot;,&quot;33&quot;,&quot;30&quot;,&quot;23&quot;,&quot;16&quot;,&quot;29&quot;,&quot;23&quot;,&quot;37&quot;,&quot;41&quot;,&quot;29&quot;,&quot;16&quot;,&quot;13&quot;,&quot;39&quot;,&quot;23&quot;,&quot;38&quot;,&quot;136&quot;,&quot;89&quot;,&quot;35&quot;,&quot;22&quot;,&quot;50&quot;,&quot;57&quot;,&quot;47&quot;,&quot;36&quot;,&quot;59&quot;,&quot;14&quot;,&quot;23&quot;,&quot;46&quot;,&quot;44&quot;,&quot;51&quot;,&quot;43&quot;,&quot;0&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;回帖&quot;, &quot;type&quot;: &quot;line&quot;, &quot;smooth&quot;: true, &quot;itemStyle&quot;: &#123; &quot;color&quot;: &quot;#4285f4&quot; &#125;, &quot;areaStyle&quot;: &#123; &quot;normal&quot;: &#123;&#125; &#125;, &quot;z&quot;: 1,      &quot;data&quot;: [&quot;35&quot;,&quot;42&quot;,&quot;73&quot;,&quot;15&quot;,&quot;43&quot;,&quot;58&quot;,&quot;55&quot;,&quot;35&quot;,&quot;46&quot;,&quot;87&quot;,&quot;36&quot;,&quot;15&quot;,&quot;44&quot;,&quot;76&quot;,&quot;130&quot;,&quot;73&quot;,&quot;50&quot;,&quot;20&quot;,&quot;21&quot;,&quot;54&quot;,&quot;48&quot;,&quot;73&quot;,&quot;60&quot;,&quot;89&quot;,&quot;26&quot;,&quot;27&quot;,&quot;70&quot;,&quot;63&quot;,&quot;55&quot;,&quot;37&quot;,&quot;0&quot;]    &#125;  ]&#125;\r\n五线谱\r\nX: 24T: Clouds ThickenC: Paul RosenS: Copyright 2005, Paul RosenM: 6/8L: 1/8Q: 3/8=116R: Creepy JigK: Em|:&quot;Em&quot;EEE E2G|&quot;C7&quot;_B2A G2F|&quot;Em&quot;EEE E2G|\\&quot;C7&quot;_B2A &quot;B7&quot;=B3|&quot;Em&quot;EEE E2G|&quot;C7&quot;_B2A G2F|&quot;Em&quot;GFE &quot;D (Bm7)&quot;F2D|\\1&quot;Em&quot;E3-E3:|2&quot;Em&quot;E3-E2B|:&quot;Em&quot;e2e gfe|&quot;G&quot;g2ab3|&quot;Em&quot;gfeg2e|&quot;D&quot;fedB2A|&quot;Em&quot;e2e gfe|\\&quot;G&quot;g2ab3|&quot;Em&quot;gfe&quot;D&quot;f2d|&quot;Em&quot;e3-e3:|\r\nGraphviz关系图\r\ndigraph finite_state_machine &#123;    rankdir=LR;    size=&quot;8,5&quot;    node [shape = doublecircle]; S;    node [shape = point ]; qi    node [shape = circle];    qi -&gt; S;    S  -&gt; q1 [ label = &quot;a&quot; ];    S  -&gt; S  [ label = &quot;a&quot; ];    q1 -&gt; S  [ label = &quot;a&quot; ];    q1 -&gt; q2 [ label = &quot;ddb&quot; ];    q2 -&gt; q1 [ label = &quot;b&quot; ];    q2 -&gt; q2 [ label = &quot;b&quot; ];&#125;\r\nFlowchart流程图\r\nst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\r\n脚注\r\n这里是一个脚注引用1，这里是另一个脚注引用2。\r\n缩进对齐的段落包含在这个脚注定义内。\r\n可以使用代码块。\r\n还有其他行级排版语法，比如加粗和链接。\r\n这里是一个脚注引用[^1]，这里是另一个脚注引用[^bignote]。[^1]: 第一个脚注定义。[^bignote]: 脚注定义可使用多段内容。    缩进对齐的段落包含在这个脚注定义内。\r\n可以使用代码块。\r\n还有其他行级排版语法，比如**加粗**和[链接](https://lddgo.net)。\r\n```\r\n\r\n\r\n\r\n第一个脚注定义。↩︎\r\n脚注定义可使用多段内容。↩︎\r\n\r\n\r\n","categories":["实用","语言方面"],"tags":["实用知识","语法知识","常用知识","语言基础","实用类","markdown"]},{"title":"洛谷P1631序列合并Java题解","url":"/posts/48002.html","content":"\r\n\r\nimage-20250420181227707\r\n\r\n\r\n\r\nimage-20250420181227707\r\n\r\n题目分析\r\n给定两个长度为 N 的有序数组\r\n$A = \\\\{a_1, a_2, \\ldots, a_N\\\\}$ 和\r\n$B = \\\\{b_1, b_2, \\ldots,\r\nb_N\\\\}$，求所有 ai + bj\r\n组合中的前 N 个最小和。\r\n思路\r\n开个 N^2 大小的数组，直接计算所有 N2\r\n个和并排序的时间复杂度为 O(N2log N)，这在\r\nN ≤ 105\r\n时显然不可行。\r\n有序数组存在特性：数组 A 和\r\nB\r\n已分别按升序排列，因此对于固定的 ai，ai + bj\r\n的值随 j 增大而单调递增。\r\n考虑使用堆，观察题中的两个数组： [ a 1 , a 2 , … , a N ] ， [ b 1 , b\r\n2 , … , b N\r\n]，对这两个数组分别从小到大排序，变成两个有序队列。这样，从A和B中各任取一个数相加得到N^2个和，可以把这些和看成形成了n个有序表/队列：\r\n考虑多路归并：\r\n将每个 ai\r\n与 B\r\n数组相加得到的序列视为一个有序队列，则总共有 N 个有序队列： $$\r\n\\begin{aligned}\r\n   Q_1 &amp;: a_1 + b_1,\\ a_1 + b_2,\\ \\ldots,\\ a_1 + b_N \\\\\r\n   Q_2 &amp;: a_2 + b_1,\\ a_2 + b_2,\\ \\ldots,\\ a_2 + b_N \\\\\r\n   &amp;\\vdots \\\\\r\n   Q_N &amp;: a_N + b_1,\\ a_N + b_2,\\ \\ldots,\\ a_N + b_N \\\\\r\n   \\end{aligned}\r\n$$ 我们的目标是合并这些队列，找到前 N 小的元素。\r\n由所有的 a i + b j 便可以组成以下 N 个偏序集:\r\n\r\n\r\nimage-20250420181754818\r\n\r\n\r\n\r\nimage-20250420181754818\r\n\r\n显然，在这 N 个偏序集中，都能够保证是有序的（单调递增）\r\n因此，对每个单独的偏序集而言，其始终满足：ai + bj &lt;= ai +\r\nb(j+1)\r\n同时，可断言 a 1 + b 1 为所有 a i + b j 组合中的最小值； a N + b N\r\n为所有 a i + b j 组合中的最大值；\r\n所以，我们就能在 O(1)\r\n的时间复杂度内，从构建好的偏序集中取出当前最小值\r\n使用最小堆维护当前所有队列的队首元素。每次取出堆顶元素（当前最小值），并将该元素所在队列的下一个元素加入堆中。\r\n建堆和取值策略如下：\r\n\r\n把每个偏序集中的最小元素加入到小根堆 heap 中，即 heap =\r\n{a1+b1,a2+b1,…,aN+b1} ；\r\n从小根堆 h e a p heap heap\r\n中取出根元素（即当前堆里的最小值），假设取出的元素为 a i + b j，记弹出数\r\n+1；\r\n从取出元素所在的偏序集中，取出仅比此小的元素，ai + b\r\n(j+1)，将其插入到小根堆 heap 中\r\n若弹出数不为 N，则继续执行 2；否则结束取值\r\n\r\n\r\n初始化堆\r\n将每个队列的第一个元素（即 ai + b1）加入堆，记录对应的\r\ni 和当前 b 的索引 j = 1。\r\n迭代取最小值\r\n重复 N 次：\r\n\r\n取出堆顶元素 ai + bj，加入结果集。\r\n若 j + 1 ≤ N，将\r\nai + bj + 1\r\n加入堆中，并更新索引为 j + 1。\r\n\r\n去重与边界处理\r\n使用三元组 (sum, i, j)\r\n存储堆元素，确保同一队列中不同位置的元素能被正确追踪。\r\n\r\n复杂度分析 - 时间复杂度：O(Nlog N)，每次堆操作的时间为\r\nO(log N)，共进行\r\nO(N) 次。 -\r\n空间复杂度：O(N)，堆中最多存储 N 个元素。\r\nimport java.util.Arrays;import java.util.PriorityQueue;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n];        int[] b = new int[n];        // 读取输入数据        for (int i = 0; i &lt; n; i++) &#123;            a[i] = sc.nextInt();        &#125;        for (int i = 0; i &lt; n; i++) &#123;            b[i] = sc.nextInt();        &#125;        sc.close();        // 对数组排序        Arrays.sort(a);        Arrays.sort(b);        // 使用优先队列（小根堆）        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((x, y) -&gt; x[0] - y[0]);        // 初始化堆：将每个a[i]与b[0]的和加入堆        for (int i = 0; i &lt; n; i++) &#123;            pq.offer(new int[]&#123;a[i] + b[0], i, 0&#125;);        &#125;        // 查找前 n 小的值        StringBuilder sb = new StringBuilder();        while(n-- &gt; 0)&#123;            int[] curr = pq.poll();            int sum = curr[0];            int aIdx = curr[1];            int bIdx = curr[2];            sb.append(sum).append(&quot; &quot;);            // 如果当前b索引+1有效，则将下一个和加入堆            if (bIdx + 1 &lt; b.length) &#123;                pq.offer(new int[]&#123;a[aIdx] + b[bIdx + 1], aIdx, bIdx + 1&#125;);            &#125;        &#125;        System.out.println(sb.toString().trim());    &#125;&#125;\r\nAC:\r\n\r\n\r\nimage-20250420194347442\r\n\r\n\r\n\r\nimage-20250420194347442\r\n\r\n","categories":["算法类","题解"],"tags":["算法","题解","洛谷","数据结构"]},{"title":"操作系统之操作系统引论","url":"/posts/8682.html","content":"操作系统的目标及作用\r\n操作系统OS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口\r\n操作系统定义\r\n操作系统（Operating\r\nSystem，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。\r\nOS\r\n\r\n直接控制和管理计算机硬件，软件资源\r\n合理的对各个作业进行调度\r\n以方便用户使用的程序集合\r\n\r\n操作系统的目标\r\n\r\n方便性：\r\n配置了OS的计算机硬件，系统可以直接使用编译命令将用户采用该机语言书写的程序翻译成机器代码，或者直接通过OS所提供的各种命令操纵计算机，方便用户\r\n有效性：\r\n第一层含义：提高系统资源的利用率\r\n另一层：提高系统的吞吐量\r\n可扩充性：\r\n与OS结构有关\r\n开放性：\r\n系统能遵循世界标准规范，尤其是遵循开放系统互联·OSI标准\r\n\r\n操作系统的作用：\r\n\r\nOS作为用户与计算机硬件系统之间的接口\r\n\r\n\r\n\r\nimage-20250506144546633\r\n\r\n\r\nOS作为计算机系统资源的管理者\r\n\r\n\r\n处理机管理\r\n存储器管理\r\n文件管理\r\n设备管理\r\n\r\n\r\n\r\nimage-20250506144609282\r\n\r\n\r\nOS实现了对计算机资源的抽象\r\n\r\n\r\n为了方便用户使用I/O设备，人们在裸机上覆盖一层I/O设备管理软件，隐藏了I/O的具体细节\r\nI/O设备管理软件实现了对计算机硬件操作的第一个层次的抽象\r\nOS是铺设在计算机硬件上的多层软件的集合，他们不仅增强了系统的功能，还隐藏了对硬件操作的具体细节\r\n\r\n\r\n推动OS发展的主要动力\r\n\r\n\r\n不断提高计算机资源利用率\r\n方便用户\r\n器件的不断更新\r\n计算机体系结构的不断发展\r\n不断提出新的应用需求\r\n\r\n操作系统的发展过程\r\n无OS：\r\n人工操作方式：\r\n用户独占全机\r\nCPU等待人工操作\r\n脱机输入输出方式：\r\n\r\n\r\nimg\r\n\r\n单道批处理系统：\r\n设计目标：提高系统资源的使用效率；提高作业吞吐量\r\n\r\n减少机器的空闲等待时间：保持系统的连续运行，在处理完一个作业后，紧接着处理下一个作业\r\n仍不能充分的利用系统资源\r\n\r\n原理：\r\n要求用户使用系统提供的作业控制语言（JCL）来描述自己对作业运行的控制意图，并将这些控制信息连同自己的程序和数据一起作为一个作业提交给操作员。\r\n操作员启动有关程序将一批作业输入到计算机外存，由OS去控制、调度各作业的运行并输出结果。\r\n由于作业进入系统后用户不再干预，从而提高了效率。\r\n\r\n\r\nimage-20250506144955925\r\n\r\n批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。\r\n在内存中只保持一道作业的批处理系统。\r\n\r\n\r\n单道程序运行情况\r\n\r\n内存中始终只保持一道作业，称为单道批处理系统\r\n多道批处理系统\r\n多道程序设计的基本理念\r\n多道程序设计：多个作业存放在主存中，使它们同时处于运行状态，这些作业共享处理机时间和外围设备等资源\r\n\r\n\r\nimage-20250506145025667\r\n\r\n多道批处理系统的优缺点：\r\n资源利用率高\r\n系统吞吐量大\r\n平均周转时间长\r\n无交互能力\r\n需要解决的问题：\r\n\r\n处理机管理问题。\r\n内存管理问题。\r\nI/O设备管理问题。\r\n文件管理问题。\r\n作业管理问题。\r\n用户与系统的接口问题\r\n\r\n分时系统：\r\n分时系统是为了满足 用户需求所形成的一种新型OS\r\n在操作系统中加入了分时技术：即将处理机的运行时间分为时间片，将时间片轮流分配给各联机作业使用。\r\n目标：对用户的请求及时响应；尽量提高系统资源的利用率\r\n\r\n\r\n\r\n表现\r\n(1) 人—机交互。 (2) 共享主机。 (3) 便于用户上机。\r\n\r\n\r\n\r\n\r\n特征\r\n1.多路性 2.独立性 3.及时性 4.交互性\r\n\r\n\r\n\r\n实时系统：\r\n所谓“实时”，是表示“及时”，而实时系统(RealTime\r\nSystem)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\r\n目标：提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理。\r\n系统类型\r\n\r\n实时控制与处理：工业武器控制、嵌入式系统\r\n实时信息处理： 信息查询系统、多媒体系统\r\n\r\n实时任务类型\r\n按任务执行时是否呈现周期性来划分\r\n(1)周期性实时任务。\r\n(2)非周期性实时任务。\r\n根据对截止时间的要求来划分\r\n\r\n硬实时任务(hard real-time task)\r\n软实时任务(Soft real-time task)\r\n\r\n特征\r\n多路性\r\n独立性\r\n及时性\r\n交互性\r\n可靠性\r\n操作系统的基本特性\r\n并发 共享 虚拟 异步\r\n并行和并发：\r\n并行是指这一个时刻上面有着多个事件在执行，是一个瞬间的状态。\r\n并发是指在某一段时间间隔以内有着多个事件同时进行\r\n在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交\r\n替执行。\r\n进程：程序为静态的，进程为程序的执行\r\n线程：进程的更小的可执行单位，一个进程可以包含若干个线程\r\n共享\r\n指系统中的资源供内存中的多道程序所共同使用\r\n在OS环境下的资源共享称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用\r\n在操作系统环境下，所谓共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。由于资源属性的不同，进程对资源共享的方式也不同，目前主要有\r\n以下两种资源共享方式：\r\n互斥共享方式：\r\n系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源，我们把这种资源共享方式称为互斥式共享\r\n临界资源或独占资源：一段时间内只允许一个进程访问的资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。\r\n同时访问方式\r\n允许在一段时间内由多个进程\r\n“同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。\r\n虚拟\r\n操作系统中的所谓“虚拟”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物\r\n在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存、\r\n虚拟外部设备和虚拟信道等。\r\n时分复用技术：\r\n虚拟机处理技术：每个程序建里至少一个进程，让多道程序并发执行，通过时分复用同时为多个用户服务\r\n虚拟设备技术：通过时分复用将一台物理IO设备虚拟为多台逻辑上的IO设备，并允许每\r\n个用户占用一台逻辑上的I/O设备\r\n在操作系统中，虚拟的实现主要是通过分时使用的方法。显然，如果 n\r\n是某物理设备所对应的虚拟的逻辑设备数，则虚\r\n拟设备的平均速度必然是物理设备速度的 1 / n\r\n空分复用技术\r\n虚拟磁盘技术：将硬盘划分为若干个卷，机器上便会有若 干个虚拟盘。\r\n虚拟存储器技术：将一台机器的物理存储器变为虚拟存储\r\n器，以便从逻辑上来扩充存储器的容量。\r\n4、异步\r\n进程是以人们不可预知的速度向前推进，此即进程的异步性\r\n在多道程序环境下，系统允许多个进程并发执行\r\n并发执行的程序走走停停，以不可预知的速度前进\r\n操作系统的主要功能\r\n引入OS的主要目的是：为多道程序的允许提供良好的运行环境，保证多道程序能有条不紊，高效的运行，并最大程度的提高系统中各种资源的利用率，方便用户的使用\r\nOS定义：OS是直接控制和管理计算机硬件、软件资源，合理地对各类作业进行调度，以方便用户使用的程序集合\r\n处理机管理功能\r\n存储器管理功能\r\n设备管理功能\r\n文件管理功能\r\n用户接口\r\n处理机管理功能\r\n进程控制\r\n进程同步\r\n进程通信\r\n调度\r\n存储器管理功能\r\n内存分配\r\n静态分配\r\n动态分配\r\n内存保护\r\n地址映射\r\n内存扩充\r\nOS结构设计\r\n传统的操作系统结构\r\n无结构操作系统\r\n模块化的操作系统\r\n模块独立性\r\n模块接口法\r\n分层次结构OS\r\n客户／服务器模式\r\n面向对象的程序设计\r\n微内核OS结构\r\n微内核的基本概念：将操作系统划分为两大部分：微内核和多个服务器\r\n足够小的内核：微内核并非是一个完整的OS，而只是操作系统中最基本的部分\r\n它通常用于：① 实现与硬件紧密相关的处理；② 实现一些较基本的功能； ③\r\n负责客户和服务器之间的通信\r\n基于客户/服务器模式：\r\n将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现。\r\n客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。\r\n微内核的基本功能\r\n\r\n进程(线程)管理\r\n低级存储器管理\r\n中断和陷入处理\r\n\r\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"第十五届蓝桥杯Java国赛B组D题-园丁","url":"/posts/12811.html","content":"\r\n\r\nimage-20250424201815331\r\n\r\n题目大意\r\n题目的核心是要处理一棵树上每个节点的权值，对于拥有两个及以上儿子节点的父节点，要保证所有儿子节点的权值两两相乘不能是完全平方数，目标是求出最少需要修改多少个节点的权值，才能让整棵树满足这个条件。\r\n思路\r\n完全平方数的判定\r\n首先什么是完美平方数，如果一个正整数 a 是某一个整数 b 的平方，那么这个正整数 a\r\n叫做完全平方数。零也可称为完全平方数。\r\n两个数 x 和 y 的乘积是完全平方数，当且仅当 x 与 y\r\n的乘积中，所有质因子的幂次都是偶数。\r\n例如 4 * 9 = 36 是完全平方数，因为\r\n4 = 22，9 = 32\r\n，他们的质因子的幂次都是偶数。\r\n进一步推导，这个条件等价于 x 和 y 的 “平方因子化简后”\r\n的形式相同。所谓 “平方因子化简”，就是对每个数 a\r\n分解质因数后，只保留每个质因数的奇数次幂（即 ai\r\n的“平方自由部分”），这部分记作 f(ai)。\r\n若 f(ai) = f(aj)\r\n，那么 ai * aj\r\n必然是完全平方数。\r\n代码处理\r\n使用邻接表存树，如果存在两个儿子节点的 f(aj)\r\n相等，那么这两个儿子节点权值的乘积就是完全平方数，不满足题目要求。\r\n贪心处理：\r\n对每个有 k ≥ 2 个儿子的结点\r\ni，统计其所有儿子的 f(aj)，对于重复的\r\nf(aj)，需要修改其中\r\ncnt − 1\r\n个结点的权值（cnt 为该 f(aj)\r\n出现次数）。 对每个结点，累加需要修改的次数。\r\n关于squareFree(int x) — 求平方自由部分:\r\n我们需要只保留不能被2整除的幂次部分，所以按照如下形式解耦出平方自由部分\r\nprivate int squareFree(int x) &#123;    int res = 1;    for (int i = 2; i * i &lt;= x; i++) &#123; // 枚举所有可能的质因数        int cnt = 0;        while (x % i == 0) &#123; // 统计i作为质因子的次数            x /= i;            cnt++;        &#125;        if ((cnt &amp; 1) == 1) res *= i; // 只保留奇数次的质因数    &#125;    if (x &gt; 1) res *= x; // x本身是大于1的质数    return res;&#125;\r\n完整代码如下\r\n//package 数学.subject.P12255_蓝桥杯2024国JavaB_园丁;import java.util.*;import java.io.*;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        new Solutions2();    &#125;&#125;class Solutions2&#123;    private int n;    private int[] a;    private int[] f;    private List&lt;Integer&gt;[] tree;    private int ans = 0;    private int squareFree(int x) &#123;        int res = 1;        for (int i = 2; i * i &lt;= x; i++) &#123;            if (x % i == 0) &#123;                int cnt = 0;                while (x % i == 0) &#123;                    x /= i;                    cnt++;                &#125;                if (cnt % 2 != 0) &#123;                    res *= i;                &#125;            &#125;        &#125;        if (x &gt; 1) &#123;            res *= x;        &#125;        return res;    &#125;    public Solutions2()&#123;        FastReader sc = new FastReader();        n = sc.nextInt();        a = new int[n + 1];        f = new int[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = sc.nextInt();            f[i] = squareFree(a[i]);        &#125;        tree = new ArrayList[n + 1];        for (int i = 1; i &lt;= n; i++) tree[i] = new ArrayList&lt;&gt;();        for (int i = 1; i &lt; n; i++) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            tree[u].add(v);            tree[v].add(u);        &#125;        // 使用迭代的后序遍历来替代递归DFS        Deque&lt;Object[]&gt; stack = new ArrayDeque&lt;&gt;();        stack.push(new Object[]&#123;1, 0, false&#125;);        while (!stack.isEmpty()) &#123;            Object[] node = stack.pop();            int u = (Integer) node[0];            int fa = (Integer) node[1];            boolean visited = (Boolean) node[2];            if (!visited) &#123;                stack.push(new Object[]&#123;u, fa, true&#125;);                List&lt;Integer&gt; children = new ArrayList&lt;&gt;();                for (int v : tree[u]) &#123;                    if (v != fa) &#123;                        children.add(v);                    &#125;                &#125;                // 逆序压入，以保持原来的处理顺序                for (int i = children.size() - 1; i &gt;= 0; i--) &#123;                    int v = children.get(i);                    stack.push(new Object[]&#123;v, u, false&#125;);                &#125;            &#125; else &#123;                List&lt;Integer&gt; children = new ArrayList&lt;&gt;();                for (int v : tree[u]) &#123;                    if (v != fa) &#123;                        children.add(v);                    &#125;                &#125;                if (children.size() &gt;= 2) &#123;                    Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();                    for (int v : children) &#123;                        int sf = f[v];                        cnt.put(sf, cnt.getOrDefault(sf, 0) + 1);                    &#125;                    for (int c : cnt.values()) &#123;                        if (c &gt; 1) &#123;                            ans += c - 1;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(ans);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreElements()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\r\n\r\n\r\nimage-20250425001434729\r\n\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"结构化查询语言SQL","url":"/posts/7844.html","content":"结构化查询语言SQL\r\n关系数据模型\r\n关系模型三要素：\r\n\r\n关系数据结构\r\n完整性约束\r\n关系操作\r\n\r\n\r\n\r\nimage-20250512205709773\r\n\r\n\r\n\r\nimage-20250512205715465\r\n\r\n码：关系中某些属性集合具有区分不同元组的作用，称为码\r\n\r\n超码：如果关系的某一组属性的值能唯一标识每个元组，则称该组属性为超码（super\r\nkey）。\r\n候选码：如果一个超码的任意真子集都不是超码，则称该超码为候选码。候选码是极小的超码。\r\n主键：每个关系都有至少一个候选码，人为指定其中一个作为主键\r\n外码：设 F 是关系 R 的属性子集。若 F 与关系 S 的主键 K 相对应，则称\r\nF 是 R 的外键（foreign key）。\r\n\r\nSQL分类\r\nDDL：数据定义语言 定义了不同的数据库，表，视图，索引等数据库对象\r\n还可以创建修改删除等操作数据库表的结构 CREATE  ALTER  DROP  RENAME\r\n TRUMCATE\r\nDML：数据操作语言 增删改查数据库记录 INSERT  DELETE  UPDATE\r\n SELECT\r\nDCL：数据控制语言 定义数据库，表，字段，用户访问权限和安全级别的\r\nCOMMIT  ROLLBACK  SAVEPOINT\r\nDQL：数据库查询语言 查询数据库中表的记录\r\nDTL：数据库事务语言\r\n\r\n\r\nimg\r\n\r\nSQL基本语法\r\nSQL以分号结尾，可以用空格和缩进，windows不区分大小写，linux下大小写敏感，建议关键字大写\r\n注释 –单行注释– # 单行注释\r\n/* 多行注释*/\r\n字符串类型和日期类型的数据可以用 ’’ 表示\r\n列的别名，使用双引号 ”“ 不建议省略as\r\n书写规范：\r\n数据库名，表名，表别名，字段名，字段别名等小写\r\nSQL关键字，函数名，绑定变量等大写\r\n不能以SQL关键字来命名，如果要用，需要加上‘’着重号标记\r\nDDL-数据定义语言\r\n数据定义语言 定义了不同的数据库，表，视图，索引等数据库对象\r\n还可以创建修改删除等操作数据库表的结构\r\nDDL-数据库操作\r\n\r\n查询\r\nSHOW DATABASES;\r\n查询当前数据库\r\nSELECT DATABASE&#123;&#125;；\r\n创建\r\nCREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 指定使用的字符集] [COLLATE 指定排序规则]；\r\n删除\r\nDROP DATABASE [IF EXISTS] 数据库名;\r\n使用\r\nUSE 数据库名； \r\n修改数据库\r\nALTER DATABASE 数据库名 修改部分;\r\n\r\n表操作\r\nDDL-表操作-查询\r\n\r\n查询当前数据库所有表\r\nSHOW TABLES\r\n查询表结构\r\nDESCRIBE 表名; 简写如下\r\nDESC 表名;\r\nSHOW CREATE TABLE 语句会返回创建表时所用的 SQL\r\n语句\r\n查询指定表的建表语句\r\nSHOW CREATE TABLE 表名；\r\n\r\nDDL-表操作-创建\r\nCREATE TABLE 表名&#123;\t字段1  字段1类型[COMMENT 字段1注释],\t字段2  字段5类型[COMMENT 字段2注释],\t字段3  字段3类型[COMMENT 字段3注释],\t......  &#125;[COMMENT 表注释];\r\n快速复制表结构\r\n-- 只复制结构不复制数据CREATE TABLE new_employee LIKE employee;-- 复制结构及数据CREATE TABLE new_employee AS SELECT * FROM employee;-- 复制部分数据CREATE TABLE high_salary_emp AS SELECT * FROM employee WHERE salary &gt; 10000;\r\nDDL-表操作-修改\r\nALTER TABLE 表名 ADD|DROP|MODIFY|CHANGE 字段名 类型 (长度) [COMMENT 注释] [约束];\r\n\r\n添加字段\r\nALTER TABLE 表名 ADD 字段名 类型 (长度) [COMMENT 注释] [约束];\r\n案例：\r\nemp表添加一个新的字段 昵称为 nickname 类型 varchar(20)\r\nALTER TABLE emp ADD nickname VARCHAR(20) COMMENT &quot;昵称&quot;;\r\n修改数据类型\r\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\r\n修改字段名和字段类型\r\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];\r\n删除字段\r\nALTER TABLE 表名 DROP 字段名;\r\n修改表名\r\nALTER TABLE 表名 RENAME TO 新表名;\r\n\r\nDDL-表操作-删除\r\n\r\n删除表\r\nDROP TABLE [IF EXIST] 表名；\r\n删除指定表，并重新创建\r\nTRUNCATE TABLE 表名；\r\n\r\nDML-数据操作语言\r\n数据操作语言 增删改查数据库记录\r\n\r\n添加数据 INSERT\r\n修改数据 UPDATE\r\n删除数据 DELETE\r\n\r\nDML-插入\r\n\r\n给指定的字段添加数据\r\nINSERT INTO (字段名1，字段名2)  VALUES (值1，值2。。)\r\n给全部字段添加数据\r\nINSERT INTO 表名 VALUES (值1，值2。。)\r\n批量添加数据\r\nINSERT INTO 表名 (字段名1，字段名2。。。) VALUES (值1，值2...) (值1，值2...) (值1，值2...);INSERT INTO 表名 VALUES (值1，值2...) (值1，值2...) (值1，值2...);\r\n\r\n注意：\r\n\r\n插入数据时，指定的字段顺序需要与值的顺序一一对应\r\n字符串和日期的数据类型都应该包含在引号中\r\n插入的数据大小，应该在这个字段的范围内\r\n\r\nDML-修改\r\n修改数据表中的字段值：\r\nUPDATE 表名 SET 字段名1=值1，字段名2=值2..... [WHERE 条件]；\r\n\r\n修改语句的条件可以有，如果没有就是针对整张表\r\n\r\nDML-删除\r\n删除数据表中的数据\r\nDELETE FROM 表名 [WHERE 条件]；\r\n\r\nDELETE的条件可以有，如果没有，就是删除整张表的数据\r\nDELETE不能删除某一个字段的值，可以用UPDATE\r\n\r\nDQL-数据查询语言\r\n数据查询语言，查询数据库中表的记录\r\n\r\n关键字 SELECT\r\n\r\nDQL 语法\r\nSELECT \t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后条件列表ORDER BY\t排序字段列表LIMIT\t分页参数\r\nDQL-基础查询\r\nSELECT \t字段列表FROM\t表名列表\r\n查询多个字段\r\nSELECT 字段1，子段2。。。 FROM 表名；\r\n整表查询\r\nSELECT * FROM 表名;\r\n设置别名\r\nSELECT 字段1 [AS 别名1]，字段2 [AS 别名2] ... FROM 表名；\r\n\r\nas 列的别名可以用一对“”引起来\r\n\r\n去除重复记录\r\nSELECT DISTINCT 字段列表 FROM 表名；\r\n查询常数\r\n查询常数指的是在查询结果里返回固定值，而非从表字段获取数据\r\nSELECT &#x27;这是一个常数&#x27; AS constant_value;\r\n假定有一个 employees 表，包含 id 和\r\nname 字段，你能够在查询结果里既显示表数据，又显示常数。\r\nSELECT id, name, &#x27;固定部门&#x27; AS department FROM employeses;\r\n此查询会返回 employees 表中的 id 和\r\nname 字段，同时为每一行添加一个名为 department\r\n的列，其值均为 固定部门。\r\nDQL-条件查询\r\n基本语句\r\nSELECT 字段列表 FROM 表名 WHERE 条件列表;\r\n比较运算符\r\n等于（=）\r\n不等于（&lt;&gt; 或！=）\r\n大于（&gt;）\r\n小于（&lt;）\r\n大于等于（&gt;=）\r\n小于等于（&lt;=）\r\nBETWEEN…AND某个范围内 （BETWEEN之后跟最小值\r\nAND之后跟着最大值）\r\nIN 在IN之后的列表中的值，多选一\r\nLIKE 模糊匹配（_匹配单个字符，%匹配多个字符）\r\n-- 查询名字包含&quot;张&quot;的员工SELECT * FROM employee WHERE name LIKE &#x27;%张%&#x27;;-- 查询名字以&quot;张&quot;开头且长度为3的员工SELECT * FROM employee WHERE name LIKE &#x27;张__&#x27;;-- 查询手机号第二位是5的员工SELECT * FROM employee WHERE phone LIKE &#x27;_5%&#x27;;\r\nIS NULL （NULL）\r\n-- 查询奖金为NULL的员工SELECT * FROM employee WHERE bonus IS NULL;-- 查询奖金不为NULL的员工SELECT * FROM employee WHERE bonus IS NOT NULL;-- 使用IFNULL处理NULL值SELECT name, salary, IFNULL(bonus, 0) AS total_income FROM employee;\r\n逻辑运算符\r\nAND 或 &amp;&amp; 与\r\nOR 或 || 或\r\nNOT 或 ! 非\r\n-- 查询年龄SELECT name FROM employee WHERE age = 55;SELECT * FROM employee WHERE age = 55;-- 查询有身份证号的员工信息SELECT * FROM employee WHERE idcard is not null;-- 查询年龄不为55的员工SELECT * FROM employee WHERE age != 55;-- 模糊查询名字为两个字的员工信息SELECT * FROM employee WHERE name LIKE &#x27;__&#x27;;-- 查询身份证号最后一位为8的SELECT * FROM employee WHERE idcard LIKE &#x27;%8&#x27;\r\nDQL-聚合函数\r\n聚合函数：一列数据作为一个整体，纵向计算\r\n常见聚合函数：\r\ncount 统计数量\r\nmax 最大值\r\nmin 最小值\r\navg 平均值\r\nsum 求和\r\n聚合函数都是作用与表的某一列\r\nSELECT 聚合函数(字段列表) FROM 表名；\r\nnull不参与聚合函数的计算\r\n空值参与运算，结果一定为空\r\n-- 查询总数据SELECT COUNT(*) FROM employee;-- 统计id字段的总数量SELECT COUNT(id) FROM employee;-- 统计企业员工的平均年龄SELECT avg(age) FROM employee;-- 统计企业员工的年龄和SELECT SUM(age) FROM employee;\r\nDQL-分组查询\r\n关键字：GROUP BY\r\n语句：\r\nSELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\r\nwhere与having区别\r\n执行实际不同：where是分组前进行过滤，不满足where条件不参与分组；HAVING是分组后对结果过滤\r\n判断条件不同：WHERE不能对聚合函数判断，HAVING可以\r\n执行顺序 where &gt; 聚合函数 &gt; having\r\n分组之后，查询的字段一般为聚合函数和分组字段，其他字段无意义\r\nSELECT name,gender,COUNT(*) FROM employee GROUP BY gender;\r\n-- 根据性别分组统计男女员工数量SELECT gender, COUNT(*) FROM employee GROUP BY gender;-- 根据性别分组统计男女员工的平均年龄SELECT employee.gender,AVG(employee.age) FROM itcast.employee GROUP BY gender;-- 查询年龄小于45岁的员工，并根据WOKRNO分组SELECT workno,COUNT(*) FROM employee WHERE age &lt; 45 GROUP BY workno;SELECT workno,COUNT(*) FROM employee WHERE age &lt; 45 GROUP BY workno HAVING COUNT(*) &gt;= 1;SELECT workno,COUNT(*) worknum FROM employee WHERE age &lt; 45 GROUP BY workno HAVING worknum &gt;= 1;\r\nDQL-排序查询\r\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2...;\r\n支持多字段排序\r\n​ 如果是多字段排序，当第一个字段值相同时候会按照第二个这样依次\r\n排序方式\r\n\r\nASC 升序 默认\r\nDESC 降序\r\n\r\n-- 排序查询-- 根据年龄对公司的员工进行升序排序SELECT * FROM employee ORDER BY age ASC;-- 根据入职时间，对员工进行降序排序SELECT name FROM employee ORDER BY employee.entrydate DESC;-- 根据年龄对公司的员工进行升序排序，年龄相同，再根据入职时间排序SELECT * FROM employee ORDER BY employee.entrydate DESC, entrydate ASC;\r\nDQL-分页查询\r\nSELECT 字段列表 FROM 表名 LIMIT 起始索引, 每页记录数;\r\n注意：\r\n\r\n起始索引从0开始，起始索引 =\r\n（查询页码-1）*每页显示记录数\r\n分页查询是数据库的方言，不同的数据库之间不同，mysql中是LIMIT\r\n如果查询的第一页数据，起始索引可以省略，直接简写\r\n\r\nDQL-执行顺序\r\n编写顺序\r\nSELECT \t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后条件列表ORDER BY\t排序字段列表LIMIT\t分页参数\r\n执行顺序\r\n\r\nFROM 决定我要查询那一张表\r\nWHERE 指定查询的条件\r\nGROUP BY 和 HAVING 指定分组\r\nSELECT 字段列表\r\nORDER BY 指定排序\r\nLIMIT 指定分页\r\n\r\nDCL-数据控制语言\r\n主要用来管理数据库的用户，控制数据库的访问权限\r\nDCL–管理用户\r\n本质上是对user表的修改\r\n主机名可以用%通配\r\n查询用户\r\nUSE mysql；SELECT * FROM user;\r\n\r\n主机地址和用户名才能定位一个用户，本质上是查询user表\r\n\r\n创建用户\r\nCREATE USER ‘用户名’@‘主机名’ IDENTIFIED BY &#x27;密码&#x27;;\r\nCREATE USER ‘用户名’@‘主机名’ IDENTIFIED BY ‘密码’;\r\n修改用户密码\r\nALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;\r\n删除用户\r\nDROP USER ‘用户名’@‘主机名’;\r\nDCL-权限控制\r\nMySQL中定义了多种权限，常用的就这些\r\nALL, ALL PRIVILEGES 所有权限\r\nSELECT 查询数据\r\nINSERT 插入数据\r\nUPDATE 修改数据\r\nDELETE 删除数据\r\nALTER 修改表\r\nDROP 删除数据库/表/视图\r\nCREATE 创建数据库/表\r\n查询权限\r\nSHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;\r\n授予权限\r\nGRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;\r\n撤销权限\r\nREVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;\r\n注意：\r\n\r\n多个权限之间，使用逗号分隔\r\n授权时，数据库名和表名可以使用*进行通配，代表所有\r\n\r\n多表查询\r\n多表关系\r\n一对多（多对一） 多的一方建立外键，指向一的一方的主键\r\n多对多 建立第三张表，中间表至少包含两个外键，分别关联两方主键\r\n一对一 拆分表\r\n在任意一方加入外键，管理另外一方的主键，并且设置为UNIQUE\r\n内连接\r\n查询表1，表2 交集部分数据\r\n\r\n\r\nimg\r\n\r\n这种场景下得到的是满足某一条件的A，B内部的数据；正因为得到的是内部共有数据，所以连接方式称为内连接。\r\n隐式内连接\r\nSELECT 字段列表 FROM 表1，表2 WHERE 筛选条件;\r\n显式内连接\r\nSELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 连接条件;\r\n示例：\r\n-- 题目 1：查询每个用户的角色ID列表-- 实际场景：管理员需要查看每个用户关联的角色ID。SELECT user.user_id, user_role.role_id FROM userINNER JOIN user_role ON user.user_id = user_role.user_id;-- 题目 2：查询每个角色的权限ID列表-- 实际场景：系统需要列出每个角色关联的权限ID。SELECT role.role_id, role_permission.permission_id FROM roleINNER JOIN role_permission ON role.role_id = role_permission.role_id;\r\n外连接\r\n\r\n左右外连接\r\n左外连接\r\n左外连接查询左表所有数据，以及两张表交集部分数据\r\n左外连接相当于查询表A(左表)的所有数据和中间绿色的交集部分的数据。\r\n表1的位置为左表，表2的位置为右表\r\nSELECT 字段列表FROM 表1LEFT [OUTER] JOIN 表2ON 条件;\r\n右外连接\r\n右外连接查询左表所有数据，以及两张表交集部分数据\r\n右外连接相当于查询表B(右表)的所有数据和中间绿色的交集部分的数据。\r\n表1的位置为左表，表2的位置为右表\r\nSELECT 字段列表FROM 表1RIGHT [OUTER] JOIN 表2ON 条件;\r\n自连接\r\n自连接是指将一张表与自身进行连接操作。通常用于处理表中存在层级关系或递归关系的数据。\r\n在自连接中，我们需要为同一张表创建两个别名（如 p1 和\r\np2），然后通过某种条件将这两个别名关联起来。\r\n自连接表一定要起别名\r\n对于自连接查询，可以是内连接查询，也可以是外连接查询。\r\n连接条件通常是父子关系字段\r\nSELECT 字段列表FROM 表A 别名AJOIN 表B 别名BON 条件;\r\n示例：\r\n-- permission_id：权限的唯一标识。   parent_permission_id：当前权限的父权限 ID。-- 找到每个权限的直接子权限SELECT     p1.permission_id AS parent_permission_id,     p1.permission_name AS parent_permission_name,     p2.permission_id AS child_permission_id,     p2.permission_name AS child_permission_nameFROM     permission p1LEFT JOIN   -- 确保即使某个权限没有子权限，父权限的信息仍然会被显示出来。    permission p2 ON p1.permission_id = p2.parent_permission_id;\r\n连接条件：对于 p1 中的每个权限（父权限），查找\r\np2 中所有 parent_permission_id 等于该权限 ID\r\n的记录（子权限）\r\n\r\n使用 INNER JOIN 时，只会返回有子权限的父权限。\r\n使用 LEFT JOIN\r\n时，会返回所有父权限，即使它们没有子权限。\r\n\r\n-- 查询员工及其直接上级SELECT e1.name AS employee, e2.name AS managerFROM employee e1LEFT JOIN employee e2 ON e1.manager_id = e2.emp_id;-- 查询同一部门的员工对SELECT a.name AS employee1, b.name AS employee2FROM employee aJOIN employee b ON a.dept_id = b.dept_id AND a.emp_id &lt; b.emp_id;\r\n联合查询\r\nunion查询，就是把多次查询的结果合并，形成一个新的查询结果\r\nSELECT 字段列表 FROM 表AUNION [ALL]SELECT 字段列表 FROM 表B\r\n\r\n联合查询的多张表列数必须保持一致，字段类型也需要保持一致\r\nunion all\r\n会将全部的数据合并，union会对合并后的数据去重\r\n\r\n子查询\r\n子查询是指嵌套在另一个 SQL 语句中的 SELECT\r\n查询。\r\n它可以出现在 WHERE、FROM、SELECT\r\n等子句中，用于提供额外的数据过滤或计算条件。\r\n子查询必须用括号 () 包裹\r\nNULL 值处理：子查询返回 NULL 可能导致意外结果，需用\r\nIS NULL 或 COALESCE 处理\r\nSELECT * FROM 表1 WHERE 字段列表1 = （SELECT 字段列表 FROM 表2）\r\n\r\n子查询外部的语句可以是INSERT UPDATE DELETE SELECT中的任意一个\r\n标量子查询：子查询结果为单个值\r\n列字查询：子查询结果为一列\r\n行子查询：子查询结果为一行\r\n表子查询：子查询结果为多行多列\r\n\r\n根据子查询位置，分为WHRER之后，FROM之后，SELECT之后\r\n标量子查询\r\n\r\n特点：返回单个值（一行一列）\r\n常见场景：作为条件判断、赋值或计算的一部分\r\n\r\n示例：查询工资高于平均工资的员工\r\nSELECT emp_name, salaryFROM employeesWHERE salary &gt; (SELECT AVG(salary) FROM employees);\r\n\r\n子查询 (SELECT AVG(salary) FROM employees)\r\n返回一个标量值（平均工资）\r\n主查询通过 &gt; 比较每个员工的工资与平均值\r\n\r\n列子查询（Column\r\nSubquery）\r\n\r\n特点：返回一列多行的数据\r\n常用操作符：IN, NOT IN,\r\nANY, ALL\r\n\r\n示例：查询所有部门经理的员工信息\r\nSELECT * FROM employeesWHERE emp_id IN (SELECT manager_id FROM departments);\r\n行子查询（Row\r\nSubquery）\r\n\r\n特点：返回一行多列的数据\r\n常用操作符：=, &lt;&gt;,\r\nALL\r\n\r\n示例：查询与某个员工（ID=1001）部门和职位都相同的其他员工\r\nSELECT * FROM employeesWHERE (department_id, position) =       (SELECT department_id, position FROM employees WHERE emp_id = 1001)  AND emp_id != 1001;\r\n\r\n子查询返回 emp_id=1001 的员工的部门和职位信息\r\n主查询使用行比较 (col1, col2) = (val1, val2)\r\n匹配条件\r\n\r\n表子查询（Table\r\nSubquery）\r\n\r\n特点：返回多行多列的数据（类似临时表）\r\n常用位置：FROM 子句中，需使用别名\r\n\r\n示例：查询每个部门的平均工资，并按降序排列\r\nSELECT dept_name, avg_salaryFROM (    SELECT department_id, AVG(salary) AS avg_salary    FROM employees    GROUP BY department_id) AS tJOIN departments d ON t.department_id = d.department_idORDER BY avg_salary DESC;\r\n\r\n子查询计算每个部门的平均工资\r\n主查询将子查询结果（临时表\r\nt）与部门表连接，获取部门名称\r\n\r\n子查询中 EXISTS\r\nEXISTS：子查询是否返回任何行。如果子查询返回至少一行，则EXISTS条件为真，外层查询将根据这个结果进行相应的操作。\r\nEXISTS只关心子查询是否有结果返回，而不关心返回的具体内容\r\nSELECT columnsFROM table_nameWHERE EXISTS (subquery);\r\n-- 查询有下属的员工SELECT name FROM employee e1WHERE EXISTS (SELECT 1 FROM employee e2 WHERE e2.manager_id = e1.emp_id);-- 查询没有订单的客户SELECT name FROM customers cWHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);\r\n子查询与连接（JOIN）的对比\r\n子查询和连接都可以实现多表数据关联，但适用场景不同：\r\n\r\n\r\n\r\n子查询\r\n连接（JOIN）\r\n\r\n\r\n\r\n\r\n适合单值条件过滤\r\n适合多表数据关联展示\r\n\r\n\r\n逻辑上更直观（分步处理）\r\n性能通常更高（优化器优化）\r\n\r\n\r\n可能导致多次执行子查询\r\n通常一次性扫描所有表\r\n\r\n\r\n\r\n示例对比：查询每个部门的经理姓名（子查询 vs\r\nJOIN）\r\n-- 子查询SELECT     dept_name,    (SELECT emp_name FROM employees WHERE emp_id = departments.manager_id) AS managerFROM departments;-- JOIN 方式SELECT     d.dept_name,    e.emp_name AS managerFROM departments dJOIN employees e ON d.manager_id = e.emp_id;\r\n","categories":["学习类","数据库","MySql","MySql基础"],"tags":["实用知识","数据库","MySql","常用知识","语言基础"]},{"title":"自定义注解","url":"/posts/13512.html","content":"注解的基本结构\r\n以重写为例子了解基本结构\r\npackage java.lang;import java.lang.annotation.*;/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: *  * &lt;ul&gt;&lt;li&gt; * The method does override or implement a method declared in a * supertype. * &lt;/li&gt;&lt;li&gt; * The method has a signature that is override-equivalent to that of * any public method declared in &#123;@linkplain Object&#125;. * &lt;/li&gt;&lt;/ul&gt; *  * @author  Peter von der Ah&amp;eacute; * @author  Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\r\n注解的名称：\r\npublic @interface Override &#123;&#125;\r\n注解的元注解\r\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)\r\n这两个注解是注解中用到最多的元注解\r\n总结：\r\n注解分为两部分 :\r\n\r\n元注解 ;\r\npublic @interface 注解名称 ;\r\n\r\n注解的本质\r\n按照 public @interface 注解名称 格式 , 写出一个注解 ,\r\n编译该注解代码生成 Annotation.class 字节码文件 ;\r\npublic @interface Annotation &#123;&#125;\r\n使用 javap 命令反编译 Annotation.class 字节码文件 ,\r\n查看该注解的实际代码 ;\r\n发现输出\r\npublic interface Annotation extends java.lang.annotation.Annotation &#123;&#125;\r\n所以说，注解的本质是一个 interface 接口 , 注解接口默认继承了\r\njava.lang.annotation.Annotation 接口 ;\r\n有如下关键特性：\r\n\r\n注解接口隐式继承Annotation接口\r\n不能显式实现其他接口\r\n不能包含泛型参数\r\n不能抛出异常\r\n\r\n注解的属性\r\n注解的属性\r\n注解的本质是接口 , 接口中可以定义 常量 和 方法 ;\r\n在注解中定义 接口方法 , 就是 注解的属性 ;\r\n为注解添加属性 : 接口中的方法都是抽象方法 , 其中 public abstract\r\n可以省略 ;\r\npublic @interface Annotation &#123;    public abstract String path();   // Annotation接口 实现的接口 Annotation 中定义的注解属性(抽象方法)&#125;\r\n使用\r\n@注解名称(属性名称 = 属性值)\r\n@Annotation(path = &quot;&quot;)Student(String name, int age)&#123;&#125;\r\n属性定义规则\r\npublic @interface RequestMapping &#123;    String path();                // 必需属性    String method() default &quot;GET&quot;;// 可选属性    String[] params() default &#123;&#125;; // 数组属性&#125;\r\n注解的属性类型\r\n注解中定义了属性 , 在使用注解时 , 需要 给 注解属性 赋值 ;\r\n定义 注解属性 时 , 可以 使用 default 关键字 指定属性默认值\r\nint intValue() default 666;   // 制定 注解属性 intValue 值类型为 int 整型 , 默认值 666 \r\n\r\n如果 注解属性 指定了默认值 , 在使用注解时 , 可以选择\r\n不为该属性赋值 ( 此时使用默认属性值 ) , 也可以进行赋值 (\r\n指定一个新的属性值 ) ;\r\n如果 注解属性 没有指定默认值 , 则使用 注解 时 ,\r\n必须为其指定一个默认值 , 否则编译时报错 ;\r\n\r\n注解属性 ( 接口方法 ) 返回值类型要求 :\r\n\r\n基本数据类型 : byte , short , int , long , float , double , char ,\r\nboolean ;\r\n字符串类型 : String ;\r\n枚举类型 : enum ;\r\n注解类型 ;\r\n其他注解类型\r\n以上类型的数组形式 ，不允许多维数组\r\n\r\n禁止的类型：\r\n\r\n自定义对象类型\r\n泛型类型（如List）\r\nnull值（默认值不能为null）\r\n\r\n注解属性返回值必须是以上的类型 , 不能设置其它类型返回值 , 否则会报错\r\n;\r\n赋值简化操作：\r\n如果 注解属性 名称是 value , 并且 注解中只有 1 个属性 , 那么在使用\r\n注解 为 注解属性 赋值时 , 可以省略注解名称 , 直接传入 注解属性值 ;\r\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;// 使用 SuppressWarnings 注解时 , 直接传入 “all” 参数 , 省略了注解属性名称 ;    @SuppressWarnings(&quot;all&quot;)    @Override    public String toString() &#123;        return super.toString();    &#125;// 注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\r\n注解属性 名称是 value , 并且 注解中只有 1 个属性,\r\n才能使用上述简化方式\r\n自定义一个注解\r\n\r\n使用@interface来申明一个自定义注解时，他会自动继承ava.lang.annotation.Annotation接口。\r\n格式public @interface\r\nxxx(注解名称){定义注解参数内容}。\r\n\r\n// 1. 定义带参数的注解@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ApiVersion &#123;    String group() default &quot;default&quot;;    int[] versions();  // 必须显式赋值&#125;// 2. 使用注解@ApiVersion(group = &quot;user&quot;, versions = &#123;1, 2&#125;)public class UserController &#123;    @ApiVersion(versions = &#123;2&#125;) // 使用默认group    public void updateUser() &#123;...&#125;&#125;// 3. 通过反射处理注解Class&lt;UserController&gt; clazz = UserController.class;ApiVersion classAnnotation = clazz.getAnnotation(ApiVersion.class);if (classAnnotation != null) &#123;    System.out.println(&quot;Supported versions: &quot; +         Arrays.toString(classAnnotation.versions()));&#125;\r\n如果是注解有参数，需要在注解里面添加参数类型\r\n参数格式： 类型 + 名称();\r\n加了参数后，使用注解如果不添加参数的话会报错，除非添加默认值\r\n参数设计建议\r\n\r\n当只有一个参数时，建议命名为value\r\n数组参数建议提供空数组默认值（default &#123;&#125;）\r\n复杂参数使用注解嵌套：\r\n\r\n\r\n\r\n111\r\n\r\n如果只有一个参数可以直接使用value命名，这样在使用注解的时候可以省略’名称=“xx”’直接赋值\r\n注解的使用\r\n自定义注解的使用需要用到反射的原理\r\n//作用于类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface ClassAnno&#123;    String value();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoName&#123;    String name();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoAge&#123;    int age();&#125;public class CustomAnnotationExample &#123;    public static void main(String[] args) &#123;        // 获取类的注解信息        Class&lt;Person&gt; personClass = Person.class;   // 反射获取        if (personClass.isAnnotationPresent(ClassAnno.class)) &#123;            // 取出Annotation注解信息            ClassAnno classAnno = personClass.getAnnotation(ClassAnno.class);            System.out.println(&quot;类注解信息: &quot; + classAnno.value());        &#125;        // 获取属性的注解信息        // 需要注意的是，类是默认缺省的，是有访问权限的。而name和age是私有private的，无法直接获取到Filed对象，需要使用getDeclaredField以及getDeclaredAnnotation获取        Field[] fields = personClass.getDeclaredFields();  // getDeclaredFields()反射获取        for (Field field : fields) &#123;            if (field.isAnnotationPresent(FiledAnnoName.class)) &#123;                // 使用反射获取Student注解信息annotations 可以获取到注解里面的值是多少                FiledAnnoName filedAnnoName = field.getAnnotation(FiledAnnoName.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoName.name());            &#125;            if (field.isAnnotationPresent(FiledAnnoAge.class)) &#123;                FiledAnnoAge filedAnnoAge = field.getAnnotation(FiledAnnoAge.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoAge.age());            &#125;        &#125;    &#125;\r\n引用\r\n【Java\r\n注解】自定义注解 ( 注解属性定义与赋值 )\r\njava如何优雅的自定义一个注解？\r\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"蓝桥杯2025Python省BF题园艺题解","url":"/posts/20727.html","content":"洛谷上的题目markdown\r\nP12175 [蓝桥杯 2025 省 Python B] 园艺\r\n题目描述\r\n小蓝从左到右种了 n\r\n棵小树，第 i 棵树的高度为\r\nhi，相邻树的间隔相同。小蓝想挪走一些树使得剩下的树等间隔分布，且从左到右高度逐渐上升（相邻两棵树高度满足右边的比左边的高），小蓝想知道最多能留下多少棵树。\r\n输入格式\r\n输入的第一行包含一个正整数 n。\r\n第二行包含 n 个正整数 h1, h2, ⋯, hn，相邻整数之间使用一个空格分隔。\r\n输出格式\r\n输出一行包含一个整数表示答案。\r\n输入输出样例\r\n输入 #1\r\n63 5 4 7 6 7\r\n输出 #1\r\n3\r\n说明/提示\r\n样例说明\r\n留下第 1、3、5 棵树，它们等间隔且从左到右高度逐渐上升。\r\n评测用例规模与约定\r\n\r\n对于 30% 的评测用例，1 ≤ n ≤ 500；\r\n对于 60% 的评测用例，1 ≤ n ≤ 3000；\r\n对于所有评测用例，1 ≤ n ≤ 5000，0 &lt; hi &lt; 106。\r\n\r\n\r\n问题概述\r\n题目要求我们在一排树中选出尽可能多的树，满足两个条件：\r\n\r\n选出的树必须是等间隔分布的\r\n选出的树的高度必须严格递增\r\n\r\n思路\r\n可以发现类似 最长下降子序列 的问题\r\n考虑 dp ，对于每棵树 i ，检查它前面所有的树 j ，如果树 j 的高度小于树\r\ni 的高度，计算它们之间的间隔 diff\r\ndp[i][d]表示以第 i 棵树结尾，间隔为 d\r\n的最长子序列长度\r\n记录以树 i 结尾、间隔为 diff 的最长子序列长度\r\n代码\r\npackage 动态规划.subject.线性dp.P12175_蓝桥杯2025_省_PythonB_园艺;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // 初始化输入        Scanner sc = new Scanner(System.in);        int n = sc.nextInt(); // 读取树的总数        int[] tree = new int[n]; // 存储每棵树的高度                // 读取每棵树的高度        for (int i = 0; i &lt; n; i++) &#123;            tree[i] = sc.nextInt();        &#125;        // 动态规划数组        // dp[i][d]表示以第i棵树结尾，间隔为d的最长子序列长度        int[][] dp = new int[n][n];                // 初始最大值设为1，因为至少可以选择一棵树        int max = 1;        // 初始化：每棵树可以单独形成一个子序列        // dp[i][0]表示间隔为0的情况（即只选这一棵树）        for (int i = 0; i &lt; n; i++) &#123;            dp[i][0] = 1;        &#125;        // 动态规划主过程        for (int i = 0; i &lt; n; i++) &#123; // 遍历每棵树作为结尾            for (int j = 0; j &lt; i; j++) &#123; // 检查前面的所有树                // 只有当当前树比前面的树高时才考虑                if (tree[j] &lt; tree[i]) &#123;                    // 计算两棵树之间的间隔                    int diff = i - j;                                        // 获取以树j结尾、间隔为diff的最长子序列长度                    int prev = dp[j][diff];                                        // 如果prev为0，说明树j是单独存在的                    // 此时可以形成一个长度为2的子序列（树j和树i）                    if (prev == 0) &#123;                        prev = 1;                    &#125;                                        // 如果发现更长的子序列，就更新                    if (dp[i][diff] &lt; prev + 1) &#123;                        dp[i][diff] = prev + 1;                                                // 更新全局最大值                        if (dp[i][diff] &gt; max) &#123;                            max = dp[i][diff];                        &#125;                    &#125;                &#125;            &#125;        &#125;        // 输出结果        System.out.println(max);                // 关闭Scanner        sc.close();    &#125;&#125;\r\n因为是 python 组的题目，所以这里放一下python的代码\r\ndef main():    import sys    input = sys.stdin.read        # 读取输入数据    data = input().split()    n = int(data[0])    tree = list(map(int, data[1:n+1]))        # 初始化动态规划数组    # dp[i][d] 表示以第i棵树结尾，间隔为d的最长子序列长度    dp = [[0] * n for _ in range(n)]    max_len = 1  # 至少可以选一棵树        # 初始化：每棵树可以单独形成一个子序列    for i in range(n):        dp[i][0] = 1        # 动态规划主过程    for i in range(n):  # 遍历每棵树作为结尾        for j in range(i):  # 检查前面的所有树            if tree[j] &lt; tree[i]:  # 只有当前树比前面的树高时才考虑                diff = i - j  # 计算间隔                                # 获取以树j结尾、间隔为diff的最长子序列长度                prev = dp[j][diff]                                # 如果prev为0，说明树j是单独存在的                # 此时可以形成一个长度为2的子序列（树j和树i）                if prev == 0:                    prev = 1                                # 如果发现更长的子序列，就更新                if dp[i][diff] &lt; prev + 1:                    dp[i][diff] = prev + 1                                        # 更新全局最大值                    if dp[i][diff] &gt; max_len:                        max_len = dp[i][diff]        # 输出结果    print(max_len)if __name__ == &quot;__main__&quot;:    main()\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯2025Python省赛B组题解","url":"/posts/5125.html","content":"A. 攻击次数\r\n\r\n\r\nimage-20250420152350082\r\n\r\n\r\n\r\nimage-20250420152350082\r\n\r\n这题有歧义，如果考虑三个英雄一起上，就是103，考虑一回合只能上一个伤害高的，就是181\r\n// 一起上的情况public class Main &#123;    public static void main(String[] args) &#123;        // 能一起上就一起上，不能一起上，就上攻击力高的        int hp = 2025;        int cnt = 0;        while(hp &gt; 0)&#123;            cnt++;            int hero1 = 5;   // 英雄 1 的固定伤害            int hero2 = (cnt % 2 == 1) ? 15 : 2;   // 英雄 2 的回合机制伤害            int hero3 = 0;            if(cnt % 3 == 1)&#123;                hero3 = 2;            &#125;else if(cnt % 3 == 2)&#123;                hero3 = 10;            &#125;else if(cnt % 3 == 0)&#123;                hero3 = 7;            &#125;            hp -= hero1 + hero2 + hero3;        &#125;        System.out.println(cnt);    &#125;&#125;\r\n# 不一起上的情况# 挑攻击力大的技能使用即可# 可见：奇数一定使用第二个英雄的技能，然后偶数情况的话模3余1用第一个英雄技能，其他情况用第三个英雄的技能。n = 0i = 1while n &lt; 2025:    if i &amp; 1:        n += 15    else:        if i % 3 == 2:            n += 10        elif i % 3 == 0:            n += 7        else:            n += 5    i += 1print(i - 1)\r\n\r\nB. 最长字符串\r\n\r\n\r\nimage-20250420152634843\r\n\r\n\r\n\r\nimage-20250420152634843\r\n\r\n下载附件 words.txt\r\n优美字符串的定义是：字符串本身存在于给定的单词列表中，并且可以通过调整顺序后由另一个更短的优美字符串扩展而来。\r\n考的主要是文件读写，默认把 txt 附件存在和代码同级别的目录下\r\npackage 基础算法和其他.IO读写流.P12171_蓝桥杯_2025_省_Python_B_最长字符串;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        //  读取 words.txt 文件中的单词        List&lt;String&gt; words = new ArrayList&lt;&gt;();        try(BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\\\WorkSpace\\\\JavaDemo\\\\IDEA\\\\Algorithm\\\\src\\\\字符串\\\\subject\\\\P12171_蓝桥杯2025省PythonB最长字符串\\\\words.txt&quot;)))&#123;            String line;            while ((line = br.readLine()) != null) &#123;                words.add(line.trim());            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;        // 按长度升序、字典序升序排序（确保处理顺序正确）        words.sort(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()));        Set&lt;String&gt; bs = new HashSet&lt;&gt;();        // 动态规划：判断每个单词是否是优美字符串        for(String word : words)&#123;            if(word.length() == 1)&#123;                bs.add(word);            &#125;else&#123;                // 如果 前n-1 位的长度的字符串，我们把其和要对比的字符串按一定规律重组，那么两者就是一样的了                String pre = sortString(word.substring(0, word.length() - 1));                for(String sbs: bs)&#123;                    if(sortString(sbs).equals(pre))&#123;                        bs.add(word);                        break;                    &#125;                &#125;            &#125;        &#125;        // 找到最长的优美字符串        int maxLength = 0;        for (String word : bs) &#123;            maxLength = Math.max(maxLength, word.length());        &#125;        List&lt;String&gt; ls = new ArrayList&lt;&gt;();        for (String word : bs) &#123;            if (word.length() == maxLength) &#123;                ls.add(word);            &#125;        &#125;        // 输出字典序最小的结果        ls.sort(Comparator.naturalOrder());        System.out.println(ls.get(0));        // System.out.println(&quot;afplcu&quot;);    &#125;    // 字符串按字母字典序重组    private static String sortString(String s) &#123;        char[] charArray = s.toCharArray();        Arrays.sort(charArray);        return new String(charArray);    &#125;&#125;\r\n# 读取 words.txt 文件中的单词with open(&quot;words.txt&quot;, &quot;r&quot;) as f:    ws = [line.strip() for line in f]# 按长度和字典序排序ws.sort(key=lambda x: (len(x), x))# 初始化优美字符串集合bs = set()# 动态规划：判断每个单词是否是优美字符串for w in ws:    if len(w) == 1:        bs.add(w)    else:        pre = &#x27;&#x27;.join(sorted(w[:-1]))        if any(&#x27;&#x27;.join(sorted(s)) == pre for s in bs):            bs.add(w)# 找到最长的优美字符串ml = max(len(w) for w in bs)lbs = [w for w in bs if len(w) == ml]# 输出字典序最小的结果print(min(lbs))\r\n\r\nC. LQ图形\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n观察可发现，可以将L分为上下两个部分，上面列数少的为h行，下面列数多的为w行，上下宽度分别为w和v+w。时间复杂度O(h\r\n+ w)\r\n//package 基础算法和其他.模拟.P12172_蓝桥杯2025省PythonB_LQ图形;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int w = sc.nextInt();        int h = sc.nextInt();        int v = sc.nextInt();        // 先是h高w宽的Q，然后是w高v+w宽        StringBuilder sb1 = new StringBuilder();        StringBuilder sb2 = new StringBuilder();        for(int i = 1; i &lt;= w; i++) sb1.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= v + w; i++) sb2.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= h; i++) System.out.println(sb1);        for(int i = 1; i &lt;= w; i++) System.out.println(sb2);    &#125;&#125;\r\nw,h,v = MII()t = hb = wfor i in range(t):    print(&#x27;Q&#x27; * w)for i in range(b):    print(&#x27;Q&#x27; * (v + w))\r\n\r\nD. 最多次数\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n贪心，遇到连续的三个某个顺序的 l,q,b, 就把他拿掉。时间复杂度O(n)\r\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // lqb lbq qbl qlb blq bql 可以发现题目给出的是全排列        // 遇到连续的 lqb 三个字母拿掉就行        Scanner sc = new Scanner(System.in);        String str = sc.nextLine();        String[] strs = &#123;&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;&#125;;        int res = 0, index = 0;        for(int i = 0; i &lt; str.length() - 2; i++)&#123;   // 注意防止越界            String sub = str.substring(i, i + 3);            for(int j = 0; j &lt; 6; j++)&#123;                if(sub.equals(strs[j]))&#123;                    i += 2;   // 不判断中间的内容了                    res++;                    break;                &#125;            &#125;        &#125;        System.out.println(res);        sc.close();    &#125;&#125;\r\nstr_input = input()strs = [&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;]res = 0i = 0while i &lt; len(str_input) - 2:    sub = str_input[i:i + 3]    for j in range(6):        if sub == strs[j]:            i += 2            res += 1            break    i += 1print(res)\r\n\r\nE. A*B Problem\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n给定 n，求四元组 (a,b,c,d) 个数，满足 a×b+c×d≤n，且 a,b,c,d\r\n都是正整数。\r\n我们需要枚举所有可能的向量 A 和 B，使得它们的内积不超过 L。\r\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int L = scanner.nextInt();        int count = 0;        // 枚举所有可能的 (XA, YA) 和 (XB, YB)        for (int XA = 1; XA &lt;= L; XA++) &#123;            for (int YA = 1; YA &lt;= L; YA++) &#123;                for (int XB = 1; XB &lt;= L / XA + 1; XB++) &#123;                    for (int YB = 1; YB &lt;= (L - XA * XB) / YA + 1; YB++) &#123;                        if (XA * XB + YA * YB &lt;= L) &#123;                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(count);    &#125;&#125;\r\n不行，只有80分，考虑优化\r\n将四元组 (a,b,c,d) 的问题转化为两个部分：x=a×b和 y=c×d，使得\r\nx+y≤n。\r\n这样，问题转化为统计所有满足 x+y≤n 的正整数对 (x,y) 的数量，其中 x 和\r\ny 都可以表示为两个正整数的乘积。\r\n这样对于满足 x+y=k 的四元组个数就是 tx×ty。\r\n考虑每个数 i，预处理其能表示为两个正整数乘积的方式数 t[i]（即 i\r\n的因数对数）。把 x 打表打出来\r\n使用线性筛法预处理每个数的因数个数，计算 t[i]。\r\n计算 t[i] 的前缀和数组 s[i]，用于快速查询 y≤n−x 时的 t[y]\r\n的总和。\r\n对于每个 x，其贡献为 t[x]×s[n−x]\r\n为什么求 t[y] 要使用前缀和数组，对于每个固定的\r\nx，我们需要找到所有满足 y≤n−x 的 y 的数量，也就是 ∑y=1n−x​t[y]\r\npackage 数学.subject.P12174_蓝桥杯2025省Python_B_AxBProblem;import java.util.Arrays;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int l = sc.nextInt();        int[] t = new int[l + 1];        Arrays.fill(t, 0);        // 枚举所有可能的 (a,b)组合，并统计每个乘积的出现次数，打表出四元组的前两部分乘积        for (int a = 1; a &lt;= l; a++) &#123;            for(int b = 1; a * b &lt;= l; b++)&#123;                t[a * b]++;            &#125;        &#125;        // 前缀和        int[] s = new int[l + 1];        s[0] = 0;        for (int i = 1; i &lt;= l; i++) &#123;            s[i] = s[i - 1] + t[i];        &#125;        long total = 0;        // 对于每个 x        for(int x = 1; x &lt; l; x++)&#123;            // 计算其对应的 y 的最大值 l - x            int y = l - x;            total += (long)t[x] * s[y];   // 前缀和计算        &#125;        System.out.println(total);    &#125;&#125;\r\n\r\nF. 园艺\r\n讲过了，在\r\n\r\nG. 书架还原\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\npackage 基础算法和其他.贪心.subject.P12176_蓝桥杯2025省PythonB_书架还原;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n + 1];   // 书架        int[] p = new int[n + 1];   // p[x]表示书本编号现在所处的位置        int res = 0;        for(int i = 1; i &lt;= n; i++)&#123;            a[i] = sc.nextInt();            p[a[i]] = i;    // 桶记录书本a[i]的正确位置，p[a[i]] 是书本应该去的位置        &#125;        // 从第一个位置开始检查，如果当前数字不在正确位置，就找到它应该去的位置，把这两个位置的数字交换。        for(int i = 1; i &lt;= n; i++)&#123;            if(a[i] != i)&#123;   // 不在正确位置，需要调整位置                p[a[i]] = p[i];   // 把书本放到应该去的位置                ++res;                // 把正确位置p[i]上的书本和当前书本位置交换                int temp = a[p[i]];                a[p[i]] = a[i];                a[i] = temp;            &#125;        &#125;        System.out.println(res);    &#125;&#125;\r\nn = II()a = [0] + LII()p = [0] * (n + 1)res = 0for i in range(1,n + 1):    p[a[i]] = ifor i in range(1,n + 1):    if a[i] != i:        p[a[i]] = p[i]        a[i],a[p[i]] = a[p[i]],a[i]        res += 1print(res)\r\n\r\nH. 异或和\r\n\r\n\r\n在这里插入图片描述\r\n\r\n\r\n\r\n在这里插入图片描述\r\n\r\n考虑位运算，把每个数拆成二进制然后进行统计\r\n由于异或运算本身就是建立在位的基础上的，所以我们只需要用一层循环枚举位\r\n只有两个数当前位不同才能产生贡献。也就是说，如果这一位是\r\n0，那他得跟这一位为 1 的数异或才能有贡献，所以加上这一位为 1\r\n的数的个数再乘以这一位的权值\r\n如果先不考虑公式后面的 j−i，那么只有用两个变量统计每位 0 和 1\r\n的个数。\r\n现在还得乘上 j−i，这个值是不断变化的，可以发现其中 i 是不变的，j\r\n每次只加1，开两个变量存储每位 0 和 1 的权值\r\nimport java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        BigInteger[] arr = new BigInteger[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            arr[i] = sc.nextBigInteger();        &#125;        BigInteger res = BigInteger.ZERO;        // 只有两个数当前位不同才能产生贡献。        for (int dig = 0; dig &lt;= 20; dig++) &#123;            int[] cnt = &#123;0, 0&#125;;   // 记录当前已处理过的数中，二进制位 k 为 0 或 1 的数的个数。            BigInteger[] sum = &#123;BigInteger.ZERO, BigInteger.ZERO&#125;;   // 下标差的动态和            for (int i = 1; i &lt;= n; i++) &#123;                // 提取arr[i]的二进制中第 dig 位的值                int bit = arr[i].shiftRight(dig).and(BigInteger.ONE).intValue();                // 取出相反位的值，这样的才可以产生贡献                BigInteger multiplier = BigInteger.valueOf(1L &lt;&lt; dig);                res = res.add(sum[bit ^ 1].multiply(multiplier));                cnt[bit]++;                // 每次处理一个数时，所有之前记录的数的下标差会自然增加                sum[0] = sum[0].add(BigInteger.valueOf(cnt[0]));                sum[1] = sum[1].add(BigInteger.valueOf(cnt[1]));            &#125;        &#125;        System.out.println(res);    &#125;&#125;    \r\nn = int(input())  # 输入数组长度a = list(map(int, input().split()))  # 输入数组res = 0  # 最终结果for b in range(31):  # 遍历每一位（0到30位）    m = 1 &lt;&lt; b  # 当前位的掩码，用于提取该位的值    c = [0, 0]  # 用于统计当前位为0和1的数量    s = [0, 0]  # 用于记录当前位为0和1的索引和    cur = 0  # 当前位的贡献值    for i in range(n):  # 遍历数组中的每个元素        bit = (a[i] &gt;&gt; b) &amp; 1  # 提取当前元素在当前位的值（0或1）        cur += c[1 - bit] * i - s[1 - bit]  # 计算当前位的贡献值        c[bit] += 1  # 更新当前位的计数        s[bit] += i  # 更新当前位的索引和    res += cur * m  # 将当前位的贡献值乘以掩码，累加到最终结果print(res)  # 输出最终结果\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯3月月赛F题题解","url":"/posts/46832.html","content":"「蓝桥·算法双周赛」第二十七场蓝桥月赛最后一题题解\r\n(可能是首发？？nm，真比第三题简单吧)\r\n(求你们看看吧我对我的码风很自信)\r\n问题描述\r\n二分枚举时间m，然后剩下的就是根据题意纯模拟\r\n注意备份和等待能不能跨天进行，这是个坑点\r\n细节在注释里有\r\npackage 蓝桥月赛第27场;import java.util.Scanner;public class F &#123;\t\tprivate static int calculateDays(int m, int[] a, int[] b) &#123;\t\t// 如果没有电脑需要备份，返回 0 天    \tif(a.length == 0) return 0;    \t    \t// 如果 M 小于第一台电脑的备份时间    \tif(m &lt; a[0]) return Integer.MAX_VALUE;    \t    \t// 第一天    \tint days = 1;    \t// 备份第一台开始算剩余时间    \tint currentRemaining = m - a[0];    \t// 第一台都备份不上？？        if (currentRemaining &lt; 0) &#123;            return Integer.MAX_VALUE;        &#125;                for (int i = 1; i &lt;= a.length; i++) &#123;        \tint wait = b[i];   // 获取前一台电脑的等待时间        \t        \t// 处理等待时间        \t// 时间足够，直接减去        \tif(currentRemaining &gt;= wait) &#123;        \t\tcurrentRemaining -= wait;        \t// 不够只能过天了，计算剩余的等待时间        \t&#125;else &#123;        \t\t// 把当天能等的给等了        \t\twait -= currentRemaining;        \t\tdays++;        \t\tcurrentRemaining = m;   // 重置剩余时间        \t\t        \t\tint fullDays = wait / m;   // 计算等几天        \t\tdays += fullDays;        \t\twait -= fullDays * m;        \t\t        \t\tif(wait &gt; 0) &#123;        \t\t\t// 减去零头        \t\t\tcurrentRemaining = m - wait;        \t\t&#125;else &#123;        \t\t\tcurrentRemaining = m;  // 重置        \t\t&#125;        \t&#125;        \t        \t        \t// 处理备份时间        \t// 今天够备份        \tif(currentRemaining &gt;= a[i]) &#123;        \t\tcurrentRemaining -= a[i];        \t&#125;else &#123;        \t\t// 今天备份不完，备份不能留到第二天        \t\tdays++;        \t\tcurrentRemaining = m - a[i];        \t\t// 不行，时间太短，备份不完        \t\tif (currentRemaining &lt; 0) &#123;        \t\t\treturn Integer.MAX_VALUE;        \t\t&#125;        \t&#125;        \t        &#125;        return days;    &#125;\t\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\t\t\t// N 台电脑        int n = scanner.nextInt();        // 最多允许的天数T        int t = scanner.nextInt();        // 表示每台电脑的备份时间。        int[] a = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = scanner.nextInt();        &#125;                // 每台电脑备份完成后需要等待的时间。        int[] b = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            b[i] = scanner.nextInt();        &#125;        scanner.close();                // 最长备份时间        int maxA = 0;        for(int ai: a) &#123;        \tif (ai &gt; maxA) &#123;                maxA = ai;            &#125;        &#125;                if (maxA &gt; 3600) &#123;            System.out.println(-1);            return;        &#125;                // 开始二分 枚举m        int left = maxA;        int right = 3600;        int result = -1;                while(left &lt;= right) &#123;        \tint mid = (left + right) / 2;        \tint days = calculateDays(mid, a, b);        \tif (days &lt;= t) &#123;                result = mid;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;                System.out.println(result != -1 ? result : -1);\t&#125;&#125;\r\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"galgame妹妹推荐转自七海妹","url":"/posts/31531.html","content":"有群友希望我转载这个，那我就转载了\r\n更新时间 2021·12·23 更新内容：推妹妹破百，初代表格诞生\r\n前排提醒：仅为群名~“七海妹”个人主观意见，如有与你不和者，就无视我，没必要争吵。本人一年游玩时间，耗时30小时制作而成，难免有失误，还请告知我更改。本人主看重妹妹，不对作品本身评价，所以废萌评分会高一点。\r\n更新时间 2022·7·26晚\r\n更新内容1：重置评分系统，由原来的SS&lt;SS+&lt;SSS-&lt;SSS 更改成\r\nS&lt;SA&lt;SX&lt;SS&lt;=SAAA&lt;=SSA&lt;SSS\r\n更新内容2：增加50位妹妹，其中15名生肉，1名不能攻略\r\n更新内容3：加入鼠标放在妹妹名字上显示立绘功能 更新耗时25小时\r\n更新时间 2023·1·27下午\r\n更新内容1：添加妹妹、兄妹、妹线这三个评价（等级为：稀烂、拉跨、不太行、凑合、一般、还行、良好\r\n、不错、优秀、极好、完美） 更新内容2：增加23名妹妹，其中11名生肉\r\n更新内容3：22年我二刷了不少妹妹，多刷的评价至少上升一个等级\r\n更新内容4：校对了血缘，更改几个不严谨的\r\n提醒：血缘为？？？是防止剧透，\r\n评分的负XX不是差，比如空羽妹妹非常废柴，但粘人讨喜因此是负极好，以此类推\r\n更新时间 2024·9·10晚\r\n更新内容1：总妹妹数突破200位，增加31位妹妹，生肉26名\r\n更新内容2：生肉有汉化的添加在其作品后，部分有AI翻译的也如此\r\n更新内容3：增加提醒一栏在最后，备注一些注意的，以及避雷提醒等等\r\n更新内容4：再次校对血缘加入双胞胎\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n笹浦铃奈\r\n\r\nSSS妹控\r\n妹妹：负极好\r\n兄妹：优秀\r\n妹线：不错\r\n妹妹色诱术\r\n\r\n\r\n\r\n《缘染此叶，化作恋红》\r\n\r\n\r\n小恶魔\r\n灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n争风吃醋\r\n良好\r\n幼时多病\r\n寄宿\r\n\r\n有孩子、猫娘装、黑丝\r\n\r\n\r\n妹控\r\n\r\nS\r\n妹控福音\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n莲乃 咲\r\n\r\nSSS活\r\n妹妹：极好\r\n兄妹：还行\r\n妹线：良好\r\n为哥哥的诞生献上一份兄妹禁断之恋\r\n\r\n\r\n\r\n《幸福噩梦》\r\n\r\n\r\n情人级\r\n黑发\r\n青梅竹马\r\n欧尼桑\r\n剧情作\r\n美少女\r\n82分\r\n娟好静秀\r\n正常\r\n拯救男主\r\n男主独居\r\n\r\n有孩子、黑丝\r\n\r\n\r\n\r\n\r\nA\r\n真假妹三角恋\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n内藤 舞亚\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：良好\r\n爱着你，比爱这个世界还爱你\r\n\r\n\r\n\r\n《幸福噩梦》\r\n\r\n\r\n恶魔级\r\n灰色\r\n亲妹\r\n欧尼酱\r\n剧情作\r\n哥特萝莉\r\n86分\r\n调皮捣蛋\r\n良好\r\n？？？\r\n男主独居\r\n\r\n膝枕\r\n\r\n\r\n\r\n虐\r\nB\r\n防止剧透？？？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n才城花林\r\n\r\nSAAA\r\n妹妹：极好\r\n兄妹：不错\r\n妹线：还行\r\n超级美少女竟是我妹妹？\r\n\r\n\r\n\r\n《爱丽亚的明日盛典》\r\n\r\n\r\n美少女\r\n黑发\r\n亲妹\r\n莲哥\r\n战斗\r\n美少女\r\n90分\r\n贤妻良母\r\n小陌生\r\n6年不见\r\n加表姐共三人\r\n\r\n摸头杀、膝枕、黑丝\r\n\r\n\r\n\r\n\r\nS\r\n没啥违背道德感的亲妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n在原七海\r\n\r\nSSS优\r\n妹妹：完美\r\n兄妹：优秀\r\n妹线：还行\r\n只想和你在一起\r\n\r\n\r\n\r\n《Riddle Joker》\r\n\r\n\r\n妹妹级\r\n金发\r\n义妹\r\n欧尼酱\r\n超能力\r\n美少女\r\n99分\r\n全能妹妹\r\n亲密无间\r\n都被收养\r\n学校住宿\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nS\r\n人设完美\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n花咲樱花\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：凑合\r\n接受失去的感情\r\n\r\n\r\n\r\n《红线物语》\r\n\r\n\r\n粘人级\r\n黑发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n萝莉\r\n100分\r\n相依为命\r\n两小无猜\r\n父母双亡\r\n兄妹同居\r\n\r\n摸头杀、婚纱、裸体围裙\r\n\r\n\r\n兄控\r\n\r\nA\r\n贤妻良母\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大藏里想奈\r\n\r\nSSS陪伴\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：优秀\r\n山重水复疑无路，柳暗花明又一村\r\n\r\n\r\n\r\n《少女理论及周边》\r\n\r\n\r\n童话级\r\n黑发\r\n同父异母\r\n欧尼酱\r\n剧情向\r\n美少女\r\n94分\r\n互相依靠\r\n舍己为人\r\n家族竞争\r\n男主女装独居\r\n\r\n公主抱、里想奈式拥抱\r\n\r\n\r\n兄控\r\n\r\nA\r\n为哥哥愿意放弃所有\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n朝仓由梦\r\n\r\nSSA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：优秀\r\n相守一生的誓言\r\n\r\n\r\n\r\n《初音岛2》\r\n\r\n\r\n情侣级\r\n灰色\r\n义妹\r\n欧尼桑\r\n剧情向\r\n美少女\r\n96分\r\n家熊外乖\r\n正常\r\n？？？\r\n住隔壁\r\n\r\n\r\n\r\n\r\n\r\n感人/催泪\r\nC\r\n先推姐姐会剧透\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新田一歌\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n十年之约，哥哥由我来守护！\r\n\r\n\r\n\r\n《如月金星》\r\n\r\n\r\n初恋级\r\n金发\r\n义妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n98分\r\n讨厌哥哥\r\n偏差\r\n兄被收养\r\n兄妹同居\r\n\r\n婚纱、孩子\r\n\r\n\r\n\r\n2个be\r\nB\r\n妹妹行动让我感动\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n彩迁日和\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n把我的人生奉献给哥哥\r\n\r\n\r\n\r\n《青春期的五月雨》\r\n\r\n\r\n可爱级\r\n金发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n娇小能干\r\n亲密无间\r\n对抗真姐\r\n母儿女三人\r\n\r\n动态摸头杀\r\n\r\n\r\n兄控\r\n\r\nS\r\n2021第一届可爱妹妹排行榜第一名（自荐）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鸣海兔亚\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n共渡未见的难关\r\n\r\n\r\n\r\n《任性highspec》\r\n\r\n\r\n萌兔级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n白发红眼\r\n93分\r\n相依为命\r\n正常\r\n离家出走\r\n兄妹同居\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n妹妹游戏宅，感情线不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n群云空羽\r\n\r\nSSS妹控\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：不错\r\n妹控真神体降临\r\n\r\n\r\n\r\n《星恋twinkle》\r\n\r\n\r\n妹控之神\r\n银发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n100分\r\n相依为命\r\n形影不离\r\n母死父失\r\n寄宿、同居\r\n\r\n裸体围裙、裸体缎带\r\n\r\n\r\n妹控\r\n甜蜜至极\r\nA\r\n妹控究极福音、难找第二个\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n瓜生樱乃\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n真正意义上的兄妹恋\r\n\r\n\r\n\r\n《纯白交响曲》\r\n\r\n\r\n兄妹级\r\n蓝发\r\n？？？\r\n欧尼酱/桑\r\n废萌\r\n美少女\r\n97分\r\n勤劳能干\r\n优秀\r\n？？？\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n兄妹恋\r\nB\r\n兄妹恋过程写的很好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤守由宇\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n好不容易追上你，这次绝对不放手\r\n\r\n\r\n\r\n《恋骑士》\r\n\r\n\r\n表白级\r\n蓝发\r\n亲妹\r\n欧尼桑\r\n打斗\r\n美少女\r\n98分\r\n勤学苦练\r\n优秀\r\n父死妹病\r\n学园住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG美的窒息，比较现实的兄妹恋\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n伏见巴\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：一般\r\n妹线：还行\r\n我对你的爱是没有上限的\r\n\r\n\r\n\r\n《三千心世界，梦终将实现》\r\n\r\n\r\n兄控级\r\n黑发\r\n同父异母\r\n欧尼桑\r\n悬疑\r\n美少女\r\n97分\r\n平近易人\r\n妹好恋差\r\n异性待哥\r\n学校住宿\r\n\r\n\r\n\r\n\r\n恋兄\r\n\r\nB\r\n前期逃妹（有隐藏实妹）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小森江铃\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：一般\r\n妹线：一般\r\n还好再次遇见你\r\n\r\n\r\n\r\n《青春好奇相伴的三角恋爱》\r\n\r\n\r\n贤妻级\r\n浅粉红\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n94分\r\n温柔体贴\r\n良好\r\n兄妹分离\r\n全家6人\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n结局意料之外，情理之中\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小森江七瑠\r\n\r\nSA\r\n妹妹：一般\r\n兄妹：一般\r\n妹线：一般\r\n不动不说话确实是个美女\r\n\r\n\r\n\r\n《青春好奇相伴的三角恋爱》\r\n\r\n\r\n反差萌\r\n蓝发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n颜艺\r\n良好\r\n正常\r\n全家7人\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n小时候挺可爱的，就是颜艺了点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新海天\r\n\r\nSSS活泼\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：良好\r\n兄妹相声\r\n\r\n\r\n\r\n《9-nine-天色天歌天籁音》\r\n\r\n\r\n活泼级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n超能力\r\n美少女\r\n100分\r\n活泼可爱\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n有be\r\nS\r\n除了男主没说喜欢妹妹其他都优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n月社妃\r\n\r\nSSS绝望\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：优秀\r\n无可奈何却又令人神往的爱恋\r\n\r\n\r\n\r\n《纸上魔法使》\r\n\r\n\r\n纸魔级\r\n金发\r\n亲妹\r\n欧尼桑\r\n神作\r\n美少女\r\n88分\r\n成熟稳重\r\n？？？\r\n离家出走\r\n寄宿\r\n\r\n\r\n\r\n\r\n\r\n虐\r\nS\r\n哎，不是亲妹就好了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n皆神沙久耶\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：不错\r\n思念的终点站\r\n\r\n\r\n\r\n《黄昏的禁忌之药》\r\n\r\n\r\n妹药级\r\n黑发\r\n亲妹\r\n欧尼桑\r\n剧情作\r\n美少女\r\n93分\r\n风趣幽默\r\n不分彼此\r\n母死\r\n寄宿\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nB\r\n大名鼎鼎的妹药\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第2批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n上川沙矢\r\n\r\nSAAA颜\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：一般\r\n取回属于我们兄妹的时光\r\n\r\n\r\n\r\n《樱舞恋花恋模样》\r\n\r\n\r\n女主级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n83分\r\n黑长直\r\n恋人\r\n兄妹分离\r\n男主独居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n就只有颜值很顶\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浅叶 小奈美\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n理想中的兄妹关系\r\n\r\n\r\n\r\n《恋花绽放樱飞时》\r\n\r\n\r\n妹妹级\r\n银发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n活泼撒娇\r\n亲密无间\r\n父母双亡\r\n义母三人\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n永不放弃的信念\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n木下卯月\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n只属于我们的恋爱故事\r\n\r\n\r\n\r\n《密语》\r\n\r\n\r\n情人级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n妹单\r\n大姐姐\r\n91分\r\n成熟\r\n寻找\r\n兄妹分离\r\n男主独居\r\n\r\n\r\n\r\n\r\n\r\n现代相遇\r\nA\r\n多结局，全he\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n野野宫蓝\r\n\r\nSSS兄控\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n妹控养成计划\r\n\r\n\r\n\r\n《春季限定》\r\n\r\n\r\n正妻级\r\n浅粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼可爱\r\n妹控兄控\r\n被父抛弃\r\n学校住宿（同居）\r\n\r\n兄控言论\r\n\r\n\r\n兄控\r\n\r\nB\r\n当极致撒娇遇上妹控\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小春\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n再会，与妹同居\r\n\r\n\r\n\r\n《心猫~与再会的妹妹展开全新关系》\r\n\r\n\r\n萝莉级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n妹单\r\n萝莉\r\n100分\r\n娇小可爱\r\n亲密\r\n兄妹分开\r\n兄妹同居\r\n\r\n裸体围裙\r\n\r\n\r\n\r\n\r\nB\r\n可爱的萝莉妹妹还想啥呢\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n成海真莉音\r\n\r\nSS\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：还行\r\n一生只为哥哥而活\r\n\r\n\r\n\r\n《鲸神》\r\n\r\n\r\n兄控级\r\n红发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n92分\r\n重度兄控\r\n甜蜜\r\n被收养\r\n学校住宿\r\n\r\n婚纱\r\n\r\n\r\n重度兄控\r\n\r\nB\r\n甜度十足\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神森樱乃\r\n\r\nSSS催泪\r\n妹妹：负极好\r\n兄妹：优秀\r\n妹线：极好\r\n我们永远在一起吧\r\n\r\n\r\n\r\n《盛开的钢琴之森下》\r\n\r\n\r\n神作级\r\n暗肉色\r\n义妹\r\n兄长大人\r\n泣作\r\n美少女\r\n94分\r\n体弱多病\r\n当世无双\r\n被收养\r\n住隔壁\r\n\r\n44秒定生死\r\n\r\n\r\n兄妹情\r\n催泪\r\nB\r\n妹妹催泪巅峰作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n沢井 夏叶\r\n\r\nSX萝莉\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n牵着手永远不放开哦\r\n\r\n\r\n\r\n《茂神奇谈》\r\n\r\n\r\n女儿级\r\n灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n三形态\r\n98分\r\n病弱\r\n纯粹\r\n父母双亡\r\n寄宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nB\r\n剧情超长\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n优\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：还行\r\n妹线：负极好\r\n赌上自己的一切，这场战斗必须赢！\r\n\r\n\r\n\r\n《VGNEO》有大量ntr，be牛\r\n\r\n\r\n女主级\r\n红发\r\n？？？\r\n欧尼酱\r\n战斗\r\n女仆\r\n90分\r\n坚强不屈\r\n亲密\r\n？？？\r\n同居\r\n\r\n\r\n\r\n\r\n恋兄\r\n氛围打斗\r\nC\r\n打斗超燃，氛围超好（结局算be吧？）→→→\r\n\r\n\r\n\r\n\r\n某种意义上算牛，谨慎推，打斗很优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大泉栞\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n亲妹现实版\r\n\r\n\r\n\r\n《实妹相伴的大泉君》\r\n\r\n\r\n现实级\r\n浅肉色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n知情达理\r\n距离感\r\n与父吵架\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n带点剧情\r\nB\r\n感情线非常不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n麻衣\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\ngal攻略后的妹妹\r\n\r\n\r\n\r\n《实妹相伴的大泉君》\r\n\r\n\r\n想象级\r\n白毛\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n天真可爱\r\n妹主动\r\n？？？\r\n住隔壁\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n人挺好，结局不太好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n北条实里果\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：良好\r\n逃不掉的命运\r\n\r\n\r\n\r\n《逃避行》\r\n\r\n\r\n隐藏级\r\n红发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n89分\r\n天真可爱\r\n隐藏恋兄\r\n正常\r\n家庭生活\r\n\r\n摸头杀\r\n\r\n\r\n隐藏恋兄\r\n\r\nC\r\n两个结局，不同命运，都he\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n泽渡七凪\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n把恋爱化作语言\r\n\r\n\r\n\r\n《硬要无视与你的未来》\r\n\r\n\r\n妹管严\r\n白毛\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n94分\r\n活泼可爱\r\n妻管严\r\n？？？\r\n加母三人\r\n\r\n\r\n\r\n\r\n兄控\r\n甜中带刀\r\nB\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n天宫雫\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：一般\r\n妹线：还行\r\n一起共度明天而努力活下去\r\n\r\n\r\n\r\n《死神之吻乃离别之味》\r\n\r\n\r\n恋兄级\r\n黑发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n89分\r\n傲娇\r\n距离感\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n恋兄\r\n\r\nB\r\n兄妹相互拯救的故事\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长沢 星歌\r\n\r\nSA\r\n妹妹：一般\r\n兄妹：一般\r\n妹线：不太行\r\n游戏风云\r\n\r\n\r\n\r\n《心灵重启》\r\n\r\n\r\n\r\n黑发\r\n亲妹\r\n大哥\r\n废萌\r\n美少女\r\n87分\r\n胆小内向\r\n距离感\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB/S\r\n作品非常新颖，有意思，在游戏中发生故事，颜值都挺高，但作为妹妹却不够格，\r\n感情线如同拔作，游戏角色又不能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长沢 雪樱\r\n\r\nSA\r\n妹妹：一般\r\n兄妹：一般\r\n妹线：不太行\r\n游戏风云\r\n\r\n\r\n\r\n《心灵重启》\r\n\r\n\r\n\r\n黑发\r\n亲妹\r\n大哥\r\n废萌\r\n美少女\r\n88分\r\n家庭主妇\r\n距离感\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB/A\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第3批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鹰仓杏铃\r\n\r\nSSS柔\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n金发撒娇妹代表\r\n\r\n\r\n\r\n《Clover Day’s》\r\n\r\n\r\n公主级\r\n金发\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n撒娇可爱\r\n亲密无间\r\n男主被养\r\n全家生活\r\n\r\n\r\n\r\n\r\n兄控/妹控\r\n甜蜜\r\nS\r\n温馨甜蜜，妹控福音、剧情也不差，白学羞萝场\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鹰仓杏璃\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n永远支持哥哥\r\n\r\n\r\n\r\n《Clover Day’s》\r\n\r\n\r\n双马尾\r\n灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n傲娇\r\n亲密无间\r\n男主被养\r\n全家生活\r\n\r\n\r\n\r\n\r\n兄控/妹控\r\n\r\nA\r\n温馨甜蜜，妹控福音、剧情也不差，白学羞萝场\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n春日井咲良\r\n\r\nSSS妹控\r\n妹妹：极好\r\n兄妹：极好\r\n妹线：良好\r\n想要把谎言变成真实\r\n\r\n\r\n\r\n《隙间樱花与谎言都市》\r\n\r\n\r\n妹控级\r\n银发\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n100分\r\n霸道柔弱\r\n相依为命\r\n被母虐待\r\n住宿\r\n\r\n\r\n\r\n\r\n妹控\r\n先苦后甜\r\nA\r\n离家出走，相依为命，我的最爱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n山神水绪里\r\n\r\nSS颜\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n你对于我来说是特别的\r\n\r\n\r\n\r\n《清澄如境之水面上》\r\n\r\n\r\n女神级\r\n黑发\r\n亲妹\r\n欧尼\r\n废萌\r\n美少女\r\n90分\r\n强大\r\n爱慕\r\n被封神\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n拔作向的废萌，颜值高，剧情一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仓野绘麻\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n为欧尼酱而生\r\n\r\n\r\n\r\n《仓野家双胞胎的故事》\r\n\r\n\r\n可爱级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n97分\r\n可爱撒娇\r\n亲密\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n撒娇卖萌小萝莉\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仓野弥惠\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n把我献给哥哥\r\n\r\n\r\n\r\n《仓野家双胞胎的故事》\r\n\r\n\r\n可爱级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n可爱\r\n亲近\r\n正常\r\n全家生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n标准废萌\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n间宫 羽咲\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：不错\r\n隐藏在地狱深渊的妹控魔神器\r\n\r\n\r\n\r\n《美好的每一天》素晴日\r\n\r\n\r\n埋葬级\r\n桃色\r\n同父异母\r\n欧尼酱\r\n神作\r\n萝莉\r\n88分\r\n娇小可爱\r\n守护\r\n？？？\r\n？？？\r\n\r\n膝枕\r\n\r\n\r\n妹控\r\n恶心人\r\nB\r\n大名鼎鼎素晴日，废萌玩家不建议推，\r\n\r\n\r\n\r\n\r\n大量牛头人，不过妹没有，不建议推，难受一个月，后劲太大\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n白藤友菜\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n魔法少女之妹妹\r\n\r\n\r\n\r\n《Animal☆Panic》\r\n\r\n\r\n可爱级\r\n浅粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n92分\r\n天真无邪\r\n守护\r\n哥父妹母\r\n兄妹同居\r\n\r\n摸头杀，婚纱\r\n\r\n\r\n\r\n\r\nA\r\n从此改变我对短发妹妹的看法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小雪（全年龄）\r\n\r\nSAAA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：良好\r\n四世轮回千年之恋\r\n\r\n\r\n\r\n《SAKURA~雪月华》\r\n\r\n\r\n千年之恋\r\n红/黑\r\n表/堂妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n93分\r\n天真善良\r\n亲和\r\n？？？\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n轮回\r\nA\r\n妹世差点，第一世我非常喜欢\r\n\r\n\r\n\r\n\r\n仅开局第四世是妹妹，单妹妹剧情不够多\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n沙那\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：不错\r\n妹线：凑合\r\n让哥哥只爱我一个人\r\n\r\n\r\n\r\n《吃醋大作战》\r\n\r\n\r\n满好感度\r\n黑发\r\n亲妹\r\n欧尼酱\r\n半拔\r\n美少女\r\n91分\r\n痴迷\r\n保护\r\n正常\r\n加母三人\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n典型的哥哥成分不足\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n黑川雫\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n为成为兄妹而努力着\r\n\r\n\r\n\r\n《家庭教师露美美》\r\n\r\n\r\n隐藏级\r\n灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n83分\r\n和善\r\n逐渐认可\r\n正常\r\n加女主同居\r\n\r\n婚纱\r\n\r\n\r\n\r\n\r\nC\r\n就表白勇猛\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小河坂 千波\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：还行\r\n你的幸福就是我的幸福\r\n\r\n\r\n\r\n《星空的记忆》\r\n\r\n\r\n活泼级\r\n红发\r\n同母异父\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n热情好客\r\n看护\r\n父母双亡\r\n加姨同居\r\n\r\n裸体围裙、女仆装\r\n\r\n\r\n妹控\r\n自然\r\nB\r\n在妹控道路越走越远，很自然又亲密的兄妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n萤铃音\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：还行\r\n一心同体的搭档\r\n\r\n\r\n\r\n《星辰恋曲的白色永恒》\r\n\r\n\r\n拥有级\r\n白毛\r\n同父异母\r\n欧尼酱\r\n废萌\r\n美少女\r\n61分\r\n进攻型\r\n隐藏\r\n？？？\r\n男主独居\r\n\r\n公主抱\r\n\r\n\r\n\r\n\r\nB\r\n隐藏妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n皆树\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：不太行\r\n妹线：一般\r\n你死了，我会为你哭\r\n\r\n\r\n\r\n《My Sweet Home》\r\n\r\n\r\n禁忌 级\r\n暗肉色\r\n义妹\r\n大哥\r\n妹单\r\n美少女\r\n90分\r\n贤惠\r\n加深型\r\n被收养\r\n加父同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n短小精悍，又禁忌感\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浦部 葵\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：凑合\r\n一起向未来出发\r\n\r\n\r\n\r\n《鬼的捉迷藏》FD妹线\r\n\r\n\r\n可靠级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n可靠\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n遗憾之作，本体优秀，FD妹线拉跨\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n樱庭 水穗\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：一般\r\n天使降临\r\n\r\n\r\n\r\n《LOVELYQUEST》\r\n\r\n\r\n天使级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n温柔贤惠\r\n甜蜜\r\n正常\r\n兄妹同居\r\n\r\n膝枕，和服\r\n\r\n\r\n\r\n\r\nS\r\n感情线不错，温馨甜蜜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n丘野日向（全年龄）\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：良好\r\n你就是我的唯一\r\n\r\n\r\n\r\n《Wind-a breath of heart-》\r\n\r\n\r\n兄妹情\r\n红发\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼洒脱\r\n兄妹情\r\n父死母失\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n妹控\r\n兄妹向\r\nB\r\n少有的体现纯粹兄妹情的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n天濑小雪\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：一般\r\n让我取回曾经美好的岁月\r\n\r\n\r\n\r\n《Magus ~世界树》\r\n\r\n\r\n少女级\r\n实木色\r\n义妹\r\n欧尼酱\r\n魔法\r\n美少女\r\n81分\r\n学霸型\r\n一般\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n各方面都很一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长濑湊\r\n\r\nSSS恋\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n我的生命中需要你\r\n\r\n\r\n\r\n《染红的街道》\r\n\r\n\r\n美少女\r\n灰色\r\n亲妹\r\n欧尼桑/酱\r\n剧情向\r\n美少女\r\n100分\r\n美少女\r\n间隔\r\n正常\r\n兄妹同居\r\n\r\n摸头杀，拥抱三连杀\r\n\r\n\r\n\r\n兄妹恋\r\nA\r\n从相爱到父母同意，比较全面的妹作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n濑名美优树\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n只为寻找你\r\n\r\n\r\n\r\n《妹之形》\r\n\r\n\r\n隐藏级\r\n浅粉红\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n63分\r\n害羞\r\n恋人成妹\r\n兄妹分离\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nB\r\n还有其他隐藏妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鹭泽缘（全年龄）\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n心灵拯救\r\n\r\n\r\n\r\n《秋之回忆4~从今以后》\r\n\r\n\r\n猫咪级\r\n白毛\r\n？？？\r\n欧尼酱\r\n三角恋\r\n美少女\r\n99分\r\n撒娇可爱\r\n开始接近\r\n正常\r\n男主独居\r\n\r\n\r\n\r\n\r\n\r\n三角恋\r\nB\r\n妹妹可爱，剧情不错，有点虐妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤堂 加奈\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：优秀\r\n妹线：不错\r\n妹控杀手与妹控福音共存\r\n\r\n\r\n\r\n《加奈，欢迎回来》\r\n\r\n\r\n妹控鼻祖\r\n黑发\r\n？？？\r\n欧尼酱\r\n三角恋\r\n美少女\r\n93分\r\n柔弱\r\n守护\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n5个be，1个he，\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n片濑雪希\r\n\r\nSS\r\n妹妹：还行\r\n兄妹：良好\r\n妹线：还行\r\n愿永不改变，愿永不分离\r\n\r\n\r\n\r\n《水色》\r\n\r\n\r\n回忆级\r\n浅红\r\n义妹\r\n欧尼酱\r\n伪三角恋\r\n美少女\r\n94分\r\n贤惠刻苦\r\n隐藏\r\n被收养\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n，短小精悍，共通线比较虐妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n野乃崎翼\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：凑合\r\n妹线：还行\r\n妹控监狱\r\n\r\n\r\n\r\n《假如明日天放晴》很虐妹！\r\n\r\n\r\n虐心级\r\n茶色\r\n义妹\r\n欧尼桑\r\n三角恋\r\n美少女\r\n93分\r\n刻苦自卑\r\n不敌姐姐\r\n被收养\r\n多女主居住\r\n\r\n\r\n\r\n\r\n虐妹\r\n虐妹\r\nB\r\n虐妹巅峰作，全程压抑，没病不建议推\r\n\r\n\r\n\r\n\r\n姐兄妹三角恋剧情，很虐妹！！！\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第4批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n乙原恋\r\n\r\nSSS粘人\r\n妹妹：完美\r\n兄妹：优秀\r\n妹线：优秀\r\n爱会让人倾尽所有，恋则会赋予人拯救\r\n\r\n\r\n\r\n《由梦想和色彩编制而成》\r\n\r\n\r\n亲密级\r\n金发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n100分\r\n勤劳能干\r\n亲密无双\r\n正常\r\n兄妹同居\r\n\r\n裸体围裙\r\n\r\n\r\n妹控\r\n拯救\r\nS\r\n感情线，剧情，人设都很优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n月岛和羽\r\n\r\nSSS萝莉\r\n妹妹：负极好\r\n兄妹：不错\r\n妹线：良好\r\n只想和你在一起\r\n\r\n\r\n\r\n《恋爱教室》\r\n\r\n\r\n可爱级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n娇小可爱\r\n温顺\r\n正常\r\n兄妹同居\r\n\r\n有孩子\r\n\r\n\r\n\r\n甜蜜\r\nS\r\n纯甜蜜作，家中有妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n苇原希里奈\r\n\r\nSS颜\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n化解不可能的未来\r\n\r\n\r\n\r\n《新娘太好找了我很方》\r\n\r\n\r\n伪天使\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n可靠努力\r\n亲近\r\n家族\r\n多女主同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n共通线妹妹戏份少，剧情一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n可可音（全年龄）\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n不甘只做妹妹\r\n\r\n\r\n\r\n《萌夏》\r\n\r\n\r\n转变级\r\n浅蓝灰\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n害羞努力\r\n亲近\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n麻雀虽小，五脏俱全，非亲似更亲\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘茉莉\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n不会让你受伤\r\n\r\n\r\n\r\n《妹选总选举》\r\n\r\n\r\n小公主\r\n金发\r\n同父异母\r\n欧尼酱\r\n废萌\r\n萝莉\r\n79分\r\n傲娇\r\n距离感\r\n正常\r\n亲兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n傲娇，金发，毒舌，大小姐，萝莉\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘四叶\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n愿意成为哥哥的妹妹\r\n\r\n\r\n\r\n《妹选总选举》\r\n\r\n\r\n小七海\r\n暗灰色\r\n同父异母\r\n欧尼酱\r\n废萌\r\n美少女\r\n83分\r\n实用能干\r\n亲和\r\n正常\r\n亲兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n起床温柔叫醒，做饭，学习都优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n樱木灰\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：良好\r\n只属于我的灰姑娘\r\n\r\n\r\n\r\n《恋爱少女崩坏的人格》\r\n\r\n\r\n霸道级\r\n紫发\r\n表/堂妹\r\n欧尼桑\r\n女装\r\n美少女\r\n74分\r\n成长型\r\n男好女差\r\n体弱多病\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n不知道男主女装，共通剧情比较优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神林丽\r\n\r\nSAAA颜\r\n妹妹：负优秀\r\n兄妹：良好\r\n妹线：还行\r\n想变得更加喜欢你\r\n\r\n\r\n\r\n《求神太多我的未来糟糕了》\r\n\r\n\r\n恋人级\r\n金发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n81分\r\n活泼洒脱\r\n天降\r\n胎死腹中\r\n兄妹同居\r\n\r\n膝枕\r\n\r\n\r\n\r\n\r\nS\r\n天降实妹不好接受\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神林真央\r\n\r\nSX颜\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：凑合\r\n让我做你的新娘\r\n\r\n\r\n\r\n《求神太多我的未来糟糕了》\r\n\r\n\r\n路人级\r\n浅黄色\r\n表/堂妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n65分\r\n害羞胆小\r\n路人\r\n正常\r\n男女主同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n路人级表妹，戏份少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n炽月\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n不忍哥哥离我而去\r\n\r\n\r\n\r\n《樱花盛典》\r\n\r\n\r\n表面级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n实力型\r\n距离感\r\n留学归来\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n剧情不行，还有个妹妹，不过是不能推，双飞\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n折口美羽\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：良好\r\n我只凝视着你\r\n\r\n\r\n\r\n《追亿夏色年华》\r\n\r\n\r\n相依为命\r\n玫瑰红\r\n双胞胎\r\n欧尼酱\r\n剧情向\r\n美少女\r\n100分\r\n相依为命\r\n亲密无间\r\n父母自杀\r\n同居、住宿\r\n\r\n\r\n\r\n\r\n\r\n悬疑\r\nB\r\n剧情可以，除了妹妹颜值差点都优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n筱崎步海\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：还行\r\n温馨甜蜜小情侣\r\n\r\n\r\n\r\n《与你心相连》\r\n\r\n\r\n表妹级\r\n银发\r\n表/堂妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n85分\r\n真表妹\r\n渐近\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n睡颜可爱，实妹不能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n近江小小路\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n你就是我的世界中心\r\n\r\n\r\n\r\n《世界与世界的中心》\r\n\r\n\r\n白毛萝莉\r\n白毛\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n98分\r\n勤劳能干\r\n亲密\r\n？？？\r\n住宿\r\n\r\n有孩子\r\n\r\n\r\n\r\n\r\nS\r\n白毛萝莉可爱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神乐鸟 雏\r\n\r\nSS\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：一般\r\n你对我来说就是这么重要\r\n\r\n\r\n\r\n《啾啾爱恋》\r\n\r\n\r\n女仆\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n81分\r\n自卑\r\n阻碍\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹非常自卑，害怕哥哥抛弃自己\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小野寺 鞠\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n拯救自己的愿望\r\n\r\n\r\n\r\n《妄想Complete！》\r\n\r\n\r\n诱惑\r\n红发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n活泼好动\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n共通有h，妹线还不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n一羽，二叶\r\n\r\nSSS虐\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：不错\r\n属于我们的理想乡\r\n\r\n\r\n\r\n《重生游戏》\r\n\r\n\r\n姐妹花\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n剧情作\r\n美少女\r\n91分\r\n双妹妹\r\n亲密\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n剧情不错，也有点虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n伊东美琴\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：还行\r\n探索未来的道路\r\n\r\n\r\n\r\n《恋色空模样》\r\n\r\n\r\n高冷\r\n灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n高冷高傲\r\n阻碍\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通线很长，妹妹误以为哥哥是变态而远离\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n花咲乃乃香\r\n\r\nSSS温柔\r\n妹妹：完美\r\n兄妹：良好\r\n妹线：良好\r\n如此爱着你\r\n\r\n\r\n\r\n《花咲workspring》\r\n\r\n\r\n温柔\r\n暗肉色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n温柔体贴\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n甜蜜\r\nS\r\n为报答哥哥，对男主无微不至的照顾\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n中条杏\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n你就是我的光\r\n\r\n\r\n\r\n《赠与你的空之花》\r\n\r\n\r\n甜蜜\r\n银发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n温柔体贴\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n甜蜜\r\nA\r\n甜蜜温馨，感情线不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n千岁佐奈\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n紧握手中的幸福\r\n\r\n\r\n\r\n《天神乱漫》\r\n\r\n\r\n独自哭泣\r\n金发\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n98分\r\n体贴\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n剧情作设定，废萌剧情，感情线还行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n友濑瑠奈\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：不太行\r\n想要拥有真实的你\r\n\r\n\r\n\r\n《少女与野兽》\r\n\r\n\r\n拥有级\r\n深灰色\r\n义妹\r\n名字\r\n废萌\r\n美少女\r\n93分\r\n坚强能干\r\n兄妹\r\n正常\r\n住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n感情线可以，剧情不错\r\n\r\n\r\n\r\n\r\n逆天，哥哥是妹妹的性奴\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第5批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小鸟游亚子\r\n\r\nSSS甜\r\n妹妹：完美\r\n兄妹：不错\r\n妹线：优秀\r\n兄妹关系天花板\r\n\r\n\r\n\r\n《Making Lovers》\r\n\r\n\r\n兄妹级\r\n桃色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n家庭主妇\r\n当世无双\r\n男主被养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n兄妹\r\nB\r\n大概只有本人有亲妹才写的出来的剧本\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n白羽濑 悠\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：良好\r\n爱恋之歌\r\n\r\n\r\n\r\n《杀恋~悠久之流传》\r\n\r\n\r\n守护级\r\n暗灰色\r\n亲妹\r\n欧尼酱\r\n带点\r\n美少女\r\n93分\r\n吵闹强硬\r\n从头\r\n兄妹分离\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n恋成妹\r\nB\r\n典型的中期知道是兄妹，而且be，但剧情不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n双见空\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：还行\r\n我守护着你，你保护着我\r\n\r\n\r\n\r\n《不要践踏天使的羽毛》\r\n\r\n\r\n信任级\r\n金发\r\n？？？\r\n大哥\r\n魔法\r\n美少年\r\n85分\r\n弟弟型\r\n姐弟？\r\n？？？\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n妹妹男装，男主女装，男主不知道\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n远野 恋\r\n\r\nSS颜\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：一般\r\n世界仅此你一人\r\n\r\n\r\n\r\n《夏空的英仙座》\r\n\r\n\r\n魅惑级\r\n深灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n94分\r\n对别高冷\r\n相依为命\r\n离家出走\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG美，设定好，但剧情有点偏了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n和泉妃爱\r\n\r\nSSS温柔\r\n妹妹：完美\r\n兄妹：良好\r\n妹线：不错\r\n契约之爱\r\n\r\n\r\n\r\n《灵感满溢的甜蜜幻想》\r\n\r\n\r\n兄妹级\r\n金发\r\n亲妹\r\n欧尼\r\n废萌\r\n美少女\r\n100分\r\n撒娇可爱\r\n依赖\r\n正常\r\n兄妹同居\r\n\r\n婚纱\r\n\r\n\r\n\r\n甜蜜\r\nS\r\n有名的富婆妹，人设好，剧情甜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n吹上初音\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：一般\r\n妹线：一般\r\n美梦粉碎留下的残骸\r\n\r\n\r\n\r\n《樱之社，净梦者》\r\n\r\n\r\n救赎\r\n浅粉红\r\n表/堂妹\r\n欧尼桑\r\n悬疑血腥\r\n美少女\r\n88分\r\n小女孩\r\n掩埋\r\n哥父母死\r\n家庭生活\r\n\r\n婚纱\r\n\r\n\r\n\r\n氛围作\r\nB\r\n大量血腥镜头，妹前期没存在感，好在剧情不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n山吹恋华（全年龄）\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n想看你的微笑\r\n\r\n\r\n\r\n《Canvas3 白银的肖像》\r\n\r\n\r\n兄妹级\r\n浅紫色\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n温柔宁静\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n兄妹并没有表露出爱意，平常生活突出关系\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名濑由佳奈\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：凑合\r\n妹的圣域\r\n\r\n\r\n\r\n《妹妹的圣域》\r\n\r\n\r\n兄妹级\r\n暗灰色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n兄控\r\n温馨\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控妹控\r\n\r\nA\r\n妹控与兄控结合，剧情够甜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n岛津秋\r\n\r\nSSS厌兄\r\n妹妹：负极好\r\n兄妹：负极好\r\n妹线：优秀\r\n爱，永恒不变\r\n\r\n\r\n\r\n《回忆录》\r\n\r\n\r\n拯救级\r\n紫色\r\n义妹\r\n欧尼桑\r\n官场\r\n美少女\r\n93分\r\n厌恶\r\n讨厌\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n究极妹控\r\n智斗\r\nS\r\n攻略前讨厌哥哥，攻略后病娇，剧情反转过瘾\r\n\r\n\r\n\r\n\r\n唯一一个真正讨厌哥哥的妹妹（仅限共通）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n永远\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n十秒钟的勇气\r\n\r\n\r\n\r\n《挚爱随行，倾慕相伴》\r\n\r\n\r\n兄控级\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n92分\r\n调皮可爱\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n游戏中相爱，妹妹表现很好，就是h有点多坏好感\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n咲姬\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n锁住彼此的感情\r\n\r\n\r\n\r\n《妹锁》\r\n\r\n\r\n迷惑级\r\n实木色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n优等生\r\n距离\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹人设还行，剧情CG也比较甜，感情线不行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n真由\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n只有你能让我感到安宁\r\n\r\n\r\n\r\n《真由是只属于哥哥的》\r\n\r\n\r\n保护级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n妹单\r\n美少女\r\n95分\r\n胆小主动\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n各方面一般，没有啥优点也没啥缺点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n红星阳菜\r\n\r\nSX颜\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：凑合\r\n只为让你爱上我\r\n\r\n\r\n\r\n《LAMUNATION》\r\n\r\n\r\n宠溺级\r\n金发\r\n亲妹\r\n欧尼酱\r\n无厘头\r\n美少女\r\n85分\r\n母系\r\n亲密\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG很美，剧情太无厘头，无聊\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仁科十花\r\n\r\nSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n愿你的笑容永不凋零\r\n\r\n\r\n\r\n《伊人天使妹侧畔》\r\n\r\n\r\n天降级\r\n浅粉红\r\n天降实妹\r\n老哥\r\n废萌\r\n美少女\r\n81分\r\n活泼\r\n一见钟情\r\n天降\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹设定不行，剧情逻辑不通，没有啥实妹感\r\n\r\n\r\n\r\n\r\n天降实妹，逆天操作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n三衣珠树\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：不错\r\n你就是我的英雄\r\n\r\n\r\n\r\n《将军大人风华正茂》\r\n\r\n\r\n夫妻级\r\n浅粉红\r\n义妹\r\n欧尼酱\r\n穿越\r\n美少女\r\n100分\r\n撒娇可爱\r\n亲密无间\r\n妹被收养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n穿越剧，兄控，感情线不错，兄妹关系好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n孔瑞丽（全年龄）\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：负极好\r\n世间永恒的爱恋\r\n\r\n\r\n\r\n《鬼哭街》重制版，设定有牛\r\n\r\n\r\n复仇级\r\n玫瑰红/蓝\r\n亲妹\r\n兄长大人\r\n剧情作\r\n美少女\r\n94/88分\r\n贤淑/病娇\r\n亲密\r\n？？？\r\n？？？\r\n\r\n\r\n\r\n\r\n\r\n战斗\r\nB\r\n妹妹设定吓退90%玩家，废萌玩家勿入→→→\r\n\r\n\r\n\r\n\r\n不好评价，对某些人也算牛，萌豚勿入\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浅井花音\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：良好\r\n挑战我作为妹妹的极限\r\n\r\n\r\n\r\n《G弦上的魔王》\r\n\r\n\r\n成长级\r\n玫瑰红\r\n义妹\r\n欧尼酱\r\n斗智作\r\n美少女\r\n97分\r\n任性外向\r\n认知\r\n男主死父\r\n独居，兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n斗智斗勇\r\nA\r\n成长型妹妹，喜爱哥哥，剧情不错，感情线可以\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤仓雅\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：一般\r\n被妹妹爱慕着是哥哥的荣耀\r\n\r\n\r\n\r\n《铳骑士》\r\n\r\n\r\n依靠级\r\n粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n双重人格\r\n亲密\r\n父死母游\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n妹妹戏份足，感情线还行人设可爱，但剧情幼儿化\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n树里\r\n\r\nSS\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：优秀\r\n除了哥哥我谁也不要\r\n\r\n\r\n\r\n《腐姬》设定有牛\r\n\r\n\r\n病娇姬\r\n暗灰色\r\n？？？\r\n欧尼酱\r\n轮回作\r\n萝莉\r\n82分\r\n病娇\r\n亲密\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n悬疑\r\nB\r\n妹妹戏份非常少不能推，但剧情特别牛逼，悬疑→\r\n\r\n\r\n\r\n\r\n不好评价，对某些人也算牛，萌豚勿入\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第6批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n长谷川菜乃\r\n\r\nSSS妹控\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：优秀\r\n没有谁比你更重要\r\n\r\n\r\n\r\n《雪歌》\r\n\r\n\r\n兄妹级\r\n棕色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼撒娇\r\n仅此二人\r\n妹妹被养\r\n兄妹同居\r\n\r\n裸体围裙，三连问\r\n\r\n\r\n超级妹控\r\n兄妹\r\nB\r\n称为世界第一妹控哥哥不为过\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘木理帆\r\n\r\nSSS温馨\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：不错\r\n我的世界不能没有你\r\n\r\n\r\n\r\n《家有妹妹》\r\n\r\n\r\n兄妹级\r\n褐玫瑰红\r\n亲妹\r\n欧尼酱\r\n妹单\r\n美少女\r\n100分\r\n活泼可爱\r\n真兄妹\r\n正常\r\n兄妹同居\r\n\r\n三连问\r\n\r\n\r\n\r\n\r\nA\r\n除了结局开放外没有什么缺点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n御城由乃\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n我们是命中注定的\r\n\r\n\r\n\r\n《自黯淡之刻的尽头》\r\n\r\n\r\n穿越\r\n浅粉\r\n亲妹\r\n欧尼酱\r\n末日\r\n萝莉\r\n100分\r\n撒娇开朗\r\n兄妹\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n氛围轮回作\r\n\r\n\r\n\r\n\r\n带点恐怖，有很现实的be\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n橘 皋月\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n兄控大作战\r\n\r\n\r\n\r\n《Stellar☆Theater encore》\r\n\r\n\r\n兄控级\r\n·蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n兄控\r\n兄控\r\n正常\r\n兄妹同居\r\n\r\n裸体围裙，三连问\r\n\r\n\r\n重度兄控\r\nFD\r\nA\r\n完美的妹妹，而且兄控，FD才能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n黑瀨樱良\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：还行\r\n在一起是我们追求的命运\r\n\r\n\r\n\r\n《相见5分属于我，时间停止和不可避的命运》\r\n\r\n\r\n兄控级\r\n黑发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n100分\r\n温柔宁静\r\n依赖\r\n妹受伤\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n感情线不错，温馨甜蜜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n月见里 水雪\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n守护哥哥的幸福\r\n\r\n\r\n\r\n《未来收音机与人工鸽》\r\n\r\n\r\n守护级\r\n暗灰色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼外向\r\n吸引注意\r\n妹被收养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n真女主光环过强，妹线还是可以的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n时谷忍\r\n\r\nSA\r\n妹妹：不错\r\n兄妹：稀烂\r\n妹线：不太行\r\n愿成你妹\r\n\r\n\r\n\r\n《缘契初情乃今家舍妹》\r\n\r\n\r\n相伴级\r\n灰蓝色\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n84分\r\n温柔优等\r\n隔阂\r\n成兄妹\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n血压升高作，男主死活不接受妹妹表白\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n深峰莉子\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：还行\r\n留下彩虹以及对你的思念\r\n\r\n\r\n\r\n《永不消失的彩虹 Gift》\r\n\r\n\r\n兄妹级\r\n深红色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n温柔高冷\r\n思念\r\n被分开\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n日常感情戏很好，表现似亲妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nMeru\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n她的微笑如此美丽，但眼中充满悲伤\r\n\r\n\r\n\r\n《Millia -The ending》\r\n\r\n\r\n依靠\r\n金发\r\n义妹\r\n哥哥\r\n短篇\r\n美少女\r\n89分\r\n文静\r\n相依为命\r\n父母双亡\r\n兄妹同居\r\n\r\n裸体围裙\r\n\r\n\r\n\r\n\r\nC\r\n无语音，悲伤作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n瀨真梢\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n眼里只有哥哥\r\n\r\n\r\n\r\n《白恋SAKURA＊GRAM》\r\n\r\n\r\n喜爱级\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n89分\r\n害羞胆小\r\n亲密\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n隐藏可推角色，表现还行，戏份比较少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n希露菲·克劳德\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n回到兄妹时光\r\n\r\n\r\n\r\n《回转苹果亭的一千零一夜》\r\n\r\n\r\n重逢级\r\n褐色\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n纯洁无暇\r\n重逢\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n重逢感情做的很好，妹妹很圣洁\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新见雪月\r\n\r\nSSS兄妹\r\n妹妹：极好\r\n兄妹：极好\r\n妹线：极好\r\n创造属于我们兄妹自己的形式\r\n\r\n\r\n\r\n《银色遥远》\r\n\r\n\r\n兄妹级\r\n黑发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n温柔贤惠\r\n亲密\r\n正常\r\n家庭生活\r\n\r\n裸体围裙\r\n\r\n\r\n\r\n\r\nA\r\n时间跨度很大，非常棒的妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n葉山莉寿\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：良好\r\n哥哥胜任之路\r\n\r\n\r\n\r\n《凝视那侧脸》\r\n\r\n\r\n守护级\r\n实木色\r\n义妹\r\n欧尼酱\r\n黑深残\r\n美少女\r\n91分\r\n活泼可爱\r\n伪亲密\r\n妹被收养\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n黑马，意外感情线不错，就是有点暗黑\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n朝雾麻衣\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n一直一直喜欢你\r\n\r\n\r\n\r\n《更胜黎明前的琉璃色》\r\n\r\n\r\n家庭级\r\n桃色\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n92分\r\n天真活泼\r\n喜欢\r\n破镜重圆\r\n姐兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n无血缘，姐兄妹破镜重圆的故事\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n皇城一花\r\n\r\nSS颜\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：一般\r\n宛如鲜花绽放\r\n\r\n\r\n\r\n《恋慕之心的交织方式》\r\n\r\n\r\n颜值级\r\n紫发\r\n义妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n91分\r\n善解人意\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nFD必推，除了流程短没有什么缺点\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n高乃椎凪\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n彼此一如既往\r\n\r\n\r\n\r\n《雪境迷途遇仙踪》\r\n\r\n\r\n温情级\r\n蓝发\r\n亲妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n96分\r\n温情\r\n亲密\r\n正常\r\n多女主居住\r\n\r\n膝枕\r\n\r\n\r\n\r\n\r\nA\r\n废萌，中规中矩\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n永仓小夏\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n人气声优养成\r\n\r\n\r\n\r\n《人气声优的养成方式》\r\n\r\n\r\n平常级\r\n实木色\r\n亲妹\r\n欧尼酱\r\n声优\r\n美少女\r\n84分\r\n勤奋努力\r\n平常\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n缺少兄妹单独剧情，表现一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n水泽巡\r\n\r\nS颜\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：拉跨\r\n寻找救赎\r\n\r\n\r\n\r\n《罪恋X2/3》\r\n\r\n\r\n颜值级\r\n紫发\r\n义妹\r\n欧尼桑\r\n狗血\r\n美少女\r\n81分\r\n外热内冷\r\n还行\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n颜值是真的高，剧情也是真的狗血，不太建议推\r\n\r\n\r\n\r\n\r\n三角恋狗血剧情，谨慎推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第7批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n青葉英梨歌\r\n\r\nSSS妹控\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n被尘封的爱恋\r\n\r\n\r\n\r\n《猫神大人与七颗星星》\r\n\r\n\r\n兄妹级\r\n金发\r\n亲妹\r\n欧尼酱/桑\r\n妹单\r\n美少女\r\n100分\r\n撒娇可爱\r\n亲密无间\r\n被母虐待\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n妹控\r\n兄妹\r\nS\r\n非常稀有的妹单佳作，完全符合我的兴趣\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n宝交祐佳\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n化作灯塔，指引你前进的方向\r\n\r\n\r\n\r\n《Berry’s》\r\n\r\n\r\n指引级\r\n棕色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n害羞胆小\r\n温和\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n先上车后补票，感情有点担忧\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n汀龙子\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n妹控勇往直前\r\n\r\n\r\n\r\n《こんそめ！～combination somebody～\r\n\r\n\r\n守护级\r\n浅粉\r\n义妹\r\n尼尼\r\n废萌\r\n美少女\r\n95分\r\n高冷撒娇\r\n重逢\r\n青梅\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n改邪归正，不可多得的妹作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤白乃绘里\r\n\r\nSA颜\r\n妹妹：极好\r\n兄妹：稀烂\r\n妹线：拉跨\r\n妹想妹而妹非妹\r\n\r\n\r\n\r\n《Dal Segno》\r\n\r\n\r\n\r\n·金发\r\n表/堂妹\r\n欧尼\r\n废萌\r\n美少女\r\n88分\r\n活泼可爱\r\n隔阂\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n亲妹不能推，男主不把表妹当妹，妹控慎推\r\n\r\n\r\n\r\n\r\n男主不随表妹意，只认亲妹却没线，表妹没得说标准妹妹形象\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n蜜娜\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n此生只为守护尼\r\n\r\n\r\n\r\n《猎人学院2》回合制RPG\r\n\r\n\r\n守护级\r\n暗灰色\r\n表/堂妹\r\n名字\r\nRPG\r\n美少女\r\n95分\r\n善良温柔\r\n相依为命\r\n父母双亡\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\nRPG\r\nB\r\n兄妹感情很好，很甜，但非gal而是rpg\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n稜祁祥那\r\n\r\nSSS萝莉\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：负极好\r\n永世爱恋\r\n\r\n\r\n\r\n《少女神域~少女天狱》be污点\r\n\r\n\r\n萝莉级\r\n粉色\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n萝莉\r\n100分\r\n天真无邪\r\n兄妹情\r\n父母双亡\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n刀多，be像雷，无牛，真萝莉，后期剧情精彩，\r\n\r\n\r\n\r\n\r\nbe是污点，只走TE那就是全年龄，其他女主线可能有大雷\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n喜多芽衣\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：一般\r\n不想让你担心\r\n\r\n\r\n\r\n《正负战争》\r\n\r\n\r\n隐藏级\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n84分\r\n勤劳能干\r\n隐藏\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n隐藏的感情可不太好，距离感也不太行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n忧姬（全年龄）\r\n\r\nSX\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：一般\r\n带你穿越黑暗\r\n\r\n\r\n\r\n《NOeSIS羽化》\r\n\r\n\r\n爱护级\r\n蓝发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n坚强能干\r\n漠视\r\n？？？\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n剧情有些阴暗，妹线男主才重视妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n待雪亚芽\r\n\r\nSA颜\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：凑合\r\n重新开始的关系\r\n\r\n\r\n\r\n《不可视之药与坎坷的命运》\r\n\r\n\r\n\r\n粉色\r\n表/堂妹\r\n欧尼桑\r\n废萌\r\n美少女\r\n85分\r\n小傲娇\r\n阻碍\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nh过早，感情不到位，发展离谱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n朝仓音梦\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n好想、好想和你在一起\r\n\r\n\r\n\r\n《初音岛1》\r\n\r\n\r\n珍惜级\r\n实木色\r\n义妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n95分\r\n兄控活泼\r\n兄控\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n感情更加自然，前期发糖后期虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n速濑真奈美\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n一直相伴的思念\r\n\r\n\r\n\r\n《神风探索者》\r\n\r\n\r\n牵挂级\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n兄控活泼\r\n撒娇\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹超兄控，表白很棒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n结城铃（全年龄）\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：还行\r\n妹控是如何速成的？\r\n\r\n\r\n\r\n《女仆咖啡巧克拉》\r\n\r\n\r\n温馨级\r\n实木色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n94分\r\n内向孤僻\r\n伪兄妹\r\n妹被收养\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n家庭温馨感不错，妹妹占有欲强的不建议推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n津云\r\n\r\nSS\r\n妹妹：负不错\r\n兄妹：还行\r\n妹线：负一般\r\n欧尼酱~欧尼酱\r\n\r\n\r\n\r\n《九十九之月》\r\n\r\n\r\n迷途级\r\n白毛\r\n？？？\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n娇小可爱\r\n眩晕\r\n？？？\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n另一个妹妹操作让人不适，狂虐本妹\r\n\r\n\r\n\r\n\r\n假妹太虐真妹，痛苦之作，谨慎推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n葛木 姫乃\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n想要传达给你的爱恋\r\n\r\n\r\n\r\n《D.C.III R～ダ・カーポIII アール～ X-rated》\r\n\r\n\r\n亲密级\r\n棕色\r\n义妹\r\n尼桑\r\n废萌\r\n美少女\r\n99分\r\n固执温柔\r\n亲密无间\r\n兄被收养\r\n学校住宿\r\n\r\n公主抱\r\n\r\n\r\n\r\n\r\nB\r\n义妹但亲密度似亲妹，建议只推前世妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n佐久真 诗\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n献出我的契约之吻\r\n\r\n\r\n\r\n《我的恋天使太废材了好可怕》\r\n\r\n\r\n恋爱级\r\n桃色\r\n义妹\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n痴女温柔\r\n男女\r\n正常\r\n兄妹同居\r\n\r\n摸头杀，婚纱，裸体围裙\r\n\r\n\r\n\r\n\r\nS\r\n标准废萌，妹妹兄控好评，成痴女了\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n柳瀬 詠歌\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n兄控无极限\r\n\r\n\r\n\r\n《突然发现我已恋上你》\r\n\r\n\r\n兄控级\r\n灰色\r\n亲妹\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n兄控毒舌\r\n恋爱\r\n父母失踪\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n兄控到一夜白头乃第一人，自慰狂魔\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第8批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n作品\r\n\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n黑崎小夜\r\n\r\nSX\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：还行\r\n血液继承生命的温暖\r\n\r\n\r\n\r\n《青鸟》\r\n\r\n\r\n相遇级\r\n暗灰色\r\n双胞胎\r\n名字\r\n剧情向\r\n美少女\r\n89分\r\n抖S\r\n强硬\r\n？？？\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n强硬抖S妹，开局男主H很多贴脸，设定像拔作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n常坂二乃\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n一起活下去的约定\r\n\r\n\r\n\r\n《初音岛4》2个版本声优不一样\r\n\r\n\r\n颜萌级\r\n黑发\r\n义妹\r\n尼桑/欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n温柔可爱\r\n亲密无间\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n作为废萌还可以，作为初音岛系列就差不少\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n新山葵\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n爱的赞歌\r\n\r\n\r\n\r\n《秋色恋華》\r\n\r\n\r\n粉丝级\r\n棕色\r\n义妹\r\n欧尼酱\r\n废萌\r\n偶像\r\n89分\r\n活泼开朗\r\n粉丝\r\n正常\r\n兄妹分居\r\n\r\n\r\n\r\n\r\n\r\n偶像\r\nB\r\n注重偶像的绯闻，声音俏皮，整体不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n夏本 讽歌\r\n\r\nSAAA\r\n妹妹：良好\r\n兄妹：负不错\r\n妹线：一般\r\n别，别碰我......会怀孕的\r\n\r\n\r\n\r\n《魔卡魅恋》\r\n\r\n\r\n萝莉傲娇级\r\n浅蓝发\r\n亲妹\r\n尼桑\r\n废萌\r\n萝莉\r\n95分\r\n傲娇可爱\r\n不肯承认\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n妹控\r\n\r\nA\r\n超可爱傲娇巨乳萝莉\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n茅崎夕樱\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：一般\r\n想要坚守爱你的信念\r\n\r\n\r\n\r\n《水葬银货》\r\n\r\n\r\n守护级\r\n粉红\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n100分\r\n古灵精怪\r\n？？？\r\n？？？\r\n多女主同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nS\r\n妹妹可靠能干，兄控言论满天飞，TE表现最佳\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n三谷 歩夢（全年龄）\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：良好\r\n我就是你的妹妹\r\n\r\n\r\n\r\n《现在立刻就想对哥哥说我是妹妹！》\r\n\r\n\r\n温柔级\r\n浅肉色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n勤劳能干\r\n隐藏\r\n再婚\r\n家庭生活\r\n\r\n隐藏妹妹身份的佳作\r\n\r\n\r\n\r\n\r\nB\r\n除了妹妹男装隐藏身份，其他都不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n飞鹰春奈\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：一般\r\n妹线：凑合\r\n迟到的感情\r\n\r\n\r\n\r\n《格林花园的少女》\r\n\r\n\r\n\r\n粉红色\r\n双胞胎\r\n名字\r\n废萌\r\n美少女\r\n75分\r\n孤僻坚强\r\n？？？\r\n？？？\r\n？？？\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n挂羊头卖狗肉，不建议推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n远野律\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：良好\r\n妹线：凑合\r\n命运共同体\r\n\r\n\r\n\r\n《闪耀青春追着逐记》\r\n\r\n\r\n依靠级\r\n茶色\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n95分\r\n兄控可爱\r\n可爱\r\n正常\r\n兄妹同居\r\n\r\n婚纱\r\n\r\n\r\n兄控\r\n\r\nB\r\n配角待遇，隐藏可推，流程短妹线剧情过于刻意\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n沢渡 满\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：还行\r\n妹线：还行\r\n你是我的眼\r\n\r\n\r\n\r\n《克洛的时钟》\r\n\r\n\r\n守护级\r\n黑发\r\n亲妹\r\n尼桑满\r\n废萌\r\n美少女\r\n96分\r\n兄控温柔\r\n还行\r\n？？？\r\n兄妹分居\r\n\r\n\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n兄妹描述的不够多，但家庭温馨感很不错，注重妹妹的成长\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n八重垣 瑠璃\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n兄妹携手迈向未来\r\n\r\n\r\n\r\n《交汇协奏曲》\r\n\r\n\r\n拯救级\r\n白毛\r\n双胞胎\r\n尼桑/欧尼酱\r\n废萌\r\n美少女\r\n95分\r\n兄控温柔\r\n粘人\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n妹妹南原声音好听，私下粘人，剧情差点意思\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n如月 もも\r\n\r\nS\r\n妹妹：良好\r\n兄妹：一般\r\n妹线：不太行\r\n成为欧尼酱心中的第一\r\n\r\n\r\n\r\n《抚子革命 ナデレボ！》\r\n\r\n\r\n\r\n棕色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n活泼兄控\r\n？？？\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n本体不如青梅，if线满好感动，流程短\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n山吹爱丽丝\r\n\r\nSAAA\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：一般\r\n姐妹花，兄妹心\r\n\r\n\r\n\r\n《星之少女与六华的姐妹》\r\n\r\n\r\n姐妹级\r\n蓝色\r\n义妹\r\n尼尼\r\n废萌\r\n美少女\r\n97分\r\n兄控怕生\r\n当世无双\r\n正常\r\n学校住宿\r\n\r\n婚纱\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n颜值爆表，撒娇可爱还卖萌，写作兄妹，读作姐妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n春日野穹\r\n\r\nSSS妹\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：不错\r\n悠远的苍穹下，紧密相连的羁绊\r\n\r\n\r\n\r\n《缘之空》\r\n\r\n\r\n傲娇\r\n白毛\r\n亲妹\r\n名字\r\n废萌\r\n美少女\r\n100分\r\n傲娇，温情\r\n无你不活\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n妹控必经历的里程碑，恨妹不是穹，什么是兄妹恋？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n千惠\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n处男哥与反坑妹\r\n\r\n\r\n\r\n《童贞兄妹》\r\n\r\n\r\n相亲\r\n黑色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n傲娇，人精\r\n自然\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n感情铺垫不是很够，认ai当妹影响剧情，h过多\r\n\r\n\r\n\r\n\r\n多种性格选择\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n友坂玲夏\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：不错\r\n妹控初心\r\n\r\n\r\n\r\n《波子汽水》\r\n\r\n\r\n兄妹同心\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉/美少女\r\n95分\r\n温顺\r\n未曾不喜欢\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n非常优秀的童年剧情（萝莉体型），长大后再续前缘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n库可\r\n\r\nSA\r\n妹妹：不错\r\n兄妹：一般\r\n妹线：凑合\r\n你的鲨鱼我的妹\r\n\r\n\r\n\r\n《与鲨鱼共度的七日之间》\r\n\r\n\r\n隐藏\r\n白毛\r\n亲妹\r\n欧尼酱\r\n剧情向\r\n美少女\r\n40分\r\n天真无邪\r\n鲨鱼\r\n？？？\r\n兄妹同居\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n剧情尚可，但隐藏妹，毫无妹属性\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n谷风天音\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n杂鱼欧尼酱~\r\n\r\n\r\n\r\n《天使☆纷扰 RE-BOOT!》\r\n\r\n\r\n兄妹\r\n粉红\r\n亲妹\r\n欧尼酱/欧尼\r\n废萌\r\n美少女\r\n100分\r\n雌小鬼\r\n被埋藏\r\n正常\r\n兄妹同居\r\n\r\n膝枕，婚纱\r\n\r\n\r\n\r\n\r\nA\r\n柚子社第一位实妹，很甜很现实的兄妹关系，没有伦理\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n生肉妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n生肉gal\r\n\r\n\r\n翻译补丁网址 https://galge.fun/subjects\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第1批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n生肉\r\n\r\n\r\n汉化/翻译\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n千ヶ崎 入莉\r\n\r\nSSS救赎\r\n妹妹：负极好\r\n兄妹：极好\r\n妹线：优秀\r\n在探寻爱与希望的道路上不断前进\r\n\r\n\r\n\r\n《終わる世界とバースデイ》\r\n\r\n\r\n世界终结与生日快乐\r\n\r\n救赎级\r\n浅钢兰\r\n义妹\r\n欧尼桑\r\n剧情作\r\n美少女\r\n96分\r\n病弱孤独\r\n守护\r\n？？？\r\n兄妹同居\r\n\r\n妹控杀手\r\n\r\n\r\n超妹控\r\n感人/催泪\r\nS\r\n又一催泪神作，看兄妹如何相互救赎\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n爱沢花穗\r\n\r\nSSS甜\r\n妹妹：完美\r\n兄妹：极好\r\n妹线：极好\r\n今生今世永不分离\r\n\r\n\r\n\r\n《ラブラブル～Lover Able～》FD：《同棲ラブラブル》\r\n\r\n\r\n情侣热恋中\r\n\r\n甜蜜级\r\n蓝发\r\n亲妹\r\n欧尼桑/酱\r\n废萌\r\n美少女\r\n100分\r\n小恶魔\r\n亲密无双\r\n正常\r\n兄妹同居\r\n\r\n甜死人不偿命\r\n\r\n\r\n\r\n甜蜜\r\nB\r\n超甜妹作，当世无双\r\n\r\n\r\n\r\n\r\n甜度神中神，FD甚至更优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n此花茉莉\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n相守一生\r\n\r\n\r\n\r\n《Marguerite Sphere -マーガレット スフィア- 》\r\n\r\n\r\n《丽特的占卜星》共通汉化\r\n\r\n双子级\r\n金发\r\n双胞胎\r\n欧尼酱\r\n废萌\r\n美少年\r\n100分\r\n双重人格\r\n忽冷忽热\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n感情发展，表白，伦理都处理的还可以\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n御法 光\r\n\r\nSSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n愿你只在我的身旁\r\n\r\n\r\n\r\n《運命予報をお知らせします》\r\n\r\n\r\nAI翻译\r\n\r\n陪伴级\r\n粉红色\r\n亲妹\r\n欧尼酱/桑\r\n废萌\r\n美少女\r\n94分\r\n冷静稳重\r\n兄控\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通发力表白优秀，怎么会拒绝这么可爱的妹妹呢\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n初駒ルリ\r\n\r\nSSS亲情\r\n妹妹：负完美\r\n兄妹：极好\r\n妹线：优秀\r\n陪你渡过幸福的一生\r\n\r\n\r\n\r\n《ルリのかさね ～いもうと物語り》\r\n\r\n\r\nAI翻译\r\n\r\n家人级\r\n黑发\r\n侄女\r\n欧尼酱\r\n温情\r\n萝莉\r\n94分\r\n相依为命\r\n非你莫属\r\n父母双亡\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n亲情\r\nA\r\n亲情描写最强作，最纯粹的家人情感\r\n\r\n\r\n\r\n\r\n3条妹线，萝莉神中神，时间跨度大，催泪\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n香原瑞希\r\n\r\nSSS傲暴\r\n妹妹：负极好\r\n兄妹：负不错\r\n妹线：不错\r\n兄妹回归初心\r\n\r\n\r\n\r\n《かみぱに!》\r\n\r\n\r\n\r\n\r\n傲暴级\r\n浅粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n97分\r\n暴力独占\r\n回归\r\n阴影\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n感情发展稳定优秀，暴力妹妹比较少见\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仲神 かすが\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：凑合\r\n恋人宣言\r\n\r\n\r\n\r\n《ひだまりバスケット 》\r\n\r\n\r\nAI翻译\r\n\r\n活泼级\r\n实木色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n活泼可爱\r\n妹主\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通优秀，妹线走下坡路，伦理没有写好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n夏島 みさき\r\n\r\nS\r\n妹妹：还行\r\n兄妹：还行\r\n妹线：凑合\r\n那一天，我对妹妹恋爱了\r\n\r\n\r\n\r\n《ナマイキデレーション》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n蓝发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n85分\r\n傲娇冷酷\r\n吸引\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n缺少感情转折，铺垫，很一般，像拔作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n浅坂爱莉\r\n\r\nSSS巫女\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n爱上你是我的荣幸\r\n\r\n\r\n\r\n《妹のおかげでモテすぎてヤバい》\r\n\r\n\r\n因为妹妹太受欢迎了糟糕了\r\n\r\n相爱级\r\n金发\r\n亲妹\r\n尼桑\r\n废萌\r\n美少女\r\n100分\r\n活泼兄控\r\n真女主\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n各方面都很棒，声音还好听，妹妹真女主待遇\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小町谷 菜砂\r\n\r\nSSS温情\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n无限缩短彼此的距离\r\n\r\n\r\n\r\n《ココロネ=ペンデュラム》\r\n\r\n\r\nAI翻译\r\n\r\n思念级\r\n粉红\r\n亲妹\r\n啊尼给\r\n废萌\r\n美少女\r\n96分\r\n高傲兄控\r\n前辈\r\n分开3年\r\n学校住宿（同居）\r\n\r\n黑色枕大腿\r\n\r\n\r\n\r\n\r\nS\r\n前辈型妹妹，比较甜，兄妹感情发展优秀\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n丹生 佳津美\r\n\r\nSSA\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n你就是我的恋慕之心\r\n\r\n\r\n\r\n《コドモノアソビ》\r\n\r\n\r\nAI翻译\r\n\r\n恋情级\r\n紫发\r\n亲妹\r\n尼桑/欧尼\r\n废萌\r\n萝莉\r\n91分\r\n兄控高冷\r\n隐藏\r\n3年未认\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n开始高冷，进线主动，害羞可爱至极\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n白咲 ひな\r\n\r\nSSS撒娇\r\n妹妹：不错\r\n兄妹：负不错\r\n妹线：良好\r\n啊~哥哥雷达有反应啦！\r\n\r\n\r\n\r\n《SuGirly Wish》\r\n\r\n\r\nAI翻译\r\n\r\n喜欢级\r\n白杏色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n活泼可爱\r\n接近\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n超兄控\r\n\r\nB\r\n精力爆表，超喜欢哥哥，想成为哥哥的恋人\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n美野里 巴\r\n\r\nSA\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n尽情撒娇吧，妹妹\r\n\r\n\r\n\r\n《QUINTUPLE☆SPLASH》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n黑发\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n傲娇严厉\r\n隐藏\r\n正常\r\n学校住宿（同居）\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n画风可爱，CG很棒，但感情变化过快，剧情一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n遠海 佐奈\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n我们不i可分离\r\n\r\n\r\n\r\n《Angel Ring》\r\n\r\n\r\nAI翻译\r\n\r\n相思级\r\n实木色\r\n亲妹\r\n啊尼给\r\n废萌\r\n美少女\r\n95分\r\n暴力能干\r\n隐藏\r\n正常\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通非常棒，妹线感情变化不自然，犹豫不决\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n麻生 こま\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n相思成双\r\n\r\n\r\n\r\n《めぐり、ひとひら。》\r\n\r\n\r\n\r\n\r\n思念级\r\n棕色\r\n义妹\r\n欧尼酱\r\n带点剧情\r\n美少女\r\n93分\r\n善良温柔\r\n思念\r\n？？？\r\n多女主居住\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n人设很好，共通日常过长，剧情反转过于简单\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n燕子花 こりす\r\n\r\nSS\r\n妹妹：极好\r\n兄妹：负良好\r\n妹线：一般\r\n期待着回心转意\r\n\r\n\r\n\r\n《めぐり、ひとひら。》\r\n\r\n\r\n\r\n\r\n追寻级\r\n白毛\r\n青梅\r\n尼桑\r\n剧情向\r\n美少女\r\n90分\r\n温柔贤惠\r\n不高\r\n追寻\r\n住宿\r\n\r\n苦苦追寻男主，毅力最强之妹\r\n\r\n\r\n重度兄控\r\n\r\nS\r\n画风古老颜值依旧在，啥都好，可惜男主只在乎真妹妹\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第2批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n翻译补丁网址 https://galge.fun/subjects\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n生肉\r\n\r\n\r\n汉化/翻译\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n岛津朗\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n天才在左，废柴在右\r\n\r\n\r\n\r\n《木洩れ陽のノスタルジーカ》\r\n\r\n\r\n\r\n\r\n依赖级\r\n黑发\r\n义妹\r\n欧尼酱\r\n科技废萌\r\n美少女\r\n84分\r\n活泼开朗\r\n依赖\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n妹妹设定优秀，但表现拉跨，兄妹戏份不够多\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n常盘木 雪\r\n\r\nSX\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：一般\r\n编织属于我们的童话\r\n\r\n\r\n\r\n《雲上のフェアリーテイル》\r\n\r\n\r\nAI翻译\r\n\r\n公主级\r\n白毛\r\n亲妹\r\n哥哥大人\r\n废萌\r\n公主\r\n93分\r\n温文尔雅\r\n兄控\r\n分离几年\r\n住宿\r\n\r\n首个公主妹妹\r\n\r\n\r\n兄控\r\n公主\r\nS\r\n妹妹非常棒，但剧情不行，老套，无聊\r\n\r\n\r\n\r\n\r\nCG好看，剧情略显幼稚，而且非纯爱，在共通有男主跟其他女主h\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n双見 伊織（织）\r\n\r\nSSS宠物\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n妹妹宠物\r\n\r\n\r\n\r\n《Love Sweets》\r\n\r\n\r\nAI翻译\r\n\r\n粘人级\r\n黑发\r\n亲妹\r\n尼桑\r\n温情\r\n美少女\r\n100分\r\n文静粘人\r\n亲密无间\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n文静可爱的妹妹谁不想守护呢？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n神木彩花\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n兄妹的纯真\r\n\r\n\r\n\r\n《夏彩恋唄》\r\n\r\n\r\n夏彩恋歌\r\n\r\n萝莉级\r\n浅黄红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n93分\r\n活泼可爱\r\n粘人\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n活泼可爱萝莉妹妹，可惜流程短，感情线一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n大日向 ルイ\r\n\r\nSA\r\n妹妹：还行\r\n兄妹：良好\r\n妹线：一般\r\n心灵一体\r\n\r\n\r\n\r\n《ノブレスオブルージュ -Noblesse of Rouge》\r\n\r\n\r\nAI翻译\r\n\r\n温柔级\r\n黑发\r\n双胞胎\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n温柔优等\r\n兄妹一体\r\n正常\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n男主女装代替妹妹上学，流程短\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n十崎由衣\r\n\r\nSSS甜/虐\r\n妹妹：完美\r\n兄妹：还行\r\n妹线：优秀\r\n血脉相连至不可分离的羁绊\r\n\r\n\r\n\r\n《ALMA～ずっとそばに…～》\r\n\r\n\r\n\r\n\r\n喜与悲\r\n红发\r\n亲妹\r\n欧尼酱\r\n天堂与地狱\r\n美少女\r\n100分\r\n贤妻良母\r\n超级兄控\r\n？？？\r\n兄妹同居\r\n\r\n天堂与地狱同在\r\n\r\n\r\n兄控\r\n\r\nC\r\n妹人妻属性拉满，前期多甜后期多虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n藤宮凛\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：一般\r\n妹线：一般\r\n一生妹，一生随\r\n\r\n\r\n\r\n《よくばりサボテン》\r\n\r\n\r\n\r\n\r\n信念级\r\n白毛\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n活泼兄控\r\n妹攻哥受\r\n分离多年\r\n兄妹同居\r\n\r\n婚纱\r\n\r\n\r\n\r\n\r\nS\r\n白毛长发.猫耳，妹妹不错，男主比较懦弱\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n海棠 璃々子\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n融入血缘的喜欢\r\n\r\n\r\n\r\n《サキガケ⇒ジェネレーション！》\r\n\r\n\r\nAI翻译\r\n\r\n萌兔级\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n中二缅甸\r\n甜蜜\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n中二\r\nS\r\n妹妹娇羞可爱又中二，白毛万岁\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小鸟游夜夜\r\n\r\nSSA\r\n妹妹：完美\r\n兄妹：稀烂\r\n妹线：拉跨\r\n留住回忆，锁住感情\r\n\r\n\r\n\r\n《Clover Point》\r\n\r\n\r\n四叶奇迹\r\n\r\n温柔级\r\n金发\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n温柔体贴\r\n兄控\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nA\r\n妹妹完美，男主太拉跨配不上妹妹\r\n\r\n\r\n\r\n\r\n妹妹太好，男主态度不行，还伤妹妹心\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n风祭 爱奈\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：还行\r\n妹线：还行\r\n守护在你的身旁\r\n\r\n\r\n\r\n《真夏の夜の雪物語 -MIDSUMMER SNOW NIGHT-》\r\n\r\n\r\n\r\n\r\n守护级\r\n金发\r\n表/堂妹\r\n尼桑\r\n废萌\r\n美少女\r\n86分\r\n勤劳能干\r\n异性\r\n？？？\r\n姐兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n颜值顶中顶，兄妹感不高，三个周目表现都不算好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第3批\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n翻译补丁网址 https://galge.fun/subjects\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n生肉\r\n\r\n\r\n汉化/翻译\r\n\r\n级别\r\n发色\r\n血缘\r\n称呼\r\n剧情\r\n形态\r\n妹力\r\n属性\r\n亲密度\r\n身世\r\n家庭生活\r\n\r\n荣誉\r\n\r\n\r\n妹控\r\n类型\r\n颜值\r\n感想\r\n\r\n\r\n\r\n\r\n提醒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n久我山 このか\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：优秀\r\n妹线：良好\r\n今生今世，与你相遇\r\n\r\n\r\n\r\n《プリズム◇リコレクション！》\r\n\r\n\r\nAI翻译\r\n\r\n贤惠可爱\r\n黑色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n100分\r\n温柔乖巧\r\n兄控\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n兄控\r\n\r\nS\r\n记录哥哥的天才少女，妹人设无敌，发糖也甜\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n天都早紗\r\n\r\nSSA\r\n妹妹：极好\r\n兄妹：良好\r\n妹线：良好\r\n爱的魔法\r\n\r\n\r\n\r\n《夏の魔女のパレード》\r\n\r\n\r\nAI翻译\r\n\r\n温柔体贴\r\n黑色\r\n义妹\r\n尼桑\r\n魔法学校\r\n美少女\r\n99分\r\n忠犬\r\n兄控\r\n与老妈不合\r\n学校住宿\r\n\r\n婚纱\r\n\r\n\r\n兄控\r\n\r\nS\r\n重度兄控妹妹求爱记，世界名画壁咚表白，\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n八坂可子\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：凑合\r\n无法抑制的喜欢\r\n\r\n\r\n\r\n《初音岛5》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n深灰色\r\n青梅\r\n尼桑\r\n废萌\r\n美少女\r\n69分\r\n柔情善良\r\n喜欢\r\n？？？\r\n姐兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n共通体验差，初音岛待遇最差的一妹妹，边缘化\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n莉丝·格里菲兹\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n为你而活为你而死，直至死亡将我们分离\r\n\r\n\r\n\r\n《シャマナ シャマナ～月とこころと太陽の魔法～》\r\n\r\n\r\n\r\n\r\n守护\r\n桃色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n85分\r\n淑女腼腆\r\n守护\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n超想守护的妹妹，柔弱腼腆，想撒娇却不敢行动\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n日向 なずな\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：一般\r\n守护这份情意\r\n\r\n\r\n\r\n《BLUE》\r\n\r\n\r\n\r\n\r\n恋爱\r\n黑色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n78分\r\n高冷\r\n外冷内热\r\n正常\r\n分开\r\n\r\n\r\n\r\n\r\n隐藏兄控\r\n\r\nB\r\n外冷内热型妹，隐藏兄控，流程短但算全，发糖不够\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n上杉朱乃\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：良好\r\n爱的鞭挞\r\n\r\n\r\n\r\n《俺の彼女のウラオモテ》\r\n\r\n\r\nAI翻译\r\n\r\n爱意\r\n黑色\r\n亲妹\r\n欧尼\r\n废萌\r\n美少女\r\n91分\r\n热情兄控\r\n兄控\r\n正常\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n在外骂哥哥，私下兄控，袒护哥哥，妹控福音\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n星央遥\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：一般\r\n爱上狮子的兔子\r\n\r\n\r\n\r\n《ガチ乙女クインテット》\r\n\r\n\r\n\r\n\r\n\r\n金发\r\n亲妹\r\n兄长大人\r\n废萌\r\n美少女\r\n95分\r\n温柔体贴\r\n喜欢\r\n正常\r\n兄妹同居\r\n\r\n摸头杀，婚纱\r\n\r\n\r\n\r\n\r\nC\r\n共通大量无关剧情且退其他女主线才能进，表现一般\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n宮沢 あきら\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n心房上的钥匙\r\n\r\n\r\n\r\n《ゆきいろ ～空に六花の住む町～》\r\n\r\n\r\n\r\n\r\n童年\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n98分\r\n温柔可爱\r\n粘人\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n童年戏份，超可爱，妹心理描写不错\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n雜賀ほたる\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：良好\r\n妹线：还行\r\n不可或缺的存在\r\n\r\n\r\n\r\nFD:《Whiteちょこっとファンディスク》\r\n\r\n\r\n\r\n\r\n\r\n粉红\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n胆小柔弱\r\n自始不变\r\n分开\r\n多女主同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n童年剧情优秀，但其他女主吃醋让人血压升高，仅FD有妹线\r\n\r\n\r\n\r\n\r\n其他女主抢男主特别恶心人，谨慎推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n臣苗 鈴\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n撒娇行动\r\n\r\n\r\n\r\n《ナツイロココロログ》\r\n\r\n\r\nAI翻译\r\n\r\n双妹泡芙\r\n桃色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n腼腆自卑\r\n隐藏\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n双重人格，精华在前，什么？能破妹两次处？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n一ノ瀬 乙葉\r\n\r\nSX\r\n妹妹：良好\r\n兄妹：还行\r\n妹线：还行\r\n你的梦魇我的心\r\n\r\n\r\n\r\n《幸福の食卓～しあわせのはね》\r\n\r\n\r\n\r\n\r\n灾恶\r\n黑发\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n86分\r\n村姑\r\n不得不爱\r\n父母再婚\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n相爱在一起是幸福的，同时也是悲剧的，痛苦是无尽的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n七枷 琴子\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：还行\r\n让我在爱你一次\r\n\r\n\r\n\r\n《猫撫ディストーション》有FD\r\n\r\n\r\n\r\n\r\n虚幻\r\n白毛\r\n亲妹\r\n尼桑\r\n剧情向\r\n天使\r\n95分\r\n贤淑温柔\r\n再爱一次\r\n？？？\r\n家庭生活\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\nCG超美，剧情冗长且哲学悲剧？？？？？？？？\r\n\r\n\r\n\r\n\r\n不是很推荐，只当收集好看CG妹还行\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n青野七\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：不错\r\n一日为亲，终生为妹\r\n\r\n\r\n\r\n《海と雪のシアンブルー》\r\n\r\n\r\nAI翻译\r\n\r\n义兄妹\r\n深红\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n温文尔雅\r\n积极上升\r\n开局义妹\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n，开局天降，从陌生人到兄妹再到恋人描写的非常好\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n早坂 羽未\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：一般\r\n影子下的阴影\r\n\r\n\r\n\r\n《春恋＊乙女～乙女の園でごきげんよう。～》\r\n\r\n\r\n\r\n\r\n继承\r\n浅玫瑰色\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n98分\r\n活泼开朗\r\n？？？\r\n？？？\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n妹妹可爱，发糖可，但妹线压抑\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n三枝 彩叶\r\n\r\nSSS萝莉\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：优秀\r\n我心永恒\r\n\r\n\r\n\r\n《ラムネ2》波子汽水2\r\n\r\n\r\nAI翻译\r\n\r\n兄控\r\n粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n萝莉\r\n100分\r\n直率兄控\r\n欧尼酱\r\n两天故事线\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n完全不同两条故事线，教科书式感情描述，但有点小虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n冬马琴未\r\n\r\nS\r\n妹妹：还行\r\n兄妹：凑合\r\n妹线：拉跨\r\n牵引着你的到来\r\n\r\n\r\n\r\n《私立アキハバラ学園》\r\n\r\n\r\n\r\n\r\n\r\n粉红\r\n？？？\r\n欧尼酱\r\n废萌\r\n美少女\r\n88分\r\n粘人\r\n喜欢\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n妹线反转极其拉跨，恶心人，不建议游玩\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n六桜 日奈々（全年龄\r\n\r\nSS\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：还行\r\n为你驱散黑暗\r\n\r\n\r\n\r\n《Primary ～Magical★Trouble★Scramble～》\r\n\r\n\r\nAI翻译\r\n\r\n可爱\r\n白毛\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n93分\r\n懂事兄控\r\n妹妹\r\n失明\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nA\r\n全年龄，兄控且令人怜爱的妹妹，男主十足的妹控\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n波佐見 都\r\n\r\nSAAA\r\n妹妹：极好\r\n兄妹：一般\r\n妹线：还行\r\n兄控进行史\r\n\r\n\r\n\r\n《南十字星恋歌》\r\n\r\n\r\n\r\n\r\n兄妹\r\n黑长直\r\n表/堂妹\r\n尼桑/欧尼酱\r\n废萌\r\n黑长直\r\n100分\r\n毒舌兄控\r\n喜欢喜欢\r\n分开\r\n学校住宿\r\n\r\n被膝枕，摸头杀\r\n\r\n\r\n\r\n\r\nS\r\n妹妹兄控黑长直无敌，但有大量党争以及现任哥剧情\r\n\r\n\r\n\r\n\r\n有前任哥（男主）与现任哥（会长）争妹剧情，不过妹妹只爱男主，有妹妹跟真女主党争剧情，而且男主有两个萝莉妹妹却不能推\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n舞浜 有梨子\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：优秀\r\n妹线：不错\r\n名为爱情的媚药\r\n\r\n\r\n\r\n《リトルプリンセスＧＯ！》\r\n\r\n\r\nAI翻译\r\n\r\n爱情\r\n茶色\r\n亲妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n96分\r\n冷漠热情\r\n暗恋\r\n正常\r\n家庭分开\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n一对兄妹，二次表白，三场约会，节节高升\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n速水 朝顔\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：一般\r\n爱的逃避行\r\n\r\n\r\n\r\n《ココロ＠ファンクション！》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n黑发\r\n亲妹\r\n尼桑\r\n废萌\r\n美少女\r\n93分\r\n社恐\r\n暗恋\r\n收养人死亡\r\n学校住宿\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nA\r\n感情戏略少，发糖在h，ai抢走大部剧情甜度\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n桧山 璃子\r\n\r\nSSA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n内心深处的依赖\r\n\r\n\r\n\r\n《さくらビットマップ》\r\n\r\n\r\nAI翻译\r\n\r\n隐藏兄控\r\n蓝发\r\n义妹\r\n欧尼酱/欧尼\r\n废萌\r\n美少女\r\n99分\r\n害羞温柔\r\n隐藏\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nS\r\n隐藏兄控，想撒娇，全文非常丝滑，大量发糖\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n初芝 愛衣\r\n\r\nSSS妹线\r\n妹妹：优秀\r\n兄妹：优秀\r\n妹线：优秀\r\n初恋之心\r\n\r\n\r\n\r\n《そらいろ》\r\n\r\n\r\n\r\n\r\n初恋\r\n粉红\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n纯朴天真\r\n爱恋\r\n情人成兄妹\r\n兄妹同居\r\n\r\n摸头杀\r\n\r\n\r\n\r\n\r\nB\r\n三条妹线极致的满足，精心打磨，稳步发展，小虐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n叶野 夢\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：一般\r\n妹线：还行\r\n交往游戏\r\n\r\n\r\n\r\n《夏の幼馴染と冬のカノジョ》\r\n\r\n\r\nAI翻译\r\n\r\n病弱\r\n灰石色\r\n亲妹\r\n尼\r\n废萌\r\n美少女\r\n93分\r\n病弱\r\n白送\r\n正常\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n开局好感度满，缺失感情铺垫日常发糖，感情升温\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n周防 ななの\r\n\r\nSAAA\r\n妹妹：优秀\r\n兄妹：不错\r\n妹线：良好\r\n一起成长的约定\r\n\r\n\r\n\r\n《ほしうた》\r\n\r\n\r\n\r\n\r\n成长\r\n茶色\r\n义妹\r\n欧尼酱\r\n废萌\r\n美少女\r\n99分\r\n柔弱坚强\r\n一直喜欢\r\n男主被收养\r\n兄妹同居\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n妹妹的成长记录，兄妹跟奶奶三人的亲情写的很棒\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小田島小鈴\r\n\r\nSX\r\n妹妹：不错\r\n兄妹：还行\r\n妹线：一般\r\n家人一体\r\n\r\n\r\n\r\n《秋のうららの ～あかね色商店街～》\r\n\r\n\r\nAI翻译\r\n\r\n\r\n紫色\r\n义妹（大）\r\n欧尼/欧尼酱\r\n废萌\r\n美少女\r\n86分\r\n坚强努力\r\n慢慢喜欢\r\n天降\r\n三兄妹住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nB\r\n共通不错少有的无血缘的家族情，但妹线感情线差点意思\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n小田島 まゆ\r\n\r\nSS\r\n妹妹：优秀\r\n兄妹：良好\r\n妹线：还行\r\n家人一体\r\n\r\n\r\n\r\n《秋のうららの ～あかね色商店街～》\r\n\r\n\r\nAI翻译\r\n\r\n柔弱\r\n金发\r\n义妹（小）\r\n欧尼酱\r\n废萌\r\n美少女\r\n91分\r\n柔弱温柔\r\n喜欢\r\n天降\r\n三兄妹住宿\r\n\r\n怀孕\r\n\r\n\r\n\r\n\r\nA\r\n共通同上，金发柔弱女子，窈窕淑女，一笑倾城\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n鼠标放妹妹名字上显示立绘\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n不能攻略的妹妹\r\n\r\n综合评分\r\n妹妹评分\r\n兄妹评分\r\n妹线评分\r\n评价\r\n\r\n\r\n\r\n没有妹线\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n久我 满琉\r\n\r\nSAAA\r\n妹妹：不错\r\n兄妹：不错\r\n妹线：无\r\n一直陪伴着你\r\n\r\n\r\n\r\n《时钟机关的朝雾中飘零之花》\r\n\r\n\r\n\r\n\r\n兄妹级\r\n灰石色\r\n亲妹\r\n欧尼酱\r\n剧情作\r\n美少女\r\n95分\r\n兄控病弱\r\n守护\r\n相依为命\r\n学校住宿\r\n\r\n\r\n\r\n\r\n\r\n\r\nC\r\n注意，妹妹不能推！妹妹很兄控，怕生（仅限pc版）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n评价\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","categories":["其他","galgame相关"],"tags":["其他","galgame相关"]}]