[{"title":"2025第十六届蓝桥杯Java省B题目加部分题解","url":"/posts/20522.html","content":"由于河北北京这边省赛那两天风很大的原因，所以导致蓝桥杯没有如期进行，所以说来做做已经考完了的人的比赛题目\n\nA. 逃离高塔\n\n首先如果不考虑溢出处理，用BigInteger估计一是比较慢二是方法写起来比较麻烦，所以还是取模取出个位数处理，因为只看个位数，所以取模不会对结果产生影响\npublic class A &#123;\tpublic static void main(String[] args) &#123;\t\tint res = 0;\t\tfor(int i = 1; i &lt;= 2025; i++) &#123;\t\t\t// 结果只取个位数，在每次乘方过程中都取模取出个位数，防止溢出\t\t\tint temp = (int) (((Math.pow(i, 2) % 10) * i) % 10);\t\t\tif(temp == 3) res++;\t\t&#125;\t\tSystem.out.print(res);\t\t// 202\t&#125;&#125;\n\n\n\nB. 消失的蓝宝\n\n大模拟题，首先 N 肯定是从 20250413开始遍历，但是直接遍历肯定要慢很多\n可以先打表发现，20260411 是第一个满足条件2 的数\n// 打表代码public class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor(long n = 20250413; n &lt; Long.MAX_VALUE; n++) &#123;\t\t\tif((n + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t\tif((n + 20240413) % 20250412 == 0) &#123;\t\t\t\tres = n;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);\t\t// 20260411\t&#125;&#125;\n\n所以从 20260411 开始，每次加 20250412 确保满足条件2，然后判断条件1\npublic class B &#123;\tpublic static void main(String[] args) &#123;\t\tlong res = 0;\t\tfor (long N = 20260411; N &lt; Long.MAX_VALUE; N += 20250412) &#123;\t\t\tif ((N + 20250412) % 20240413 == 0) &#123;\t\t\t\tres = N;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(res);    // 409876661809331\t&#125;&#125;\n\n\n\nC. 电池分组\n\n\n\n两组电池异或和相等，异或 相同为 0，不同为1，那么相等的数异或和为 0，要求能分成两组， 那么就是意思组内所有数异或后为 0\npublic class C &#123;\tpublic static void main(String[] args) &#123;\t\tScanner sc = new Scanner(System.in);\t\tint T = sc.nextInt();\t\tfor(int i = 1; i &lt;= T; i++) &#123;\t\t\tint sum = 0;\t\t\tint N = sc.nextInt(); // 本组电池的数量\t\t\tfor (int j = 1; j &lt;= N; j++) &#123;\t\t\t\tint element = sc.nextInt();\t\t\t\tsum = sum ^ element;\t\t\t&#125;\t\t\tif(sum == 0) &#123;\t\t\t\tSystem.out.println(&quot;YES&quot;);\t\t\t&#125;else &#123;\t\t\t\tSystem.out.println(&quot;NO&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n\n\nD. 魔法科考试\n\n\n\n朴素模拟发现只能过2&#x2F; 5的数据，那么该如何优化呢\nclass Solutions1&#123;\t// 质数筛\tboolean check(int p) &#123;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) return false;\t\t&#125;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\n\n首先，看到时间限制就知道这题不简单。 我们在这里要注意以下几个点\n\n素数判定只需要判定这个数的算术平方根及以下的数是不是这个数的因数，这样更节省时间。\n对于已经判定过的数，不需要判断，所以可以打质数筛\nif 判断是有顺序的（从左往右判断）所以素数判定放在最后，当前面不符时，会直接退出就不会再素数判定，节省时间。\n\n// AC代码import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.util.StringTokenizer;import java.util.*;public class Main &#123;\tpublic static void main(String[] args) &#123;\t\tnew Solutions1();\t&#125;&#125;class Solutions1&#123;\tint[] dx = new int[40004];\t// 质数筛\tboolean check(int p) &#123;\t\t// 已经判定过，就无须再判定\t\tif(dx[p] == 1) return false;\t\tif(dx[p] == 2) return true;\t\tfor(int i = 2; i * i &lt;= p; i++) &#123;\t\t\tif(p % i == 0) &#123;\t\t\t\tdx[p] = 1;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t\tdx[p] = 2;\t\treturn true;\t&#125;\t\tpublic Solutions1() &#123;\t\tFastReader sc = new FastReader();\t\tint n = sc.nextInt();\t\tint m = sc.nextInt();\t\tint[] a = new int[n];\t\tint[] b = new int[m];\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\ta[i] = sc.nextInt();\t\t&#125;\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tb[i] = sc.nextInt();\t\t&#125;\t\tArrays.sort(a);\t\tArrays.sort(b);\t\tint index_a = 0 ,index_b = 0;\t\tfor(int i = 0; i &lt; n; i++) &#123;\t\t\tif(a[i] &gt; n + m) break;\t\t\tindex_a++;\t\t&#125;\t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tif(b[i] &gt; n + m) break;\t\t\tindex_b++;\t\t&#125;\t\t//System.out.println(index_a);\t\t//System.out.println(index_b);\t\tHashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();   // 去重\t\tfor (int i = 0; i &lt; index_a; i++) &#123;\t\t\tfor (int j = 0; j &lt; index_b; j++) &#123;\t\t\t\tif(a[i] + b[j] &lt;= m + n &amp;&amp; check(a[i] + b[j])) &#123;\t\t\t\t\tset.add(a[i] + b[j]);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\tSystem.out.println(set.size());\t&#125;\t\t\tclass FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;/*3 42 3 103 4 5 1 */\n\n\n\nE.  爆破\n\n\n\n题目大意：使用尽可能的小距离使 n 个圆连在一起。\n最小生成树，圆和圆的距离可以用圆心距离减半径，用 prim 写吧，算法讲解都在注释里详细写下了\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    private int n;    private class cirlce implements Comparable&lt;cirlce&gt; &#123;        int x, y, r;        public cirlce() &#123;        &#125;        public cirlce(int x, int y, int r) &#123;            this.x = x;            this.y = y;            this.r = r;        &#125;        @Override        public int compareTo(cirlce o) &#123;            return this.x - o.x;        &#125;    &#125;    private cirlce[] cirlces = new cirlce[5005];    private double Getdist(int u, int v) &#123;        return Math.sqrt((cirlces[u].x - cirlces[v].x) * (cirlces[u].x - cirlces[v].x) + (cirlces[u].y - cirlces[v].y) * (cirlces[u].y - cirlces[v].y));    &#125;    private double prim() &#123;        boolean[] visited = new boolean[n];  // 用于标记每个顶点是否已经被加入到最小生成树中        double[] dist = new double[n];   // 距离数组        // 初始化        Arrays.fill(visited, false);        Arrays.fill(dist, Double.MAX_VALUE);         // 选择0号为起点，并且设为距离0        dist[0] = 0.0;        double sum = 0.0;    // 最小生成树的边总权重\t    // 每次选择一个顶点加入到最小生成树中        for (int i = 0; i &lt; n; i++) &#123;            int u = -1;            double minDist = Double.MAX_VALUE;   // 最小距离指针            // 找到距离最小生成树最近且未被访问的顶点            for (int j = 0; j &lt; n; j++) &#123;                if(!visited[j] &amp;&amp; dist[j] &lt; minDist)&#123;                    minDist = dist[j];                    u = j;                &#125;            &#125;            // 没有点可以移出去了，说明全部加入            if(u == -1)&#123;                break;            &#125;            visited[u] = true;            sum += minDist;\t\t   // 遍历所有未被访问的顶点，更新它们到最小生成树的距离            for(int v = 0; v &lt; n; v++)&#123;                if(!visited[v])&#123;                    double w;                    double spcr = Getdist(u, v);                    // 圆心之间距离小于等于半径之和，相交相切                    if(spcr &lt;= cirlces[u].r + cirlces[v].r)&#123;                        w = 0.0;   // 不需要搭桥                    &#125;else&#123;                        w = spcr - (cirlces[u].r + cirlces[v].r);                    &#125;                    // 松弛操作                    if(w &lt; dist[v])&#123;                        dist[v] = w;                    &#125;                &#125;            &#125;        &#125;        return sum;    &#125;    public Solutions() &#123;        FastReader sc = new FastReader();        n = sc.nextInt();        for (int i = 0; i &lt; n; i++) &#123;            cirlces[i] = new cirlce(sc.nextInt(), sc.nextInt(), sc.nextInt());        &#125;        double sum = prim();        System.out.printf(&quot;%.2f&quot;, sum);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n\n\nF. 数组翻转\n\n\n\n贪心，可以发现，答案只跟数组中每个数连续出现的次数有关，如果有两段一样且连续的数但是被分隔开了，那么肯定存在一种翻转方法翻转到答案的数值，所以答案就是统计这两段然后一乘\npublic class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions &#123;    public Solutions() &#123;        FastReader in = new FastReader();        int n = in.nextInt();        int[] a = new int[n];        for (int a_i = 0; a_i &lt; n; a_i++) &#123;            a[a_i] = in.nextInt();        &#125;        // 桶，记录最大的两个连续值        int[][] backet = new int[1000086][2];        for(int i = 0; i &lt; n; i++)&#123;            int cp = 0;   // 出现次数            cp++;            // 发现了两个连续的相等的数            while(i &lt; n - 1 &amp;&amp; a[i] == a[i + 1])&#123;                cp++;                i++;   // 指针跳过相同的数            &#125;            // 第一段出现的更长            if(cp &gt; backet[a[i]][0])&#123;                backet[a[i]][1] = backet[a[i]][0];                backet[a[i]][0] = cp;            // 第二段出现的更长            &#125;else if(cp &gt; backet[a[i]][1])&#123;                backet[a[i]][1] = cp;            &#125;        &#125;        long res = 0;        for(int i = 0; i &lt; 1000003; i++)&#123;            // ai * 总段长 （backet[i][1] + backet[i][0]）            long temp = (long) i * (backet[i][1] + backet[i][0]);            if(temp &gt; res)&#123;                res = temp;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\nG. 2的幂\n\n\n\n\n数组中所有元素的乘积是 2 的 k 次方倍数。\n\n要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。\n\n如果数组中所有元素的 2 的幂次之和大于k，已经符合了，输出0\n如果初始的 2 的幂次之和小于 k，则需要通过重新选择或增加数组中的某些元素，来使总的 2 的幂次之和达到 k。\n考虑dp\n\n使用一个 DP 数组 dp，其中 dp[j] 表示在增加的 2 的幂次之和为 j 时，所需的最小增加的数的总和。\n遍历数组中的每个数 num，计算其在加上某个正整数后，新数能被 2 的 q 次方整除的最小增量cost，并且能够获得的 2 的幂次增量 gain。\n更新 DP 数组，即通过考虑当前数的所有可能增加的选项来更新之前的 DP 状态。\n如果 dp[re]（其中 re 是需要补充的 2 的幂次）仍然是无穷大，说明无法达到目标，输出 -1\n\npackage 动态规划.subject.线性dp.P12160_蓝桥杯2025省JavaB_2的幂;import scala.reflect.internal.util.OwnerOnlyChmod;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main &#123;    public static void main(String[] args) &#123;        new Solutions();    &#125;&#125;class Solutions&#123;    // 计算一个数是 2 的几次幂    private int countTwos(int num) &#123;        int count = 0;        while(num % 2 == 0 &amp;&amp; num &gt; 0)&#123;            count++;            num /= 2;        &#125;        return count;    &#125;    public Solutions()&#123;        FastReader fs = new FastReader();        int n = fs.nextInt();        int k = fs.nextInt();    // 目标 2 的幂次        int[] a = new int[n + 1];        for (int i = 1; i &lt;= n; i++) a[i] = fs.nextInt();        // 初始状态 2 的幂次和        int total = 0;        for(int num: a)&#123;            total += countTwos(num);        &#125;        if(total &gt;= k)&#123;            System.out.println(0);            return;        &#125;        // 需要新增的2的幂次        int rp = k - total;  // 差2的rp次幂        int[] dp = new int[rp + 1];        Arrays.fill(dp, Integer.MAX_VALUE);        dp[0] = 0;   // 初始化dp[0]为0，意思是1为初态，不加        // 处理每个数        // 数组中所有元素的乘积是 2 的 k 次方倍数。        // 要做到这一点，数组中所有元素的 2 的幂次之和必须至少为 k。        for (int i = 0; i &lt; n; i++) &#123;            int num = a[i];            int p = countTwos(num);    // 该数为2的几次幂            // 临时 DP 数组，避免同一组重复选择            int[] tempDp = dp.clone();            // 生成增量选项，开到30差不多            for (int q = p + 1; q &lt;= 30; q++) &#123;                long mp = (long)Math.pow(2, q);    // 2^q                if(mp &gt; 100000) break;   // 注意最大值限制                // 不小于 num 且是 2^q 倍数的最小数 sp                long sp = ((long)num + mp - 1) / mp * mp;                // 新数能被 2 的 q 次方整除的最小增量cost 和 能够获得的 2 的幂次增量 gain。                int cost = (int)(sp - num);                int gain = countTwos((int)sp) - p;                if (gain &lt;= 0) continue;                // 更新dp                for(int j = rp; j &gt;= gain; j--)&#123;                    // dp[j - gain] 不是无穷大，存在一种方式可以到达 j - gain 的 2 的幂次增量                    if(dp[j - gain] != Integer.MAX_VALUE)&#123;                        tempDp[j] = Math.min(tempDp[j], dp[j - gain] + cost);                    &#125;                &#125;            &#125;        &#125;        System.out.println(dp[rp] == Integer.MAX_VALUE? -1 : dp[rp]);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n\n\nH. 研发资源分配\n\n\n\n可以发现，题目思路类似于田忌赛马，贪心考虑，用下等马换掉对方的上等马\n例如题解 1 3 2 用 2 1 3，就是用 最下等的 1 抵掉了 最上等的 3\n而且由于是全排列，所以剩下的所有位置一定可以排出都比对方大的排列。\n// 我是真不知道为什么洛谷一直给我一个 WA 我也不知道哪里错了）public class Main &#123;    public static void main(String[] args) &#123;        new Solutions2();    &#125;&#125;// 1 2 3    2 3 1  1+2-3=0// 1 4 3 2   2 1 4 3  1-2+3+4=6// 1 3 2 4   2 4 3 1  1+2+3-4=2// 2 3 1 5 4   3 4 2 1 5   1+2+3-4+5// 经过了几个案例的打表，我们发现，总是存在这样一种排列，会使得资源份额的差值最大// 那么就是 对面最多只能拿到一天的分数，而且拿到的只能是等级最高的那天class Solutions2&#123;    public Solutions2()&#123;        FastReader sc = new FastReader();        int n = sc.nextInt();        int[] b = new int[n + 1];        for (int i = 1; i &lt;= n; i++) b[i] = sc.nextInt();        if (n == 1) &#123;            System.out.println(0);            return;        &#125;        long res = 0;        for (int i = 1; i &lt;= n; i++) &#123;            // 对面出动了最大的等级，我们使用最下等的去换取，这天的不要            if(b[i] == n)&#123;                res -= i;            &#125;else&#123;                // 别的情况我们都能凑出一种排列比他大，因为我们用最小的把他最大的给抵出去了                res += i;            &#125;        &#125;        System.out.println(res);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        public String next() &#123;            while (!st.hasMoreTokens()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        public int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"绘隙碎笔","url":"/posts/29865.html","content":"​\t才三月份，石家庄就依旧进入繁盛的春天了啊。。。。在我的家乡长久生活的人，不知道会不会感叹这岁月的笔触实在是太快了。​\t又是一节我习惯绘画的课堂，坐在最靠窗户的一排，三月份已然有些许热气，拿出本来，感觉都温暖了许多。​\t我常于这光影交错处徘徊，看日光一寸寸移动，感觉把我生命的长度都不经意的丈量了。​\t所以我把这梦境画下，我又回到那个熟悉的楼里了，那个我可能再也不会有机会回去的，却满含怀念的建筑里。​\t她靠着下午五点半的夕阳，在梦里和我相遇吗。其实不然，在梦里只有楼和我，我却无法把自己画下，只能把祈莉作为我思索的对象，让她替我在一步一步的忧郁。  \n\n\n\n&#123;% asset_img ShenBangQili.jpg example %&#125;\t\n\n​\t本人懈怠，绘画的热度感觉一日不如一日，也许我是想画吧，可是我用时间在绘画上的刻痕实在是太浅，被琐事纠缠的我，大概是无暇提笔哩。。。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-2025.3.27 中午\n","categories":["杂谈","绘画相关"],"tags":["绘画相关","杂谈"]},{"title":"Hexo根目录下的_config.yml配置文件","url":"/posts/63024.html","content":"我们在使用hexo初始化一个项目的时候，在根目录下会有一个配置文件_config.yml，这个文件配置了所写博客里面的内容，我们从根目录的该文件来说明每个配置的作用\n头注释_config.yml文件在头部会有一些注释，Hexo Configuration下的两行表示hexo文档的相关文档，Docs指的是hexo的文档，Source指的是hexo的GitHub源码，方便供他人参考查阅\n# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/\n\n\n\n博客网站相关Site下面是网站相关的一些信息配置\n# Sitetitle: Hexosubtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: John Doelanguage: entimezone: &#x27;&#x27;\n\ntitle：网站的名字，会写在hexo generator命令生成后的public文件夹下的index.html文件的title标签里，作为你个人博客网站的标题，我们也可以在主题的首页左下角找到\nsubtitle：网站的副标题，生成的时候默认为空，一般会出现在你主标题的下面，也就是大约在背景图中间\ndescription：主要用于SEO，告诉搜索引擎一个关于站点的简单描述，在官方文档中建议在这段描述中增加自己的一些关键词\nkeywords：网站的关键词，使用半角逗号分隔开多个关键词，对SEO的优化有一定的作用\nauthor：顾名思义就是作者，这个也只是署个名而已，不会显式的看到\nlanguage：这里就写了网站使用的语言\ntimezone：网站对应的时区，一般情况下不用去刻意配置，会默认使用电脑的时区，但如果发布到其他地方的服务器，可能会使用当地服务器的时区，一般中国的时区可以设置为Asia&#x2F;Shanghai或者北京\n博客网址相关# URL## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;url: http://example.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # 设置为false时会将末尾的index.html去掉  trailing_html: true # 设置为false时会将末尾的.html去掉，对index.html无效\n\nurl：指定博客的完整域名或 URL 地址。当你将博客部署到互联网上时，访问者需要通过这个地址来访问你的博客，要确保 url 地址准确无误，不然可能会导致博客内的链接（如文章内的图片链接、页面跳转链接等）无法正常访问\nroot：网站的根目录，指定博客在域名下的根目录，如果你的博客是直接部署在域名的根目录下，就将 root 设置为 /；若博客部署在域名的子目录下，比如部署在 http://example.com/blog 下，那么就需要把 root 设置为 /blog/。正确设置 root 很重要，不然会影响博客内资源（如 CSS、JavaScript 文件等）的加载路径。\npermalink：文章的永久链接格式，一般是格式化日期字符串，可以在permalink这里配置，如默认中的配置，在hello world文章中就会是这样的url\n\n当使用Font-matter中的值配置的时候（文章格式标签），可选的值有\n\n\n\n**permalink_defaults:**设置永久链接的默认值。当你在文章的 Front - Matter（文章开头的元数据部分）中没有对某些永久链接相关的变量进行设置时，就会使用这里定义的默认值。不过在示例中，没有具体设置默认值，所以会采用 Hexo 的默认配置。\n**pretty_urls:**就是如注释那样\n目录相关# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:\n\nsource_dir：存放hexo文章的文件夹，我们写的md文件都放在这个配置对应的文件夹下，默认值是source\npublic_dir：存放hexo g生成的文件，执行hexo g后根目录就会出现这个文件夹，默认值是public\ntag_dir：按标签存放文章的目录，默认值是tags，如果我们给文章添加标签，使用hexo g时public文件夹下就会多出一个tags文件夹（根据我们的配置文件夹名不同）\narchive_dir：归档文件夹，存放归档文件，默认值为archives\ncategory_dir：分类文件夹，按分类存放的文件，和上面的tags一样，只要在文章中的Font-matter添加了categories就会在使用hexo g构造时出现相应的文件夹\ncode_dir：Include code 文件夹，source_dir 下的子目录，默认值为downloads&#x2F;code\ni18n_dir：国际化（i18n）文件夹，默认值:lang\nskip_render：跳过指定文件的渲染，匹配到的文件将会被不做改动复制到public文件夹下，如果路径对应的是我们的文章，那会直接忽略掉该文章，我们这样设置来忽略掉hello-world.md文件\nskip_render: &quot;_posts/hello-world.md&quot;\n\n​\t\t然后hexo g之后可见生成的文件夹只有一些基础的内容，没有和hello-world.md相关的东西\n文章相关# Writingnew_post_name: :title.md default_layout: posttitlecase: false # Transform title into titlecaseexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: false\n\nnew_post_name：新文章的默认名称，我们是使用hexo new来构造文章的，生成的文章名就是通过这里配置的，默认为:title.md，也就是标题.md\ndefault_layout：预设布局，指定你新建文章的布局，布局决定了文章在渲染时使用的模板，hexo new可以创建三种文件，post&#x2F;帖子，draft&#x2F;草稿，page&#x2F;页面，这里设置默认值在使用hexo new就可以直接创建对应默认类型的文章，设置了post就等同于说在命令行执行hexo new 和执行hexo new post 是一样的，也可以设置为draft和page\ntitlecase：控制是否将文章标题转换为标题大小写格式。当设置为 true 时，文章标题会被转换为标题大小写（即每个单词的首字母大写）；设置为 false 则不进行转换，保持标题的原始大小写。\nexternal_link：\n\nenable：控制是否在新标签页中打开外部链接。设置为 true 时，文章中的外部链接会在新标签页中打开；设置为 false 则会在当前页面打开。\nfield：指定外部链接设置的应用范围。site 表示该设置应用于整个网站。\nexclude：指定不应用此外部链接设置的域名或路径。这里为空字符串，表示没有排除的域名或路径。\n\nfilename_case：控制文件名的大小写规则。取值为 0 时，文件名保持原始大小写；取值为 1 时，文件名转换为小写；取值为 2 时，文件名转换为大写。\nrender_drafts：控制是否渲染草稿文章。草稿文章通常存放在 source/_drafts 目录下。设置为 true 时，草稿文章会被渲染并显示在网站上；设置为 false 则不会渲染草稿文章。\npost_asset_folder：是否启动资源文件夹，对于我们的网站，如果我们的文章里面有图片，我们可以在source文件夹下建立一个统一的images文件夹来存放图片，但是如果有的文章有很多的资源文件如图片，就可以设置为true，控制为每篇文章创建一个同名的资源文件夹。当设置为 true 时，使用 hexo new 命令创建文章时，会同时创建一个与文章同名的文件夹，用于存放该文章相关的图片、附件等资源；设置为 false 则不会创建。\nrelative_link: 控制是否使用相对链接。设置为 true 时，文章中的链接会使用相对路径；设置为 false 则使用绝对路径。\nfuture：控制是否发布未来日期的文章。设置为 true 时，即使文章的发布日期设置为未来的某个时间，也会正常发布；设置为 false 则不会发布未来日期的文章。\nhighlight：代码高亮的显示\n\nenable：控制是否启用代码高亮功能。设置为 true 时，文章中的代码块会进行高亮显示；设置为 false 则不进行高亮。\nline_number：控制是否显示代码块的行号。设置为 true 时，代码块会显示行号；设置为 false 则不显示。\nauto_detect：控制是否自动检测代码块的语言。设置为 true 时，Hexo 会尝试自动检测代码块的语言；设置为 false 则需要在代码块中手动指定语言\ntable_replace：用n个空格来代表tab键，如果值为空，则不会代替tab键，这里为空字符串，表示不进行替换。\nwarp：是否将代码放在table标签里，默认为true\nhljs：控制是否使用 highlight.js 进行代码高亮。设置为 true 时，使用 highlight.js 进行高亮；设置为 false 则使用 Hexo 内置的高亮方式。\n\n主页设置index_generator:  path: &#x27;&#x27;  per_page: 10  order_by: -date\n\nindex_generator：主页相关的设置\n\npath：主页对应的路径，默认为’’，即域名根目录就是主页的路径\nper_page：每页显示的帖子数，默认为10\norder_by：帖子的排序，默认为-date，即按日期倒序排\n\n分类和标签# Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名\n\ndefault_category：当你创建新文章时，如果没有在文章的 Front - Matter（即文章开头的元数据部分）中明确指定文章的分类，那么这篇文章就会被自动归类到 default_category 所指定的分类中。在这个例子里，默认分类是 uncategorized，也就是 “未分类”。\ncategory_map：category_map 用于设置分类的别名。在实际写文章和管理博客的过程中，你可能会使用一个比较简洁或者容易输入的分类名，但在博客的展示页面上，你希望使用更正式、美观或者表意更清晰的名称。这时就可以通过 category_map 来实现分类名的映射。\n例如：\ncategory_map:  tech: 技术分享  life: 生活随笔\n\n当你在文章的 Front - Matter 中使用 categories: [tech] 时，在博客的分类页面显示的分类名称将会是 “技术分享”，而不是 tech。\ntag_map：tag_map 的作用与 category_map 类似，不过它是用于设置标签的别名。在写文章时，你可能会使用一些简单的标签名，但在博客展示时，希望使用更合适的名称，就可以通过 tag_map 来进行映射。\n元数据元素# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true\n\n是否在页面开头插入下面的meta标签，默认为true\n\n日期和时间# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## Use post&#x27;s date for updated date unless set in front-matteruse_date_for_updated: false\n\ndate_format：日期格式，默认为YYYY-MM-DD，即年月日\ntime_format：时间格式，默认为HH:mm:ss，即时分秒\nuse_date_for_updated：启用以后，如果 Front Matter 中没有指定 updated（文件更新日期），post.updated 将会使用 date 的值而不是文件的创建时间，默认值为true\n分页# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page\n\nper_page：分页时每页的文章数，如果为0则不分页，默认为10\npagination_dir分页的目录，默认为page，对应于public文件夹下的archives文件夹下的page文件夹，如果只有一页是不会生成这个文件夹的\n包括或不包括目录和文件# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:\n\ninclude：Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。\nexclude：Hexo 会忽略这些文件和目录\nignore：忽略的文件,要注意的是，这里要写入的是数组，而yaml的数组要用-值表示数组中一个元素或者直接采用js中数组的写法[]\n主题# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 当前使用的主题名\n\n\n\n部署# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: &#x27;&#x27;\n\nhexo提供了快速方便的一键部署功能hexo deploy，但我们至少需要在_config.yml文件中的deploy中至少配置一个type，比如\ndeploy:  type: git\n\ndeploy:  type: git  repo: &lt;repository url&gt; # 库地址  branch: [branch] # 分支名称  message: [message] # 自定义提交信息\n\n\n\n\n\n\n\n参考内容：部分内容转载自https://blog.csdn.net/zemprogram/article/details/104288872\n hexo官方中文文档\n hexo官方英文文档（有些中文文档没有的英文文档的才有）\n hexo fromt-matter\n hexo 部署\n","categories":["实用","介绍说明"],"tags":["网站技术","Hexo相关","实用知识"]},{"title":"Hibernate框架之介绍与初识Hibernate程序","url":"/posts/48900.html","content":"Hibernate介绍Hibernate是一个开源的Java对象关系映射（ORM）框架，它提供了一种方便的方式将Java对象与关系型数据库进行映射和交互。通过Hibernate，开发人员可以使用面向对象的方式操作数据库，而不需要直接编写SQL查询语句\n架构图\n\n\nHibernate是一个开源的对象关系映射（ORM）框架，用于将Java对象映射到关系型数据库中的关系表。它提供了一种面向对象的方式来操作数据库，简化了开发人员对数据库的访问和管理\n如何理解提供了一种面向对象的方式来操作数据库。\n\n一方面：Hibernate可以将定义好的java类映射为数据库中的表，并将java类的实例化的对象，映射为对应表中的一行记录。另一方面：使用Hibernate，开发人员可以直接操作对象，不需要编写复杂的SQL语句。通过对象的属性和方法来进行数据的读取、修改和删除等操作。\n\nHibernate提供的核心功能和特性ORM映射（可以将java对象与数据库表之间进行映射，实现对象和关系数据库之间的转换，支持各种映射策略和注解）；\n数据库查询（提供了一组丰富的API，用于执行数据库操作，包括插入、更新、删除、查询，还支持HQL和基于SQL的查询一级Criteria查询和原生SQL查询）；\n缓存机制(Hibernate内置了一级缓存和二级缓存机制，用于提供查询性能和减少数据库的访问。一级缓存是会话级别的缓存，保存了会话期间加载的实体对象。二级缓存是跨会话的缓存，可以在多个会话之间共享缓存数据）；\n事物管理（可以通过编程或声明式的方式管理数据库事物。支持标准的java事物API（JTA）和本地事物管理）；\n延迟加载（允许按需加载关联对象，提高查询性能。这意味着只有在需要访问关联对象时，才会从数据库中加载相应的数据。）；\n对象状态管理（通过跟踪对象的状态来管理对象的持久化。它提供了持久化、脱管和删除等状态之间的转换，使开发人员能够方便地操作对象。）\n对象的持久化把对象永久的保存到数据库中\n持久化包括和数据库相关的各种操作\n\n保存\n更新\n删除\n查询\n加载：加载特定的 OID，把一个对象从数据库加载到内存中\n\nOID：为了在系统中能找到所需对象，需要为对象分配一个唯一的标识号，在关系型数据库中称为主键，在对象术语中叫对象标识OID\nORM 对象关系映射ORM主要解决对象-关系的映射\n\n类的一个对象可以对应一张表，对象对应表的行，属性对应位表的列\n\nORM的思想：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。ORM 采用元数据来描述对象-关系映射细节,元数据通常采用XML 格式,并且存放在专门的对象-关系映射文件中。描述数据的数据\n\nHibernate框架的优点\n使开发更加面向对象化：Hibernate提供了一个面向对象的编程模型，使开发人员可以使用面向对象的思想来操作数据库。\n\n提高开发效率：Hibernate提供了许多强大的特性和工具：如自动生成数据库表结构，提供了公共的操作数据库的方法，让开发人员不用写SQL语句、缓存机制、事物管理。可以大大减少开发人员的工作量，提高开发效率。\n\n可移植性：Hibernate可以在不同的数据库系统上运行，如Mysql、Oracle、SQL Server等，开发人员可以使用统一的API和语法，无需关系底层数据库的差异。\n\n\nHibernate、jpa、jdbc他们三者之间是什么关系\njdbc：jdbc是Java提供的用于与关系型数据库进行交互的标准API，它提供了一组接口和类，使开发人员能够执行数据库的连接、查询、更新等操作。JDBC 需要开发人员手动编写 SQL 查询和处理数据库结果集，对于较低层次的数据库操作提供了灵活性。使开发人员能够执行数据库的连接、查询、更新等操作。JDBC 需要开发人员手动编写 SQL 查询和处理数据库结果集，对于较低层次的数据库操作提供了灵活性。\nJPA：JPA是Java持久化标准，定义了一组API和规范，提供了一种与数据库无关的方式来操作实体对象。JPA定义了实体、映射关系、查询语言和事物管理等方面的规范，使开发人员能够以面向对象的方式进行数据库的操作。\nHibernate：Hibernate实现了JPA规范，同时还提供了一些额外的功能和特性。Hibernate封装了底层的JDBC操作，提供了更高层次的抽象，来简化开发人员对数据库的访问。通过 HIbernate 开发人员可以通过配置和注解来定义实体和映射关系，使用面向对象的方式进行数据库操作。\n\nHibernate 是 JPA 的实现之一，而 JPA 则是对数据库持久化操作的规范。JDBC 是底层的数据库连接和操作技术，Hibernate 和 JPA 则在 JDBC 的基础上提供了更高层次的抽象和便利性，使得开发人员能够以面向对象的方式进行数据库操作\n下载安装现在 Spring Boot JPA 集成的 Hibernate 进行数据持久化更加常见，\n一般不用安装，装好依赖就行了，配置文件配置properties就行。\n不用maven导入，jar包到 官网 下就行。\n下载网站：https://sourceforge.net/projects/hibernate/files/hibernate-orm/\nHibernate开发步骤\n第一个例子——学生信息管理编写例子\n创建了一个Java项目（Maven或Gradle）\n\n添加了Hibernate依赖（如果是Maven项目，在pom.xml中添加）\n&lt;!-- Hibernate核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;    &lt;version&gt;5.6.14.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库驱动（这里使用H2内存数据库作为示例） --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;2.1.214&lt;/version&gt;&lt;/dependency&gt;\n\n创建实体类\n使用hibernate时候，不需要自己手动创建表，hibernate帮把表创建\nimport javax.persistence.*;@Entity@Table(name = &quot;students&quot;)public class Student &#123;        // Hibernate作为JPA的实现，支持这些标准JPA注解    // 注解表示了对象关系映射的基本信息    // Hibernate 要求实体类有一个属性是唯一的    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;name&quot;, nullable = false)    private String name;        @Column(name = &quot;email&quot;)    private String email;        @Column(name = &quot;age&quot;)    private Integer age;        // 必须有无参构造函数    public Student() &#123;&#125;        // 全参构造函数    public Student(String name, String email, Integer age) &#123;        this.name = name;        this.email = email;        this.age = age;    &#125;        // Getter和Setter方法    public Long getId() &#123;        return id;    &#125;        public void setId(Long id) &#123;        this.id = id;    &#125;        public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;        public String getEmail() &#123;        return email;    &#125;        public void setEmail(String email) &#123;        this.email = email;    &#125;        public Integer getAge() &#123;        return age;    &#125;        public void setAge(Integer age) &#123;        this.age = age;    &#125;        @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n使用xml或者纯注解配置\nHibernate配置文件 hibernate.cfg.xml 是Hibernate框架中至关重要的部分，它负责初始化Hibernate并提供与数据库交互所需的所有配置信息。在这个配置文件中，开发者需要指定数据库连接的URL、用户名和密码，以及数据库使用的方言，这些信息是Hibernate能够正常工作所必须的。\n该配置文件的结构通常包含以下几个主要部分：\n\nhibernate-configuration ：这是配置文件的根元素，其中可以包含一个或多个 session-factory 元素。\nsession-factory ：定义了一个或多个 session-factory ，每一个 session-factory 都可以配置不同的数据库连接信息。\nproperty ：在 session-factory 内部，使用多个 property 元素来指定Hibernate连接数据库所需的参数，如\nconnection.url 、 connection.username 、 connection.password 、 dialect 等。\nmapping ：这个元素用于指定实体类与数据库表的映射关系，可以通过 class 或 mapping-file 指定。\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库连接设置 --&gt;        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;org.h2.Driver&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:h2:mem:testdb&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.username&quot;&gt;sa&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.password&quot;&gt;&lt;/property&gt;                &lt;!-- JDBC连接池大小 --&gt;        &lt;property name=&quot;hibernate.connection.pool_size&quot;&gt;1&lt;/property&gt;                &lt;!-- SQL方言 - 告诉Hibernate使用哪种数据库语法 --&gt;        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.H2Dialect&lt;/property&gt;                &lt;!-- 在控制台显示SQL语句 --&gt;        &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;                &lt;!-- 自动创建/更新数据库表结构 --&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;                &lt;!-- 映射实体类 --&gt;        &lt;mapping class=&quot;com.example.Student&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;\n\n数据库连接和方言配置：配置数据库连接信息是通过 hibernate.cfg.xml 中 property 元素的几个关键属性来完成的。 connection.url 指定了数据库的连接字符串， connection.username 和 connection.password 分别指定了数据库的用户名和密码，而 dialect 属性则指定了对应数据库的方言。方言配置对于Hibernate的SQL生成至关重要。方言是Hibernate为不同数据库提供的抽象，它知道如何生成特定数据库支持的SQL语法。这样，Hibernate可以为不同的数据库产生正确的SQL语句而无需修改代码。 \n参数说明 ：\nconnection.url ：该属性定义了数据库的连接URL，格式取决于所使用的JDBC驱动程序。\nconnection.username 和 connection.password ：分别定义了访问数据库时所需的用户名和密码。\ndialect ：该属性指定了数据库方言的完全限定类名，Hibernate根据这个类来生成特定数据库的SQL语句。 \n\n使用properties配置文件和xml配置属于是一样的\n在纯注解方式下，我们可以完全摆脱hibernate.cfg.xml文件，使用Java配置类和JPA注解来配置Hibernate。\nimport java.util.Properties;import javax.sql.DataSource;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.AvailableSettings;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;public class HibernateUtil &#123;        private static SessionFactory sessionFactory;        public static SessionFactory getSessionFactory() &#123;        if (sessionFactory == null) &#123;            try &#123;                Configuration configuration = new Configuration();                                // 设置数据库连接属性                Properties settings = new Properties();                settings.put(AvailableSettings.DRIVER, &quot;org.h2.Driver&quot;);                settings.put(AvailableSettings.URL, &quot;jdbc:h2:mem:testdb&quot;);                settings.put(AvailableSettings.USER, &quot;sa&quot;);                settings.put(AvailableSettings.PASS, &quot;&quot;);                                // Hibernate特定属性                settings.put(AvailableSettings.DIALECT, &quot;org.hibernate.dialect.H2Dialect&quot;);                settings.put(AvailableSettings.SHOW_SQL, &quot;true&quot;);                settings.put(AvailableSettings.HBM2DDL_AUTO, &quot;update&quot;);                                configuration.setProperties(settings);                                // 添加实体类                configuration.addAnnotatedClass(Student.class);                                ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()                    .applySettings(configuration.getProperties()).build();                                sessionFactory = configuration.buildSessionFactory(serviceRegistry);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        return sessionFactory;    &#125;        public static void shutdown() &#123;        if (sessionFactory != null) &#123;            sessionFactory.close();        &#125;    &#125;&#125;\n\n创建主程序进行 CURD 操作\n，创建SessionFactory对象import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import java.util.List;public class HibernateDemo &#123;        public static void main(String[] args) &#123;        // 1. 创建SessionFactory，对应hibernate基本配置信息        // 加载hibernate核心配置文件，Configuration类加载 hibernate.cfg.xml        SessionFactory sessionFactory = new Configuration()                .configure(&quot;hibernate.cfg.xml&quot;)                .buildSessionFactory();                try &#123;            // 2. 创建Session，创建SessionFactory对象            // 并且使用SessionFactory创建session对象，类似于连接            Session session = sessionFactory.openSession();                        // 3. 开始事务            Transaction transaction = session.beginTransaction();                        // 4. 创建学生对象并保存            Student student1 = new Student(&quot;张三&quot;, &quot;zhangsan@example.com&quot;, 20);            Student student2 = new Student(&quot;李四&quot;, &quot;lisi@example.com&quot;, 22);                        System.out.println(&quot;保存学生...&quot;);            // 调用session的方法实现添加            session.save(student1);            session.save(student2);                        // 5. 提交事务            transaction.commit();                        // 6. 查询所有学生            transaction = session.beginTransaction();            System.out.println(&quot;\\n查询所有学生...&quot;);            List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        // 7. 更新学生信息            System.out.println(&quot;\\n更新学生信息...&quot;);            Student studentToUpdate = session.get(Student.class, student1.getId());            studentToUpdate.setEmail(&quot;newemail@example.com&quot;);            session.update(studentToUpdate);                        // 8. 再次查询验证更新            System.out.println(&quot;\\n查询更新后的学生...&quot;);            Student updatedStudent = session.get(Student.class, student1.getId());            System.out.println(updatedStudent);                        // 9. 删除学生            System.out.println(&quot;\\n删除学生...&quot;);            session.delete(student2);                        // 10. 最终查询            System.out.println(&quot;\\n最终学生列表...&quot;);            students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        transaction.commit();                        // 11. 关闭Session            session.close();                    &#125; finally &#123;            // 12. 关闭SessionFactory            sessionFactory.close();        &#125;    &#125;&#125;\n\n这个例子使用了H2内存数据库，所以不需要额外安装数据库服务器，H2数据库非常适合学习和测试。\n这个简单的示例展示了Hibernate的核心功能：\n\n对象-关系映射：通过注解将Java类映射到数据库表\nCRUD操作：\n创建(Create)：session.save()\n读取(Read)：session.get()和HQL查询\n更新(Update)：session.update()\n删除(Delete)：session.delete()\n\n\n事务管理：通过Transaction对象管理\nHQL查询：使用面向对象的查询语言from Student\n\n使用新的配置方式，该如何写\nimport org.hibernate.Session;import org.hibernate.Transaction;public class HibernateAnnotationDemo &#123;        public static void main(String[] args) &#123;        // 获取SessionFactory        SessionFactory sessionFactory = HibernateUtil.getSessionFactory();        Session session = sessionFactory.openSession();                try &#123;            // 开始事务            Transaction transaction = session.beginTransaction();                        // 创建并保存学生            Student student1 = new Student(&quot;王五&quot;, &quot;wangwu@example.com&quot;, 21);            Student student2 = new Student(&quot;赵六&quot;, &quot;zhaoliu@example.com&quot;, 23);                        System.out.println(&quot;保存学生...&quot;);            session.save(student1);            session.save(student2);                        // 提交事务            transaction.commit();                        // 查询示例            transaction = session.beginTransaction();            System.out.println(&quot;\\n所有学生:&quot;);            List&lt;Student&gt; students = session.createQuery(&quot;from Student&quot;, Student.class).list();            students.forEach(System.out::println);                        transaction.commit();                    &#125; finally &#123;            session.close();            HibernateUtil.shutdown();        &#125;    &#125;&#125;\n\n其中的注解声明\n\n\n\n注解\n来源\n说明\n\n\n\n@Entity\nJPA\n标记类为实体类，将映射到数据库表\n\n\n@Table\nJPA\n指定映射的表名\n\n\n@Id\nJPA\n标记主键字段\n\n\n@GeneratedValue\nJPA\n指定主键生成策略\n\n\n@Column\nJPA\n指定字段与列的映射关系\n\n\n@Transient\nJPA\n标记不持久化的字段\n\n\n\n\n涉及到的APIConfiguration在使用Hibernate时，首先要创建Configuration实例，Configuration实例主要用于启动、加载、管理hibernate的配置文件信息。 \n\nHibernate 运行的底层信息：数据库的 URL，用户名，密码，JDBC驱动类，数据库Diaiect，数据库连接池等，对应hibernate.cfg.xml 文件\n持久化类与数据表的映射关系 hbm.xml文件\n\n在启动Hibernate的过程中，Configuration实例首先确定Hibernate配置文件的位置，然后读取相关配置，最后创建一个唯一的SessionFactory实例。Configuration对象只存在于系统的初始化阶段，它将SessionFactory创建完成后，就完成了自己的使命。\nHibernate通常使用Configuration config = new Configuration().configure()；的方式创建实例，此种方式默认会去src下读取hibernate.cfg.xml配置文件。如果不想使用默认的hibernate.cfg.xml配置文件，而是使用指定目录下（或自定义）的配置文件，则需要向configure()方法中传递一个文件路径的参数，其代码写法如下：\nConfiguration config = new Configuration().configure(&quot;xml文件位置&quot;);\n\n传递 hibernate.properties 属性文件\nConfiguration config = new Configuration();\n\n此种写法hibernate会去指定位置查找配置文件，例如，想要使用src下config包中的hibernate.cfg.xml文件，只需将文件位置加入configure()中即可，其代码如下所示：\nConfiguration config = new Configuration().configure(&quot;/config/hibernate.cfg.xml&quot;);\n\n\n\nSessionFactorySessionFactory接口负责Hibernate的初始化和建立Session对象。它在Hibernate中起到一个缓冲区作用，Hibernate可以将自动生成的SQL语句、映射数据以及某些可重复利用的数据放在这个缓冲区中。同时它还保存了对数据库配置的所有映射关系，维护了当前的二级缓存。\n\n针对单个数据库映射关系经过编译后的内存镜像，是线程安全的。\nSessionFactory对象一且构造完毕，即被赋予特定的配置信息。\nSessionFactory是生成Session的工厂\n构造SessionFactory很消耗资源，一般情况下一个应用中只初始化一个SessionFactory对象。\nHibernate4 新增了一个ServiceRegistry接口，所有基于Hibernate 的配置或者服务都必须统一向这个ServiceRegistry注册后才能效，但是 Hibernate5 又不需要了\n\nSessionFactory实例是通过Configuration对象获取的，其获取方法如下所示：\nSessionFactory sessionFactory = config.buildSessionFactory();\n\nSessionFactory具有以下特点：\n\n它是线程安全的，它的同一个实例能够供多个线程共享。\n它是重量级的，不能随意的创建和销毁它的实例。\n\n由于SessionFactory的这些特点，一般情况下，**一个项目中只需要一个SessionFactory**，只有当应用中存在多个数据源时，才为每个数据源建立一个SessionFactory实例。因此，在实际项目使用中，通常会抽取出一个HibernateUtils的工具类，用来提供Session对象。\nSessionSession是应用程序与数据库之间交互操作的一个单线程对象，是Hibernate运作的中心，它的主要功能是为持久化对象提供创建、读取和删除的能力，所有持久化对象必须在session的管理下才可以进行持久化操作。\n相当于 JDBC 的 Connection，持久化类与 Session 关联起来之后就具有了持久化的能力\n创建SessionFactory实例后，就可以通过它获取Session实例。获取Session实例有两种方式，一种是通过openSession()方法，另一种是通过getCurrentSession()方法。两种方法获取session的代码如下：\n// 采用openSession方法创建session =&gt; 获得全新sessionSession session = sessionFactory.openSession();// 采用getCurrentSession方法创建session =&gt; 获得与线程绑定的sessionSession session = sessionFactory.getCurrentSession();\n\n以上两种获取session实例方式的主要区别是，采用openSession方法获取Session实例时，SessionFactory直接创建一个新的Session实例，并且在使用完成后需要调用close方法进行手动关闭。而getCurrentSession方法创建的Session实例会被绑定到当前线程中，它在提交或回滚操作时会自动关闭。\nSession是线程不安全的，多个并发线程同时操作一个Session实例时，就可能导致Session数据存在混乱（方法内部定义和使用Session时，不会出现线程问题）。因此设计软件架构时，应避免多个线程共享一个Sesion实例。同时它也是轻量级的，实例的创建和销毁不需要消耗太多的资源。它还有一个缓存，即Hibernate的一级缓存，这个缓存主要用于存放当前工作单元加载的对象。\n在Session中提供了大量的常用方法，具体如下：\n\nsave()、update()和saveOrUpdate()方法：用于增加和修改对象\ndelete()方法：用于删除对象\nget()和load()方法：根据主键查询\ncreateQuery()和createSQLQuery()方法：用于数据库操作对象\ncreateCriteria()方法：条件查询\n\nTransactionTransaction接口主要用于管理事务，它是Hibernate的数据库事务接口，且对底层的事务接口进行了封装。Transaction接口的事务对象是通过Session对象开启的，其开启方式如下所示：\nTransaction transaction = session.beginTransaction();\n\n在Transaction接口中，提供了事务管理的常用方法，具体如下：\n\ncommit()方法：提交相关联的session实例。\nrollback()方法：撤销事务操作\nwasCommitted()方法：检查事务是否提交\n\n**Session执行完数据库操作后，要使用Transaction接口的commit()方法进行事务提交，才能真正的将数据操作同步到数据库中。\n发生异常时，需要使用rollback()方法进行事务回滚，以避免数据发送错误。因此，在持久化操作后，必须调用Transaction接口的commit()方法和rollback()方法。如果没有开启事务，那么每个Session的操作，都相当于一个独立的操作。\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"JSON之基础部分与语法","url":"/posts/18280.html","content":"JSON基础部分什么是JSONJavaScript 对象表示法（JSON）是用于将结构化数据表示为 JavaScript 对象的标准格式，通常用于在网站上表示和传输数据（例如从服务器向客户端发送一些数据，因此可以将其显示在网页上）\nJSON: JavaScript Object Notation(JavaScript 对象表示法)\nJSON 是存储和交换文本信息的语法，类似 XML。\nJSON 比 XML 更小、更快，更易解析。\nJSON 是轻量级的文本数据交换格式\nJSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持 JSON\nJSON 具有自我描述性，更易理解\nJSON 文本格式在语法上与创建 JavaScript 对象的代码相同。\nJSON 可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据\n\n将字符串转换为原生对象称为反序列化（deserialization），而将原生对象转换为可以通过网络传输的字符串称为序列化（serialization）。\n\n由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。\n\nJSON 格式化工具：https://www.jyshare.com/front-end/53/\nJSON 转义&#x2F;去除转义：https://www.jyshare.com/front-end/7683/\nJSON 在线解析工具：https://www.jyshare.com/front-end/7438/\nJSON 差异对比工具：https://www.jyshare.com/front-end/9557/\n\n\nJSON语法与结构JSON 语法是 JavaScript 语法的子集\n数据在名称&#x2F;值对中\n数据由逗号 , 分隔\n使用斜杆 \\ 来转义字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\nJSON的两种结构：JSON 是一个字符串，其格式非常类似于 JavaScript 对象字面量的格式。你可以在 JSON 中包含与标准 JavaScript 对象相同的基本数据类型——字符串、数字、数组、布尔值和其他对象字面量。这使你可以构建一个数据层次结构，如下所示：\n&#123;  &quot;squadName&quot;: &quot;Super hero squad&quot;,  &quot;homeTown&quot;: &quot;Metro City&quot;,  &quot;formed&quot;: 2016,  &quot;secretBase&quot;: &quot;Super tower&quot;,  &quot;active&quot;: true,  &quot;members&quot;: [    &#123;      &quot;name&quot;: &quot;Molecule Man&quot;,      &quot;age&quot;: 29,      &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;,      &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;]    &#125;,    &#123;      &quot;name&quot;: &quot;Madame Uppercut&quot;,      &quot;age&quot;: 39,      &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;,      &quot;powers&quot;: [        &quot;Million tonne punch&quot;,        &quot;Damage resistance&quot;,        &quot;Superhuman reflexes&quot;      ]    &#125;,    &#123;      &quot;name&quot;: &quot;Eternal Flame&quot;,      &quot;age&quot;: 1000000,      &quot;secretIdentity&quot;: &quot;Unknown&quot;,      &quot;powers&quot;: [        &quot;Immortality&quot;,        &quot;Heat Immunity&quot;,        &quot;Inferno&quot;,        &quot;Teleportation&quot;,        &quot;Interdimensional travel&quot;      ]    &#125;  ]&#125;\n\n\n对象：大括号 &#123;&#125; 保存的对象是一个无序的名称&#x2F;值对集合。一个对象以左括号&#123; 开始， 右括号&#125;结束。每个”键”后跟一个冒号 :，名称&#x2F;值对使用逗号,分隔。\n数组：中括号[]保存的数组是值（value）的有序集合。一个数组以左中括号[开始， 右中括号]结束，值之间使用逗号,分隔。\n值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array），它们是可以嵌套。\n\n\n\nJSON名称 &#x2F; 键值对JSON 数据的书写格式是：\nkey : value\n\n名称&#x2F;值对包括字段名称（在双引号中），后面写一个冒号，然后是值：\n&quot;name&quot; : &quot;ErgouTree&quot;\n\n这很容易理解，等价于这条 JavaScript 语句：\nname = &quot;ErgouTree&quot;\n\nJSON 值可以是：\n\n数字（整数或浮点数）\n字符串（在双引号中）\n逻辑值（true 或 false）\n数组（在中括号中）\n对象（在大括号中）\nnull\n\nJSON 对象对象语法JSON 对象在大括号 {} 中书写，对象可以包含多个名称&#x2F;值对：\n&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;\n\nkey 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。\nkey 和 value 中使用冒号 : 分割。\n每个 key&#x2F;value 对使用逗号 , 分割。\n访问对象值你可以使用 点号 .  和 中括号[]来访问对象的值：\nvar myObj, x;myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;x = myObj[&quot;name&quot;];x = myObj.name;\n\n循环对象你可以使用 for-in 来循环对象的属性：\nvar myObj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null &#125;;for (x in myObj) &#123;    document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;&#125;\n\n嵌套JSON对象JSON 对象中可以包含另外一个 JSON 对象：\nmyObj = &#123;    &quot;name&quot;:&quot;runoob&quot;,    &quot;alexa&quot;:10000,    &quot;sites&quot;: &#123;        &quot;site1&quot;:&quot;www.runoob.com&quot;,        &quot;site2&quot;:&quot;m.runoob.com&quot;,        &quot;site3&quot;:&quot;c.runoob.com&quot;    &#125;&#125;\n\n你可以使用点号 . 或者中括号[...]来访问嵌套的 JSON 对象。\nx = myObj.sites.site1;// 或者x = myObj.sites[&quot;site1&quot;];\n\n修改值你可以使用点号  . 或中括号 []来通过赋值的方式修改 JSON 对象的值\nmyObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;;\n\n删除对象属性我们可以使用 delete 关键字来删除 JSON 对象的属性：\ndelete myObj.sites.site1;delete myObj.sites[&quot;site2&quot;]\n\n\n\nJSON数组数组作为 JSON 对象\nJSON 数组在中括号中书写。\n中括号 [] 保存的数组是值（value）的有序集合，值之间使用逗号 , 分隔。\nJavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。\n对象属性的值可以是一个数组\n&#123;&quot;name&quot;:&quot;网站&quot;,&quot;num&quot;:3,&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]&#125;// 访问x = myObj.sites[0];\n\n循环数组也可以使用，类似于 js 和 java的增强 for 循环\n修改和删除和对象一样\nmyObj.sites[1] = &quot;Github&quot;;delete myObj.sites[1];\n\n\n\nJSON.parse()JSON 通常用于与服务端交换数据。\n在接收服务器数据时一般是字符串。\n我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。\nJSON.parse(text[, reviver])\n\n参数说明：\n\n**text:**必需， 一个有效的 JSON 字符串。\nreviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。\n\nJSON解析实例例如我们从服务器接收了以下数据：\n&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;\n\n我们使用  JSON.parse()  方法处理以上数据，将其转换为 JavaScript 对象：\nvar obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);\n\n解析完成后，我们就可以在网页上使用 JSON 数据了：\n&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt;var obj = JSON.parse(&#x27;&#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; &#125;&#x27;);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;：&quot; + obj.site;&lt;/script&gt;\n\n从服务端接收 JSON 数据我们可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript 对象。\nvar xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123;    if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;        myObj = JSON.parse(this.responseText);        document.getElementById(&quot;demo&quot;).innerHTML = myObj.name;    &#125;&#125;;xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/json_demo.txt&quot;, true);xmlhttp.send();\n\n如果从服务端接收的是数组的 JSON 数据，则 JSON.parse 会将其转换为 JavaScript 数组：\n异常解析JSON 不能存储 Date 对象。\n如果你需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为 Date 对象。\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期: &quot; + obj.initDate;\n\n我们可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数。\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text, function (key, value) &#123;    if (key == &quot;initDate&quot;) &#123;        return new Date(value);    &#125; else &#123;        return value;&#125;&#125;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期：&quot; + obj.initDate;\n\nJSON 不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。\nvar text = &#x27;&#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:&quot;function () &#123;return 10000;&#125;&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;&#x27;;var obj = JSON.parse(text);obj.alexa = eval(&quot;(&quot; + obj.alexa + &quot;)&quot;); document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot; Alexa 排名：&quot; + obj.alexa();\n\n\n\nJSON.stringify()JSON 通常用于与服务端交换数据。\n在向服务器发送数据时一般是字符串。\n我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。\n语法\nJSON.stringify(value[, replacer[, space]])\n\n参数说明：\n\nvalue:\n必需， 要转换的 JavaScript 值（通常为对象或数组）。\n\nreplacer:\n可选。用于转换结果的函数或数组。\n如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。\n如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。\n\nspace:\n可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。\n\n\nJavaScipt对象转换例如我们向服务器发送以下数据：\nvar obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;\n\n使用  JSON.stringify()  方法处理以上数据，将其转换为字符串：\nvar myJSON = JSON.stringify(obj);\n\n可以将 myJSON 发送到服务器：\nvar obj = &#123; &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\n\n数组转换和对象转换差不多\nvar arr = [ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Facebook&quot; ];var myJSON = JSON.stringify(arr);document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\n\n异常解析JSON 不能存储 Date 对象。\nJSON.stringify() 会将所有日期转换为字符串。\nJSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。\nvar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\n\n我们可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生：\nvar obj = &#123; &quot;name&quot;:&quot;Runoob&quot;, &quot;alexa&quot;:function () &#123;return 10000;&#125;, &quot;site&quot;:&quot;www.runoob.com&quot;&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(&quot;demo&quot;).innerHTML = myJSON;\n\n\n\nJSON使用把 JSON 文本转换为 JavaScript 对象JSON 最常见的用法之一，是从 web 服务器上读取 JSON 数据（作为文件或作为 HttpRequest），将 JSON 数据转换为 JavaScript 对象，然后在网页中使用该数据。\n实例：\n创建包含 JSON 语法的 JavaScript 字符串\nvar txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;;\n\n由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。\neval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：\nvar txt = &#x27;&#123; &quot;sites&quot; : [&#x27; +&#x27;&#123; &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#x27; +&#x27;&#123; &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; &#125; ]&#125;&#x27;; var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); document.getElementById(&quot;name&quot;).innerHTML=obj.sites[0].name document.getElementById(&quot;url&quot;).innerHTML=obj.sites[0].url\n\n\n\n一些注意事项\nJSON 是一种纯数据格式，它只包含属性，没有方法。\nJSON 要求在字符串和属性名称周围使用双引号。单引号无效。\n甚至一个错位的逗号或分号就可以导致 JSON 文件出错。你应该小心的检查你想使用的数据（虽然计算机生成的 JSON 很少出错，只要生成程序正常工作）。你可以通过像 JSONLint 这样的应用程序来验证 JSON。\nJSON 实际上可以是任何可以有效包含在 JSON 中的数据类型的形式。比如，单个字符串或者数字就是有效的 JSON 对象。\n与 JavaScript 代码中对象属性可以不加引号不同，JSON 中只有带引号的字符串可以用作属性。\n\n","categories":["前端技术","JSON"],"tags":["实用知识","前端技术","JSON","JavaScript","语法知识"]},{"title":"Hibernate框架之实体类编写规则和Session","url":"/posts/21432.html","content":"持久化类Hibernate是持久层的ORM映射框架，专注于数据的持久化工作。\n所谓的持久化，就是将内存中的数据永久存储到关系型数据库中。\n所谓的持久化类指的是一个Java类与数据库表建立了映射关系，那么这个类称为是持久化类。\n其实你可以简单的理解为持久化类就是一个Java类有了一个映射文件与数据库的表建立了关系。\n那么我们编写持久化类的时候有哪些要求呢？\n实体类编写规则我们在编写持久化类的时候需要有一下几点需要注意：\n\n持久化类需要提供无参数的构造方法。因为在 Hibernate 的底层需要使用反射生成类的实例。\n\n持久化类的属性需要私有，对私有的属性提供公有的get和set方法。\n因为在Hibernate底层会将查询到的数据进行封装。也就是说，实体类里面属性是私有的\n\n持久化类的属性要尽量使用包装的类型。\n因为包装类和基本数据类型的默认值不同，包装类的类型语义描述更清晰而基本数据类型不容易描述。举个例子：\n假设表中有一列员工工资，如果使用double类型，如果这个员工工资忘记录入到系统中，系统会将默认值0存入到数据库，如果这个员工的工资被扣完了，也会向系统中存入0.那么这个0就有了多重含义，而如果使用包装类类型就会避免以上情况。如果使用Double类型，忘记录入的工资就会存入null，而如果这个员工的工资被扣完了，就会存入0，不会产生歧义。\n\n持久化类要有一个唯一标识OID与表的主键对应，也就是要求实体类有属性作为唯一值（一般使用id值）\n因为Hibernate中需要通过这个唯一标识OID区分在内存中是否是同一个持久化类。在Java中通过地址区分是否是同一个对象，在关系型数据库的表中是通过主键区分是否是同一条记录。那么Hibernate就是通过这个OID来进行区分的。Hibernate是不允许在内存中出现两个OID相同的持久化对象的。\n\n持久化类尽量不要使用final进行修饰。\n因为Hibernate中有延迟加载的机制，这个机制中会产生代理对象，Hibernate产生代理对象使用的是字节码的增强技术完成的，其实就是产生了当前类的一个子类对象实现的。如果使用了final修饰持久化类。那么就不能产生子类，从而就不会产生代理对象，那么Hibernate的延迟加载策略（是一种优化手段）就会失效。\n\n\n持久化类我们已经可以正常编写了，但是在持久化类中需要有一个唯一标识OID与表的主键去建立映射关系。而且主键一般我们是不会让客户手动录入的，一般我们是由程序生成主键。那么Hibernate中也提供了相应的主键生成的方式，下面我们来看Hibernate的主键生成策略。\n主键生成策略主键的类型在讲解Hibernate的主键生成策略之前，先来了解两个概念，即自然主键和代理主键，具体如下：\n\n自然主键（少见）：把具体业务含义的字段作为主键，称之为自然主键。\n例如在customer表中，如果把name字段作为主键，其前提条件必须是：每一个客户的名字不允许为null，不允许客户重名，并且不允许修改客户姓名。尽管这也是可行的，但是不能满足不断变化的业务需求，一旦出现了允许客户重名的业务需求，就必须修改数据模型，重新定义表的主键，这给数据库的维护增加了难度。\n\n代理主键：把不具备业务含义的字段作为主键（一般是ID），称之为代理主键。\n该字段一般取名为”ID“，通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间。在上面的例子中，显然更合理的方式是使用代理主键。\n\n\n主键生成策略hibernate要求实体类里面有一个属性作为唯一值，对应表主键，主键可以不同生成策略\nHibernate中，提供了几个内置的主键生成策略，其常用主键生成策略的名称和描述如下：\n\n自然主键\nassigned：自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入。如果不知道 id 元素的generator属性，则默认使用该主键生成策略。\n\n\n代理主键\nidentity：主键自增.要求在数据库中把主键定义为自增长类型.录入时不需要指定主键.\nsequence：Oracle中的主键生成策略.\nincrement(了解)：主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值.只有当没有其他进程向同一张表中插入数据时才可以使用，不能在集群环境下使用。\nnative：hilo+sequence+identity 自动三选一策略.适合跨数据库平台开发 自动增长\nuuid：产生随机字符串作为主键. 主键类型必须为string 类型.\n\n\n\n\n持久化对象的状态持久化对象的三种状态Hibernate为了更好的来管理持久化类，将持久化类分成了三种状态：瞬时态、持久态和脱管态，一个持久化类的实例可能处于三种不同状态中的某一中。\n　　1、瞬时态（transient）\n​       对象里面没有id值，对象与session没有关联，不处于 Session 的缓存中\n　　瞬时态也称为临时态或者自由态，瞬时态的实例是由new命令创建、开辟内存空间的对象，不存在持久化标识OID（相当于主键值），尚未与Hibernate的Session关联，在数据库中也没有记录，失去引用后将被JVM回收。瞬时状态的对象在内存中是孤立存在的，与数据库的数据没有任何关联，仅是一个信息携带的载体。\n　　2、持久态（persistent）\n​       对象里面有id值，对象与session关联，也是持久化对象\n　　持久态的对象存在持久化标识OID，加入到了Session缓存中，并且相关联的Session没有关闭，在数据库中有对应的记录，每条记录只对应唯一的持久化对象，需要注意的是，持久态对象是在事务还未提交前变成持久态的。\n　　3、脱管态（detached）\n​       对象有id值，对象与session没有关联\n　　脱管态也称为离线态或者游离态，当某个持久化状态的实例与Session的关联被关闭时就变成了脱管态。脱管态对象存在持久化标识OID，并且仍然与数据库中的数据存在关联，只是失去了与当前Session的关联，脱管状态对象发生改变时Hibernate不能检测到。\n区分对象的三种状态@Test    public void demo1() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();                Customer customer = new Customer(); //瞬时态对象:没有持久化标识OID,没有被session管理        customer.setCust_name(&quot;王五&quot;);        session.save(customer); // 持久化对象:有持久化标识OID,被session管理                tx.commit();        session.close();                System.out.println(customer); //脱管态对象:有持久化标识OID,没有被session管理    &#125;\n\ncustomer对象由new关键字创建，此时还未与Session进行关联，它的状态称为瞬时态；在执行了session.save(customer)操作后，customer对象纳入了Session的管理范围，这时的customer对象变成了持久态对象，此时Session的事务还没有被提交；程序执行完commit()操作并关闭了Session后，customer对象与Session的关联被关闭，此时customer对象就变成了脱管态。\n三种状态的转换\n从图中可以看出，当一个对象被执行new关键字创建后，该对象处于瞬时态；当对瞬时态对象执行Session的save()或saveOrUpdate()方法后，该对象将被放入Session的一级缓存，对象进入持久态；当对持久态对象执行evict()、close()或clear()操作后，对象进入脱管态（游离态）；当直接执行Session的get()、load()、find()或iterate()等方法从数据库里查询对象时，查询到的对象也处于持久态；当对数据库中的记录进行update()、saveOrUpdate()以及lock()等操作后，此时脱管态的对象就过渡到持久态；由于瞬时态和脱管态的对象不在Session的管理范围，所以一段时间后会被JVM回收。\n持久化对象的三种状态可以通过调用Session中的一系列方法实现状态间的转换，具体如下：\n瞬时态转换到其他状态\n通过前面学习可知，瞬时态的对象由new关键字创建，瞬时态对象转换到其他状态总结如下：\n\n瞬时态转换为持久态：执行Session的save()或saveOrUpdate()方法。\n瞬时态转换为脱管态：为瞬时态对象设置持久化标识OID。\n\n　　由于持久化对象状态演化图中没有涉及到瞬时态转换到脱管态的情况，这里做下简要的说明，在前面的学习中可知，脱管态对象存在OID，但是没有Session的关联，也就是说脱管态和瞬时态的区别就是OID有没有值，所以可以通过为瞬时态对象设置OID，使其变成脱管态对象。\n持久态对象转换到其他状态\n持久化对象可以直接通过Hibernate中Session的get()、load()方法，或者Query查询从数据库中获得，持久态对象转换到其他状态总结如下： \n\n持久态转换为瞬时态：执行Session的delete()方法，需要注意的是被删除的持久化对象，不建议再次使用。\n持久态转换为脱管态：执行Session的evict()、close()或clear()方法。evict()方法用于清楚一级缓存中某一对象；close()方法用于关闭Session，清楚一级缓存；clear()方法用于清除一级缓存的所有对象。\n\n脱管态对象转换到其他状态\n脱管态对象无法直接获得，是由其他状态对象转换而来的，脱管态对象转换到其他状态总结如下：\n\n脱管态转换为持久态：执行Session的update()、saveOrUpdate()或lock()方法。\n脱管态转化为瞬时态：将脱管态对象的持久化标识OID设置为null。\n\n由于持久化对象状态演化图中没有涉及到脱管态转换到瞬时态的情况，这里做下简要的说明，跟瞬时态转换到脱管态的情况相似，脱管态和瞬时态的区别就是OID有没有值，所有可以通过将脱管态对象的OID设置为null，使其变成瞬时态对象。例如在session.close()操作后，加入代码customer.setCust_id(null)，customer对象将由脱管态转化为瞬时态。\n持久态对象能够自动更新数据库// 测试持久化类的持久化对象有自动更新数据库的能力    @Test    public void demo2() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();        // 获得持久化对象        Customer customer = session.get(Customer.class, 1l);        customer.setCust_name(&quot;王五&quot;);        // session.update(customer); // 不用手动调用update方法j就可以更新        tx.commit();        session.close();    &#125;\n\n执行测试我们会发现，我们并没有手动调用update方法，Hibernate就可以将数据自动更新了。持久态对象之所以有这样的一个功能，其实都依赖了HIbernate的一级缓存。\n\n这一部分参考 https://www.cnblogs.com/yft-javaNotes/p/10244422.html\n\nHibernate的一级缓存hibernate的一级缓存默认打开的\nhibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围\nhibernate的一级缓存中，存储数据必须 持久态数据\nHibernate的缓存分为一级缓存和二级缓存（二级缓存现在不使用了），Hibernate的这两级缓存都位于持久化层，存储的都是数据库数据的备份。其中第一级缓存为Hibernate的内置缓存，不能被卸载。接下来围绕Hibernate的一级缓存进行详细的讲解。\nHibernate的一级缓存就是指Session缓存，Session缓存是一块内存空间，用来存放相互管理的Java对象，在使用Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值的对象，则会去数据库中查找相应的数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。Hibernate一级缓存的作用就是减少对数据库的访问次数。\n在Session接口的实现中包含一系列的Java集合，这些Java集合构成了Session缓存。只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。所以一级缓存也被称为Session的基本缓存。\nHibernate的一级缓存有如下特点：\n\n当应用程序调用Session接口的save()、update()、saveOrUpdate()时，如果Session缓存中没有相应的对象，Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。\n当调用Session接口的load()、get()方法，一级Query接口的list()、iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要查询的对象，再去数据库中查询相应的对象，并添加到一级缓存中。\n当调用Session的close()方法时，Session缓存会被清空。\n\n测试一级缓存\n// 证明Hibernate一级缓存的存在    @Test    public void demo3() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();        // 马上发送一条sql语句查询1号客户,并将数据存入缓存        Customer customer1 = session.get(Customer.class, 1l);        System.out.println(customer1);        // 没有发送sql语句,从缓存中取的数据        Customer customer2 = session.get(Customer.class, 1l);        System.out.println(customer2);        // true 一级缓存缓存的是对象的地址        System.out.println(customer1 == customer2);        tx.commit();        session.close();    &#125;\n\n以上代码中，第一次执行Session的get()方法获取customer1对象时，由于一级缓存中没有数据，所以Hibernate会向数据库发送一条sql语句，查询id为1的对象；当再次调用Session的get()方法获取customer2对象时，不会再发送sql语句，这是因为customer2对象是从一级缓存中获取的。\n当Session对象的生命周期还没有结束的时候,在查询相同的数据对象,会现在缓存之中寻找,如果有找到就直接使用缓存中的数据.\n\n接下来验证一下代码的执行结果是否和描述的一致。在Customer customer1 &#x3D;  session.get(Customer.class,  1l);这一行设置断点，用debug方式执行该方法，程序进入断点后点击单步跳过（F6），代码执行过System.out.println(customer1);语句后，控制台的输出结果如下：\n\n从上图的输出结果可以看出，customer2对象的查询结果被直接打印了，说明第二次调用Session对象的get()方法时，没有向数据库发送select语句，而是直接从一级缓存中获取customer2对象。\n之前我们介绍过，Hibernate的持久态对象能够自动更新数据库，其实就是依赖了一级缓存。那么一级缓存为什么就可以去更新数据库呢？其实是因为一级缓存的一块特殊区域——快照区。\n\nHIbernate向一级缓存放入数据时，同时复制一份数据放入到Hibernate的快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果这两个对象中的属性发送变化，则执行update语句，将缓存中的内容同步到数据库，并更新快照；如果一致，则不执行update语句。Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。\n// 一级缓存中的快照区:持久态对象能够自动更新数据库    @Test    public void demo4() throws Exception &#123;        Session session = HibernateUtils.openSession();        Transaction tx = session.beginTransaction();                Customer customer = session.get(Customer.class, 1l);        customer.setCust_name(&quot;张三&quot;);                // 比对缓存中和快照区的数据是否一致,如果一致,不更新数据库        // 如果不一致则自动更新数据库        tx.commit();        session.close();    &#125;\n\n\n\n\n\nHibernate SessionSession 概述Session 是什么\n\n持久化管理器：负责执行所有持久化操作的核心接口\n短生命周期对象：通常一个业务操作对应一个Session\n一级缓存：维护了持久化对象的缓存\n工作单元：代表应用程序与数据库的一次会话\n\nSession 概述\n\nSession接口是Hibernate向应用程序提供的操纵数据库的最主要的接口，它提供了基本的保存，更新，删除和加载Java对象的方法\n\nSession 具有一个缓存, 位于缓存中的对象称为持久化对象, 它和数据库中的相关记录对应。Session 能够在某些时间点, 按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库, 这一过程被称为刷新缓存(flush)。也叫一级缓存。\n在 Session 接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存。 只要 Session 实例没有结束生命周期, 且没有清理缓存，则存放在它缓存中的对象也不会结束生命周期。Session 缓存可减少 Hibernate 应用程序访问数据库的频率。\nsession缓存的示例\n@Test    public void getUser()&#123;        User user=session.get(User.class,1);        User user2=session.get(User.class,1);        System.out.println(user);        System.out.println(user2);//查询出来的两条记录完全一样    &#125;\n\n站在持久化的角度，Hibemate把对象分为4种状态：持久化态，临时状态，游离状态，删除状态，Session的特定方法能使对象从一个状态转换到另一个状态.\n\n\nSession 核心方法对象状态管理方法\n\n\n\n方法\n说明\n对象状态变化\n\n\n\nsave()\n将临时对象持久化\n临时 → 持久\n\n\npersist()\n同save()，但无返回值\n临时 → 持久\n\n\nget()\n立即加载对象\n无 → 持久\n\n\nload()\n延迟加载对象\n无 → 代理(持久)\n\n\nupdate()\n更新脱管对象\n脱管 → 持久\n\n\nmerge()\n合并脱管对象状态\n脱管 → 持久\n\n\ndelete()\n删除对象\n持久 → 删除\n\n\nsaveOrUpdate()\n智能保存或更新\n临时&#x2F;脱管 → 持久\n\n\nevict()\n从缓存移除对象\n持久 → 脱管\n\n\nclear()\n清空整个缓存\n所有持久 → 脱管\n\n\nflush()\n同步缓存与数据库\n保持状态\n\n\n查询方法\n\n\n\n方法\n说明\n\n\n\ncreateQuery()\n创建HQL查询\n\n\ncreateSQLQuery()\n创建原生SQL查询\n\n\ncreateCriteria()\n创建Criteria查询(已废弃)\n\n\nbyId()\n通过ID加载(5.2+)\n\n\n事务控制方法\n\n\n\n方法\n说明\n\n\n\nbeginTransaction()\n开始事务\n\n\ngetTransaction()\n获取当前事务\n\n\n缓存管理方法\n**evict()**：移除特定对象\nsession.evict(student); // 从缓存移除该对象\n\n**clear()**：清空整个缓存\nsession.clear(); // 清空所有缓存对象\n\n**contains()**：检查对象是否在缓存\nboolean cached = session.contains(student);\n\n\n\nsession缓存的操作方法\nflush方法：session会按照缓存中对象属性的变化来更新数据库中的记录，使数据库中记录和缓存中的对象保持一致，默认情况下，在以下时间点会刷新缓存：\n\n当应用程序调用Transaction.commit()方法时，该方法会先调用flush()方法，然后在 向 数据库提交事务\n\n显示的调用flush()方法时\n\n当应用程序执行一些查询(HQL, Criteria)操作时，如果缓存中持久化对象的属性已经发生了变化，会先 flush 缓存，以保证查询结果能够反映持久化对象的最新状态\n\n\nflush 缓存的例外情况:\n如果对象使用 native 生成器生成 OID, 那么当调用 Session 的 save() 方法保存对象时, 会立即执行向数据库插入该实体的 insert 语句.\nflush()和commit()方法的区别：\nflush()方法会执行一系列的sql语句，但是不会提交事物；commit()在提交事物前，会先调用flush()方法，然后再提交事物，提交事物以为这将数据库的操作永久的保存下来\n测试flush方法\n@Testpublic void testFlush()&#123;    News vo = (News) this.session.get(News.class,1);    vo.setInfo(&quot;flush()方法测试&quot;);    this.session.flush();//调用flush()方法    System.out.println(vo);&#125;\n\n可以发现当调用了修改了缓存之中的对象,在调用了flush()方法之后,会执行update语句以来保证缓存之中的数据和数据库之中的数据保持同步\n\n数据库之中保存的数据\n\nrefresh：refresh会强制发送select语句， 以使数据库中的记录和缓存中的对象保持一致；如果在调用refresh方法前，手动的修改数据库中的记录，查询出来的结果还不是最新的，这跟数据库的数据的隔离级别是相关的，可以在配置文件中显示的修改事物的隔离级别，每一个隔离级别都对应一个整数；\n@Testpublic void testReFlush()&#123;    News vo = (News) this.session.get(News.class,1);    /*使用断点,暂停程序,暂停程序的时候修改数据库中的数据,查看最后输出的内容是否有变化*/    this.session.refresh(vo);    System.out.println(vo);&#125;\n\n在暂停的时候修改数据库中的info数据\n\n但是会发现最后输出的结果并不是修改过的数据，因为可重复读的隔离级别，事务持续期间，禁止其他事务对这个字段进行更新。\n\n缓存同步机制\n自动同步：在以下时机会自动flush：\n\n事务提交时\n执行查询前(确保查询结果准确)\n显式调用session.flush()\n\n手动同步：\nsession.flush(); // 强制同步缓存与数据库\n\n\n\nevict()从session缓存中把指定的持久化对象移除\n@Testpublic void testEvict()&#123;    //使用load()方法将数据库中的一个对象将在到缓存之中    News vo1 = (News)this.session.load(News.class,4);        //使用evict()方法将缓存中的对象清除    this.session.evict(vo1);    //当要使用该对象的时候,系统无法从缓存之中初始化该对象,就会出现异常    System.out.println(vo1);&#125;\n\n\nSession核心方法详解对实体类 CURD 操作添加操作通过调用session里面的save方法实现\nsave()方法最大的特点就是将一个临时对象变为持久化对象\n为对象分配ID\n在flush()缓存时会发送一条INSERT语句.\n@Testpublic void testSave()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);    System.out.println(vo);    this.session.save(vo);    System.out.println(vo);&#125;\n\n\n\n在save()执行前，设置ID的方法是无效的，在save()方法执行过后修改id，会出现异常\n\n@Testpublic void testSave()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);        //在save()方法执行前设置ID    vo.setId(12345);        System.out.println(vo);    this.session.save(vo);    // 在save()方法执行过后修改id，会出现异常    vo.setId(12345);    System.out.println(vo);&#125;\n\n\n持久化对象的ID是不能够被修改的\n\n通过调用 presist() 方法\npersist()方法也会执行INSERT操作，与save()类似，但无返回值\n在presist()方法执行之前,如果对象已经有ID值,则不会执行INSERT,而会抛出一个异常.\n@Testpublic void testPersist()&#123;    News vo = new News();    vo.setTitle(&quot;testSave()&quot;);    vo.setInfo(&quot;测试Save&quot;);    vo.setPrice(55.0);    vo.setId(12345);    System.out.println(vo);    this.session.persist(vo);    System.out.println(vo);&#125;\n\n\n与save()的区别：\n\n不保证立即执行INSERT(可能在flush时执行)\n\n不返回ID，需通过对象获取\n\nJPA规范方法，行为更标准化\n\n\n查询操作调用session里面的get方法实现\n执行get()方法会立即加载对象，session.get(实体类的class, id值)是根据 id 查询\n@Testpublic void testGet()&#123;    News getVo = (News)this.session.get(News.class,1);    System.out.println(getVo.getClass().getName());&#125;\n\n特点：\n\n立即发出SELECT语句\n\n对象不存在时返回null\n\n返回真实对象(非代理)\n\n\n调用session里面的load方法实现\n延迟加载，返回代理对象\n执行load方法，若不使用该对象，则不会立即执行查询操作，而返回一个代理对象.\n// 返回代理对象，不立即查询Student student = session.load(Student.class, 1L);System.out.println(&quot;尚未查询数据库&quot;);// 实际访问非ID属性时才触发查询System.out.println(student.getName());  \n\n可以发现使用load()方法得到的对象在没有使用的情况下是一个代理对象,这是因为使用load()方法得到的对象，在没有使用任何属性的情况下，不会立即加载,而是加载到内存之中，在有需要的时候再加载对象.\n\n延迟加载(访问非ID属性时查询)\n对象不存在时抛ObjectNotFoundException\n返回代理对象(运行时生成子类)\n\n若查询一个数据表中没有的记录,而且Session也没有被关闭,同时需要使用对象的时候.   \n\n使用get方法查询会：返回null\n使用load方法查询：若不是用该对象的任何属性没有问题，若需要初始化，抛出异常.\n\n在需要初始化代理对象之前若关闭Session. load方法可能会抛出 异常\n@Testpublic void testLoad()&#123;    News  loadVo = (News)this.session.load(News.class,1888);    this.session.close();//在使用loadVO类之前关闭session    System.out.println(loadVo);&#125;\n\n抛出的异常org.hibernate.LazyInitializationException: could not initialize proxy - no Session(无法初始化代理,没有Session)\n\n更新操作自动脏检查更新\n最常用方式：Hibernate自动检测变化\nStudent student = session.get(Student.class, 1L);student.setName(&quot;王五&quot;);  // 修改属性student.setEmail(&quot;wangwu@example.com&quot;);// 无需调用update方法，提交时自动更新tx.commit();  // 触发UPDATE语句\n\n\nSession跟踪持久化对象的状态\n\nflush时比较快照，生成UPDATE语句\n\n\n调用session里面的update方法实现\n首先查询，修改值，然后调用 update 显式更新脱管对象\nupdate()方法相当于sql语句之中的Update语句\n\n若更新一个持久化对象，不必显示的调用update()方法，因为在调用Transaction的commit()方法时，会调用session的flush()\n更新一个游离对象，需要显示的调用update()方法，可以将一个游离对象转换为持久化对象\n当 update() 方法关联一个游离对象时, 如果在 Session 的缓存中已经存在相同 OID 的持久化对象, 会抛出异常\n当 update() 方法关联一个游离对象时, 如果在数据库中不存在相应的记录, 也会抛出异常. \n注意：\n\n无论要更新的游离对象是否与数据表中的记录是否一致,都会发送Update语句.\n\n@Testpublic void  testUpdate()&#123;    News temp =new News();    temp.setId(1);    temp.setTitle(&quot;update()方法测试&quot;);    temp.setPrice(550.2);    temp.setInfo(&quot;testUpdate&quot;);    temp.setPubDate(new Date());    this.session.update(temp);&#125;\n\n\n如何能让update方法不再盲目的触发update语句?在.hbm.xml文件的class节点设置一个select-before-update&#x3D;“true”()但通常不使用该属性\n&lt;class name=&quot;News&quot; table=&quot;NEWS&quot; select-before-update=&quot;true&quot;&gt;\n\n\n如果数据表中没有对应的记录,但还调用了update方法,会抛出异常\n\n当update()方法关联一个游离对象时,如果在Session的缓存之中已经存在了相同的OID的持久化对象.会出现异常,因为在Session缓存中,不能够同时存在两个OID相同的对象，也就是说 同ID对象已存在于Session时会抛异常\n@Test public void  testUpdate()&#123;     //使用get()方法得到一个持久化对象,此时这个对象会保存在session的缓存之中     News vo = (News) this.session.get(News.class,1);        //创建一个于vo的id相同的对象     News temp = new News();     temp.setId(vo.getId());     //使用update()方法关联这个temp对象     //由于此时的temp对象和vo对象的id都是相同的     //并且vo对象已经保存在了session之中     //所以当使用update()方法的时候,就会出现在同一session之中存在两个id相同的对象     this.session.update(temp); &#125;   \n\n\n\n应确保对象所有属性已设置(否则可能覆盖为null)\n\n\n调用session里面的merge方法实现\n更安全的更新方式\n将脱管对象的状态复制到持久化对象中\nStudent detachedStudent = new Student();detachedStudent.setId(1L);detachedStudent.setName(&quot;钱七&quot;);Session newSession = sessionFactory.openSession();newSession.beginTransaction();// 合并对象状态Student persistentStudent = (Student) newSession.merge(detachedStudent);// merge返回的是持久化对象，参数对象仍为脱管状态System.out.println(detachedStudent == persistentStudent);  // falsenewSession.getTransaction().commit();newSession.close();\n\n方法工作流程\n\n检查传入对象：\n如果为 null，直接返回 null\n如果是持久化状态，直接返回该对象（无操作）\n\n\n查找对应持久化对象：\n在 Session 缓存中查找同 ID 的实体\n如果找到，将脱管对象属性值复制到该持久化对象\n如果未找到，从数据库加载或创建新实例\n\n\n返回值处理：\n返回的是持久化对象（可能是缓存中的或新创建的）\n重要：传入的参数对象不会被关联到 Session\n\n\n状态同步：\n在 flush 时，生成的持久化对象会同步到数据库\n\n\n\nmerge() 与 update() 的对比\n\n\n\n特性\nmerge()\nupdate()\n\n\n\n同ID对象存在时\n合并属性值到持久化对象\n抛出NonUniqueObjectException\n\n\n返回值\n返回持久化对象\n无返回值\n\n\n参数对象状态\n保持脱管状态\n转为持久化状态\n\n\nSQL执行时机\n根据flush策略\n根据flush策略\n\n\n级联行为\n支持CascadeType.MERGE\n支持CascadeType.UPDATE&#x2F;SAVE_UPDATE\n\n\n新对象处理\n可能转为save操作\n抛出TransientObjectException\n\n\n性能\n可能需要额外SELECT\n直接操作\n\n\n调用session里面的saveOrUpdate方法实现\nSession 的 saveOrUpdate() 方法同时包含了 save() 与 update() 方法的功能，自动判断保存或更新\n\n// 新对象(无ID) - 执行INSERTStudent newStudent = new Student();newStudent.setName(&quot;孙八&quot;);session.saveOrUpdate(newStudent);// 脱管对象(有ID) - 执行UPDATEStudent detachedStudent = new Student();detachedStudent.setId(1L);detachedStudent.setName(&quot;周九&quot;);session.saveOrUpdate(detachedStudent);\n\n判断对象是不是临时对象：\n\nJava 对象的 OID 为 null\n\n映射文件中为 &lt;id&gt; 设置了 unsaved-value 属性, 并且 Java 对象的 OID 取值与这个 unsaved-value 属性值匹配\n\n\n判断逻辑：\n\n对象ID为null → save()\n对象ID非null → update()\n\n如果OID不为null,但数据表中还没有和其对应的记录,会抛出一个异常.\n@Testpublic void testSaveOrUpdate()&#123;    News news = new News();    news.setId(123456);//此时数据库之中不存在此id的数据    this.session.saveOrUpdate(news);//如果调用saveOrUpdate()方法就会出现异常&#125;\n\n\n删除操作调用session中的delete() 方法\n删除持久化对象，只要OID和数据表中的一条记录对应，就执行delete操作\n如果OID和数据库中的一条记录保持一致，则执行删除操作，把对象从 Session 缓存中删除,  该对象进入删除状态，若OID在数据库中没有对应的记录，则抛出异常，Hibernate 的 cfg.xml 配置文件中有一个  hibernate.use_identifier_rollback 属性, 其默认值为 false, 若把它设为 true，改变  delete() 方法的运行行为: delete() 方法会把持久化对象或游离对象的 OID 设置为 null, 使它们变为临时对象，软删除\nStudent student = session.get(Student.class, 1L);// 删除对象session.delete(student);  // 转为Removed状态// 也可以直接删除(避免先查询)Student studentToDelete = new Student();studentToDelete.setId(2L);session.delete(studentToDelete);  // 按ID删除tx.commit();  // 执行DELETE语句\n\n注意事项：\n\n删除后对象变为Removed状态\n关联对象需考虑级联删除\n批量删除建议使用HQL更高效\n\nSession 方法的完整例子使用 spring data jpa\n添加依赖\n&lt;dependencies&gt;    &lt;!-- Spring Boot Starter Data JPA --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;!-- H2 数据库 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.h2database&lt;/groupId&gt;        &lt;artifactId&gt;h2&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- Lombok --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n应用配置 (application.yml)\nspring:  datasource:    url: jdbc:h2:mem:testdb    driver-class-name: org.h2.Driver    username: sa    password:   jpa:    hibernate:      ddl-auto: update    show-sql: true    properties:      hibernate:        format_sql: true\n\n定义实体类\nimport javax.persistence.*;import lombok.Data;@Data@Entity@Table(name = &quot;students&quot;)public class Student &#123;        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(nullable = false)    private String name;        private String email;        private Integer age;        @Version    private Integer version; // 乐观锁版本字段&#125;\n\nRepository 接口\nimport org.springframework.data.jpa.repository.JpaRepository;public interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123;&#125;\n\n完整 Service 示例\nimport javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.transaction.Transactional;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class StudentService &#123;        @PersistenceContext    private EntityManager entityManager; // 相当于Hibernate Session        private final StudentRepository studentRepository;        public StudentService(StudentRepository studentRepository) &#123;        this.studentRepository = studentRepository;    &#125;        // ========== 创建操作 ==========        /**     * 使用EntityManager的persist方法     */    @Transactional    public Long createWithPersist(Student student) &#123;        entityManager.persist(student);        return student.getId(); // 返回生成的ID    &#125;        /**     * 使用Repository的save方法     */    @Transactional    public Student createWithSave(Student student) &#123;        return studentRepository.save(student);    &#125;        // ========== 读取操作 ==========        /**     * 使用EntityManager的find方法(相当于get)     */    @Transactional    public Student findById(Long id) &#123;        return entityManager.find(Student.class, id);    &#125;        /**     * 使用EntityManager的getReference方法(相当于load)     */    @Transactional    public Student lazyFindById(Long id) &#123;        return entityManager.getReference(Student.class, id);    &#125;        /**     * 使用Repository方法查询     */    public List&lt;Student&gt; findAllStudents() &#123;        return studentRepository.findAll();    &#125;        // ========== 更新操作 ==========        /**     * 自动脏检查更新     */    @Transactional    public Student updateWithDirtyChecking(Long id, String newName) &#123;        Student student = entityManager.find(Student.class, id);        student.setName(newName);        return student; // 事务提交时会自动更新    &#125;        /**     * 使用merge方法更新脱管对象     */    @Transactional    public Student updateWithMerge(Student detachedStudent) &#123;        return entityManager.merge(detachedStudent);    &#125;        // ========== 删除操作 ==========        /**     * 使用EntityManager的remove方法     */    @Transactional    public void deleteWithRemove(Long id) &#123;        Student student = entityManager.find(Student.class, id);        if (student != null) &#123;            entityManager.remove(student);        &#125;    &#125;        /**     * 使用Repository的delete方法     */    @Transactional    public void deleteWithRepository(Long id) &#123;        studentRepository.deleteById(id);    &#125;        // ========== 其他操作 ==========        /**     * 刷新对象状态     */    @Transactional    public Student refreshStudent(Long id) &#123;        Student student = entityManager.find(Student.class, id);        entityManager.refresh(student); // 从数据库重新加载        return student;    &#125;        /**     * 清空持久化上下文     */    @Transactional    public void clearPersistenceContext() &#123;        entityManager.clear();    &#125;        /**     * 立即刷新到数据库     */    @Transactional    public void flushChanges() &#123;        entityManager.flush();    &#125;&#125;\n\n测试控制器\nimport org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/api/students&quot;)public class StudentController &#123;        private final StudentService studentService;        public StudentController(StudentService studentService) &#123;        this.studentService = studentService;    &#125;        @PostMapping    public Long createStudent(@RequestBody Student student) &#123;        return studentService.createWithPersist(student);    &#125;        @GetMapping(&quot;/&#123;id&#125;&quot;)    public Student getStudent(@PathVariable Long id) &#123;        return studentService.findById(id);    &#125;        @GetMapping(&quot;/lazy/&#123;id&#125;&quot;)    public Student getStudentLazy(@PathVariable Long id) &#123;        Student student = studentService.lazyFindById(id);        System.out.println(&quot;Before access: Proxy object&quot;);        System.out.println(&quot;Name: &quot; + student.getName()); // 触发实际加载        return student;    &#125;        @GetMapping    public List&lt;Student&gt; getAllStudents() &#123;        return studentService.findAllStudents();    &#125;        @PutMapping(&quot;/&#123;id&#125;&quot;)    public Student updateStudent(@PathVariable Long id, @RequestBody Student student) &#123;        student.setId(id);        return studentService.updateWithMerge(student);    &#125;        @PatchMapping(&quot;/&#123;id&#125;&quot;)    public Student updateName(@PathVariable Long id, @RequestParam String name) &#123;        return studentService.updateWithDirtyChecking(id, name);    &#125;        @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void deleteStudent(@PathVariable Long id) &#123;        studentService.deleteWithRemove(id);    &#125;        @PostMapping(&quot;/refresh/&#123;id&#125;&quot;)    public Student refresh(@PathVariable Long id) &#123;        return studentService.refreshStudent(id);    &#125;&#125;\n\n测试用例\nimport javax.transaction.Transactional;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTest@Transactionalclass StudentServiceTest &#123;        @Autowired    private StudentService studentService;        @Test    void testFullCrudCycle() &#123;        // 1. 创建        Student student = new Student();        student.setName(&quot;Test Student&quot;);        student.setEmail(&quot;test@example.com&quot;);        student.setAge(20);                Long id = studentService.createWithPersist(student);        assertNotNull(id);                // 2. 查询        Student found = studentService.findById(id);        assertEquals(&quot;Test Student&quot;, found.getName());                // 3. 更新(自动脏检查)        found.setName(&quot;Updated Name&quot;);        // 不需要显式调用update方法                // 4. 验证更新        Student updated = studentService.findById(id);        assertEquals(&quot;Updated Name&quot;, updated.getName());                // 5. 删除        studentService.deleteWithRemove(id);                // 6. 验证删除        Student deleted = studentService.findById(id);        assertNull(deleted);    &#125;        @Test    void testMergeDetachedEntity() &#123;        // 1. 创建并持久化        Student student = new Student();        student.setName(&quot;Original&quot;);        Long id = studentService.createWithPersist(student);                // 2. 模拟脱管对象        Student detached = new Student();        detached.setId(id);        detached.setName(&quot;Detached&quot;);        detached.setAge(25);                // 3. 合并        Student merged = studentService.updateWithMerge(detached);                // 验证        assertEquals(id, merged.getId());        assertEquals(&quot;Detached&quot;, merged.getName());        assertEquals(25, merged.getAge());    &#125;&#125;\n\nSpring Data JPA 与 Hibernate Session 的关系\n\n**EntityManager**：JPA 标准接口，Spring Data JPA 底层使用 Hibernate 实现\npersist() → Hibernate save()/persist()\nmerge() → Hibernate merge()\nfind() → Hibernate get()\ngetReference() → Hibernate load()\nremove() → Hibernate delete()\n\n\nRepository 方法：\nsave()：实际执行 merge 语义\ndeleteById()：先查询再删除\n\n\n\n事务管理\n\n@Transactional 注解自动管理事务边界\n方法结束时自动提交，异常时回滚\n同一个事务内共享持久化上下文\n\n乐观锁冲突处理\n@Transactionalpublic Student updateWithOptimisticLock(Long id, String newName) &#123;    Student student = studentRepository.findById(id)        .orElseThrow(() -&gt; new RuntimeException(&quot;Student not found&quot;));        student.setName(newName);        try &#123;        return studentRepository.save(student);    &#125; catch (ObjectOptimisticLockingFailureException e) &#123;        // 处理并发修改冲突        throw new RuntimeException(&quot;数据已被其他用户修改，请刷新后重试&quot;);    &#125;&#125;\n\n","categories":["Java学习","Hibernate框架"],"tags":["Java技术","JavaWeb","Hibernate","数据库技术","框架知识"]},{"title":"JavaWeb-http","url":"/posts/31243.html","content":"HTTP请求客户端–&gt;请求–&gt;服务器\n\n超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\n\nHTTP是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。\n\n\n以请求百度为例\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\nAccept: text/htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9  语言Cache-Control: max-age=0Connection: keep-alive\n\n1.请求行请求行中的请求方式：GET\n\n\n\nGET请求方式\n请求方式：\n\n\n\n2.消息头\n\n\nAccept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接\n\n\n\nHTTP响应服务器–&gt;响应–&gt;客户端\n例子\nRequest URL: https://www.baidu.com/  请求地址Request Method: GET 请求方法get/postStatus Code: 200 OK  状态码Remote Address: 36.152.44.96:443   远程地址ip+端口\n\n响应体Accept: 告诉浏览器，请求支持的数据类型Accept-Encoding: 支持的编码格式Accept-Language:   语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完是断开还是保持连接Refresh:表示浏览器应该在多少时间之后刷新文档，以秒计。Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的    sendRedirect方法，该方法同时设置状态代码为302。Set-Cookie:设置和页面关联的Cookie。\n\n响应状态码常见状态码200：请求响应成功\n301：请求重定向\n\n请求重定向(Redirect)：通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。\n\n404: 找不到资源\n500：服务器代码错误\nHTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\n\n\n\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaWeb","JavaEE","Web"]},{"title":"JavaWeb之Filter过滤器","url":"/posts/42974.html","content":"Filter 介绍过滤器，顾名思义就是对事物进行过滤的，在Web中的过滤器，当然就是对请求进行过滤，对web服务器管理的所有web资源，我们使用过滤器，就可以对请求进行拦截，然后做相应的处理，实现许多特殊功能。如登录控制，权限管理，过滤敏感词汇等.\nServlet API中提供了一个Filter接口，开发web应用时，如果编写的Java类实现了这个接口，则把这个java类称之为过滤器Filter。通过 Filter 技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截，Filter接口源代码： \npublic abstract interface Filter&#123;    public abstract void init(FilterConfig paramFilterConfig) throws ServletException;    public abstract void doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain         paramFilterChain) throws IOException, ServletException;    public abstract void destroy();&#125;\n\nFilter接口中有一个doFilter方法，当我们编写好Filter，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：\n\n调用目标资源之前，让一段代码执行。\n是否调用目标资源（即是否让用户访问web资源）。\n\nweb服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个 doFilter 方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。 \n过滤器原理当我们使用过滤器时，过滤器会对游览器的请求进行过滤，过滤器可以动态的分为3个部分\n1.放行之前的代码，2.放行，3.放行后的代码\n\n第一部分代码会对游览器请求进行第一次过滤，然后继续执行\n第二部分代码就是将游览器请求放行，如果还有过滤器，那么就继续交给下一个过滤器\n第三部分代码就是对返回的Web资源再次进行过滤处理\n\n我们使用过滤器，也就是说，不止请求会经过过滤器，我们的响应也会经过过滤器。\n\n\n使用过滤器 我们创建Filter，只需要继承Filter接口就行。\nimport javax.servlet.*;import java.io.IOException;@WebFilter(&quot;/*&quot;)public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;对request进行过滤&quot;);        //下面这行代码就是放行        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;对response进行过滤&quot;);    &#125;&#125;\n\n我们实现了一个 doFilter 方法，这个方法就是我们写过滤代码的地方，具体逻辑就是和上面介绍的过滤器原理一样的。\n我简单介绍下上面的代码，WebFilter(&quot;/*&quot;) 表示对所有请求进行过滤,而在doFilter中的放行代码，也就是filterChain.doFilter(servletRequest,servletResponse);这行代码就是对拦截进行放行\n过滤器并不会管资源是否存在，而只会对配置的拦截路径进行拦截。拦截不仅会对请求进行拦截，而且还会对相应进行拦截。\n配置过滤器拦截路径配置Filter的拦截路径有2种方式，一种是注解，一种是xml方式，我们分别进行讲解\n注解方式我们如果使用注解来进行配置，那么我们就需要使用 @WebFilter ，直接看该注解的源码\n\n\n\nfilterName：该filter的名字\ninitParams：初始化参数\ndisplayName：filter显示名称\nservletNames：指定对哪些servlet进行过滤\nasyncSupported：是否支持异步模式\nurlPatterns：指定拦截路径\nvalue：指定拦截路径\n\nurlPatterns和value是一样的。urlPatterns和value只能配置一个，不能两个都配置，两个都配置就会报错。\n对于使用**@WebFilter**,里面的多个参数用 , 进行分隔。 \n如果我们仅仅需要配置一个拦截路径，那么我们可以直接简写@WebLister(“拦截路径”)，如@WebFilter(“&#x2F;*“)就是拦截所有请求。 \n@WebFilter(value = &#123;&quot;/login&quot;&#125;, filterName = &quot;filtersss&quot;)public class CharSetFilter implements Filter &#123;\n\n多个参数配置，需要分隔\nxml 方式xml方式可以说是和Servlet使用xml配置方式一样了\n&lt;filter&gt;    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.ergoutree.filter.MyFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;myFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n把注解换成了xml标签来配置，里面属性都是一样的，这个和Servlet的配置方式基本一样\n过滤器生命周期 Filter 的生命周期和 Servlet 也十分相似\n创建一个类\nimport javax.servlet.*;import java.io.IOException; public class LifeCycleFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\n\nFilter有3个阶段，分别是初始化，拦截和过滤，销毁。\n\n初始化阶段：当服务器启动时，我们的服务器(Tomcat)就会读取配置文件，扫描注解，然后来创建我们的Filter。\n拦截和过滤阶段：只要请求资源的路径和拦截的路径相同，那么过滤器就会对请求进行过滤，这个阶段在服务器运行过程中会一直循环。\n销毁阶段：当服务器(Tomcat)关闭时，服务器创建的Filter也会随之销毁。\n\nFilter的三个阶段就对应着Filter的3个方法，init 方法会在 Filter 创建时调用，doFilter 方法会在请求和拦截匹配时调用，destroy 方法会在 Filter 销毁时调用。\n@WebFilter(value = &#123;&quot;/login&quot;&#125;, filterName = &quot;filtersss&quot;)public class CharSetFilter implements Filter &#123;    private static final Logger LOGGER = Logger.getLogger(CharSetFilter.class.getName());    private static final String CHARSET = &quot;UTF-8&quot;;    public void init(FilterConfig config) throws ServletException &#123;        System.out.println(&quot;LoginOccasion过滤器初始化完成 - &quot; + new Date());    &#125;    public void destroy() &#123;        System.out.println(&quot;LoginOccasion过滤器被销毁 - &quot; + new Date());    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;        // 1. 预处理 - 在请求到达Servlet之前执行        System.out.println(&quot;LoginOccasion过滤器: 预处理开始&quot;);        // 获取客户端IP地址        String ipAddress = request.getRemoteAddr();        System.out.println(&quot;请求来自IP: &quot; + ipAddress + &quot; - &quot; + new Date());        request.setCharacterEncoding(CHARSET);        response.setCharacterEncoding(CHARSET);        response.setContentType(&quot;text/html; charset=&quot; + CHARSET);        if(request instanceof HttpServletRequest) &#123;            HttpServletRequest httpRequest = (HttpServletRequest) request;            System.out.println(&quot;访问的URL: &quot; + httpRequest.getRequestURL());            System.out.println(&quot;HTTP方法: &quot; + httpRequest.getMethod());        &#125;        // 记录请求开始时间        long startTime = System.currentTimeMillis();        // 2. 将请求传递给下一个过滤器或目标Servlet        chain.doFilter(request, response);        // 3. 后处理 - 在响应返回客户端之前执行        long endTime = System.currentTimeMillis();        System.out.println(&quot;请求处理耗时: &quot; + (endTime - startTime) + &quot;毫秒&quot;);        System.out.println(&quot;LoginOccasion过滤器: 后处理完成&quot;);    &#125;&#125;\n\n\n\nFilterConfig和FilterChainFilterConfig和FilterConfig这2个对象是由服务器(Tomcat)在创建和调用Filter对象时所传入的，这2个对象十分有用，FilterConfig对象可以读取我们配置的初始参数，FilterChain可以实现多个Filter之间的连接。\nFilterConfig\n\n\n\n里面的方法就4个，下面我们分别进行讲解\n\ngetFilterName()：获取filter的名称\ngetServletContext()：获取ServletContext\ngetInitparamter(String var1)：获取配置的初始参数的值\ngetInitParamterNames()：获取配置的所有参数名称\n\n实际例子我们在init方法中使用FilterConfig来读取配置的数据库的信息，然后输出。\nimport javax.servlet.*;import java.io.IOException;import java.util.Enumeration; public class MyFilterConfig implements Filter &#123;     @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;-----------获取全部key:value------------&quot;);        //得到所有配置参数的名字        Enumeration&lt;String&gt; names = filterConfig.getInitParameterNames();        while (names.hasMoreElements()) &#123;            //得到每一个名字            String name = names.nextElement();            System.out.println(name+&quot; = &quot;+filterConfig.getInitParameter(name));        &#125;        System.out.println(&quot;-----------end.....------------&quot;);    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\n\nxml 配置\n&lt;filter&gt;        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;        &lt;filter-class&gt;com.clucky.filter.MyFilterConfig&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;driver&lt;/param-name&gt;            &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;url&lt;/param-name&gt;            &lt;param-value&gt;jdbc:mysql://localhost:3306/equip_employ_manage?serverTimezone=GMT&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;username&lt;/param-name&gt;            &lt;param-value&gt;root&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;password&lt;/param-name&gt;            &lt;param-value&gt;root&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\n\n\n\n\n我们使用FilterConfig提供的方法就成功实现了功能，FilterConfig就是用来读取配置文件的。\n\nFilterChain在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在 web.xml 文件中的注册顺序，决定先调用哪个Filter，当第一个 Filter 的 doFilter 方法被调用时，web服务器会创建一个代表 Filter 链的FilterChain 对象传递给该方法。在 doFilter  方法中，开发人员如果调用了 FilterChain 对象的 doFilter 方法，则 web 服务器会检查 FilterChain 对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。 \n\n\n\n\n我们查看类图，可以发现 FilterChain 就只有一个方法，其实这个方法就是用来对拦截进行放行的，如果有多个拦截器，那么就会继续调用下一个Filter进行拦截。doFilter 方法需要传入个参数，一个是 ServletRequest ，一个是 ServletResponse 参数，这个直接传入进行。 \nTomcat 在调用过滤器时，默认就会传入 Request 和 Response，这个参数封装了请求和响应，我们直接使用就行。ServletResquest 和 ServletResponse 可以直接强转成 HttpServletRequest 和 HttpServletResponse，然后使用相应的方法。\n  将ServletRequest转成HttpServletRequest\n\n\n应用实例我们前面一直都是一个Filter，现在我们来配置2个Filter，通过FilterChain来进行多个过滤。\n第一个 Filter\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Filter01 implements Filter &#123;     @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;调用过滤器01对请求进行过滤~~~~&quot;);        //放行,如果还有过滤器，那么就执行下一个过滤器        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;调用过滤器01对响应进行过滤~~~~&quot;);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\n\n第二个Filterl\nimport javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException; @WebFilter(&quot;/*&quot;)public class Filter02 implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;     @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;调用过滤器02对请求进行过滤~~~~&quot;);        //放行,如果还有过滤器，那么就执行下一个过滤器        filterChain.doFilter(servletRequest,servletResponse);        System.out.println(&quot;调用过滤器02对响应进行过滤~~~~&quot;);    &#125;     @Override    public void destroy() &#123;    &#125;&#125;\n\n启动服务器，访问8080，查看控制台输出。\n\n\n我们可以看见Filter01先进行过滤，然后交给Filter02，然后访问资源，然后Filter02对响应进行过滤，然后Filter01对响应进行过滤。图示如下：\n\n\n多个 Filter 的执行顺序上面我们配置了2个过滤器，那么我们怎么知道那个过滤器先执行呢？\n\n如果我们是在web.xml中配置的过滤器，那么过滤器的执行顺序就是在web配置的顺序，配置在上面那么就会先执行。\n如果我们是使用@WebFilter进行配置的，那么执行顺序就是字符比较顺序来执行，例如有2个过滤器，一个是AFilter，一个是BFilter，那么AFilter就会先执行。\n如果注解和xml混用，那么在web.xml中配置的会先执行。\n\n","categories":["Java学习","JavaEE"],"tags":["Java技术","JavaWeb","JavaEE"]},{"title":"Java注解与Annotation类","url":"/posts/54622.html","content":"了解注解Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。是提供一种为程序元素设置元数据的方法，这些信息可以被编译器、开发工具或运行时环境读取和处理。\n（程序元素：接口、类、属性、方法等；   元数据：描述数据的数据）\n关键特性：\n\n注解本身不包含业务逻辑，但可以通过反射机制在运行时获取并处理\n\n注解不影响程序本身的执行，但可以通过工具影响程序的行为\n\n注解可以包含命名参数，这些参数可以有默认值\n\n\n其实就是写在接口、类、属性、方法上的一个标签，或者说是一个特殊形式的注释，普通注释只是一个注释，而注解在代码运行时是可以被反射读取并进行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。\nJava 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。\n在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。\n可以利用注解来自定义一些实现，比如在某个方法上加一个自定义注解，就可以实现方法日志的自动记录打印\n举例@Override:\n它的作用是告诉阅读者(开发人员、编译器)这个方法重写了父类的方法，对于开发人员只是一个标志，然而编译器如果发现方法标注了这个注解，就会检查这个方法到底是不是真的覆写了父类的方法，如果没有会报错，而如果不添加@Override注解，程序也是可以正常运行的，不过缺乏了静态的检查\n在spring框架中加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。\n注意：注解不能直接干扰程序代码的运行\n注解的作用话说当年非常流行xml配置的。优点呢就是整个项目的配置信息集中在一个文件中，从而方便管理，是集中式的配置。缺点也显而易见，当配置信息非常多的时候，配置文件会变得越来越大不易查看管理，特别是多人协作开发时会导致一定的相互干扰。\n现在都提倡解耦、轻量化或者说微小化，那么注解就顺应了这一需求，各个包或模块在内部方法或类上使用注解即可实现指定功能，缺点呢就是不方便统一管理，如果需要修改某一类功能，则需要整体搜索逐个修改，是分散式的存在各个角落。\nxml的方式是集中式的元数据，不需要和代码绑定的，而注解是一种分散式的元数据设置方式。\n开发者的视角可以解读出这个类&#x2F;方法&#x2F;属性的作用以及该怎么使用，而从框架的视角则可以解析注解本身和其属性实现各种功能，编译器的角度则可以进行一些预检查(@Override)和抑制警告(@SuppressWarnings)等。\n\n作为特定标记，用于告诉编译器一些信息\n编译时动态处理，如动态生成代码\n运行时动态处理，作为额外信息的载体，如获取注解信息\n\nAnnotation架构Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。\n\n\n其中\n\n1 个 Annotation 和 1 个 RetentionPolicy 关联。\n可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。\nRetentionPolicy 是一个枚举类型，它定义了注解的保留策略，也就是规定了注解在什么阶段是可用的。\n\n\n\n\n1 个 Annotation 和 1~n 个 ElementType 关联。\n对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性\n\n\nAnnotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。\n每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\n\n\n\nAnnotation 组成部分java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：Annotation  ElementType RetentionPolicy\npackage java.lang.annotation;public interface Annotation &#123;    // 当两个注解对象满足以下条件时，认为它们相等：注解类型相同  所有注解元素的值都相等    boolean equals(Object obj);    int hashCode();    // 将当前注解对象转换为字符串表示形式,字符串表示通常包含注解的类型名称和所有注解元素的值。    String toString();       // 获取当前注解对象的注解类型。注解类型是一个 Class 对象，它表示定义该注解的接口。    Class&lt;? extends Annotation&gt; annotationType();   &#125;\n\npackage java.lang.annotation;public enum ElementType &#123;    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */    FIELD,              /* 字段声明（包括枚举常量）  */    METHOD,             /* 方法声明  */    PARAMETER,          /* 参数声明  */    CONSTRUCTOR,        /* 构造方法声明  */    LOCAL_VARIABLE,     /* 局部变量声明  */    ANNOTATION_TYPE,    /* 注释类型声明  */    PACKAGE             /* 包声明  */&#125;\n\npackage java.lang.annotation;public enum RetentionPolicy &#123;    SOURCE,   /*源码级 Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */    CLASS,             /*类文件级 编译器将Annotation存储于类对应的.class文件中。默认行为  */    RUNTIME            /*运行级 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125;\n\n其中：\n\nAnnotation这个接口中，每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\nElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途\n就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。\n\nAnnotation 通用定义@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125;\n\n上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。\n定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。\njava常用的Annotation@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented  -- @Documented 所标注内容，是否包含在用户文档中javadoc@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention   -- @Retention只能被用来标注“Annotation类型”，用来指定Annotation的RetentionPolicy属性作用域。@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。\n\n\n\nAnnotation 的作用编译检查Annotation 具有”让编译器进行编译检查的作用”。\n例如\n\n@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。\n若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。\n\n\n我们可以发现 getString() 函数会报错。这是因为 getString() 被 @Override 所标注，但在OverrideTest 的任何父类中都没有定义 getString() 函数”。\n反射中使用Annotation在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。我们可以在反射中解析并使用 Annotation。\n/** * Annotation在反射函数中的使用示例 */@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String[] value() default &quot;unknown&quot;;&#125;/** * Person类。它会使用MyAnnotation注解。 */class Person &#123;        /**     * empty()方法同时被 &quot;@Deprecated&quot; 和 &quot;@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注      * (01) @Deprecated，意味着empty()方法，不再被建议使用     * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;     */    @MyAnnotation    @Deprecated    public void empty()&#123;        System.out.println(&quot;\\nempty&quot;);    &#125;        /**     * sombody() 被 @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，     * @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;     */    @MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)    public void somebody(String name, int age)&#123;        System.out.println(&quot;\\nsomebody: &quot;+name+&quot;, &quot;+age);    &#125;&#125;public class AnnotationTest &#123;    public static void main(String[] args) throws Exception &#123;                // 新建Person        Person person = new Person();        // 获取Person的Class实例        Class&lt;Person&gt; c = Person.class;        // 获取 somebody() 方法的Method实例        Method mSomebody = c.getMethod(&quot;somebody&quot;, new Class[]&#123;String.class, int.class&#125;);        // 执行该方法        mSomebody.invoke(person, new Object[]&#123;&quot;lily&quot;, 18&#125;);        iteratorAnnotations(mSomebody);                // 获取 somebody() 方法的Method实例        Method mEmpty = c.getMethod(&quot;empty&quot;, new Class[]&#123;&#125;);        // 执行该方法        mEmpty.invoke(person, new Object[]&#123;&#125;);                iteratorAnnotations(mEmpty);    &#125;        public static void iteratorAnnotations(Method method) &#123;        // 判断 somebody() 方法是否包含MyAnnotation注解        if(method.isAnnotationPresent(MyAnnotation.class))&#123;            // 获取该方法的MyAnnotation注解实例            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);            // 获取 myAnnotation的值，并打印出来            String[] values = myAnnotation.value();            for (String str:values)                System.out.printf(str+&quot;, &quot;);            System.out.println();        &#125;                // 获取方法上的所有注解，并打印出来        Annotation[] annotations = method.getAnnotations();        for(Annotation annotation : annotations)&#123;            System.out.println(annotation);        &#125;    &#125;&#125;\n\n\n\n注解的分类 通常来说注解分为以下三类\n\n元注解 – java内置的注解，标明该注解的使用范围、生命周期等。\n标准注解 – Java提供的基础注解，标明过期的元素&#x2F;标明是复写父类方法的方法&#x2F;标明抑制警告。\n自定义注解 – 第三方定义的注解，含义和功能由第三方来定义和实现。\n\n元注解用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。\n元注解就是最基本不可分解的注解，我们不能去改变它只能使用它来定义自定义的注解。\n元注解包含以下五种： @Retention、@Target、@Documented、@Inherited、@Repeatable\n@Retention定义\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    RetentionPolicy value();&#125;\n\n标明自定义注解的生命周期，这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。它决定了注解在何时有效以及在何处可用。\n从编写Java代码到运行主要周期为源文件→ Class文件 → 运行时数据，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为SOURCE →CLASS→RUNTIME。\n\nSOURCE：源代码java文件，不会包含在编译后的 class 文件中，编译时候会丢弃\nCLASS：类文件级别保留，class文件中会保留注解，但是jvm加载运行时就没有了，是默认的保留策略\nRUNTIME：运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的\n\n各个生命周期的用途：\n\nSOURCE级别：\n典型应用：Lombok的@Getter、@Setter\n特点：编译后完全消失，不会增加运行时负担\n使用场景：仅用于编译期检查或代码生成\n\n\nCLASS级别：\n典型应用：Android的@Keep注解\n特点：保留到class文件但不会被加载到JVM\n使用场景：字节码分析工具使用\n\n\nRUNTIME级别：\n典型应用：Spring的@Controller、@Service\n特点：可通过反射获取，影响运行时行为\n使用场景：框架开发中最常用\n\n\n\n// Lombok的@Getter示例 SOURCE级别@Retention(RetentionPolicy.SOURCE)public @interface Getter &#123;    AccessLevel value() default AccessLevel.PUBLIC;&#125;// 使用@Getterpublic class User &#123;    private String name;&#125;// 编译时会生成getName()方法，但注解本身不会保留\n\n@Target描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上(类、方法、属性、局部属性、参数…)\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    ElementType[] value();&#125;\n\nvalue是一个数组，可以有多个取值，说明同一个注解可以同时用于标注在不同的元素上。value的取值如下\n@Target可以指定更精确的应用目标，包括：\n@Target(&#123;    ElementType.TYPE,               // 类、接口、枚举    ElementType.FIELD,              // 字段（包括枚举常量）    ElementType.METHOD,             // 方法    ElementType.PARAMETER,          // 方法参数    ElementType.CONSTRUCTOR,        // 构造器    ElementType.LOCAL_VARIABLE,     // 局部变量    ElementType.ANNOTATION_TYPE,    // 注解类型    ElementType.PACKAGE,            // 包    ElementType.TYPE_PARAMETER,     // 类型参数（Java 8+）    ElementType.TYPE_USE            // 类型使用（Java 8+）&#125;)\n\n自定义一个注解@MyAnnotation1想要用在类或方法上，就可以如下定义\n/**    * 自定义注解，使用@Target指定该注解可以应用在哪些元素上    * 这里指定了TYPE(类/接口/枚举等)和METHOD(方法)上    */   @Retention(RetentionPolicy.RUNTIME)    // 运行时保留   @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)  // 只能用于类和方法上   public @interface MyAnnotation &#123;       String description() default &quot;&quot;;   // 注解属性默认值   &#125;   /**    * 测试类，演示@Target的使用    * 因为@MyAnnotation允许用在TYPE上，所以可以用在类声明上    */   @MyAnnotation(description = &quot;这是一个类级别的注解示例&quot;)   public static class AnnotationTest &#123;       // @MyAnnotation   用在属性上则会报错       public String name;       @MyAnnotation(description = &quot;这是一个方法级别的注解示例&quot;)       public void testMethod() &#123;           System.out.println(&quot;测试方法执行&quot;);       &#125;   &#125;\n\n获取其中的注解，只能获取到类和方法上的\npublic static void main(String[] args) &#123;        // 获取类上的注解        MyAnnotation classAnnotation = AnnotationTest.class.getAnnotation(MyAnnotation.class);        System.out.println(classAnnotation.description());        try&#123;            // 获取方法上的注释            Method method = AnnotationTest.class.getMethod(&quot;testMethod&quot;);            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);            System.out.println(annotation.description());        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;\n\n@Inherited表示是否可以被标注类的子类继承。当注解 Inheritable 被 @Inherited 标注时，它具有继承性。否则，没有继承性。\n定义如下\n@Documented   // 说明该注解能出现在 javadoc 中。@Retention(RetentionPolicy.RUNTIME)   // 指定 Inherited 的策略是 RetentionPolicy.RUNTIME@Target(ElementType.ANNOTATION_TYPE)  // @Inherited 只能被用来标注 &quot;Annotation 类型&quot;// 它的用来修饰 Inherited，意味着 Inherited 实现了 Annotation 接口；即 Inherited 就是一个注解。public @interface Inherited &#123;    &#125;\n\n当一个类使用了带有 @Inherited 的注解时，这个注解会被该类的子类继承。\n\n仅对类注解有效：@Inherited 只对类级别的注解有效（即注解的 @Target 包含 ElementType.TYPE）\n不适用于接口：从父类继承的注解不会应用于实现接口的类\n不适用于方法等其他元素：方法上的注解不会被继承\n\n\n示例，通过反射获取注解\n// 定义一个可以被继承的注释@Inherited@Retention(RetentionPolicy.RUNTIME)  // 运行时保留，可以通过反射获取@Target(ElementType.TYPE)  // 只能用于类/接口/枚举上@interface InheritableAnnotation &#123;    String value() default &quot;父类注解&quot;;&#125;// 定义一个不可被继承的注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface NonInheritableAnnotation &#123;    String value() default &quot;不可继承的注解&quot;;&#125;// 父类，带有可继承和不可继承的注解@InheritableAnnotation(&quot;这是父类的可继承注解&quot;)@NonInheritableAnnotation(&quot;这是父类的不可继承注解&quot;)class ParentClass &#123;&#125;// 子类，继承自ParentClass，没有显式添加任何注解class ChildClass extends ParentClass &#123;&#125;\n\n打印注解的信息后可以发现：\n类 ParentClass 上的注解:  InheritableAnnotation:   NonInheritableAnnotation: 类 ChildClass 上的注解:  InheritableAnnotation: \n\n发现ChildClass 类没有继承 NonInheritableAnnotation 注解\n@Repeatable定义如下\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123;    // 指定包含重复注解的容器注解类型    Class&lt;? extends Annotation&gt; value();&#125;\n\n标识某注解可以在同一个声明上使用多次。（Java 8+特性）\n示例：\n// 定义可重复注解@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation &#123;    String value();&#125;// 定义包含可重复注解的容器注解@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations &#123;    MyAnnotation[] value();&#125;// 使用可重复注解@MyAnnotation(&quot;First Annotation&quot;)@MyAnnotation(&quot;Second Annotation&quot;)class MyClass &#123;    // 类的内容&#125;public class RepeatableExample &#123;    public static void main(String[] args) &#123;        // 普通的获取类上的所有 MyAnnotation 注解        // 需要定义容器注解来存放重复注解        // 通过getAnnotationsByType()获取重复注解        MyAnnotation[] annotations = MyClass.class.getAnnotationsByType(MyAnnotation.class);        for (MyAnnotation annotation : annotations) &#123;            System.out.println(annotation.value());        &#125;        // 使用MyAnnotations，获取类上的 MyAnnotations 注解        MyAnnotations container = MyClass.class.getAnnotation(MyAnnotations.class);        if (container != null) &#123;   // 语法糖，相当于是返回一个MyAnnotation[]            for (MyAnnotation annotation : container.value()) &#123;                System.out.println(annotation.value());            &#125;        &#125;    &#125;&#125;\n\n虽然我们标注的是多个@MyAnnotation，其实会给我们返回一个@MyAnnotations，相当于是Java帮我们把重复的注解放入了一个数组属性中\n@Documented定义如下\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\n\n标记注解是否包含在Javadoc中。被@Documented标注的注解会出现在生成的API文档里。\n\n无参数\n只影响文档生成\n常用于重要的API注解\n\n根据 Annotation 生成帮助文档：\n通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。\n标准注解@Override定义\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\n\n标识方法覆写了父类或接口中的方法，提供编译时检查。\n\n仅用于方法\n编译时检查（非强制使用）\n源代码级别（不保留到class文件）\n可防止拼写错误导致意外创建新方法\n\n支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE\n这个天天用，估计大伙都会都知道，很多人注解学习的起步就是@Override\n@Deprecated某个方法被 @Deprecated 标注，则该方法不再被建议使用\n如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息\n\n\n定义如下\n@Documented  // 会出现在doc中@Retention(RetentionPolicy.RUNTIME)   // 指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。// @interface -- 它的用来修饰 Deprecated,即 Deprecated 就是一个注解public @interface Deprecated &#123;&#125;\n\n@SuppressWarnings让编译器对”它所标注的内容”的某些警告保持静默。\n\n定义如下\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();  // SuppressWarnings 能指定参数&#125;\n\n@FunctionalInterface用于标识函数式接口\n定义：\n@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125;\n使用示例\n@FunctionalInterfaceinterface Greeter &#123;    void greet(String name);        // 可以有默认方法    default void defaultGreet() &#123;        System.out.println(&quot;Hello, world!&quot;);    &#125;&#125;\n\n编译时会检查是否确实是函数式接口\n如果不是（有多个抽象方法），会报错\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"Java之动态代理","url":"/posts/60449.html","content":"设计模式–代理模式代理模式是常用的java设计模式，它允许你通过创建一个代理对象来控制对另一个对象（即目标对象）的访问，代理类与委托类有同样的接口。\n代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。\n代理对象充当了目标对象的接口，客户端通过代理对象与目标对象进行交互，而不是直接访问目标对象。\n代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。\n在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。代理模式可以在不改变目标对象代码的前提下，对目标对象的功能进行增强或扩展。\n\n\n可以发现，其中有\n\n代理对象\n\n被代理的行为\n\n被代理的对象\n\n行为的完全控制\n\n\n静态代理静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。\n简单实现首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。\n/** * 创建Person接口 * @author Gonjan */public interface Person &#123;    //上交班费    void giveMoney();&#125;\n\nStudent类实现Person接口。Student可以具体实施上交班费的动作。\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\n\nStudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为\n// 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为public class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        stu.giveMoney();    &#125;&#125;\n测试主类\npublic class StaticProxyTest &#123;    public static void main(String[] args) &#123;        //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成        Person zhangsan = new Student(&quot;张三&quot;);                //生成代理对象，并将张三传给代理对象        Person monitor = new StudentsProxy(zhangsan);                //班长代理上交班费        monitor.giveMoney();    &#125;&#125;\n\n这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。\n代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。\n代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。\n这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以很方便的加上一些其他用途\npublic class StudentsProxy implements Person&#123;    //被代理的学生    Student stu;        public StudentsProxy(Person stu) &#123;        // 只代理学生对象        if(stu.getClass() == Student.class) &#123;            this.stu = (Student)stu;        &#125;    &#125;        //代理上交班费，调用被代理学生的上交班费行为    public void giveMoney() &#123;        System.out.println(&quot;张三最近学习有进步！&quot;);  // 代理类顺便告诉张三最近学习有进步        stu.giveMoney();    &#125;&#125;\n\n可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。\n动态代理介绍代理类在程序运行时创建的代理方式被成为动态代理。  \n我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。\n然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。\n相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法：\npublic void giveMoney() &#123;      //调用被代理方法前加入处理方法      beforeMethod();      stu.giveMoney();  &#125;\n\n这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。\n简单实现在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。\n相关方法：\n创建一个InvocationHandler对象\n//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);\n\nInvocationHandler接口定义了一个invoke方法，当通过代理对象调用目标方法时，invoke 方法会被调用。invoke 方法接收三个参数：代理对象、被调用的方法对象以及方法的参数数组。在 invoke 方法中，我们可以编写额外的逻辑，然后调用目标方法并返回结果。\n例如\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler接口 &#123;  // 实现InvocationHandler接口    private Object target;    public MyInvocationHandler(Object target) &#123;        // 存储目标对象。这个目标对象就是我们要为其添加额外功能的对象。        this.target = target;    &#125;    // 需要重写invoke方法    @Override    // Object proxy：代理对象本身   Method method：被调用的目标方法对象   Object[] args：调用目标方法时传递的参数数组    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        // 调用目标方法前的逻辑，例如记录日志        System.out.println(&quot;Before method invocation: &quot; + method.getName());        // 调用目标方法        Object result = method.invoke(target, args);   // 代理target对象实际方法        // 调用目标方法后的逻辑，例如记录日志        System.out.println(&quot;After method invocation: &quot; + method.getName());        return result;    &#125;&#125;\n\n\n\n使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass \nClass&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;);\n\n该类提供了静态方法用于创建动态代理类和代理对象。\n其中，newProxyInstance 方法是创建代理对象的关键方法，它接收三个参数：类加载器、目标对象实现的接口数组以及 InvocationHandler 实例。\n例如\nimport java.lang.reflect.Proxy;// 为传入的目标对象创建一个动态代理对象。public class ProxyFactory &#123;    public static Object createProxy(Object target) &#123;        return Proxy.newProxyInstance(                target.getClass().getClassLoader(),     // 类加载器// 动态代理只能为实现了接口的类创建代理对象，因此需要指定目标对象实现的接口，这样代理对象才能实现相同的接口。                target.getClass().getInterfaces(),   // 获取目标对象所实现的所有接口的数组                new MyInvocationHandler(target));    &#125;&#125;\n\n\n\n获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor\nConstructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);\n\n在 Java 反射机制中，Class 类提供了一系列方法来获取类的构造器信息。这里通过 PersonProxy.getConstructor(InvocationHandler.class) 来获取 PersonProxy 类中，参数为 InvocationHandler.class 的构造器。getConstructor 方法会返回一个 Constructor 对象，它代表了对应的构造器。\n通过构造器constructor来创建一个动态实例stuProxy\nPerson stuProxy = (Person) cons.newInstance(stuHandler);\n\nConstructor 类的 newInstance 方法用于根据构造器来创建类的实例。这里传入了 stuHandler 作为参数，stuHandler 应该是实现了 InvocationHandler 接口的对象实例。它会调用之前获取到的构造器（要求参数为 InvocationHandler 类型 ）来初始化一个 PersonProxy 实例，并将其强制转换为 Person 类型（前提是 PersonProxy 类实现了 Person 接口 ）\n一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化\n//创建一个与代理对象相关联的InvocationHandler  InvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);\n\n\n\n完整的动态代理例子定义一个Person接口，里面定义一个抽象方法 giveMoney();\npublic interface Person &#123;    //上交班费    void giveMoney();&#125;\n\n创建需要被代理的实际类 Student类，实现了Person接口，是被代理的目标对象：\npublic class Student implements Person &#123;    private String name;    public Student(String name) &#123;        this.name = name;    &#125;        @Override    public void giveMoney() &#123;        try &#123;          //假设数钱花了一秒时间            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;       System.out.println(name + &quot;上交班费50元&quot;);    &#125;&#125;\n\n再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。\npublic class MonitorUtil &#123;        private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();        public static void start() &#123;        tl.set(System.currentTimeMillis());    &#125;        //结束时打印耗时    public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();        System.out.println(methodName + &quot;方法耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);    &#125;&#125;\n\n创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。再在invoke方法中执行被代理对象target的相应方法。\n所以说InvocationHandler 负责处理代理对象方法的调用，当调用代理对象的方法时，实际上会调用 InvocationHandler 的 invoke 方法。\n当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。\npublic class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123;   // invocationHandler持有的被代理对象    T target;        public StuInvocationHandler(T target) &#123;       this.target = target;    &#125;        /**     * proxy:代表动态代理对象     * method：代表正在执行的方法     * args：代表调用目标方法时传入的实参     */     @Override   // 实现 InvocationHandler 接口需要重写invoke方法    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;);          //代理过程中插入监测方法,计算该方法耗时        MonitorUtil.start();        Object result = method.invoke(target, args);        MonitorUtil.finish(method.getName());        return result;    &#125;&#125;\n\n我们使用简化的方式创建动态代理对象：\npublic class ProxyTest &#123;    public static void main(String[] args) &#123;        //创建一个实例对象，这个对象是被代理的对象        Person zhangsan = new Student(&quot;张三&quot;);        //创建一个与代理对象相关联的InvocationHandler        InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan);        //创建一个代理对象stuProxy来代理张三，代理对象的每个执行方法都会替换执行Invocation中的invoke方法        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；       //代理执行上交班费的方法        stuProxy.giveMoney();    &#125;&#125;\n\n过程讲解： \nstuHandler为代理对象相关联的InvocationHandler，将目标对象 张三 传递给 StuInvocationHandler 的构造函数。InvocationHandler 的作用是处理代理对象方法的调用，当调用代理对象的方法时，会自动调用 InvocationHandler 的 invoke 方法\n使用 Proxy.newProxyInstance 方法创建一个代理对象 stuProxy，需要传入类加载器，实现的接口，指定处理代理对象方法调用的InvocationHandle对象，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\n之后调用代理对象的 giveMoney 方法，实际上会调用 StuInvocationHandler 的 invoke 方法，在 invoke 方法中会先调用 MonitorUtil.start() 记录开始时间，然后调用目标对象的 giveMoney 方法，最后调用 MonitorUtil.finish() 计算并打印方法执行的耗时。\n\n\n动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。\n是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。\n例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而只做了很少的代码量。\n动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。\n因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行，这就涉及到java动态代理的原理了\n动态代理原理分析Java动态代理创建出来的动态代理类上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：\n/** * 返回一个指定接口的代理类实例，该实例会将方法调用分派到指定的调用处理器。 * * @param loader 定义代理类的类加载器 * @param interfaces 代理类要实现的接口列表 * @param h 调度方法调用的调用处理器 * @return 一个实现了指定接口的代理类实例，它会将方法调用分派给指定的调用处理器 * @throws IllegalArgumentException 如果违反了对该方法参数的任何限制 */public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)    throws IllegalArgumentException&#123;    // 检查调用处理器是否为 null，如果为 null 则抛出 NullPointerException    Objects.requireNonNull(h);    // 克隆接口数组，防止外部对原数组进行修改影响后续操作    final Class&lt;?&gt;[] intfs = interfaces.clone();    // 获取系统的安全管理器    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        // 如果存在安全管理器，检查调用者是否有创建代理类的权限        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    /*     * 查找或生成指定的代理类。     */    // 通过类加载器和接口数组获取代理类的 Class 对象    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * 使用指定的调用处理器调用其构造函数。     */    try &#123;        if (sm != null) &#123;            // 如果存在安全管理器，检查调用者是否有创建代理实例的权限            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        // 获取代理类的构造函数，该构造函数接收一个 InvocationHandler 类型的参数        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        // 保存传入的调用处理器        final InvocationHandler ih = h;        if (!Modifier.isPublic(cl.getModifiers())) &#123;            // 如果代理类不是公共类，则使用特权操作将构造函数设置为可访问            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;        // 使用构造函数创建代理类的实例，并传入调用处理器        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;        // 处理非法访问或实例化异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        // 处理构造函数调用抛出的异常        Throwable t = e.getCause();        if (t instanceof RuntimeException) &#123;            // 如果是运行时异常，直接抛出            throw (RuntimeException) t;        &#125; else &#123;            // 否则抛出内部错误            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        // 处理构造函数未找到的异常，抛出内部错误        throw new InternalError(e.toString(), e);    &#125;&#125;\n\nClass&lt;?&gt; cl = getProxyClass0(loader, intfs);\n\n\nloader：这是一个 ClassLoader 对象，它指定了代理类应该使用哪个类加载器来加载。类加载器负责将类的字节码文件加载到 JVM 中，不同的类加载器可能会从不同的位置（如文件系统、网络等）加载类。通常，我们会使用被代理接口的类加载器，这样可以确保代理类和被代理接口在同一个类加载器的命名空间中，从而避免类加载的冲突。\nintfs：这是一个 Class[] 数组，包含了代理类需要实现的接口列表。代理类会实现这些接口中定义的所有方法，当调用代理对象的这些方法时，实际上会将调用转发到 InvocationHandler 的 invoke 方法中进行处理。\n\n其实，我们最应该关注的是 Class&lt;?&gt; cl &#x3D; getProxyClass0(loader,  intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，这个类文件时缓存在java虚拟机中的\n\n在 Java 动态代理中，Proxy.newProxyInstance 方法的核心目标是创建一个实现了指定接口的代理对象。而 getProxyClass0 方法就是用来生成这个代理对象所对应的代理类的。这个代理类是在运行时动态生成的，并且会被加载到 Java 虚拟机（JVM）中，后续的代理对象实例就是基于这个动态生成的类来创建的。\n\n那么是如何动态生成代理类的：\n\ngetProxyClass0 方法会根据传入的类加载器和接口数组，在运行时动态生成一个代理类的字节码。这个代理类会实现 intfs 数组中指定的所有接口，并且会重写这些接口中的方法。在重写的方法中，会调用 InvocationHandler 的 invoke 方法，从而实现对目标方法的增强。\n这其中有一个缓存机制，为了提高性能，Java 虚拟机对动态生成的代理类采用了缓存机制。也就是说，如果已经为相同的类加载器和接口列表生成过代理类，那么 getProxyClass0 方法会直接从缓存中获取这个代理类，而不是再次生成。这样可以避免重复生成相同的代理类，减少开销。\n\n之后对这个class文件反编译\nimport java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import proxy.Person;// $Proxy0 是动态生成的代理类，它继承自 Proxy 类并实现了 Person 接口。Proxy 类是 Java 中所有代理类的基类// 它持有一个 InvocationHandler 类型的成员变量 h，用于处理方法调用public final class $Proxy0 extends Proxy implements Person&#123;  // 这些静态变量用于存储通过反射获取的方法对象。m3 对应 Person 接口的 giveMoney 方法，m0、m1、m2 分别对应 Object 类的 hashCode、equals 和 toString 方法。  private static Method m1;  private static Method m2;  private static Method m3;  private static Method m0;    /**  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，代理类的构造方法接收一个 InvocationHandler 类型的参数，并调用父类 Proxy 的构造方法将其传递给父类的 h 成员变量。这意味着代理类持有一个 InvocationHandler 对象，后续的方法调用将由该对象处理。  *  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。  *父类持有：protected InvocationHandler h;  *Proxy构造方法：  *    protected Proxy(InvocationHandler h) &#123;  *         Objects.requireNonNull(h);  *         this.h = h;  *     &#125;  *  */  public $Proxy0(InvocationHandler paramInvocationHandler)    throws   &#123;    super(paramInvocationHandler);  &#125;    //这个静态块本来是在最后的，我把它拿到前面来，方便描述   static  &#123;    try    &#123;      //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);      m3 = Class.forName(&quot;proxy.Person&quot;).getMethod(&quot;giveMoney&quot;, new Class[0]);      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);      return;    &#125;    catch (NoSuchMethodException localNoSuchMethodException)    &#123;      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());    &#125;    catch (ClassNotFoundException localClassNotFoundException)    &#123;      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());    &#125;  &#125;   /**  *   *当调用代理对象的 giveMoney 方法时，实际上会调用 InvocationHandler 对象的 invoke 方法，并将代理对象本身（this）、giveMoney 方法的 Method 对象（m3）和方法参数（这里为 null）作为参数传递给 invoke 方法。  *this.h.invoke(this, m3, null);这里简单，明了。  *InvocationHandler 对象持有被代理对象的引用，在 invoke 方法中可以调用被代理对象的相应方法，并可以在方法调用前后添加额外的逻辑，从而实现对被代理对象方法的增强。  */  public final void giveMoney()    throws   &#123;    try    &#123;      this.h.invoke(this, m3, null);      return;    &#125;    catch (Error|RuntimeException localError)    &#123;      throw localError;    &#125;    catch (Throwable localThrowable)    &#123;      throw new UndeclaredThrowableException(localThrowable);    &#125;  &#125;  //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。&#125;\n\njdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。\n我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。\n代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。\n引用\n[java动态代理实现与原理详细分析\nJava动态代理详细讲解-使用方式及应用场景\n","categories":["Java学习","JavaSE","JavaEE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识01之对象流","url":"/posts/54621.html","content":"Java难绷知识01之对象流本篇文章会探讨一些JavaIO流中比较容易被忽视的对象流，而且会相对的探讨其中的一些细节其中对于对象流的操作讲解会少一些，主要讨论的是一些细节  \n在 Java IO 流中，对象流（ObjectInputStream对象输入流 和 ObjectOutputStream对象输出流）用于将对象进行序列化和反序列化操作  \n对象流及其序列化首先，ObjectInputStream和ObjectOutputStream这两个类都属于是字节流，它们分别继承自InputStream和OutputStream  \n对象输出流，ObjectOutputStream，用于对象的序列化，也就是把Java对象转换成字节序列，把字节序列写出到文件，以这种对象转换为字节序列的机制实现了对象存储序列化目的是能够将整个 Java 对象（包括对象的状态，即成员变量的值）转换为字节流，以便在网络上传输或存储到文件中，之后还能稳定的从字节流中恢复出原来的对象。通过序列化，对象的状态信息（包括成员变量的值）可以被保存下来，以便后续传输或存储。  \n对象输入流，ObjectInputStream，用于对象的反序列化，是将文件中的字节序列恢复为Java对象，以这种字节序列转换为对象的机制实现了对象读取反序列化时，系统会根据字节流中的信息重新构建对象的状态。  \n在其基础上，我们再探讨序列化的一些细节  \n对象序列化的条件要想使一个类的对象能够被序列化，该类必须实现 java.io.Serializable 接口这是一个标记接口，没有任何方法需要实现。实现该接口，意味着告诉 Java 虚拟机这个类的对象可以被序列化。  \n\n点击查看代码\n\nimport java.io.*;// 定义一个实现Serializable接口的类class Person implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;public class SerializationExample &#123;    public static void main(String[] args) &#123;        // 创建一个对象        Person person = new Person(&quot;Alice&quot;, 30);        // 序列化对象到文件        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;))) &#123;            oos.writeObject(person);            System.out.println(&quot;对象已成功序列化到文件 person.ser&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 从文件反序列化对象        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.ser&quot;))) &#123;            Person deserializedPerson = (Person) ois.readObject();            System.out.println(&quot;反序列化后的对象: &quot; + deserializedPerson);        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注意：\n每个可序列化的类都应该有一个serialVersionUID，用于验证序列化和反序列化过程中的版本兼容性\n使用transient关键字声明的成员变量不会被序列化\n序列化可能会引发安全问题  \n\n对象流的使用细节对象流需要关闭吗先说结论，可以不关但是强烈建议关闭。这与 Java 流的资源管理机制紧密相关。涉及到对外部资源的读写操作，包括网络、硬盘等等的I&#x2F;O流，如果在使用完毕之后不关闭，会导致资源泄漏以及可能会引起文件锁定等问题。  \n当我们使用流进行数据操作时，它们会占用系统资源，如文件句柄、网络连接等。如果不关闭流，这些资源将不会被释放，可能导致资源泄漏问题。长时间运行的程序如果频繁出现资源泄漏，最终可能耗尽系统资源，导致程序崩溃或系统性能严重下降。\n而且关闭流可以确保所有已写入的数据被正确地传输到目标位置例如，当使用 ObjectOutputStream 将对象写入文件时，关闭流会保证缓冲区中的所有数据都被写入文件，避免数据丢失。通常建议使用try - with - resources语句来自动关闭流，示例代码如下  \n\n示例代码\n\nimport java.io.*;class MyClass implements Serializable &#123;    private static final long serialVersionUID = 1L;    int data;    public MyClass(int data) &#123;        this.data = data;    &#125;&#125;public class SerializeExample &#123;    public static void main(String[] args) &#123;        MyClass obj = new MyClass(42);        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;myfile.ser&quot;))) &#123;            oos.writeObject(obj);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n  \n#### 对象流需要使用flush吗\n先说结论，不用  \nObjectOutputStream内部维护了一个缓冲区。在调用writeObject方法时，数据首先会被写入缓冲区。调用flush方法可以强制将缓冲区中的数据立即写入底层输出流。然而，在大多数情况下，并不需要显式调用flush。因为当缓冲区满、流关闭或者调用某些特定方法（如writeObject在某些情况下会触发缓冲区数据的刷新）时，缓冲区的数据会自动被写入底层流。\n当然特意需要弄的时候可以弄  \n\nserialVersionUID在对象流中的必要性凡是实现Serializable接口（标识接口）的类都有一个表示序列化版本标识符的静态常量：    private static final long serialVersionUID;来表明类的不同版本间的兼容性。  \n在完成序列化操作后，如果对序列化对象进行了修改，那么我们再进行反序列化就会抛出InvalidClassException异常。 因为serialVersionUID缺失（没有显式分配）或者serialVersionUID发生了变化， serialVersionUID的作用在此体现——对序列化对象进行版本控制，有关各版本反序加化时是否兼容。避免混乱。  \nclass Person implements Serializable &#123;    private static final long serialVersionUID = 1234567890123456789L;    private String name;    private int age;    // 后续可以安全地对类结构进行一些兼容的修改&#125;\n一个类在没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。所以建议一般显式声明。  \n序列化的一些细节static修饰的属性 不可以被序列化原因在于 static 变量属于类，而不是类的实例。它们是类级别的共享数据，与对象的状态无关。序列化的目的是保存对象的状态，所以 static 变量不会被包含在序列化的内容中。\nclass StaticExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private static int sharedValue = 10;    private int instanceValue;    public StaticExample(int instanceValue) &#123;        this.instanceValue = instanceValue;    &#125;&#125;\n当我们序列化 StaticExample 类的对象时，sharedValue 不会被序列化。在反序列化时，sharedValue 的值将取决于类加载时的初始化状态，而不是序列化时的值  \ntransient 修饰的属性不可以被序列化transient 关键字用于标记那些不希望被序列化的属性。这在某些场景下非常有用，比如当对象的某个属性包含敏感信息（如密码）或者该属性在反序列化后可以通过其他方式重新计算得到时。\nclass TransientExample implements Serializable &#123;    private static final long serialVersionUID = 1L;    private String username;    private transient String password;    public TransientExample(String username, String password) &#123;        this.username = username;        this.password = password;    &#125;&#125;\n当对 TransientExample 对象进行序列化时，password 的值不会被写入序列化流。这样可以保护敏感信息，防止其在序列化过程中被泄露。在反序列化后，password 属性的值将为 null，程序可以重新设置该值。\n对象序列化的作用为什么JavaIO流要特意造出这么一个IO流  \n当你需要把对象写入到文件或者读取的时候，其实我们更多的情况通常是保存对象的有效值字段，也就是对象的具体实例的字段，那么使用文件操作流FileOutputStream和字符输出流BufferedWriter或PrintStream就足够。这些流可以用于处理文件写入和基本数据类型及字符串的输出，但对象序列化有着独特且不可替代的作用  \n网络传输对象对象序列化机制是Java内建的一种对象持久化方式，可以很容易实现在JVM中的活动对象与字节流之间进行转换\n在网络传输中，发送端将对象序列化成字节流，经过网络传输到网络的另一端，可以从字节流重新还原为对象，这个特点使得在进行端到端的网络传输数据时候，字节流和Java对象之间的转换稳定且快速。  \n在其中分布式系统中，不同的节点之间需要进行对象的传递，对象序列化使得这种对象传输变得简单直接，确保了对象在不同 Java 虚拟机之间的准确传输，即使这些 JVM 运行在不同的操作系统上。\nRMI 是 Java 的一种远程方法调用机制，它允许一个 JVM 中的对象调用另一个 JVM 中的对象的方法。对象序列化也在其中起着关键作用 \n确保对象深层次的复制和持久化当对一个对象进行序列化然后反序列化时，会得到一个与原对象状态完全相同但内存地址不同的新对象。可以实现在不影响原对象的情况下对对象进行操作，多线程下的数据处理的机制也有一定序列化和反序列化的影子。这种情况对于远程创建对象副本并且调度的时候十分方便，而且不会干扰对象内部包含的复杂的引用关系，合理使用对象流可以大大提高程序处理复杂数据的能力。  \n在很多情况下，对象内部状态是需要被持久化的，序列化通过把对象写为字节流，保存的位置从JVM内存转移到文件系统，在需要的时候随时可以进行快速方便的还原例如：在一个游戏中，可以使用对象流将玩家的游戏进度（一个复杂的对象，包含玩家角色信息、游戏关卡等）保存到文件中，下次玩家启动游戏时可以恢复到上次的进度。  \n对象流与其他流的关系与字节流的关系字符流是对象流的特例，它们处理的是字符数据的序列化和反序列化。\n字符流（Reader 和 Writer 及其子类，如 BufferedReader、BufferedWriter 等）主要用于处理字符数据。Java 采用 Unicode 编码来表示字符，字符流对其的输入输出有优化。而且字符流在处理数据时，会根据指定的字符编码进行字节和字符之间的转换  \n而对象流可以将任何实现了 Serializable 接口的对象进行序列化和反序列化，意味着对象流操作的数据是复杂的对象结构，包括对象的成员变量、对象之间的引用关系。  \n与缓冲流的关系功能叠加：缓冲流（如 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter）的主要作用是提高数据读写的效率，通过在内存中设置缓冲区，减少实际的 I&#x2F;O 操作次数。对象流可以和缓冲流结合使用，以提升对象序列化和反序列化的性能。可以将 ObjectOutputStream 包装在 BufferedOutputStream 中，这样在写入对象时，数据会先写入缓冲区，当缓冲区满或流关闭时，才会一次性将数据写入底层输出流，从而减少磁盘 I&#x2F;O 操作的频率，提高写入效率。在处理大量对象的序列化或反序列化时，结合缓冲流能显著提升性能。不过反序列化涉及到的种种安全关系，这种情况，讨论一下就好。  \n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识03--包装器类及其自动装箱和拆箱","url":"/posts/24697.html","content":"Java难绷知识03——包装器类及其自动装箱和拆箱本篇文章和之前的倾向稍微有些不同，这篇文章我不仅要讨论一些容易头疼的细节，而且我打算尝试讨论一下如何理解Java中的包装类以及自动拆箱和自动装箱\n自动装箱（Autoboxing）和自动拆箱（Unboxing）是在基本数据类型和它们对应的包装类之间“转换”的一个包装过程，其中\n装箱：基本数据类型包装成对应的包装类\n拆箱：包装类拆包装成基本数据类型\n自动拆装箱下，上述转换在代码中是隐式的，由编译器自动完成。\n为什么Java要引入包装类，来包装起来数据类型其实很简单，原因就是因为：Java的面向对象语言，一切面向对象\n为了让基本类型也具有对象的特征，Java引入了包装器类，使得它具有了对象的性质\n统一数据类型处理基本数据类型不是对象，无法使用对象的特性,包装类将基本数据类型包装成对象，使其能够融入面向对象的编程体系\n在集合框架中，如ArrayList、HashMap等，它们只能存储对象类型。如果要将基本数据类型存储到这些集合中，就需要使用对应的包装类。\n使其支持多态包装类使得基本数据类型也能参与多态的实现。通过向上转型，不同的包装类对象可以被统一处理。例如，所有的包装类都继承自Number类（Boolean除外），可以在需要Number类型的地方使用Integer、Double等包装类对象，来满足Number的特别支持，也就是满足多态\n使其支持泛型和反射机制支持泛型  \n在泛型代码中，类型参数必须是引用类型，不能是基本数据类型。这与泛型的实现原理有关，在编译后，泛型类型信息会被擦除，替换为其限定的类型，所以基本数据类型无法直接参与这种类型擦除机制。引入了包装器类  \n用ArrayList存储整数时使用泛型作为例子\nimport java.util.ArrayList;import java.util.List;public class GenericWithWrapper &#123;    public static void main(String[] args) &#123;        // 使用Integer包装类在泛型中存储整数        List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();        intList.add(10);        int num = intList.get(0); // 自动拆箱    &#125;&#125;\n有兴趣可以试试String丢进去会咋样瞬间爆炸\n支持反射\n反射允许程序在运行时获取和操作类的信息那你基本数据类型就没法支持了，众所周知反射在java里面有多有用，所以引入了包装器类  \n包装类为基本数据类型提供了对应的类对象，使得可以通过反射操作基本数据类型包装类在反射机制中为基本数据类型提供对象层面的操作能力  \n通过Class.forName(“java.lang.Integer”)获取Integer包装类的Class对象，然后利用反射机制调用其构造函数创建Integer对象，同样，也可以通过反射调用包装类的方法。\npublic class ReflectionInWrapper &#123;    public static void main(String[] args) &#123;        try &#123;            // 获取Integer类的Class对象            Class&lt;?&gt; wrapperClass = Class.forName(&quot;java.lang.Integer&quot;);            // 通过反射调用构造函数创建对象            Object instance = wrapperClass.getConstructor(int.class).newInstance(10);            System.out.println(instance);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n基本数据类型及其细节为什么还要重新讲一下8 种基本数据类型，很简单，因为他们是Java语言的基础，并且在自动装箱（autoboxing）和自动拆箱（unboxing）机制中扮演着关键角色（毕竟进行的是基本数据类型和引用数据类型的“转换”）\n不厌其烦的八种基本数据类型Java是一种强类型语言，第一次变量赋值称为变量的初始化8 种基本数据类型可以分类为如下三类：字符类型 char布尔类型 boolean数值类型 byte、short、int、long、float、double\n\n\n\n基本数据类型\n所占字节数（大小）\n备注\n\n\n\nbyte\n1字节\n表示范围 -128 到 127\n\n\nshort\n2字节\n表示范围 -32,768 到 32,767\n\n\nint\n4字节\n范围是-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)\n\n\nlong\n8字节\n范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)\n\n\nfloat\n4字节\n大约 7 位有效数字\n\n\ndouble\n8字节\n大约 15 - 17 位有效数字\n\n\nchar\n2字节\n采用 Unicode 编码\n\n\nboolean\n通常占用 1 位\n\n\n\n\n\n类型转换问题（向上和向下取型）为什么上面我还要列个表格，就是要注意，在进行自动拆装箱和类型转换时，要注意数据的范围和精度问题，可能会隐藏一些类型转换错误。\n在 Java 的基本数据类型中，类型转换分为自动类型转换（向上转型）和强制类型转换（向下转型）。自动类型转换（向上转型）：当把一个取值范围小的类型赋值给取值范围大的类型时，会自动进行转换。强制类型转换（向下转型）：当把一个取值范围大的类型赋值给取值范围小的类型时，需要进行强制类型转换，这可能会导致数据丢失。\n当基本数据类型自动装箱为包装器类时，也遵循自动类型转换的规则，转换的是包装器类所继承的类，例如，byte 装箱为 Byte，Byte 可以自动向上转型为 Number（因为 Byte 继承自 Number）。\n当从包装器类自动拆箱为基本数据类型时，如果要进行向下转型，同样需要强制类型转换。\n跨类型的包装器转换：对于数值类型的包装器类，有时需要进行跨类型的转换。例如，将 Integer 转换为 Double。这需要先拆箱再装箱。\nInteger intValue = 10;// 先拆箱为int，再装箱为DoubleDouble doubleValueFromInt = new Double(intValue); \n\nboolean 类型及其包装类 Boolean 与其他基本数据类型和包装类之间不存在类型转换关系。boolean 类型只有 true 和 false 两个值，不能转换为数值类型或其他类型。\nchar 类型及其包装类 Character 可以与数值类型进行一些转换。char 本质上是一个无符号的 16 位整数，所以 char 可以自动转换为 int 类型。\nCharacter charValue = &#x27;A&#x27;;int intValueFromChar = charValue; // 自动装箱后，Character可自动转换为int\n\n\n有关溢出在基本数据类型下，进行同类型数值运算的时候溢出并不会抛异常，也没有任何提示，需要注意包装器类下溢出的情况代码\npublic class WrapperOverflowExample &#123;    public static void main(String[] args) &#123;        Integer maxInt = Integer.MAX_VALUE;        // 尝试增加1        Integer result = maxInt + 1;        System.out.println(&quot;运算结果: &quot; + result);    &#125;&#125;\n以上例而言，Integer.MAX_VALUE 是 int 类型能表示的最大值。当对 maxInt 加 1 时，会发生溢出，结果变为 Integer.MIN_VALUE，这和直接使用 int 基本数据类型进行运算溢出的情况一致。所以处理极大数的时候，我们偏向使用 BigInteger 和 BigDecimal 类\nJava中的数值类型不存在无符号的，它们的取值范围是固定的\n伏笔实际上，Java中还存在另一种基本类型void，它也有对应的包装类java.lang.Void，不过他很特殊，我们无法直接对它们进行操作，这个在下面我会特意说\n基本数据类型及其包装类八种基本数据类型都分别都有对应的包装类，如下表\n\n\n\n基本数据类型\n包装类\n缓存值范围\n\n\n\nboolean\njava.lang.Boolean\ntrue和false\n\n\nbyte\njava.lang.Byte\n-128～127\n\n\nchar\njava.lang.Character\n0 ~ 127\n\n\nfloat\njava.lang.Float\n没有缓存\n\n\nint\njava.lang.Integer\n-128～127\n\n\nlong\njava.lang.Long\n-128～127\n\n\nshort\njava.lang.Short\n-128～127\n\n\ndouble\njava.lang.Double\n没有缓存\n\n\n有关记忆：在这八个类名中，除了Integer和Character类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。\n包装类的方法与常量首先，使用和声明包装器类需要实例化，因为包装器类对象，需要进行实例化，才能对变量数据进行处理。包装类提供了丰富的方法和常量方便对基本数据类型进行操作\n方法\n构造方法（在 Java 9 及之后不推荐使用）\nInteger(int value)Integer i = new Integer(1000);\n\n\n\n因为我们更多使用静态工厂方法：（也就是valueOf进行装箱）例如\nvalueOf(byte b)：返回一个表示指定 byte 值的 Byte 实例。例如：Byte byteObj = Byte.valueOf((byte)5);valueOf(String s)：返回表示字符串指定值的相应包装类实例，其值由字符串参数解析得到例如：Integer intFromString = Integer.valueOf(&quot;123&quot;);，但字符串必须是合法的数值表示，否则会抛出 NumberFormatException。\n\n\n\n解析方法：\nparseXxx()\n该方法用于将字符串解析为对应的基本数据类型。字符串必须是合法的数值表示形式，否则会抛出 NumberFormatException\nint num = Integer.parseInt(&quot;123&quot;);double d = Double.parseDouble(&quot;3.14&quot;);\n\n特殊的一点，在parseBoolean(String s)，将字符串参数解析为 boolean 值时候  \n如果输入的字符串不是 “true”（不区分大小写），该方法将返回 false。\n这种设计使得 Boolean.parseBoolean 方法在处理非标准布尔字符串输入时，有一个明确且一致的返回值，不会抛出异常，而是统一返回 false。\n\n\n转换方法：\nXxxValue()\n该方法以Xxx类型返回输入的Byte、Short、Integer、Long、Float、Double 的值\n例如：\nshortValue()以 short 类型返回此 Short、Integer、Long、Float、Double 的值。Long l = 20L; short s = l.shortValue();\n\n其中在Character中，还有一些字符判断方法和字符转换方法，看一下就会用，也没啥特殊之处需要注意，就不在这里说了。\n\n\n常量\nMIN_VALUE 和 MAX_VALUE\n每个数值型包装类和Character都有这两个常量，分别表示该类型能够表示的最大值和最小值。\n例如，Integer.MAX_VALUE 表示 int 类型能表示的最大整数值，Double.MIN_VALUE 表示 double 类型能表示的最小正非零值（接近零）。\n在Character中，Character.MIN_VALUE 表示 char 类型能表示的最小 Unicode 代码点（’\\u0000’），Character.MAX_VALUE 表示 char 类型能表示的最大 Unicode 代码点（’\\uffff’）。在Character中，Character.MIN_VALUE和Character.MAX_VALUE分别表示所缓存的最大值\n\n\nTRUE 和 FALSE\n两个常量分别表示布尔值 true 和 false。它们是 Boolean 类的静态成员，用于获取对应的 Boolean 对象。\n在使用 Boolean 对象时，推荐使用这两个常量，而不是通过 new Boolean(true) 或 new Boolean(false) 创建对象，因为后者会创建新的对象实例，可能会引起问题\n基本数据类型和包装类需要注意的问题缓存机制：部分包装类（如 Integer、Byte、Short、Long、Character）在一定范围内会缓存对象。就拿Integer来说，Integer缓存了 -128 到 127 之间的整数。这意味着在这个范围内，相同值的对象是共享的。\nInteger a = 100; Integer b = 100; System.out.println(a == b); // 输出 true，因为 a 和 b 引用的是缓存中的同一个对象Integer c = 200; Integer d = 200; System.out.println(c == d); // 输出 false，因为 200 超出缓存范围，c 和 d 是不同的对象\n\n\n\n自动拆装箱如何理解自动拆装箱从用途上理解其实就是下述这样，自动装箱就是将基本数据类型自动转换为封装类型，自动拆箱是将封装类型自动转换为基本数据类型。\n但是其实编译器的自动执行情况如下：自动装箱，相当于Java编译器替我们执行了 Integer.valueOf(XXX);自动拆箱，相当于Java编译器替我们执行了Integer.intValue(XXX)\n/ 自动装箱 Autoboxing// Xxx.valueOf(xxx i)// 编译器会转成 Integer.valueOf(int i) 进行自动装箱Integer i = 100;Integer j = Integer.valueOf(100);System.out.println(&quot;i == j --&gt; &quot; + (i == j));j = Integer.valueOf(i);System.out.println(&quot;i == j --&gt; &quot; + (i == j));// 直接创建包装器类型的对象Integer k = new Integer(100);System.out.println(&quot;i == k --&gt; &quot; + (i == k));// 拆箱 Unboxing// Xxx..xxxValue()// 编译器会转成 Integer.intValue() 进行拆箱int m = i;System.out.println(&quot;i == m --&gt; &quot; + (i == m));\n\n参考：https://www.cnblogs.com/wpbxin/p/14311010.html\n\n\n\n什么时候会发生自动拆装箱\n赋值操作 = ：\n原始数据类型与对应包装器类型之间的相互赋值操作 = ，会自动装箱(拆箱)\n\n注意：注：原始数据类型赋值给 Long ，都需要明确标出是长整型\n\n\n作为方法参数：\n例如包装器类型.equals(原始数据类型)，原始数据类型会自动装箱。 Integer.equals(1)\n如果方法参数接收的是原始数据类型，则传入包装器类型时会拆箱；如果方法参数接收的是包装器类型，则传入原始数据类型时会自动装箱。\n作为方法返回值：\n方法返回值是包装器类型：如果返回的是原始数据类型，会自动装箱\n方法返回值是原始数据类型：如果返回的是包装器类型，会拆箱。\n\n\n算术运算和比较运算:\n在对包装类对象进行算术运算（如加、减、乘、除等）或比较运算（如 &#x3D;&#x3D;、&gt;、&lt; 等）时，会发生自动拆箱。因为这些运算符通常只适用于基本数据类型。\nInteger num3 = 10;Integer num4 = 20;int sum = num3 + num4; // num3 和 num4 自动拆箱为基本数据类型 int 后进行加法运算boolean isGreater = num3 &gt; num4; // num3 和 num4 自动拆箱为基本数据类型 int 后进行比较运算\n\n\n\n集合操作:\n当向集合（如 List、Set、Map 等）中添加基本数据类型时，会发生自动装箱，因为集合只能存储对象。\n当从集合中获取元素并赋值给基本数据类型变量时，会发生自动拆箱。\nimport java.util.ArrayList;import java.util.List;public class CollectionExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int num = 5;        list.add(num);         // 这里将 int 类型的 num 自动装箱为 Integer 后添加到 list 中        int retrievedNum = list.get(0);         // 这里将从 list 中获取的 Integer 对象自动拆箱为 int 类型并赋给 retrievedNum    &#125;&#125;\n\n\n\n一定要注意Java自动拆装箱的类型敏感问题，空指针问题和性能敏感问题\n\n\n自动拆装箱需要注意的问题和细节\n\n空指针异常：\n当对一个 null 值的包装类对象进行自动拆箱时，会抛出 NullPointerException;因为自动拆箱实际是调用包装类对象的 xxxValue 方法，null 对象无法调用该方法。\n\n\n装箱拆箱有开销：\n自动装箱和拆箱过程涉及对象的创建与销毁，相较于直接操作基本数据类型，会带来额外的性能开销。在性能敏感的场景（如频繁的循环操作）中，应尽量减少自动拆装箱的使用。\n可以用如下代码了解自动拆装箱的性能开销\nlong startTime = System.currentTimeMillis();for (int i = 0; i &lt; 1000000; i++) &#123;    Integer wrapper = i;     int primitive = wrapper; &#125;long endTime = System.currentTimeMillis();System.out.println(&quot;Time taken: &quot; + (endTime - startTime) + &quot; ms&quot;);\n\n\n\n方法重载与自动拆装箱：\n在方法重载的情况下，自动拆装箱可能导致选择错误的方法。\n例如，当有一个方法接受 int 参数，另一个方法接受 Integer 参数时，传递一个 Integer 对象可能会调用接受 Integer 参数的方法，而不是自动拆箱后调用接受 int 参数的方法。\npublic class AutoBoxingOverload &#123;    public static void print(Object obj) &#123;        System.out.println(&quot;Object method: &quot; + obj);    &#125;    public static void print(int num) &#123;        System.out.println(&quot;int method: &quot; + num);    &#125;    public static void main(String[] args) &#123;        Integer i = 10;        print(i);         // 调用 print(Object obj) 方法，可能与预期不符    &#125;&#125;\n\n\n\n运算：\n当 &#x3D;&#x3D; 运算符的两个操作数都是包装器类型引用，则比较指向的是否是同一个对象，而如果其中有一个操作数是原始数据类型（包含表达式结果）则比较的是数值（即会触发自动拆箱）。\n不同类型的包装器不能 &#x3D;&#x3D; 比较，报错提示：Incompatible operand types Long and Integer\n\n\n有关void和Voidvoid 是 Java 中的一种特殊数据类型，它表示 “无类型” 或 “空类型”\nJava不能声明 void 类型的变量，void 不能作为数组元素类型。\n\n\nVoid包装类:\nVoid 是 void 对应的包装类，它是一个不可实例化的类（其构造函数是私有的）。Void 类主要用于与 Java 反射机制和泛型等特性交互。\n\n\n特殊之处如下：\nVoid 类没有公共的构造函数，所以无法创建 Void 类的实例。因为 void 本身表示无值，创建 Void 实例没有实际意义。\n唯一常量 TYPE：Void 类包含一个公共的静态成员 TYPE它是一个 Class 类型的对象，用于表示 void 类型本身。\n在反射中获取一个返回 void 的方法的返回类型\nimport java.lang.reflect.Method;public class VoidExample &#123;    public void voidMethod() &#123;&#125;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method method = VoidExample.class.getMethod(&quot;voidMethod&quot;);        if (method.getReturnType() == Void.TYPE) &#123;            System.out.println(&quot;The method returns void.&quot;);        &#125;    &#125;&#125;\n\n\n\n不要混淆 Void 与 void：虽然 Void 是 void 的包装类，但它们的使用场景和语义有很大区别。void 用于声明方法返回类型或在特定语义中表示无值，而 Void 主要用于在需要对象表示 void 类型的场景\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识02-抽象类中只能有或者必须有抽象方法吗以及抽象类的细节探讨","url":"/posts/44268.html","content":"Java难绷细节02—抽象类中只能有抽象方法吗首先回答标题抛出的问题——False显然，有抽象方法的类是抽象类，但是，抽象类中只能有抽象方法吗？  \n抽象类可以包含抽象方法，也可以包含具体方法如果一个类包含至少一个抽象方法，用abstract关键字修饰，那么这个类必须被声明为抽象类。抽象类除了可以有抽象方法外，还可以包含具体的方法，即有方法体的方法。一个类用abstract修饰，那它就是抽象类了，但是不是说抽象类中必须有抽象方法，如果一个类像接口那样所有方法都有具体的实现，也可以用abstract修饰为抽象类那么反过来想，抽象方法只能写在抽象类中，但是抽象类中不一定要有抽象方法  \n一个包含了抽象方法和具体方法的抽象类\npublic abstract class Shape &#123;    // 抽象方法    public abstract double getArea();    // 具体方法    public void displayInfo() &#123;        System.out.println(&quot;This is a shape.&quot;);    &#125;&#125;\nabstract class AbstractParent &#123;    // 具体方法    public void printMessage() &#123;        System.out.println(&quot;This is a message from AbstractParent.&quot;);    &#125;&#125;// 子类继承抽象类，非抽象子类需要实现抽象方法class Child extends AbstractParent &#123;    // 子类可以直接使用父类的具体方法，根据需要重写    @Override    public void printMessage() &#123;        System.out.println(&quot;This is a message from Child, overriding the parent method.&quot;);    &#125;&#125;\n另外，如果一个抽象类并没有包含任何抽象方法，那么它的子类即使不实现任何方法也是非抽象类\n总之，抽象类是一种特殊的类，它的存在主要是为了提供一个通用的框架或基类，让其他子类去继承和实现具体的功能，抽象类可以包含抽象方法和具体方法，但是有抽象方法的类必须是抽象类\n如果我这篇博客就说这一点东西就有种，“因为这点事就把大伙叫过来？”的蹩脚感觉于是我们接着探讨一些抽象类中的各种令人很难绷的住的细节  \n为什么要有抽象类这个问题尽管乍看之下对实际开发的直接引导作用并非立竿见影，但深入剖析其中缘由，能让我们对 Java 语言的设计理念和面向对象编程的本质有更为透彻的理解（也能让我说出更多东西）   \n抽象类和抽象方法的产生是为了维护继承链的逻辑，即抽象类相对于那些普通的类处于继承树的根部。抽象类和抽象方法的诞生，很大程度上是为了维护继承体系的逻辑完整性与合理性  \n首先，类用于描述现实生活中一类事物。类中有属性、方法等成员  \n那么，抽象类中，有用的就是方法的声明，方法主体存在的意义被弱化，这种情况下十分适合用于取规范一个子类应该具备一个怎样的方法，既可以定义需要子类去实现的抽象行为，以满足不同子类的个性化需求，又能实现一些通用的行为或属性，让子类能够共享这些功能，从而提高代码的复用性和可维护性。  \n但是，抽象类中的非抽象方法如同在非抽象类中一样，正常继承使用。  \n所以，抽象类通常用于作为其他类的父类，用来定义一些需要子类去实现的抽象行为  \n主要目的是为了阻止其他类直接实例化这个类，同时为其子类提供一个通用的基类框架，用于实现一些通用的行为或属性。  \n抽象类可以设计模板模式，其中的某些步骤由抽象方法表示，具体的实现留给子类，大大增加了可读性和简便程度。\n抽象类可以用于定义一组相关类的通用接口规范，通过抽象类，我们可以确保所有相关类都具有特定的行为，同时又允许它们根据自身特性进行个性化实现。  \n抽象方法抽象方法只有方法声明，没有方法体（有爆Error），并且必须使用 abstract 关键字修饰。\npublic abstract class Shape &#123;    public abstract double getSquare();&#125;\n抽象方法的特点\n抽象方法必须存在于抽象类中\n\n包含抽象方法的类必须被声明为抽象类。这样做的目的是为了确保抽象方法不会被意外调用，因为抽象方法本身没有实际的执行代码，实例化该类时就可能调用到没有实现的方法，这会导致运行时错误。\n\n\n所有子类都需要实现抽象类中的抽象方法，除非子类本身也是抽象类。\n\n抽象类定义了一种抽象的概念，其中的抽象方法是这种概念下未完成的行为。子类继承抽象类，就继承了这种抽象概念及其未完成的行为。如果子类不实现抽象方法，那么这个子类仍然是不完整的，因为它没有完成抽象类中定义的行为。\n\n\n强制子类实现\n\n这个没啥好说的，当一个类继承自包含抽象方法的抽象类时，除非子类本身也是抽象类，否则它必须实现父类中的所有抽象方法。这是保证行为一致性的重要手段。\n\n\n\nabstract class Shape &#123;    public abstract double getArea();&#125;// 子类本身是抽象类，可以不实现getArea方法abstract class ThreeDShape extends Shape &#123;    // 这里没有实现getArea方法，因为ThreeDShape是抽象类&#125;class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\n\n\n\n抽象方法不能用private、final、static、native修饰。\n\n抽象方法不能被声明为 static，静态方法属于类本身，而不是类的实例，而抽象方法的实现依赖于具体的子类实例。如果将抽象方法声明为静态，就无法通过子类实例来提供具体的实现。来回的限制区域错误会导致无法通过子类实例来提供具体的实现\n\nprivate修饰的成员只能在本类中访问，抽象方法的设计目的是为了让子类去实现，矛盾\n\nfinal修饰的方法不能被子类重写。如果一个方法同时被abstract和final修饰，就会产生矛盾\n\nnative方法表示该方法的实现是由本地代码提供的，Java 本身不包含该方法的实现。抽象方法没有实现，就会出现冲突\n\n\n\n\n抽象类的一些各种细节1、抽象类不能被实例化首先抽象类是不能实例化的类\n抽象类存在的意义是作为一种抽象概念，为子类提供一个通用的框架，可能包含一些尚未具体实现的抽象方法，这些方法需要子类去实现如果抽象类可以被实例化，就可能调用到未实现的抽象方法，导致运行时错误\nabstract class Galgame &#123;    public abstract void run();&#125;\n如果允许Galgame被实例化，如Galgame galgame &#x3D; new Galgame();当调用galgame.run()时，由于run方法没有具体实现，就会出现问题\n2、abstract不能static抽象方法可以使用 public 或 protected 作为访问修饰符，但是static不行\n再次强调，抽象方法是一种只有声明没有实现的方法，需要子类去重写实现。它依赖于具体的子类实例来确定具体的行为。  \n而静态方法属于类本身的方法，不依赖于任何类的实例，是通过类名直接调用。在类加载时就已经确定，其生命周期与类的生命周期相同。\n如果一个方法同时被abstract和static修饰，就会产生矛盾。\n因为抽象方法没有具体实现，不能直接调用。只有在创建了子类的实例，并将其赋值给父类类型的引用变量后，通过该引用变量调用抽象方法时，才会执行子类中重写的具体实现。而静态方法不依赖于实例，在类加载时就可调用，这样会导致内存的顺序出现问题，因为静态方法不依赖于对象实例，而抽象方法却依赖子类实例来提供具体实现  \n反证法，如果是静态抽象方法，那么在类加载时就可调用，但此时由于它是抽象的，没有具体实现，调用必然出错。  \n3、抽象类的构造器抽象类可以有构造器虽然抽象类不能被直接实例化，但它的构造器用于被子类调用因为抽象类中是可以有成员变量的当创建子类对象时，会先调用抽象类的构造器，然后再调用子类的构造器。这确保了在子类对象初始化之前，从抽象类继承的部分已经被正确初始化。  \n4、可以有成员变量抽象类可以有成员变量的原因是抽象类中的成员变量可以用于存储子类共享或需要继承的状态信息，如果子类需要，抽象父类可以提供成员变量的访问控制：与普通类一样，抽象类中的成员变量可以有不同的访问修饰符  \nabstract class Vehicle &#123;    private int wheels;    protected String color;    public int speed;    Vehicle(int wheels, String color, int speed) &#123;        this.wheels = wheels;        this.color = color;        this.speed = speed;    &#125;    public int getWheels() &#123;        return wheels;    &#125;    public abstract void move();&#125;class Car extends Vehicle &#123;    public Car(int wheels, String color, int speed) &#123;        super(wheels, color, speed);    &#125;    @Override    public void move() &#123;        System.out.println(&quot;The &quot; + color + &quot; car is moving.&quot;);    &#125;&#125;\n\n5、继承抽象类的抽象子类问题如果一个类继承自抽象类，但它本身也是抽象类，那么它可以选择不实现父类的抽象方法\nabstract class Shape &#123;    public abstract double getArea();&#125;abstract class ThreeDShape extends Shape &#123;    // 可以不实现getArea方法，因为ThreeDShape本身是抽象类&#125;// 而 Sphere 类继承自 ThreeDShape，作为具体类，它必须实现 getArea 方法。class Sphere extends ThreeDShape &#123;    private double radius;    public Sphere(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double getArea() &#123;        return 4 * Math.PI * radius * radius;    &#125;&#125;\n\n抽象类跟接口包括我而言，很多人不禁疑惑，为什么有了抽象类，还要干出一个接口来？？这俩都是一定程度上规范子类的方法，功能一眼看过去差不多  \n这个我打算写一篇详细的文章，但是算了，没啥时间））我还要推gal，而且这不是一个需要长篇大论的问题，在这里和大家简单探讨一下   \n其实是很简单的问题，但凡遇到了两种东西，功能很相似，通常情况就是这几种：使用场景不同，产生的最终结果不同，兼容性与更优性问题。  \n突破继承限制与灵活性在 Java 中，一个类只能继承一个直接父类。这是为了避免多重继承带来的诸如继承混乱问题（什么哈斯图，我正好在看离散）而接口则打破了这种限制，一个类可以实现多个接口。这使得类能够从多个不同的 “行为集合” 中获取规范，灵活性极大up，使得子类更好的拥有多种行为能力。  \n功能侧重点差异抽象类虽然可以包含抽象方法，但也能有具体的属性和方法实现。这意味着抽象类在一定程度上仍然保留了对具体实现细节的描述。这是根据子类的需要，抽象类并不特别死的限制会带来很多方便和意想不到的特别之处  \n接口是一种完全抽象的类型，它只包含抽象方法（Java 8 及之后版本可包含默认方法和静态方法，但是本质绝对不会因为这个改动而改变），没有任何成员变量，只关注行为的定义，不涉及任何细节，只做出最少最需要的方法约束，更加纯粹地体现了一种行为规范，而且不用不行。  \n场景差异当多个类之间存在一些共同的属性和行为，并且这些共同部分可以在抽象类中进行部分实现时，适合使用抽象类。也就是对于很多个类中，我抽象出了一些共有属性实现了一个类，之后的符合该属性的类，就按照抽象类的规定来实现。与行为约束相比，更偏向共性总结。\n而当需要为不相关的类添加一些通用行为时，接口更为合适。也就是接口这是一个规矩，有什么类需要实现这个规矩，我就用接口来规范它。  \n扩展性差异如果在抽象类中添加新的方法，可能需要在所有子类中实现该方法，这对于已经存在的大量子类来说，维护成本较高，一个个改会比较累。  \n对于接口，如果添加新的方法，（在 Java 8 之前，实现该接口的类不会受到影响（除非强制要求实现新方法）），那么实现该接口的类会分为两种，一个是完全实现了接口的类，一个是未完全实现了接口的类。在 Java 8 及之后，新增的默认方法有了默认实现，实现接口的类可以选择是否重写这些默认方法，这使得接口在扩展时对已有实现类的影响较小，更易于维护和扩展。\n\n文章个人编辑较为匆忙，需要大家积极反馈来帮助这篇文章和我的更进一步QQ：1746928194，是喜欢画画的coder，欢迎来玩！\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Java难绷知识04--异常处理中的finally块","url":"/posts/683.html","content":"Java难绷知识04——异常处理中的finally块前情提要：该文章是个人花的时间最长，查询资料最多，可能是有关finally块的最长文章，希望大家能看下去\n一些前言在Java中，异常处理机制是程序设计中至关重要的一部分。它允许程序员在程序运行时捕获并处理错误，防止程序因为异常情况而突然崩溃。try - catch - finally结构是异常处理的核心部分。而finally块虽非必需，但为什么finally是异常处理中的最后一道防线  \n我的想法主要认为finally的必要关键之处是能够确保代码健壮性。\n而且finally块中存在许多深入理解的地方，在这篇文章我将依旧侧重于finally在异常处理中的细节\n\n\ntry - catch - finally结构及其基础内容try - catch - finally结构是Java异常处理的核心部分。它允许你在代码出现错误时进行适当的处理，而不是让程序崩溃。在这里只对其简单阐述，本篇文章侧重点是finally\n基本结构\ntry &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType e) &#123;    // 异常处理代码&#125; finally &#123;    // 无论是否发生异常，都会执行的代码&#125;\n\ntry语句作用：try语句块用于包含可能抛出异常的代码  \n它是异常监控的起始点，我们需要将可能出现问题的代码段放在 try 块内。\n其中：一个 try 块后必须至少跟一个 catch 块或者一个 finally 块。不能单独存在 try 块。\ntry 块内的代码一旦抛出异常，异常抛出点之后的代码将不会继续执行，程序流程会立即跳转到相应的 catch 块\n\n\ncatch语句:作用：catch 块用于捕获并处理 try 块中抛出的异常。每个 catch 块指定了它能够捕获的异常类型。\n在 catch 块内，你可以对捕获到的异常进行处理，例如记录日志、向用户显示更友好的错误信息、进行恢复操作等。捕获到的异常对象可以通过 catch 块的参数（如 e）来访问，通过这个对象可以获取异常的详细信息\n其中：catch 块会按顺序检查，只有与抛出异常类型匹配（包括子类类型匹配）的 catch 块才会被执行。\n示例代码如下：\ntry &#123;    // 有一些语句抛出了 IOException &#125; catch (IOException e)) &#123;    // 那么 catch (IOException e) 块会先被执行    // 如果没有 catch (IOException e)，才会执行 catch (Exception e)&#125; catch (Exception e) &#123;    &#125;\n\n多个 catch 块顺序：在编写多个 catch 块时，子类异常的 catch 块必须放在父类异常的 catch 块之前。否则，编译器会报错，因为子类异常永远无法被捕获。例如，以下代码会报错：\ntry &#123;    // 有一些语句抛出了 IOException&#125; catch (Exception e) &#123;   &#125; catch (IOException e) &#123;    // 编译器会报错，因为子类异常永远无法被捕获&#125;\ncatch语句可以有多个\n\n\nfinally语句finally语句块是可选的\n无论try块是否抛出异常，finally块代码通常都会执行。  \n它允许程序员在程序运行时捕获并处理错误，防止程序因为异常情况而突然崩溃。  \n如下代码片段验证finally的执行情况\ntry &#123;    System.out.println(&quot;Inside try block&quot;);&#125; catch (Exception e) &#123;    System.out.println(&quot;Exception caught&quot;);&#125; finally &#123;    System.out.println(&quot;Finally block always executes&quot;);&#125;\n它主要用于放置必须执行的清理代码，如关闭文件流、释放数据库连接等。\nfinally块中的代码总是在try和catch执行之后、方法返回之前执行。即使在try或catch中出现了return语句，finally块依然会执行。  \n\n\nfinally的基础知识finally块的作用\n确保资源释放：\n\nfinally 块最主要的作用是确保无论 try 块中是否发生异常，也无论 catch 块是否捕获到异常，特定的代码段（通常用于资源清理和关闭资源）都会被执行。这对于需要手动管理资源的情况（如文件流、数据库连接、网络连接等）至关重要，避免资源泄漏。  \n\nfinally 块常用于确保文件流、数据库连接、网络连接等资源的正确关闭。在 Java 中，这些资源若不及时关闭，可能导致资源泄漏，长时间运行后会耗尽系统资源，使程序性能下降甚至崩溃。\n\n我认为这是finally块在异常中被设计出来的初衷，因为我们也不知道也需要一个异常后被正确处理的情况。\n\n虽然现在，大家使用更多的是使用try-with-resources语法，因为它能够自动管理资源，减少错误发生的概率。省事还高级。\n\n\n\n\n\n\n\n异常后执行清理工作：\n\nfinally块确保程序不会因为异常中断而漏掉必要的清理操作。这样可以避免资源泄漏或系统状态不一致的问题。\n\n其中，在涉及多层资源嵌套的场景中，finally 块的作用更为突出，多层资源之间的关系密切复杂，在finally块中去有条理的解决即友好又省事。因为finally 块确保了处理是成功还是因异常回滚，相关资源都能被正确释放。\n\n\n\n\n\n\n\n对某些操作的保证：finally 块会影响 return 语句的执行流程，确保在返回值确定前执行必要的清理操作。即使try或catch语句中发生了return语句，finally块的代码依然会执行，保证了关键代码的执行。我们可以利用这个来处理异常发生后的操作。\n    public class FinallyWithReturnExample &#123;   public static int test() &#123;       try &#123;           // 当 try 块执行到 return 1 时，会先暂存返回值 1,然后执行 finally 块中的代码,最后再返回暂存的 1           return 1;       &#125; finally &#123;           // finally 块在 return 语句真正返回前执行,在有 return 的情况下，也能保证清理等必要收尾操作的执行，前提是你finally块中没有retrun语句           System.out.println(&quot;Finally block in test method&quot;);       &#125;   &#125;   \tpublic static void main(String[] args) &#123;       \tint result = test();       \tSystem.out.println(&quot;Result: &quot; + result);   \t&#125;&#125;\n\n\n\n\n维护程序状态一致性\n\n确保部分操作完成：在某些业务逻辑中，部分操作完成后需要执行特定的收尾操作以维护程序状态的一致性。  \n\n恢复中间状态：在一些复杂的业务流程中，程序可能会在执行过程中进入临时的中间状态。finally 块可用于在异常发生时恢复到之前的稳定状态。  \n    public class OrderProcessingExample &#123;   private static String orderStatus = &quot;INITIAL&quot;;   public static void processOrder() &#123;   \t// try 块尝试处理订单并更新订单状态       try &#123;           orderStatus = &quot;PROCESSING&quot;;           // 模拟订单处理的复杂逻辑，可能抛出异常           if (Math.random() &gt; 0.5) &#123;               throw new RuntimeException(&quot;Order processing failed&quot;);           &#125;           orderStatus = &quot;COMPLETED&quot;;       &#125; catch (Exception e) &#123;           e.printStackTrace();       // finally 块会检查订单状态       &#125; finally &#123;       \t// 如果不是 COMPLETED，则将其恢复到 INITIAL 状态       \t// 保证程序状态的一致性和准确性。           if (!&quot;COMPLETED&quot;.equals(orderStatus)) &#123;               orderStatus = &quot;INITIAL&quot;;           &#125;           System.out.println(&quot;Final order status: &quot; + orderStatus);       &#125;   &#125;   \tpublic static void main(String[] args) &#123;       \tprocessOrder();   \t&#125;&#125;\n\n增强代码的健壮性与可维护性：finally 块为异常处理提供了一个统一的出口，无论 try 块中发生何种异常，都能在此进行统一的处理逻辑。这使得代码结构更加清晰，易于理解和维护。而且这样能够大量的减少代码重复。\n\n\n\n\n\n\n所以这就是为什么要有异常捕获结构中要有finally块。\nfinally关键字的细节之处\n\n有异常但未被捕获时，finally块的执行情况finally块的执行与异常是否被捕获和处理是相对独立的。即使异常未被捕获，finally块也会执行其代码。这确保了无论异常如何传播，finally块中的资源清理或其他关键代码都能得到执行。 \n这里也可以看出finally块的必定会被执行的一个性质  \nfinally块执行完毕后，向外传播的异常类型和try块中抛出的异常类型一致，不会因为finally块的存在而改变。但是，如果finally块中的代码抛出了异常，它会覆盖try块或catch块中已经抛出的异常\n例如，如果try块抛出IOException，即使经过finally块的执行，向外传播的依然是IOException。\n示例代码如下\npublic class FinallyThrowsExceptionExample &#123;    public static void main(String[] args) &#123;        try &#123;            methodThatThrowsException();        &#125; catch (Exception e) &#123;            System.out.println(&quot;Caught in main: &quot; + e.getMessage());        &#125;    &#125;\t\t// main方法捕获到的异常信息是Caught in main: Exception thrown in finally    public static void methodThatThrowsException() &#123;        try &#123;        \t// 原始try块中的异常被覆盖            throw new RuntimeException(&quot;Exception thrown in inner try&quot;);        &#125; finally &#123;            throw new RuntimeException(&quot;Exception thrown in finally&quot;);        &#125;    &#125;&#125;\n\n\n\n\n与 return 语句的交互首先，在 finally 代码块中改变返回值并不会改变最后返回的内容，而且finally中的语句一定会执行 \n\n\n1.当 try 代码块和 catch 代码块中有 return 语句时，finally 仍然会被执行。且 try 代码块或 catch 代码块中的 return 语句执行之前，都会先执行 finally 语句\npublic class TryReturnFinallyExample &#123;    public static int test() &#123;        try &#123;        \tint result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;        \treturn 2;        &#125; finally &#123;            System.out.println(&quot;Finally block in test method&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\n\n\n\n2.finally 块中的代码可以访问和修改 try 块和 catch 块中定义的局部变量，但这种修改不会影响 return 语句返回的值\npublic class CatchReturnFinallyVariableExample &#123;    public static int test() &#123;        try &#123;            int result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;            int num = 2;            return num;        &#125; finally &#123;        \t// finally 块将 num 修改为 3            num = 3;        &#125;    &#125;\t\t// 但 return 语句返回的还是 catch 块中 return 语句执行时 num 的值    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\n\n\n\n如果此时，finally 块本身也有 return 语句，会以一种较为复杂的方式处理局部变量\ntry和catch块中的局部变量：即便finally块可以访问并修改try和catch块中定义的局部变量，由于finally块中的return会主导返回值，所以这种修改对最终返回值的影响也会被finally块的return逻辑所掩盖。\n当在try块暂存return的结果时候，如果finally块修改了局部变量影响了返回值，但本质是finally块的return起了决定性作用。\n示例代码\npublic class FinallyModifyLocalVar &#123;    public static int test() &#123;        int num = 1;        try &#123;            return num;        &#125; finally &#123;            num = 3;            return num;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\n\n\n\n\n如果 finally 块中有 return 语句，它会覆盖 try 或 catch 块中的 return 语句。这意味着无论 try 或 catch 块中原本打算返回什么值，最终都会被 finally 块中的 return 值取代。\n\npublic class FinallyReturnOverrideExample &#123;    public static int test() &#123;        try &#123;        \t// 尽管 try 块原本要返回 1            return 1;        &#125; catch (Exception e) &#123;            return 2;        &#125; finally &#123;        \t// 但由于 finally 块中有 return 3，最终返回的值是 3。            return 3;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\n\n所以说finally块中最好不要包含 return 语句，要不然程序会提前退出,，而且使用 finally 块中的 return 语句会使代码的逻辑变得混乱，因为它打破了正常的 try - catch - finally 异常处理流程，使得代码的返回值不依赖于 try 或 catch 块中的逻辑。可读性和可维护性会瞬间爆炸\n\n\n\n异常情况下的返回：如果try块抛出异常，catch块捕获并处理异常，finally块的return语句依然会生效，覆盖catch块中的return\n\npublic class FinallyReturnWithException &#123;    public static int test() &#123;        try &#123;            int result = 10 / 0;            return result;        &#125; catch (ArithmeticException e) &#123;            return 2;        &#125; finally &#123;            return 3;        &#125;    &#125;    public static void main(String[] args) &#123;        int result = test();        System.out.println(&quot;Result: &quot; + result);    &#125;&#125;\n\n在这里强调一下，如果出现了异常未捕获的情况，就是try块抛出异常且未被catch块捕获，那么finally块执行完毕后，finally块中的return会阻止异常继续传播，并且返回finally块中的值。（这种情况可能会隐藏程序中的异常，导致调试难度从Galgme变成黑暗之魂，别用）\n\n\n异常屏蔽首先要知道一个前提：\ntry 块抛出异常且 catch 块未捕获：当 try 块抛出异常，而 catch 块没有捕获该异常时，finally 块依然会执行。执行完 finally 块后，异常会继续向外层传递。\npublic class ExceptionFinallyInteractionExample &#123;    public static void test() &#123;        try &#123;            throw new RuntimeException(&quot;Exception in try block&quot;);        &#125; finally &#123;            System.out.println(&quot;Finally block in test method&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            test();        &#125; catch (RuntimeException e) &#123;            System.out.println(&quot;Caught in main method: &quot; + e.getMessage());        &#125;    &#125;&#125;\n\n\n\n如果finally块中的代码抛出了异常，它会覆盖try块或catch块中已经抛出的异常。\n所以我们应该尽量避免在finally块中抛出异常，因为会覆盖异常本身的情况，导致调试出现歧义\npublic class FinallyThrowsExceptionExample &#123;    public static void test() &#123;        try &#123;            throw new RuntimeException(&quot;Exception in try block&quot;);        &#125; finally &#123;            throw new RuntimeException(&quot;Exception in finally block&quot;);        &#125;    &#125;\t\t// main 方法捕获到的是 finally 块抛出的异常信息 Exception in finally block    public static void main(String[] args) &#123;        try &#123;            test();        &#125; catch (RuntimeException e) &#123;            System.out.println(&quot;Caught in main method: &quot; + e.getMessage());        &#125;    &#125;&#125;\n\n\n\nfinally中可能抛出异常的情况的处理&lt; 引用自 https://blog.csdn.net/qq_44861675/article/details/106353369 本人作补充\n有这样一段代码\npackage Stream_IntOut;import java.io.*;/** * 使用缓冲区输入流和缓冲区输出流实现复制文件的功能。 * 并简单处理IO异常 * */public class Practice3_BufferedWriter_BufferedReader_Copy &#123;    public static void main(String[]args)&#123;        FileWriter fw = null;        FileReader fr = null;        BufferedWriter bufw = null;        BufferedReader bufr = null;        try&#123;            fw = new FileWriter(&quot;E:\\\\file_copy2.txt&quot;);            fr = new FileReader(&quot;E:\\\\file.txt&quot;);            bufw = new BufferedWriter(fw);            bufr = new BufferedReader(fr);            String line;            while((line=bufr.readLine())!=null)&#123;                bufw.write(line);                //写入换行符                bufw.newLine();                //刷新一次流对象                bufw.flush();            &#125;        &#125;catch(IOException e)&#123;            e.printStackTrace();        &#125;finally &#123;            if(fr!=null)                try&#123;                    assert bufr != null;                    bufr.close();            &#125;catch (IOException e)&#123;                    throw new RuntimeException(&quot;无法关闭fr流对象&quot;);                &#125;            if(fw!=null)                try&#123;                    assert bufw != null;                    bufw.close();                &#125;catch (IOException e)&#123;                    throw new RuntimeException(&quot;无法关闭fw流对象&quot;);                &#125;        &#125;    &#125;&#125;\n\n我们可以从IDEA的提示里边看到一些东西: throw inside “finally” block\n也就是说，finally块里边抛出异常是不建议的，java异常语句中的finally块通常用来做资源释放操作，finally块和普通代码块一样，无法同时使用return语句和throw语句，因为无法通过编译\n为什么不被建议？\nfinally块中的throw语句会覆盖try和catch语句中的异常\n实例代码\npackage 面试题;public class FinallyAndReturnAndThrow3 &#123;    public static void main(String[]args)&#123;        displayTest();    &#125;    private static void displayTest() &#123;        try&#123;            System.out.println(2/0);//异常发生        &#125;catch (Exception e)&#123;            System.out.println(&quot;displayTest&#x27;s catch&quot;);            throw new RuntimeException(&quot;除数为0&quot;);        &#125;finally &#123;            System.out.println(&quot;displayTest&#x27;s finally&quot;);            throw new RuntimeException(&quot;俺会覆盖catch的异常&quot;);        &#125;    &#125;&#125;\n\n在结果中，返回的异常是finally里面的，catch的异常并没有被抛出。同样的try中捕抓的异常也会被掩盖。\n在Java核心技术书中，作者建议在finally块中尽量不要使用会抛出异常的资源回收语句。\n那么在我们使用IO流时，常常在finally使用到throw，那该如何解决呢？\n其中一个方法，就是接下来说的，在finally块中使用try-catch块，进行多层嵌套的try - catch - finally情况\n但其实，大家更常用的方法就是 使用 Java 7 的try-with-resources语句，在关闭资源时抛出的异常会被添加为原来异常的被抑制异常并展示，不会掩盖try块中的异常。\n\n\n多层嵌套的try - catch - finally情况异常捕获顺序\n内层优先：当异常发生时，Java 首先会尝试在最内层的try块对应的catch块中捕获异常。如果内层try块没有匹配的catch块，异常会向外层try块传播，寻找匹配的catch块。\n也需要遵循子类优先：在编写catch块时，捕获子类异常的catch块应该放在其父类异常的catch块之前。否则，子类异常的catch块永远不会被执行，编译器会报错。\n\nfinally块的执行顺序\n内层优先：无论异常是否发生，内层try块的finally块总是在内层try块结束时（正常结束或因异常结束）立即执行，然后才会执行外层try块的finally块。\n异常传递：如果内层try块的finally块抛出异常，这个异常会向外层传播，可能会掩盖内层try块中原本抛出的异常。为避免这种情况，可以在内层finally块中捕获并处理异常，或者使用辅助变量记录内层try块的异常，同时处理内层finally块抛出的异常。\n\n注意资源的关闭顺序，永远是在多层嵌套中需要注意的地方所以我建议使用try - with - resources语句，它会自动管理资源的关闭，并确保每个资源只被关闭一次。\n示例代码\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class NestedTryCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            try &#123;                InputStream inputStream = new FileInputStream(&quot;example.txt&quot;);                try &#123;                    int data;                    while ((data = inputStream.read())!= -1) &#123;                        System.out.print((char) data);                    &#125;                &#125; catch (IOException e) &#123;                    System.out.println(&quot;读取文件时出错: &quot; + e.getMessage());                &#125; finally &#123;                    try &#123;                        if (inputStream!= null) &#123;                            inputStream.close();                        &#125;                    &#125; catch (IOException e) &#123;                        System.out.println(&quot;关闭文件时出错: &quot; + e.getMessage());                    &#125;                &#125;            &#125; catch (FileNotFoundException e) &#123;                System.out.println(&quot;文件未找到: &quot; + e.getMessage());            &#125;        &#125; catch (Exception e) &#123;            System.out.println(&quot;发生其他异常: &quot; + e.getMessage());        &#125;    &#125;&#125;\n\n\n\n\n上一篇：Java难绷知识03–包装器类及其自动装箱和拆箱下一篇：Java难绷知识05——Swing中的事件调度线程和资源释放\n\n","categories":["Java学习","JavaSE","Java难绷知识系列"],"tags":["实用知识","Java技术","JavaSE","语言方面","学习"]},{"title":"Log4j2日志记录框架的使用与配置文件的解析","url":"/posts/47832.html","content":"Log4j2如何使用什么是日志日志(Log)是软件系统运行时记录的重要事件、状态信息和操作轨迹的机制。它是软件开发、测试和维护过程中不可或缺的工具，具有以下特点和作用：\n\n问题诊断：当系统出现异常或错误时，日志提供了问题发生的上下文信息，帮助开发人员快速定位问题根源\n行为追踪：记录用户操作和系统行为，便于审计和追踪业务流程\n性能监控：通过记录关键操作的时间戳，可以分析系统性能瓶颈\n安全审计：记录系统访问和敏感操作，满足合规性要求\n运行状态记录：保存系统运行期间的重要状态变化，便于事后分析\n\n日志通常分为不同级别，便于过滤和分类处理：\n\nFATAL&#x2F;ERROR：错误，严重错误事件，可能导致系统崩溃或功能失效\nWARN：警告，输出警告的信息，潜在的有害情况，需要引起注意但不会立即影响系统运行\nINFO：信息，输出重要的运行时信息，记录系统正常运行状态\nDEBUG：调试，一般在开发中都设置的最低级别，详细的调试信息，用于开发阶段问题排查\nTRACE：追踪，最低的日志级别，最详细的跟踪信息，记录程序执行的详细路径\n\n级别高的日志会自动屏蔽级别低的日志\n日志的输出目的地指定了日志将会打印到控制台还是文件中，输出格式控制了日志信息的显示内容\nLog4j2作为Java生态中最流行的日志框架之一，提供了强大的日志记录能力，能够满足上述所有日志需求。\n简介Log4j的1.x版本虽然已经被广泛使用于很多应用程序中，但由于出现内存泄漏等bug，代码难以维护，以及需要使用老版本的jdk等劣势，在2015年8月已经玩完。它的替代品，SLF4J，Logback，Log4j2对日志框架做了很多必要的改进。\n历史上出现了很多的日记框架，如：\nLog4j：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。\nLog4j2：Apache Log4j 2是apache开发的一款Log4j的升级产品。\nCommons Logging：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。\nSlf4j：类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。\nLogback：一套日志组件的实现(Slf4j阵营)。\nJul(Java Util Logging)：自Java1.4以来的官方日志实现。\n安装在开发中使用Log4j2日志记录框架需要引入的jar包如下：\nlog4j-api-2.13.0.jarlog4j-core-2.13.0.jar\n\nmaven中配置xml如下\n&lt;properties&gt;    &lt;logging.log4j.version&gt;2.13.0&lt;/logging.log4j.version&gt;&lt;/properties&gt; &lt;dependencies&gt;    &lt;!-- Log4j2日志记录框架 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;$&#123;logging.log4j.version&#125;&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置文件在项目的src根目录下，创建log4j2.xml配置文件。配置信息如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;     &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。对于Loggers中level的定义同样适用。\n下面是Appender配置，Appender可以理解为日志的输出目的地，这里配置了一个类型为Console的Appender，也就是输出到控制台。Console节点中的PatternLayout定义了输出日志时的格式。\nLog4j提供的转换模式：\n\n%m 输出代码中指定的消息。\n\n%p 输出优先级，即DEBUG,INFO,WARN,ERROR,FATAL。\n\n%r 输出自应用启动到输出该log信息耗费的毫秒数。\n\n%c 输出所属的类目,通常就是所在类的全名。\n\n%t 输出产生该日志事件的线程名。\n\n%n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n”。\n\n%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d{dd MMM yyyy HH:mm:ss,SSS}，输出类似：02 Nov 2012 14:34:02,781)。\n\n%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数， 如：Testlog.main(TestLog.java:10)。\n\n%F 输出日志消息产生时所在的文件名称。\n\n%L 输出代码中的行号。\n\n%x 输出和当前线程相关联的NDC(嵌套诊断环境)，像java servlets多客户多线程的应用中。\n\n%% 输出一个”%”字符。\n\n\n最后是Logger的配置，这里只配置了一个Root Logger。\n可以用如下代码测试\npublic static void main(String[] args)&#123;    Logger logger = LogManager.getLogger(LogFunction.class);    logger.trace(&quot;trace level&quot;);    logger.debug(&quot;debug level&quot;);    logger.info(&quot;info level&quot;);    logger.warn(&quot;warn level&quot;);    logger.error(&quot;error level&quot;);    logger.fatal(&quot;fatal level&quot;);&#125;\n\n\n\nSpring中整合Log4j2日志框架Log4j2依赖导入引入Log4j2的依赖\n&lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;          &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;          &lt;version&gt;2.19.0&lt;/version&gt;      &lt;/dependency&gt;\n\n在引入log4j2时，需要排除掉Logback日志框架的依赖即。\n&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n\nlog4j2一般可以通过xml,json,yaml或者properties形式文件来实现，我们这边主要介绍xml文件格式。因为log4j 2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本配置文件后缀名只能为”.xml”,”.json”或者”.jsn”。\n系统选择配置文件的优先级(从先到后)如下：\n(1).classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件。\n(2).classpath下的名为log4j2-test.xml的文件。\n(3).classpath下名为log4j2.json 或者log4j2.jsn的文件。\n(4).classpath下名为log4j2.xml的文件。\n我们一般默认使用log4j2.xml进行命名。如果本地要测试，可以把log4j2-test.xml放到classpath，而正式环境使用log4j2.xml，则在打包部署的时候不要打包log4j2-test.xml即可。\nLog4j2的路径相关默认路径\n引入log4j2依赖后，默认在src/main/resources目录下加入log4j2.xml配置文件对日志进行配置即可，然后在application.yml中进行访问路径的配置。\n示例如下：\n\nlog4j2.xml部署位置   在代码工程中的src&#x2F;main&#x2F;resources目录下放入配置文件。\nyml配置\n\n#日志配置 无特殊需求无需更改logging:  config:  classpath:log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\n\n那么如何自定义部署位置\n当然我们也可以在微服务部署的config/目录下放置，然后在application.yml中进行访问路径的配置。\n举例：我们的micro-service01部署中配置的log4j2.xml路径。\n\nlog4j2.xml部署位置\n\n[userA@linux01 config]$ pwd/home/userA/SpringBoot/micro-service01/config[userA@linux01 config]$ lltotal 24-rwxr-xr-x 1 userA userA 5938 Sep  9 16:30 application.yml-r-------- 1 userA userA 8342 Sep  8 16:33 log4j2.xml\n\n\nyml配置\n\n#日志配置 无特殊需求无需更改logging:  config: /home/userA/SpringBoot/micro-service01/config/log4j2.xml  level:    root: INFO    javax.activation: info    org.apache.catalina: INFO    org.apache.commons.beanutils.converters: INFO    org.apache.coyote.http11.Http11Processor: INFO    org.apache.http: INFO    org.apache.tomcat: INFO    org.springframework: INFO    com.chinamobile.cmss.bdpaas.resource.monitor: DEBUG\n\nLog4j2.xml配置详解缺省默认配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;&lt;Appenders&gt;    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;        &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;    &lt;/Console&gt;&lt;/Appenders&gt;&lt;Loggers&gt;    &lt;Root level=&quot;error&quot;&gt;        &lt;AppenderRef ref=&quot;Console&quot; /&gt;    &lt;/Root&gt;&lt;/Loggers&gt;&lt;/Configuration&gt;\n\n解读：\n全局配置：\n\n仅输出 ERROR 及以上级别的日志（Root level=&quot;error&quot;）。\n使用名为 Console 的Appender（控制台输出）。\n\n日志格式：\n14:25:30.456 [main] ERROR com.example.MyClass - This is an error message\n\n\n%d&#123;HH:mm:ss.SSS&#125; → 时间（时:分:秒.毫秒）。\n[%t] → 线程名（如 [main]）。\n%-5level → 左对齐的日志级别（如 ERROR）。\n%logger&#123;36&#125; → 类名（长度限制为36字符）。\n%msg%n → 日志内容 + 换行。\n\n配置文件节点解析\n**根节点 &lt;Configuration**&gt;\n&lt;Configuration status=&quot;WARN&quot;&gt;\n\n\n作用：整个配置文件的根节点。\n两个属性：\nstatus：用来指定log4j2本身的打印日志的级别，用于调试配置文件问题。可选值：TRACE, DEBUG, INFO, WARN, ERROR, FATAL。\n其他可选属性：monitorInterval=&quot;30&quot;用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s\n\n\n有两个子节点：Appenders和Loggers(表明可以定义多个Appender和Logger)。\n\n\n日志输出器Appenders节点，常见的有三种子节点：Console、RollingFile、File。\n&lt;Appenders&gt;  &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;    &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;  &lt;/Console&gt;&lt;/Appenders&gt;\n\n\n作用：定义日志输出的目的地（如控制台、文件等）。\n子节点类型：\n**&lt;Console&gt;**：定义输出到控制台的Appender。\nname：唯一标识符,指定Appender的名字。（后续通过 AppenderRef 引用）。\ntarget：输出目标，可选 SYSTEM_OUT（标准输出）或 SYSTEM_ERR（标准错误）。一般只设置默认：SYSTEM_OUT。\nPatternLayout：输出格式，不设置默认为:%m%n。\n\n\n&lt;File&gt;：输出到文件（支持滚动日志）。用来定义输出到指定位置的文件的Appender。\nname：指定Appender的名字\nfileName：指定输出日志的目的文件带全路径的文件名。\nPatternLayout：输出格式，不设置默认为:%m%n。\n\n\n**&lt;RollingFile&gt;**节点用来定义超过指定大小自动删除旧的创建新的的Appender。\nname：指定Appender的名字。\nfileName：指定输出日志的目的文件带全路径的文件名。\nPatternLayout：输出格式，不设置默认为:%m%n。\nfilePattern：指定新建日志文件的名称格式。\nPolicies：指定滚动日志的策略，就是什么时候进行新建日志文件输出日志。\nTimeBasedTriggeringPolicy：Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate&#x3D;true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am。\nSizeBasedTriggeringPolicy：Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小。\nDefaultRolloverStrategy：用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。\n\n\n其他：&lt;Socket&gt;   &lt;Kafka&gt;   &lt;JDBC&gt;  等\n\n\n**&lt;PatternLayout&gt;**：定义日志格式。\npattern：格式模板，常用占位符：\n%d：日期时间（可指定格式如 %d&#123;yyyy-MM-dd HH:mm:ss&#125;）。\n%t：线程名。\n%-5level：左对齐的日志级别（长度5）。\n%logger&#123;36&#125;：Logger名称（最大长度36）。\n%msg：日志消息。\n%n：换行符。\n\n\n\n\n\n\n日志记录器&lt;Loggers&gt;\n&lt;Loggers&gt;  &lt;Root level=&quot;error&quot;&gt;    &lt;AppenderRef ref=&quot;Console&quot; /&gt;  &lt;/Root&gt;&lt;/Loggers&gt;\n\n\n作用：定义日志的采集规则（哪些级别的日志被记录，输出到哪些Appender）。常见的有两种：Root和Logger。\n核心节点：\nRoot节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出。\nlevel：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。\nAppenderRef：Root的子节点，用来指定该日志输出到哪个Appender。\nLogger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。\nlevel：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。\nname：用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点。\nAppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=&quot;false&quot;只在自定义的Appender中进行输出。\n\n\n\n\n关于日志level\n共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。\n\nAll：最低等级的，用于打开所有日志记录。\nTrace：是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出。\nDebug：指出细粒度信息事件对调试应用程序是非常有帮助的。\nInfo：消息在粗粒度级别上突出强调应用程序的运行过程。\nWarn：输出警告及warn以下级别的日志。\nError：输出错误信息日志。\nFatal：输出每个严重的错误事件将会导致应用程序的退出的日志。\nOFF：最高等级的，用于关闭所有日志记录。\n\n程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。\n\n\n比较完整的log4j2.xml配置模板配置模板1:不同级别日志分离存储带日志滚动归档，历史日志分析\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;!--先定义所有的appender--&gt;    &lt;appenders&gt;        &lt;!--这个输出控制台的配置--&gt;         &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;        &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;        &lt;/File&gt;        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/info.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/warn.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingFile&gt;        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/error.log&quot;                     filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;loggers&gt;        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;        &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt;        &lt;root level=&quot;all&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n配置模板2基础控制台 + 文件日志（带滚动策略）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- status=&quot;WARN&quot; 表示 Log4j2 自身日志级别，调试时可设为 TRACE --&gt;&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;Appenders&gt;        &lt;!-- 控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!-- 日志格式：时间 线程 级别 类名 - 消息 --&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 滚动文件日志 (每天滚动，最多保留7天) --&gt;        &lt;RollingFile name=&quot;RollingFile&quot;                      fileName=&quot;logs/app.log&quot;                      filePattern=&quot;logs/app-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout&gt;                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;            &lt;/PatternLayout&gt;            &lt;Policies&gt;                &lt;!-- 每天午夜滚动日志 --&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;                &lt;!-- 单个日志文件最大 100MB --&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- 最多保留 7 天的日志 --&gt;            &lt;DefaultRolloverStrategy max=&quot;7&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- Spring 框架日志控制 --&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- Hibernate 日志控制 --&gt;        &lt;Logger name=&quot;org.hibernate&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 项目代码日志 (包路径根据实际情况修改) --&gt;        &lt;Logger name=&quot;com.example&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Logger&gt;        &lt;!-- 根日志配置 --&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n配置模板3按环境区分配置（开发&#x2F;生产）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Properties&gt;        &lt;!-- 通过环境变量切换配置 --&gt;        &lt;Property name=&quot;log.level&quot;&gt;$&#123;sys:spring.profiles.active:-dev&#125;&lt;/Property&gt;        &lt;Property name=&quot;logPath&quot;&gt;logs&lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!-- 彩色控制台输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;cyan&#125; %highlight&#123;%-5level&#125; %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!-- 生产环境专用文件日志 --&gt;        &lt;RollingFile name=&quot;ProdFile&quot;                      fileName=&quot;$&#123;logPath&#125;/prod.log&quot;                     filePattern=&quot;$&#123;logPath&#125;/prod-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;500 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 开发环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;dev&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;DEBUG&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;        &lt;!-- 生产环境配置 --&gt;        &lt;If condition=&quot;$&#123;&#123;log.level&#125; == &#x27;prod&#x27;&#125;&quot;&gt;            &lt;Root level=&quot;WARN&quot;&gt;                &lt;AppenderRef ref=&quot;Console&quot;/&gt;                &lt;AppenderRef ref=&quot;ProdFile&quot;/&gt;            &lt;/Root&gt;        &lt;/If&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n配置模板4高性能异步日志\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;!-- 启用异步日志 --&gt;    &lt;AsyncLoggerConfig includeLocation=&quot;true&quot; /&gt;    &lt;Appenders&gt;        &lt;!-- 异步文件追加器 --&gt;        &lt;RollingRandomAccessFile name=&quot;AsyncFile&quot;                                fileName=&quot;logs/async.log&quot;                                filePattern=&quot;logs/async-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;ISO8601&#125; %-5level [%t] %logger&#123;36&#125; - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;200 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;!-- 控制台快速输出 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 异步记录器配置 --&gt;        &lt;AsyncLogger name=&quot;com.example&quot; level=&quot;INFO&quot; includeLocation=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/AsyncLogger&gt;        &lt;!-- SQL 日志单独记录 --&gt;        &lt;Logger name=&quot;jdbc.sqlonly&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;WARN&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;AsyncFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n模板5JSON 格式日志（适用于 ELK 收集）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;JsonLayout compact=&quot;true&quot; eventEol=&quot;true&quot;&gt;                &lt;KeyValuePair key=&quot;app&quot; value=&quot;MySpringApp&quot;/&gt;                &lt;KeyValuePair key=&quot;env&quot; value=&quot;$&#123;sys:spring.profiles.active&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/Console&gt;        &lt;File name=&quot;JsonFile&quot; fileName=&quot;logs/app.json&quot;&gt;            &lt;JsonLayout complete=&quot;false&quot; compact=&quot;false&quot;&gt;                &lt;KeyValuePair key=&quot;timestamp&quot; value=&quot;$$&#123;date:yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#125;&quot;/&gt;                &lt;KeyValuePair key=&quot;thread&quot; value=&quot;%t&quot;/&gt;                &lt;KeyValuePair key=&quot;level&quot; value=&quot;%level&quot;/&gt;                &lt;KeyValuePair key=&quot;logger&quot; value=&quot;%logger&quot;/&gt;                &lt;KeyValuePair key=&quot;message&quot; value=&quot;%message&quot;/&gt;                &lt;KeyValuePair key=&quot;exception&quot; value=&quot;%ex&#123;full&#125;&quot;/&gt;            &lt;/JsonLayout&gt;        &lt;/File&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- 结构化日志专用配置 --&gt;        &lt;Logger name=&quot;com.example.api&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;INFO&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;JsonFile&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n\n\n\n\n自定义配置文件夹位置log4j2默认在classpath下查找配置文件，可以修改配置文件的位置。在非web项目中：\npublic static void main(String[] args) throws IOException&#123;    File file = new File(&quot;D:/log4j2.xml&quot;);    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));    final ConfigurationSource source = new ConfigurationSource(in);    Configurator.initialize(null, source);     Logger logger = LogManager.getLogger(&quot;mylog&quot;);&#125;\n\n如果是web项目，在web.xml中添加：\n&lt;context-param&gt;    &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt;    &lt;param-value&gt;/WEB-INF/conf/log4j2.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;listener&gt;    &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n\n上述内容部分引用自  https://blog.csdn.net/pan_junbiao/article/details/104313938\n推荐教程\n推荐几篇我在网上找到的，写的很好的学习教程：\n学习资料1：详解log4j2(上) - 从基础到实战\n学习资料2：详解log4j2(下) - Async&#x2F;MongoDB&#x2F;Flume Appender 按日志级别区分文件输出\n学习资料3：SpringBoot—整合log4j2入门和log4j2.xml配置详解\n\n简单示例在项目的src根目录下的resources文件夹创建如下log4j2.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- log4j2 配置文件 --&gt;&lt;!-- 日志级别 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --&gt;&lt;configuration status=&quot;debug&quot;&gt;    &lt;!-- 自定义属性 --&gt;    &lt;Properties&gt;        &lt;!-- 日志格式(控制台) --&gt;        &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt;        &lt;!-- 日志格式(文件) --&gt;        &lt;Property name=&quot;pattern2&quot;&gt;            =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n        &lt;/Property&gt;        &lt;!-- 日志文件路径 --&gt;        &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt;    &lt;/Properties&gt;    &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot;                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;debug&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n日志功能测试类\npublic class TestUser &#123;    // 创建Logger    private Logger logger = LoggerFactory.getLogger(TestUser.class);    @Test    public void test() &#123;        // 加载spring配置文件，对象创建        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 获取创建的对象        User user = (User)context.getBean(&quot;user&quot;);        System.out.println(&quot;1:&quot; + user);    // 输出了对象的地址        // 使用对象调用方法完成测试        System.out.println(&quot;2:&quot;);        user.add();        // 手动写日志        logger.info(&quot;@执行调用成功&quot;);        // 追踪        logger.trace(&quot;trace level&quot;);        logger.debug(&quot;debug level&quot;);        logger.info(&quot;info level&quot;);        logger.warn(&quot;warn level&quot;);        logger.error(&quot;error level&quot;);    &#125;\n\n输出结果\n\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework","日志与调试"]},{"title":"Little Busters!EX游戏攻略","url":"/posts/28134.html","content":"请注意！本攻略转载自“LBEX中文化攻略Ver1.01”，侵删制作：抛雨挥虹  修订：中野梓喵 攻略：Pyhh\n游戏简介Little  Busters！EX（リトルバスターズ!エクスタシー）是VisualArt’s&#x2F;KEY继1999年的KANON，2000年的AIR，2004年的Clannad，2005年的智代after，2007年的Little Busters!之后，2008年7月25日发售的新作。Little Busters-EX和Little Busters!不同的地方在于Little Busters!里的配角二木佳奈多和笹濑川佐佐美升为可攻略女主角，另外再加一个可攻略新女主角朱鹭户沙耶，新的迷你游戏与音乐也是追加要素。一般把原本的Little Busters!称为“无印”(没有EX印记的意思)，而Little Busters！EX称为EX。\n游戏名称：リトルバスターズ!エクスタシー (Little Busters!EX)制作公司：VisualArt’s&#x2F;KEY\n游戏类型：AVG&#x2F;ADV\n年龄限制：18X游戏语音：全程语音\n故事简介：主角直枝理树与其青梅竹马的朋友棗恭介、棗铃、井之原真人、宫沢谦吾一起过着全寄宿制的高中生活。他们从小就结成了一个与恶势力作斗争，号称正义的使者的队伍，名为“Little Busters”。升上高中后，他们依然像以前一样过着快乐的每一天，理树也渴望与伙伴们的日子能够永远持续下去。一天，恭介提议要组成一个棒球队伍，像从前一样再热闹地玩一次。于是理树他们就开始寻找队员，挥洒着青春的光彩…\n\n注意事项1.是否开启棒球练习和战斗排位赛都不会对攻略有影响。如果在游戏中开启了则在攻略上没有「闲逛」「挑战」「到处走走」之类的选项均可自行选择。此攻略在战斗排位赛和棒球练习OFF的情况下制作。\n2.如想在第一次游戏就攻略沙耶,佳奈多,佐佐美,需在游戏起始询问「你知道世界的秘密吗?」选「是」；如果没玩过此游戏建议选「否」。\n3.如果在游戏起始询问「你知道世界的秘密吗?」选「否」，在攻略标上符号“★”的部分是必须完成Refrain之后才能攻略。\n4.用(   )括号括住的选项是在特定的情况下才会出现，如果在游戏时攻略上带(   )的选项没出现请忽略。\n5.攻略过的女主角再攻略一次时有些选项会变成灰色不能选择，不能再进入已攻略过的角色线(铃和小毬除外)，到Refrain之后会恢复。\n6.本攻略为最速攻略，只保证收集全部CG以及Scene，不保证剧情的100%达成，追求完整剧情的同学请自行探索。\n\n共通线5月14日Mon出声招呼不怎么好不怎么好\n不怎么好不怎么好\n\n5月15日Tue借去找她\n存档A就这样看着用别的笔记代替\n\n5月16日Wed追铃暂时看着赶紧找人接受去凑热闹结束算了帮忙找\n\n5月17日Thu找找看吧沉默去追铃暂时先看着去屋顶\n-——————————————————————————-\n5月18日Fri存档B我西园留在中庭她到底问了什么呢？西园去买果汁接受(感觉到了敌意)制止她\n-——————————————————————————-\n5月19日Sat去找铃站着看一会(还是很在意)\n(到屋外去)\n(帮忙)参与进去中庭(结束)帮忙\n\n5月20日Sun去\n(找人)恭介存档①普通的甜甜圈\n↓CG回收(如不需100%CG达成率可以忽略此步骤)※在此处选择不同的选项在24日活动室里小毬的小裤裤CG会有变化\n※在选择其中一个选项后继续剧情直到24日对应→CG回收的步骤\n→第1次读取存档①后选择\n有巧克力条纹的甜甜圈\n→第2次读取存档①后选择\n软软的草莓的甜甜圈\n-——————————————————————————-\n5月21日Mon(认真阅读)去买果汁去去找找看善意去听听她们在说什么铃\n\n5月22日Tue去叫她回教室存档②去中庭(劝谦吾)听听她们在说什么对着库特点头。去\n-——————————————————————————-\n5月23日Wed和库特打招呼上前打招呼存档③制止她存档④去屋顶买果汁去去听听在谈些什么和恭介他们一起吃算了去恭介的房间叫大家来\n\n5月24日Thu去买果汁帮忙回教室去听听她们在说些什么→CG回收\n※在活动室获取第1张小毬的CG后\n→第1次读取存档①\n※获取此处第2张小毬的CG后\n→第2次读取存档①※获取此处第3张小毬的CG后继续下面的剧情小毬库特\n-——————————————————————————-\n5月25日Fri就这样决定了\n(躲进去)谢绝结束\n(兔子)\n(乔)\n\n5月27日Sun存档⑤\n※共通线结束，开始角色线\n\n\n神北 小毬5月27日Sun那下个晴天再去不就行了吗\n\n5月28日Mon去屋顶●小毬给恭介发短信上网找找拉好询问关于梦的事情找来谷问\n存档⑥\n小毬TRUE END不直面这些不行小毬TRUE END\n\n小毬BAD END上述END后读取存档⑥把这些抛到脑后就好这就是守护了吧小毬BAD END\n\n能美 库特莉亚芙卡读取存档⑤\n5月27日Sun库特TRUE END要不要我来拿东西呢？铃的●库特莉亚芙卡叶留佳和西园去调查下关于昨晚的疑问存档⑦现在，就想回应她对她说，回去吧库特TRUE END\n\n上述END后 库特BAD END读取存档⑦现在就回应她这样好吗对她说，希望她能留下来库特BAD END\n★以下攻略必须完成Refrain线后开启\n\n库特TRUE END２ 以下攻略必须完成Refrain线后开启读取存档⑦现在，就想回应她听听库特自己希望怎么样小卖部\n查找语言学的书架※库特CG回收库特TRUE END２\n\n三枝 叶留佳读取存档②\n5月22日Tue去食堂我先叶留佳(去追恭介)听听她们在说什么对着库特摇头。去\n\n5月23日Wed进教室上前打招呼制止她去食堂帮忙买果汁去去听听在谈些什么\n和恭介他们一起吃算了去恭介的房间叫大家来\n\n5月24日Thu去买果汁目送她离去去找猫去听听她们在说些什么叶留佳美鱼\n\n5月25日Fri就这样决定了(躲进去)谢绝结束(乔)(外星人)\n\n5月28日Mon (叶留佳TRUE END)中庭的自动贩卖机去问问发生什么事了●叶留佳去委员会室询问真相去确认一下继续找叶留佳回答说看名单找到的有我明白了觉得可以蓝莓之类进一步的用手\n→CG回收\n※获取用手的CG后在菜单选择返回上一选择肢\n用嘴接收条件存档⑧不放弃叶留佳TRUE END\n\n叶留佳BAD END上述END后读取存档⑧放弃期望叶留佳BAD END\n\n来谷 唯湖读取存档②\n5月22日Tue去后院仔细听(去追恭介)听听她们在说什么对着库特摇头。去\n\n5月23日Wed进教室上前打招呼制止她去食堂拒绝买果汁去去听听在谈些什么(打扫一下吧)和恭介他们一起吃算了去恭介的房间叫大家来\n\n5月24日Thu去买果汁目送她离去回教室去听听她们在说些什么来谷库特\n-——————————————————————————-\n5月25日Fri就这样决定了(躲进去)拒绝结束\n\n5月28日Mon  （来谷TRUE END）不说●来谷死不承认\n存档⑨     \n↓下面3个选项的顺序可随意选择（包括人物也可以自由选择，叶留佳也可以作为选项之一）库特美鱼小毬\n↑上面3个选项的顺序可随意选择恭介就是前面就算是那样…老实回答来谷TRUE END\n★以下攻略必须完成Refrain线之后开启\n\n来谷TRUE END２以下攻略必须完成Refrain线之后开启\n读取存档⑨\n↓下面3个选项的顺序可随意选择，建议多S&#x2F;L几次选择不同的顺序会有很有趣的剧情\n库特美鱼\n小毬\n↑上面3个选项的顺序可随意选择（包括人物也可以自由选择，叶留佳也可以作为选项之一）\n恭介\n就是前面\n就算是那样…老实回答※下面的选项在三周目以后追加\n记得这个名字\n※来谷CG回收来谷TRUE END２\n\n西园 美鱼读取存档④\n5月23日Wed去中庭和真人玩去听听在谈些什么上前搭话去恭介的房间叫大家来\n-——————————————————————————-\n5月24日Thu去买果汁目送她离去去中庭回教室去听听她们在说些什么美鱼小毬\n\n5月25日Fri就这样决定了(跑过走廊)拒绝结束(兔子)(乔)\n\n5月27日Sun那下个晴天再去不就行了吗\n\n5月28日Mon （美鱼TRUE END）去中庭●美鱼\n↓下面5个选项的顺序可随意选择库特小毬铃恭介真人↑上面5个选项的顺序可随意选择美鸟存档⑩善意美鱼TRUE END\n\n美鱼TRUE END２上述END后\n读取存档⑩善意\n※美鱼Hscene美鱼TRUE END２\n读取存档⑩恶意\n※美鸟Hscene美鸟END\n\n棗 铃 BAD END※在第一次攻略 棗铃时无法避免BAD END\n※完成Refrain后再攻略此路线时将不会再出现BAD END而直接进入棗 铃END1\n\n读取存档③\n5月23日Wed继续帮忙和真人玩集中精神练习(继续用那种眼神盯着看)和恭介他们一起吃再来一碗去恭介的房间叫大家来\n\n5月24日Thu陪真人玩去找猫去练习铃库特\n\n5月25日Fri跟铃商量(躲进去)拒绝结束(外星人)(兔子)\n\n5月27日Sun （铃BAD END）那下个晴天再去不就行了吗●铃鼓励她举手铃BAD END\n※完成铃BAD END和小毬、库特、叶留佳、来谷、美鱼的END后将开启棗 铃END１\n\n棗 铃 END１※此路线必须先完成棗铃BAD END和小毬、库特、叶留佳、来谷、美鱼的END后才能开启\n※此路线为开启Refrain的最后条件，在标题画面选Start→New Game开始\n\n5月14日Mon就这样看着不怎么好不怎么好不怎么好不怎么好\n-——————————————————————————-\n5月15日Tue不借去找她出声招呼用别的笔记代替\n-——————————————————————————-\n5月16日Wed追铃搭话赶紧找人让他自己去结束算了不要管太多了\n\n5月17日Thu没有制止去追铃打个招呼不去屋顶\n\n5月18日Fri返回食堂和真人玩(感觉到了敌意)制止她\n\n5月19日Sat去找铃出声打招呼与真人玩老实待着还有作业…\n\n5月20日Sun去\n(找人)恭介软软的草莓的甜甜圈\n\n5月21日Mon和真人玩就此结束铃\n\n5月22日Thu和真人玩去后院劝谦吾认真练习去\n\n5月23日Wed上前打招呼\n存档⑪\n继续帮忙买果汁去集中精神练习继续用那种眼神盯着看打扫一下吧上前打招呼在一旁看着去恭介的房间叫大家来\n\n5月24日Thu陪真人玩去找猫去练习不阻止铃小毬\n\n5月25日Fri    （铃END１）跟铃商量(躲进去)拒绝结束(兔子)(乔)●铃鼓励她举手中庭去铃END１※ＥＤ后从此坚强地活下去\n\nRefrain※此路线必须完成铃END１后开启，在标题画面选择Refrain\n\n5月21日Mon靠头脑\n\n5月23日Wed问他\n\n5月24日Thu （铃END２）问他看看他想起来左手受伤了●修学旅行带着铃逃走铃END２\n\n铃TRUE END &amp; Little Busters!TRUE END※ＥＤ后\n●Epilogue不好●修学旅行冷静下来去折树枝之后再来去大家的包里找思考一下救恭介Little Busters!TRUE END\n铃TRUE END &amp; Little Busters!TRUE END\n\nLittle Busters! TRUE END的其他回收※完成一次Refrain线后在标题画面选择Start里Refrain\n\n5月21日Mon靠头脑\n\n5月23日Wed问他\n\n5月24日Thu问他看看他想起来左手受伤了●修学旅行\n带着铃逃走●Epilogue\n嗯\n※ＥＤ后不好\n●修学旅行冷静下来去折树枝之后再来去大家的包里找思考一下救恭介铃TRUE ENDLittle Busters! TRUE END\n\n笹濑川 佐佐美★此路线在游戏起始的询问「你知道世界的秘密吗?」\n→选「是」可以在一周目攻略\n→选「否」需要完成Refrain线后开启\n\n读取存档⑪\n5月23日Wed制止她拒绝买果汁去集中精神练习练习不管去食堂要紧算了去恭介的房间叫大家来\n\n5月24日Thu陪真人玩回教室去练习阻止她小毬美鱼\n\n5月25日Fri跟铃商量(躲进去)请他帮忙结束(外星人)(乔)\n\n10月23日Tue  （佐佐美TRUE END）脸被拧了●佐佐美猫食默不作声地拿出猫粮娶她库特存档C待在她身边我也…\n※佐佐美Hscene佐佐美TRUE END\n\n-——————————————————————————-\n佐佐美GOOD END上述END后读取存档C就这样让她一个人静一静还有其他的答案佐佐美GOOD END\n\n二木 佳奈多★此路线在游戏起始的询问「你知道世界的秘密吗?」\n→选「是」可以在一周目攻略\n→选「否」需要完成Refrain线后开启\n\n读取存档B\n5月18日Fri我小毬返回食堂差不多该走了和真人玩感觉到了好意制止她\n\n5月19日Sat不管她还是很在意到屋外去帮忙\n参与进去帮忙\n\n5月20日Sun去\n(找人)真人有巧克力条纹的甜甜圈\n\n5月21日Mon随便读一下到外面去呼吸新鲜空气就此结束叶留佳\n\n5月22日Tue平时的那家伙又出现了！回教室去后院去追恭介认真练习对着库特摇头。去\n\n5月23日Wed和库特打招呼去食堂帮忙买果汁去集中精神练习练习(打扫一下吧)去食堂要紧算了去恭介的房间叫大家来\n\n5月24日Thu去买果汁目送她离去去找猫去练习叶留佳库特\n\n5月25日Fri就这样决定了(跑过走廊)拒绝结束(兔子)(外星人)\n\n5月28日Mon （佳奈多TRUE END）去帮忙●佳奈多去宿舍会帮忙\n存档D不出去不出去不叫电影赠票问问关于泡菜的问题喜欢你\n※佳奈多Hscene佳奈多TRUE END\n\n佳奈多BAD END上述END后\n读取存档D\n出去\n佳奈多BAD END\n\n朱鹭户 沙耶(理树通常ver)\n★此路线在游戏起始的询问「你知道世界的秘密吗?」\n→选「是」可以在一周目攻略\n→选「否」需要完成Refrain线后开启\n※射击游戏OFF\n\n读取存档A\n5月15日Tue出声招呼\n※如果此处出现询问「想要能再次攻略沙耶线吗?」选「是」开启沙耶线去取返回学校\n\n5月16日Wed乞求帮助结束算了不好金字塔\n\n5月17日Thu没有\n制止\n不放弃\n\n5月18日Fri默不作声喜欢恭介\n\n※在迷宫部分，符号“&gt;”表示提示\n\n■地下１层&gt;右上方的房间我\n\n-——————————————————————————-\n■地下２层\n\n&gt;中间的房间往右转\n\n5月19日Sat确实也有感到有趣的时候\n\n■地下３层&gt;右上方尽头的房间老老实实地去石头(此处选项可随意选择)\n\n-——————————————————————————-\n■地下４层&gt;左上方3个房间中顶部的房间到房间外面去调查\n\n5月20日Sun想和朱鹭户同学待在一起问她喜欢什么样的男人有巧克力条纹的甜甜圈\n\n-——————————————————————————-\n■地下５层\n\n&gt;右下方的房间用冰来雕刻出这条龙的形象更加努力更加努力\n\n■地下６层\n&gt;其中一边黄色地点→另一边黄色地点→红色点的房间重新看一次这层的地图王\n\\\n&gt;返回其中一边黄色地点&gt;打通地图成“王”字&gt;右上方的空房间打开这个房间的棺材去找木乃伊\n&gt;在各个房间寻找\n\n5月21日Mon(随便读一下)库特库特我和恭介在交往中真人就此结束\n\n5月22日Tue说去后院去追恭介握她的手\n\n■地下７层\n\n&gt;把迷宫全部走遍试着碰她的手\n&gt;在迷宫内侧移动试着抚摸她的头\n&gt;回到起点的房间&gt;按一笔书规则在迷宫内侧走“８”字\n\n■地下８层\n\n&gt;右下方尽头\n\n■地下８层\n&gt;右下方尽头开枪\n&gt;在各处寻找\n\n■重播\n※为完成此路线必须按步骤GAME OVER数次\n※每次GAME OVER选择REPLAY继续游戏\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\n\n存档E调查地板调查后面的黑板\n\n■地下１层\n&gt;绿色的房间拉绳索\n左\n&gt;回到绿色的房间\n拉绳索\n正中\n&gt;回到绿色的房间\n拉绳索\n右\n&gt;回到绿色的房间\n问问理树的意见\n\n■地下２层\n&gt;黄色的房间\n听听理树的意见\n&gt;绿色的房间试试看&gt;回到绿色的房间\n&gt;再回到绿色的房间跳进去\n\n■地下３层&gt;绿色的房间飞身退避&gt;回到绿色的房间登上石像\n\n■地下４层&gt;绿色的房间\n进入沸水里还是要进去&gt;红色的房间→绿色的房间\n\n■地下５层\n&gt;红色的房间去弄清楚&gt;绿色的房间寻找别的方法&gt;红色的房间脱掉衣服连内裤都脱掉&gt;绿色的房间\n\n■地下６层\n\n&gt;经过4个房间后向迷宫正中心移动\n\n&gt;往黄色的地点进行爆破→绿色的房间→红色的房间移动\n&gt;绿色的房间打开这个房间的棺材\n\n■地下７层&gt;在迷宫内侧走“８”字问问理树君的意见\n\n&gt;在迷宫内侧走“５”字\n\n■地下８层&gt;右下方尽头\n\n※在标题画面选择Start里New Game继续\n5月14日Mon出声招呼可以\n(可以)\n(可以)\n(可以)\n\n5月15日Tue不借不管她去取返回学校\n\n5月16日Wed自己想办法上去结束算了不好\n\n5月17日Thu  (沙耶END)取下来没有制止沙耶END\n\n※如果之前未攻略过沙耶线，此路线结束后请攻略朱鹭户沙耶(笨蛋理树ver)，回收CG和部分内容会有变化。\n朱鹭户 沙耶(笨蛋理树ver)①★此路线在游戏起始的询问「你知道世界的秘密吗?」\n→选「是」可以在一周目攻略\n→选「否」需要完成Refrain线后开启\n\n读取存档A\n5月15日Tue\n出声招呼\n※如果此处出现询问「想要能再次攻略沙耶线吗?」选「是」开启沙耶线去取返回学校\n-——————————————————————————-\n5月16日Wed乞求帮助结束算了我会逃掉的和她合作太阳塔罗森\nFamima\n-——————————————————————————-\n5月17日Thu没有沉默\n※射击游戏OFF不放弃\n-——————————————————————————-\n5月18日Fri呼喊呼唤爱对她说谎最喜欢了绝对是恭介\n-——————————————————————————-\n※在迷宫部分，符号“&gt;”表示提示\n-——————————————————————————-\n■地下１层&gt;先去岔路上方的房间&gt;之后进入岔路右边的房间朱鹭户坚持要跳\n-——————————————————————————-\n■地下２层&gt;先走一遍迷宫外侧&gt;最后进入中间的房间往左转回转一圈\n-——————————————————————————-\n5月19日Sat不比十分有趣\n-——————————————————————————-\n■地下３层&gt;为了把地图全部发现在各个地方走一遍&gt;反复5次左右进入有陷阱的房间&gt;最后进入右上方尽头的房间让朱鹭户去布(此处选项可随意选择)\n-——————————————————————————-\n■地下４层&gt;为把地图全部发现在各个地方走一遍&gt;最后进入左上方3个房间中顶部的房间到房间外面去调查\n-——————————————————————————-\n5月20日Sun想和朱鹭户同学待在一起问她喜欢什么样的男人其实我年纪比你大啊？\n(试一下)\n有巧克力条纹的甜甜圈\n-——————————————————————————-\n■地下５层&gt;为把地图全部发现在各个地方走一遍&gt;最后进入右下方的房间边赏龙边喝冰镇酒更加努力更加努力\n-——————————————————————————-\n■地下６层&gt;其中一边黄色地点→另一边黄色地点→红色点的房间重新看一次这层的地图死&gt;返回其中一边黄色地点\n&gt;打通地图成“王”字→右边的空房间→右边另一间空房间打开这个房间的棺材去找木乃伊&gt;在各个房间寻找\n-——————————————————————————-\n5月21日Mon(随便读一下)西园铃我和恭介在交往中来谷西园就此结束\n-——————————————————————————-\n5月22日Tue蒙混过去去食堂最后再去去追恭介握她的手\n-——————————————————————————-\n■地下７层&gt;把迷宫全部走遍试试碰她的手&gt;在迷宫内侧移动试试抚摸她的头\n&gt;回到起点的房间\n&gt;反复走错路6次以上(例如向前走一步然后向后走一步)&gt;按一笔书规则在迷宫内侧走“８”字\n-——————————————————————————-\n■地下８层&gt;把迷宫全部走一遍&gt;右下方尽头\n-——————————————————————————-\n■地下８层&gt;右下方尽头开枪&gt;在各处寻找\n-——————————————————————————-\n●重播※为完成此路线必须按步骤GAME OVER数次\n※每次GAME OVER选择REPLAY继续游戏\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\n-——————————————————————————-\t\t\t\t\t\t\t\t\n​\t\t\t\t\t\t\t\t朱鹭户 沙耶(笨蛋理树ver)②\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n​\t\t\t\t\t\t\t\t存档E移动桌子试着移动桌子调查后面的黑板\n-——————————————————————————-\n■地下１层&gt;重复3次进入红色的房间(进入房间REPLAY后再返回此房间如此类推)\n&gt;之后进入绿色的房间拉绳索\n左\n&gt;回到绿色的房间\n拉绳索\n正中\n&gt;回到绿色的房间\n拉绳索\n右\n&gt;回到绿色的房间\n问问理树的意见\n-——————————————————————————-\n■地下２层&gt;重复3次进入红色的房间&gt;之后进入绿色的房间还是自己上&gt;回到绿色的房间紧抱住把手&gt;回到绿色的房间\n-——————————————————————————-\n■地下３层&gt;按黄色的路线移动(为避免进入绿色的房间)&gt;重复3次进入红色的房间&gt;之后进入绿色的房间用枪应战&gt;回到绿色的房间&gt;再回到绿色的房间拿剑&gt;回到绿色的房间\n-——————————————————————————-\n■地下４层&gt;先进入绿色的房间进入沸水里还是要进去&gt;回到绿色的房间想别的办法&gt;红色的房间&gt;逃脱之后再回到红色的房间不相信&gt;回到红色的房间相信理树君&gt;逃脱后进入绿色的房间\n-——————————————————————————-\n■地下５层&gt;红色的房间去弄清楚&gt;之后绿色的房间用冰雕出龙&gt;红色的房间裸足下去&gt;回到红色的房间脱掉衣服不要越过这条线&gt;回到红色的房间脱掉衣服&gt;绿色的房间\n-——————————————————————————-\n■地下６层&gt;经过4个房间后向迷宫正中心移动&gt;往黄色的地点进行爆破→绿色的房间→红色的房间打开这个房间的棺材&gt;往黄色的地点移动→绿色的房间打开这个房间的棺材\n-——————————————————————————-\n■地下７层&gt;在迷宫内侧走“８”字问问理树君的意见&gt;在迷宫内侧走“５”字\n-——————————————————————————-\n■地下８层&gt;右下方尽头\n-——————————————————————————-\n※在标题画面选择Start里New Game继续\n5月14日Mon出声招呼可以(可以)(可以)(可以)\n-——————————————————————————-\n5月15日Tue不借不管她去取返回校舍\n-——————————————————————————-\n5月16日Wed自己想办法上去结束算了不怎么好\n-——————————————————————————-\n5月17日Thu存档F不取下来没有制止沙耶BAD END\n-——————————————————————————-\n※如果在Refrain之前读取存档F取下来没有制止沙耶TRUE END\n※如果在Refrain之后\n读取存档F取下来没有就这么等待着\n存档G是沙耶同学赢了制止沙耶TRUE END\n-——————————————————————————-\n读取存档G是我赢了沙耶CG回收\n-——————————————————————————-\n※这样能避免一部分CG和选项不出现\n情况是在完成Refrain后而且是笨蛋理树，需要笨蛋沙耶推进。\n如果按照上述攻略到Refrain后再来攻略的话将会全部出现\n​\t\t\t\t\t\t\t\tSchoolRevo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n​\t\t\t\t\t\t\t\t※此路线必须完成一次沙耶END后才能开启\n-——————————————————————————-\n ●重播※为完成此路线必须按步骤GAME OVER数次\n※每次GAME OVER选择REPLAY继续游戏\n※地图中红色的房间为陷阱，绿色的房间为陷阱&amp;出口，黄色为其他情况\n-——————————————————————————-\n读取存档E移动桌子试着移动桌子调查后面的黑板\n-——————————————————————————-\n■地下１层\n※必须开启射击游戏，难度自行选择&gt;重复3次以上进入红色的房间(进入房间后REPLAY再返回此房间如此类推)\n※直到沙耶说「搞什么，谁会喜欢啊！！」为止\n&gt;绿色的房间拉绳索\n左\n&gt;回到绿色的房间\n拉绳索\n正中\n&gt;回到绿色的房间\n拉绳索\n右\n&gt;回到绿色的房间\n问问理树的意见\n-——————————————————————————-\n■地下２层&gt;重复3次以上进入红色的房间※直到沙耶说「很好，来吧—！！ 毒蛇们、COME ON–！！」为止&gt;绿色的房间还是自己上&gt;回到绿色的房间紧抱住把手&gt;回到绿色的房间\n-——————————————————————————-\n■地下３层&gt;按黄色的路线移动(为避免进入绿色的房间)&gt;重复3次以上进入红色的房间※直到沙耶说「喂，来吧—-！！」为止&gt;绿色的房间用枪应战&gt;回到绿色的房间&gt;再回到绿色的房间拿剑&gt;回到绿色的房间\n-——————————————————————————-\n■地下４层&gt;绿色的房间进入沸水里还是要进去&gt;回到绿色的房间进入沸水里还是要进去&gt;回到绿色的房间进入沸水里还是要进去※看到沙耶说「开水、我–来–啦–！！」为止&gt;红色的房间&gt;逃脱之后再回到红色的房间不相信&gt;回到红色的房间不相信&gt;回到红色的房间不相信※看到沙耶说「水、COME ON—-！」为止&gt;回到红色的房间相信理树君&gt;绿色的房间\n-——————————————————————————-\n■地下５层&gt;红色的房间去弄清楚&gt;绿色的房间用冰雕出龙&gt;红色的房间裸足下去&gt;回到红色的房间裸足下去\n&gt;回到红色的房间裸足下去※看到沙耶说「哟嚯———–…」为止\n&gt;回到红色的房间脱掉衣服不要越过这条线&gt;回到红色的房间脱掉衣服&gt;绿色的房间\n-——————————————————————————-\n■地下６层&gt;经过4个房间后向迷宫正中心移动&gt;往黄色的地点进行爆破→绿色的房间→红色的房间打开这个房间的棺材&gt;回到红色的房间打开这个房间的棺材&gt;回到红色的房间打开这个房间的棺材※看到沙耶说「我来送死了！ 嘿，陷阱COME ON—-！！」为止&gt;绿色的房间打开这个房间的棺材\n-——————————————————————————-\n■地下７层&gt;现在！！必须要做的就是让沙耶不断去被镭射光XXOO (向前走一步然后往后走一步即可实现)※直到沙耶说「很好，镭射光，COME ON—！」\n※看屏幕出现沙耶M觉醒,能发动Ecstasy模式于是我们的革命战争开始了！！&gt;在迷宫内侧走“８”字问问理树君的意见\n-——————————————————————————-\n■地下８层&gt;右下方的路口\n※在与时风战斗时Ecstasy模式发动后并不能够无限回复生命，被击中6次就会失败，建议在战斗前存档\n当受到几次伤害之后Ecstasy模式发动，打败时风瞬SchoolRevo END\n​\t\t\t\t\t\t\t\t真人 肌肉\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n​\t\t\t\t\t\t\t\t※此路线即使不攻略也不会对其他路线有影响★此路线在游戏起始的询问「你知道世界的秘密吗?」\n→选「是」可以在一周目攻略\n→选「否」需要完成Refrain线后开启\n-——————————————————————————-\n5月14日Mon就这样看着不怎么好不怎么好不怎么好不怎么好\n-——————————————————————————-\n5月15日Tue不借不管她用别的笔记代替\n-——————————————————————————-\n5月16日Wed\n用手机读取QR code让他自己去结束算了帮忙找\n-——————————————————————————-\n5月17日Thu没有沉默\n进入手机网站\n接着读吧(×133)(去追铃)(就这样看着)去屋顶\n-——————————————————————————-\n5月18日Fri我西园(留在中庭)她到底问了什么呢？西园去食堂和真人玩(感觉到了敌意)制止她\n-——————————————————————————-\n5月19日Sat(不看)与真人玩和真人玩帮忙\n-——————————————————————————-\n5月20日Sun去\n(找人)真人普通的甜甜圈\n-——————————————————————————-\n5月21日Mon(随便读一下)和真人玩(去练习)就此结束真人铃\n-——————————————————————————-\n5月22日Tue清扫用具的整理和真人玩去食堂我先真人去追恭介听听她们在说什么对着库特点头.和恭介他们一起玩\n真的\n-——————————————————————————-\n5月23日Wed和库特打招呼\n去食堂拒绝和真人玩去听听在谈些什么打扫一下吧上前搭话去恭介的房间叫大家来\n-——————————————————————————-\n5月24日Thu陪真人玩回教室去听听她们在说些什么库特美鱼\n-——————————————————————————-\n5月25日Fri就这样决定了(躲进去)拒绝结束(兔子)(乔)\n-——————————————————————————-\n5月27日Sun要不要我来拿东西呢？真人的\n我和真人(去调查下关于昨晚的疑问)肌肉肌肉肌肉就算如此还是肌肉真人 肌肉END\n​\t\t\t\t\t\t\t\t游戏攻略常见问题\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n​\t\t\t\t\t\t\t\t■Ｑ.看不到库特线的TRUE END2。□Ａ.在游戏起始的讯问「你知道世界的秘密吗?」选「是」在完成库特TRUE END1和BAD END后会出现\n​      追加选项。选「否」需要完成库特TRUE END1和BAD END以及Refrain后会出现追加选项。\n■Ｑ.攻略沙耶线到后期直接回到了标题画面。□Ａ.从最初遇见沙耶处继续攻略会有不同剧情。\n■Ｑ.无法取回沙耶剩余的CG和Hscene。□Ａ.走笨蛋理树线的话可以回收不足的CG。\n​      在完成因各种陷阱死去的沙耶线路重播(Replay)后，再一次进入沙耶线会追加选项。\n■Ｑ.无法再次进入朱鹭户沙耶线。□Ａ.Clear所有角色(包括EX追加角色)并完成Refrain线，之后选择“New Game”到5月15日会追加\n​    「想要能再次攻略沙耶线吗?」的询问。\n■Ｑ.无法取回佳奈多的剩余CG。□Ａ.在叶留佳线获得。\n■Ｑ.来谷的CG没有填满。□Ａ.请在Refrain之后再一次攻略来谷。\n■Ｑ.没有铃的Hscene啊。□Ａ.Refrain完后再开一次Refrain，这次记得向铃求婚哦。\n■Ｑ.小毬线Clear之后还差一张CG。□Ａ.铃END1之后，22日的选项选择「去」女生宿舍。     ※如果在“知道世界的秘密”的情况下2周目回收可能。\n■Ｑ.小毬不同种类的内裤CG回收不能。□Ａ.20日的甜甜圈选项会影响24日小毬CG的变化。请按攻略走3次。\n■Ｑ.找不到佐佐美的Hscene。□Ａ.进入路线以后请按攻略进行。     (猫食→默不作声地拿出猫粮→娶她→待在她身边→我也…)\n■Ｑ.虽然看到了美鸟的Hscene，但是没看到美鱼的。(世界的秘密：不知道)□Ａ.请在最后的选项之前「善意or恶意」存档      美鱼END之后读取存档选择「善意」。      ※(世界的秘密：知道)只需一次就能看到Hscene。\n■Ｑ.怎样决定攻略的顺序才好呢？□Ａ.※不知道世界的秘密的情况下，推荐以下攻略顺序     共通线→(铃BAD or小毬or库特or叶留佳or来谷or西园)→铃END1→Refrain→\n​     (库特TRUE2＆来谷TRUE2 or Refrain)or佐佐美or佳奈多or沙耶\n　\n   ※知道世界的秘密的情况下(沙耶、佐佐美、佳奈多在Refrain前后都可以攻略)\n​     共通线→沙耶or佳奈多or佐佐美or(铃BAD or小毬or库特or叶留佳or来谷or西园)→\n​     铃END1→Refrain→(来谷TRUE2 or Refrain)→沙耶(为了回收不同的CG)\n","categories":["其他","galgame相关","攻略"],"tags":["galgame","其他","攻略","杂项"]},{"title":"Servlet与http","url":"/posts/62509.html","content":"软件架构与网络通信软件架构：\n\nB&#x2F;S：浏览器端-服务器端（JavaEE体系）  客户端不用再去开发，开发更加快速\nC&#x2F;S：客户端-服务器端\n\n资源分类：\n\n静态资源：所有用户访问后得到的结果是一样的，称为静态资源\n如html css js\n\n\n动态资源：每个用户访问相同资源后，得到的结构可能不一样，称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器\n如 servlet php jsp\n\n\n\n网络通信三要素：\n\nIP：电子设备在网络中的唯一标识\n端口:应用程序在计算机中的唯一标识\n传输协议：规定了通信的规则\n基础协议：tcp udp\n\n\n\n\n\nhttp概述http：超文本传输协议\n传输协议：定义了客户端和服务器端通信的时候发送数据的格式\n特点：\n\n基于TCP&#x2F;IP的高级协议\n默认端口号是80\n基于请求响应模型，一次请求对应一次响应\n无状态的，每次请求之间相互独立\n\nhttp的请求消息和请求行请求消息数据格式：\n请求行\n明确请求的基本信息（操作类型、目标资源、协议版本）\n请求方式 请求url 请求协议&#x2F;版本    \n请求方法：\n常见方法（Servlet 中常用）\n\n\n\n\n方法\n含义\n特点\n是否有请求体\n\n\n\nGET\n请求获取资源\n请求参数在请求行，数据通过 URL 传递，明文可见，长度有限制（浏览器通常限制 8KB）\n无\n\n\nPOST\n提交数据（如表单）\n数据放在请求体中，适合传输大量数据，安全性较高\n有\n\n\nPUT\n更新资源（全量更新）\n需指定资源完整路径，幂等性（多次操作结果一致）\n有\n\n\nDELETE\n删除资源\n指定 URL 对应的资源，幂等性\n无\n\n\nHEAD\n获取资源头部信息\n仅返回响应头，不返回响应体，用于快速检查资源是否存在\n无\n\n\n请求url：协议:&#x2F;&#x2F;主机:端口&#x2F;路径?查询参数#锚点\n\n协议：固定为http或https（如http://）\n\n主机：服务器域名（如www.example.com）或 IP 地址（如192.168.1.1）\n\n端口：可选，默认80（HTTP）或443（HTTPS），如8080\n\n路径：资源在服务器上的路径（如/user/login）\n\n查询参数：可选，格式为key=value&amp;key2=value2，通过?与路径分隔\n\n锚点：客户端浏览器使用，用于定位页面内元素，服务器不处理\nServlet服务器接收的 URL 部分：不包含锚点，仅到查询参数为止\n\n\n\n请求头\n携带请求的附加信息（客户端环境、请求参数、安全信息等）\n请求头名称：请求头值\n通用头字段：\n\n\n\n字段名\n含义\n示例\nServlet 获取方法\n\n\n\nHost\n目标服务器的主机和端口（必传）\nlocalhost:8080\nrequest.getHeader(&quot;Host&quot;)\n\n\nUser-Agent\n客户端信息（浏览器 &#x2F; 操作系统）\nMozilla/5.0 (Windows NT 10.0) Chrome/110.0.0.0\nrequest.getHeader(&quot;User-Agent&quot;)\n\n\nReferer\n来源页面 URL（防盗链，统计）\nhttp://example.com/login.html\nrequest.getHeader(&quot;Referer&quot;)\n\n\nAccept\n客户端接受的响应内容类型\ntext/html,application/json\nrequest.getHeader(&quot;Accept&quot;)\n\n\n可以在服务器端获取User-Agent该头的信息，解决浏览器端兼容性问题\n与请求体相关的头字段：\n\n\n\n字段名\n含义\n示例\nServlet 关联\n\n\n\nContent-Type\n请求体的数据格式和编码\napplication/x-www-form-urlencoded; charset=UTF-8（表单数据） multipart/form-data; boundary=xxx（文件上传）\n通过request.getContentType()获取\n\n\nContent-Length\n请求体的字节长度\n1024\n通过request.getContentLength()获取\n\n\n\n请求空行\n作为请求头和请求体的分隔符，必须存在且仅包含一个换行符（\\r\\n）\n\n请求体\n封装POST请求消息的请求体的，GET请求没有请求体\n空行之后（可选，非必须），存放请求的具体数据（如表单提交的参数、上传文件内容等）\n\n数据格式\n\n\napplication&#x2F;x-www-form-urlencoded：表单默认格式，键值对编码为key=value&amp;key2=value2，不支持文件上传\nmultipart&#x2F;form-data：文件上传专用格式，通过boundary分隔不同字段，支持二进制数据\napplication&#x2F;json：JSON 格式数据，需在Content-Type头中声明\n\n\nServlet 中获取请求体数据\n\n\n普通表单数据：通过request.getParameter(&quot;参数名&quot;)直接获取（自动解码）\nJSON 数据：需通过request.getReader()或request.getInputStream()手动解析\n文件上传：需使用MultipartHttpServletRequest（需配置MultipartResolver）\n\n\n\n响应消息数据格式\nRequest请求原理\n\nrequest对象和response对象的原理：\n由服务器创建，我们仅使用\nrequest对象获取请求消息，response对象来设置响应消息\n\nrequest对象继承体系的结构Servlet中的HttpServletRequest对象是处理HTTP请求的核心接口\n基本继承层次：\njavax.servlet.ServletRequest (接口)       ↑javax.servlet.http.HttpServletRequest (接口)       ↑org.apache.catalina.connector.RequestFacade (Tomcat实现类)\n\nServletRequest接口这是最基础的请求接口，定义了通用的请求方法，不限于HTTP协议：\n\n核心方法：\ngetParameter(String name) - 获取请求参数\ngetAttribute(String name) - 获取请求属性\nsetAttribute(String name, Object o) - 设置请求属性\ngetInputStream() - 获取输入流\ngetReader() - 获取字符读取器\ngetContentType() - 获取内容类型\ngetLocalAddr() - 获取服务器IP地址\n\n\n\nHttpServletRequest接口继承自ServletResponse接口，专门用来封装HTTP响应消息。  由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。：\n\nHTTP相关方法：\ngetHeader(String name) - 获取请求头\ngetMethod() - 获取HTTP方法(GET&#x2F;POST等)\ngetCookies() - 返回一个cookie对象数组\ngetSession() - 返回与这个请求相关的会话对象\ngetRequestURI() - 获取请求URI\ngetQueryString() - 返回请求URL中的查询字符串\ngetContextPath() - 返回请求上下文的请求URI部分\ngetServletPath() - 获取Servlet路径\n\n\n\n实现类 (以Tomcat为例)Tomcat中的具体实现类结构：\nRequest (org.apache.catalina.connector.Request)       ↑RequestFacade (org.apache.catalina.connector.RequestFacade)\n\n\nRequest：Tomcat内部的实际实现类，包含大量内部方法\nRequestFacade：提供给Servlet开发者的门面类，遵循门面模式，隐藏了内部复杂实现\n\njavax.servlet.http包内容HttpServlet是由GenericServlet抽象类扩展而来的，HttpServlet抽象类的声明如下所示：\npublic abstract class HttpServlet extends GenericServlet implements Serializable \n\nHttpServlet之所以运用广泛的另一个原因是现在大部分的应用程序都要与HTTP结合起来使用。这意味着我们可以利用HTTP的特性完成更多更强大的任务。Javax.servlet.http中的许多类型都覆盖了Javax.servlet中的类型。\n\n\nHttpServlet抽象类HttpServlet 抽象类是继承于 GenericServlet 抽象类而来的。\n使用 HttpServlet 抽象类时，还需要借助分别代表 Servlet 请求和 Servlet 响应的 HttpServletRequest 和 HttpServletResponse 对象。\nHttpServletRequest 接口扩展于 javax.servlet.ServletRequest 接口，HttpServletResponse 接口扩展于javax.servlet.servletResponse 接口。\npublic interface HttpServletRequest extends ServletRequest\n\npublic interface HttpServletResponse extends ServletResponse\n\n\n\n其中，HttpServlet 抽象类覆盖了 GenericServlet 抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法。\n这是 GenericServlet 抽象类中定义的service方法：\npublic abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\nHttpServlet 实现的这个 service 方法\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    HttpServletRequest request;    HttpServletResponse response;    try &#123;        request = (HttpServletRequest)req;        response = (HttpServletResponse)res;    &#125; catch (ClassCastException var6) &#123;        throw new ServletException(&quot;non-HTTP request or response&quot;);    &#125;     this.service(request, response);&#125;\n\nHttpServlet 中的 service 方法把接收到的 ServletRequsest 类型的对象转换成了 HttpServletRequest 类型的对象，把ServletResponse 类型的对象转换成了 HttpServletResponse 类型的对象。  \n之所以能够这样强制的转换，是因为在调用Servlet的Service方法时，Servlet容器总会传入一个 HttpServletRequest 对象和 HttpServletResponse 对象，预备使用HTTP。因此，转换类型当然不会出错了。\n转换之后，service方法把两个转换后的对象传入了另一个service方法\n// 参数是HttpServletRequest对象和HttpServletResponse对象，刚好接收了上一个service方法传过来的两个对象protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String method = req.getMethod();    long lastModified;    // 解析HttpServletRequest中的方法参数，并调用以下方法之一，每一种方法都表示一个Http方法。doGet和doPost是最常用的    if (method.equals(&quot;GET&quot;)) &#123;        lastModified = this.getLastModified(req);        if (lastModified == -1L) &#123;            this.doGet(req, resp);        &#125; else &#123;            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);            if (ifModifiedSince &lt; lastModified) &#123;                this.maybeSetLastModified(resp, lastModified);                this.doGet(req, resp);            &#125; else &#123;                resp.setStatus(304);            &#125;        &#125;    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;        lastModified = this.getLastModified(req);        this.maybeSetLastModified(resp, lastModified);        this.doHead(req, resp);    &#125; else if (method.equals(&quot;POST&quot;)) &#123;        this.doPost(req, resp);    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;        this.doPut(req, resp);    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;        this.doDelete(req, resp);    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;        this.doOptions(req, resp);    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;        this.doTrace(req, resp);    &#125; else &#123;        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);        Object[] errArgs = new Object[]&#123;method&#125;;        errMsg = MessageFormat.format(errMsg, errArgs);        resp.sendError(501, errMsg);    &#125;&#125;\n\n\n\n\n\n通过request获取内容通过request获得请求行请求行包含HTTP方法、URI和协议版本，例如：GET /test?name=value HTTP/1.1\n// 获取请求方法(GET/POST/PUT/DELETE等)String method = request.getMethod();// 获取请求URL(不包含协议、域名和端口)String requestURL = request.getRequestURL().toString(); // 获取请求URI(相对于Context Path的部分)String requestURI = request.getRequestURI();// 获取查询字符串(问号后面的部分)String queryString = request.getQueryString();// 获取协议和版本String protocol = request.getProtocol(); // HTTP/1.1// 获取上下文路径(web应用的根路径)String contextPath = request.getContextPath();// 获取Servlet路径String servletPath = request.getServletPath();\n\n获取请求头信息请求头包含了客户端环境和请求的附加信息\n// 获取指定请求头的值String userAgent = request.getHeader(&quot;User-Agent&quot;);String accept = request.getHeader(&quot;Accept&quot;);// 获取所有请求头名称的枚举Enumeration&lt;String&gt; headerNames = request.getHeaderNames();// 遍历所有请求头while(headerNames.hasMoreElements()) &#123;    String name = headerNames.nextElement();    String value = request.getHeader(name);    System.out.println(name + &quot;: &quot; + value);&#125;// 获取Int类型的请求头值int contentLength = request.getIntHeader(&quot;Content-Length&quot;);// 获取日期类型的请求头值long date = request.getDateHeader(&quot;If-Modified-Since&quot;);// 获取多值请求头Enumeration&lt;String&gt; languages = request.getHeaders(&quot;Accept-Language&quot;);\n\n获取请求体请求体主要出现在POST、PUT等请求中，包含客户端发送的数据\n获取表单数据// 获取单个表单参数值String username = request.getParameter(&quot;username&quot;);// 获取多值参数(如复选框)String[] hobbies = request.getParameterValues(&quot;hobby&quot;);// 获取所有参数名的枚举Enumeration&lt;String&gt; paramNames = request.getParameterNames();// 获取所有参数的MapMap&lt;String, String[]&gt; paramMap = request.getParameterMap();// 遍历所有参数paramMap.forEach((key, values) -&gt; &#123;    System.out.print(key + &quot;: &quot;);    for(String value : values) &#123;        System.out.print(value + &quot; &quot;);    &#125;    System.out.println();&#125;);\n\n获取原始请求体// 获取输入流读取原始数据ServletInputStream inputStream = request.getInputStream();BufferedReader reader = request.getReader();// 示例：读取JSON请求体StringBuilder sb = new StringBuilder();String line;while ((line = reader.readLine()) != null) &#123;    sb.append(line);&#125;String jsonBody = sb.toString();\n\n获取其他请求信息// 获取客户端IP地址String clientIP = request.getRemoteAddr();// 获取客户端主机名String clientHost = request.getRemoteHost();// 获取客户端端口int clientPort = request.getRemotePort();// 获取服务器信息String serverName = request.getServerName();int serverPort = request.getServerPort();// 获取请求的会话HttpSession session = request.getSession();// 获取Cookie数组Cookie[] cookies = request.getCookies();// 获取内容类型String contentType = request.getContentType();// 获取字符编码String encoding = request.getCharacterEncoding();// 设置字符编码(处理中文乱码)request.setCharacterEncoding(&quot;UTF-8&quot;);\n\n示例处理JSON请求\nprotected void doPost(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 设置字符编码    request.setCharacterEncoding(&quot;UTF-8&quot;);        // 读取JSON请求体    StringBuilder sb = new StringBuilder();    try (BufferedReader reader = request.getReader()) &#123;        String line;        while ((line = reader.readLine()) != null) &#123;            sb.append(line);        &#125;    &#125;        // 解析JSON    JSONObject json = new JSONObject(sb.toString());    String username = json.getString(&quot;username&quot;);    // 处理业务逻辑...&#125;\n\nRequest乱码问题的解决方法Servlet默认编码是ISO-8559-1，需要手动修改编码方式为UTF-8编码\nrequest.setCharacterEncoding(&quot;UTF-8&quot;);  // 解决post提交方式的乱码parameter = newString(parameter.getbytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);    //  解决get提交的方式的乱码\n\n\n\n\n\n通过Response设置响应HttpServletResponse对象是Servlet中用于构建HTTP响应的核心接口，它提供了丰富的方法来设置响应状态、响应头和响应体\n设置响应状态设置状态码// 设置成功状态码(200)response.setStatus(HttpServletResponse.SC_OK);// 设置404未找到response.setStatus(HttpServletResponse.SC_NOT_FOUND);// 设置500服务器错误response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);// 设置302重定向(已废弃，推荐使用sendRedirect)response.setStatus(HttpServletResponse.SC_FOUND);\n\n设置状态码和错误消息// 设置状态码和自定义错误消息response.sendError(HttpServletResponse.SC_NOT_FOUND, &quot;资源不存在&quot;);// 仅设置状态码(使用默认错误消息)response.sendError(HttpServletResponse.SC_FORBIDDEN);\n\n设置响应头基本响应头设置// 设置单个响应头response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 添加响应头(可设置多个同名头)response.addHeader(&quot;Set-Cookie&quot;, &quot;name=value&quot;);// 设置Int类型响应头response.setIntHeader(&quot;Content-Length&quot;, 1024);// 设置日期类型响应头response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis() + 3600000);\n\n常用响应头快捷方法// 设置内容类型和字符编码(等同于setHeader(&quot;Content-Type&quot;, ...))response.setContentType(&quot;text/html;charset=UTF-8&quot;);// 设置内容长度(等同于setIntHeader(&quot;Content-Length&quot;, ...))response.setContentLength(1024);// 设置字符编码(单独设置)response.setCharacterEncoding(&quot;UTF-8&quot;);\n\n设置响应体获取输出流// 获取字节输出流(用于二进制数据)// 获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。ServletOutputStream outputStream = response.getOutputStream();// 获取字符输出流(用于文本数据)// 获得字符流，通过字符流的write(String s)方法可以将字符串设置到response缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。PrintWriter writer = response.getWriter();\n\n注意，其中response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。\n重定向相关302重定向// 简单重定向(相对路径)response.sendRedirect(&quot;newPage.html&quot;);// 重定向到绝对URLresponse.sendRedirect(&quot;http://example.com/newPath&quot;);// 重定向到上下文路径下的资源response.sendRedirect(request.getContextPath() + &quot;/secured/page.jsp&quot;);\n\n请求转发(服务器内部)// 获取转发器RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/target.jsp&quot;);// 转发请求和响应dispatcher.forward(request, response);\n\n示例RESTful API响应protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);        try (PrintWriter out = response.getWriter()) &#123;        JSONObject json = new JSONObject();        json.put(&quot;status&quot;, &quot;success&quot;);        json.put(&quot;data&quot;, new JSONObject()            .put(&quot;id&quot;, 123)            .put(&quot;name&quot;, &quot;张三&quot;)            .put(&quot;email&quot;, &quot;zhangsan@example.com&quot;));                out.print(json.toString());    &#125;&#125;\n\n文件下载protected void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        String fileName = &quot;example.pdf&quot;;    String filePath = &quot;/path/to/files/&quot; + fileName;        response.setContentType(&quot;application/pdf&quot;);    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);        try (InputStream in = new FileInputStream(filePath);         OutputStream out = response.getOutputStream()) &#123;                byte[] buffer = new byte[4096];        int length;        while ((length = in.read(buffer)) &gt; 0) &#123;            out.write(buffer, 0, length);        &#125;    &#125;&#125;\n\n乱码问题response缓冲区的默认编码也是iso8859-1\nresponse.setCharacterEncoding(&quot;utf-8&quot;);  // 更改response的编码方式为UTF-8\n\n更改response的编码方式为UTF-8，只是其中一步，因为发送端服务端虽然改变了编码方式为UTF-8，但是接收端浏览器端仍然使用GB2312编码方式解码，还是无法还原正常的中文，因此还需要告知浏览器端使用UTF-8编码去解码。\n// 通知浏览器使用utf8response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);\n\nresponse.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)这个方法包含了上面的两个方法的调用，因此在实际的开发中，只需要调用一个response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)方法即可。\n\nServlet的工作流程\n\n关于Web基础部分\nJavaWeb-http\n引用文章\nJavaWeb——HTTP详解\nJavaWeb——Servlet\n菜鸟教程Servlet部分\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Web","Servlet"]},{"title":"Servlet与会话管理","url":"/posts/45466.html","content":"为什么进行会话管理Web应用程序基于HTTP协议\n\nHTTP基于请求&#x2F;响应模式\n所有请求都是相互独立的，无连续性的\n\n\nHTTP是无连接的协议\n限制每次连接只处理一个请求\n\n\nHTTP是无状态的协议\n协议对于事务处理没有记忆能力\n\n\n\n对于简单的页面浏览或信息获取，HTTP协议即可胜任，但是对于需要客户端和服务器端多次交互的网络应用，则必须记住客户端状态\n会话就是一个客户端连续不断地和服务器端进行请求&#x2F;响应的一系列交互\n何为会话多次请求间建立关联的方式称为会话管理，或会话跟踪\n会话状态，指服务器与浏览器在会话过程中产生的状态信息\n会话管理是管理浏览器客户端和服务器端之间会话过程中产生的会话数据。\n会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话，主要有四种会话跟踪方法，设置隐藏表单字段，URL重写，Cookie和Session。常用的会话跟踪技术是Cookie和Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。\n浏览器客户端和服务器端的会话管理涉及的技术有Cookie技术与Session技术，两者的区别在于：\n\nCookie技术将会话数据保存在浏览器客户端\nSession技术将会话数据保存在服务器端\n\n会话的实现过程HTTP没有提供任何记住客户端的途径，服务器如何建立、维护与客户端的会话\n\n\nCookie技术如何理解Cookie技术Cookie实际上是存放在客户端浏览器的一小块文本。\n客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来记录用户状态。\nCookie的工作原理主要的记录用户状态，客户端浏览器第一次请求服务器后，服务器会颁发一个Cookie(name &#x3D;  ErgouTree，该Cookie就相当于那唯一的卡号)响应给客户端浏览器，以后客户端的每次请求都会带上这个Cookie，这样服务器就可以根据这唯一的Cookie识别不同的用户。\n特点\n\nCookie技术将会话数据保存在浏览器客户端。\nCookie数据只能是非中文的字符串类型的数据\n浏览器可以保存多个Cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie\n每个Cookie的大小限制为4KB\n\nCookie核心APICookie(String name, String value)   // 用户创建Cookie对象的构造函数void setPath(String uri)    // 设置cookie的有效访问路径，这个可以在浏览器内看，设置-&gt;内容设置-&gt;Cookie-&gt;查看所有Cookie和网站void setMaxAge(int expiry)    // 设置cokie的存活时间void setValue(String newValue)   // 设置cookie的值Cookie[] request.getCookies()    // 接收cookievoid response.addCookie(Cookie cookie)    // 发送cookie到浏览器端保存\n\nCookie的创建Cookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);response.addCookie(cookie);   // Cookie从servlet里发送到浏览器端\n\n创建Cookie对象，利用Cookie的构造函数来创建Cookie，Cookie的构造函数有两个参数，name和value，必须要有这两个参数，value固定为String类型的。\nCookie 是存放在浏览器端的，所以还需要把 Cookie 从 servlet 里发送到浏览器端，利用response里的addCookie方法可以做到，原理是通过在响应中设置 set-Cookie 标头，以 Key&#x2F;Value 键值对的形式发送到浏览器\n你可以使用google浏览器查看响应头中的set-Cookie标头，你能看到你刚刚添加的Cookie和它的属性值\n\n\n响应首部中黄色的部分就是从Servlet发送到浏览器的Cookie\n请求首部中红色划线部分是浏览器发回到服务器的Cookie，这个不是你刚创建的Cookie，因为你创建的Cookie刚发送到浏览器，之后你再请求一次就可以在请求首部看到你刚创建的Cookie。\nCookie的获取在Servlet中只能使用getCookies方法获取所有的Cookie，没有通过Cookie名来获取Cookie的方法。所以需要你自己来编写代码实现。\n&lt;%    // 如何获取Cookie    Cookie[] cookies = request.getCookies();   // 返回值类型为Cookie[]    if (cookies != null) &#123;        for (int i = 0; i &lt; cookies.length; i++) &#123;            System.out.println(cookies[i].getName() + &quot;: &quot; + cookies[i].getValue());        &#125;    &#125;%&gt;\n\nCookie的修改与删除Cookie并不提供修改，删除操作。\n如果要修改某个Cookie，需要新建一个同名的Cookie，并添加到response中就会覆盖原来的Cookie。\n下面的两行代码就可把username的value值 “kindleheart”改为”Hush”。\n// 修改Cookie的示例方法protected void modifyCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 假设我们要将用户名从旧值改为&quot;Hush&quot;    Cookie cookie = new Cookie(&quot;username&quot;, &quot;Hush&quot;);    cookie.setPath(&quot;/Demo&quot;);  // 设置与原始Cookie相同的路径    cookie.setMaxAge(7 * 24 * 60 * 60); // 保持相同的有效期    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已修改&quot;);&#125;\n\n删除Cookie的实现\n如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。\n// 删除Cookie的标准方法protected void deleteCookie(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException &#123;        // 1. 创建一个同名Cookie    Cookie cookie = new Cookie(&quot;username&quot;, &quot;&quot;);    // 设置值为空        // 2. 设置path与原始Cookie一致（重要！）    cookie.setPath(&quot;/Demo&quot;);        // 3. 设置生存期为0（立即失效）    cookie.setMaxAge(0);        // 4. 添加到响应中    response.addCookie(cookie);        response.getWriter().println(&quot;Cookie已删除&quot;);&#125;\n\n修改和删除Cookie时，新建的Cookie除value，maxAge之外的所有属性，例如name，path，domain等，都要与原Cookie完全一样。否则，浏览器会把这两个Cookie视为不同的Cookie，不允许覆盖，导致修改删除失败。\n服务的完整示例@Override   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       request.setCharacterEncoding(&quot;UTF-8&quot;);       // 获取表单数据       String username = request.getParameter(&quot;username&quot;);       String password = request.getParameter(&quot;pwd&quot;);       String rememberMe = request.getParameter(&quot;rememberMe&quot;);       // 简单的验证（实际项目中应该连接数据库验证）       if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123;           // 登录成功           // 如果用户选择了&quot;记住我&quot;           if(&quot;true&quot;.equals(rememberMe)) &#123;               // 创建Cookie保存用户名               Cookie usernameCookie = new Cookie(&quot;username&quot;, username);               // 设置Cookie有效期为7天               usernameCookie.setMaxAge(7 * 24 * 60 * 60);               response.addCookie(usernameCookie);           &#125;else&#123;               // 用户没有选择记住我，删除可能存在的Cookie               Cookie usernameCookie = new Cookie(&quot;username&quot;, &quot;&quot;);               usernameCookie.setMaxAge(0); // 立即过期               response.addCookie(usernameCookie);           &#125;           // 创建会话           HttpSession session = request.getSession();           session.setAttribute(&quot;username&quot;, username);           // 重定向到欢迎页面           response.sendRedirect(&quot;&quot;);       &#125;else&#123;           // 登录失败           response.sendRedirect(&quot;index.jsp?error=1&quot;);       &#125;   &#125;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 初始化变量    String name = &quot;&quot;;    boolean isRemembered = false;        // 获取Cookie    Cookie[] cookies = request.getCookies();    if (cookies != null) &#123;        for (Cookie cookie : cookies) &#123;            // 查找用户名Cookie            if(cookie.getName().equals(&quot;username&quot;))&#123;                name = cookie.getValue();                isRemembered = true;            &#125;        &#125;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;用户登录&lt;/h2&gt;    &lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;        账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;1&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;        记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;        登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nCookie的属性除了name与value之外，Cookie还有其它的一些可选属性，比如注释、路径和域限定符、最大生存时间和版本号。\n每个属性对应着一个get方法和一个set方法。\n\n\n有效期Cookie的maxAge决定着Cookie的有效期，单位为秒，默认值为-1。\nCookie中通过getMaxAge()方法与setMaxAge()方法来读写maxAge属性。\n\nmaxAge &gt; 0：表示Cookie会在 maxAge 秒之后自动失效。浏览器会将 maxAge 为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在 maxAge 秒之前，登录网站时该Cookie仍然有效。\nmaxAge &lt; 0，则表示该Cookie仅仅在关闭窗口前有效。maxAge 为负数的Cookie，为临时Cookie，不会被持久化，不会被写到Cookie文件中，而是保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。\nmaxAge &#x3D; 0，有效时间为0，就表示为删除Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除。\n\nCookie的域名Cookie是不可跨域名的，同一个一级域名下的两个二级域名如 www.kindleheart.com 和 images.kindleheart.com 也不能互相使用Cookie，因为二者的域名并不严格相同。如果想所有kindleheart.com名下的二级域名都可以使用该Cookie，可以设置domain参数。\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setDomain(&quot;.kindleheart.com&quot;);response.addCookie(cookie);\n\nCookie的路径domain属性决定访问Cookie的域名，而path属性决定允许访问Cookie的路径(ContextPath)。\n如果只允许Demo工程下的程序使用Cookie，可以这么写：\nCookie cookie = new Cookie(&quot;username&quot;, &quot;kindleheart&quot;);cookie.setPath(&quot;/Demo&quot;);response.addCookie(cookie);\n\n\n\nSeesion核心APIHttpSession getSession()    ——    得到session对象HttpSession getSession(boolean create)    ——  当create参数为true时，如果获取不到对应session对象就为浏览器创建一个session对象；如果create参数为false时，如果获取不到对应session对象就返回null。   void setAttribute(String name, Object value)    ——    保存会话数据到session对象Object getAttribute(String name)    ——    从session对象中获取会话数据void removeAttribute(String name)    ——     清除session对象中对应的会话数据void setMaxInactiveInterval(int interval)    ——    设置session的有效时间，默认情况是30分钟void invalidate()    ——    销毁session对象String getId()    ——    得到session编号\n\n理解SessionCookie可以让服务器跟踪每个客户端的访问，Cookie存放在客户端浏览器，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多，那么无形地会增加了客户端与服务器端的数据传输量，而Session正是解决这个问题的。\nSession存放在服务器端，同一个客户每次和服务器端进行交互时，不需要每次传回所有的Cookie值，而是只要传回一个ID，这个ID是客户端第一次访问时生成的，而且每个客户端都是唯一的，这样每个客户端都有了一个唯一的ID，客户端只需要传回这个ID就行了，这个ID通常是name为JSESSIONID的一个Cookie。\n实际上有以下三种方式使得Session正常工作。\n\n基于Cookie，如果没有修改Context容器的Cookies标识，则默认也是支持的。客户端每次请求的时候，Cookie会被返回到服务器，利用请求头中的Cookie标头。　　\n\n基于URL Path Parameter(URL重写)，默认支持。\n浏览器不支持Cookie或者用户把浏览器的Cookie功能关闭了，浏览器就会把该用户的Session的ID信息(JSESSIONID)重写到用户请求的URL参数中，服务器再从URL参数中解析出Session的ID。、\n首先我们把浏览器的Cookie关闭，再使用HttpServletRequest类提供的encodeURL(String url)实现地址重写，下面是一个计录浏览次数的小例子：\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;       response.setContentType(&quot;text/html;charset=utf-8&quot;);       HttpSession session = request.getSession();       int count = 0;       if(session.getAttribute(&quot;count&quot;) != null) &#123;           int c = (int) session.getAttribute(&quot;count&quot;);           count = c + 1;       &#125;       session.setAttribute(&quot;count&quot;, count);       PrintWriter out = response.getWriter();       out.println(&quot;&lt;html&gt;&quot;);       out.println(&quot;&lt;body&gt;&quot;);       out.println(&quot;&lt;h1&gt;登入&quot; + count + &quot;次&lt;/h1&gt;&quot;);       //URL重写把JSESSIONID发送到服务器       out.println(&quot;&lt;a href=&#x27;&quot; + response.encodeURL(&quot;IndexServlet&quot;) + &quot;&#x27;&gt;click me&lt;/a&gt;&quot;);       out.println(&quot;&lt;/body&gt;&quot;);       out.println(&quot;&lt;/html&gt;&quot;);       out.close();   &#125;  \n\n在浏览器的地址栏URL里文件名后面URL参数前面可以看到 jsessionid &#x3D; XXX。　\n注意：如果浏览器支持Cookie，那么Tomcat仍然会解析Cookie里的中的Session ID，并会覆盖URL中的Session ID，也就是你在URL就中看不到 jsessionid &#x3D; XXX了。\n\n基于SSL，默认不支持，只有connector.getAttribute(“SSLEnabled”)为TRUE时才支持。\n\n\nSession的生命周期\nSession的创建\n\n\nSession在用户第一次请求服务器的时候自动创建，只有访问Servlet，JSP等动态资源才会创建，访问HTML，IMAGE等静态资源并不会创建Session，如果没有创建成功，也可以使用request.getSession(true)强制创建Session。\n\n\nSession的获取\n\n\n通过HttpServletRequest对象的getSession方法获取一个HttpSession实例。\n//获取此会话HttpSession session = request.getSession();\n\n\nSession的撤销\nSession的撤销有三种可能的情况：\n\nSession超时，Session的默认有效期为30分钟，你如果30分钟内没有请求服务器，Session就会撤销，你30分钟内请求了服务器，服务器就认为你active了一次，重新计算有效期。\n可以在web.xml文件里或者使用setMaxInactiveInterval(20 *  60)方法设置Session的有效期，注意的是web.xml文件里参数以分为单位，15分钟，setMaxInactiveInterval(20 * 60)中的参数以秒为单位，这里是20分钟。\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;session-config&gt;    &lt;session-timeout&gt;15&lt;/session-timeout&gt;  &lt;/session-config&gt;&lt;/web-app&gt;\n\n//设置Session的有效期为20分钟session.setMaxInactiveInterval(20 * 60);\n\n通过会话对象使用invalidate方法使Session无效。\n//使此会话无效session.invalidate();\n\n程序结束\n\n\n\n\nSession的属性操作\nSession增加属性\nSession中的属性也是以键值对的形式存储的，用setAttibute(name, value)方法添加属性，value是Object对象的，所以value不限于String类型，可以是任何数据类型。\n//添加一个name为count的属性，值为250int count = 250;session.setAttribute(&quot;count&quot;, count);\n\nSession获取属性值\n//获取name为count的value值，需要强转int count = (int) session.getAttribute(&quot;count&quot;);\n\nSession修改属性\nSession修改属性，直接使用setAttibute(name, value)方法覆盖相同name的Session即可。\n//把name为count的属性值由250修改到520session.setAttribute(&quot;count&quot;, 250);session.setAttribute(&quot;count&quot;, 520);\n\nSession删除属性\nSession删除属性，使用removeAttribute(name)方法，删除对应name的属性。\n//删除name为count的属性session.removeAttribute(&quot;count&quot;);\n\n应用实例@Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;pwd&quot;);        String rememberMe = request.getParameter(&quot;rememberMe&quot;);        // 简单的登录验证        if(isValidUser(username, password)) &#123;            // 创建或获取session            HttpSession session = request.getSession();            // 存储登录状态            session.setAttribute(&quot;isLoggedIn&quot;, true);            session.setAttribute(&quot;username&quot;, username);            // 如果用户选择了&quot;记住我&quot;            if(&quot;true&quot;.equals(rememberMe)) &#123;                session.setAttribute(&quot;rememberMe&quot;, true);                // 设置session超时时间（7天）                session.setMaxInactiveInterval(7 * 24 * 60 * 60);            &#125;else &#123;                // 不记住则移除属性                session.removeAttribute(&quot;rememberMe&quot;);                // 使用默认的超时时间            &#125;            // 重定向到欢迎页面            response.sendRedirect(&quot;welcome.jsp&quot;);        &#125; else &#123;            // 登录失败            response.sendRedirect(&quot;index.jsp?error=1&quot;);        &#125;    &#125;\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%    // 检查session中是否有记住的用户名    String name = &quot;&quot;;    boolean isRemembered = false;    HttpSession existingSession = request.getSession(false);    if (existingSession != null &amp;&amp; existingSession.getAttribute(&quot;rememberMe&quot;) != null) &#123;   \t    // 取出session中存储的用户名，一般只是取出，不修改        name = (String) existingSession.getAttribute(&quot;rememberMe&quot;);        isRemembered = true;    &#125;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;用户登录(Session版)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;用户登录(Session版)&lt;/h2&gt;&lt;% if (&quot;1&quot;.equals(request.getParameter(&quot;error&quot;))) &#123; %&gt;&lt;p style=&quot;color:red;&quot;&gt;用户名或密码错误!&lt;/p&gt;&lt;% &#125; %&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;    账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&lt;%= name %&gt;&quot;/&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;/&gt;&lt;br&gt;    记住我：&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot; value=&quot;true&quot; &lt;%= isRemembered ? &quot;checked&quot; : &quot;&quot; %&gt;/&gt;&lt;br&gt;    登录：&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n比较ServletContext，HttpServletRequest和HttpSessionServletContext\n\n范围最大,应用程序级别的,整个应用程序都能访问；\n是Servlet上下文对象，在服务器启动阶段解析web.xml文件创建ServletContext对象，在同一个web app中所有的Servlet对象共享同一个ServletContext对象。该对象一旦创建不会被销毁，除非将服务器停掉。\n一般存储在该对象中的数据首先是所有用户共享的，不会被修改的，少量数据。\nServletContext对象传递数据可以跨Servlet、跨请求、跨用户(跨会话)传递数据。\n\nHttpSession\n\n次之,会话级别的，在当前的浏览器中都能訪问，不论是在同一浏览器开多少窗体，都能够访问，可是换个浏览器就不行了，就必须又一次创建session；\n每一个用户都有一个这样的对象，是一个用户级别的对象，存储在该对象中的数据一般都是该用户专属的数据\nHttpSession对象传递数据可以跨Servlet、跨请求(这些请求必须属于同一个会话)、但是不能跨用户传递数据。\n\nHttpServletRequest\n\n范围最小,请求级别,请求结束,变量的作用域也结束（也就是仅仅是一次访问,访问结束，这个也结束）。\n是请求对象，一次请求一个对象，每一次请求都会新建一个请求对象，是一个请求级别的对象，存储该对象中的数据一般都是请求级别的数据，一次请求之后这个数据就不再使用的数据可以存储在该对象中\nHttpServletRequest对象传递数据可以跨Servlet，但是不能跨请求，更不能跨用户传递数据。\n\n尽量从小范围向大范围使用。(考虑原则：request&lt; session &lt; application)\nServletContext、HttpSession、HttpServletRequest接口的对比：\n以上都是范围对象:\n\nServletContext application; 是应用范围\nHttpSession session; 是会话范围\nHttpServletRequest request; 是请求范围\n\n三个范围的排序：application &gt; session &gt; request\n\napplication完成跨会话共享数据\nsession完成跨请求共享数据，但是这些请求必须在同一个会话当中\nrequest完成跨Servlet共享数据，但是这些Servlet必须在同一个请求当中【转发】\n\n使用原则：有小到大尝试，优先使用小范围。例如：\n\n登录成功之后，已经登录的状态需要保存起来，可以将登录成功的这个状态保存到session对象中。\n登录成功状态不能保存到request范围中，因为一次请求对应一个新的request对象。\n登录成功状态也不能保存到application范围中，因为登录成功状态是属于会话级别的，不能所有用户共享。\n\nCookie与Session的比较Cookie与Session都是为了保持用户访问的连续状态，之所以为了要保持这种状态，一方面是为了实现业务方便，另一方面就是简化服务器端的程序设计，提高访问性能。但是两者的实现原理不太一样，各自都有优点和缺陷，下面通过比较说明这两者的特点和适用场合。\n\n存取方式上\nCookie中只能保持ASCLL字符串，如果存取Unicode字符或者二进制数据，需要进行UTF-8，GBK，或者BASE64等方式的编码，而Session中可以存取任何类型的数据。\n\n隐私安全上\nCookie存放在客户端浏览器，对客户端是可见的，客户端的一些程序可能会窥探复制甚至修改Cookie中的内容。而Session存放在服务器端，对用户是透明的，不存在敏感信息泄露的危险。\n\n有效期上\nCookie可以设置长期有效，浏览器关闭也有效，虽然Session可以设置很长的有效期，但是Session依赖名为JSESSIONID的Cookie，该Cookie的maxAge默认为-1，浏览器关闭Cookie就失效，所以该Session也就失效了。\n\n服务器的负担上\nSession存放在服务器端，每个用户都会产生一个Session。如果并发非常大的网站，会产生大量的Session，消耗大量内存，因此像Baidu，Google这样并发量极高的网站是不会使用Session来追踪会话的，而Cookie保存在客户端，不占用服务器资源，对于并发量极高的网站Cookie是更好的选择。\n\n从浏览器支持上\nCookie是需要浏览器支持的，如果浏览器不支持Cookie，就需要使用Session以及URL地址重写。\n\n从跨域名上\nCookie支持跨域名访问，只要设置domain属性即可，但Session不能够跨域名访问，Session仅在他的域名下有效。\n\n\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Servlet"]},{"title":"Servlet学习之核心接口,工作原理和配置","url":"/posts/4234.html","content":"什么是Servlet运行在服务器端的程序\nservlet是一个接口，定义了Java类被浏览器访问到的规则（接口）\nServlet是用java编写的服务器端的程序，主要是交互式的浏览和修改数据，生成动态Web内容，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上\nServlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\nStruts2的核心用的是Filter（过滤器），而SpringMVC的核心用的就是Servlet。\n// WebServlet注解表示这是一个Servlet，并映射到地址/:@WebServlet(urlPatterns = &quot;/&quot;)public class HelloServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;        // 设置响应类型:        resp.setContentType(&quot;text/html&quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;&#125;\n\n一个Servlet总是继承自HttpServlet，然后重写doGet()或doPost()方法。注意到doGet()方法传入了HttpServletRequest和HttpServletResponse两个对象，分别代表HTTP请求和响应。我们使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为HttpServletRequest和HttpServletResponse就已经封装好了请求和响应\n工作模式\n客户端发送请求至服务器\n服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器\n服务器将响应返回客户端\n\nAPI预览Servlet API 包含以下4个Java包：\n1.javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。\n2.javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。\n3.javax.servlet.annotation   其中包含标注servlet，Filter,Listener的标注。它还为被标注元件定义元数据。\n4.javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。\n使用ServletServlet技术的核心是Servlet，它是所有Servlet类必须直接或者间接实现的一个接口。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。\n工作原理​    Servlet接口定义了Servlet与servlet容器之间的契约：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。\n​    但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​    用户请求致使Servlet容器调用Servlet的Service()方法,并传入一个ServletRequest对象和一个ServletResponse对象。 ServletRequest中封装了当前的Http请求,ServletResponse表示当前用户的Http响应.\n​     对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。\n接口中定义的方法public interface Servlet &#123;    // 这是 Servlet 的初始化方法，在 Servlet 实例被创建之后，容器会调用此方法对 Servlet 进行初始化操作。    void init(ServletConfig var1) throws ServletException; \t    // 用于获取 Servlet 的配置信息，会返回由Servlet容器传给init（ ）方法的ServletConfig对象    ServletConfig getServletConfig(); \t    // 用来处理客户端的请求并生成响应。当有客户端请求到达时，Servlet 容器会调用这个方法。    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; \t    // 用于返回 Servlet 的描述信息    String getServletInfo(); \t    // 这是 Servlet 的销毁方法，在 Servlet 实例被销毁之前，容器会调用此方法，用于释放 Servlet 占用的资源    void destroy();&#125;\n\n执行原理当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\n查找Web.xml文件，是否有对应的标签体的内容，如果有，则在对应的全类名\ntomcat会将其字节码加载进内存然后构建对象，调用其方法\nServlet的生命周期上述接口中定义的方法内，init( ),service( ),destroy( )是Servlet生命周期的方法。\nServlet容器（例如TomCat）会根据下面的规则来调用这三个方法：\n\n当Servlet第一次被请求时，Servlet容器就会开始调用 init() 方法，初始化一个Servlet对象出来,这个方法在后续请求中不会在被Servlet容器调用。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。\n\nservice( )方法，每当请求Servlet时，Servlet容器就会调用这个方法，第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。\n\ndestory,当要销毁Servlet时，Servlet容器就会调用这个方法，一般在这个方法中会写一些清除代码，只有服务器正常关闭的时候，才会执行destory方法\n演示代码\n@Overridepublic void init(ServletConfig servletConfig) throws ServletException &#123;    System.out.println(&quot;Servlet正在初始化&quot;);&#125; @Overridepublic ServletConfig getServletConfig() &#123;    return null;&#125; @Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;    //专门向客服端提供响应的方法    System.out.println(&quot;Servlet正在提供服务&quot;); &#125; @Overridepublic String getServletInfo() &#123;    return null;&#125; @Overridepublic void destroy() &#123;    System.out.println(&quot;Servlet正在销毁&quot;);&#125;\n\n其中servlet的创建时期是可以被指定的\n&lt;!-- 指定servlet的创建时期，负数为第一次访问时期，0或正数为服务器启动时期--&gt;&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;\n\nServlet中的 init 方法只执行一次，说明一个Servlet中只存在一个对象，是单例的，多个用户同时访问可能存在线程安全的隐患，所以尽量不要再其中定义成员变量，也不要对其赋值\nTomcat部分普通的Java程序是通过启动JVM，然后执行main()方法开始运行。但是Web应用程序有所不同，我们无法直接运行war文件，必须先启动Web服务器，再由Web服务器加载我们编写的HelloServlet，这样就可以让HelloServlet处理浏览器发送的请求。\nTomcat本身的目录层次结构\n\nTomcat提供了一个部署其服务器在你本地电脑上的功能\n​\t实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机\n​\t执行Tomcat的main()方法，然后由Tomcat负责加载我们的.war文件，并创建一个HelloServlet实例，最后以多线程的模式来处理HTTP请求。\n​\t如果Tomcat服务器收到的请求路径是/（假定部署文件为ROOT.war），就转发到HelloServlet并传入HttpServletRequest和HttpServletResponse两个对象。\n配置Servletweb.xml配置web.xml 文件是用于配置 Web 应用程序的核心文件，它能对 Servlet、过滤器、监听器等组件进行配置\nServlet 定义&lt;servlet&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.ergoutree.servletexpdemo.demo1.FastGo&lt;/servlet-class&gt;&lt;/servlet&gt;\n\n\n标签：该标签的作用是定义一个 Servlet。在一个 web.xml 文件中，可以定义多个 Servlet。\n标签：这里为 Servlet 指定一个名称，也就是 ServletExpDemo。这个名称属于逻辑名称，主要用于在 web.xml 文件的其他部分引用该 Servlet。\n标签：它指定了 Servlet 类的全限定名，即 org.ergoutree.servletexpdemo.demo1.FastGo。当 Web 容器启动时，会依据这个全限定名来加载并实例化该 Servlet 类。\n\nServlet 映射&lt;servlet-mapping&gt;    &lt;servlet-name&gt;ServletExpDemo&lt;/servlet-name&gt;    &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n标签：此标签的功能是将 Servlet 与一个或多个 URL 模式进行映射。当客户端发送请求时，Web 容器会根据请求的 URL 找到对应的 Servlet。\n标签：这里引用了之前定义的 Servlet 的名称，也就是 ServletExpDemo。\n标签：它指定了与该 Servlet 关联的 URL 模式，即 /demo1。当客户端请求的 URL 匹配这个模式时，Web 容器就会将请求转发给 ServletExpDemo 所对应的 Servlet 类（也就是org.ergoutree.servletexpdemo.demo1.FastGo）进行处理。\n\n原理及其示例原理说明当客户端向 Web 应用程序发送 HTTP 请求时，Web 容器（像 Tomcat 这类）会按照以下步骤处理请求：\n\n解析请求 URL：Web 容器对客户端请求的 URL 进行解析，从中提取出请求的路径部分。\n查找 Servlet 映射：Web 容器在 web.xml 文件里查找与请求路径相匹配的 &#96;&#96;。\n定位 Servlet：若找到匹配的 ，Web 容器会根据对应的  找到之前定义的 Servlet。\n实例化并调用 Servlet：Web 容器加载并实例化该 Servlet 类，然后调用其 service() 方法来处理请求。\n返回响应：Servlet 处理完请求后，将响应返回给客户端。\n\n示例假设客户端发送的请求 URL 为 http://localhost:8080/yourApp/demo1，Web 容器会进行如下操作：\n\n解析出请求路径为 /demo1。\n在 web.xml 文件中找到 为 `/demo1` 的。\n根据 &#96;&#96; 为 ServletExpDemo，找到对应的 Servlet 类 org.ergoutree.servletexpdemo.demo1.FastGo。\n加载并实例化 FastGo 类，调用其 service() 方法处理请求。\n将处理结果返回给客户端。\n\nSerlvet3.0的注解配置@WebServlet 的属性列表：\n![image-20250412202207184](D:\\WorkSpace\\github space\\hexo-blog\\source_posts\\Servlet学习之核心接口，工作原理和配置\\image-20250412202207184.png)\n核心注解**@WebServlet**取代  和 ，直接绑定 URL 模式与 Servlet 类。\n@WebServlet(    name = &quot;userServlet&quot;, // Servlet 名称（可选）    urlPatterns = &#123;&quot;/user&quot;, &quot;/api/user&quot;&#125;, // 支持多 URL 模式    loadOnStartup = 1, // 容器启动时立即加载（替代 &lt;load-on-startup&gt;）    initParams = &#123;        @WebInitParam(name = &quot;encoding&quot;, value = &quot;UTF-8&quot;) // 初始化参数    &#125;,    asyncSupported = true // 启用异步支持（默认 false）)public class UserServlet extends HttpServlet &#123; ... &#125;\n\n\nurlPatterns：支持精确匹配 (/user)、通配符 (/api/*)、后缀匹配 (*.do)。\n\nloadOnStartup：值越小优先级越高，控制 Servlet 初始化顺序。\n\nasyncSupported：异步处理开关，需配合 AsyncContext 使用（后文详解）。\n\n\n@WebFilter：声明过滤器替代  和，定义请求预处理和后处理逻辑。\n@WebFilter(    filterName = &quot;auditFilter&quot;,    urlPatterns = &quot;/*&quot;, // 过滤所有请求    servletNames = &#123;&quot;userServlet&quot;&#125;, // 针对特定 Servlet    dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.ASYNC&#125;)public class AuditFilter implements Filter &#123; ... &#125;\n\n\ndispatcherTypes：控制过滤器作用的请求类型（如 FORWARD、ERROR）。\n执行顺序问题：注解无法直接指定顺序，需通过类名自然排序或结合 web.xml 的 &#96;&#96;。\n\n@WebListener：事件监听器简化监听器的声明，覆盖 Servlet 上下文、会话、请求等生命周期事件。\n@WebListenerpublic class AppContextListener implements ServletContextListener &#123;    @Override    public void contextInitialized(ServletContextEvent sce) &#123;        // 应用启动逻辑    &#125;&#125;\n\n\n\n异步处理在 @WebServlet 或 @WebFilter 中设置 asyncSupported = true。\n流程：\n\n开启异步上下文：AsyncContext asyncContext = request.startAsync()。\n提交耗时任务到其他线程（如数据库查询、远程调用）。\n任务完成时，通过 asyncContext.complete() 或返回响应。\n\n@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)public class AsyncServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123;        AsyncContext ctx = req.startAsync();        CompletableFuture.runAsync(() -&gt; &#123;            // 模拟耗时操作            ctx.getResponse().getWriter().write(&quot;Async Response&quot;);            ctx.complete();        &#125;);    &#125;&#125;\n\n\n\n模块化部署介绍Servlet 3.0 模块化特性：\n\n允许将 Web 组件（Servlet、Filter、Listener）打包为 JAR 文件，置于 WEB-INF/lib 目录。\n容器自动扫描 JAR 中的 META-INF/web-fragment.xml 和注解，实现“即插即用”\n\n注意情况如果使用@WebServlet Annotation（注解）来配置Servlet，需要注意：\n① 不要在 web.xml 文件的根元素（&lt;web-app—&#x2F;&gt;）中指定 metadata-complete&#x3D;“true”；② 不要在 web.xml 文件中再次配置该 Servlet 相关属性\nServletRequest 和 ServletResponse 为 Servlet 提供了处理客户端请求和发送响应的能力；ServletConfig 为 Servlet 提供了配置信息；ServletContext 为 Servlet 提供了整个 Web 应用程序的上下文环境。它们共同协作，使得 Servlet 能够正常运行并处理客户端的请求。\nServletRequset接口Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\nServletRequest接口的部分内容：\npublic interface ServletRequest &#123;    int getContentLength();//返回请求主体的字节数    String getContentType();//返回主体的MIME类型    String getParameter(String var1);//返回请求参数的值&#125;\n\n\n\nServletResponse接口javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。\nServletResponse隐藏了向浏览器发送响应的复杂过程。在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。\nServletResponse内部定义的方法：\npublic interface ServletResponse &#123;    String getCharacterEncoding(); \t// 在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型,加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。    String getContentType(); \t// 发送二进制数据的    ServletOutputStream getOutputStream() throws IOException; \t// PrintWriter对象使用ISO-8859-1编码（该编码在输入中文时会发生乱码）。    PrintWriter getWriter() throws IOException;     void setCharacterEncoding(String var1);     void setContentLength(int var1);     void setContentType(String var1);     void setBufferSize(int var1);     int getBufferSize();     void flushBuffer() throws IOException;     void resetBuffer();     boolean isCommitted();     void reset();     void setLocale(Locale var1);     Locale getLocale();&#125;\n\n\n\nServletConfig接口当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init( )方式传入一个ServletConfig对象。\n其中几个方法如下：\n\nServletContext对象ServletContext对象表示Servlet应用程序，是Servlet的上下文对象。每个Web应用程序都只有一个ServletContext对象。\n在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。\n通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。\n有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中\nServletContext中的下列方法负责处理属性：\nObject getAttribute(String var1);  // 获取 ServletContext 中指定名称的属性值 // 用于获取 ServletContext 中所有属性的名称。返回的是一个 Enumeration 对象，通过它可以遍历所有属性的名称。Enumeration&lt;String&gt; getAttributeNames(); void setAttribute(String var1, Object var2);    // 向 ServletContext 中设置一个属性 void removeAttribute(String var1);    // 从 ServletContext 中移除指定名称的属性\n\n\n\nServlet是否为线程安全线程安全问题指的是多线程在并发执行时会不会出现问题。由于Web容器只会创建一个Servlet实例，所以多个用户发起请求时，会有多个线程处理Servlet代码，因此Servlet是线程不安全的。\n考虑以下代码：\n@WebServlet(name = &quot;ThreadSafeServlet&quot;, urlPatterns = &quot;/ThreadSafeServlet&quot;)public class ThreadSafeServlet extends HttpServlet &#123;    private String name;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        name = request.getParameter(&quot;name&quot;);        try &#123;            Thread.sleep(10000);//使线程沉睡10秒        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        response.getWriter().println(&quot;name:&quot; + name);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doPost(request, response);    &#125;&#125;\n\n10秒内在两个不同的浏览器窗口中的表单输入name并提交，假如在A浏览器中输入111，B浏览器中输入222，最后会发现A和B浏览器显示的name都是222。这是因为在第一个线程睡眠时，第二个线程修改了name的值，所有最后显示都是222，那么就产生了线程不安全问题。\n实际上Servlet，Context上下文作用域，HttpSession都是线程不安全的，只有request请求和局部变量是线程安全的。\n关于Servlet与http相关的应用，下一部分是这个\nServlet与http\n关于Web基础部分\nJavaWeb-http\n引用文章\nJavaWeb——HTTP详解\nJavaWeb——Servlet\n菜鸟教程Servlet部分\n","categories":["Java学习","JavaEE","Servlet"],"tags":["Java技术","JavaWeb","JavaEE","Servlet"]},{"title":"Spring Framework part2--IoC容器之IoC原理","url":"/posts/undefined.html","content":"Spring Framework part2–IoC容器之IoC原理在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。\n什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。\n例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。\n通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。\nSpring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。\nIoC容器，主要关于Spring容器如何对组件进行生命周期管理和配置组装服务。\nIoC原理Spring提供的容器又称为IoC容器，什么是IoC？\nIoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。\n控制翻转IoCIoC是一种设计思想，能够指导我们能设计出松耦合，更优良的程序，提高程序的扩展力\nSpring 通过 IoC容器来管理所有Java对象的实例化和初始化，控制对象和对象之间的依赖关系，我们将由IoC容器管理的Java对象称为 Spring Bean，他与使用关键字 new 创建的 Java 对象没有任何区别\n容器中存放我们的Bean（java中的对象），创建到销毁过程都是容器进行管理的\n控制反转，反转的是什么\n\n把对象的创建权力交出去，交给第三方容器\n将对象和对象之间的关系的维护权交出去，交给第三方容器负责\n\n控制反转如何实现\n\nDI 依赖注入\n\n容器放bean对象，使用的是 map 集合\nIoC容器过程示例图\n\n\n\n\n依赖注入DI  依赖注入 实现了控制反转的思想\n依赖注入\n\nSpring创建对象的过程中，将对象依赖属性通过配置进行注入\n\n常见方式包括以下两种\n\n第一种，set注入\n第二种，构造注入\n\n所以，IoC就是一直控制反转的思想，而 DI 是对IoC的一种具体实现\nBean管理说的是：Bean对象的创建，以及Bean对象中属性的值（Bean对象之间关系的维护）\nIoC容器在Spring的实现IoC容器中管理的组件也叫Bean，创建Bean之前，首先要创建IoC容器，Spring提供了IoC容器的两组实现方式\n\nBeanFactory\n顶层接口，IoC容器的基本实现，是Spring内部使用的接口，面向Spring本身，不提供给开发人员使用\n\nApplicationContext\nBeanFactory的子接口，提供了更多的高级特性\n主要实现类如下\n\n\n![1](Spring Framework part2-IoC容器之IoC原理&#x2F;image-20250419180915322.png)\n\n\n![image-20250419180928366](Spring Framework part2-IoC容器之IoC原理&#x2F;image-20250419180928366.png)\n\n\n传统 Java 组件协作 与  IoC 控制反转 的对比会在下述例子中体现一个电商系统需要处理订单，订单服务（OrderService）依赖支付服务（PaymentService）完成支付逻辑。\n传统方式：硬编码依赖\n// 支付服务实现public class PaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment...&quot;);    &#125;&#125;// 订单服务直接创建依赖对象public class OrderService &#123;    private PaymentService paymentService = new PaymentService(); // 硬编码依赖    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方代码public class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        orderService.createOrder();    &#125;&#125;\n\n紧耦合：OrderService 直接实例化 PaymentService，若需替换支付实现（如改用支付宝或微信支付），必须修改 OrderService 的代码。\n上述每个组件都采用了一种简单的通过new创建实例并持有的方式，但是这种方式有着很大的缺点：\n\n随着更多的组件被引入，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。\n没有必要让不同的两个类分别创建相同功能的实例，完全可以共享同一个，但谁负责创建，谁负责获取其他组件已经创建的，不好处理\n实例化一个组件其实很难，因为各种依赖关系可能存在\n测试某个组件，例如OrderService，是复杂的，因为必须要在支付环境下执行。\n\n从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。\n因此，核心问题是：\n\n谁负责创建组件？\n谁负责根据依赖关系组装组件？\n销毁时，如何按依赖顺序正确销毁？\n\n解决这一问题的核心方案就是IoC。\nIoC 方式：通过依赖注入解耦\n// 定义支付接口（面向接口编程）public interface PaymentService &#123;    void processPayment();&#125;// 支付宝实现public class AlipayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;// 微信支付实现public class WechatPayService implements PaymentService &#123;    @Override    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Wechat Pay...&quot;);    &#125;&#125;// 订单服务通过构造函数注入依赖public class OrderService &#123;    private PaymentService paymentService;    // 依赖由外部传入（控制权反转）    public OrderService(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;    public void createOrder() &#123;        paymentService.processPayment();        System.out.println(&quot;Order created!&quot;);    &#125;&#125;// 调用方通过容器（如 Spring）管理依赖public class Main &#123;    public static void main(String[] args) &#123;        // 由容器决定具体实现（如配置为 AlipayService）        PaymentService paymentService = new AlipayService();        OrderService orderService = new OrderService(paymentService);        orderService.createOrder();    &#125;&#125;\n\n\n解耦：OrderService 不再关心 PaymentService 的具体实现，只需依赖接口。\n灵活性：更换支付方式时，只需修改外部配置（如 Spring 的 Bean 定义），无需改动 OrderService 代码。\n可测试性：在单元测试中，可以注入 MockPaymentService 模拟不同场景。\n\n在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。\n为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如 OrderService 自己并不会创建 paymentService，而是等待外部通过createOrder方法来注入一个OrderService \npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;        System.out.println(&quot;Order created!&quot;);    &#125;&#125;\n\n不直接用 new，而是注入一个 paymentService，带来了一系列好处\n\n可维护性显著提升\n\n在传统方式中，若要更换支付服务的实现，比如从当前的简单支付服务切换到支付宝支付服务，就需要直接修改 OrderService 类的代码。而在 IoC 模式下，由于采用了注入机制，OrderService 类本身不需要做任何修改。\n假设我们有一个新的 AlipayPaymentService 类\npublic class AlipayPaymentService &#123;    public void processPayment() &#123;        System.out.println(&quot;Processing payment via Alipay...&quot;);    &#125;&#125;\n\n在调用方代码中，我们只需要注入新的支付服务实例即可\npublic class Main &#123;    public static void main(String[] args) &#123;        OrderService orderService = new OrderService();        AlipayPaymentService alipayPaymentService = new AlipayPaymentService();        orderService.createOrder(alipayPaymentService);    &#125;&#125;\n\n这样，当业务需求发生变化时，我们可以轻松地替换支付服务的实现，而不会影响到 OrderService 类的内部逻辑，大大提高了代码的可维护性。\n\n\n\n可测试性大幅增强\n\n在传统方式下，测试 OrderService 类时，由于它直接依赖于 PaymentService，必须在真实的支付环境下进行测试，这不仅增加了测试的复杂性，还可能带来不必要的风险\n而在 IoC 模式下，我们可以使用模拟对象（Mock Object）来进行测试。例如，使用 JUnit 和 Mockito 框架，我们可以创建一个模拟的 PaymentService 对象，并将其注入到 OrderService 中进行测试：\nimport org.junit.jupiter.api.Test;import static org.mockito.Mockito.*;public class OrderServiceTest &#123;    @Test    public void testCreateOrder() &#123;        // 创建模拟的 PaymentService 对象        PaymentService mockPaymentService = mock(PaymentService.class);        OrderService orderService = new OrderService();        // 调用 createOrder 方法并注入模拟对象        orderService.createOrder(mockPaymentService);        // 验证 PaymentService 的 processPayment 方法是否被调用        verify(mockPaymentService, times(1)).processPayment();    &#125;&#125;\n\n\n依赖关系管理更加清晰\n\n在 IoC 模式下，所有组件的创建和依赖关系的组装都由 IoC 容器负责，应用程序只需要使用已经创建好并配置好的组件。在 IoC 模式下,通过配置文件或注解的方式将这些依赖关系清晰地表达出来，由 IoC 容器根据这些配置信息来创建和组装组件。这样，开发人员只需要关注组件的功能实现，而不需要关心组件之间的依赖关系，降低了系统的复杂度。\n\n\n\n因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。\n因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现\n&lt;beans&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;HikariDataSource&quot; /&gt;    &lt;bean id=&quot;bookService&quot; class=&quot;BookService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为dataSource的组件通过属性dataSource（即调用setDataSource()方法）注入到另外两个组件中。\n在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。\n依赖注入方式我们从上面的代码可以看到，依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。\n很多Java类都具有带参数的构造方法，如果我们把 OrderService 改造为通过构造方法注入，那么实现代码如下：\npublic class OrderService &#123;    private PaymentService paymentService;     public void createOrder(PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;&#125;\n\nSpring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。\n无侵入容器在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\n\n应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\n测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Farmewrok part1-Spring生态介绍和入门","url":"/posts/26666.html","content":"Spring 和 Spring FrameworkSpring、Spring Framework、Spring Boot、Spring Cloud的区别。\n首先不少人乐意把  Spring Framework 叫做 spring，但是 spring framework 只是 spring中的一个模型，核心是Ioc和aop，而spring是一个生态，spring 是框架。\n\n\n\n\nSpring是一个生态体系（也可以说是技术体系），是集大成者，它包含了 Spring Framework、Spring Boot、Spring Cloud 等（还包括Spring Cloud data flow、spring data、spring integration、spring batch、spring security、spring hateoas），如下图所示（部分截图）：\n\nSpring FrameworkSpring Framework是整个spring生态的基石，它可是硬生生的消灭了Java官方主推的企业级开发标准EJB，从而实现一统天下。\nSpring Framework为基于现代企业应用提供了一个全面的编程和配置的模型 - 在任何类型部署平台上\nSpring Framework为依赖注入、事务管理、WEB应用、数据访问等提供了核心的支持，专注于企业级应用程序的“管道”，以便开发团队可以专注于应用程序的业务逻辑。\nSpring Boot搭建项目的脚手架、黏合剂，整合周边生态\nSpring Boot这家伙简直就是对Java企业级应用开发进行了一场浩浩荡荡的革命。如果稍微有几年工作经验的老油条，应该都记得以前的Java Web开发模式：Tomcat + WAR包。\nSpring Boot能够让你非常容易的创建一个单机版本、生产级别的基于spring framework的应用。然后，”just run”即可。Spring Boot默认集成了很多第三方包，让构建独立的生产级别的Spring应用变得简单，开箱即用，以便你能以最小的代价开始一个项目。\nSpring CloudSpring Clound的出现真正简化了分布式架构的开发\nSpring Cloud事实上是一整套基于Spring Boot的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：配置管理、注册中心、服务发现、限流、网关、链路追踪等。\nSpring Boot是build anything，而Spring Cloud是coordinate anything，Spring Cloud的每一个微服务解决方案都是基于Spring Boot构建的：\n\n\nSpring Cloud AlibabaSpring Cloud Alibaba为分布式应用开发提供一站式解决方案，它包含分布式应用程序开发所需的所有组件，使你可以轻松地使用Spring Cloud开发应用程序。\n使用Spring Cloud Alibaba，你只需要增加一些注解和少量的配置，即可将Spring Cloud应用连接到阿里巴巴的分布式解决方案，并可使用阿里巴巴的中间件构建分布式系统\nSpring Framework主要包括什么Spring Framework主要包括几个模块：\n\n支持IoC和AOP的容器；\n支持JDBC和ORM的数据访问模块；\n支持声明式事务的模块；\n支持基于Servlet的MVC开发；\n支持基于Reactive的Web开发；\n以及集成JMS、JavaMail、JMX、缓存等其他模块。\n\nSpring版本5.x 和 6.x的区别\n\n\nSpring官网是spring.io\n为什么要学Spring FrameworkSpring Framework 是其他 Spring 子项目的基础\n无论是传统企业应用还是云原生微服务，Spring Framework 的核心思想（如 IoC、AOP）均贯穿始终\nSpring Framework 是整个 Spring 技术栈的基石，其他子项目（如 Spring Boot、Spring MVC、Spring Cloud  等）均基于其核心功能扩展。它通过控制反转（IoC）、依赖注入（DI）和面向切面编程（AOP）等机制，为上层模块提供统一的基础设施支持\n而且S pring Framework 其分层架构（如 Core、AOP、Data Access、Web 等模块）允许开发者按需选择功能，避免冗余依赖。这种灵活性使得 Spring 能够适配从传统单体应用到现代微服务的多样化需求\nSpring Framework 提供与多种企业级技术（如 JDBC、JPA、Hibernate、消息队列等）的无缝集成能力，简化了复杂系统的开发\n学习 Spring Framework 是掌握 Spring Boot（快速开发）、Spring Cloud（微服务）等高级框架的前提。例如，Spring Boot 的自动配置机制本质上是基于 Spring Framework 的条件化 Bean 加载实现\n\nSpring Framework 官方文档\nSpring Framework 源码\nSpring 入门课程（W3CSchool）\n\nSpring Framework特点\n非侵入式：Spring Framework开发应用程序时，Spring 对应用程序本身的结构影响特别小，应用代码基本不会被 Spring 特定的 API 所束缚。开发者能够在不依赖 Spring 框架的环境下对代码进行编译、测试和运行。当项目需要更换框架或者调整架构时，由于代码没有与 Spring 框架深度绑定，迁移工作会相对轻松。开发者可以逐步移除 Spring 相关的配置和依赖，而不会对业务逻辑代码造成重大影响。\n控制反转IoC：控制反转是 Spring 框架的核心特性之一，它将对象的创建和依赖关系的管理从应用程序代码转移到了 Spring 容器中。通过控制反转，对象之间的依赖关系变得更加灵活，降低了组件之间的耦合度。\n面向切面编程AOP：面向切面编程允许开发者将横切关注点（如日志记录、事务管理、权限验证等）从业务逻辑中分离出来，以提高代码的可维护性和复用性。通过 AOP，我们可以将通用的横切关注点代码封装到切面中，在多个业务模块中复用这些代码，减少了代码的重复编写。\n容器：Spring 框架提供了强大的容器功能，用于管理对象的生命周期和依赖关系。IoC是一个容器，包含并且管理组件对象的生命周期，组件享受到了容器化的管理，屏蔽了大量的细节。Spring 容器通过依赖注入的方式将对象之间的依赖关系注入到对象中，使得对象之间的协作更加灵活。\n组件化：Spring 鼓励开发者将应用程序拆分成多个独立的组件，每个组件负责特定的功能。开发者可以将不同的业务功能封装成独立的组件，这些组件可以独立开发、测试和部署。组件化的开发方式使得代码结构更加清晰，易于维护和扩展。当需要添加新的功能时，只需要开发新的组件并将其集成到应用中即可。\n一站式：Spring 框架提供了一站式的解决方案，涵盖了企业级应用开发的各个方面。可以整合各种企业应用的开源框架和优秀的第三方类库。\n\nSpring6 的模块组成\n\nSpring Framework 主要是围绕 Core 部分\n\n\nSpring Core：核心容器\n\n\nSpring AOP\n\n\nSpring Data Access\n\n\nSpring Web\n就是大家通常说的Spring MVC部分\n\n\nSpring Message 和 Spring test\n\n\n如何创建工程父工程 spring6    子工程 你自己项目名称\n开发步骤：\n\n引入spring相关依赖\n创建类，定义属性和方法\n按照spring要求创建配置文件   xml\nspring配置文件配置相关信息\n进行测试\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework Part3-IoC基于XML管理Bean上篇","url":"/posts/17876.html","content":"基于XML管理bean搭建基本环境在这之前，建议在父工程中的pom文件里导入我们需要的依赖，这样其里面的子工程会自动添加，会方便许多\n父工程(Spring6)的pom.xml文件，导入相关依赖\n&lt;!-- 依赖关系定义 --&gt;    &lt;dependencies&gt;                &lt;!--log4j2的依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.19.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;            &lt;version&gt;2.19.0&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 引入Spring Context依赖，它是Spring框架的基础模块，提供了环境配置、Bean生命周期管理、事件传播等功能 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;6.0.2&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- 引入JUnit5测试框架，用于编写和运行单元测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;            &lt;version&gt;5.3.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n设置成功刷新后，Maven里应该是这样子的\n\n搭建子模块spring6-ioc-xml\n在Spring6父工程中创建子模块，在子模块中的resources文件夹下创建配置文件–bean.xml\n创建相关的User类，以便后续测试使用，注意有分包的好习惯\npackage com.sakurapaid.spring.iocxml; public class User &#123;    private String name;    private int age;     public void test() &#123;        System.out.println(&quot;这是一个test测试输出~(￣▽￣)／&quot;);    &#125;&#125;\n\n\n\n获取bean实例首先在bean.xml配置文件中进行配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean id=&quot;user&quot; class=&quot;com.sakurapaid.spring.iocxml.User&quot;&gt;        &lt;/bean&gt;&lt;/beans&gt;\n\n在Spring的XML配置文件中，&lt;bean&gt;元素用于定义一个Bean实例。id 属性为 Bean 定义一个唯一标识符，可以通过这个标识符在其他地方引用这个 Bean 。class 属性指定了创建 Bean 实例时使用的类，它告诉 Spring 容器要实例化哪个类。\n例如，在示例中，&lt;bean id=&quot;user&quot; class=&quot;com.sakurapaid.spring.iocxml.User&quot;&gt;表示Spring将实例化一个com.sakurapaid.spring.iocxml.User类的 Bean，并将其标识符设置为”user”。（这样就省去了自己手动创建实例化对象相关的操作）\n其中与XML Schema相关的部分格式是固定的，我们只关注&lt;bean&gt;的配置\n\n每个&#96;&#96;都有一个id标识，相当于Bean的唯一ID；\n在userServiceBean中，通过&#96;&#96;注入了另一个Bean；\nBean的顺序不重要，Spring根据依赖关系会自动正确初始化。\n\n只不过Spring容器是通过读取XML文件后使用反射完成的。\n如果注入的不是Bean，而是boolean、int、String这样的数据类型，则通过value注入，例如，创建一个HikariDataSource：\n&lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;password&quot; /&gt;    &lt;property name=&quot;maximumPoolSize&quot; value=&quot;10&quot; /&gt;    &lt;property name=&quot;autoCommit&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;\n\n再创建一个相关的测试类UserTest.Java\npackage com.sakurapaid.spring.iocxml; public class UserTest &#123;    public static void main(String[] args) &#123;     &#125;&#125;\n\n根据id获取// 方式一：根据Bean的id获取实例User user1 = (User) context.getBean(&quot;user&quot;);System.out.println(user1);\n\n根据Bean的类型获取实例// 方式二：根据Bean的类型获取实例User user2 = (User) context.getBean(User.class);System.out.println(user2);\n\n根据Bean的id和类型获取实例//方式三：根据Bean的id和类型获取实例User user3 = context.getBean(&quot;user&quot;, User.class);System.out.println(user3);\n\n输出都是一样的\n/** * UserTest类用于演示通过XML配置文件进行Spring IOC（Inverse of Control）的简单示例。 */package com.sakurapaid.spring.iocxml; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserTest &#123;    /**     * 主函数入口，演示了三种方式从Spring容器中获取Bean实例。     */    public static void main(String[] args) &#123;        // 创建Spring容器，使用ClassPathXmlApplicationContext加载名为&quot;bean.xml&quot;的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);         // 方式一：根据Bean的id获取实例        User user1 = (User) context.getBean(&quot;user&quot;);        System.out.println(user1);         // 方式二：根据Bean的类型获取实例        User user2 = (User) context.getBean(User.class);        System.out.println(user2);         // 方式三：根据Bean的id和类型获取实例        User user3 = context.getBean(&quot;user&quot;, User.class);        System.out.println(user3);    &#125;&#125;// 输出/*com.ergoutree.User@48793befcom.ergoutree.User@48793befcom.ergoutree.User@48793bef*/\n\n在传统的编程方式中，我们通常需要在代码中通过 new 关键字创建对象实例，同时还需要手动管理对象之间的依赖关系。然而，在这段Spring的IoC示例中：\n我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：\n通过 ClassPathXmlApplicationContext 加载了名为 “bean.xml” 的Spring配置文件，这个配置文件中定义了Bean（这里是 User 类的实例）的创建方式和依赖关系。\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);\n\n然后，我们通过三种不同的方式从Spring容器中获取 User 类的实例：\n\n直接通过Bean的id（”user”）获取。\n根据Bean的类型（User.class）获取唯一匹配的Bean。\n同时指定Bean的id和类型获取实例。\n\n从Spring容器中“取出”装配好的Bean然后使用它\n// 获取Bean:UserService userService = context.getBean(UserService.class);// 正常调用:User user = userService.login(&quot;bob@example.com&quot;, &quot;password&quot;);\n\n在以上每步中，都没有直接执行 new User() 来创建对象，而是由Spring IoC容器负责创建并管理这些对象。这就是所谓的“控制反转”：对象的创建控制权从应用代码转移到了Spring容器，从而实现了对象的生命周期管理、依赖关系注入等高级功能，减少了代码之间的耦合度，增强了系统的可维护性和可扩展性。\n注意点当在Spring的IoC容器中配置了两个相同类型的Bean，会怎么样？\n当在Spring的IoC容器中配置了两个相同类型的Bean时，例如：\n&lt;bean id=&quot;user1&quot; class=&quot;com.ergoutree.spring.iocxml.User&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;user2&quot; class=&quot;com.ergoutree.spring.iocxml.User&quot;&gt;&lt;/bean&gt;\n\n这时，如果你试图仅根据类型(User.class)来获取Bean，Spring容器会因为无法确定具体应该返回哪个Bean实例而抛出异常。当Spring容器中存在多个同类型Bean定义时，若仅根据类型来查找，容器无法唯一确定应该返回哪一个Bean实例，因为按照类型查找期望得到的是唯一的匹配Bean。\n如果需要根据类型获取Bean，需要确保容器中对应类型的Bean只有一个，或者通过Bean的id来明确指定要获取的Bean。\n\n\n如果一个实现类实现了接口，根据接口类型可以获取 bean 吗？\n\nUserDao 接口\npublic interface UserDao &#123;    public void test();&#125;\n\nUserDaoImpl 实现类\npublic class UserDaoImpl implements UserDao &#123;    @Override    public void test()&#123;        System.out.println(&quot;UserDao01 test&quot;);    &#125;&#125;\n\nUserTest 添加\nUserDao bean = context.getBean(UserDao.class);        System.out.println(bean);        bean.test();\n\n最后运行抛出异常 因为 bean.xml 中没有进行配置\nException in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#x27;com.ergoutree.interf.UserDao&#x27; available\n\n因为UserDao是一个接口，接口是不能有自己的对象，只能由实现它的类userDaoImp01来创建对象，所以下面\n&lt;bean id=&quot;userDaoImp01&quot;   class=&quot;com.sakurapaid.spring.iocxml.interf.UserDaoImp01&quot;&gt;&lt;/bean&gt;\n\n&lt;bean&gt; 元素是用来声明和定义Spring IoC容器中托管的一个Bean实例。\nid&#x3D;”userDaoImp01”：这部分指定了在Spring容器中的Bean的唯一标识符，通过这个ID，你可以从容器中获取或引用这个Bean实例。\nclass=&quot;com.sakurapaid.spring.iocxml.interf.UserDaoImp01&quot;：这部分定义了Bean的实现类，即当 Spring 容器创建这个Bean 时，会使用这个类的信息来生成 Bean 的实例。尽管UserDao是个接口，但在实际应用中，我们需要通过其实现类UserDaoImp01 来创建对象，因为接口不能实例化，只有具体的实现类才能生成对象实例。\n此配置意味着Spring IoC容器将在启动时根据 UserDaoImp01 类的无参构造函数来创建一个Bean实例，并将其注册到容器中，之后在任何需要 UserDao 接口的地方，都可以通过 Spring 容器自动注入或通过 getBean 方法根据 Bean 的 ID（这里是”userDaoImp01”）来获取到这个实现了 UserDao 接口的具体实例。这就是Spring框架中的依赖注入（DI）机制。\n所以回答最上面的问题，如果就一个实现类实现了接口，根据接口类型可以获取 bean 吗？\n是的，如果只有一个实现类实现了接口，并且这个实现类已经在Spring的IoC容器中配置为一个Bean，那么根据接口类型是可以成功获取到对应的Bean实例的。\n前提条件：\n\n实现类已经在Spring配置文件（如：bean.xml）中被正确配置为一个Bean。\n配置时指定了实现类的全限定名作为class属性的值。\n在IoC容器中根据接口类型获取Bean时，容器中没有其他同样实现了该接口的Bean定义，即接口的实现类在容器中是唯一的。\n\n\n\n如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？\n\n不可以，如果一个接口有多个实现类，并且这些实现类都被配置成了Spring容器中的Bean，那么直接根据接口类型来获取Bean将会抛出NoUniqueBeanDefinitionException异常，因为Spring容器无法确定应该返回哪个Bean实例。\n例如，有两个实现类UserDaoImp01和UserDaoImp02都实现了UserDao接口，并且都在Spring配置文件中配置为Bean：\n&lt;bean id=&quot;userDaoImp01&quot; class=&quot;com.ergoutree.interf.UserDaoImp01&quot;/&gt;&lt;bean id=&quot;userDaoImp02&quot; class=&quot;com.ergoutree.interf.UserDaoImp02&quot;/&gt;\n\n相当于在Spring的IoC容器中配置了两个相同类型的Bean\n依赖注入之 setter 注入总体结构\n\n\n创建学生类Student\npublic class Student &#123;    private String name;    private int age;        public Student() &#123;&#125;     public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;     public String getName() &#123;        return name;    &#125;        public void setName(String name) &#123;        this.name = name;    &#125;     public int getAge() &#123;        return age;    &#125;     public void setAge(int age) &#123;        this.age = age;    &#125;     public String toString() &#123;        return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;&#125;&quot;;    &#125;&#125;\n\nbean-di.xml 配置文件\n这里的元素对应于Student类中的setter方法\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置student的name属性为&quot;ergoutree&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;ergoutree&quot;&gt; &lt;/property&gt;        &lt;!-- 设置student的age属性为18 --&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt; &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类\n当Spring容器读取并解析bean-di.xml配置文件时，会创建一个Student实例，并通过调用对应的setter方法（setName 和setAge），将值”ergoutree”注入到name属性，将值18注入到age属性，从而完成依赖注入。\npublic class StudentTest &#123;    @Test    public void test() &#123;        // 创建ClassPathXmlApplicationContext实例，并加载名为&quot;bean-di.xml&quot;的配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        // 通过上下文对象获取名为&quot;student&quot;的Bean实例，其类型为Student类        Student student = context.getBean(&quot;student&quot;, Student.class);        // 打印学生对象的信息        System.out.println(student);    &#125;&#125;\n\n\n\n\n\n\n\n依赖注入之构造器注入在Student类中添加有参构造\npublic Student(String name) &#123;&#125;\n\n配置bean-di.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置student的name属性为&quot;ergoutree&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;ergoutree&quot;&gt; &lt;/property&gt;        &lt;!-- 设置student的age属性为18 --&gt;        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt; &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;studentcon&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 通过构造器参数name传入值&quot;ergou&quot; --&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;ergou&quot;&gt; &lt;/constructor-arg&gt;        &lt;!-- 通过构造器参数age传入值&quot;19&quot; --&gt;        &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt; &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n这里使用了&lt;constructor-arg&gt;标签来指定构造函数的参数。根据注释，我们知道 Student 类应该有一个带有两个参数（name和age）的构造函数，类似于下面的Java代码：\npublic class Student &#123;    private String name;    private int age;     // 构造函数注入    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    // 省略其他代码...&#125;\n\nconstructor-arg标签还有两个属性可以进一步描述构造器参数：\nindex属性：指定参数所在位置的索引（从0开始）\nname属性：指定参数名\n测试方法\n@Test    public void test2() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        // 通过上下文对象获取名为&quot;student&quot;的Bean实例，其类型为Student类        Student student = context.getBean(&quot;studentcon&quot;, Student.class);        // 打印学生对象的信息        System.out.println(student);    &#125;\n\n当Spring容器加载并解析XML配置文件时，它会找到studentcon这个bean，并根据&lt;constructor-arg&gt;标签提供的信息，调用 Student 类的相应构造函数，传入”ergou”作为name参数，传入19作为age参数，从而创建并初始化Student实例。\n最终，通过context.getBean(&quot;studentcon&quot;, Student.class)获取到了通过构造器注入生成的Student实例，并将其打印出来。\n特殊值处理某些XML配置片段在Spring框架中的意义\n\n字面量赋值\n\n&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;\n\n在Spring的XML配置中，&lt;property&gt;标签是用来设置Bean属性值的。这里的value=&quot;张三&quot;就是将字面量“张三”赋给名为”name”的属性。这意味着当你在Bean中引用该属性时，它的值就是字符串”张三”，而不是一个变量或者表达式的结果。\n\n设置null值\n\n&lt;property name=&quot;name&quot;&gt;    &lt;null /&gt;&lt;/property&gt;\n\n这种方式是用来给Bean的属性设置 null 值的。与直接使用value=&quot;null&quot;不同，后者会被当作字符串”null”而非实际的Java null值处理。 &lt;null /&gt;标签告诉Spring容器将此属性值设为空引用。\n注意下面的这样写法\n&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;\n\n这样的写法，为name所赋的值是字符串null\n\nXML实体\n\n&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;\n\n在XML中，”&lt;” 和 “&gt;” 等特殊字符有特殊的含义，它们分别表示标签的开始和结束。如果你想在属性值中包含这样的字符，需要使用XML实体来转义。\n例如，XML实体如 &amp;lt 代替小于号 &lt; ，这样解析器就会知道这是一个小于符号，而不是标签的起始。XML实体如 &amp;gt代替大于号 &gt;\n\nCDATA节\n\nCDATA(Characters Data)是一种在XML文档中嵌入大段文本的方式，其中的内容不会被XML解析器解析为标记或实体。在这里，如果你的属性值可能包含大量的特殊字符或者需要包含XML语法结构，为了防止解析错误，可以将这部分内容放在&lt;![CDATA[ ... ]]&gt;之中。因此，&lt;![CDATA[a &lt; b]]&gt;意味着a&lt; b被当作纯文本对待，里面的 &quot;&lt;&quot;字符不会被解析成标签开始。\n为对象类型属性赋值示例准备工作\n\n\n部门类\npackage com.ergoutree.diobj;public class Department &#123;    private String name;    public void sout() &#123;        System.out.println(&quot;部门名: &quot; + name);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\n员工类\npackage com.ergoutree.diobj;public class Employee &#123;    private Department department;    private String name;    private int age;    public void work() &#123;        System.out.println(&quot;员工: &quot; + name + &quot;，年龄: &quot; + age);        department.sout();    &#125;    public Department getDepartment() &#123;        return department;    &#125;    public void setDepartment(Department department) &#123;        this.department = department;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n引用外部bean，配置 bean-diobj.xml\n&lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;这一行表示：当Spring容器初始化 “employee” 这个 Bean 时，会自动查找ID为”department”的Bean，并将该Bean的实例注入到 Employee 类的 department 属性上，实现了依赖注入。\n   &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;   &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;       &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;       &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;   &lt;/bean&gt;&lt;!--外部bean使用ref指定依赖所注入的对象--&gt;   &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;   &lt;bean id=&quot;employee&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;       &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;       &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;       &lt;!-- 设置员工年龄为 20 --&gt;       &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;       &lt;!--通过ref属性指定依赖注入的对象--&gt;       &lt;!-- 将该员工所属部门设置为 &quot;department&quot;，实现依赖注入 --&gt;       &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;   &lt;/bean&gt;\n\n测试输出\n在测试类EmployeeTest中，我们通过Spring应用上下文加载XML配置文件，然后获取”employee”这个Bean的实例，并调用其work方法。由于依赖注入已经完成，此时调用employee.work()方法时，不仅会输出员工的基本信息，还会通过注入的department对象输出部门名称。\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;employee&quot;, Employee.class);        employee.work();    &#125;&#125;\n\n总结起来，这种引用外部 bean 的方式就是在配置文件中通过 ref 属性指定了依赖对象，Spring 容器负责自动装配这些依赖关系，使得类之间的耦合度降低，提高了程序的可维护性和灵活性。\n内部bean内部bean（Inner Bean）是在Spring配置文件中直接定义并初始化的一个Bean，它不是顶级Bean（Root  Bean），而是作为另一个Bean的属性值出现。在给出的示例中，我们展示了如何通过内部bean的方式来注入Employee类的department属性。\n在bean配置上和内部bean有所区别，但能达到一样的效果\n在XML配置文件中，对于employee2这个Bean的定义，我们不再通过ref属性引用已经定义好的外部Bean，而是直接在其department属性内部定义一个新的Department Bean。\n这里的新Department Bean没有显式定义ID，因为它是一个内部Bean，由Spring容器自动生成一个唯一的ID。同时，它拥有自己的属性设置，如name属性被设置为”开发部”。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;!--外部bean方式--&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;employee1&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;    &lt;/bean&gt;        &lt;!--内部bean方式--&gt;    &lt;bean id=&quot;employee2&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot;&gt;               &lt;bean class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;                   &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;               &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;  &lt;/beans&gt;\n\n当Spring容器加载配置文件并初始化 employee2 这个Bean时，它会发现 department 属性需要注入一个 Department 类型的 Bean 。于是，它会在当前上下文中查找匹配的 Bean 定义，发现内部定义的 Department Bean，然后创建并初始化这个内部 Bean，并将其实例注入到 employee2 的 department 属性上。\n在测试类 EmployeeTest 中，我们仅获取并操作了使用内部 bean 方式注入的 Employee 实例（employee2），同样能够达到与外部 bean 方式相同的效果，即输出员工基本信息以及所属部门名称。\n内部 bean 方式的优势在于可以在同一个配置块内清晰地展示和组织 Bean 之间的依赖关系，简化配置文件结构。但在某些场景下，如果某个 Bean 会被多个其他 Bean 共享，使用外部 bean 并通过 ref 引用则更为合适。\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;employee2&quot;, Employee.class);        employee.work();    &#125;&#125;\n\n级联属性赋值不常用\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;!--外部bean方式--&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;employee1&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;    &lt;/bean&gt;        &lt;!--内部bean方式--&gt;    &lt;bean id=&quot;employee2&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;property name=&quot;department&quot;&gt;               &lt;bean class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;                   &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;               &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;!--级联属性赋值--&gt;    &lt;bean id=&quot;department3&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Department&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;employee3&quot; class=&quot;com.sakurapaid.spring.iocxml.diobj.Employee&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!-- 级联属性赋值，直接为 employee3 的属性赋值 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;department3&quot;/&gt;        &lt;property name=&quot;department.name&quot; value=&quot;测试部&quot;/&gt;    &lt;/bean&gt; &lt;/beans&gt;\n\n级联属性赋值是针对对象类型属性的进一步操作，当一个 Bean 的属性是另一个对象类型时，我们不仅可以为这个对象属性赋值，还可以直接为该对象属性的内部属性进行赋值。\n在单独的 &lt;bean&gt;标签中，把 bean 对象所依赖的类通过  &lt;property&gt; 中标出，也是使用 ref\n级联属性赋值时，要确保被赋值的对象属性已经正确实例化\n级联属性赋值的优先级高于直接在被引用的 Bean 中设置的属性值，即后配置的值会覆盖前面已配置的值。\n\n为数组类型属性赋值修改Employee员工类\n主要是新增了数组成员和及其输出\npublic class Employee &#123;    private Department department;    private String name;    private int age;    private String[] hobby;    public Employee() &#123;&#125;    public Employee(Department department, String name, int age, String[] hobby) &#123;        this.department = department;        this.name = name;        this.age = age;        this.hobby = hobby;    &#125;    public void work() &#123;        System.out.println(&quot;员工: &quot; + name + &quot;，年龄: &quot; + age);        department.sout();        // 遍历数组        System.out.println(Arrays.toString(hobby));    &#125;    public Department getDepartment() &#123;        return department;    &#125;    public void setDepartment(Department department) &#123;        this.department = department;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String[] getHobby() &#123;        return hobby;    &#125;    public void setHobby(String[] hobby) &#123;        this.hobby = hobby;    &#125;    public String toString() &#123;        return &quot;Employee&#123;department = &quot; + department + &quot;, name = &quot; + name + &quot;, age = &quot; + age + &quot;, hobby = &quot; + hobby + &quot;&#125;&quot;;    &#125;&#125;\n\n编辑 spring 配置文件\n&lt;property&gt;标签用于设置 Employee 类中对应的属性值。对于数组类型的&quot;hobby&quot;属性，我们使用了&lt;array&gt;标签来进行嵌套注入。在&lt;array&gt;标签内部，通过多个&lt;value&gt;标签来分别指定数组中的每个元素值。\n所以当Spring容器创建&quot;employee&quot;这个 Bean 时，它会自动将这些值注入到 Employee 对象的 “hobby” 数组属性中，最终得到的数组内容即为 [“吃饭”, “睡觉”, “打gal”] 。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;    &lt;bean id=&quot;employee&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置员工年龄为 20 --&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!--通过ref属性指定依赖注入的对象--&gt;        &lt;!-- 将该员工所属部门设置为 &quot;department&quot;，实现依赖注入 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;department&quot;/&gt;                &lt;property name=&quot;hobby&quot;&gt;            &lt;array&gt;                &lt;value&gt;吃饭&lt;/value&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;打gal&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试输出\n\n\n\n为集合类型属性赋值为 List 集合类型属性赋值修改Department部门类\n多了个List集合，一个部门有很多人，再定义个输出方法\nimport java.util.List;public class Department &#123;    //一个部门有很多人    private List&lt;Employee&gt; employees;    //部门名称    private String name;    public void sout() &#123;        System.out.println(&quot;部门名: &quot; + name);        for (Employee emp : employees)&#123;            System.out.println(emp.getName());        &#125;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public List&lt;Employee&gt; getEmployees() &#123;        return employees;    &#125;    public void setEmployees(List&lt;Employee&gt; employees) &#123;        this.employees = employees;    &#125;&#125;\n\n定义 Spring 配置文件\n两个员工 bean 和一个部门 bean\n在 XML 配置文件中，首先定义了两个 Employee 类型的 Bean（emp1和emp2），它们分别具有不同的属性值，包括名字、年龄和兴趣爱好列表（hobby）。这里的 hobby 属性是一个列表类型，使用&lt;list&gt;标签进行配置，通过多个&lt;value&gt;子标签为列表添加元素。\n然后，定义了一个 Department 类型的 Bean（dept），它具有一个名字属性和一个 employees 集合属性。employees 属性也是一个列表类型，用于存放 Department 下的多个 Employee 对象。这里使用&lt;list&gt;标签，并通过&lt;ref&gt;子标签引用前面定义好的 Employee Bean（emp1和emp2），从而将这两个 Employee 对象注入到 Department 的 employees 集合属性中。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个部门 bean，命名为 &quot;department&quot; --&gt;    &lt;bean id=&quot;department&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 设置部门名称为 &quot;开发部&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;开发部&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 定义一个员工 bean，命名为 &quot;employee&quot; --&gt;    &lt;bean id=&quot;emp1&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 设置员工姓名为 &quot;张三&quot; --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置员工年龄为 20 --&gt;        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;        &lt;!--通过ref属性指定依赖注入的对象--&gt;        &lt;!-- 将该员工所属部门设置为 &quot;dept&quot;，实现依赖注入 --&gt;        &lt;property name=&quot;department&quot; ref=&quot;dept&quot;/&gt;        &lt;property name=&quot;hobby&quot;&gt;            &lt;array&gt;                &lt;value&gt;吃饭&lt;/value&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;打gal&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 定义另一个员工对象，员工2 --&gt;    &lt;bean id=&quot;emp2&quot; class=&quot;com.ergoutree.diobj.Employee&quot;&gt;        &lt;!-- 员工的名字 --&gt;        &lt;property name=&quot;name&quot; value=&quot;Lucy&quot; /&gt;        &lt;!-- 员工的年龄 --&gt;        &lt;property name=&quot;age&quot; value=&quot;21&quot; /&gt;        &lt;!-- 员工的爱好，以列表形式 --&gt;        &lt;property name=&quot;hobby&quot;&gt;            &lt;list&gt;                &lt;value&gt;睡觉&lt;/value&gt;                &lt;value&gt;学习&lt;/value&gt;                &lt;value&gt;吃饭&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 定义一个部门对象 --&gt;    &lt;bean id=&quot;dept&quot; class=&quot;com.ergoutree.diobj.Department&quot;&gt;        &lt;!-- 部门的名字 --&gt;        &lt;property name=&quot;name&quot; value=&quot;财政部&quot; /&gt;        &lt;!-- 部门下的员工列表 --&gt;        &lt;property name=&quot;employees&quot;&gt;            &lt;list&gt;                &lt;!-- 引用员工1对象 --&gt;                &lt;ref bean=&quot;emp1&quot; /&gt;                &lt;!-- 引用员工2对象 --&gt;                &lt;ref bean=&quot;emp2&quot; /&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试输出\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class EmployeeTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diobj.xml&quot;);        Employee employee = context.getBean(&quot;emp1&quot;, Employee.class);        employee.work();        Department dept = context.getBean(&quot;dept&quot;, Department.class);        dept.sout();    &#125;&#125;\n\n\n\n为Map集合类型赋值修改 student 类，添加一个 Map 类型的属性，用于存储学生的课程和对应的成绩\npackage com.ergoutree.di;import java.util.Map;public class Student &#123;    private String name;    private int age;    private Map&lt;String, Integer&gt; scores;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public Student(String name) &#123;&#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Map&lt;String, Integer&gt; getScores() &#123;        return scores;    &#125;    public void setScores(Map&lt;String, Integer&gt; scores) &#123;        this.scores = scores;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, scores=&quot; + scores + &quot;&#125;&quot;;    &#125;&#125;\n\n修改 bean-di.xml\n&lt;bean id=&quot;student2&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;        &lt;!-- 设置学生姓名 --&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;        &lt;!-- 设置学生的成绩 Map --&gt;        &lt;property name=&quot;scores&quot;&gt;            &lt;map&gt;                &lt;!-- 键值对：课程名和对应的成绩 --&gt;                &lt;entry key=&quot;数学&quot; value=&quot;90&quot;/&gt;                &lt;entry key=&quot;英语&quot; value=&quot;85&quot;/&gt;                &lt;entry key=&quot;语文&quot; value=&quot;88&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;\n\n\n&lt;map&gt; 标签：用于定义一个 Map 集合，在 标签内部使用 标签来定义 Map 中的键值对。\n&lt;entry&gt; 标签：key 属性指定键，value 属性指定值。这里的键和值都是基本数据类型（字符串和整数）\n键和值的类型：在 &lt;entry&gt; 标签中，key 和 value 属性的值会根据 Bean 属性的类型自动进行类型转换。如果键或值是复杂对象，你可以使用 key-ref 和 value-ref 引用其他 Bean。\n\n测试\n@Test    public void test3() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);        Student student = context.getBean(&quot;student2&quot;, Student.class);        System.out.println(student);    &#125;// 输出// Student&#123;name=&#x27;张三&#x27;, scores=&#123;数学=90, 英语=85, 语文=88&#125;&#125;\n\n引用集合类型的 bean修改学生类\n新增一个 List 集合，管理课程\npackage com.ergoutree.di;import java.util.*;public class Student &#123;    private String name;    private int age;    private Map&lt;String, Integer&gt; scores;    private int stu_id;    private List&lt;Lesson&gt; listLessons;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void sout()&#123;        // 输出学生的基本信息        System.out.println(&quot;学生id : &quot; + stu_id + &quot;, &quot; +                &quot;学生姓名 : &quot; + name);        System.out.println();        // 输出课程集合        System.out.print(&quot;课程集合 : &quot;);        for(Lesson lesson : listLessons)&#123;            System.out.print(lesson.getLessonName() + &quot; &quot;);        &#125;    &#125;    public Student(String name) &#123;&#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;        public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Map&lt;String, Integer&gt; getScores() &#123;        return scores;    &#125;    public void setScores(Map&lt;String, Integer&gt; scores) &#123;        this.scores = scores;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#x27;&quot; + name + &quot;&#x27;, scores=&quot; + scores + &quot;&#125;&quot;;    &#125;&#125;\n\n对应的Lesson类\npublic class Lesson &#123;    private String lessonName;    public String getLessonName() &#123;        return lessonName;    &#125;    public void setLessonName(String lessonName) &#123;        this.lessonName = lessonName;    &#125;&#125;\n\n配置Spring文件\n使用util:list、util:map标签必须引入相应的命名空间\n代码样式放在上的，需要用时直接复制粘贴即可\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util    http://www.springframework.org/schema/util/spring-util.xsd    http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n&lt;bean id=&quot;studentcon&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;!-- 通过构造器参数name传入值&quot;ergou&quot; --&gt;       &lt;constructor-arg name=&quot;name&quot; value=&quot;ergou&quot;&gt; &lt;/constructor-arg&gt;       &lt;!-- 通过构造器参数age传入值&quot;19&quot; --&gt;       &lt;constructor-arg name=&quot;age&quot; value=&quot;19&quot;&gt; &lt;/constructor-arg&gt;   &lt;/bean&gt;   &lt;bean id=&quot;student2&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;!-- 设置学生姓名 --&gt;       &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;       &lt;!-- 设置学生的成绩 Map --&gt;       &lt;property name=&quot;scores&quot;&gt;           &lt;map&gt;               &lt;!-- 键值对：课程名和对应的成绩 --&gt;               &lt;entry key=&quot;数学&quot; value=&quot;90&quot;/&gt;               &lt;entry key=&quot;英语&quot; value=&quot;85&quot;/&gt;               &lt;entry key=&quot;语文&quot; value=&quot;88&quot;/&gt;           &lt;/map&gt;       &lt;/property&gt;   &lt;/bean&gt;   &lt;bean id=&quot;student3&quot; class=&quot;com.ergoutree.di.Student&quot;&gt;       &lt;property name=&quot;stu_id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;name&quot; value=&quot;王昊&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;listLessons&quot; ref=&quot;listlessons&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!--新建的lesson bean--&gt;   &lt;bean id=&quot;lesson1&quot; class=&quot;com.ergoutree.di.Lesson&quot;&gt;       &lt;property name=&quot;lessonName&quot; value=&quot;liang_zi_qi&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;bean id=&quot;lesson2&quot; class=&quot;com.ergoutree.di.Lesson&quot;&gt;       &lt;property name=&quot;lessonName&quot; value=&quot;wanghao&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;   &lt;!--课程列表包含bean--&gt;   &lt;util:list id=&quot;listlessons&quot;&gt;       &lt;ref bean=&quot;lesson1&quot;&gt;&lt;/ref&gt;       &lt;ref bean=&quot;lesson2&quot;&gt;&lt;/ref&gt;   &lt;/util:list&gt;\n\n测试\nimport org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; public class MapAndListTest &#123;    @Test    public void test()&#123;        // 加载名为&quot;bean-diMapAndList.xml&quot;的XML配置文件，创建ApplicationContext上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-diMapAndList.xml&quot;);        // 从上下文中获取名为&quot;student&quot;的Bean实例，其类型为Student        Student student = context.getBean(&quot;student&quot;, Student.class);        // 调用Student实例的sout方法，输出相关信息        student.sout();    &#125;&#125;\n\n\n\n\n由于篇幅太长，转到 下篇\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework part3-IoC基于XML管理Bean下篇","url":"/posts/55768.html","content":"接着上篇进行\n\np 命名空间引入 p 命名空间\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util       http://www.springframework.org/schema/util/spring-util.xsd       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n引入p命名空间后，可以通过以下方式为bean的各个属性赋值\n&lt;!-- p命名空间方式 --&gt;    &lt;bean id=&quot;student1&quot; class=&quot;com.ergoutree.di.Student&quot;          p:stu_id=&quot;1411&quot; p:name=&quot;李四&quot; p:listLessons-ref=&quot;lesson1&quot; p:mapTeachers-ref=&quot;mapTeachers&quot;&gt;    &lt;/bean&gt;\n\n测试后依旧成立\n\n引入外部属性文件在Spring框架中，引入外部属性文件是一种管理应用程序配置的有效方法。当我们在Spring的 XML 配置文件中直接编写大量的固定配置信息（如数据库用户名、密码、URL，或是服务器IP地址、端口号等），这些信息如果频繁变动，将会使得配置文件变得难以维护，而且每当配置信息发生变化时，开发人员就需要打开源代码去修改XML配置文件，然后再重新打包部署项目，这是一个繁琐的过程。\n为了解决这个问题，Spring 支持将这些容易变化的配置项提取出来，存放在单独的 properties 文件中，如database.properties 或 application.properties 。这些文件通常包含键值对的形式，例如\ndatabase.properties文件\ndb.username=admindb.password=secretpassworddb.url=jdbc:mysql://localhost:3306/mydatabase\n\n接下来，在Spring的XML配置文件中，我们可以使用PropertyPlaceholderConfigurer（在较旧版本中）或&lt;context:property-placeholder&gt;（在Spring 3.1及以上版本推荐使用）来引入和解析这些外部属性文件：\n&lt;!-- Spring 3.1+ 使用context命名空间简化引入 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;...&quot;&gt;          &lt;!-- 引入外部属性文件 --&gt;   &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;    &lt;!-- 使用外部属性文件中的值注入Bean --&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;       &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;       &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;       &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;   &lt;/bean&gt;&lt;/beans&gt;\n\n这样一来，当数据库的连接信息需要变更时，我们只需要修改database.properties文件，而不需要碰触到Spring的XML配置文件或Java代码。这样既实现了配置的模块化，又增强了配置的可维护性，同时降低了因配置变更导致的应用程序整体重新部署的频率。\n此外，这种模式还可以方便地根据不同的环境（如开发、测试、生产）切换不同的配置文件，实现灵活部署。\n\nbean作用域&#x2F;生命周期作用域\n在Spring框架中，Bean（Java对象）的作用域指的是在应用程序的整个生命周期中，对于某个特定的Bean对象，Spring容器是如何管理和创建其实例的。Bean 的作用域决定了容器在何时以及如何创建Bean实例，以及这些实例之间的关系。\n\n\n\n取值\n含义\n创建对象\n\n\n\nsingleton（默认）单实例\n在IOC容器中，这个bean的对象始终为单实例\nIOC容器初始化时\n\n\nprototype  多实例\n这个bean在IOC容器中有多个实例\n获取bean时\n\n\n如果实在 WebApplicationContext 环境下还有几个作用域\n\n\n\n取值\n含义\n\n\n\nrequest\n在一个请求范围内有效\n\n\nsession\n在一个会话范围内有效\n\n\nsingleton 作用域：\n\n含义：当指定一个Bean为singleton时，Spring容器会在启动时创建该Bean的一个实例，并在整个容器的生命周期内，任何对该Bean的请求都将返回同一个共享的实例。这意味着不论有多少个地方请求该Bean，始终只会有一个Bean实例存在。\n创建对象的时机： Spring容器在初始化时（加载配置文件并创建Bean的过程中），就会创建singleton作用域的Bean实例。\n\nprototype 作用域：\n\n含义： 当指定一个Bean为prototype时，每次客户端请求一个Bean时，Spring容器都会创建一个新的Bean实例，也就是说，每次getBean()方法被调用时都会产生一个新的对象实例。\n创建对象的时机： prototype作用域的Bean实例是在客户端请求时创建的，即每次调用ApplicationContext.getBean()方法请求一个prototype类型的Bean时，Spring容器才会创建新的实例。\n\n示例：\n新建 Order 类\npublic class Order &#123;&#125;\n\n新建 bean-scope.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--单实例对象演示 通过 scope 属性配置单实例还是多实例--&gt;    &lt;bean id=&quot;order&quot; class=&quot;com.ergoutree.scope.Order&quot; scope=&quot;singleton&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n新建 TestOrder\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestOrder &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-scope.xml&quot;);        // 单实例对象，输出地址相同        Order order = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order);        Order order2 = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order2);    &#125;&#125;\n\n可以发现输出地址是一样的，单实例对象\n然而带上多实例对象，发现并非是一个实例化的对象\npublic class TestOrder &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-scope.xml&quot;);        // 单实例对象，输出地址相同        Order order = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order);        Order order2 = context.getBean(&quot;order&quot;, Order.class);        System.out.println(order2);        // 多实例对象        Order order3 = context.getBean(&quot;order2&quot;, Order.class);        System.out.println(order3);        Order order4 = context.getBean(&quot;order2&quot;, Order.class);        System.out.println(order4);    &#125;&#125;\n\n输出结果\ncom.ergoutree.scope.Order@7b8b43c7com.ergoutree.scope.Order@7b8b43c7com.ergoutree.scope.Order@44c73c26com.ergoutree.scope.Order@41005828\n\n\n生命周期关于Bean的生命周期：除了Bean的作用域之外，Bean还有一个完整的生命周期，它包括以下几个阶段：\n\n实例化（Instantiation）：\n\n这是Bean生命周期的起点，类似于开始备料，即调用Bean的无参构造函数创建Bean实例。Spring容器通过反射机制找到合适的构造函数并创建Bean对象。\n\n\n依赖注入（Dependency Injection，DI）：\n\n类似于加入必要的调料，Spring容器根据配置信息，通过setter方法、构造函数注入或其他注解方式（如@Autowired）将Bean依赖的其他对象注入到当前Bean中。\n\n\nBean的后置处理器（Post Processor Before Initialization）：\n\n在Bean初始化之前，Spring容器会对Bean进行一系列额外的处理。例如，Spring的BeanPostProcessor接口提供了两个方法postProcessBeforeInitialization()和postProcessAfterInitialization()，在这一步骤中，Spring会调用postProcessBeforeInitialization()方法对Bean进行自定义的预处理。\n\n\n初始化（Initialization）：\n\n此阶段相当于烹饪前的准备工作，如预热烤箱。Spring容器在完成所有依赖注入后，会检查Bean是否实现了InitializingBean接口，若实现了则调用afterPropertiesSet()方法；或者在配置文件中通过init-method属性指定了初始化方法，此时Spring容器会调用该方法对Bean进行初始化。\n\n\nBean的后置处理器（Post Processor After Initialization）：\n\n初始化完成后，Spring容器会调用postProcessAfterInitialization()方法进一步处理Bean。这一阶段可用于在Bean正式投入使用前进行一些补充性的定制化工作。\n\n\n使用（Use）：\n\n到了这个阶段，Bean就如同完成烹饪的菜肴一样，已经准备好供客户（应用程序）使用。通过Spring容器的getBean()方法，可以在应用程序中任意位置获取并使用这个Bean实例。\n\n\n销毁（Destruction）：\n\n当Bean不再需要时，比如应用程序关闭或容器被销毁时，Spring容器会触发Bean的销毁过程。如果Bean实现了DisposableBean接口，则调用destroy()方法；或者在配置文件中通过destroy-method属性指定了销毁方法，Spring容器会调用该方法释放资源，如关闭数据库连接、清除缓存等，这就好比客人用餐结束后清理餐具、打扫卫生。\n\n\nIOC容器关闭：\n\n当整个IoC容器需要关闭时，所有处于singleton作用域的Bean都会经历销毁阶段，以确保相关资源得到妥善释放，整个容器生命周期结束。\n\n\n\n总的来说，在Spring框架中，Bean的作用域是指Bean实例的创建策略，而生命周期则是指Bean实例从创建到销毁的过程。通过理解并合理配置Bean的作用域和生命周期，可以更好地管理和控制Bean实例的行为，提高应用效率和资源利用率。\n示例：\n创建 Applyskd 类\npublic class Applyskd &#123;    private String name;    //初始化方法    public void init() &#123;        System.out.println(&quot;生命周期：3、初始化~&quot;);    &#125;    //销毁方法    public void destroy() &#123;        System.out.println(&quot;生命周期：5、销毁~&quot;);    &#125;    public Applyskd() &#123;        System.out.println(&quot;生命周期：1、创建对象~&quot;);    &#125;    public Applyskd(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;生命周期：2、依赖注入~&quot;);        this.name = name;    &#125;    public String toString() &#123;        return &quot;User&#123;name = &quot; + name + &quot;&#125;&quot;;    &#125;&#125;\n\n创建 xml 配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 定义一个名为&quot;user&quot;的Bean，对应于com.ergoutree.liferoutine.Applyskd类 --&gt;    &lt;!-- 该Bean的生命周期由Spring容器管理 --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.ergoutree.liferoutine.Applyskd&quot;          scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;sakura&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 注解解释：    id属性：为Bean定义一个唯一标识符；    class属性：指定Bean的实现类；    scope属性：定义Bean的作用域，此处为&quot;singleton&quot;，表示该Bean在容器中只存在一个实例；    init-method属性：指定Bean初始化时要执行的方法，此处为&quot;init&quot;；    destroy-method属性：指定Bean销毁时要执行的方法，此处为&quot;destroy&quot;。 --&gt;&lt;/beans&gt;\n\n测试结果\npublic class Test &#123;    @org.junit.jupiter.api.Test    public void test() &#123;        //想要实现bean生命周期的销毁，需要使用ClassPathXmlApplicationContext        //而不是用ApplicationContext，它里面没有destroy方法        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-lifeRoutine.xml&quot;);        Applyskd bean = context.getBean(Applyskd.class);        System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用~&quot;);        bean.destroy();    &#125;&#125;/*生命周期：1、创建对象~生命周期：2、依赖注入~生命周期：3、初始化~生命周期：4、通过IOC容器获取bean并使用~生命周期：5、销毁~*/\n\n\n基于 xml 自动装配自动装配：\n\n根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值\n\nSpring 自动装配：\n\n它能在背后悄悄帮你处理Bean之间的关联关系。当你定义了一些Bean，并告诉Spring使用自动装配时，Spring会在创建这些Bean时，自动找出并填充它们所需要的依赖对象。\n打个比方，假设你在装修房子，有电工、木工和油漆工三个工种。如果没有自动装配，你需要亲自安排电工去做电线安装，木工去做家具组装，油漆工去做刷漆工作。而有了自动装配功能，你只需要告诉Spring哪个房间需要装修，Spring会根据每个工人的技能（电工擅长电，木工擅长木工活，油漆工擅长刷漆）自动分配任务，不需要你一一指定谁去做什么。\n在Spring中，不同的自动装配策略相当于不同的分工规则，比如按名字找合适的工人（byName）、按工种找合适的工人（byType）等。这样，你就可以更加专注于整体的设计和规划，而无需过于关注每个细小环节的具体实施。\n\n主要有如下几种自动装配的策略：\n\nbyName\nSpring容器会根据Bean的属性名查找IoC容器中ID（或name）与该属性名相同的Bean进行注入。\nSpring会看你的Bean缺少什么“工具”，然后去查找名字一样的工具。\n\n\nbyType:\nSpring容器会查找IoC容器中类型与待注入属性类型匹配的Bean进行注入。如果有多个类型匹配的Bean，则会抛出异常，除非其中一个被标记为主Bean。\nSpring会根据你的Bean需要的工具类型，去找仓库里拥有同样类型的工具。\n\n\nconstructor\n类似于byType，但专门针对构造函数参数，根据构造函数参数类型查找并注入Bean。\n当你创建Bean时，Spring会检查构造函数需要哪些工具，然后自动提供正确的工具。\n\n\ndefault &#x2F; no\n这是默认策略，表示不进行自动装配，所有依赖都需要显式配置。\n如果关闭自动装配，那就得你自己一个个地把工具交给Bean。\n\n\n\n通过启用自动装配功能，Spring可以帮助开发者减少大量手动配置依赖注入的工作，提高开发效率，同时保持代码结构清晰。不过，过度依赖自动装配可能会导致问题不易排查，因此在实际项目中应合理权衡是否使用自动装配以及选择哪种装配策略。\n总之，自动装配就是Spring帮你自动完成对象间的依赖关系建立，让你编写代码时更轻松，不过要注意避免因自动装配带来的不确定性，适当地结合显式配置更为稳健。\n代码示例：\n做一个UserController、UserService、UserDao三层之间的实际场景模拟\n创建UserController\npublic class UserController &#123;    //生成service层对象    private UserService userService;    //设置service属性set方法    public void setUserService(UserService userService)    &#123;        this.userService = userService;    &#125;    public void conMethod()&#123;        //调用service层方法        userService.setMethod();        System.out.println(&quot;UserController方法执行了~&quot;);    &#125;&#125;\n\n创建 UserDao 接口 和 UserDaoImpl 实现类\npublic interface UserDao &#123;    public void method();&#125;\n\npublic class UserDaoImpl implements UserDao &#123;    @Override    public void method() &#123;        System.out.println(&quot;UserDao方法执行了~&quot;);    &#125;&#125;\n\n创建UserService 接口 和 UserServiceImpl 实现类\npublic interface UserService &#123;    public void setMethod();&#125;\n\npublic class UserServiceImpl implements UserService &#123;    //生成dao层对象    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void setMethod() &#123;        //调用dao层方法        userDao.method();        System.out.println(&quot;UserService方法执行了~&quot;);    &#125;&#125;\n\n上面的都还是准备工作，现在就实现真正的自动装配\n使用bean标签的autowire属性设置自动装配效果根据类型进行自动装配–byType\n若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null\n若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException\n配置spring bean xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;controller&quot; class=&quot;com.ergoutree.user.UserController&quot; autowire=&quot;byType&quot;&gt;    &lt;/bean&gt;    &lt;bean id=&quot;service&quot; class=&quot;com.ergoutree.user.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;            &lt;/bean&gt;    &lt;bean id=&quot;dao&quot; class=&quot;com.ergoutree.user.UserDaoImpl&quot; autowire=&quot;byType&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n根据属性名进行自动装配–byName\n配置spring bean\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;controller&quot; class=&quot;com.ergoutree.user.UserController&quot; autowire=&quot;byName&quot;&gt;    &lt;/bean&gt;    &lt;bean id=&quot;service&quot; class=&quot;com.ergoutree.user.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;            &lt;/bean&gt;    &lt;bean id=&quot;dao&quot; class=&quot;com.ergoutree.user.UserDaoImpl&quot; autowire=&quot;byName&quot;&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试结果\nclass autoTest &#123;    @Test    public void test() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-user.xml&quot;);        UserController controller = (UserController) context.getBean(&quot;controller&quot;);        controller.conMethod();    &#125;&#125;\n\n\n\nApplicationContext我们从创建Spring容器的代码：\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-user.xml&quot;);\n\n可以看到，Spring容器就是ApplicationContext，它是一个接口，有很多实现类，这里我们选择ClassPathXmlApplicationContext，表示它会自动从classpath中查找指定的XML配置文件。\n获得了ApplicationContext的实例，就获得了IoC容器的引用。从ApplicationContext中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：\nUserService userService = context.getBean(UserService.class);\n\nSpring还提供另一种IoC容器叫BeanFactory，使用方式和ApplicationContext类似\nBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;application.xml&quot;));MailService mailService = factory.getBean(MailService.class);\n\nBeanFactory和ApplicationContext的区别在于，BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean。实际上，ApplicationContext接口是从BeanFactory接口继承而来的，并且，ApplicationContext提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用ApplicationContext，很少会考虑使用BeanFactory。\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringFrameworkPart4-IoC基于注解管理bean","url":"/posts/29786.html","content":"IoC 基于注解方式操作 Bean 管理使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。\n使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。\n我们可以使用Annotation配置\n基于注解配置 Bean在Spring中，基于注解方式配置Bean，主要应用于项目开发中的组件，eg : Controller, Service, DAO.\n常用的组件注解的形式有——\n\n@Component : 表示当前注解标识的是一个组件，相当于定义了一个Bean，它有一个可选的名称，默认是mailService，即小写开头的类名。\n@Controller : 表示当前注解标识的是一个控制器，通常用于Servlet\n@Service : 表示当前注解标识的是一个处理业务逻辑的类，通常用于Service。\n@Repository : 表示当前注解标识的是一个持久化层的类，通常用于DAO类。\n\n应用实例\n首先，在已有jar包的基础上，各种依赖\n我们依旧根据“Web层调用Service层，Service层调用DAO层”的分层设计思想，分别在web, service, dao包下新建PotUserServlet, PotUserServiceImpl, PotUserDAOImpl类；并在component包下新建一个CyanComponent类\nPotUserServlet类代码如下 : （使用@Controller注解标记）\nimport org.springframework.stereotype.Controller;@Controllerpublic class PotUserServlet &#123;&#125;\n\n PotUserServiceImpl类代码如下 : (使用@Service注解标记)\nimport org.springframework.stereotype.Service;@Servicepublic class PotUserServiceImpl &#123;&#125;\n\nPotUserDAOImpl类代码如下 : (使用@Repository注解标记)\nimport org.springframework.stereotype.Repository;@Repositorypublic class PotUserDAOImpl &#123;&#125;\n\n新建一个配置文件beans_annotation.xml，在配置文件中通过context命名空间配置自动扫描，格式如下 &lt;context:component-scan base-package=&quot;...&quot;/&gt;其中\n\ncontext:component-scan表示配置对指定包的自动扫描，并创建对象到容器；\n属性base-package表示被扫描的包；\n配置达到的效果是：Spring 容器创建时，就会扫描base-package对应包下所有的用@Controller, @Service, @Repository, @Component注解标记的类，并将其实例化，放入到IOC容器中。\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.web&quot;/&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.service&quot;/&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.dao&quot;/&gt;&lt;/beans&gt;\n\n接着，新建一个测试类，用于定义进行单元测试的方法。 TestBeanByAnnotation类代码如下\n@SpringBootTestclass SpringNoteBeanApplicationTests &#123;    @Test    public void annotationIntro() &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans_annotation.xml&quot;);        /*            PS :            基于注解配置创建的Bean对象，默认id是类名首字母小写。            eg : PotUserServlet类Bean对象的id = potUserServlet.         */        PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);        PotUserServiceImpl potUserServiceImpl = ioc.getBean(&quot;potUserServiceImpl&quot;, PotUserServiceImpl.class);        PotUserDAOImpl potUserDAOImpl = ioc.getBean(&quot;potUserDAOImpl&quot;, PotUserDAOImpl.class);        System.out.println(&quot;potUserServlet = &quot; + potUserServlet);        System.out.println(&quot;potUserServiceImpl = &quot; + potUserServiceImpl);        System.out.println(&quot;potUserDAOImpl = &quot; + potUserDAOImpl);    &#125;&#125;/*输出如下potUserServlet = edu.software.ergoutree.springnotebean.web.PotUserServlet@fe87dddpotUserServiceImpl = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@4eea94a4potUserDAOImpl = edu.software.ergoutree.springnotebean.dao.PotUserDAOImpl@7c281eb */\n\n注意后面@之后的内容\n注意事项：\n\n若想配置自动扫描一个包下所有的子包，可以使用通配符 * 来指定。eg : &lt;context:component-scan base-package=&quot;com.cyan.spring.*&quot;/&gt;，表示会自动扫描com.cyan.spring包下所有的子包。即使不使用通配符 * ，Spring IOC容器也会默认扫描base-package所指定包的全部子包。\n\n**Spring的IOC容器不能检测一个使用了@Controller注解的类究竟是否为一个控制器（其他注解同理），即注解的名称只是用于程序员自己识别当前标识的组件类型，Spring IOC容器只要扫描到注解标识的类就会创建其对象，并不会去识别注解的含义。\n\ncontext:component-scan亦可支持只扫描满足特定要求的类，需要用到resource-pattern属性，格式为: resource-pattern&#x3D;”特定要求”&#x2F;&gt;.  eg：&lt;context:component-scan base-package&#x3D;”com.cyan.spring.web” resource-pattern&#x3D;”Pot*.class”&#x2F;&gt; 表示只扫描com.cyan.spring.web包下的以”Pot”开头的类。\n\nSpring IOC容器还支持扫描时指定过滤某些类 以及 在扫描时指定扫描某些类。\n\n指定过滤某些类 : 通过&lt;context:exclude-filter/&gt;标签来指定（该标签要放在&lt;context:component-scan&gt;标签内），其中，type属性表示根据什么规则来进行过滤，expression属性则表示具体要过滤的类型。\n&lt;!--    (1) context:component-scan表示配置自动扫描，        base-package=&quot;com.cyan.spring&quot;表示扫描com.cyan.spring下的所有子包。    (2) context:exclude-filter表示配置过滤的类，        type=&quot;annotation&quot;表示以注解类型为规则进行过滤，        expression=&quot;org.springframework.stereotype.Service&quot;表示以该注解标记的类会被过滤掉，不会被扫描。--&gt;&lt;context:component-scan base-package=&quot;com.cyan.spring&quot;&gt;    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt;\n\n指定扫描某些类 : 通过&lt;context:include-filter/&gt;标签来指定（该标签要放在&lt;context:component-scan&gt;标签内），其中，type 属性表示根据什么规则来进行扫描，expression 属性则表示具体要扫描的类型。可见，&lt;context:include-filter/&gt;标签 和 上文的&lt;context:exclude-filter/&gt;标签在格式上非常类似，不过需要注意的一点是，&lt;context:include-filter/&gt;标签在使用时还需要在&lt;context:include-filter/&gt;标签中额外标识一个属性use-default-filters=&quot;false&quot;，表示不再使用默认扫描机制。\n&lt;!--    表示指定扫描com.cyan.spring包及其所有子包下的————使用了@Service注解标记的类。--&gt;&lt;context:component-scan base-package=&quot;com.cyan.spring&quot; use-default-filters=&quot;false&quot;&gt;    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;&lt;/context:component-scan&gt;\n\n\n使用注解标记后，默认情况下所创建的Bean对象的id &#x3D; 类名首字母小写；但也可以借助注解的value属性手动指定id值，且value可以省略。注解的value属性（注解中定义的方法实际上对应的是注解的属性，而不是传统意义上的方法。），如下图所示 : \n\n我们可以在配置注解时，给出指定的id值\n\n进入Debug界面，在IOC容器的beanFactory –&gt; singletonObjects下，可以看到bean对象的id值已经变成了我们在配置@Service注解时给出的value &#x3D; “…” 的值。如下图所示 : \n\n\n\n全注解开发如果完全不使用 XML 来配置 Spring 的 IoC 容器，我们可以使用 Java 配置类来替代。下面是对之前例子的更改\n我们保持之前定义的类不变，即 PotUserServlet、PotUserServiceImpl 和 PotUserDAOImpl，这些类依然使用相应的注解进行标记。\n// PotUserServlet.javaimport org.springframework.stereotype.Controller;@Controllerpublic class PotUserServlet &#123;&#125;// PotUserServiceImpl.javaimport org.springframework.stereotype.Service;@Servicepublic class PotUserServiceImpl &#123;&#125;// PotUserDAOImpl.javaimport org.springframework.stereotype.Repository;@Repositorypublic class PotUserDAOImpl &#123;&#125;\n\n我们需要创建一个 Java 配置类来替代 beans_annotation.xml 文件。使用 @Configuration 注解标记该类，表示这是一个配置类，使用 @ComponentScan 注解来指定要扫描的包\n@Configuration\n作用：该注解用于标记一个类为 Spring 的配置类，类似于 XML 配置文件。配置类中可以定义 Bean 的创建和依赖关系。\n\n@ComponentScan\n作用：该注解用于指定 Spring 容器要扫描的包，Spring 会自动扫描这些包及其子包下使用 @Controller、@Service、@Repository、@Component 等注解标记的类，并将它们注册为 Bean，并根据@Autowired进行装配。\n属性\nbasePackages：指定要扫描的包的名称，可以是一个数组，用于指定多个包。\nbasePackageClasses：指定要扫描的包下的某个类，Spring 会扫描该类所在的包及其子包。\nincludeFilters 和 excludeFilters：用于指定扫描时的过滤规则，类似于 XML 中的 和。\n\n\n\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &#123;    &quot;edu.software.ergoutree.springnotebean.web&quot;,    &quot;edu.software.ergoutree.springnotebean.service&quot;,    &quot;edu.software.ergoutree.springnotebean.dao&quot;&#125;)public class AppConfig &#123;&#125;\n\n测试类也需要进行相应的修改，使用 AnnotationConfigApplicationContext 来加载 Java 配置类\nimport org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.junit.jupiter.api.Test;public class TestBeanByAnnotation &#123;    @Test    public void annotationIntro() &#123;        // 使用 AnnotationConfigApplicationContext 加载 Java 配置类        // AnnotationConfigApplicationContext\t   //作用：这是一个 Spring 容器的实现类，用于加载 Java 配置类。通过它可以创建一个基于 Java 配置的 Spring 应用上下文。        ApplicationContext ioc = new AnnotationConfigApplicationContext(AppConfig.class);        PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);        PotUserServiceImpl potUserServiceImpl = ioc.getBean(&quot;potUserServiceImpl&quot;, PotUserServiceImpl.class);        PotUserDAOImpl potUserDAOImpl = ioc.getBean(&quot;potUserDAOImpl&quot;, PotUserDAOImpl.class);        System.out.println(&quot;potUserServlet = &quot; + potUserServlet);        System.out.println(&quot;potUserServiceImpl = &quot; + potUserServiceImpl);        System.out.println(&quot;potUserDAOImpl = &quot; + potUserDAOImpl);    &#125;&#125;\n\n使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：\n\n每个Bean被标注为@Component并正确使用@Autowired注入；\n配置类被标注为@Configuration和@ComponentScan；\n所有Bean均在指定包以及子包内。\n\n使用@ComponentScan非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置AppConfig位于自定义的顶层包（例如com.itranswarp.learnjava），其他Bean按类别放入子包。\n自动装配Spring 基于注解配置和管理Bean也可实现自动装配，使用的注解主要是两种，分别是@AutoWired和@Resource。\n@Autowired自动装配：根据属性类型进行自动装配使用@Autowired就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，@Autowired大幅简化了注入，因为它不但可以写在set()方法上，还可以直接写在字段上，甚至可以写在构造方法中\n@Componentpublic class UserService &#123;    MailService mailService;    public UserService(@Autowired MailService mailService) &#123;        this.mailService = mailService;    &#125;    ...&#125;\n\n当类中的某个属性上使用@Autowired注解标识时，会在IOC容器中查找待装配的组件的类型，如果有唯一的bean对象与之匹配，则使用该bean对象进行装配。\n若待装配的属性在IOC容器中对应有多个同类型的bean对象，则使用待装配的属性的属性名作为id值再进行查找，若找到就进行装配，若找不到就抛出异常。\n若想在使用@Autowired注解时也指定id值，可以配合@Qualifier注解，@Qualifier：根据名称进行注入，目的在于区别同一接口下有多个实现类，根据类型就无法选择，如下图所示 : \n\n@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）\n//@Resource //根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao;\n\n@Value：注入普通类型属性\n@Value(value = &quot;abc&quot;)private String name\n\n示例新建一个beans_Auto.xml配置文件，在配置文件中配置要扫描的包\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.springnotebean.*&quot;/&gt;&lt;/beans&gt;\n\n以PotUserServlet和PotUserServiceImpl类为例，在PotUserServlet类中维护一个PotUserServiceImpl类的属性，使用@Autowired对其进行自动装配。PotUserServlet类代码如下 : （在register()方法中打印出属性potUserService，与测试类中获取到的Bean对象进行比较）\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PotUserService &#123;    //Web层调用Service层    @Autowired    private PotUserServiceImpl potUserService;    // 定义用户注册方法的 demo    public void register()&#123;        System.out.println(&quot;PotUserServlet &#x27;s register() is invoked~~~&quot;);        System.out.println(&quot;potUserService = &quot; + potUserService);        potUserService.register();    &#125;&#125;\n\nPotUserServiceImpl类代码如下 : （注意，此处给出了指定的id值[value&#x3D;”potUserServiceImpl01”]）\nimport org.springframework.stereotype.Service;@Service(value=&quot;potUserServiceImpl01&quot;)public class PotUserServiceImpl &#123;    //定义注册用户的方法    public void register() &#123;        System.out.println(&quot;PotUserServiceImpl &#x27;s register() is invoked~&quot;);    &#125;&#125;\n\n在测试类中定义单元测试方法，在测试类中单独通过 id 获取到PotUserServiceImpl类的 Bean 对象，与 PotUserServlet的register方法中打印出的Bean对象进行对比，查看是否为同一个对象。testAutoAssembleByAutoWired() 方法代码如下\n@Testpublic void testAutoAssembleByAutoWired() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean_Auto.xml&quot;);    PotUserServlet potUserServlet = ioc.getBean(&quot;potUserServlet&quot;, PotUserServlet.class);    potUserServlet.register();    PotUserServiceImpl potUserServiceImpl01 = ioc.getBean(&quot;potUserServiceImpl01&quot;, PotUserServiceImpl.class);    System.out.println(&quot;potUserServiceImpl01 = &quot; + potUserServiceImpl01);&#125;/*PotUserServlet &#x27;s register() is invoked~~~potUserService = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@ebda593PotUserServiceImpl &#x27;s register() is invoked~potUserServiceImpl01 = edu.software.ergoutree.springnotebean.service.PotUserServiceImpl@ebda593 */\n\n 可以看到，由于此时我们在bean_Auto.xml中配置了自动扫描，而使用@Service注解时，我们又给出了value = &quot;potUserServiceImpl01&quot;的指定id。所以最终IOC容器中只有一个PotUserServiceImpl类型的 bean 对象[根据类型进行自动装配]，并且其id = potUserServiceImpl01。因此，在测试方法中，我们通过id = potUserServiceImpl01获取到的Bean对象就是自动装配的Bean对象。\n\n@Resource自动装配@Resource有两个属性比较重要，分别是name 和 type；Spring将@Resource注解的name属性解析为bean对象的id值，而将type属性解析为bean对象的类型。\n当使用name属性时，采取byName的自动注入策略；当使用type属性时，采取byType的自动注入策略。\n若@Resource注解未指定name 和 type，则优先使用byName注入策略，若匹配不上再采取byType注入策略，若仍然匹配不上，报错。\nJDK17.0不支持@Resource注解。\n将 Resource 改为 by Type 策略\n\n此时，由于IOC容器中只有唯一一个PotUserServiceImpl类型的Bean对象，所以可以装配成功。\n\n但是，如果此时我们在beans_Auto.xml中再配置一个以上PotUserServiceImpl类型的bean对象\n[注意：基于注解配置Bean和基于XML配置Bean，两者配置的Bean对象是互不干扰的，但容器中总共存在的Bean对象的数量会发生改变]\n那么再次运行testAutoAssembleByResource()方法，就会报错\n当@Resource注解采取“**byType”注入策略时，同样要求当前IOC容器中只有唯一一个该类型的Bean对象。\n泛型依赖注入\nSpring提供了基于泛型依赖的注入机制，以更好地管理有继承和相互依赖的Bean的自动装配。\n泛型依赖注入需要用到@Autowired注解。\n泛型依赖注入，本质是利用了OOP的多态机制。eg : BasicService中维护有一个使用了泛型的BasicDAO类的属性。\n\n实例：\n首先需要创建下面这五个类，如下图所示 : （最终要实现——将OrderDAO类型的Bean对象装配给BasicService中维护的BasicDAO类型的属性[多态]）\n\nOrder类代码如下 : （作为JavaBean类）\npublic class Order &#123;&#125;\n\nBasicDAO类代码如下 : （定义了save()抽象方法）\npublic abstract class BasicDAO&lt;T&gt; &#123;    public abstract void save();&#125;\n\n OrderDAO类代码如下 : (继承自BasicDAO，并重写BasicDAO的save方法)\nimport org.springframework.stereotype.Repository;@Repositorypublic class OrderDAO extends BasicDAO&lt;Order&gt; &#123;    @Override    public void save()&#123;        System.out.println(&quot;OrderDAO &#x27;s save() is invoked~&quot;);    &#125;&#125;\n\nBasicService类代码如下 : (注意，针对basicDAO属性使用了@Autowire自动装配，最终会将OrderDAO类型的对象引用给basicDAO属性，构成多态)\nimport org.springframework.beans.factory.annotation.Autowired;public class BasicService&lt;T&gt; &#123;    @Autowired    private BasicDAO&lt;T&gt; basicDAO;    public void save() &#123;        basicDAO.save();    &#125;&#125;\n\nOrderService类代码如下 : (继承自BasicService)\n@Servicepublic class OrderService extends BasicService&lt;Order&gt;&#123;&#125;\n\n然后配置文件 xml 配置一下\n测试输出发现 OrderService 被装配，且 bean 对象是 basicDAO属性，形成了多态\n@Test    public void testParameterizedTypeDependencyInjection() &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean_parame.xml&quot;);        OrderService orderService = ioc.getBean(&quot;orderService&quot;, OrderService.class);        orderService.save();    &#125;    // OrderDAO &#x27;s save() is invoked~","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework Part5-Spring中的AOP面向切面编程","url":"/posts/50477.html","content":"什么是 AOP，如何理解面向切面编程AOP,  Aspect Oriented Programming ，即面向切面编程。通过预编译方法和运行期间动态代理的方式实现，在不修改源代码的方式下，给程序动态统一添加额外功能的一种技术。\n\nAOP是对面向对象编程OOP的一个补充。\n它的目的是将复杂的需求分解为不同的切面，将散布在系统中的公共功能集中解决。\n它的实际含义是在运行时将代码切入到类的指定方法、指定位置上，将不同方法的同一个位置抽象为一个切面对象，并对该对象进行编程。\n\n\n\nAOP 的目的是为了解耦 其次是简化开发，AOP 是 Spring 的核心 面向切面编程\n他是一套规范，通过预编译方式和运行期间动态代理实现程序的统一维护\n核心概念 就是 将分散在各个业务逻辑代码中的相同的代码通过横向切割的方式抽取到一个独立的模块中\n\nAOP的优点\n\n降低模块之间的耦合度\n使系统更容易扩展\n更好的代码复用\n非业务代码更加集中，不分散，便于统一管理\n业务代码更加简洁纯粹，不掺杂其他的代码的影响\n\nAOP中出现的一些概念\n切面：横切关注点，从每个方法中抽取的非核心业务，被模块化的抽象对象，横切关注点的模块化，比如下标提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为在哪干和干什么集合；\n通知：切面对象完成的工作（非业务代码），在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为干什么；\n目标：被通知的对象（即被横切的对象），需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为对谁干；\n代理：切面、通知、目标混合之后的对象。封装通知方法的类\nAOP代理：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。在AOP中表示为怎么实现的一种典型方式；\n连接点：通知要插入业务代码的具体位置，表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点，在AOP中表示为spring允许你使用通知的地方；（如Spring实现中的JoinPoint）\n切入点：选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为在哪里干的集合；\n织入：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。在AOP中表示为怎么实现的；\n引入：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为干什么（引入什么）；\n\n\nAOP 的核心是连接点\n连接点是我们需要关注的程序拓展点\n可能是类初始化 方法执行 方法调用 字段调用 异常处理等\nSpring 支持的连接点是方法执行点\n切入点是一系列连接点的集合，Spring默认使用AspectJ语法，在AOP中抽象表示为可以进行操作的集合\n之后就是通知\n通知就是我们在连接点上执行的行为\n连接点 切入点 通知组合在一起 就是一个切面\n把切面映入到其他应用程序或者对象上，创建一个被通知的对象，这些就是织入，Spring 在运行时完成织入 ，在 AOP 中表示为怎么实现的，实现方式\n通知类型：\n前置通知（Before advice）：\n在被代理的目标方法之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\n\n后置通知（After returning advice）：\n在被代理的目标方法后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\n\n异常通知（After throwing advice）：\n在被代理的目标方法抛出异常退出时执行的通知。\n\n最终通知（After (finally) advice）：\n当被代理的目标方法最终说明的时候执行的通知（不论是正常返回还是异常退出）。\n\n环绕通知（Around Advice）：\n包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\n\n\n环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知，推荐你使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成同样的事情。用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要在JoinPoint上调用用于环绕通知的proceed()方法，就不会有调用的问题。\nSpring AOP和 AspectJ 是什么关系AspectJ 是一个更加强大的 AOP 框架 是一个 AOP 标准\n如果只是简单的业务 可以使用 AOP\nAOP 一个重要的原则就是无侵入性\nAspectJ 重要的是 一般在编译期进行 即静态织入\n在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。\n动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术。\nSpring AOP更易用，AspectJ更强大\nJava中的代理模式实现AOP创建一个计算器接口，定义四个方法\npackage edu.software.ergoutree.spring6aop.example;public interface Calculator &#123;    public int add(int a, int b);    public int subtract(int a, int b);    public int multiply(int a, int b);    public int divide(int a, int b);&#125;\n\n创建一个带日志输出的实现类\n高耦合的写法，每次打印日志都要手动完成\npackage edu.software.ergoutree.spring6aop.example;// 带日志的实现类// 发现日志功能对核心功能没有影响，但是混合到一起了，既要关心核心业务逻辑，还要关注日志，维护困难public class CalculatirLogImpl implements Calculator&#123;    @Override    public int add(int a, int b) &#123;        System.out.println(&quot;[日志] add 方法开始&quot;);        int result = a + b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] add 方法结束&quot;);        return result;    &#125;    @Override    public int subtract(int a, int b) &#123;        System.out.println(&quot;[日志] sub 方法开始&quot;);        int result = a - b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] sub 方法结束&quot;);        return result;    &#125;    @Override    public int multiply(int a, int b) &#123;        System.out.println(&quot;[日志] mul 方法开始&quot;);        int result = a * b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] mul 方法结束&quot;);        return result;    &#125;    @Override    public int divide(int a, int b) &#123;        System.out.println(&quot;[日志] div 方法开始&quot;);        int result = a / b;        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] div 方法结束&quot;);        return result;    &#125;&#125;\n\n使用静态代理进行优化上方代码中，日志信息和业务逻辑的耦合性很高，不利于代码的维护。\n关于静态代理和动态代理的部分，可以看我的另一篇文章，这里只做简单讲解\n介绍：代理是一种设计模式，提供一个代理类，调用方法的时候使用代理类间接调用，让不属于目标方法核心方法中的代码解耦出来，减少对目标方法的调用和打扰，同时让功能更加集中统一更利于维护\n静态代理是通过创建一个代理类来实现对目标对象的访问控制。下面是计算器例子改为静态代理的实现方式\npackage edu.software.ergoutree.spring6aop.example;// 代理类public class CalculatorProxy implements Calculator &#123;    // 传递被代理的目标对象    private final Calculator target;      public CalculatorProxy(Calculator target) &#123;        this.target = target;    &#125;    @Override    public int add(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行add方法&quot;);   // 关于代理的日志仅仅是记录操作，不代表没有实现代理        // 调用目标对象的方法实现核心业务的实现        int result = target.add(a, b);        System.out.println(&quot;代理: add方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int subtract(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行subtract方法&quot;);        int result = target.subtract(a, b);        System.out.println(&quot;代理: subtract方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int multiply(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行multiply方法&quot;);        int result = target.multiply(a, b);        System.out.println(&quot;代理: multiply方法执行完成，结果=&quot; + result);        return result;    &#125;    @Override    public int divide(int a, int b) &#123;        System.out.println(&quot;代理: 开始执行divide方法&quot;);        try &#123;            int result = target.divide(a, b);            System.out.println(&quot;代理: divide方法执行完成，结果=&quot; + result);            return result;        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;代理: divide方法执行出错 - &quot; + e.getMessage());            throw e;        &#125;    &#125;&#125;\n\n测试类\npackage edu.software.ergoutree.spring6aop.example;public class Main &#123;    public static void main(String[] args) &#123;        // 创建目标对象        Calculator target = new CalculatorImpl();                // 创建代理对象，传入目标对象        Calculator proxy = new CalculatorProxy(target);                // 通过代理对象调用方法        System.out.println(&quot;10 + 5 = &quot; + proxy.add(10, 5));        System.out.println(&quot;10 - 5 = &quot; + proxy.subtract(10, 5));        System.out.println(&quot;10 * 5 = &quot; + proxy.multiply(10, 5));        System.out.println(&quot;10 / 5 = &quot; + proxy.divide(10, 5));                // 测试除法异常        try &#123;            System.out.println(&quot;10 / 0 = &quot; + proxy.divide(10, 0));        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getMessage());        &#125;    &#125;&#125;\n\n使用动态代理优化静态代理没有实现对日志的统一管理，实际上并没有进行多少的优化\n\n定义计算器接口和实现类都不变，我们添加一个日志处理器，实现 InvocationHandler 接口\n// 日志处理器，实现 InvocationHandler 接口class LogHandler implements InvocationHandler &#123;    private final Object target;    public LogHandler(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        String methodName = method.getName();        System.out.println(&quot;[日志] &quot; + methodName + &quot; 方法开始&quot;);        Object result = method.invoke(target, args);        System.out.println(&quot;方法内部Result: &quot; + result);        System.out.println(&quot;[日志] &quot; + methodName + &quot; 方法结束&quot;);        return result;    &#125;&#125;\n\n// 测试类public class DynamicProxyExample &#123;    public static void main(String[] args) &#123;        // 创建目标对象        Calculator calculator = new CalculatorImpl();        // 创建日志处理器        LogHandler logHandler = new LogHandler(calculator);        // 创建代理对象        Calculator proxyCalculator = (Calculator) Proxy.newProxyInstance(                calculator.getClass().getClassLoader(),                calculator.getClass().getInterfaces(),                logHandler        );        // 调用代理对象的方法        proxyCalculator.add(2, 3);        proxyCalculator.subtract(5, 2);        proxyCalculator.multiply(3, 4);        proxyCalculator.divide(10, 2);    &#125;&#125;\n\n\n\n在上述动态代理的例子中，我们通过 InvocationHandler 实现了日志功能的增强。然而，当项目变得复杂时，手动编写代理逻辑会变得繁琐，并且难以维护。这时候，Spring AOP（面向切面编程）就可以发挥作用了。\nSpring AOP 是 Spring 框架的一个重要特性，它允许我们在不修改原有代码的情况下，对程序进行增强。Spring AOP 基于动态代理实现，提供了一种更加简洁、灵活的方式来实现横切关注点（如日志、事务管理等）。\n动态代理的工厂类\npackage edu.software.ergoutree.spring6aop.example;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyFactory &#123;    // 目标对象    private Object target;    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    // 返回代理对象    public Object getProxy() &#123;        /*        Proxy.newProxyInstance() 方法有三个参数        第一个参数 ClassLoader：加载动态生成代理类的加载器        第二个参数 class&lt;?&gt;[] interfaces:目标对象实现的所有接口的class类型的数组        第三个参数 InvocationHandler 设置代理对象实现目标对象方法的过程         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() &#123;            // 第一个参数 代理对象            // 第二个参数 需要重写的目标对象的方法            // 第三个参数 method方法里面的参数            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                // 方法调用前的日志输出                System.out.println(&quot;[动态代理日志] 开始执行 &quot; + method.getName() + &quot; 方法，参数: &quot; +                        java.util.Arrays.toString(args));                // 调用目标的方法                Object result = method.invoke(target, args);                // 方法调用后的日志输出                System.out.println(&quot;[动态代理日志] &quot; + method.getName() + &quot; 方法执行完毕，结果: &quot; + result);                System.out.println(&quot;----------------------------------&quot;);                return result;            &#125;        &#125;;        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);    &#125;&#125;\n\n测试\npackage edu.software.ergoutree.spring6aop.example;public class CalcutorTestProxy &#123;    public static void main(String[] args) &#123;        Calculator target = new CalculatorImpl();        // 创建代理工厂        ProxyFactory proxyFactory = new ProxyFactory(target);        // 获取代理对象        Calculator proxy = (Calculator) proxyFactory.getProxy();        // 通过代理对象调用方法        System.out.println(&quot;===== 测试加法 =====&quot;);        int addResult = proxy.add(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + addResult);        System.out.println(&quot;\\n===== 测试减法 =====&quot;);        int subtractResult = proxy.subtract(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + subtractResult);        System.out.println(&quot;\\n===== 测试乘法 =====&quot;);        int multiplyResult = proxy.multiply(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + multiplyResult);        System.out.println(&quot;\\n===== 测试除法 =====&quot;);        int divideResult = proxy.divide(10, 5);        System.out.println(&quot;主程序获取的结果: &quot; + divideResult);        // 测试异常情况        try &#123;            System.out.println(&quot;\\n===== 测试除法异常 =====&quot;);            proxy.divide(10, 0);        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getClass().getName());        &#125;    &#125;&#125;\n\n\n\n基于注解的 AOP技术说明动态代理分类：JDK动态代理 和 cglib动态代理\n有接口，使用 JDK 动态代理，生成接口实现类的代理对象，代理对象和目标对象都实现同样的接口\n无接口，使用 cglib 动态代理，生成子类的代理对象，继承目标类\n\n动态代理分为JDK动态代理和glib动态代理\n当目标类有接口的情况使用JDK动态代理和cglib动态代理， 没有接口时只能使用cgib动态代理\nJDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1,和目标类实现相同的接口●cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类\n动态代理(InvocationHandler) : JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求“代理对象和目标对象实现同样的接口* (兄弟两个拜把子模式)。\ncglib: 通过继承被代理的目标类(认干爹模式)实现代理，所以不需要目标类实现接口。\nAspectJ:是AOP思想的一种实现。本质上是静态代理，将代理逻辑”织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。 Spring只是借用了 AspectJ中的注解。\n使用注解配置AOPSpring AOP允许使用基于注解的方式实现AOP，这样做可以简化Spring配置文件的臃肿代码。\n\n步骤：\n\n引入 AOP 相关依赖\n创建目标资源\n接口\n实现类\n\n\n创建切面类\n切入点\n通知类型\n\n\n\n实例所以先创建 LogAspect 切面类\npackage edu.software.ergoutree.spring6aop.anoaop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;// 切面类@Component  // IoC容器中进行管理@Aspect   // 表示是一个切面类public class LogAspect &#123;    // 定义切入点表达式，匹配Calculator接口的所有方法    @Pointcut(&quot;execution(* edu.software.ergoutree.spring6aop.anoaop.Calculator.*(..))&quot;)    public void calculatorPointcut() &#123;&#125;    // 设置切入点和通知类型    // 通知类型  前置 返回 异常 后置 环绕    // 前置  @Before(value=&quot;切入点表达式配置切入点&quot;)    // 单独写切入点表达式@Before(value=&quot;execution(public int edu.software.ergoutree.spring6aop.anoaop.CalculatorImpl.add(..))&quot;)    @Before(&quot;calculatorPointcut()&quot;)    public void beforeMethod(JoinPoint joinPoint) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;前置通知，方法名&quot; + methodName + &quot; 参数 &quot; + args);    &#125;    // 后置通知（最终通知）    @After(&quot;calculatorPointcut()&quot;)    public void afterMethod(JoinPoint joinPoint) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;后置通知，方法名&quot; + methodName + &quot; 参数 &quot; + args);    &#125;    // 返回通知    // 返回  @AfterReturning(value = &quot;切入点表达式&quot;, returning = &quot;增强的目标方法返回值（和方法中的Object一样）&quot;)    @AfterReturning(value = &quot;calculatorPointcut()&quot;, returning = &quot;result&quot;)    public void afterReturningMethod(JoinPoint joinPoint, Object result) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;返回通知，方法名&quot; + methodName + &quot; 参数 &quot; + args + &quot;目标方法的返回值&quot; + result);    &#125;    // 异常通知，目标方法出现了异常，这个通知会执行    // @AfterThrowing(value = &quot;切入点表达式&quot;, throwing = &quot;目标方法的异常信息&quot;)    @AfterThrowing(value = &quot;calculatorPointcut()&quot;, throwing = &quot;ex&quot;)    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) &#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger-&gt;异常通知 方法 &quot; + methodName + &quot; 参数 &quot; + args + &quot; 执行抛出异常: &quot; + ex.getMessage());    &#125;    // 环绕通知    @Around(&quot;calculatorPointcut()&quot;)    public Object aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123;        String methodName = joinPoint.getSignature().getName();        Object[] args = joinPoint.getArgs();        System.out.println(&quot;Logger-&gt;环绕通知-前 方法 &quot; + methodName + &quot; 开始执行，参数: &quot; + Arrays.toString(args));        try &#123;            System.out.println(&quot;Logger-&gt;环绕通知-目标方法之前执行&quot;);            // 执行目标方法            Object result = joinPoint.proceed();            System.out.println(&quot;Logger-&gt;环绕通知-目标方法之后执行 方法 &quot; + methodName + &quot; 执行成功，结果: &quot; + result);            return result;        &#125; catch (Exception e) &#123;            System.out.println(&quot;Logger-&gt;环绕通知-异常 方法 &quot; + methodName + &quot; 执行失败，异常: &quot; + e.getMessage());            throw e;        &#125; finally &#123;            System.out.println(&quot;Logger-&gt;环绕通知-最终 方法 &quot; + methodName + &quot; 执行结束&quot;);        &#125;    &#125;    // 环绕通知另一个应用，计算执行时间    @Around(&quot;calculatorPointcut()&quot;)    public Object timingAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;        long start = System.currentTimeMillis();        try &#123;            return joinPoint.proceed();        &#125; finally &#123;            long end = System.currentTimeMillis();            System.out.println(&quot;方法 &quot; + joinPoint.getSignature().getName()                    + &quot; 执行耗时: &quot; + (end - start) + &quot;ms&quot;);        &#125;    &#125;&#125;\n\n关于切入点表达式\n语法细节：\n\n用号代替”权限修饰符”和“返回值”部分表示”权限修饰符”和“返回值”不限\n\n在包名的部分，一个*号只能代表包的层次结构中的一层，表示这一层是任意的。\n\n例如: *.Hello匹配com.Hello, 不匹配com.atguigu.Hello\n\n在包名的部分，使用 *.. 表示包名任意，包的层次深度任意\n\n在类名的部分，类名部分整体用 * 号代替,表示类名任意\n\n在类名的部分，可以使用 * 号代替类名的一部分\n\n例如: *Service匹配所有名称以Service结尾的类或接口\n\n\n在方法名部分，可以使用 * 号表示方法名任意\n\n在方法名部分，可以使用 * 号代替方法名的一部分\n\n例如: *Operation匹配所有方法名以Operation结尾的方法\n\n\n在方法参数列表部分，使用(..)表示参数列表任意\n\n在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头\n\n在方法参数列表部分，基本数据类型和对应的包装类型是不一-样的\n\n切入点表达式中使用int和实际方法中Integer 是不匹配的\n\n\n在方法返回值部分，如果想要明确指定一个返回值类型， 那么必须同时写明楫限修饰符。\n\n例如: execution(public int ..Service,(..,int))正确\n例如: execution( int ..Service.*(..,int))错误\n\n\n\n完整例子：\nexecution(访问修饰符 增强方法的返回类型 增强方法所在类全路径.方法名)\n\n关于 环绕通知\n环绕通知的特点\n\n功能最强大的通知类型：可以控制目标方法是否执行、何时执行、如何执行\n唯一能控制方法执行的切入点：可以决定是否调用proceed()方法来执行目标方法\n可以修改返回值：在方法执行前后对返回值进行处理\n可以处理异常：捕获并处理目标方法抛出的异常\n\naroundMethod 的方法参数说明\n需要注意的是，环绕通知必须接收一个类型为ProceedingJoinPoint的参数，返回值也必须是Object类型，且必须抛出异常\n\nProceedingJoinPoint：继承自JoinPoint，新增了proceed()方法\nproceed()：执行目标方法，返回目标方法的返回值\nproceed(Object[] args)：使用新参数执行目标方法\n\n\n\n与其他通知的执行顺序\n当环绕通知与其他通知共存时，执行顺序为：\n\n环绕通知的前半部分\n前置通知\n目标方法\n返回通知&#x2F;异常通知\n后置通知\n环绕通知的后半部分\n\n重用切入表达式\n关于 @Pointcut\n@Pointcut 是 Spring AOP 里的一个注解，其作用是定义一个切入点（Pointcut）\npublic void calculatorPointcut() &#123;&#125;这是一个空方法，其作用是为切入点命名。通过这种方式，可以在其他通知注解（如 @Before、@After 等）中引用这个切入点\n创建 bean.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6aop.anoaop&quot;&gt;    &lt;/context:component-scan&gt;    &lt;!--开启Aspectj自动代理，为目标类自动生成代理--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\n\n当然也可以用注解类\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@ComponentScan(&quot;edu.software.ergoutree.spring6aop.anoaop&quot;)@EnableAspectJAutoProxy // 启用AOP自动代理public class AppConfig &#123;&#125;\n\n\n\n基于 XML 的AOP实现因为Spring AOP的代理对象由IoC容器自动生成，所以开发者无须过多关注代理对象生成的过程，只需选择连接点、创建切面、定义切点并在XML文件中添加配置信息即可。\n\n配置切面在Spring的配置文件中，配置切面使用的是&lt;aop:aspect&gt;元素，该元素会将一个已定义好的Spring Bean转换成切面Bean，因此，在使用&lt;aop:aspect&gt;元素之前，要在配置文件中先定义一个普通的Spring Bean。Spring Bean定义完成后，通过&lt;aop:aspect&gt;元素的ref属性即可引用该 Bean。\n配置&lt;aop:aspect&gt;元素时，通常会指定 id 和 ref 这两个属性\n配置切入点在Spring的配置文件中，切入点是通过&lt;aop:pointcut&gt;元素来定义的，表示该切入点是全局切入点，它可被多个切面共享；当&lt;aop:pointcut&gt;元素作为&lt;aop:aspect&gt;元素的子元素时，表示该切入点只对当前切面有效。\n在定义&lt;aop:aspect&gt;元素时，通常会指定 id 和 expression 这两个属性\n\n\n\n属性名称\n描述\n\n\n\nid\n用于指定切入点的唯一标识\n\n\nexpression\n用于指定切入点关联的切入点表达式\n\n\n配置通知在Spring的配置文件中，使用&lt;aop:aspect&gt;元素配置了5种常用通知，如表所示，5种通知分别为前置通知、后置通知、环绕通知、返回通知和异常通知，&lt;aop:aspect&gt;元素的常用属性如表4所示。\n\n实例文件结构\nsrc/├── main/│   ├── java/│   │   └── edu.software.ergoutree.spring6aop.xmlaop/│   │       ├── Calculator.java          # 接口│   │       ├── CalculatorImpl.java      # 实现类│   │       └── LogAspect.java           # 切面类│   └── resources/│       └── bean-aopxml.xml                     # XML配置└── test/    └── java/        └── CalculatorAOPTest.java          # 测试类\n\n导入AspectJ框架相关JAR包的依赖，在pom.xml中添加的代码如下：\n&lt;dependency&gt;\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t&lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;\t&lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\t&lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt;\n\n计算器的接口和实现类依旧用上面的那个\n切面类，定义了5种通知\n// LogAspect.javapackage edu.software.ergoutree.spring6aop.xmlaop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;public class LogAspect &#123;    // 前置通知    public void beforeAdvice(JoinPoint joinPoint) &#123;        System.out.println(&quot;[前置] 方法名: &quot; + joinPoint.getSignature().getName());    &#125;    // 后置通知（无论是否异常都会执行）    public void afterAdvice(JoinPoint joinPoint) &#123;        System.out.println(&quot;[后置] 方法执行完毕&quot;);    &#125;    // 返回通知    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;        System.out.println(&quot;[返回] 结果: &quot; + result);    &#125;    // 异常通知    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) &#123;        System.out.println(&quot;[异常] 错误信息: &quot; + ex.getMessage());    &#125;    // 环绕通知    public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable &#123;        System.out.println(&quot;[环绕前] 参数: &quot; + pjp.getArgs()[0] + &quot;, &quot; + pjp.getArgs()[1]);        Object result = pjp.proceed(); // 执行目标方法        System.out.println(&quot;[环绕后] 结果: &quot; + result);        return result;    &#125;&#125;\n\nxml 配置 bean-aopxml.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6aop.xmlaop&quot;/&gt;    &lt;!-- 定义切面Bean --&gt;    &lt;bean id=&quot;logAspect&quot; class=&quot;edu.software.ergoutree.spring6aop.xmlaop.LogAspect&quot;/&gt;    &lt;!-- AOP配置 --&gt;    &lt;aop:config&gt;        &lt;aop:aspect ref=&quot;logAspect&quot;&gt;            &lt;!-- 定义切入点表达式 --&gt;            &lt;aop:pointcut id=&quot;calculatorMethods&quot;                          expression=&quot;execution(* edu.software.ergoutree.spring6aop.xmlaop.Calculator.*(..))&quot;/&gt;            &lt;!-- 五种通知绑定到切入点 --&gt;            &lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;            &lt;aop:after method=&quot;afterAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;            &lt;aop:after-returning method=&quot;afterReturningAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot; returning=&quot;result&quot;/&gt;            &lt;aop:after-throwing method=&quot;afterThrowingAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot; throwing=&quot;ex&quot;/&gt;            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;calculatorMethods&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;!-- 显式声明Calculator类型的Bean --&gt;    &lt;bean id=&quot;calculator&quot; class=&quot;edu.software.ergoutree.spring6aop.xmlaop.CalculatorImpl&quot;/&gt;&lt;/beans&gt;\n\n测试\npackage edu.software.ergoutree.spring6aop;import edu.software.ergoutree.spring6aop.xmlaop.Calculator;import edu.software.ergoutree.spring6aop.xmlaop.CalculatorImpl;import org.junit.jupiter.api.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class CalculatroAOPTest &#123;    @Test    public void Test1() &#123;        try (ClassPathXmlApplicationContext context =                     new ClassPathXmlApplicationContext(&quot;bean-aopxml.xml&quot;)) &#123;            CalculatorImpl calculator = context.getBean(&quot;calculator&quot;, CalculatorImpl.class);            // 正常测试            System.out.println(&quot;=== 正常测试 ===&quot;);            calculator.add(5, 3);            calculator.divide(6, 2);            // 异常测试（除数为0）            System.out.println(&quot;\\n=== 异常测试 ===&quot;);            try &#123;                calculator.divide(6, 0);            &#125; catch (ArithmeticException ignored) &#123;&#125;        &#125;    &#125;&#125;\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"SpringFrameworkPart6-Spring Framework常用注解","url":"/posts/undefined.html","content":"Spring框架核心注解Spring的一个核心功能是IOC，就是将Bean初始化加载到容器中，Bean是如何加载到容器的，可以使用Spring注解方式或者Spring XML配置方式。\nSpring注解方式减少了配置文件内容，更加便于管理，并且使用注解可以大大提高了开发效率！\n注解本身是没有功能的，和xml一样，注解和xml都是一种元数据，元数据即解释数据的数据，也就是所谓的配置。\n我们可以通过 org.springframework.beans.factory.annotation 和 org.springframework.context.annotation 包中的注解来使用 Spring DI 引擎的功能。\n\nxml用来管理bean；\n注解只负责完成属性的注入；\n\n使用注解需要开启对注解的支持\n&lt;context:component-scan base-package=&quot;com.guo&quot;&gt;&lt;/context:component-scan&gt;&lt;context:annotation-config/&gt;\n\n\n常用注解给容器中注入组件包扫描+组件标注注解\n@Component：表示一个带注释的类是一个“组件”，成为Spring管理的Bean\n\n作用：是一个泛化的组件注解，用于标记一个类作为 Spring 容器中的一个组件，让 Spring 能够自动扫描并将其纳入容器管理。\n\n使用：当一个类不属于特定的层（如控制层、业务层、数据访问层），但又需要被 Spring 容器管理时，就可以使用@Component注解。例如，一些工具类、配置类等可以使用该注解。\n\n@Controller、@Service、@Repository都可以称为@Component。@Controller、@Service、@Reponsitory都组合了 @Component注解。为了区分三层不同的作用，因此分别为三层起了不同的名字。\n\n\n\n@Controller：应用在控制层\n\n作用：用于标记控制层的组件，主要处理用户的请求和视图的展示。它负责接收客户端的请求，调用相应的业务逻辑方法，并将结果返回给客户端。\n使用场景：在 Web 应用中，通常用于处理 HTTP 请求的控制器类上。比如，处理用户登录、注册请求，或者根据用户的操作返回相应页面的控制器。\n\n\n@Service：应用在service层（业务逻辑层）\n\n作用：用于标记业务层的组件，主要包含应用的业务逻辑。它通常会调用数据访问层的方法来完成数据库操作，并对数据进行处理和业务规则的应用。\n使用场景：在处理复杂业务逻辑的服务类上使用，如用户服务、订单服务等。例如，在电商应用中，计算订单总价、处理库存更新等业务逻辑就可以放在@Service注解标记的类中。\n\n\n@Repository：应用在dao层（实现类）（数据访问层）\n\n作用：用于标记数据访问层的组件，主要负责与数据库进行交互，执行数据库的增删改查操作。它提供了一种将数据访问逻辑封装起来的方式，使得业务层可以方便地调用数据访问方法。\n使用场景：在与数据库交互的 DAO（Data Access Object）类上使用。比如，在用户管理系统中，实现用户数据的存储、查询、更新和删除操作的类就可以使用@Repository注解。\n\n\n\n配置相关注解配置管理\n@Configuration\n\n作用：标记类为配置类，替代XML配置文件。配置类中可以声明@Bean方法，Spring容器会将其作为Bean定义的来源。\n\n使用：\n@Configurationpublic class AppConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new HikariDataSource();    &#125;&#125;\n\n\n@ComponentScan\n\n作用：自动扫描指定包路径下的组件（如@Component, @Service, @Repository等），并将其注册为Spring Bean。\n\n属性：\n\nbasePackages：指定扫描的包路径（支持多个）\nexcludeFilters：排除不需要扫描的组件\n\n\n使用\n@Configuration@ComponentScan(basePackages = &quot;com.example.service&quot;,               excludeFilters = @ComponentScan.Filter(type=FilterType.ANNOTATION, classes=Controller.class))public class AppConfig &#123;&#125;\n\n\n@AliasFor\n\n作用：为注解属性声明别名（用于元注解组合）主要用于元注解组合时实现属性覆盖\n\n\n@PropertySource\n\n作用：加载外部属性文件到Spring Environment\n\n特性：\n\n支持classpath:、file:等前缀\n支持多个文件（Spring 4+使用@PropertySources）\n\n\n使用：\n@Configuration@PropertySource(&quot;classpath:app.properties&quot;)@PropertySource(value = &quot;file:/etc/config/override.properties&quot;, ignoreResourceNotFound = true)public class AppConfig &#123; ... &#125;\n\n扩展：@PropertySources\n\n可以使用此注解指定多个 @PropertySource 配置：\n@Configuration@PropertySources(&#123;     @PropertySource(&quot;classpath:/annotations.properties&quot;),    @PropertySource(&quot;classpath:/vehicle-factory.properties&quot;)&#125;)class VehicleFactoryConfig &#123;&#125;\n\n注意，自 Java 8 以来，可以通过上述重复注解的特性来实现同样的功能。\n\n\n\n\n\n\nBean管理\n@Bean：导入第三方包里面的注解\n\n作用：@Bean注解通常用于在 Java 配置类中定义 Bean。当你需要将第三方库中的类或者你自己编写的但不适合用组件扫描注解标注的类纳入 Spring 容器管理时，就可以使用@Bean注解。它允许你以编程的方式创建和配置 Bean。\n\n特性：\n\n方法名默认作为Bean名称\n支持initMethod&#x2F;destroyMethod配置生命周期方法\n\n\n使用\n@Configurationpublic class DataSourceConfig &#123;    @Bean(name = &quot;primaryDataSource&quot;, initMethod = &quot;init&quot;)    public DataSource dataSource() &#123;        return new HikariDataSource();    &#125;&#125;\n\n\n@Conditional：\n\n作用：这是一个元注解，用于自定义条件化创建 Bean。可以根据指定的条件决定是否创建某个 Bean。基于条件决定是否注册 Bean（自定义条件逻辑）。它需要配合一个条件类（Condition Class）使用，条件类通过实现Condition接口，定义了Bean加载的条件逻辑。\n\n使用：\n@Component@Conditional(MyCondition.class)public class MyConditionalComponent &#123;    public void doSomething() &#123;        System.out.println(&quot;Conditional component...&quot;);    &#125;&#125;\n\n在上述代码中，MyConditionalComponent类仅在MyCondition条件满足时才会被加载。这种方式使得开发者可以根据运行时环境或配置动态决定Bean的加载，增强了应用的灵活性。通过这种方式，开发者可以实现按需加载Bean，从而优化应用的性能和资源利用率。\n\n\n\n@ConditionalOnProperty（Spring Boot特有）\n\n作用：根据配置文件中的属性值来决定是否创建 Bean。\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class PropertyConfig &#123;\n    @Bean\n    @ConditionalOnProperty(name = &quot;myapp.feature.enabled&quot;, havingValue = &quot;true&quot;)\n    public MyFeature myFeature() &#123;\n        return new MyFeature();\n    &#125;\n&#125;\n    在这个例子中，只有当配置文件（如`application.properties`）中`myapp.feature.enabled`属性的值为`true`时，`myFeature` Bean 才会被创建。  - @Order  - 作用：定义Bean的加载/执行顺序（数值越小优先级越高）  - **应用场景**：    - 多个Bean实现同一接口时指定注入顺序    - AOP切面的执行顺序  - 使用：    ```java    @Component    @Order(1)    public class ValidationFilter implements Filter &#123; ... &#125;\n\n\n\n\n@ApplicationScope\n\n作用：定义 Bean 的作用域为 ServletContext 级别\n\n\n@Scope：Bean作用域注解\n\n作用：@Scope注解用于定义Bean的作用域。它支持以下几种作用域：\n\n取值\n\nSingleton：单例作用域，Spring容器中只有一个实例（默认值）。\nPrototype：原型作用域，每次请求都会创建一个新的实例。\nSession：会话作用域，每个用户会话对应一个实例。\nRequest：请求作用域，每个HTTP请求对应一个实例。\n\n\n使用：\n@Component@Scope(&quot;prototype&quot;)public class MyComponent &#123;    public void doSomething() &#123;        System.out.println(&quot;Doing something...&quot;);    &#125;&#125;\n\n在上述代码中，MyComponent类被标记为原型作用域。这意味着每次请求该Bean时，Spring都会创建一个新的实例。这种方式适用于需要独立实例的场景，例如工具类或状态管理类。通过@Scope注解，开发者可以灵活地控制Bean的生命周期，从而更好地满足应用的需求。\n\n扩展：\n@RequestScope &#x2F; @SessionScope &#x2F; @ApplicationScope\n\n作用：Web作用域的快捷注解（Spring 4+）\n等价于：@Scope(&quot;request&quot;), @Scope(&quot;session&quot;), @Scope(&quot;application&quot;)\n\n\n\n\n@PostConstruct\n\n作用：@PostConstruct注解用于定义Bean初始化后的方法。被标记的方法会在Bean实例化并注入依赖后自动执行，通常用于执行初始化逻辑。\n\n使用：\n@Componentpublic class MyComponent &#123;    @PostConstruct    public void init() &#123;        System.out.println(&quot;Bean initialized...&quot;);    &#125;&#125;\n\nMyComponent类的init()方法被标记为初始化后执行。这意味着在Bean实例化并注入依赖后，Spring会自动调用该方法。这种方式使得开发者可以在Bean初始化阶段执行必要的逻辑，例如资源分配或状态初始化。通过这种方式，开发者可以确保Bean在使用前处于正确的状态。\n\n\n\n@PreDestroy\n\n作用：@PreDestroy注解用于定义Bean销毁前的方法。被标记的方法会在Bean销毁前自动执行，通常用于执行清理逻辑。\n使用和@PostConstruct类似\n\n\n@DependsOn：依赖关系管理\n\n作用：强制指定当前Bean的依赖项，确保依赖项先初始化\n\n使用\n@Bean@DependsOn(&quot;databaseInitializer&quot;)public DataSource dataSource() &#123; ... &#125;\n\n\n@Description\n\n作用：为Bean添加描述信息（通常用于JMX等管理场景）\n\n\n@Value\n\n作用：在Spring应用中，配置文件（如application.properties）通常用于存储应用的配置信息。通过@Value注解，开发者可以将配置文件中的属性值注入到Bean中。\n\n$&#123;&#125;：从Environment中取值\n#&#123;&#125;：SpEL表达式\n\n\n使用：\n@Componentpublic class MyComponent &#123;    @Value(&quot;$&#123;my.property&#125;&quot;)    private String property;&#125;\n\n在上述代码中，@Value注解将配置文件中的my.property属性值注入到property字段中。这种方式使得开发者可以灵活地从配置文件中读取配置信息，而无需手动解析配置文件。通过这种方式，开发者可以实现配置的动态化管理，从而增强应用的灵活性。\n\n\n\n@Profile\n\n作用：在多环境开发中，某些Bean可能仅在特定环境下需要被加载。通过@Profile注解，开发者可以定义Bean所属的环境，例如开发环境（dev）、测试环境（test）或生产环境（prod）。\n\n\n\nImport组件导入\n@Import：导入其他配置类或组件（如@Configuration类）\n\n作用：将配置类、普通类或其他组件导入到当前 Spring 容器中，支持导入 @Configuration 类、ImportSelector 实现类和 ImportBeanDefinitionRegistrar 实现类\n\n使用：\n@Import(SomeService.class)@Configurationpublic class AppConfig &#123;    // ...&#125;\n\n这样，SomeService 类就会被注册为 Spring 容器中的一个 bean。\n使用ImportSelector动态导入\nImportSelector 是一个接口，可以实现动态选择要导入的类：\npublic class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        // 根据条件动态返回要导入的类        return new String[] &#123;            &quot;com.example.ServiceA&quot;,            &quot;com.example.ServiceB&quot;        &#125;;    &#125;&#125;@Import(MyImportSelector.class)@Configurationpublic class AppConfig &#123;    // ...&#125;\n\n\n@ImportResource\n\n作用：导入 XML 配置文件\n\n使用：\n@Configuration@ImportResource(&quot;classpath:legacy-config.xml&quot;)public class HybridConfig &#123; ... &#125;\n\n\n\n依赖注入注解\n@Autowired\n\n作用：自动注入依赖（默认按类型匹配），@Autowired 是 Spring 中最常用的依赖注入注解，其主要功能是自动装配 Bean。它可以作用于构造函数、字段、方法之上。默认情况下，它会依据类型进行自动装配，如果存在多个相同类型的 Bean，就会抛出异常。\n\n\n@Qualifier\n\n作用：当存在多个相同类型的 Bean 时，@Autowired 仅依据类型注入会产生歧义，此时就需要使用 @Qualifier 注解来指定要注入的 Bean 的名称，以此解决歧义问题。\n\n使用场景：\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;interface MyComponent &#123;&#125;class MyComponentImpl1 implements MyComponent &#123;&#125;class MyComponentImpl2 implements MyComponent &#123;&#125;@Servicepublic class MyService &#123;    private MyComponent myComponent;    @Autowired    @Qualifier(&quot;myComponentImpl1&quot;)    public MyService(MyComponent myComponent) &#123;        this.myComponent = myComponent;    &#125;    // 其他方法&#125;\n\n\n@Resource\n\n作用：它默认按照名称进行注入，如果找不到匹配的名称，就会按照类型进行注入。是Java标准注解，用于按名称注入依赖关系。与@Autowired类似，@Resource也可以用于字段、构造函数或方法。不同之处在于，@Resource支持通过name属性指定注入的Bean名称，这在存在多个同类型Bean时非常有用。\n\n\n@Inject\n\n作用：@Inject是Java标准注解，用于声明依赖注入。它与@Autowired功能类似都是依据类型进行注入，但遵循Java标准规范。不过，@Inject 没有 required 属性，即默认情况下注入的 Bean 必须存在。在Spring环境中，@Inject和@Autowired可以互换使用，但在某些情况下（例如与Java EE集成时），@Inject可能是更好的选择。\n\n\n@Value\n\n作用：@Value 注解主要用于将外部配置的值注入到 Bean 的字段中，这些外部配置可以来自属性文件、环境变量等。（如@Value(&quot;$&#123;key&#125;&quot;)或 SpEL 表达式）\n\n\n@Primary\n\n作用：当容器中存在多个相同类型的 Bean 时，使用 @Autowired 进行依赖注入会产生歧义。@Primary 注解的作用就是指定在这种情况下优先注入被该注解标记的 Bean。\n\n\n@Required\n\n作用：@Required 注解用于标记 Bean 的属性为必需的，即要求在配置 Bean 时必须为该属性注入值。不过，从 Spring 5.1 开始，该注解已被标记为过时，推荐使用构造器注入来确保依赖的必需性。\n\n使用：构造器注入能在对象创建时就确保依赖的注入，避免了在运行时出现依赖未注入的问题，提高了代码的健壮性。\nimport org.springframework.stereotype.Component;@Componentclass MyBean &#123;    private final String requiredProperty;    public MyBean(String requiredProperty) &#123;        this.requiredProperty = requiredProperty;    &#125;&#125;\n\n\n@Lookup\n\n作用：@Lookup 注解用于声明查找方法，主要用于获取原型作用域的 Bean。在 Spring 中，单例 Bean 默认会在容器启动时创建，并且在整个应用生命周期中只有一个实例。而原型作用域的 Bean 每次被请求时都会创建一个新的实例。当单例 Bean 需要使用原型作用域的 Bean 时，使用 @Lookup 注解可以确保每次获取到的都是新的原型 Bean 实例。\n\n\n\nAOP与切面编程\n@Aspect\n\n作用：该注解用于把一个类标记为切面类。切面类里包含了切入点和通知，这些可以对特定的方法进行增强。\n\n\n@Pointcut\n\n作用：@Pointcut 注解用于定义切点表达式，以此指定切入点。切入点明确了在哪些方法执行时会触发通知。\n\n\n@Before\n\n作用：@Before 注解定义的是前置通知，它会在目标方法执行之前执行。\n\n\n@After\n\n作用：@After 注解定义的是后置通知，无论目标方法是否抛出异常，它都会在目标方法执行之后执行。\n\n\n@AfterReturning\n\n作用：@AfterReturning 注解定义的是返回通知，它会在目标方法成功返回后执行。\n\n\n@AfterThrowing\n\n作用：@AfterThrowing 注解定义的是异常通知，它会在目标方法抛出异常后执行\n\n\n@Around\n\n作用：@Around 注解定义的是环绕通知，它能够完全控制目标方法的执行，既可以在目标方法执行前后添加额外的逻辑，还能决定是否执行目标方法。\n\n\n@EnableAspectJAutoProxy\n\n作用：@EnableAspectJAutoProxy 注解用于启用 AspectJ 自动代理功能，它需要和 @Configuration 注解一起使用，这样 Spring 就能自动识别并应用切面类。\n\n\n@DeclareParents\n\n作用：@DeclareParents 注解用于引入其他接口到目标类，从而实现接口增强。通过这个注解，目标类可以在不修改原有代码的情况下拥有新的接口和实现。\n\n使用：\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;import org.springframework.stereotype.Component;interface NewFeature &#123;    void performNewFeature();&#125;class NewFeatureImpl implements NewFeature &#123;    @Override    public void performNewFeature() &#123;        System.out.println(&quot;Performing new feature&quot;);    &#125;&#125;@Aspect@Componentpublic class IntroductionAspect &#123;    @DeclareParents(value = &quot;com.example.service.*+&quot;, defaultImpl = NewFeatureImpl.class)    public static NewFeature newFeature;&#125;\n\n在这个例子中，IntroductionAspect 切面类使用 @DeclareParents 注解将 NewFeature 接口引入到 com.example.service 包下的所有类中，默认实现为 NewFeatureImpl 类。\n\n\n\n\nJSON常用注解\n@JsonIgnoreProperties\n\n作用：此注解是类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。\n\n使用：\n//生成json时将name和age属性过滤@JsonIgnoreProperties(&#123;&quot;name&quot;&#125;,&#123;&quot;age&quot;&#125;)public class  user &#123;     private  String name;    private int age;&#125;\n\n\n@JsonIgnore\n\n作用：此注解用于属性或者方法上（最好是属性上），作用和上面的@JsonIgnoreProperties一样。\n\n\n@JsonFormat\n\n作用：此注解用于属性或者方法上（最好是属性上），格式化日期&#x2F;时间类型字段\n\n参数：\n\nshape：数据类型（如Shape.STRING）\npattern：自定义格式（如&quot;yyyy-MM-dd HH:mm&quot;）\n\n\n使用：\npublic class Event &#123;    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy/MM/dd&quot;)    private LocalDate eventDate;&#125;\n\n\n@JsonInclude\n\n作用：控制序列化时包含属性的规则\n取值：\nInclude.NON_NULL：排除null值\nInclude.NON_EMPTY：排除空值&#x2F;空集合\n\n\n\n\n@JsonSerialize\n\n作用：@JsonSerialize 注解通常用在属性或者 getter 方法上，其主要作用是在对象序列化为 JSON 格式时，嵌入自定义的序列化逻辑。在处理一些特殊类型的数据或者需要对数据进行特定格式转换时，这个注解就非常有用\n\n\n@JsonDeserialize\n\n作用：@JsonDeserialize 注解用于属性或者 setter 方法上，它的作用是在将 JSON 数据反序列化为 Java 对象时，嵌入自定义的反序列化逻辑。当 JSON 数据的格式和 Java 对象的属性类型不完全匹配，或者需要对数据进行一些预处理时，就可以使用这个注解。\n\n\n@Transient\n\n作用：在使用对象关系映射（ORM）框架（如 Hibernate）时，如果一个 Java 类的属性并非对应数据库表中的字段，就需要使用 @Transient 注解来标记这个属性。如果不标记，ORM 框架默认会将其视为数据库表字段，可能会导致错误。\n\n\n@JsonIgnoreType\n\n作用：@JsonIgnoreType 注解标注在类上，当其他类将该类作为属性时，这个属性在序列化过程中会被忽略，不会出现在生成的 JSON 数据中\n\n\n\n事件，异步与定时任务\n@EnableAsync\n\n作用：配置类中通过此注解开启对异步任务的支持；当你在配置类上添加了这个注解后，Spring 会自动扫描带有 @Async 注解的方法，并将这些方法的执行交给线程池来处理，从而实现异步执行。\n\n\n@Async：\n\n作用：@Async 注解用于标记一个方法为异步方法。当调用这个方法时，Spring 会将该方法的执行从当前线程中分离出来，放到线程池中异步执行，调用者线程不会被阻塞，可以继续执行后续的代码。\n\n使用：\nimport org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncService &#123;    @Async    public void asyncMethod() &#123;        try &#123;            // 模拟耗时操作            Thread.sleep(3000);            System.out.println(&quot;异步方法执行完成&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n在调用 asyncMethod 时，调用者线程不会等待该方法执行完毕，而是会继续执行后续代码。\n\n\n\n@EnableScheduling\n\n作用：此注解同样用在配置类上，用于开启 Spring 的定时任务调度功能。添加该注解后，Spring 会自动扫描带有 @Scheduled 注解的方法，并按照指定的时间规则定时执行这些方法。\n\n\n@Scheduled：\n\n作用：@Scheduled 注解用于标记一个方法为定时任务方法，它可以指定方法的执行时间规则。该注解支持多种时间表达式，常见的有 fixedRate、fixedDelay 和 cron 等。\n属性：\n**fixedRate**：指定方法执行的时间间隔，单位为毫秒。无论方法执行时间长短，下一次执行都会在上一次开始后的指定时间间隔后启动。\n**fixedDelay**：指定方法执行完成后，下一次执行的延迟时间，单位为毫秒。即上一次方法执行完毕后，等待指定的时间再执行下一次。\n**cron**：使用 Cron 表达式来指定方法的执行时间，Cron 表达式可以更灵活地定义执行时间规则。\n\n\n\n\n\nEnable***注解这些注解主要是用来开启对xxx的支持：\n\n@EnableAspectAutoProxy：开启对AspectJ自动代理的支持；\n\n@EnableAsync：开启异步方法的支持；\n\n@EnableScheduling：开启计划任务的支持；\n\n@EnableWebMvc：开启web MVC的配置支持；\n\n@EnableConfigurationProperties：开启对@ConfigurationProperties注解配置Bean的支持；\n\n@EnableJpaRepositories：开启对SpringData JPA Repository的支持；\n\n@EnableTransactionManagement：开启注解式事务的支持；\n\n@EnableCaching：开启注解式的缓存支持；\n\n\n测试相关\n@RunWith\n\n作用：运行器，Spring中通常用于对JUnit的支持\n\n\n@ContextConfiguration\n\n作用：用来加载配置配置文件，其中classes属性用来加载配置类。\n\n使用\n@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath*:/*.xml&quot;&#125;)public class CDPlayerTest &#123;&#125;\n\n@ContextConfiguration这个注解通常与@RunWith(SpringJUnit4ClassRunner.class)联合使用用来测试。\n@ContextConfiguration括号里的locations &#x3D; {“classpath*:&#x2F;*.xml”}就表示将classpath路径里所有的xml文件都包括进来，自动扫描的bean就可以拿到，此时就可以在测试类中使用@Autowired注解来获取之前自动扫描包下的所有bean。\n\n\n\n@SpringBootTest\n\n作用：启动完整Spring应用上下文\n\n参数：\n\nwebEnvironment：定义Web环境模式\nclasses：显式指定配置类\n\n\n示例：\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)class ApplicationIntegrationTests &#123; ... &#125;\n\n\n@MockBean\n\n作用：向应用上下文注入Mock对象（替换现有Bean）\n示例：\n\n@SpringBootTestclass UserServiceTest &#123;    @MockBean    private UserRepository userRepository;        @Autowired    private UserService userService;&#125;\n\n@SpyBean\n\n作用：对现有Bean进行部分Mock（保留原始实现）\n示例：\n\n@SpyBeanprivate EmailService emailService;\n\n@TestConfiguration\n\n作用：定义测试专用的配置类\n\n示例\n@TestConfigurationstatic class TestConfig &#123;    @Bean    public Clock testClock() &#123;        return Clock.fixed(Instant.now(), ZoneId.systemDefault());    &#125;&#125;\n\n\n\n其他注解\n@EqualsAndHashCode（Lombok）\n\n作用：自动生成 equals() 和 hashCode() 方法，避免手动编写冗余代码。\n\n参数：\n\ncallSuper：是否包含父类的字段（默认false）。若为true，生成的方法会调用super.equals()。\nexclude&#x2F;of：排除或指定参与计算的字段。\n\n\n注意：需添加 Lombok 依赖\n\n使用\n@EqualsAndHashCode(callSuper = true, exclude = &quot;age&quot;)public class Person extends Human &#123;    private String name;    private int age;&#125;\n\n\n@XmlAccessorType  (JAXB)\n\n作用：控制 JAXB 如何将 Java 对象与 XML 互相转换，指定字段&#x2F;属性的访问方式。类级别的注解，定义这个类中何种类型需要映射到XML。\n属性：\nXmlAccessType.FIELD：映射这个类中的所有字段到XML\nXmlAccessType.PROPERTY：映射这个类中的属性（get&#x2F;set方法）到XML\nXmlAccessType.PUBLIC_MEMBER：将这个类中的所有public的field或property同时映射到XML（默认）\nXmlAccessType.NONE：不映射\n\n\n\n\n\n引用自Spring Framework 的详细注解大全的注解表格核心容器与配置\n\n\n注解\n说明\n\n\n\n@Configuration\n标记类为配置类，替代 XML 配置\n\n\n@Bean\n在配置类中声明一个 Bean，由 Spring 容器管理\n\n\n@Component\n通用组件注解，标记类为 Spring 管理的 Bean\n\n\n@ComponentScan\n自动扫描并注册指定包下的组件（如@Component、@Service等）\n\n\n@Import\n导入其他配置类或组件（如@Configuration类）\n\n\n@PropertySource\n加载外部属性文件（如.properties或.yml）\n\n\n@Lazy\n延迟初始化 Bean\n\n\n@Scope\n定义 Bean 的作用域（如singleton 、prototype 、request等）\n\n\n@DependsOn\n指定当前 Bean 依赖的其他 Bean，确保初始化顺序\n\n\n@Profile\n指定 Bean 或配置仅在特定环境下生效（如dev、prod）\n\n\n@Conditional\n基于条件决定是否注册 Bean（自定义条件逻辑）\n\n\n@Service\n标记服务层组件（@Component的特化）\n\n\n@Repository\n标记数据访问层组件（@Component的特化），支持异常转换\n\n\n@Controller\n标记 MVC 控制器组件（@Component的特化）\n\n\n@Role\n定义 Bean 的角色（如ROLE_APPLICATION 、ROLE_INFRASTRUCTURE）\n\n\n@Description\n为 Bean 添加描述信息（通常用于监控或文档）\n\n\n@PropertySources\n组合多个@PropertySource\n\n\n@ImportResource\n导入 XML 配置文件\n\n\n@Order\n定义 Bean 的加载顺序（值越小优先级越高）\n\n\n@AliasFor\n为注解属性声明别名（用于元注解组合）\n\n\n@RequestScope\n定义 Bean 的作用域为 HTTP 请求级别\n\n\n@SessionScope\n定义 Bean 的作用域为 HTTP 会话级别\n\n\n@ApplicationScope\n定义 Bean 的作用域为 ServletContext 级别\n\n\n依赖注入（DI）\n\n\n注解\n说明\n\n\n\n@Autowired\n自动注入依赖（默认按类型匹配）\n\n\n@Qualifier\n按名称指定注入的 Bean，配合@Autowired使用\n\n\n@Primary\n当存在多个同类型 Bean 时，优先注入被标记的 Bean\n\n\n@Value\n注入属性值（如@Value(&quot;$&#123;key&#125;&quot;)或 SpEL 表达式）\n\n\n@Required\n标记 Bean 属性为必需（已过时，推荐使用构造器注入）\n\n\n@Lookup\n声明查找方法，用于获取原型作用域的 Bean\n\n\n@Resource\nJSR-250 注解，按名称注入依赖（类似@Autowired + @Qualifier）\n\n\n@Inject\nJSR-330 注解（需引入javax.inject），功能类似@Autowired\n\n\nAOP 与切面编程\n\n\n注解\n说明\n\n\n\n@Aspect\n标记类为切面类\n\n\n@Pointcut\n定义切点表达式，指定切入点\n\n\n@Before\n在目标方法执行前执行\n\n\n@After\n在目标方法执行后执行（无论是否抛出异常）\n\n\n@AfterReturning\n在目标方法成功返回后执行\n\n\n@AfterThrowing\n在目标方法抛出异常后执行\n\n\n@Around\n环绕通知，可完全控制目标方法执行\n\n\n@EnableAspectJAutoProxy\n启用 AspectJ 自动代理（需配合@Configuration）\n\n\n@DeclareParents\n引入其他接口到目标类（实现接口增强）\n\n\n数据访问与事务\n\n\n注解\n说明\n\n\n\n@Transactional\n声明事务管理（类或方法级别），可配置隔离级别、传播行为等\n\n\n@Repository\n标记数据访问层（DAO）组件，支持异常转换（如将 SQL 异常转换为 Spring 异常）\n\n\n@PersistenceContext\n注入 JPA 的EntityManager\n\n\n@PersistenceUnit\n注入 JPA 的EntityManagerFactory\n\n\n@Sql\n在测试方法执行前 &#x2F; 后运行 SQL 脚本\n\n\n@SqlMergeMode\n控制测试类与方法的@Sql注解合并方式\n\n\nWeb&#x2F;MVC 相关\n\n\n注解\n说明\n\n\n\n@Controller\n标记类为 MVC 控制器\n\n\n@RequestMapping\n映射 HTTP 请求路径（支持method 、produces等属性）\n\n\n@RequestParam\n绑定请求参数到方法参数\n\n\n@PathVariable\n绑定 URL 路径变量到方法参数\n\n\n@RequestBody\n将请求体反序列化为对象（如 JSON&#x2F;XML）\n\n\n@ResponseBody\n将方法返回值序列化为响应体（如 JSON）\n\n\n@ModelAttribute\n绑定请求参数到模型对象，或添加模型数据\n\n\n@SessionAttributes\n将模型属性存储到 HTTP Session 中\n\n\n@CookieValue\n绑定 Cookie 值到方法参数\n\n\n@RequestHeader\n绑定请求头到方法参数\n\n\n@ExceptionHandler\n处理控制器内的异常\n\n\n@ControllerAdvice\n全局异常处理类，可结合@ExceptionHandler\n\n\n@InitBinder\n自定义请求参数绑定逻辑\n\n\n@CrossOrigin\n允许跨域请求（Spring 4.2 + 支持）\n\n\n@RestController\n组合@Controller和@ResponseBody（Spring 4.0+）\n\n\n@GetMapping&#x2F;@PostMapping\n@RequestMapping的快捷方式（如@GetMapping(&quot;/path&quot;)）\n\n\n@PutMapping\n@RequestMapping(method = PUT)的快捷方式\n\n\n@DeleteMapping\n@RequestMapping(method = DELETE)的快捷方式\n\n\n@PatchMapping\n@RequestMapping(method = PATCH)的快捷方式\n\n\n@MatrixVariable\n绑定 URL 矩阵变量（如/users;id=1）\n\n\n@RestControllerAdvice\n组合@ControllerAdvice和@ResponseBody\n\n\n@ResponseStatus\n定义 HTTP 响应状态码（如@ResponseStatus(HttpStatus.NOT_FOUND)）\n\n\n测试相关\n\n\n注解\n说明\n\n\n\n@ContextConfiguration\n指定测试类的 Spring 配置（如 XML 或配置类）\n\n\n@WebAppConfiguration\n标记测试类需要加载 Web 应用上下文\n\n\n@DirtiesContext\n标记测试后需要重置 Spring 上下文\n\n\n@TestExecutionListeners\n自定义测试执行监听器\n\n\n@TestPropertySource\n为测试类指定属性文件或键值对\n\n\n@DynamicPropertySource\n动态注册测试属性（如集成测试中的数据库端口）\n\n\n@Sql\n在测试方法执行前 &#x2F; 后运行 SQL 脚本\n\n\n事件与异步\n\n\n注解\n说明\n\n\n\n@EventListener\n标记方法为事件监听器（监听 Spring 事件）\n\n\n@Async\n标记方法为异步执行（需启用@EnableAsync）\n\n\n@EnableAsync\n启用异步方法执行支持\n\n\n@Scheduled\n定义定时任务（需启用@EnableScheduling）\n\n\n@EnableScheduling\n启用定时任务支持\n\n\n消息与 WebSocket\n\n\n注解\n说明\n\n\n\n@MessageMapping\n映射消息到处理方法（如 WebSocket 消息）\n\n\n@SubscribeMapping\n处理订阅请求（如 STOMP 协议）\n\n\n@SendTo\n指定方法返回值的发送目标（如广播消息）\n\n\n@DestinationVariable\n绑定消息目标路径中的变量\n\n\n@MessageExceptionHandler\n处理消息处理过程中的异常\n\n\n缓存相关\n\n\n注解\n说明\n\n\n\n@Cacheable\n缓存方法结果（需启用@EnableCaching）\n\n\n@CachePut\n更新缓存\n\n\n@CacheEvict\n清除缓存\n\n\n@Caching\n组合多个缓存操作\n\n\n@CacheConfig\n在类级别统一配置缓存属性\n\n\n@EnableCaching\n启用缓存支持\n\n\n校验与格式化\n\n\n注解\n说明\n\n\n\n@Valid\n触发 Bean 验证（JSR-303&#x2F;JSR-349 规范，需引入 Hibernate Validator）\n\n\n@Validated\nSpring 的校验注解，支持分组校验\n\n\n@DateTimeFormat\n格式化日期时间字段（如@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)）\n\n\n@NumberFormat\n格式化数字字段\n\n\nJSR 标准注解支持\n\n\n注解\n说明\n\n\n\n@PostConstruct\nJSR-250 注解，标记 Bean 初始化后执行的方法\n\n\n@PreDestroy\nJSR-250 注解，标记 Bean 销毁前执行的方法\n\n\n@Resource\nJSR-250 注解，按名称注入依赖（类似@Autowired + @Qualifier）\n\n\n@Inject\nJSR-330 注解（需引入javax.inject），功能类似@Autowired\n\n\n@Named\nJSR-330 注解，功能类似@Component或@Qualifier\n\n\n空安全注解\n\n\n注解\n说明\n\n\n\n@NonNull\n标记字段、参数或返回值不可为null（编译时检查）\n\n\n@Nullable\n标记字段、参数或返回值可为null\n\n\n@NonNullApi\n包级别注解，默认所有参数和返回值不可为null\n\n\n@NonNullFields\n包级别注解，默认所有字段不可为null\n\n\n响应式编程（WebFlux）\n\n\n注解\n说明\n\n\n\n@WebFluxTest\n针对 WebFlux 控制器的切片测试\n\n\n@EnableWebFlux\n启用 WebFlux 配置（替代@EnableWebMvc）\n\n\n国际化与资源\n\n\n注解\n说明\n\n\n\n@MessageSource\n注入国际化消息源（需配置ResourceBundleMessageSource）\n\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"SpringFrameworkPart7-JDBCTemplate事务-上","url":"/posts/58016.html","content":"什么是 JdbcTemplateSpring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作。\nJdbcTemplate 是 Spring 框架 提供的一个核心 JDBC 工具类，位于 org.springframework.jdbc.core 包中。它简化了 JDBC 数据库操作，避免了繁琐的 JDBC 代码编写，提高了开发效率。\n在Spring使用JDBC，首先我们通过IoC容器创建并管理一个DataSource实例，然后，Spring提供了一个JdbcTemplate，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个JdbcTemplate。顾名思义，这个类主要使用了Template模式。\n作用：\n\n执行 SQL 语句：JdbcTemplate 提供了多种方法来执行 SQL 语句，包括查询、更新、插入、删除等。  \n处理结果集：JdbcTemplate 可以自动将查询结果转换为 Java 对象，简化了结果集的处理。  \n管理数据库连接：JdbcTemplate 自动管理数据库连接的获取和释放，避免了资源泄漏。  \n处理异常：JdbcTemplate 将 JDBC 异常转换为 Spring 的统一数据访问异常，方便进行异常处理。  \n支持事务：JdbcTemplate 可以与 Spring 的事务管理机制集成，实现事务控制。\n\nJava程序使用JDBC接口访问关系数据库的时候，需要以下几步：\n\n创建全局DataSource实例，表示数据库连接池；\n在需要读写数据库的方法内部，按如下步骤访问数据库：\n从全局DataSource实例获取Connection实例；\n通过Connection实例创建PreparedStatement实例；\n执行SQL语句，如果是查询，则通过ResultSet读取结果集，如果是修改，则获得int结果。\n\n\n\n正确编写JDBC代码的关键是使用try ... finally释放资源，涉及到事务的代码需要正确提交或回滚事务。\n实现CURD 增删改查我们可以将 JdbcTemplate 的创建权交给 Spring，将数据源 DataSource 的创建权也交给 Spring\n在Spring容器内部将数据源 DataSource 注入到 JdbcTemplate 模版对象中,然后通过 Spring 容器获得 JdbcTemplate 对象来执行操作\n准备工作新建子模块，引入如下依赖\n&lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;         &lt;scope&gt;runtime&lt;/scope&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifactId&gt;lombok&lt;/artifactId&gt;         &lt;optional&gt;true&lt;/optional&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;         &lt;scope&gt;test&lt;/scope&gt;     &lt;/dependency&gt;\n\n创建 jdbc.properties，配置数据库连接池\n将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护\nspring.application.name=spring6-jdbcspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/SpringJDBCTemple?serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=truespring.datasource.username=spring.datasource.password=\n\n配置 Spring 的配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 开启组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;edu.software.ergoutree.spring6jdbc&quot;/&gt;    &lt;!-- 引入外部属性文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.zaxxer.hikari.HikariDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;spring.datasource.url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;spring.datasource.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;spring.datasource.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置JdbcTemplate, 注入 DataSource--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启事务注解 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n创建需要连接的数据库 \nCREATE DATABASE IF NOT EXISTS SpringJDBCTemple;USE SpringJDBCTemple;CREATE TABLE IF NOT EXISTS t_user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(50) NOT NULL,    age INT,    email VARCHAR(100)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \n\n进行测试\npackage edu.software.ergoutree.spring6jdbc;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass Spring6JdbcApplicationTests &#123;    @Test    public void testJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //通过接口来获取数据源对象        DataSource dataSource = ioc.getBean(&quot;dataSource&quot;, DataSource.class);        Connection connection = dataSource.getConnection();        System.out.println(&quot;dataSource&#x27;s class = &quot; + dataSource.getConnection());        System.out.println(&quot;connection = &quot; + connection);        connection.close();    &#125;&#125;\n\n\n\n通过 JDBCTemplate 实现数据的添加，修改，删除实例向表中新增两条记录，用两种方法实现\n// 数据添加@Testpublic void InsertJdbcTemplate() throws SQLException &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    DataSource dataSource = ioc.getBean(&quot;dataSource&quot;, DataSource.class);    Connection connection = dataSource.getConnection();    System.out.println(&quot;dataSource&#x27;s class = &quot; + dataSource.getConnection());    System.out.println(&quot;connection = &quot; + connection);    JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);    String sql1 = &quot;INSERT INTO t_user VALUE (1113, &#x27;zjmd&#x27;, 23, &#x27;3783489@qq.com&#x27;);&quot;;    String sql2 = &quot;INSERT INTO t_user VALUE (?, ?, ?, ?);&quot;;    // 添加方式1  通过execute的方式    jdbcTemplate.execute(sql1);    //添加方式二 ：通过update方法添加，按照顺序传递参数    int affectedRows = jdbcTemplate.update(sql2, 221, &quot;wh&quot;, 34, &quot;234e3434@email.com&quot;);    System.out.println(&quot;affected rows = &quot; + affectedRows);    connection.close();&#125;\n\n测试通过，发现可以插入数据\n注意的是 excute() 是 JDBC 原生方法的简单封装，用于执行完整 SQL 字符串\n// 注意：需手动转义参数值，避免安全问题！int id = 111;String name = &quot;zjm&quot;;int age = 23;String unsafeSql = String.format(&quot;INSERT INTO t_user VALUES (%d, &#x27;%s&#x27;, %d)&quot;, id, name, age);jdbcTemplate.execute(unsafeSql); // 仅用于演示，生产环境禁止！// 只能做到静态sql语句的插入\n\n修改和删除的方法类\n// 数据修改    @Test    public void UpdateJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);        // 方式1：直接执行静态SQL        String sql1 = &quot;UPDATE t_user SET name=&#x27;zjm_updated&#x27;, age=25 WHERE id=1113&quot;;        jdbcTemplate.execute(sql1);        // 方式2：使用参数化SQL（推荐）        String sql2 = &quot;UPDATE t_user SET name=?, age=? WHERE id=?&quot;;        int affectedRows = jdbcTemplate.update(sql2, &quot;wh_updated&quot;, 35, 221);        System.out.println(&quot;Updated rows: &quot; + affectedRows);    &#125;\n\n// 数据删除    @Test    public void DeleteJdbcTemplate() throws SQLException &#123;        ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);        // 方式1：直接执行静态SQL        String sql1 = &quot;DELETE FROM t_user WHERE id=1113&quot;;        jdbcTemplate.execute(sql1);        // 方式2：使用参数化SQL（推荐）        String sql2 = &quot;DELETE FROM t_user WHERE id=?&quot;;        int affectedRows = jdbcTemplate.update(sql2, 221);        System.out.println(&quot;Deleted rows: &quot; + affectedRows);    &#125;\n\nupdate方法详解可以看到，JDBCTemplate对数据库的增删改操作都是update方法，执行最终的效果只根据语句有关系\nupdate 方法的主要作用是执行 SQL 语句并返回受影响的行数。它可以执行的 SQL 语句包括 INSERT、UPDATE 和 DELETE 语句。\n返回值：update 方法的返回值是一个整数，表示 SQL 语句执行后受影响的行数\n\n其中方法的重载形式：\nint update(String sql)\n\n参数说明：\nsql：要执行的 SQL 语句。\n\n\n使用场景：当 SQL 语句中不包含参数时，可以使用这个方法。例如，删除表中所有数据：\n\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;DELETE FROM users&quot;;int rows = jdbcTemplate.update(sql);System.out.println(&quot;删除的行数: &quot; + rows);\n\n int update(String sql, @Nullable Object... args)\n\n参数说明\nsql：要执行的 SQL 语句，其中可以包含占位符 ?。\nargs：SQL 语句中占位符对应的参数值，参数的顺序要和占位符的顺序一致。\n\n\n使用场景：当 SQL 语句中包含参数时，可以使用这个方法。例如，插入一条新记录：\n\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;;Object[] args = &#123;&quot;John&quot;, 25&#125;;int rows = jdbcTemplate.update(sql, args);System.out.println(&quot;插入的行数: &quot; + rows);\n\nint update(String sql, PreparedStatementSetter pss)\n\n参数说明\nsql：要执行的 SQL 语句，其中可以包含占位符 ?。\npss：一个 PreparedStatementSetter 接口的实现类，用于设置 PreparedStatement 对象的参数。\n\n\n使用场景：当需要更复杂的参数设置逻辑时，可以使用这个方法。例如：\n\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.PreparedStatementSetter;import java.sql.PreparedStatement;import java.sql.SQLException;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;UPDATE users SET age = ? WHERE name = ?&quot;;int age = 26;String name = &quot;John&quot;;int rows = jdbcTemplate.update(sql, new PreparedStatementSetter() &#123;    @Override    public void setValues(PreparedStatement ps) throws SQLException &#123;        ps.setInt(1, age);        ps.setString(2, name);    &#125;&#125;);System.out.println(&quot;更新的行数: &quot; + rows);\n\n异常处理\nupdate 方法可能会抛出 DataAccessException 及其子类的异常，例如 SQLException 等。在实际使用中，建议捕获这些异常并进行相应的处理。例如：\nimport org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已经正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;DELETE FROM users&quot;;try &#123;    int rows = jdbcTemplate.update(sql);    System.out.println(&quot;删除的行数: &quot; + rows);&#125; catch (DataAccessException e) &#123;    System.err.println(&quot;数据库操作出错: &quot; + e.getMessage());&#125;\n\n\n\n通过 JDBCTemplate 实现数据的查询案例// 数据查询    @Test    public void SelectJdbcTemplate() throws SQLException &#123;        String sql = &quot;SELECT * FROM t_user WHERE id=?&quot;;        // 查询返回 Map        Map&lt;String, Object&gt; userMap = jdbcTemplate.queryForMap(sql, 1113);        System.out.println(&quot;User as Map: &quot; + userMap);        // 查询返回对象        // 写法1        User user = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; &#123;            User u = new User();            u.setId(rs.getInt(&quot;id&quot;));            u.setName(rs.getString(&quot;name&quot;));            u.setAge(rs.getInt(&quot;age&quot;));            u.setEmail(rs.getString(&quot;email&quot;));            return u;        &#125;, 1113);        System.out.println(&quot;User as Object: &quot; + user);        // 写法2        User user2 = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 1113);        System.out.println(&quot;User as Object: &quot; + user2);        // 返回集合        // 返回List&lt;User&gt;        List&lt;User&gt; users = jdbcTemplate.query(sql, (rs, rowNum) -&gt; &#123;            User u = new User();            u.setId(rs.getInt(&quot;id&quot;));            u.setName(rs.getString(&quot;name&quot;));            u.setAge(rs.getInt(&quot;age&quot;));            u.setEmail(rs.getString(&quot;email&quot;));            return u;        &#125;, 20);        System.out.println(&quot;Users as Objects: &quot; + users);        // 返回List&lt;Map&gt;        List&lt;Map&lt;String, Object&gt;&gt; userMaps = jdbcTemplate.queryForList(sql, 20);        System.out.println(&quot;Users as Maps: &quot; + userMaps);        // 返回单个值，查询有多少记录        String sql2 = &quot;select count(*) from t_user&quot;;        Integer count = jdbcTemplate.queryForObject(sql2, Integer.class);        System.out.println(&quot;Count of users: &quot; + count);    &#125;\n\nqueryForObject方法详解可以看到，JDBCTemplate对数据库的增删改操作都是queryForObject方法，执行的结果跟这个方法重载的各种类型有关系。\n在queryForObject()方法中，传入SQL以及SQL参数后，JdbcTemplate会自动创建PreparedStatement，自动执行查询并返回ResultSet，我们提供的RowMapper需要做的事情就是把ResultSet的当前行映射成一个JavaBean并返回。整个过程中，使用Connection、PreparedStatement和ResultSet都不需要我们手动管理。\nJdbcTemplate 中的 queryForObject 方法主要用于执行 SQL 查询语句，并期望返回单个结果对象（集合）.\nqueryForObject 方法用于执行查询操作，且预期查询结果为单个对象。当你确定查询只会返回一条记录时，就可以使用这个方法将结果映射到指定的对象类型中。\n常见重载形式\n T queryForObject(String sql, Class requiredType)\n\n参数说明\n\nsql：要执行的 SQL 查询语句，此语句一般用于查询单个值，如查询某一列的总和、平均值等。\n\n\nrequiredType：期望返回结果的类型，比如 Integer、String 等。\n\n使用场景：当查询结果是单个值时使用。例如，查询 users 表中的用户总数：\n\n\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT COUNT(*) FROM users&quot;;Integer userCount = jdbcTemplate.queryForObject(sql, Integer.class);System.out.println(&quot;用户总数: &quot; + userCount);\n\nT queryForObject(String sql, Object[] args, Class requiredType)\n\n参数说明\n\nsql：包含占位符 ? 的 SQL 查询语句。\n\n\nargs：SQL 语句中占位符对应的参数值数组，参数顺序需与占位符顺序一致。\n\nrequiredType：期望返回结果的类型。\n\n\n使用场景：当查询语句包含参数且结果为单个值时使用。例如，查询名为 John 的用户的年龄：\n\n\nimport org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT age FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;John&quot;&#125;;Integer age = jdbcTemplate.queryForObject(sql, args, Integer.class);System.out.println(&quot;John 的年龄: &quot; + age);\n\nT queryForObject(String sql, RowMapper rowMapper)\n\n参数说明\n\nsql：要执行的 SQL 查询语句，用于查询完整的记录。\n\n\nrowMapper：RowMapper 接口的实现类，用于将查询结果集中的每一行数据映射到指定类型的对象。\n\n使用场景：当查询结果是一条完整的记录，需要将其映射到自定义对象时使用。例如，查询 id 为 1 的用户信息\n\n\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT * FROM users WHERE id = 1&quot;;User user = jdbcTemplate.queryForObject(sql, new RowMapper&lt;User&gt;() &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        return user;    &#125;&#125;);System.out.println(user);\n\nT queryForObject(String sql, Object[] args, RowMapper rowMapper)\n\n参数说明\n\nsql：包含占位符 ? 的 SQL 查询语句。\n\n\nargs：SQL 语句中占位符对应的参数值数组。\n\nrowMapper：RowMapper 接口的实现类，用于将查询结果集中的每一行数据映射到指定类型的对象。\n\n\n使用场景：当查询语句包含参数，且需要将查询结果映射到自定义对象时使用。例如，查询名为 John 的用户信息：\n\n\nimport org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT * FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;John&quot;&#125;;User user = jdbcTemplate.queryForObject(sql, args, new RowMapper&lt;User&gt;() &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        return user;    &#125;&#125;);System.out.println(user);\n\n返回值\nqueryForObject 方法的返回值是一个指定类型的对象。如果查询结果为空，该方法可能会抛出 EmptyResultDataAccessException 异常；如果查询结果有多条记录，也会抛出异常。\n异常处理\n在使用 queryForObject 方法时，需要注意处理可能抛出的异常，如 EmptyResultDataAccessException 和 IncorrectResultSizeDataAccessException。\nimport org.springframework.dao.EmptyResultDataAccessException;import org.springframework.jdbc.core.JdbcTemplate;// 假设 jdbcTemplate 已正确初始化JdbcTemplate jdbcTemplate = ...;String sql = &quot;SELECT age FROM users WHERE name = ?&quot;;Object[] args = &#123;&quot;NonExistentUser&quot;&#125;;try &#123;    Integer age = jdbcTemplate.queryForObject(sql, args, Integer.class);    System.out.println(&quot;年龄: &quot; + age);&#125; catch (EmptyResultDataAccessException e) &#123;    System.err.println(&quot;未找到符合条件的记录: &quot; + e.getMessage());&#125;\n\n\n\n更进阶的使用数据批量处理JdbcTemplate 提供 batchUpdate() 方法实现批量操作，适合一次性处理大量数据，提升性能。\n参数说明：\n\nbatchUpdate(String sql, List batchArgs)：\nbatchArgs 中每个 Object[] 对应 SQL 中的一组参数。\n\n\n\n@Testpublic void BatchInsertJdbcTemplate() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    JdbcTemplate jdbcTemplate = ioc.getBean(&quot;jdbcTemplate&quot;, JdbcTemplate.class);    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (?, ?, ?)&quot;;        // 批量数据：参数为 Object 数组的集合    List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();    batchArgs.add(new Object[]&#123;&quot;Alice&quot;, 28, &quot;alice@example.com&quot;&#125;);    batchArgs.add(new Object[]&#123;&quot;Bob&quot;, 32, &quot;bob@example.com&quot;&#125;);    batchArgs.add(new Object[]&#123;&quot;Charlie&quot;, 25, &quot;charlie@example.com&quot;&#125;);    // 执行批量插入    int[] affectedRows = jdbcTemplate.batchUpdate(sql, batchArgs);    System.out.println(&quot;插入行数统计: &quot; + Arrays.toString(affectedRows));&#125;\n\n\n\n查询到的数据封装到 Bean 对象通过 RowMapper 或 BeanPropertyRowMapper 将结果集自动映射到 Java 对象。\n自定义 RowMapper\npublic class UserRowMapper implements RowMapper&lt;User&gt; &#123;    @Override    public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;        User user = new User();        user.setId(rs.getInt(&quot;id&quot;));        user.setName(rs.getString(&quot;name&quot;));        user.setAge(rs.getInt(&quot;age&quot;));        user.setEmail(rs.getString(&quot;email&quot;));        return user;    &#125;&#125;// 使用示例@Testpublic void QueryWithCustomRowMapper() &#123;    String sql = &quot;SELECT * FROM t_user WHERE age &gt; ?&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         new UserRowMapper(),         20  // 参数：age &gt; 20    );    System.out.println(&quot;Users: &quot; + users);&#125;\n\n使用 BeanPropertyRowMapper\nSpring 提供的自动映射工具，要求数据库字段名与 Java 对象属性名一致（如 user_name → userName）。\n@Testpublic void QueryWithBeanPropertyRowMapper() &#123;    String sql = &quot;SELECT * FROM t_user&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         new BeanPropertyRowMapper&lt;&gt;(User.class)    );    System.out.println(&quot;Users: &quot; + users);&#125;\n\n\n\n查询到的数据以Bean对象的形式封装到集合中直接使用 query() 方法返回 List，适用于查询多条记录。\n@Testpublic void QueryAllUsersAsBeanList() &#123;    String sql = &quot;SELECT * FROM t_user&quot;;    List&lt;User&gt; users = jdbcTemplate.query(        sql,         (rs, rowNum) -&gt; &#123;            User user = new User();            user.setId(rs.getInt(&quot;id&quot;));            user.setName(rs.getString(&quot;name&quot;));            user.setAge(rs.getInt(&quot;age&quot;));            user.setEmail(rs.getString(&quot;email&quot;));            return user;        &#125;    );    System.out.println(&quot;All Users: &quot; + users);&#125;\n\n\n\n查询单行单列的具体字段使用 queryForObject() 直接返回基本类型值（如 Integer, String）。\n@Testpublic void QuerySingleValue() &#123;    // 查询最大年龄    String sqlMaxAge = &quot;SELECT MAX(age) FROM t_user&quot;;    Integer maxAge = jdbcTemplate.queryForObject(sqlMaxAge, Integer.class);    System.out.println(&quot;最大年龄: &quot; + maxAge);    // 查询特定用户的邮箱    String sqlEmail = &quot;SELECT email FROM t_user WHERE name = ?&quot;;    String email = jdbcTemplate.queryForObject(        sqlEmail,         String.class,         &quot;Alice&quot;    );    System.out.println(&quot;Alice 的邮箱: &quot; + email);&#125;\n\n\n\n\n\n使用具名参数添加数据以往我们使用SQL语句时，总是用到占位符 ? ，就像我们上面刚刚用到的SQL语句\n这么做有个问题——除非我们知道对应表的结构，不然就无法确定这个占位符? 应该传入什么参数。\n使用具名参数可以很好的解决这个问题。\n通过 NamedParameterJdbcTemplate 支持具名参数（如 :name），提升 SQL 可读性。\n首先在之前的 xml 配置文件下新配置一个 NamedParameterJdbcTemplate 对象，如下\n&lt;bean id=&quot;namedParameterJdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;\n\n@Testpublic void InsertWithNamedParameters() &#123;    ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    NamedParameterJdbcTemplate namedTemplate = ioc.getBean(        &quot;namedParameterJdbcTemplate&quot;,         NamedParameterJdbcTemplate.class    );    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (:name, :age, :email)&quot;;        // 使用 Map 传递参数    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();    params.put(&quot;name&quot;, &quot;David&quot;);    params.put(&quot;age&quot;, 29);    params.put(&quot;email&quot;, &quot;david@example.com&quot;);    int affectedRows = namedTemplate.update(sql, params);    System.out.println(&quot;插入行数: &quot; + affectedRows);&#125;\n\n使用 SqlParameterSource\n更灵活的传参方式（支持 Bean 对象自动映射）：\n@Testpublic void InsertWithSqlParameterSource() &#123;    NamedParameterJdbcTemplate namedTemplate = ...; // 获取 Bean    String sql = &quot;INSERT INTO t_user (name, age, email) VALUES (:name, :age, :email)&quot;;        // 使用 BeanPropertySqlParameterSource    User newUser = new User();    newUser.setName(&quot;Eva&quot;);    newUser.setAge(27);    newUser.setEmail(&quot;eva@example.com&quot;);        SqlParameterSource params = new BeanPropertySqlParameterSource(newUser);    int affectedRows = namedTemplate.update(sql, params);    System.out.println(&quot;插入行数: &quot; + affectedRows);&#125;\n\n\n\n总结我们总结一下JdbcTemplate的用法，那就是：\n\n针对简单查询，优选query()和queryForObject()，因为只需提供SQL语句、参数和RowMapper；\n针对更新操作，优选update()，因为只需提供SQL语句和参数；\n任何复杂的操作，最终也可以通过execute(ConnectionCallback)实现，因为拿到Connection就可以做任何JDBC操作。\n\n实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用BeanPropertyRowMapper就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。\n例如，表的列名是office_address，而JavaBean属性是workAddress，就需要指定别名，改写查询如下\nSELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?\n\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"SpringFrameworkPart7-JDBCTemplate事务-下","url":"/posts/8801.html","content":"声明式事务控制关于事务理解事务事务是一组操作的执行单元，相对于数据库操作来讲，事务管理的是一组SQL指令，比如增加，修改，删除等\n事务的一致性，要求，这个事务内的操作必须全部执行成功，如果在此过程种出现了差错，比如有一条SQL语句没有执行成功，那么这一组操作都将全部回滚\n事务由事务开始和事务结束之间执行的全部数据库操作组成。\n事务四大特性原子性A：事务是不可分割的最小操作单元，要么全成功，要么全失败\n一致性C：事务完成时，必须所据都保持一致状态\n隔离性I：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下进行\n持久性D：事务一旦提交或回滚，他对数据库的改变是永久的\n声明式事务控制理解声明式事务Spring 对事务逻辑的代码有封装，在配置文件中或者注解管理即可实现相关操作\nSpring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在Spring 配置文件中声明式的处理事务来代替代码式的处理事务\n声明式事务处理的作用\n\n事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可\n在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便\n\nSpring提供了一个PlatformTransactionManager来表示事务管理器，所有的事务都由它负责管理。而事务由TransactionStatus表示。如果手写事务代码，使用try...catch如下\nTransactionStatus tx = null;try &#123;    // 开启事务:    tx = txManager.getTransaction(new DefaultTransactionDefinition());    // 相关JDBC操作:    jdbcTemplate.update(&quot;...&quot;);    jdbcTemplate.update(&quot;...&quot;);    // 提交事务:    txManager.commit(tx);&#125; catch (RuntimeException e) &#123;    // 回滚事务:    txManager.rollback(tx);    throw e;&#125;\n\nSpring为啥要抽象出PlatformTransactionManager和TransactionStatus？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction  API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。\nSpring为了同时支持JDBC和JTA两种事务模型，就抽象出PlatformTransactionManager。因为我们的代码只需要JDBC事务，因此，在AppConfig中，需要再定义一个PlatformTransactionManager对应的Bean，它的实际类型是DataSourceTransactionManager：\n@Configuration@ComponentScan@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...    @Bean    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n\n\n\n\n\nSpring 声明式事务控制底层就是AOP\n编程式：自己写代码实现功能\n声明式：通过配置让框架实现框架实现\n编程式事务控制相关对象PlatformTransactionManagerPlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。例如获取事务状态、提交事务和回滚事务等。\n\nPlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类\n例如：\n\nDao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager\n\nDao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager\n\n\nTransactionDefinitionTransactionDefinition 是事务的定义信息对象，包含了事务的隔离级别、传播行为、超时时间和是否只读等信息。\n\nTransactionStatusTransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。\n在 Spring 的编程式事务管理里，TransactionStatus 对象由 PlatformTransactionManager 的 getTransaction() 方法返回。它记录了事务的当前状态，例如事务是否为新开启的、是否已完成等，并且能让开发者对事务进行控制，比如提交或者回滚事务。\n常用方法\n\nisNewTransaction()\n\n\n功能：判断当前事务是否为新开启的事务。若返回 true，表示该事务是在此次调用 getTransaction() 方法时新开启的；若返回 false，则说明当前事务是已存在事务的一部分（比如在事务传播行为是 REQUIRED 时，加入了已有的事务）。\n\n\nhasSavepoint()\n\n\n功能：判断当前事务是否有保存点。保存点是事务中的一个标记，可让事务部分回滚到该标记处，而非整个事务回滚。\n\n\nsetRollbackOnly()\n\n\n功能：将当前事务标记为仅回滚。一旦调用此方法，事务在结束时会被强制回滚，即便后续代码尝试提交事务也不会生效。\n\n\nisRollbackOnly()\n\n\n功能：检查当前事务是否已被标记为仅回滚。\n\n\nisCompleted()\n\n\n功能：判断事务是否已经完成，即是否已经提交或者回滚。\n\n声明式事务控制说明使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。使用声明式事务非常简单，除了在AppConfig中追加一个上述定义的PlatformTransactionManager外，再加一个@EnableTransactionManagement就可以启用声明式事务：\n@Configuration@ComponentScan@EnableTransactionManagement // 启用声明式@PropertySource(&quot;jdbc.properties&quot;)public class AppConfig &#123;    ...&#125;\n\n然后，对需要事务支持的方法，加一个@Transactional注解：\n@Componentpublic class UserService &#123;    // 此public方法自动具有事务支持:    @Transactional    public User register(String email, String password, String name) &#123;       ...    &#125;&#125;\n\n或者更简单一点，直接在Bean的class处加上，表示所有public方法都具有事务支持：\n@Component@Transactionalpublic class UserService &#123;    ...&#125;\n\n\n\n\n\n事务隔离级别SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：\n\n读未提交（READ UNCOMMITTED）\n读提交 （READ COMMITTED）\n可重复读 （REPEATABLE READ）\n串行化 （SERIALIZABLE）\n\n从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是 MySQL 的默认级别。\n事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度\n\n事务传播行为\nREQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）\n\nSUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）\n\nMANDATORY：使用当前的事务，如果当前没有事务，就抛出异常\n\nREQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。\n\nNOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n\nNEVER：以非事务方式运行，如果当前存在事务，抛出异常\n\nNESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作\n\n超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置\n\n是否只读：建议查询时设置为只读\n\n\n示例假设我们有一个简单的用户账户表，需要进行转账操作。\n我们需要配置 Spring 的上下文和数据源\n&lt;!-- applicationContext.xml --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置 JdbcTemplate --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置业务服务 --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.example.AccountService&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n然后，我们创建一个 AccountService 类来处理转账业务：\npackage com.example;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.TransactionDefinition;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.DefaultTransactionDefinition;public class AccountService &#123;    private JdbcTemplate jdbcTemplate;    private PlatformTransactionManager transactionManager;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;        this.transactionManager = transactionManager;    &#125;    public void transferMoney(int fromAccountId, int toAccountId, double amount) &#123;        // 定义事务属性        TransactionDefinition def = new DefaultTransactionDefinition();        // 获取事务状态        TransactionStatus status = transactionManager.getTransaction(def);        try &#123;            // 减少转出账户的余额            jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, amount, fromAccountId);            // 模拟异常            // int result = 1 / 0;            // 增加转入账户的余额            jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, amount, toAccountId);            // 提交事务            transactionManager.commit(status);        &#125; catch (Exception e) &#123;            // 回滚事务            transactionManager.rollback(status);            e.printStackTrace();        &#125;    &#125;&#125;\n\n最后，我们可以编写一个测试类来调用 AccountService 的 transferMoney 方法\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123;    public static void main(String[] args) &#123;        // 加载 Spring 上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        // 获取 AccountService 实例        AccountService accountService = (AccountService) context.getBean(&quot;accountService&quot;);        // 执行转账操作        accountService.transferMoney(1, 2, 100.0);    &#125;&#125;\n\n在这个示例中，我们使用 PlatformTransactionManager 和 TransactionDefinition 来手动管理事务。在 transferMoney 方法中，我们首先获取事务状态，然后执行数据库操作，如果操作过程中出现异常，我们会回滚事务，否则提交事务。\n基于 XML 的声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。\n声明式事务控制明确事项：\n\n谁是切点？\n谁是通知？\n配置切面？\n\n配置事务管理器与命名空间在 applicationContext.xml 中添加事务相关命名空间及事务管理器配置：\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;           http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd           http://www.springframework.org/schema/tx           http://www.springframework.org/schema/tx/spring-tx.xsd           http://www.springframework.org/schema/aop           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!-- 数据源配置（同上） --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- JdbcTemplate 配置（同上） --&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 业务服务 --&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.example.AccountService&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 声明式事务配置 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 配置事务属性：方法名匹配规则 --&gt;            &lt;tx:method name=&quot;transferMoney&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;                        timeout=&quot;-1&quot; read-only=&quot;false&quot; rollback-for=&quot;Exception&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- AOP 切面配置 --&gt;    &lt;aop:config&gt;        &lt;!-- 定义切点：匹配业务层方法 --&gt;        &lt;aop:pointcut id=&quot;servicePointcut&quot;                       expression=&quot;execution(* com.example.AccountService.*(..))&quot;/&gt;        &lt;!-- 将事务通知与切点关联 --&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;servicePointcut&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n\n\n\n配置项\n作用\n\n\n\n&lt;tx:advice&gt;\n定义事务通知，指定事务管理器和事务属性\n\n\n&lt;tx:method&gt;\n配置具体方法的事务规则（如传播行为、隔离级别）\n\n\n&lt;aop:pointcut&gt;\n定义切点，匹配需要事务管理的方法\n\n\n&lt;aop:advisor&gt;\n将事务通知与切点关联，实现声明式事务控制\n\n\n移除 AccountService 中的 PlatformTransactionManager 依赖和手动事务管理代码：\npackage com.example;import org.springframework.jdbc.core.JdbcTemplate;public class AccountService &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    public void transferMoney(int fromAccountId, int toAccountId, double amount) &#123;        // 减少转出账户的余额        jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, amount, fromAccountId);        // 模拟异常（测试回滚）        // int result = 1 / 0;        // 增加转入账户的余额        jdbcTemplate.update(&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, amount, toAccountId);    &#125;&#125;\n\n事务属性详解\n在 &lt;tx:method&gt; 标签中配置事务规则：\n\n\n\n属性\n说明\n\n\n\nname\n匹配的方法名（支持通配符，如 * 表示所有方法）\n\n\npropagation\n事务传播行为（默认 REQUIRED）\n\n\nisolation\n事务隔离级别（默认 DEFAULT，使用数据库默认隔离级别）\n\n\ntimeout\n事务超时时间（单位秒，默认 -1 表示不超时）\n\n\nread-only\n是否只读事务（默认 false，查询操作建议设为 true）\n\n\nrollback-for\n触发回滚的异常类型（如 Exception 表示所有异常均回滚）\n\n\nno-rollback-for\n不触发回滚的异常类型\n\n\n编写测试类验证事务是否生效\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        AccountService accountService = (AccountService) context.getBean(&quot;accountService&quot;);        try &#123;            // 正常转账（事务提交）            accountService.transferMoney(1, 2, 100.0);                        // 模拟异常（事务回滚）            // accountService.transferMoney(1, 2, 100.0); // 内部有 int result = 1 / 0;        &#125; catch (Exception e) &#123;            System.err.println(&quot;事务回滚：&quot; + e.getMessage());        &#125;    &#125;&#125;\n\n\n\n基于注解的声明式事务控制注解的方式，只需在方法上面加一个@Transaction注解，那么方法执行之前spring会自动开启一个事务，方法执行完毕之后，会自动提交或者回滚事务，而方法内部没有任何事务相关代码，用起来特别的方便。\n将会通过如下完整示例进行说明\n首先创建数据库表\n-- 银行账户表CREATE TABLE IF NOT EXISTS t_account (    id INT PRIMARY KEY AUTO_INCREMENT,    account_no VARCHAR(20) NOT NULL UNIQUE,    account_name VARCHAR(50) NOT NULL,    balance DECIMAL(10,2) NOT NULL DEFAULT 0.00,    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- 交易记录表CREATE TABLE IF NOT EXISTS t_transaction (    id INT PRIMARY KEY AUTO_INCREMENT,    from_account_id INT NOT NULL,    to_account_id INT NOT NULL,    amount DECIMAL(10,2) NOT NULL,    transaction_time DATETIME DEFAULT CURRENT_TIMESTAMP,    status VARCHAR(20) NOT NULL,    remark VARCHAR(200),    FOREIGN KEY (from_account_id) REFERENCES t_account(id),    FOREIGN KEY (to_account_id) REFERENCES t_account(id)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n创建实体类\n// 实体类 账户package edu.software.ergoutree.spring6jdbc.affairs.entity;import lombok.Data;import java.math.BigDecimal;import java.time.LocalDateTime;@Datapublic class Account &#123;    private Integer id;    private String accountNo;    private String accountName;    private BigDecimal balance;    private LocalDateTime createTime;    private LocalDateTime updateTime;&#125;\n\n// 实体类 表示一次交易package edu.software.ergoutree.spring6jdbc.affairs.entity;import lombok.Data;import java.math.BigDecimal;import java.time.LocalDateTime;@Datapublic class Transaction &#123;    private Integer id;    private Integer fromAccountId;    private Integer toAccountId;    private BigDecimal amount;    private LocalDateTime transactionTime;    private String status;    private String remark;&#125;\n创建 DAO 层\npackage edu.software.ergoutree.spring6jdbc.affairs.dao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import java.math.BigDecimal;// 账户数据访问对象的接口public interface AccountDao &#123;    Account findById(Integer id);   // 根据账户 ID 查询账户信息    Account findByAccountNo(String accountNo);   // 根据账户号码查询账户信息    void updateBalance(Integer id, BigDecimal balance);   // 更新指定账户的余额    void save(Account account);   // 保存新的账户信息到数据库&#125;\n\n// 实现了 AccountDao 接口，使用 JdbcTemplate 与数据库进行交互。package edu.software.ergoutree.spring6jdbc.affairs.dao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.math.BigDecimal;@Repositorypublic class AccountDaoImpl implements AccountDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public Account findById(Integer id) &#123;        String sql = &quot;SELECT * FROM t_account WHERE id = ?&quot;;        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), id);    &#125;    @Override    public Account findByAccountNo(String accountNo) &#123;        String sql = &quot;SELECT * FROM t_account WHERE account_no = ?&quot;;        // 将查询结果映射到 Account 实体类。        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Account.class), accountNo);    &#125;    @Override    public void updateBalance(Integer id, BigDecimal balance) &#123;        String sql = &quot;UPDATE t_account SET balance = ? WHERE id = ?&quot;;        jdbcTemplate.update(sql, balance, id);    &#125;    @Override    public void save(Account account) &#123;        String sql = &quot;INSERT INTO t_account (account_no, account_name, balance) VALUES (?, ?, ?)&quot;;        jdbcTemplate.update(sql, account.getAccountNo(), account.getAccountName(), account.getBalance());    &#125;&#125;\n\n创建 Service 层\npackage edu.software.ergoutree.spring6jdbc.affairs.service;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import java.math.BigDecimal;// 定义了账户服务的接口public interface AccountService &#123;    void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount);  // 转账    Account createAccount(Account account);   // 新建账户    Account getAccount(String accountNo);   // 根据账户号码查询账户信息&#125; \n\npackage edu.software.ergoutree.spring6jdbc.affairs.service;import edu.software.ergoutree.spring6jdbc.affairs.dao.AccountDao;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import java.math.BigDecimal;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao accountDao;    @Override    // @Transactional 用于声明事务的属性    @Transactional(        propagation = Propagation.REQUIRED,        rollbackFor = Exception.class,   // 任何异常都会触发回滚。        timeout = 30    )    public void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;        // 查询转出账户        Account fromAccount = accountDao.findByAccountNo(fromAccountNo);        if (fromAccount == null) &#123;            throw new RuntimeException(&quot;转出账户不存在&quot;);        &#125;        // 查询转入账户        Account toAccount = accountDao.findByAccountNo(toAccountNo);        if (toAccount == null) &#123;            throw new RuntimeException(&quot;转入账户不存在&quot;);        &#125;        // 检查余额是否足够        if (fromAccount.getBalance().compareTo(amount) &lt; 0) &#123;            throw new RuntimeException(&quot;账户余额不足&quot;);        &#125;        // 执行转账        BigDecimal fromBalance = fromAccount.getBalance().subtract(amount);        BigDecimal toBalance = toAccount.getBalance().add(amount);        // 更新账户余额        accountDao.updateBalance(fromAccount.getId(), fromBalance);        accountDao.updateBalance(toAccount.getId(), toBalance);    &#125;    @Override    @Transactional(propagation = Propagation.REQUIRED)    public Account createAccount(Account account) &#123;        accountDao.save(account);        return account;    &#125;    @Override    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)    public Account getAccount(String accountNo) &#123;        return accountDao.findByAccountNo(accountNo);    &#125;&#125; \n我们对需使用事务的目标上加@Transaction注解\n\n@Transaction放在接口上，那么接口的实现类中所有public都被spring自动加上事务\n@Transaction放在类上，那么当前类以及其下无限级子类中所有pubilc方法将被spring自动加上事务\n@Transaction放在public方法上，那么该方法将被spring自动加上事务\n注意：**@Transaction只对public方法有效**\n\n下面我们看一下@Transactional源码：\n@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Transactional &#123;     /**     * 指定事务管理器的bean名称，如果容器中有多事务管理器PlatformTransactionManager，     * 那么你得告诉spring，当前配置需要使用哪个事务管理器     */    @AliasFor(&quot;transactionManager&quot;)    String value() default &quot;&quot;;     /**     * 同value，value和transactionManager选配一个就行，也可以为空，如果为空，默认会从容器中按照类型查找一个事务管理器bean     */    @AliasFor(&quot;value&quot;)    String transactionManager() default &quot;&quot;;     /**     * 事务的传播属性     */    Propagation propagation() default Propagation.REQUIRED;     /**     * 事务的隔离级别，就是制定数据库的隔离级别，数据库隔离级别大家知道么？不知道的可以去补一下     */    Isolation isolation() default Isolation.DEFAULT;     /**     * 事务执行的超时时间（秒），执行一个方法，比如有问题，那我不可能等你一天吧，可能最多我只能等你10秒     * 10秒后，还没有执行完毕，就弹出一个超时异常吧     */    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;     /**     * 是否是只读事务，比如某个方法中只有查询操作，我们可以指定事务是只读的     * 设置了这个参数，可能数据库会做一些性能优化，提升查询速度     */    boolean readOnly() default false;     /**     * 定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常及其子类异常的时候，spring会让事务回滚     * 如果不配做，那么默认会在 RuntimeException 或者 Error 情况下，事务才会回滚      */    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;     /**     * 和 rollbackFor 作用一样，只是这个地方使用的是类名     */    String[] rollbackForClassName() default &#123;&#125;;     /**     * 定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常的时候，事务不会回滚     */    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;     /**     * 和 noRollbackFor 作用一样，只是这个地方使用的是类名     */    String[] noRollbackForClassName() default &#123;&#125;; &#125;\n\n参数介绍\n\n\n\n参数\n描述\n\n\n\nvalue\n指定事务管理器的bean名称，如果容器中有多事务管理器PlatformTransactionManager，那么你得告诉spring，当前配置需要使用哪个事务管理器\n\n\ntransactionManager\n同value，value和transactionManager选配一个就行，也可以为空，如果为空，默认会从容器中按照类型查找一个事务管理器bean\n\n\npropagation\n事务的传播属性，下篇文章详细介绍\n\n\nisolation\n事务的隔离级别，就是制定数据库的隔离级别，数据库隔离级别大家知道么？不知道的可以去补一下\n\n\ntimeout\n事务执行的超时时间（秒），执行一个方法，比如有问题，那我不可能等你一天吧，可能最多我只能等你10秒 10秒后，还没有执行完毕，就弹出一个超时异常吧\n\n\nreadOnly\n是否是只读事务，比如某个方法中只有查询操作，我们可以指定事务是只读的 设置了这个参数，可能数据库会做一些性能优化，提升查询速度\n\n\nrollbackFor\n定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常及其子类异常的时候，spring会让事务回滚 如果不配做，那么默认会在 RuntimeException 或者 Error 情况下，事务才会回滚\n\n\nrollbackForClassName\n同 rollbackFor，只是这个地方使用的是类名\n\n\nnoRollbackFor\n定义零(0)个或更多异常类，这些异常类必须是Throwable的子类，当方法抛出这些异常的时候，事务不会回滚\n\n\nnoRollbackForClassName\n同 noRollbackFor，只是这个地方使用的是类名\n\n\n通过 @Transactional 注解，Spring 会自动管理事务的开始、提交和回滚。在@Transaction标注类或者目标方法上执行业务操作，此时这些方法会自动被spring进行事务管理\n在 transfer 方法中，如果在转账过程中出现任何异常，事务会自动回滚，确保数据的一致性\n下面讲解一些出现的注解：\n\n@Transactional 注解\t：用于声明事务的属性。\npropagation：事务传播行为\nPropagation.REQUIRED 表示如果当前没有事务，则创建一个新事务；如果已经存在一个事务，则加入该事务。\nPropagation.SUPPORTS 表示如果当前存在事务，则加入该事务；如果不存在事务，则以非事务方式执行。\n\n\nrollbackFor：指定哪些异常会触发事务回滚，这里指定为 Exception.class 表示任何异常都会触发回滚。\ntimeout：指定事务的超时时间，单位为秒。\nreadOnly：指定事务是否为只读事务，用于提高查询性能。\nisolation ：指定事务的隔离级别\n\n\n\n扩展事务功能\n嵌套事务与传播行为 REQUIRES_NEW\n场景: 日志记录操作需要独立事务，不受主事务回滚影响。\n\n@Servicepublic class LogService &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    // 独立事务：即使转账失败，日志仍需记录    @Transactional(propagation = Propagation.REQUIRES_NEW)    public void logTransaction(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;        String sql = &quot;INSERT INTO t_transaction (from_account_id, to_account_id, amount, status) VALUES (?, ?, ?, ?)&quot;;        jdbcTemplate.update(sql, fromAccountNo, toAccountNo, amount, &quot;PROCESSING&quot;);    &#125;&#125;// 修改 AccountServiceImpl 的转账方法@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public void transfer(String fromAccountNo, String toAccountNo, BigDecimal amount) &#123;    // ...原有逻辑...    // 记录交易日志（独立事务）    logService.logTransaction(fromAccountNo, toAccountNo, amount);    // 模拟异常（主事务回滚，但日志记录成功）    // int a = 1 / 0;&#125;\n\n\n\n控制隔离级别和只读事务的配置\n// 控制隔离级别解决脏读问题@Transactional(isolation = Isolation.READ_COMMITTED)public BigDecimal getAccountBalance(String accountNo) &#123;    return accountDao.findByAccountNo(accountNo).getBalance();&#125;// 只读事务优化查询@Transactional(readOnly = true)public List&lt;Transaction&gt; getTransactionHistory(String accountNo) &#123;    return accountDao.getTransactionHistory(accountNo);&#125;\n\n注解优先级和类级的配置\n@Service@Transactional(isolation = Isolation.READ_COMMITTED, timeout = 10) // 类级默认配置public class AccountServiceImpl implements AccountService &#123;    @Override    @Transactional(isolation = Isolation.SERIALIZABLE, timeout = 30) // 方法级覆盖    public void highConcurrencyTransfer(...) &#123; ... &#125;&#125;\n\n若容器中存在多个事务管理器，需通过 transactionManager 指定：\n@Transactional(transactionManager = &quot;orderTransactionManager&quot;)public void createOrder(...) &#123; ... &#125;\n\n\n\n\n\n新建一个测试类测试上述代码能否正常执行\npackage edu.software.ergoutree.spring6jdbc.affairs;import edu.software.ergoutree.spring6jdbc.affairs.entity.Account;import edu.software.ergoutree.spring6jdbc.affairs.service.AccountService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.transaction.annotation.Transactional;import java.math.BigDecimal;import static org.junit.jupiter.api.Assertions.*;@SpringBootTest@Transactionalpublic class AccountServiceTest &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer() &#123;        // 创建两个账户        Account account1 = new Account();        account1.setAccountNo(&quot;1001&quot;);        account1.setAccountName(&quot;张三&quot;);        account1.setBalance(new BigDecimal(&quot;1000.00&quot;));        accountService.createAccount(account1);        Account account2 = new Account();        account2.setAccountNo(&quot;1002&quot;);        account2.setAccountName(&quot;李四&quot;);        account2.setBalance(new BigDecimal(&quot;500.00&quot;));        accountService.createAccount(account2);        // 执行转账        accountService.transfer(&quot;1001&quot;, &quot;1002&quot;, new BigDecimal(&quot;200.00&quot;));        // 验证转账结果        Account updatedAccount1 = accountService.getAccount(&quot;1001&quot;);        Account updatedAccount2 = accountService.getAccount(&quot;1002&quot;);        assertEquals(new BigDecimal(&quot;800.00&quot;), updatedAccount1.getBalance());        assertEquals(new BigDecimal(&quot;700.00&quot;), updatedAccount2.getBalance());    &#125;    @Test    public void testTransferWithInsufficientBalance() &#123;        // 创建两个账户        Account account1 = new Account();        account1.setAccountNo(&quot;1003&quot;);        account1.setAccountName(&quot;王五&quot;);        account1.setBalance(new BigDecimal(&quot;100.00&quot;));        accountService.createAccount(account1);        Account account2 = new Account();        account2.setAccountNo(&quot;1004&quot;);        account2.setAccountName(&quot;赵六&quot;);        account2.setBalance(new BigDecimal(&quot;500.00&quot;));        accountService.createAccount(account2);        // 尝试转账超过余额的金额        assertThrows(RuntimeException.class, () -&gt; &#123;            accountService.transfer(&quot;1003&quot;, &quot;1004&quot;, new BigDecimal(&quot;200.00&quot;));        &#125;);        // 验证余额未改变        Account updatedAccount1 = accountService.getAccount(&quot;1003&quot;);        Account updatedAccount2 = accountService.getAccount(&quot;1004&quot;);        assertEquals(new BigDecimal(&quot;100.00&quot;), updatedAccount1.getBalance());        assertEquals(new BigDecimal(&quot;500.00&quot;), updatedAccount2.getBalance());    &#125;&#125; \n\n另外可以操作如下测试方法\n@Testpublic void testNestedTransaction() &#123;    // 创建账户    Account account1 = accountService.createAccount(...);    Account account2 = accountService.createAccount(...);    try &#123;        // 转账并记录日志（主事务抛异常）        accountService.transfer(&quot;1001&quot;, &quot;1002&quot;, new BigDecimal(&quot;200.00&quot;));    &#125; catch (Exception e) &#123;        // 验证主事务回滚        Account updatedAccount1 = accountService.getAccount(&quot;1001&quot;);        assertEquals(1000.00, updatedAccount1.getBalance());        // 验证日志记录事务提交        List&lt;Transaction&gt; logs = logService.getTransactionHistory(&quot;1001&quot;);        assertFalse(logs.isEmpty());    &#125;&#125;","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework"]},{"title":"Spring Framework part8-Spring Resources接口与资源访问","url":"/posts/54991.html","content":"Resource接口和实现类Resource接口JDK提供的访问资源的类(如java.NET.URL,File)等并不能很好很方便的满足各种底层资源的访问需求。Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。\nSpring的Resource接口位于org.sprigframework.core.io中。旨在实现一个更強大的接口，用于抽象对低级资源的方向。以下演示了Resource接口定义的方法\n/** * 用于描述资源的接口，该接口抽象了底层资源的实际类型，如文件或类路径资源。 * * &lt;p&gt;对于每个资源，如果它在物理形式上存在，都可以打开一个输入流，但只有某些资源才能返回 URL 或文件句柄。具体行为取决于其实现。 */public interface Resource extends InputStreamSource &#123;    /**     * 判断此资源是否在物理形式上真正存在。     */    boolean exists();    /**     * 指示是否可以通过 &#123;@link #getInputStream()&#125; 读取此资源的非空内容。     * 实际的内容读取可能仍然失败。     */    default boolean isReadable() &#123;        return exists();    &#125;    /**     * 指示此资源是否代表一个打开的流的句柄。     * 如果为 true，则输入流不能被多次读取，并且在读取后必须被关闭，以避免资源泄露。     */    default boolean isOpen() &#123;        return false;    &#125;    /**     * 判断此资源是否代表文件系统中的文件。     */    default boolean isFile() &#123;        return false;    &#125;    /**     * 返回此资源的 URL 句柄。     */    URL getURL() throws IOException;    /**     * 返回此资源的 URI 句柄。     */    URI getURI() throws IOException;    /**     * 返回此资源的文件句柄。     */    File getFile() throws IOException;    /**     * 返回一个 &#123;@link ReadableByteChannel&#125;。     */    default ReadableByteChannel readableChannel() throws IOException &#123;        return Channels.newChannel(getInputStream());    &#125;    /**     * 确定此资源的内容长度。     */    long contentLength() throws IOException;    /**     * 确定此资源的最后修改时间戳。     */    long lastModified() throws IOException;    /**     * 创建相对于此资源的资源。     */    Resource createRelative(String relativePath) throws IOException;    /**     * 返回此资源的文件名。     */    @Nullable    String getFilename();    /**     * 返回此资源的描述，用于在处理资源时的错误输出。     */    String getDescription();&#125;\n\nResource接口継承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。\nInputStreamSource接口，只有一个方法:\n/** * 表示可以提供输入流的资源或对象的接口。 */public interface InputStreamSource &#123;\t/**\t * 返回基础资源内容的 InputStream。\t * 期望每次调用都会创建一个新的流。\t * @return 基础资源的输入流（不能为 null）\t * @throws java.io.FileNotFoundException 如果基础资源不存在\t * @throws IOException 如果无法打开内容流\t */\tInputStream getInputStream() throws IOException;&#125;\n\n\n\nResource的实现类Resource接口是Spring资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成，每个实现类代表-一种资源访问策略。Resource-一般包括这些实现类: UrlResource，ClassPathResource，FilsSystemResource，ServletContextResource，InputStreamResource，ByteArrayResource\nUrlResource用于访问通过 URL 表示的资源，比如 http:// 开头的网络资源（如网页、远程文件等），也可以是 file:// 开头的本地文件资源。它会根据 URL 的协议来决定如何获取资源。例如，当你需要访问一个远程服务器上的文件时，就可以使用 UrlResource。代码示例如下\nimport org.springframework.core.io.UrlResource;import java.net.URL;public class UrlResourceExample &#123;    public static void main(String[] args) throws Exception &#123;        URL url = new URL(&quot;http://example.com/somefile.txt&quot;);        UrlResource resource = new UrlResource(url);        // 这里可以进行资源的读取等操作，比如获取输入流        java.io.InputStream inputStream = resource.getInputStream();        // 处理输入流        inputStream.close();    &#125;&#125;\n\n\n\nClassPathResource用于访问类路径下的资源文件。在 Java 项目中，类路径通常包含 src/main/resources（在 Maven 或 Gradle 项目结构中）这样的目录。它会从类加载器的类路径中查找资源。例如，如果你有一个配置文件 application.properties 放在 src/main/resources 目录下，你可以通过 ClassPathResource 来获取它。示例代码：\npackage edu.software.ergoutree.springresources;import org.springframework.core.io.ClassPathResource;import java.io.IOException;import java.io.InputStream;// 访问类路径下的资源public class ClassPathDemo &#123;    public static void main(String[] args) &#123;        loadClassPathResources(&quot;test&quot;);    &#125;    public static void loadClassPathResources(String path)&#123;        // 创建对象 ClassPathResource        ClassPathResource resource = new ClassPathResource(path);        System.out.println(resource.getFilename());        System.out.println(resource.getDescription());        try &#123;            InputStream in = resource.getInputStream();            byte[] bytes = new byte[in.available()];            while (in.read(bytes) != -1)&#123;                System.out.println(new String(bytes));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n\n\nFileSystemResource用于访问本地文件系统中的资源。它通过文件路径来定位资源，不管是绝对路径还是相对路径（相对于当前工作目录）。比如你要访问本地磁盘上的一个文件，就可以使用 FileSystemResource。\npackage edu.software.ergoutree.springresources;import org.springframework.core.io.FileSystemResource;import java.io.IOException;import java.io.InputStream;// 访问系统资源public class FileSystemResourceDemo &#123;    public static void loadFileResource(String fileName) &#123;        // 创建对象        FileSystemResource resource = new FileSystemResource(fileName);        System.out.println(resource.getFilename());        System.out.println(resource.getDescription());        try &#123;            InputStream in = resource.getInputStream();            byte[] bytes = new byte[in.available()];            while (in.read(bytes) != -1)&#123;                System.out.println(new String(bytes));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        loadFileResource(&quot;Spring Framework\\\\Spring6Exp\\\\spring-resources\\\\src\\\\main\\\\resources\\\\test&quot;);    &#125;&#125;\n\n\n\nServletContextResource\n主要用于在 Web 应用（基于 Servlet 的应用）中访问 ServletContext 相关的资源。它根据 ServletContext 来解析资源路径，通常用于访问 Web 应用根目录下的资源，比如 WEB-INF 目录下的文件。在 Spring Web 应用中使用较多。例如：\nimport org.springframework.web.context.ServletContextAware;import org.springframework.web.context.support.ServletContextResource;import javax.servlet.ServletContext;public class ServletContextResourceExample implements ServletContextAware &#123;    private ServletContext servletContext;    @Override    public void setServletContext(ServletContext servletContext) &#123;        this.servletContext = servletContext;    &#125;    public void accessResource() &#123;        ServletContextResource resource = new ServletContextResource(servletContext, &quot;/WEB-INF/somefile.txt&quot;);        try &#123;            java.io.InputStream inputStream = resource.getInputStream();            // 处理输入流            inputStream.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\nInputStreamResource允许你将一个已有的 InputStream 包装成 Resource 对象。当你已经通过其他方式获取到了一个输入流，但是又想将其作为 Resource 来使用时，就可以使用这个类。比如从数据库中读取二进制数据得到了一个 InputStream，然后可以将其包装为 InputStreamResource。示例：\nimport org.springframework.core.io.InputStreamResource;import java.io.ByteArrayInputStream;import java.io.IOException;public class InputStreamResourceExample &#123;    public static void main(String[] args) throws IOException &#123;        String data = &quot;Some sample data&quot;;        ByteArrayInputStream inputStream = new ByteArrayInputStream(data.getBytes());        InputStreamResource resource = new InputStreamResource(inputStream);        // 这里可以对 resource 进行操作，比如获取输入流        java.io.InputStream actualInputStream = resource.getInputStream();        // 处理输入流        actualInputStream.close();    &#125;&#125;\n\n\n\nByteArrayResource用于将字节数组包装成 Resource 对象。它适用于将内存中的字节数据当作一种资源来处理。例如，如果你在程序中生成了一些字节数据，然后想要以 Resource 的形式使用它，就可以使用 ByteArrayResource。示例代码：\nimport org.springframework.core.io.ByteArrayResource;import java.io.IOException;public class ByteArrayResourceExample &#123;    public static void main(String[] args) throws IOException &#123;        byte[] byteArray = &quot;Hello, World!&quot;.getBytes();        ByteArrayResource resource = new ByteArrayResource(byteArray);        // 可以获取输入流来读取字节数组内容        java.io.InputStream inputStream = resource.getInputStream();        // 处理输入流        inputStream.close();    &#125;&#125;\n\n\n\n这些 Resource 接口的实现类，为在 Spring 应用中访问不同类型的资源提供了方便和统一的方式，使得开发者可以根据具体的资源来源选择合适的实现类来进行资源操作。\n\nResourceLoader接口Spring提供了如下两个标志性接口\nResourceLoader：该接口的实现类实例可以获得一个Resource实例\nResourceLoaderAware:该接口的实现类实例可以获得一个ResourceLoader的引用\norg.springframework.core.io.ResourceLoader 是 Spring 框架中的一个关键接口，它定义了如何获取资源（例如类路径资源、文件系统资源或网页资源）的策略。这个接口是 Spring 资源加载抽象的核心，使得应用程序可以从不同的资源位置以统一的方式加载资源。\nSpring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是FileSystemXmlApplicationContext, res 就是FileSystemResource实例;如果ApplicationContext是ClassPathXmIApplicationContext, res 就是ClassPathResource实例\n当Spring应用需要进行资源访问时，实际上并不需要直接使用 Resource 实现类，而是调用 ResourceLoader 实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来\n另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类.（多态）\nResource res = ctx.getResource(&quot;classpath:bean.xml&quot;);Resource res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;https://localhost8080.bean.xml&quot;);\n\n\n\n主要功能\n统一资源加载ResourceLoader 提供了一个标准化的方法来加载资源，不论资源是存放在类路径、文件系统、网络URL还是其他位置。\n\n资源位置解析根据提供的资源字符串位置（如 “classpath:”, “file:”, “http:”），ResourceLoader 可以确定资源的类型，并为其创建相应的 Resource 实例。\n\n返回 Resource 实例通过 Resource getResource(String location) 方法，ResourceLoader 返回一个 Resource 对象，代表了指定位置的资源。这使得读取和操作资源变得简单且统一。\n\n与 ClassLoader 的交互ResourceLoader 通过 ClassLoader getClassLoader() 方法返回与其关联的 ClassLoader。这使得资源加载策略可以与特定的类加载器关联。\n\n扩展性ResourceLoader 是一个接口，这意味着我们可以实现自己的资源加载策略，或者扩展默认的策略以满足特定需求。\n\n内置实现与整合\n  Spring 提供了默认的 ResourceLoader 实现，如 DefaultResourceLoader。但更重要的是，org.springframework.context.ApplicationContext 也实现了 ResourceLoader，这意味着 Spring 上下文本身就是一个资源加载器。\n\n\n接口源码ResourceLoader 接口为 Spring 框架定义了资源加载策略。它提供了获取资源的方法，并公开了其使用的 ClassLoader。通过这种策略，资源可以从各种来源（如类路径、文件系统等）以统一方式加载。这提供了资源加载的灵活性和一致性，并支持各种资源描述符，如 URL、类路径等。此外，它还允许对资源句柄进行多次重新使用和读取。\n/** * 用于加载资源（例如类路径或文件系统资源）的策略接口。 * 一个 ApplicationContext 需要提供此功能以及扩展的 ResourcePatternResolver 支持。 *  * DefaultResourceLoader 是一个独立的实现，可在 ApplicationContext 外部使用，并被 ResourceEditor 使用。 *  * 当在 ApplicationContext 中运行时，类型为 Resource 和 Resource[] 的 Bean 属性可以从字符串中填充，使用特定上下文的资源加载策略。 * * @author Juergen Hoeller * @since 10.03.2004 */public interface ResourceLoader &#123;\t/** 用于从类路径加载的伪 URL 前缀：&quot;classpath:&quot;。 */\tString CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\t/**\t * 返回指定资源位置的 Resource 句柄。\t * 该句柄应始终是一个可重用的资源描述符，允许进行多次 Resource#getInputStream() 调用。\t * 必须支持完全限定的 URLs，例如 &quot;file:C:/test.dat&quot;。\t * 必须支持类路径伪-URLs，例如 &quot;classpath:test.dat&quot;。\t * 应支持相对文件路径，例如 &quot;WEB-INF/test.dat&quot;。\t * （这将是实现特定的，通常由 ApplicationContext 实现提供。）\t * 请注意，Resource 句柄并不意味着资源存在；我们需要调用 Resource#exists 来检查其存在性。\t *\t * @param location 资源位置\t */\tResource getResource(String location);\t/**\t * 公开此 ResourceLoader 使用的 ClassLoader。\t * 需要直接访问 ClassLoader 的客户端可以与 ResourceLoader 以统一的方式这样做，而不是依赖线程上下文 ClassLoader。\t *\t * @return ClassLoader（仅当连系统 ClassLoader 都不可访问时为 null）\t */\t@Nullable\tClassLoader getClassLoader();&#125;\n\npublic class ResourceLoaderDemo &#123;        public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext();        Resource resource = context.getResource(&quot;test&quot;);                ApplicationContext ctx = new FileSystemXmlApplicationContext();        Resource resource2 = context.getResource(&quot;test&quot;);    &#125;&#125;\n\n主要实现\nDefaultResourceLoader\n\n这是基本的资源加载器实现。它可以处理 “classpath:” 前缀的资源，如果没有提供这样的前缀，它会尝试使用类加载器或文件系统来加载资源。\n\n使用 DefaultResourceLoader 从不同的资源（类路径和文件系统）加载内容。\n示例\npublic class DefaultResourceLoaderDemo &#123;    public static void main(String[] args) &#123;        DefaultResourceLoader loader = new DefaultResourceLoader();        // 从类路径加载资源        Resource classpathResource = loader.getResource(&quot;classpath:application.properties&quot;);        try (InputStream is = classpathResource.getInputStream()) &#123;            // 读取和处理资源内容            System.out.println(&quot;Classpath = &quot;+ new String(is.readAllBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        // 加载文件系统中的资源        Resource fileResource = loader.getResource(&quot;file:/idea-work-space-xcs/spring-reading/spring-resources/spring-resource-resourceLoader/myfile1.txt&quot;);        try (InputStream is = fileResource.getInputStream()) &#123;            // 读取和处理资源内容            System.out.println(&quot;File = &quot;+ new String(is.readAllBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n运行结果发现\n从类路径上，我们加载了一个文件：application.properties 。这意味着在我们的项目的类路径中，有这个文件。从文件系统上，我们加载了一个文件：myfile1.txt。这些文件位于我们之前在代码中硬编码的文件路径 &#x2F;idea-work-space-xcs&#x2F;spring-reading&#x2F;spring-resources&#x2F;spring-resource-resourceLoader&#x2F; 下。\n与其他组件的关系\nApplicationContext\n 所有的 Spring ApplicationContext 都实现了 ResourceLoader。这意味着我们可以使用 Spring 上下文本身来加载资源。\n\nResource\n ResourceLoader 返回 Resource 对象，它代表实际的资源，可以是文件系统中的文件、类路径资源、URLs 等。Resource 提供了访问和读取资源内容的方法。\n\nResourcePatternResolver 这是 ResourceLoader 的扩展，可以解析给定的位置模式以加载多个资源。PathMatchingResourcePatternResolver 是它的主要实现。\n\nResourceEditor 这是一个属性编辑器，用于将字符串转换为 Resource 对象。它内部使用 ResourceLoader 来执行转换。\n\nResourceLoaderAware\n 这是一个特殊的接口，任何 bean 如果实现了它，那么它就可以在被创建时获得对 ResourceLoader 的引用，这样它就可以自己加载资源。\n\nEmbeddedValueResolverAware\n  一些组件，如属性占位符处理器，可能需要解析值中的动态部分。它们可以使用 ResourceLoader 作为解析这些值的一部分，特别是当值代表资源位置时。\n\nPathMatchingResourcePatternResolver\n 它是 ResourcePatternResolver 的一个实现，它扩展了 ResourceLoader 来处理以 “classpath*:” 开头的资源模式，这允许加载所有匹配的资源，而不仅仅是第一个找到的资源。\n\n\n常见问题\n加载类路径资源使用前缀 “classpath:”，例如：loader.getResource(“classpath:myconfig.xml”)。\n\n加载文件系统资源\n使用前缀 “file:”，例如：loader.getResource(“file:&#x2F;path&#x2F;to&#x2F;myconfig.xml”)。\n\n加载URL资源\n直接使用 URL，例如：loader.getResource(“http://www.example.com/config.xml&quot;)。\n\n资源不存在使用 Resource.exists() 方法检查资源是否存在。确保路径或位置正确，并且资源真的存在于预期的位置。\n\n如何读取资源内容从 Resource 对象中获取 InputStream，例如：resource.getInputStream()。\n\n从 Resource 获取到文件路径使用 Resource.getFile()。但请注意，这并不总是有效的，例如当资源实际上是一个类路径资源或URL资源时。\n\n自动注入 ResourceLoader实现 ResourceLoaderAware 接口，Spring 将自动为我们的 bean 提供 ResourceLoader 的引用。\n\n扩展或自定义资源加载机制我们可以实现自己的 ResourceLoader 或继承现有的实现，如 DefaultResourceLoader\n\n加载资源时考虑环境或属性占位符使用 PropertyPlaceholderConfigurer 或 PropertySourcesPlaceholderConfigurer 与 @Value 注解可以解析属性值中的资源路径\n\n\n\nResourceLoaderAware 接口在 Spring 中，ResourceLoaderAware 接口是一个回调接口，它提供了一个用于设置 Bean 所在的ResourceLoader 的方法。当一个 Bean 实现了 ResourceLoaderAware 接口时，在该 Bean 实例被实例化后，Spring 容器会调用 setResourceLoader 方法，并将该 Bean 所在的 ResourceLoader 作为参数传递进去。\n源码\nResourceLoaderAware 主要用于获取加载当前 Bean 的 ResourceLoader，使得 Bean 能够在运行时获取到关于资源加载的能力。\n使用要让一个Bean实现 ResourceLoaderAware 接口，需要按以下步骤进行\n\npackage org.example.cheney;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import java.io.InputStream;public class DemoBean implements ResourceLoaderAware &#123;    private ResourceLoader resourceLoader;    @Override    public void setResourceLoader(ResourceLoader resourceLoader) &#123;        this.resourceLoader = resourceLoader;        System.out.println(&quot;【ResourceLoaderAware】: 通过 ResourceLoader 创建 Bean&quot;);    &#125;    public void loadResource(String resourceName) throws Exception &#123;        // 使用 ResourceLoader 加载资源        System.out.println(&quot;加载的文件名是: &quot; + resourceName);        Resource resource = resourceLoader.getResource(resourceName);        InputStream inputStream = resource.getInputStream();        // 读取资源内容        byte[] contentBytes = new byte[inputStream.available()];        inputStream.read(contentBytes);        String content = new String(contentBytes);        System.out.println(&quot;文件内容:\\n&quot; + content);    &#125;&#125;\n\n配置bean\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;       &gt;    &lt;bean id=&quot;demoBean&quot; class=&quot;org.example.cheney.DemoBean&quot;/&gt;&lt;/beans&gt;\n\n测试输出\npackage org.example.cheney;import org.springframework.context.support.AbstractXmlApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123;    public static void main(String[] args) throws Exception &#123;        String location = &quot;applicationContext.xml&quot;;        try (AbstractXmlApplicationContext context = new ClassPathXmlApplicationContext(location)) &#123;            DemoBean demo = (DemoBean) context.getBean(&quot;demoBean&quot;);            demo.loadResource(&quot;classpath:demo.txt&quot;);            System.out.println(&quot;End.&quot;);        &#125;    &#125;&#125;\n\nResourceLoaderAware 接口通常用于以下场景：\n\n加载资源：当一个 Bean 需要在运行时加载外部资源时，可以使用 ResourceLoaderAware 获取 ResourceLoader 并使用它加载资源\n\n处理资源相关逻辑：当一个 Bean 与资源相关的操作时，例如读取配置文件、加载模板文件等，可以使用 ResourceLoaderAware 获取 ResourceLoader\n\n\n\n使用Resource作为属性前面介绍了Spring提供的资源访问策略，但这些依赖访问策略要么需要使用Resource实现类，要么需要使用ApplicationContext来获取资源。实际上，当应用程序中的Bean实例需要访问资源时，Spring有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和IoC进行充分地结合，最大程度地简化了Spring资源访问。归纳起来，如果Bean实例需要访问资源，有如下两种解决方案：\n\n代码中获取Resource实例。\n\n使用依赖注入\n\n\n对于第一种方式，当程序获取Resource实例时，总需要提供Resource所在的位置，不管通过FileSystemResource创建实例，还是通过ClassPathResource创建实例，或者通过ApplicationContext的getResource()方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让Spring为Bean实例依赖注入资源。\n示例\npackage edu.software.ergoutree.springresources.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestBean &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        RescoureBean rescoureBean = context.getBean(RescoureBean.class);        rescoureBean.pares();    &#125;&#125;\n\nbean配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--解耦合--&gt;    &lt;bean id=&quot;rescoureBean&quot; class=&quot;edu.software.ergoutree.springresources.di.RescoureBean&quot;&gt;        &lt;property name=&quot;resource&quot; value=&quot;classpath*:test&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试\npackage edu.software.ergoutree.springresources.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestBean &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        RescoureBean rescoureBean = context.getBean(RescoureBean.class);        rescoureBean.pares();    &#125;&#125;\n\n\n应用程序上下文和资源路径–Resource 指定访问策略在 Spring 框架中，应用程序上下文（ApplicationContext）不仅负责管理 Bean 的生命周期，还提供了资源加载的能力。通过 ApplicationContext，开发者可以方便地访问不同类型的资源，而无需关心底层的资源访问细节。ApplicationContext 本身实现了 ResourceLoader 接口，因此可以直接通过上下文加载资源。\n资源路径的指定方式Spring 支持多种资源路径的指定方式，开发者可以通过不同的前缀来强制使用特定的资源访问策略。以下是常见的资源路径前缀及其对应的访问策略：\n\nclasspath:表示从类路径下加载资源。例如：\nResource resource = context.getResource(&quot;classpath:config.properties&quot;);\n\n这会从类路径（如 src/main/resources）中查找 config.properties 文件。\n\nfile:表示从文件系统中加载资源。例如：\nResource resource = context.getResource(&quot;file:/path/to/config.properties&quot;);\n\n这会从文件系统的指定路径加载文件。\n\nhttp: 或 https:表示从网络 URL 加载资源。例如：\nResource resource = context.getResource(&quot;https://example.com/config.properties&quot;);\n\n这会通过 HTTP 或 HTTPS 协议从远程服务器加载资源。\n\n无前缀如果没有指定前缀，ApplicationContext 会根据上下文类型决定默认的资源访问策略：\n\n对于 ClassPathXmlApplicationContext，默认从类路径加载资源。\n对于 FileSystemXmlApplicationContext，默认从文件系统加载资源。\n\n\n\n示例代码以下是一个完整的示例，展示如何通过 ApplicationContext 加载不同类型的资源：\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import java.io.IOException;import java.io.InputStream;public class ResourceLoadingDemo &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext();        // 从类路径加载资源        Resource classpathResource = context.getResource(&quot;classpath:application.properties&quot;);        printResourceContent(classpathResource);        // 从文件系统加载资源        Resource fileResource = context.getResource(&quot;file:/path/to/myfile.txt&quot;);        printResourceContent(fileResource);        // 从网络 URL 加载资源        Resource urlResource = context.getResource(&quot;https://example.com/data.json&quot;);        printResourceContent(urlResource);    &#125;    private static void printResourceContent(Resource resource) &#123;        try (InputStream inputStream = resource.getInputStream()) &#123;            byte[] bytes = inputStream.readAllBytes();            System.out.println(&quot;Resource content: &quot; + new String(bytes));        &#125; catch (IOException e) &#123;            System.err.println(&quot;Failed to read resource: &quot; + e.getMessage());        &#125;    &#125;&#125;\n\n资源路径的通配符支持\nSpring 还支持使用通配符加载多个资源，例如：\n\nclasspath*:：从所有类路径下匹配的资源加载。加载多个\nfile: 或 classpath: 结合通配符：匹配符合模式的文件。\n\nResource[] resources = context.getResources(&quot;classpath*:config/*.properties&quot;);for (Resource res : resources) &#123;    System.out.println(&quot;Found resource: &quot; + res.getFilename());&#125;\n\n通过 ApplicationContext 加载资源时，开发者可以通过前缀指定资源的访问策略，从而实现灵活的资源管理。这种方式不仅简化了代码，还提高了应用程序的可维护性和可扩展性。无论是类路径资源、文件系统资源还是网络资源，Spring 都提供了统一的访问接口，使得资源加载变得简单而高效。\n","categories":["Java学习","Spring系列","Spring Framework"],"tags":["Java技术","JavaWeb","JavaEE","Spring系列","Spring Framework","Java框架"]},{"title":"butterfly配置文件速读-自查用","url":"/posts/62149.html","content":"转自 Butterfly 文档(三) 主题配置\n\n_config.butterfly.yml\n# --------------------------------------# 导航设置# --------------------------------------nav:  # 导航栏 Logo 图片  logo:  # 是否显示标题  display_title: true  # 是否固定导航栏  fixed: falsemenu:  # 首页: / || fas fa-home  # 列表||fas fa-list:  #   音乐: /music/ || fas fa-music  #   电影: /movies/ || fas fa-video# --------------------------------------# 代码块设置# --------------------------------------code_blocks:  # 代码块主题: darker / pale night / light / ocean / false  theme: light  # 是否使用 Mac 风格  macStyle: false  # 代码块高度限制（单位: px）  height_limit: false  # 是否自动换行  word_wrap: false  # 工具栏  # 是否显示复制按钮  copy: true  # 是否显示语言标签  language: true  # true: 收缩代码块 | false: 展开代码块 | none: 展开代码块并隐藏按钮  shrink: false  # 是否显示全屏显示代码块按钮  fullpage: false# 社交媒体链接# 格式:#   icon: 链接 || 描述 || 颜色social:# --------------------------------------# 图片设置# --------------------------------------# 网站的 favicon 图标favicon: /img/favicon.png# 头像设置avatar:  # 头像图片链接  img: https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png  # 是否启用头像效果  effect: false# 禁用所有横幅图片disable_top_img: false# 如果页面未设置横幅，则显示默认的横幅图片default_top_img:# 主页的横幅图片index_img:# 归档页的横幅图片archive_img:# 注意: 是标签页（单个标签），不是标签页面（所有标签）tag_img:# 标签页的横幅图片，可以为每个标签设置横幅图片# 格式:#  - 标签名: 图片链接tag_per_img:# 注意: 是分类页（单个分类），不是分类页面（所有分类）category_img:# 分类页的横幅图片，可以为每个分类设置横幅图片# 格式:#  - 分类名: 图片链接category_per_img:# 页脚的背景图片footer_img: false# 网站背景# 可以设置为颜色或图片# 图片格式: url(http://xxxxxx.com/xxx.jpg)background:# 封面设置cover:  # 是否禁用封面  index_enable: true  aside_enable: true  archives_enable: true  # 主页封面的位置  # 选择: left/right/both  position: both  # 当未设置封面时，显示默认封面  default_cover:    # - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg# 替换损坏的图片error_img:  # 友链页面的错误图片  flink: /img/friend_404.gif  # 文章页面的错误图片  post_page: /img/404.jpg# 简单的 404 页面error_404:  # 是否启用 404 页面  enable: false  # 404 页面的副标题  subtitle: &#x27;Page Not Found&#x27;  # 404 页面的卡片背景图片  background: https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png# 文章元数据设置post_meta:  # 主页页面  page:    # 日期类型: created / updated / both    date_type: created    # 日期格式: date / relative    date_format: date    # 是否显示分类    categories: true    # 是否显示标签    tags: false    # 是否显示文字标签    label: true  # 文章页面  post:    # 元数据位置: left / center    position: left    # 日期类型: created / updated / both    date_type: both    # 日期格式: date / relative    date_format: date    # 是否显示分类    categories: true    # 是否显示标签    tags: true    # 是否显示文字标签    label: true# --------------------------------------# 首页设置# --------------------------------------# 首页头图的设置# 默认: 头图全屏，站点信息在中间# 站点信息的位置，例如: 300px/300em/300rem/10%index_site_info_top:# 头图的高度，例如: 300px/300em/300remindex_top_img_height:# 首页的副标题设置subtitle:  # 是否启用副标题  enable: false  # 是否启用打字机效果  effect: true  # 自定义 typed.js  # https://github.com/mattboldt/typed.js/#customization  typed_option:  # 来源 - 调用第三方服务 API（仅限中文）  # 它将首先显示来源，然后显示副标题内容  # 选择: false/1/2/3  # false - 禁用此功能  # 1 - hitokoto.cn  # 2 - yijuzhan.com  # 3 - jinrishici.com  source: false  # 如果关闭打字机效果，副标题将仅显示 sub 的第一行内容  sub:# 首页文章佈局# 1: 行佈局# 2: 列布局index_layout: 1# 在首页显示文章简介# 1: 描述# 2: 两者（如果存在描述，将显示描述，否则显示自动摘要）# 3: 自动摘要（默认）# false: 不显示文章简介index_post_content:  method: 3  # 如果设置 method 为 2 或 3，需要配置长度  length: 500# --------------------------------------# 文章设置# --------------------------------------toc:  # 是否在文章中显示目录  post: true  # 是否在页面中显示目录  page: false  # 是否显示目录编号  number: true  # 是否默认展开目录  expand: false  # 是否使用简洁风格（仅适用于文章）  style_simple: false  # 是否显示滚动百分比  scroll_percent: truepost_copyright:  # 是否启用版权声明  enable: true  # 是否进行文章 URL 解码  decode: false  # 作者链接  author_href:  # 许可证类型  license: CC BY-NC-SA 4.0  # 许可证链接  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/# 贊助/打赏reward:  # 是否启用打赏  enable: false  # 打赏案例文本  text:  QR_code:    # - img: /img/wechat.jpg    #   link:    #   text: 微信    # - img: /img/alipay.jpg    #   link:    #   text: 支付宝# 文章编辑# 轻鬆在线浏览和编辑博客源代码post_edit:  # 是否启用在线编辑  enable: false  # url: https://github.com/用户名/仓库名/edit/分支名/子目录名/  # 例如: https://github.com/jerryc127/butterfly.js.org/edit/main/source/  url:# 相关文章related_post:  # 是否显示相关文章  enable: true  # 显示的文章数量  limit: 6  # 选择: created / updated  date_type: created# 选择: 1 / 2 / false# 1: “下一篇文章”将链接到旧文章# 2: “下一篇文章”将链接到新文章# false: 禁用分页post_pagination: 1# 显示文章过期通知noticeOutdate:  # 是否启用过期通知  enable: false  # 样式: simple / flat  style: flat  # 多少天后显示通知  limit_day: 365  # 位置: top / bottom  position: top  message_prev: 已经过了  message_next: 天自上次更新，文章内容可能已过时。# --------------------------------------# 页脚设置# --------------------------------------footer:  owner:    # 是否启用所有者显示    enable: true    # 网站创建年份    since: 2019  # 自定义文本  custom_text:  # 主题和框架的版权声明  copyright: true# --------------------------------------# 侧边栏设置# --------------------------------------aside:  # 是否启用侧边栏  enable: true  # 是否默认隐藏侧边栏  hide: false  # 是否在右下角显示隐藏侧边栏的按钮  button: true  # 移动设备上是否启用侧边栏  mobile: true  # 侧边栏位置：left / right  position: right  display:    # 归档页面是否显示侧边栏    archive: true    # 标签页面是否显示侧边栏    tag: true    # 分类页面是否显示侧边栏    category: true  card_author:    # 是否显示作者信息卡片    enable: true    # 作者描述    description:    button:      # 是否显示按钮      enable: true      # 按钮图标      icon: fab fa-github      # 按钮文本      text: Follow Me      # 按钮链接      link: https://github.com/xxxxxx  card_announcement:    # 是否显示公告卡片    enable: true    # 公告内容    content: This is my Blog  card_recent_post:    # 是否显示最近文章卡片    enable: true    # 显示文章数量，0 表示显示所有    limit: 5    # 排序方式：date / updated    sort: date    sort_order:  card_newest_comments:    # 是否显示最新评论卡片    enable: false    sort_order:    # 显示评论数量    limit: 6    # 单位：分钟，保存数据到 localStorage    storage: 10    # 是否显示头像    avatar: true  card_categories:    # 是否显示分类卡片    enable: true    # 显示分类数量，0 表示显示所有    limit: 8    # 选择：none / true / false    expand: none    sort_order:  card_tags:    # 是否显示标签卡片    enable: true    # 显示标签数量，0 表示显示所有    limit: 40    # 是否启用颜色    color: false    # 标签排序方式：random/name/length    orderby: random    # 排序顺序：1 表示升序，-1 表示降序    order: 1    sort_order:  card_archives:    # 是否显示归档卡片    enable: true    # 归档类型：monthly / yearly    type: monthly    # 日期格式，例如：YYYY年MM月    format: MMMM YYYY    # 排序顺序：1 表示升序，-1 表示降序    order: -1    # 显示归档数量，0 表示显示所有    limit: 8    sort_order:  card_post_series:    # 是否显示系列文章卡片    enable: true    # 标题显示系列名称    series_title: false    # 排序方式：title 或 date    orderBy: &#x27;date&#x27;    # 排序顺序：1 表示升序，-1 表示降序    order: -1  card_webinfo:    # 是否显示网站信息卡片    enable: true    # 是否显示文章数量    post_count: true    # 是否显示最后推送日期    last_push_date: true    sort_order:    # 发佈日期与当前日期的时间差    # 格式：Month/Day/Year Time 或 Year/Month/Day Time    # 如果不启用此功能，请留空    runtime_date:# --------------------------------------# 右下角按钮设置# --------------------------------------# 右下角按钮与底部的距离（默认单位：px）rightside_bottom:# 简繁转换设置translate:  # 是否启用简繁转换  enable: false  # 按钮文本  default: 繁  # 网站语言（1 - 繁体中文 / 2 - 简体中文）  defaultEncoding: 2  # 转换延迟  translateDelay: 0  # 按钮在简体中文时的文本  msgToTraditionalChinese: &#x27;繁&#x27;  # 按钮在繁体中文时的文本  msgToSimplifiedChinese: &#x27;简&#x27;# 閲读模式readmode: true# 暗黑模式设置darkmode:  # 是否启用暗黑模式  enable: true  # 切换暗黑/明亮模式的按钮  button: true  # 是否自动切换暗黑/明亮模式  # autoChangeMode: 1  跟随系统设置，如果系统不支持暗黑模式，则在晚上 6 点到早上 6 点之间切换暗黑模式  # autoChangeMode: 2  在晚上 6 点到早上 6 点之间切换暗黑模式  # autoChangeMode: false  不自动切换  autoChangeMode: false  # 设置明亮模式时间，值在 0 到 24 之间。如果未设置，默认值为 6 和 18  start:  end:# 在返回顶部按钮中显示滚动百分比rightside_scroll_percent: false# 不要修改以下设置，除非你知道它们的工作原理# 选择：readmode,translate,darkmode,hideAside,toc,chat,comment# 不要重复相同的值rightside_item_order:  # 是否启用右侧项目顺序  enable: false  # 隐藏的默认项目：readmode,translate,darkmode,hideAside  hide:  # 显示的默认项目：toc,chat,comment  show:# --------------------------------------# 全局设置# --------------------------------------# 锚点设置anchor:  # 滚动时，URL 将根据标题 ID 更新  auto_update: false  # 点击标题滚动并更新锚点  click_to_scroll: false# 图片标题photofigcaption: false# 复制设置copy:  # 是否启用复制功能  enable: true  # 在复制的内容后添加版权信息  copyright:    enable: false    # 当复制字符数超过 limit_count 时添加版权信息    limit_count: 150# 需要安装 hexo-wordcount 插件wordcount:  # 是否启用字数统计  enable: false  # 在文章元信息中显示字数统计  post_wordcount: true  # 在文章元信息中显示閲读时间  min2read: true  # 在侧边栏网站信息中显示总字数  total_wordcount: true# 不蒜子 PV / UV 统计busuanzi:  # 网站 UV 统计  site_uv: true  # 网站 PV 统计  site_pv: true  # 页面 PV 统计  page_pv: true# --------------------------------------# 数学公式设置# --------------------------------------# 关于 per_page# 如果设置为 true，将在每个页面加载 mathjax/katex 脚本# 如果设置为 false，将根据你的设置加载 mathjax/katex 脚本（在页面的 front-matter 中添加 &#x27;mathjax: true&#x27; 或者 &#x27;katex: true&#x27;）math:  # 选择：mathjax, katex  # 如果不需要数学公式，保持为空  use:  per_page: true  hide_scrollbar: false  mathjax:    # 启用上下文菜单    enableMenu: true    # 选择：all / ams / none，这控制是否对公式编号以及如何编号    tags: none  katex:    # 启用复制 KaTeX 公式    copy_tex: false# --------------------------------------# 搜索设置# --------------------------------------search:  # 选择：algolia_search / local_search / docsearch  # 如果不需要搜索功能，保持为空  use:  placeholder:  # Algolia 搜索  algolia_search:    # 每页搜索结果数量    hitsPerPage: 6  # 本地搜索  local_search:    # 页面加载时预加载搜索数据    preload: false    # 每篇文章显示的顶部 n 个搜索结果，设置为 -1 显示所有结果    top_n_per_article: 1    # 将 HTML 字符串反转义为可读内容    unescape: false    CDN:  # Docsearch  # https://docsearch.algolia.com/  docsearch:    appId:    apiKey:    indexName:    option:# --------------------------------------# 分享系统# --------------------------------------share:  # 选择：sharejs / addtoany  # 如果不需要分享功能，保持为空  use: sharejs  # Share.js  # https://github.com/overtrue/share.js  sharejs:    sites: facebook,twitter,wechat,weibo,qq  # AddToAny  # https://www.addtoany.com/  addtoany:    item: facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link# --------------------------------------# 评论系统# --------------------------------------comments:  # 最多两个评论系统，第一个将作为默认显示  # 如果不需要评论功能，保持为空  # 选择：Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk  # 两个评论系统的格式：Disqus,Waline  use:  # 按钮旁边显示评论系统名称  text: true  # 懒加载：评论系统将在评论元素进入浏览器视口时加载  # 如果设置为 true，评论计数将无效  lazyload: false  # 在文章顶部图片中显示评论计数  count: false  # 在主页显示评论计数  card_post_count: false# Disqus 评论插件配置# 官方文档：https://disqus.com/disqus:  # Disqus 的 shortname  shortname:  # 最新评论小部件的 API 密钥  apikey:# 使用 Disqus API 渲染评论的替代方案# 官方文档：https://github.com/SukkaW/DisqusJSdisqusjs:  # Disqus 的 shortname  shortname:  # API 密钥  apikey:  # 其他可选配置  option:# Livere 评论插件配置# 官方文档：https://www.livere.com/livere:  # Livere 的用户 ID  uid:# Gitalk 评论插件配置# 官方文档：https://github.com/gitalk/gitalkgitalk:  # GitHub 应用的客户端 ID  client_id:  # GitHub 应用的客户端密钥  client_secret:  # 存储评论的仓库名称  repo:  # 仓库拥有者的用户名  owner:  # 管理员用户名列表  admin:  # 其他可选配置  option:# Valine 评论插件配置# 官方文档：https://valine.js.orgvaline:  # LeanCloud 应用的 appId  appId:  # LeanCloud 应用的 appKey  appKey:  # 评论者头像样式  avatar: monsterid  # 该配置适用于国内自定义域名用户，海外版本将自动检测（无需手动填写）  serverURLs:  # 评论框背景图片  bg:  # 使用 Valine 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# Waline 评论插件配置，一个简单的评论系统，基于 Valine 开发，支持后端# 官方文档：https://waline.js.org/waline:  # 服务器 URL  serverURL:  # 评论框背景图片  bg:  # 使用 Waline 的访客计数作为页面的访客量  pageview: false  # 其他可选配置  option:# Utterances 评论插件配置# 官方文档：https://utteranc.es/utterances:  # 存储评论的 GitHub 仓库  repo:  # 问题映射方式，可选值：pathname/url/title/og:title  issue_term: pathname  # 浅色主题，可选值：github-light  light_theme: github-light  # 深色主题，可选值：photon-dark  dark_theme: photon-dark# Facebook 评论插件配置# 官方文档：https://developers.facebook.com/docs/plugins/comments/facebook_comments:  # 应用 ID  app_id:  # 用户 ID，可选  user_id:  # 每页显示评论数  pageSize: 10  # 评论排序方式，可选值：social / time / reverse_time  order_by: social  # 语言设置  lang: zh_TW# Twikoo 评论插件配置# 官方文档：https://github.com/imaegoo/twikootwikoo:  # 环境 ID  envId:  # 区域  region:  # 使用 Twikoo 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# Giscus 评论插件配置# 官方文档：https://giscus.app/giscus:  # 仓库地址  repo:  # 仓库 ID  repo_id:  # 分类 ID  category_id:  # 主题配置，light 为浅色主题，dark 为深色主题  theme:    light: light    dark: dark  # 其他可选配置  option:# Remark42 评论插件配置# 官方文档：https://remark42.com/docs/configuration/frontend/remark42:  # 服务器地址  host:  # 站点 ID  siteId:  # 其他可选配置  option:# Artalk 评论插件配置# 官方文档：https://artalk.js.org/guide/frontend/config.htmlartalk:  # 服务器地址  server:  # 站点名  site:  # 使用 Artalk 的访客计数作为页面的访客量  visitor: false  # 其他可选配置  option:# --------------------------------------# 聊天服务配置# --------------------------------------chat:  # 聊天服务类型，可选值：chatra/tidio/crisp，如果不需要聊天功能则留空  use:  # 推荐使用聊天按钮，会在网站右下角创建一个按钮，并隐藏原始按钮  rightside_button: false  # 原始聊天按钮在向上滚动时显示，向下滚动时隐藏  button_hide_show: false# Chatra 聊天服务配置# 官方网站：https://chatra.io/chatra:  # Chatra 服务 ID  id:# Tidio 聊天服务配置# 官方网站：https://www.tidio.com/tidio:  # Tidio 公钥  public_key:# Crisp 聊天服务配置# 官方网站：https://crisp.chat/en/crisp:  # Crisp 网站 ID  website_id:# --------------------------------------# 分析服务配置# --------------------------------------# 百度统计配置# 官方网站：https://tongji.baidu.com/web/welcome/loginbaidu_analytics:# 谷歌分析配置# 官方网站：https://analytics.google.com/analytics/web/google_analytics:# Cloudflare 分析配置# 官方网站：https://www.cloudflare.com/zh-tw/web-analytics/cloudflare_analytics:# Microsoft Clarity 分析配置# 官方网站：https://clarity.microsoft.com/microsoft_clarity:# --------------------------------------# 广告配置# --------------------------------------# Google Adsense 广告配置google_adsense:  # 是否启用  enable: false  # 是否自动投放广告  auto_ads: true  # 广告脚本 URL  js: https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js  # 客户 ID  client:  # 是否启用页面级广告  enable_page_level_ads: true# 手动插入广告配置，如果不需要广告则留空ad:  # 在首页每三个帖子后插入广告  index:  # 在侧边栏插入广告  aside:  # 在文章分页前插入广告  post:# --------------------------------------# 站点验证配置# --------------------------------------site_verification:  # 示例：  # - name: google-site-verification  #   content: xxxxxx  # - name: baidu-site-verification  #   content: xxxxxxx# --------------------------------------# 美化 / 效果# --------------------------------------# 主题颜色自定义# 注意：颜色值必须用双引号，如 &quot;#000&quot;，否则可能会导致错误！# 主题颜色配置# theme_color:#   是否启用主题颜色#   enable: true#   主颜色#   main: &quot;#49B1F5&quot;#   分页器颜色#   paginator: &quot;#00c4b6&quot;#   按钮悬停颜色#   button_hover: &quot;#FF7242&quot;#   文本选择颜色#   text_selection: &quot;#00c4b6&quot;#   链接颜色#   link_color: &quot;#99a9bf&quot;#   元数据颜色#   meta_color: &quot;#858585&quot;#   水平线颜色#   hr_color: &quot;#A4D8FA&quot;#   代码前景色#   code_foreground: &quot;#F47466&quot;#   代码背景色#   code_background: &quot;rgba(27, 31, 35, .05)&quot;#   目录颜色#   toc_color: &quot;#00c4b6&quot;#   引用块填充颜色#   blockquote_padding_color: &quot;#49b1f5&quot;#   引用块背景颜色#   blockquote_background_color: &quot;#49b1f5&quot;#   滚动条颜色#   scrollbar_color: &quot;#49b1f5&quot;#   浅色模式下的主题颜色#   meta_theme_color_light: &quot;ffffff&quot;#   深色模式下的主题颜色#   meta_theme_color_dark: &quot;#0d0d0d&quot;# 分类和标签页面的用户界面设置# 选择：index - 与主页 UI 相同 / default - 与归档 UI 相同# 留空或设置为 indexcategory_ui:tag_ui:# 拉伸行使每行宽度相等text_align_justify: false# 为页眉和页脚添加遮罩mask:  header: true  footer: true# 加载动画preloader:  # 是否启用加载动画  enable: false  # 资源  # 1. 全屏加载  # 2. 进度条  source: 1  # pace 主题 (参见 https://codebyzach.github.io/pace/)  pace_css_url:# 页面过渡效果enter_transitions: true# 默认显示模式 - light (默认) / darkdisplay_mode: light# 美化文章内容的配置beautify:  # 是否启用美化  enable: false  # 指定美化的范围 (site 或 post)  field: post  # 指定标题前缀图标，如 &#x27;\\f0c1&#x27;  title-prefix-icon:  # 指定标题前缀图标的颜色，如 &#x27;#F47466&#x27;  title-prefix-icon-color:# 全局字体设置# 除非您知道它们的工作原理，否则不要修改以下设置font:  global-font-size:  code-font-size:  font-family:  code-font-family:# 网站标题和副标题的字体设置blog_title_font:  font_link:  font-family:# 分隔符图标的设置hr_icon:  # 是否启用分隔符图标  enable: true  # Font Awesome 图标的 unicode 值，如 &#x27;\\3423&#x27;  icon:  icon-top:# 打字机效果# https://github.com/disjukr/activate-power-modeactivate_power_mode:  # 是否启用打字机效果  enable: false  # 是否启用彩色效果  colorful: true  # 是否启用震动效果  shake: true  # 是否在移动设备上启用  mobile: false# 背景效果# --------------------------------------# canvas_ribbon# 参见: https://github.com/hustcc/ribbon.jscanvas_ribbon:  # 是否启用 canvas_ribbon  enable: false  # ribbon 的大小  size: 150  # ribbon 的不透明度 (0 ~ 1)  alpha: 0.6  zIndex: -1  # 是否点击更改颜色  click_to_change: false  # 是否在移动设备上启用  mobile: false# Fluttering Ribboncanvas_fluttering_ribbon:  # 是否启用 Fluttering Ribbon  enable: false  # 是否在移动设备上启用  mobile: false# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest:  # 是否启用 canvas_nest  enable: false  # 线条颜色，默认: &#x27;0,0,0&#x27;; RGB 值: (R,G,B).(注意: 使用 &#x27;,&#x27; 分隔.)  color: &#x27;0,0,255&#x27;  # 线条的不透明度 (0~1)  opacity: 0.7  # 背景的 z-index 属性  zIndex: -1  # 线条数量  count: 99  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 烟花fireworks:  # 是否启用烟花效果  enable: false  zIndex: 9999  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 心形符号click_heart:  # 是否启用心形符号效果  enable: false  # 是否在移动设备上启用  mobile: false# 鼠标点击效果: 文字clickShowText:  # 是否启用文字效果  enable: false  text:    # - I    # - LOVE    # - YOU  fontSize: 15px  # 是否随机显示文字  random: false  # 是否在移动设备上启用  mobile: false# --------------------------------------# 灯箱设置# --------------------------------------# 选择: fancybox / medium_zoom# https://github.com/francoischalifour/medium-zoom# https://fancyapps.com/fancybox/# 如果不需要灯箱效果，请留空lightbox:# --------------------------------------# 标签外挂设置# --------------------------------------# 系列series:  # 是否启用系列  enable: false  # 按标题或日期排序  orderBy: &#x27;title&#x27;  # 排序方式。1, asc 为升序; -1, desc 为降序  order: 1  # 是否显示编号  number: true# ABCJS - ABC 音乐符号插件# https://github.com/paulrosen/abcjsabcjs:  # 是否启用 ABCJS  enable: false  # 是否每页启用  per_page: true# Mermaid# https://github.com/mermaid-js/mermaidmermaid:  # 是否启用 Mermaid  enable: false  # 使用代码块编写 Mermaid 图表  code_write: false  # 内置主题: default / forest / dark / neutral  theme:    light: default    dark: dark# chartjs# 参见 https://www.chartjs.org/docs/latest/chartjs:  enable: false  # 除非你了解它们的工作原理，否则不要修改。  # 默认设置仅在未指定 MD 语法时使用。  # 图表的字体颜色  fontColor:    light: &quot;rgba(0, 0, 0, 0.8)&quot;    dark: &quot;rgba(255, 255, 255, 0.8)&quot;  # 图表的边框颜色  borderColor:    light: &quot;rgba(0, 0, 0, 0.1)&quot;    dark: &quot;rgba(255, 255, 255, 0.2)&quot;  # 雷达图和极区图的刻度标签背景颜色  scale_ticks_backdropColor:    light: &quot;transparent&quot;    dark: &quot;transparent&quot;# Note - Bootstrap 提示框note:  # Note 标签样式值:  #  - simple    bs-callout 旧警告样式。默认。  #  - modern    bs-callout 新 (v2-v3) 警告样式。  #  - flat      扁平提示框样式，带背景，如 Mozilla 或 StackOverflow。  #  - disabled  禁用所有 Note 标签的 CSS 样式。  style: flat  # 是否显示图标  icons: true  # 边框半径  border_radius: 3  # 背景颜色偏移百分比 (modern: -12 | 12; flat: -18 | 6)。  # 也应用于标签变量。此选项可与禁用的 Note 标签一起使用。  light_bg_offset: 0# --------------------------------------# 其他设置# --------------------------------------# https://github.com/MoOx/pjaxpjax:  # 是否启用 pjax  enable: false  # 排除指定页面不使用 pjax，如 &#x27;/music/&#x27;  exclude:    # - /xxxxxx/# 注入 CSS 和脚本 (aplayer/meting)aplayerInject:  # 是否启用注入  enable: false  # 是否每页启用  per_page: true# Snackbar - Toast 通知# https://github.com/polonel/SnackBar# 位置: top-left / top-center / top-right / bottom-left / bottom-center / bottom-rightsnackbar:  # 是否启用 Snackbar  enable: false  # 通知位置  position: bottom-left  # 浅色模式和深色模式下的通知背景颜色  bg_light: &#x27;#49b1f5&#x27;  bg_dark: &#x27;#1f1f1f&#x27;# Instant.page# https://instant.page/instantpage: false# Lazyload# https://github.com/verlok/vanilla-lazyloadlazyload:  # 是否启用 Lazyload  enable: false  # 使用浏览器的原生 lazyload 而不是 vanilla-lazyload  native: false  # 指定使用 Lazyload 的范围 (site 或 post)  field: site  placeholder:  blur: false# PWA# 参见 https://github.com/JLHwung/hexo-offline# ---------------pwa:  # 是否启用 PWA  enable: false  # PWA manifest 文件路径  manifest:  # Apple Touch 图标路径  apple_touch_icon:  # 32x32 像素的 favicon 图标路径  favicon_32_32:  # 16x16 像素的 favicon 图标路径  favicon_16_16:  # mask 图标路径  mask_icon:# Open graph meta tags# 参见 https://hexo.io/docs/helpers#open-graphOpen_Graph_meta:  # 是否启用 Open Graph meta 标签  enable: true  option:    # twitter_card:    # twitter_image:    # twitter_id:    # twitter_site:    # google_plus:    # fb_admins:    # fb_app_id:# 结构化数据# https://developers.google.com/search/docs/guides/intro-structured-datastructured_data: true# 添加供应商前缀以确保兼容性# 是否启用 CSS 前缀css_prefix: true# Inject# 插入代码到 head（在 &#x27;&lt;/head&gt;&#x27; 标签之前）和底部（在 &#x27;&lt;/body&gt;&#x27; 标签之前）inject:  head:    # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;  bottom:    # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;# CDN 设置# 除非你知道它们的工作原理，否则不要修改以下设置CDN:  # 内部和第三方脚本的 CDN 提供商  # 两者的选项：local/jsdelivr/unpkg/cdnjs/custom  # 注意： Dev 版本只能使用 &#x27;local&#x27; 作为内部脚本  # 注意：将第三方脚本设置为 &#x27;local&#x27; 时，需要安装 hexo-butterfly-extjs  internal_provider: local  third_party_provider: jsdelivr  # 是否在 URL 中添加版本号，true 或 false  version: false  # 自定义格式  # 例如：https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125;  custom_format:  option:\n\n","categories":["实用","配置相关"],"tags":["其他","实用类","配置文件","Hexo"]},{"title":"docker和WSL2的安装","url":"/posts/61013.html","content":"Docker简介简而言之，Docker 是一个可供开发者通过容器(container)来构建，运行和共享应用(application)的平台。用容器来部署应用被称为集装箱化(containerization)。\n\nDocker 就像一个盒子，里面可以装很多物件，如果需要某些物件，可以直接将该盒子拿走，而不需要从该盒子中一件一件的取。\nDocker中文社区、Docker中文文档\n\nDocker 包括三个基本概念:\n\n镜像（Image）\nDocker的镜像概念类似于虚拟机里的镜像(比如.ISO文件)，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。\n例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了MySQL或用户需要的其它应用程序。\n这里的镜像就如下方虚拟机创建时候使用的镜像类似。这个镜像便于移动,并且这个镜像我们可以交给任何人使用,其他人使用的时候也很方便,只需要将其实例化即可。\n\n\n容器（Container）\nDocker容器是由Docker镜像创建的运行实例，类似VM虚拟机，支持启动，停止，删除等。\n每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。\n容器就类似与虚拟机中我们创建好的虚拟机系统,之后我们所有的操作都是在容器中进行的,我们的程序也是运行在容器中。\n\n\n仓库（Repository）\n镜像便于传播,而仓库就是专门用来传播这些镜像的地方,他有点类似与Github,或者你可以把他看成一个存放各种镜像的镜像商店\nDocker官方的仓库: 他的服务器处于国外,所以下载速度较慢,不过我们可以通过换源解决。\ndaocloud国内仓库: 国内也有一些优秀的商店，他和Docker官方的仓库的区别类似与Github和Gitee的区别。\n网易云镜像中心\n\n\n\n本博客主要解决在Windows环境下,快速上手使用Docker的问题,主要会介绍在Windows系统下Docker Desktop的安装,Docker  基础命令,比如说下载镜像、实例化镜像、使用容器、关闭容器、删除容器\\镜像、使用仓库、创建镜像等模块的使用。其他系统应该除了安装外其他操作都可以通用。\nDocker安装(Winodws)开启 Hyper-V程序与功能中，启用或关闭 Windows 功能\n\n\n下载 Docker DesktopGet Started with Docker\n\n打开安装包加载一会后一般会弹出两个选项,在较旧的Windows10或之前的系统会出现如下所示的相关提示。我们把第一个选上,第二个根据需求选择即可。\n\n而较新的Windows则会出现一个使用wsl2的提示(最少是1903以上,推荐为2004或更高版本),如果使用wsl2则docker的性能会发挥更好。如下图,这里推荐使用WSL2,如果之后安装完成后发生报错可能是WSL2版本比较老,需要更新导致的\n\n换源，使用阿里云注册一个阿里云阿里云账号。进入管理控制台界面。\n进入控制台\n\n进入产品与服务\n\n进入镜像加速器中，获取加速器地址\n\n打开安装好的docker的主界面：在设置界面找到Docker Engin，将复制好的加速器地址填入即可\n\n&#123;  &quot;registry-mirrors&quot;:[    &quot;仓库地址&quot;  ],  &quot;builder&quot;: &#123;    &quot;gc&quot;: &#123;      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,      &quot;enabled&quot;: true    &#125;  &#125;,  &quot;experimental&quot;: true&#125;\n\ngithub上有个项目:docker_mirror，可以自动检测在你的网络环境下哪个源是最快的\n启动Dockerwindows下启动docker打开桌面的docker图标启动即可。启动成功后，在Win + R 输入cmd进入windows命令行界面，输入docker -v，查看docker版本：\n\n首先我们输入docker run hello-world是否会出现下图所示的提示,如果出现报错,环境配置可能出现了问题。\n我在配置时候出现了Docker无法拉取镜像并提示网络超时的问题，这里以我为例子解决一下\n\n命令docker images显示说明images镜像中没有helloworld这个文件\n\n这时我们只需要创建一个daemon.json文件，然后进入这个文件中添加如下内容：\n&#123;  &quot;registry-mirrors&quot;: [&quot;https://alzgoonw.mirror.aliyuncs.com&quot;]  &#125;\n\n然后保存退出，并重启docker\n另一个错误\n\n未运行Docker Desktop，要运行了之后再跑Docker的命令才行！\n安装完成Docker后,默认每次开机的时候都会自动启动,但我们也可以手动启动,关闭或者重启Docker\n# 启动dockersudo service docker start# 重启dockersudo service docker restart# 停止dockersudo service docker stop\n\n\n\n汉化 Docker Desktop下载对应版本的中文语言包\n访问 GitHub，下载适用于 Docker Desktop 的中文语言包，链接地址为：DockerDesktop-CN\n选择对应你的版本\n\n导航至 Docker 的安装目录，路径默认为：\nC:\\Program Files\\Docker\\Docker\\frontend\\resources\n\n在该目录下找到 app.asar 文件，建议先备份原文件，然后将复制的中文语言包中的 app.asar 文件粘贴并替换原有文件。\n\n完成替换后，请关闭 Docker Desktop，然后重新启动该程序。此时，Docker Desktop 应该以中文界面显示。\n\nWSL2安装WSL（Windows Subsystem for Linux）是微软开发的一项技术，允许用户在Windows系统中直接运行完整的Linux环境，无需虚拟机。通过操作系统级虚拟化，WSL将Linux子系统无缝嵌入Windows，提供原生Linux命令行工具、软件包管理器及应用程序支持。它具有轻量化、文件系统集成、良好的交互性及开发效率提升等优点，消除了Windows与Linux之间的隔阂，尤其适合开发者和需在Windows平台上使用Linux工具的用户。\n启用 WSL 功能\n打开开始菜单，在开始菜单中点击应用与程序\n在应用与程序选项里面，鼠标滚到最底下，点击程序与功能\n点击选项启用或关闭 Windows 功能\n在弹出的窗口中勾选 虚拟机平台（Virtual Machine Platform） 和 适用于 Linux 的 Windows 子系统。\n\n\ndos命令自动安装对于 windows10 版本2004（内部版本19041或更高）及更新版本或者 windows11，可以直接用 dos命令安装\n管理员打开 cmd 或者 powershell，依次\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n\n\n启用虚拟机功能\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n\n将 WSL 2 设置为默认版本\nwsl --set-default-version 2\n\n更新 wsl 内核\nwsl --update\n\n列出发行版本并且选择一个安装\nwsl --list --online\n\nwsl --install -d Ubuntu-24.04\n\n\n之后使用 wsl.exe -d Ubuntu-24.04 启动\n\n下次想要使用 wsl 的话，在 cmd 或者 powershell 内输入 wsl 命令即可：\n\nWindows 下的所有文件都被挂载在了 /mnt 下，在Windows 终端中的任意目录下输入 wsl，即可进入 Linux 对应的路径。\n错误修复：\n无法访问。你可能没有权限使用网络资源。请与这台服务器的管理员联系以查明你是否有访问权限\n\nWSL报告”请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化”\n在 启用或关闭windows 功能中，查看是否勾选虚拟机平台\n将注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order\n和HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\HwOrder\n两个键值中ProviderOrder的值从 cbfs6,P9NP,RDPNP,LanmanWorkstation,webclient 改为 P9NP,RDPNP,LanmanWorkstation,webclient\n在资源管理器中的 「地址栏」输入：\\\\wsl.localhost 或者 \\\\wsl.localhost\\  也有概率直接就好了\n导出到D盘注意接下来的操作需要使用 管理员权限的 cmd或pw\n首先，查看可用的 WSL 发行版\nwsl --list --online\n\n查看你的版本\nwsl -l -v \n\n关闭ubuntu\nwsl --shutdown Ubuntu-24.04\n\n导出Ubuntu到指定位置\nwsl --export Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04\\Ubuntu-24.04.tar\n\n取消注册原有的 Ubuntu,注销\nwsl --unregister Ubuntu-24.04\n\n导入虚拟机到指定位置\nwsl --import Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04 D:\\OtherLanguageSetting\\WSL\\Ubuntu-24.04\\Ubuntu-24.04.tar --version 2\n\n现在在目录下，WSL2 发行版的文件存储在一个 虚拟磁盘映像文件（ext4.vhdx） 中，该文件用于存储整个 Ubuntu-20.04 文件系统，如下图所示：\n\n导入完成后，你可以启动 WSL\nwsl -d Ubuntu-24.04\n\n添加新用户并设置其管理员权限，需要 root 权限\n切换到 root 用户\n在 WSL 的 Ubuntu 系统中，使用 su 命令切换到 root 用户：\nsu -\n\n执行该命令后，系统会提示你输入 root 用户的密码。如果你之前没有设置过 root 密码，可以使用以下命令设置：\nsudo passwd root\n\n按照提示输入当前用户的密码，然后设置新的 root 密码。\n添加新用户\nsudo adduser --allow-bad-names yourname\n\n赋予新用户管理员权限\n在 Ubuntu 系统中，管理员权限通常通过将用户添加到 sudo 组来实现。使用以下命令将 ErgouTree 用户添加到 sudo 组：\nsudo usermod -aG sudo ErgouTree\n\n验证\n# 切换到新用户su - ErgouTree# 验证管理员权限sudo ls /root\n\n","categories":["实用","教程","配置教程"],"tags":["Docker","Linux","虚拟机技术","容器技术","配置相关","教程类","实用技术"]},{"title":"Hello World","url":"/posts/16107.html","content":"常用命令Quick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nWrite Draftshexo n draft draft1\n\n在source\\目录下创建_drafts目录，并生成一个draft1.md文件\n当你编辑完草稿后，可以把文章推送到_posts目录下\n$ hexo publish &lt;file_name&gt;\n\n或\nhexo --draft\n\nDeploy In Github# 清理旧文件hexo clean# 生成新文件hexo g# 部署到 GitHub Pageshexo dhexo server\n\n\n\n引用图片![alt](path [title])\n\npath是必选的，表示图片的路径，可使用绝对或相对路径。\nalt是可选的，是图片无法加载时的替代描述文本。\ntitle是可选的，是图片的标题\n将所有文章的图片放到source/images 文件夹中，然后使用markdown语句引用图片\n或\n为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：\n\n在博客根目录打开_config.yml文件做如下修改：yaml post_asset_folder: true\n然后使用hexo n text命令后创建一个使用post布局名为text的文章，你将发现hexo在\\source\\_post文件夹下创建了一个\\text文件夹以及同名的.md文件：\n最后就可以打开text.md文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。注意：请不要自作聪明将text.md文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用\n\nhexo插入图片的原生语法使用 Hexo 的 asset_img 标签\n&#123;% asset_img 文件名.后缀 图片描述 %&#125;\n\n\n需要将图片放在 source/images/ 目录下（或 _config.yml 中 post_asset_folder: true 时与文章同名的文件夹中）\n文件名需要包含后缀（如 .jpg, .png 等）\n\n使用 HTML 的 标签&lt;img src=&quot;图片路径&quot; alt=&quot;图片描述&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;\n\n\n\n\n\n插入视频&lt;video width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;source src=video_path&gt;&lt;/video&gt;\n\n\nvideo_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。\nwidth和height是视频区块的宽度和高度，可自定义。\n\n引用和代码区块&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content...&#123;% endblockquote %&#125;\n\n例如：\nQuick Start\nluzhengli hello-worldluzhengli.github.io/2020/04/10/hello-world\n\n还有一种简单的引用语法：\n&gt; 这也是引用&gt;&gt; 引用1&gt;&gt; 饮用2\n\n\n这也是引用\n引用1\n饮用2\n\n代码用Hexo的太麻烦了\n用markdown原来的&#96;&#96;&#96;得了\nMermaid画流程图语法\n\n    内容\n  \n\n\n\nbutterfly主题的标签外挂语法&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;&#123;% note [class] [no-icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125;\n\n\n\nbutterfly主题下的tag-hide如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。\ninline 在文本里面添加按钮隐藏内容，只限文字\n( content 不能包含英文逗号，可用 &amp;sbquo;)\n&#123;% hideInline content,display,bg,color %&#125;\n\n参数\t解释content\t文本内容display\t【可选】按钮显示的文字bg\t【可选】按钮的背景颜色color\t【可选】按钮文字的颜色\n哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人? &#123;% hideInline ErgouTree %&#125;\n\n哪个英文字母最酷？ 查看答案因为西装裤(C装酷)\n门里站着一个人? ClickErgouTree\nbutterfly主题下的tabs&#123;% tabs Unique name, [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\n\n\n&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\ntest1 1test1 2test1 3This is Tab 1.This is Tab 2.This is Tab 3.\n\n&#123;% tabs test4 %&#125;&lt;!-- tab 第一个Tab --&gt;**tab 名字为第一个 Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有 Tab 名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;\n\n第一个Tab炸弹tab 名字为第一个 Tab只有图标 没有 Tab 名字名字+icon\n\n\n\n文章写完之后编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。\n生成&#x2F;删除静态文件\n 生成静态文件命令：hexo generate或 hexo g 删除静态文件命令：hexo clean\n\n正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。\n如果发生了一些错误，可以先删除静态文件，然后再重新生成。hexo g命令还提供了一个参数-f提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。\n启动本地端口\n 命令：hexo server或 hexo s\n\n"},{"title":"markdown常用语法","url":"/posts/43275.html","content":"markdown常用语法标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n#后必须要有空格还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。Heading level 1===============Heading level 2---------------在实际渲染中，’#’ 号数量对应标题级别，一个 ‘#’ 是一级标题，两个 ‘#’ 是二级标题，以此类推。#的叠加可以很多，但是当过多之后，会变的比正常字体还要小，可以利用这个特性***## 段落和换行#### 换行句子末尾双空格代表换行。或者多个空格进行换行 貌似也可以#### 段落处理段落就是用空白行将一行或多行文本进行分割注意：不要用空格（spaces）或制表符（ tabs）缩进段落。***## 强调*斜体文本*   前后各添加一个星号或下划线  _斜体文本_**粗体文本**   前后各添加两个星号或下划线  __粗体文本__***加粗斜体文本***~~删除线文本~~粗体和斜体可以混合用***## 代码块行内代码：用反引号 包裹代码片段，如System.out.println(“Hello World”);代码块：使用三个反引号  包裹代码块，并可在其后指定语言（可选，用于语法高亮）​```代码语言内部代码注意```需要闭合  貌似三个波浪号也可以~~~ ~~~### 链接- **行内式链接**：`[链接文本](链接地址 &quot;可选标题&quot;)`，例如：[百度](https://www.baidu.com &quot;百度首页&quot;)- **参考式链接**：[链接文本][链接标识][链接标识]: 链接地址 &quot;可选标题&quot;***## 引用&gt; 这是一段引用文本&gt; 引用可以有多行&gt; 若有多段引用，可在每段前加 &gt; 符号。&gt; 嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。块引用可以包含其他 Markdown 格式的元素。但并非所有元素都可以使用我已经验证了强调和段落换行表格可以用​&#96;&#96;&#96;markdown&gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用&gt; 这是一段引用文本&gt; 引用可以嵌套&gt; &gt; 我继续引用&gt; &gt;&gt; &gt; &gt; 我还引用  &gt; &gt; &gt;&gt; &gt; &gt; ***## 分割\n\n以上三种写法都可生成一条分隔线。  ***## 列表### 有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。  数字不必按数学顺序排列，但是列表应当以数字 1 起始。  ​```markdown1. 列表项12. 列表项2   1. 子列表项1   2. 子列表项23. 列表项3\n无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n- 列表项1  - 子列表项1  - 子列表项2+ 列表项2* 列表项3\n列表中来回嵌套的问题在如果需要列表中嵌套其他元素，基本所有都可以，甚至图片，拿代码块举例子要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符  \n1.  列表行12.  下面是代码        &amp;&lt;html&gt;          &amp;lt;head&gt;            &amp;lt;title&gt;Test&amp;lt;/title&gt;          &amp;lt;/head&gt;3.  同样的，列表也可以嵌套列表\n\n列表行1\n\n下面是代码\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Test&amp;lt;/title&gt;\n  &lt;/head&gt;\n\n\n同样的，列表也可以嵌套列表\n\n\n\n表格基本表格语法表头与内容分隔：使用 | 来分隔表格的列，表头与表格内容之间通过 — 分隔，— 还可用于指定列的对齐方式。  \n| 表头1 | 表头2 | 表头3 || :---: | :-- | --: || 居中内容 | 左对齐内容 | 右对齐内容 || 第二行数据1 | 第二行数据2 | 第二行数据3 |\n\n\n\n表头1\n表头2\n表头3\n\n\n\n居中内容\n左对齐内容\n右对齐内容\n\n\n第二行数据1\n第二行数据2\n第二行数据3\n\n\n表格内容换行如果表格内容需要换行，可以直接在 Markdown 源文件中使用 HTML 的  标签。支持扩展语法的编辑器中，也可以通过在单元格内容中按回车键进行换行，然后适当缩进以保持格式。  \n| 列1 | 列2 || ---- | ---- || 长内容 &lt;br&gt; 换行显示 | 其他内容 |\n\n\n\n列1\n列2\n\n\n\n长内容  换行显示\n其他内容\n\n\n合并单元格标准 Markdown 语法本身不支持直接合并单元格。不过，在一些特定的 Markdown 渲染器（如在 Markdown 中嵌入 HTML 时），可以使用 HTML 的  标签来实现。  \n\n图片行内式图片：例如：，换成你自己的图片链接参考式图片：\n![替代文本][图片标识][图片标识]: 图片地址 &quot;可选标题&quot;\n\n任务列表任务列表可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。\n- [x] Write the press release- [ ] Update the website- [ ] Contact the media\n\n Write the press release\n Update the website\n Contact the media\n\n\n转义字符在字符前面添加反斜杠字符 \\ ，这样markdown会识别不去执行该符号例如* Without the backslash, this would be a bullet in an unordered list.  \n\nWithout the backslash, this would be a bullet in an unordered list.  不加就会被识别成列表\n\n\n内嵌html代码对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到Markdown 文本中即可html里面咋用，在这里就可以咋用  \n\n插入表情符号可以简单地从Emojipedia 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。\n目录导航[[TOC]]  \n隐藏注释\n数学公式本质上就是插入latex代码，但是在markdown中插入latex代码需要用两个$符号\n行内公式：$E=mc^2$块级公式：$$\\begin&#123;bmatrix&#125;1 &amp; 0 \\\\0 &amp; 1\\end&#123;bmatrix&#125;$$\n\n流程图（需渲染器支持）`&#96;&#96;mermaid\ngraph TD\n  A[开始] –&gt; B(处理逻辑)\n  B –&gt; C{判断}\n  C –&gt;|是| D[结果1]\n  C –&gt;|否| E[结果2]\n`&#96;&#96;\ngraph TD\n    A[开始] --&gt; B(处理逻辑)\n    B --&gt; C&#123;判断&#125;\n    C --&gt;|是| D[结果1]\n    C --&gt;|否| E[结果2]\n\n","categories":["实用","语言方面"],"tags":["语言方面","实用工具","常用知识"]},{"title":"个人总结的Java技术栈路线-持续更新","url":"/posts/14621.html","content":"Java SE部分\n基础语法\n\n变量与数据类型：基本数据类型（byte、short、int、long、float、double、char、boolean），引用数据类型（类、接口、数组、字符串等），变量的声明、初始化和作用域。\n运算符：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符等。\n流程控制：顺序结构、选择结构（if - else、switch - case）、循环结构（for、while、do - while），以及 break、continue 关键字的使用。\n方法：方法的定义、参数传递、返回值，方法的重载和递归调用。\n数组：一维数组和多维数组的声明、初始化、遍历和常用操作。\n\n\n面向对象编程\n\n类与对象：类的定义，对象的创建和使用，构造方法，this 关键字。\n封装：访问修饰符（public、private、protected、默认），成员变量的封装和访问控制。\n继承：继承的概念，extends 关键字，方法重写，super 关键字，继承的层次结构和多态性。\n多态：对象的多态性，方法的动态绑定，向上转型和向下转型。\n抽象类与接口：抽象类的定义和使用，抽象方法，接口的定义和实现，接口的多实现和默认方法。\n\n\n常用类\n\nString 类：字符串的创建、操作（拼接、截取、替换等），字符串的比较，不可变特性。\nStringBuilder 与 StringBuffer：可变字符串，两者的区别和适用场景。\n包装类：基本数据类型的包装类（Integer、Double、Boolean 等），自动装箱和拆箱。\nMath 类：数学运算相关的方法，如随机数生成、三角函数、指数运算等。\nDate 与 Calendar 类：日期和时间的处理，获取当前日期和时间，日期的格式化和解析。\nFile 类：文件和目录的操作，文件的创建、删除、读取、写入，目录的创建和遍历。\n\n\n内部类和包装类\n\n内部类\n\n成员内部类：定义在另一个类的内部，作为外部类的一个成员，可以访问外部类的所有成员。\n静态内部类：使用 static 修饰的内部类，只能访问外部类的静态成员。\n局部内部类：定义在方法内部，只能在该方法内部使用。\n匿名内部类：没有显式的类名，通常用于创建一次性的对象，常用于实现接口或继承抽象类。\n\n\n包装类\n\n基本数据类型对应的包装类：Byte、Short、Integer、Long、Float、Double、Character、Boolean。\n自动装箱和拆箱：Java 提供了自动将基本数据类型转换为包装类对象（装箱）和将包装类对象转换为基本数据类型（拆箱）的功能。\n\n\n\n\n注解\n\n内置注解：如 @Override 用于标识方法重写；@Deprecated 用于标记已过时的元素；@SuppressWarnings 用于抑制编译器警告。\n元注解：用于定义注解的注解，如 @Retention 用于指定注解的保留策略（SOURCE、CLASS、RUNTIME）；@Target 用于指定注解可以应用的目标元素类型。\n自定义注解：可以通过 @interface 关键字定义自己的注解，并使用元注解进行配置。\n\n\n动态代理\n\n概念：在运行时动态创建代理类和代理对象，无需手动编写代理类的代码。\nJava 中的动态代理实现\n基于接口的动态代理：使用 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口实现。\n基于类的动态代理：使用第三方库如 CGLIB 实现，它可以为没有实现接口的类创建代理。\n\n\n\n\n枚举\n\n基本概念：枚举是一种特殊的类，用于定义一组固定的常量。\n枚举的定义和使用：使用 enum 关键字定义枚举类型，枚举常量默认是 public static final 的。\n枚举的方法：枚举类型可以有自己的构造方法、成员变量和方法，还可以实现接口。\n\n\n集合框架\n\nList 接口：有序、可重复的集合，常用实现类有 ArrayList、LinkedList，列表的添加、删除、查找等操作。\nSet 接口：无序、不可重复的集合，常用实现类有 HashSet、TreeSet，集合的交、并、差等操作。\nMap 接口：键值对形式的集合，常用实现类有 HashMap、TreeMap、Hashtable，映射的添加、获取、遍历等操作。\nQueue 接口：队列，先进先出（FIFO）的数据结构，常用实现类有 LinkedList、PriorityQueue。\n迭代器（Iterator）：用于遍历集合元素，统一的遍历方式，避免对集合内部结构的暴露。\n\n\n异常处理\n\n异常体系：Throwable 类，Error 和 Exception 的区别，受检异常和非受检异常。\ntry - catch - finally 语句：捕获和处理异常，finally 块的作用，多个 catch 块的使用。\nthrow 与 throws 关键字：手动抛出异常，声明方法可能抛出的异常。\n自定义异常：创建自定义异常类，用于特定业务场景下的异常处理。\n\n\n多线程\n\n线程基础：线程的概念，进程与线程的区别，线程的生命周期（新建、就绪、运行、阻塞、死亡）。\n创建线程的方式：继承 Thread 类，实现 Runnable 接口，使用 Callable 接口和 Future 获取线程执行结果。\n线程同步：synchronized 关键字，同步方法和同步块，解决线程安全问题。\n线程通信：wait ()、notify ()、notifyAll () 方法，生产者 - 消费者模型。\n线程池：Executor 框架，线程池的创建和使用，常见的线程池类型（如 FixedThreadPool、CachedThreadPool 等）。\n\n\n并发编程\n\n原子操作：Atomic 类（如 AtomicInteger、AtomicBoolean 等），利用 CAS（Compare and Swap）实现原子操作。\n并发集合：ConcurrentHashMap、CopyOnWriteArrayList 等，支持高并发访问的集合类。\nLock 接口：可重入锁（ReentrantLock），读写锁（ReentrantReadWriteLock），用于更灵活的线程同步控制。\n并发工具类：CountDownLatch、CyclicBarrier、Semaphore 等，用于协调多个线程的执行。\n\n\nJava I&#x2F;O\n\n字节流：InputStream 和 OutputStream 及其子类，如 FileInputStream、FileOutputStream，用于读写字节数据。\n字符流：Reader 和 Writer 及其子类，如 FileReader、FileWriter，用于读写字符数据，字符编码的转换。\n缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter，提高读写效率。\n对象流：ObjectInputStream 和 ObjectOutputStream，用于对象的序列化和反序列化。\nNIO（New I&#x2F;O）：通道（Channel）、缓冲区（Buffer）、选择器（Selector），基于非阻塞的 I&#x2F;O 模型，提高 I&#x2F;O 性能。\n\n\n反射机制\n\nClass 类：获取类的 Class 对象，通过 Class 对象获取类的构造方法、成员变量、成员方法等信息。\n反射的应用：动态创建对象，调用对象的方法，访问和修改对象的成员变量，在框架开发和插件化开发中有广泛应用。\n\n\n泛型\n\n泛型的定义：在类、接口、方法中使用类型参数，提高代码的复用性和类型安全性。\n泛型的通配符：？、？extends T、？super T 的含义和使用场景。\n泛型擦除：泛型在编译后的类型擦除机制，以及带来的一些限制和注意事项。\n\n\n网络编程\n\nHTTP协议：深入理解请求头&#x2F;响应头结构、状态码、Cookie&#x2F;Session机制\nNIO进阶：Selector多路复用、ByteBuffer内存池优化、Netty底层原理\nWebSocket：实现即时通讯功能，对比HTTP长轮询方案\n实战案例：开发简易HTTP服务器（支持GET&#x2F;POST）、实现文件断点续传\n\n\nJUnit和断言\n\n新特性\n\n**Java 8+**：Lambda表达式、Stream API、Optional空安全处理\n**Java 11+**：ZGC低延迟垃圾回收器、var局部变量类型推断\n**Java 17+**：密封类（sealed class）、模式匹配（Pattern Matching）\n实战案例：用Stream重构集合处理代码，实现并行数据清洗\n\n\n\nJava进阶部分\n高并发\n\n并发工具进阶：\nLongAdder vs AtomicLong性能对比\nStampedLock乐观锁实现高吞吐量场景\n\n\n并发模式：\nFork&#x2F;Join框架实现分治算法\nDisruptor无锁队列在金融交易系统中的应用\n\n\n实战案例：设计百万级QPS的抢购系统（库存防超卖）\n\n\n分布式\n\n一致性协议：Raft选举机制、ZAB协议在ZooKeeper中的应用\n分布式存储：Ceph对象存储原理、MinIO私有云部署\n实战案例：基于Paxos算法实现分布式锁服务\n\n\n微服务\n\nService Mesh：Istio流量管理、链路加密（mTLS）\nServerless：Spring Cloud Function实现无服务器架构\n实战案例：将单体应用改造为Serverless微服务集群\n\n\nJVM\n内存分析：\n\nMAT工具分析堆内存泄漏\nJProfiler定位CPU热点方法\n\nGC调优：\n\nG1回收器Region划分策略\n大对象分配优化（-XX:PretenureSizeThreshold）\n\n\n\n数据库部分关系型数据库：MySQL   PostgreSQL\nNoSQL：MongoDB   Redis\n缓存：\n搜索引擎：\n\nElasticsearch：\n\nWeb前端部分\n前端基础 HTML&#x2F; CSS&#x2F; JavaScript AJAX jQuery\n有精力可以学一下 TypeScript 很像js\n\n前端框架\n\nReact：组件化开发、Hooks、状态管理（Redux&#x2F;Context API）27。\nVue.js：Vue 3组合式API、Pinia&#x2F;Vuex状态管理37。\n\n\n工程化工具\n\nWebpack模块打包、Babel转译、NPM&#x2F;Yarn依赖管理8。\n\n\n前后端协作：\n\nRESTful API设计\n使用Swagger&#x2F;OpenAPI生成文档，Postman调试接口8。\n\n\nSSR与静态站点\n学习Next.js（React）或Nuxt.js（Vue）实现服务端渲染57。\n\n\n\n\n\nJavaEE与Web后端部分J2EE基础\nServlet\nTomcat（Web服务器）\nJSP &#x2F; \nNginx\n\n常用框架\nSpring部分\nMyBatis\nNetty\n工作流\n实用工具类库\n\n高性能和高可用\nCDN\n消息队列\n负载均衡\n\nDevOps与云原生1. 容器化与编排\nDocker：镜像构建、Docker Compose多容器管理28。\nKubernetes：Pod部署、Service暴露、Ingress路由管理710。\n\n2. CI&#x2F;CD与监控\nJenkins&#x2F;GitLab CI：自动化构建、测试与部署流水线810。\n云服务：AWS EC2&#x2F;S3、阿里云容器服务，实现弹性伸缩与负载均衡28。\n\n其他内容构建工具\nMaven\n\nGradle\n\n\n版本控制\nGit\nGithub\n\n测试部分Linux与服务器部分远程调用设计模式![Java 后端学习路线概览-1](个人总结的Java技术栈路线-持续更新&#x2F;Java 后端学习路线概览-1.png)\nSpring部分第一阶段：Spring核心原理与基础框架1. Spring Framework Core\n核心目标：理解IoC&#x2F;DI、AOP设计思想\n重点内容：\nIoC容器：Bean生命周期、@Component&#x2F;@Bean注解、XML配置与JavaConfig对比\n依赖注入：@Autowired原理、构造器注入 vs Setter注入、解决循环依赖\nAOP编程：\nJDK动态代理与CGLIB区别\n实现日志记录&#x2F;事务管理（@Around、@Before等切面注解）\n\n\nSpring JDBC：JdbcTemplate使用，对比原生JDBC的优势\n\n\n实践项目：实现一个银行转账系统，手动模拟事务管理（不依赖Spring事务注解）\n\n2. Spring MVC\n核心目标：从Servlet过渡到MVC框架\n关键衔接：对比Servlet开发模式 → DispatcherServlet工作原理\n重点内容：\n请求处理流程：HandlerMapping → Controller → ViewResolver\n注解驱动开发：@Controller&#x2F;@RequestMapping&#x2F;@RequestBody\n参数绑定：@RequestParam&#x2F;@PathVariable&#x2F;@ModelAttribute\n视图技术：Thymeleaf模板引擎集成（替代JSP）\n\n\n实践项目：开发博客系统的文章管理模块（CRUD+分页）\n\n\n第二阶段：现代Spring开发范式3. Spring Boot\n核心目标：掌握自动化配置与生产级应用构建\n重点内容：\nStarter机制：分析spring-boot-starter-web的自动配置过程\n外部化配置：多环境配置（application-{profile}.yml）、@ConfigurationProperties\n嵌入式容器：Tomcat vs Undertow性能对比\nActuator：健康检查、Metrics监控端点配置\n测试：@SpringBootTest集成测试、MockMVC模拟HTTP请求\n\n\n实践项目：改造第一阶段项目为Spring Boot版本，增加Swagger API文档\n\n4. Spring Security\n核心目标：构建安全认证体系\n学习路径：\n基础认证：内存认证 → JDBC认证 → 自定义UserDetailsService\n表单登录 vs JWT认证：实现无状态认证（搭配JJWT库）\n权限控制：方法级安全（@PreAuthorize）、ACL权限模型\nOAuth2.0：授权码模式实现（整合GitHub登录）\n\n\n实践项目：为博客系统增加RBAC权限管理，支持JWT+OAuth2混合认证\n\n\n第三阶段：企业级整合与深度优化5. 数据持久化整合\nSpring Data JPA：\nRepository动态代理机制\n@Query注解实现复杂查询\n审计功能（@CreatedDate）\n\n\nMyBatis Plus：\n通用Mapper与条件构造器\n分页插件原理分析\n\n\n多数据源配置：AbstractRoutingDataSource动态切换\n性能优化：\n二级缓存整合（Ehcache&#x2F;Redis）\n批处理优化（JdbcTemplate批量插入）\n\n\n\n6. 响应式编程\nSpring WebFlux：\nReactor编程模型（Flux&#x2F;Mono）\n对比Servlet阻塞模型的性能优势\n整合MongoDB Reactive驱动\n\n\n\n\n第四阶段：微服务架构进阶7. Spring Cloud\n基础组件：\n服务注册发现：Eureka vs Nacos注册中心对比\n配置中心：Spring Cloud Config + Bus动态刷新\n服务调用：OpenFeign声明式客户端 + Hystrix熔断\n\n\n进阶方案：\n网关：Spring Cloud Gateway动态路由配置\n链路追踪：Sleuth + Zipkin全链路监控\n分布式事务：Seata AT模式实现\n\n\n实践项目：拆解博客系统为微服务架构（用户服务&#x2F;内容服务&#x2F;评论服务）\n\n\n\n必读文档：\nSpring Framework官方文档\nSpring Boot Reference Guide\n\n\n深度书籍：\n《Spring揭秘》（深入理解设计思想）\n《Spring Boot编程思想》（核心原理剖析）\n\n\n\n按照这个路径学习，建议每完成一个阶段就进行知识图谱绘制（如用XMind整理技术点关联），遇到问题优先查阅官方文档，同时结合Github优质开源项目（如spring-petclinic）进行对比学习。\n","categories":["Java学习","技术栈路线与知识总结"],"tags":["其他","Java学习","计算机理论知识","知识总结"]},{"title":"个人向galgame原声带或相关音乐整理及其资源","url":"/posts/40344.html","content":"也是一直以来打算整理一下自己爱听的galgame ost 或者其他galgame相关的音乐，按照专辑的方式进行整理，同时我有的也会扒下来上传\n就借助这个机会，好好的搞一下吧\n顺序随缘\n持续更新\n\n\n【FLAC+MP3】AIR ORIGINAL SOUNDTRACK神尾观铃镇楼\n\n\n\n通过网盘分享的文件：AIR ORIGINAL SOUNDTRACK.zip13XeUCWQxV19snaDqzz48uA?pwd&#x3D;1174 提取码: 1174      解压 10086\n\n【WAV】ゲーム「水葬銀貨のイストリア」Sound Track／ウグイスカグラ\n【WAV】ゲーム「水葬銀貨のイストリア」Sound Track／ウグイスカグラ.zip百度网盘 提取码: 1174\n\n【FLAC】さよならアーリーサマー／やなぎなぎ、麻枝准\n 百度网盘 提取码: 1174  需要改后缀\n解压码www.summerpockets.com   因为是鸟白岛演绎厅的资源\n\n【WAV】ゲーム「Summer Pockets REFLECTION BLUE」EDM Arrange Album「De-Stress Summer」／Key Sounds Label\n百度网盘 1174 \n解压码www.summerpockets.com   因为是鸟白岛演绎厅的资源\n\n【WAV】ゲーム「HEAVEN BURNS RED」Original Sound Track Vol.2／Key Sounds Label&#x2F;1zGCb-DbVtiZw7OEhjtrEAw?pwd&#x3D;1174 提取码: 1174\n\n【FLAC】オーガスト歴代ボーカル ピアノアレンジ集「SPROUT AUGUST」／AUGUST.zip\n通过网盘分享的文件：【FLAC】オーガスト歴代ボーカル ピアノアレンジ集「SPROUT AUGUST」／AUGUST.zip&#x2F;s&#x2F;18sbtkuMKA4Y0pCgZnt9Vug?pwd&#x3D;1174 提取码: 1174\n\n【WAV】Symphony Sounds Request 3／Symphony Sounds.zips&#x2F;1egfV1odE2EYjNly2zOHSOw?pwd&#x3D;1174 提取码: 1174\n\n【FLAC】アニメ「この世の果てで恋を唄う少女YU-NO」Original Sound Track Vol.1+Vol.2／MAGES\n&#x2F;s&#x2F;11H4oSdj7eLC8DnjLczy3OA?pwd&#x3D;1174 提取码: 1174\n解压密码：www.summerpockets.com\n\n【WAV／MP4】ゲーム「Kanon」16bit Arrangements／Key Sounds Label\\1c6qn8xBuPZKcZa7r48aeig?pwd&#x3D;1174 提取码: 1174\n解压密码：www.summerpockets.com\n\n【MP3+FLAC】White Eternity of AstralAir ORIGINAL SOUNDTRACK PLUS\n通过网盘分享的文件：White Eternity of AstralAir ORIGINAL SOUNDTRACK PLUS 解10086.zip链接: https://pan.baidu.com/s/1n67xwWghZ6AHxl3x5UwXlg?pwd=1174 提取码: 1174\n解压10086\n\n【MP3+FLAC】Key+Lia Best 2001-2010\n\n\n通过网盘分享的文件：【FLAC】Key+Lia Best 2001-2010.zip1uQsB0IOIx3WiV-alVB30Hg?pwd&#x3D;1174 提取码: 1174\n\n【FLAC+MP3】Kanon AIR Piano Arrange Album Re-feel\n\n\nKanon AIR Piano Arrange Album Re-feel1esxDlcRiuVKFVnSHSehd7A?pwd&#x3D;1174 提取码: 1174\n\n【FLAC+MP3】CLANNAD ORIGINAL SOUNDTRACK1e-8hP1MQxodUMCvR3AYw5g?pwd&#x3D;1174 提取码: 1174\n\n【WAV】ゲーム「夢と色でできている」USB Memory with Digital Contents／feng\n通过网盘分享的文件：【WAV】ゲーム「夢と色でできている」USB Memory with Digital Contents／feng链接: https://pan.baidu.com/s/1KFY7ByNth5tp9VPDyBglkw?pwd=1174 提取码: 1174\n\n【WAV】fengコンプリートボーカルアルバム／feng\n通过网盘分享的文件：feng Complete Vocal Album.zip链接: https://pan.baidu.com/s/1NtXdmhhizF9JlCR4qTFi7g?pwd=1174 提取码: 1174\n解压10086\n\n【FLAC+MP3】FAVORITE 15th ANNIVERSARY VOCAL COLLECTION\nMP3:1lJbEcMMquJ3XgJ7UI003uQ?pwd&#x3D;1174 提取码: 1174\nFLAC:\n解压10086\n通过网盘分享的文件：FAVORITE 15th ANNIVERSARY VOCAL COLLECTION链接: https://pan.baidu.com/s/12PkkRzwkNPo71vxaaH5HnA?pwd=1174 提取码: 1174\n\n【FLAC】鍵音祭 (セットリスト)／Key Sounds Labe\n来自鸟白岛放映厅的资源\n通过网盘分享的文件：【FLAC】鍵音祭 (セットリスト)／Key Sounds Labe1DdJwmZ1DvbJ0erWJN1ZMqQ?pwd&#x3D;1174 提取码: 1174\n解压 www.summerpockets.com\n\n【WAV】ゲーム「フレラバ ～Friend to Lover～」Mini Fandisc &amp; Full Sound Track／SMEE\n通过网盘分享的文件：【WAV】ゲーム「フレラバ ～Friend to Lover～」Mini Fandisc &amp; Full Sound Track／SMEE1SI5G8FG2tSenoIdsm5wDBw?pwd&#x3D;1174 提取码: 1174\n解压 鸟白岛演绎厅-www.summerpockets.com\n\n【FLAC】向日葵の教会と長い夏休み サウンドトラック Himawari no Kyoukai to Nagai Natsuyasumi Soundtrack CD\n通过网盘分享的文件：Himawari no Kyoukai to Nagai Natsuyasumi Soundtrack CD.zip1sH6YwII1vADiQQ95ho4Y7Q?pwd&#x3D;1174 提取码: 1174\n解压 10086\n\n【WAV】Key ORCHESTRA CONCERT 2018／Key Sounds Label\n通过网盘分享的文件：【WAV】Key ORCHESTRA CONCERT 2018／Key Sounds Label17JZcyCw6nE2–xxXU2dSOA?pwd&#x3D;1174 提取码: 1174\n解压 鸟白岛演绎厅-www.summerpockets.com\n\n","categories":["其他","galgame相关"],"tags":["galgame","其他","音乐"]},{"title":"把Hexo博客配置到Github Pages下","url":"/posts/53748.html","content":"使用 Hexo+GitHub 搭建个人博客前情提要你需要自己去安装nodejs和git的环境，因为Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。\n这种教程csdn一搜一大堆啊，基本照着做都是下一步和最后的配置环境变量\n\nNode.js：https://nodejs.org/zh-cn\n\nGit：https://git-scm.com/downloads\n\n\n安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git --version 并回车，出现程序版本号即可。\n然后你需要自己去注册一个GitHub账号，这里强烈建议设置SSH密钥\n安装Hexo新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog\n安装Hexo使用 npm 一键安装 Hexo 博客程序：\n注意：建议之后所有使用命令行安装操作都使用 管理员模式下的cmd\nnpm install -g hexo-cli\n\n比较难绷的是安装时候界面没有任何反应，而且时间还不短\n初始化Hexo初始化并安装所需组件\nhexo init      # 初始化npm install    # 安装组件\n\n完成后依次输入下面命令，启动本地服务器进行预览：\nhexo g   # 生成页面hexo s   # 启动预览\n\n访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！\n\n如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。\n博客文件目录结构\n创建一个Github仓库来存放你的静态页面GitHub 主页右上角加号 -&gt; New repository：\n​\t注意，这里的仓库名字是 用户名.github.io   最好选上 “Initialize this repository with a README”\n此时如果你在这个仓库上配置博客的话，博客地址为：https://用户名.github.io\n部署到Github Pages本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。\n首先安装 hexo-deployer-git：\nnpm install hexo-deployer-git --save\n\n然后修改博客根目录下的 _config.yml 文件末尾的 Deployment 部分，修改成如下：\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: main\n\n这里说一下yml文件的格式，yml缩进有严格的格式要求，而且每个字段后的冒号之后必须有空格才能输入有效\n完成后运行 hexo d 将网站上传部署到 GitHub Pages。\n完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。\n绑定域名博客搭建完成使用的是 GitHub 的子域名（用户名.http://github.io），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。\n建议这里使用免实名的域名，实名一个域名比较麻烦，而且要等\n域名注册和解析\n域名注册和解析教程：Namesilo 域名购买及使用教程\n\n按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 用户名.github.io。\n\n绑定域名到 Hexo 博客进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如 http://www.example.com，保存名称为 “CNAME”，格式为 “所有文件”（无 .txt 后缀）。\n清除缓存等文件并重新发布网站：\nhexo clean   # 清除缓存文件等hexo g       # 生成页面hexo s       # 启动预览\n\n现在就可以使用自己的域名访问 Hexo 博客了。\n开启HTTPS配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。\n\nHTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！\n关于使用发布文章进入博客所在目录，右键打开 Git Bash Here，创建博文：\nhexo new &quot;My New Post&quot;\n\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。\n写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。\nhexo g   # 生成页面hexo d   # 部署发布\n\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。\n---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文\n\n\n\n常用命令hexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助\n\n我的另一篇博客也提到了hexo命令的基本用法，可以看看\nHexo命令的基本用法\n","categories":["教程","配置教程"],"tags":["Hexo相关","教程","部署"]},{"title":"操作系统之处理机的死锁部分概述","url":"/posts/27893.html","content":"死锁概述死锁（Deadlock）：是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。\n资源问题\n可重用性资源和消耗性资源：\n可重用性资源：\n\n是一种可供用户重复使用多次的资源。每一个可重用性资源只能分配给一个进程使用，不允许多个进程共享。\n资源的单元数目是相对固定的，在运行期间既不能创建也不能删除它\n\n\n消耗性资源：\n\n在进程运行期间，由进程动态地创建和消耗。\n资源的单元数目在进程运行期间可以不断变化的。进程可以请求若干个可消耗性资源单元。\n可消耗性资源通常由生产者创建，消费者消耗。\n\n\n\n\n可抢占性资源和不可抢占性资源。\n可抢占性资源：\n\n某进程获得该资源后，该资源可以再被其他进程或系统抢占。\n不会引起死锁。\n\n\n不可抢占性资源是指资源一旦被分配给进程，只能在进程用完后自行释放。\n\n\n\n\n计算机中的死锁\n竞争不可抢占性资源引起死锁。\n两进程分别保持一个临界资源，而又分别因请求对方所保持的资源被阻塞。\n\n\n竞争可消耗性资源引起死锁。\n一进程需接受到对方发送的消息a后才能发送消息b，而另一进程需接受到对方发送的消息b后才能发送消息a。\n\n\n进程推进顺序不当引起死锁。\n同样是请求和保持原因。\n\n\n\n死锁的定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的时间，那么该组进程是死锁的。\n产生死锁的必要条件互斥条件：指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。\n请求和保持条件：指进程已经保持了至少一个资源，但又提出了 新的资源请求（该资源又被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放）。\n不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放\n环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。即进程集合{P0,P1,P2,…,Pn}中的P0正在等待一个P1占用的资源；P1正在等待一个P2占用的资源，……，Pn正在等待一个已被P0占用的资源。\n死锁处理方法预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件的一个或几个，来预防发生死锁。\n避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁\n检测死锁：通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当的措施，从系统中将已发生的死锁清除掉\n解除死锁：当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源\n预防死锁由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏其它三个条件。\n破坏“请求和保持”条件第一种协议：​\t规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。在整个运行期间便不会再提出资源要求，从而破坏了请求条件。\n​\t在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需的各资源都空闲，也不分配给该进程，即在该进程的等待期间，它并未占有任何资源，因而也破坏了保持条件。\n第二种协议：​\t允许进程只获得运行初期所需的资源后，便开始运行。\n​\t进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再去请求新的所需资源\n破坏不可抢占条件当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。\n这意味着某一进程已经占有的资源，在运行过程中会被暂时地释放掉，也可认为是被抢占了，从而破坏了“不可抢占”条件。\n破坏 循环等待条件系统将所有类型资源进行线性排队，并赋予不同的序号。规定每个进程必须按序号递增的顺序请求资源。\n假如某进程已请求到一些序号较高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源\n在采用这种策略后不可能再出现环路，因而破坏了“循环等待”条件。\n避免死锁系统安全状态：系统在进行资源分配之前，应先计算此次资源分配的安全性。\n安全状态，是指系统能按某种进程顺序（ P0, P1, P2, …, Pn ）来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态\n安全状态下不会产生死锁，但是不安全状态不一定产生死锁\n利用银行家算法避免死锁描述资源的数据结构在系统中必须设置四种数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。\n（设系统中有m类资源，n个进程）\n\n可利用资源向量 Available：\n\n这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。\n\n如果 Available[j]&#x3D;K，则表示系统中现有 R j类资源K 个。\n\n\n\n最大需求矩阵 Max：\n\n这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m 类资源的最大需求。\n\n\n分配矩阵 Allocation：\n\n这也是一个 n×m 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。\n如果 Allocation[i,j]&#x3D;K，则表示进程 i 当前已分得 R j类资源的数目为 K。\n\n\n需求矩阵 Need。这也是一个 n×m 的矩阵，用以表示每一个进程尚需的各类资源数。\n\n如果 Need[i,j]&#x3D;K，则表示进程 i 还需要 R j类资源 K 个，方能完成其任务。\n\n\n\n 上述三个矩阵间存在下述关系：Need[i, j] &#x3D; Max[i, j] - Allocation[i, j]\n银行家算法：设 Request[i] 是进程 P i 的请求向量，如果 Request[i][j]&#x3D;K，表示进程 P i需要 K 个 R j 类型的资源。当 P i发出资源请求后，系统按下述步骤进行检查： \n\n如果 Request[i][j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值\n如果 Request[i][j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi 须等待。 \n系统试探着把资源分配给进程 P i，并修改下面数据结构中的数值：\nAvailable[j] &#x3D; Available[j]-Request[i][j]；  更新可用资源数目\nAllocation[i,j] &#x3D; Allocation[i,j]+Request[i][j]；  更新分配给该进程的资源数\nNeed[i,j] &#x3D; Need[i,j]-Request[i][j]；    更新该进程需要的资源数\n\n\n\n安全性算法：\n设置两个向量：\n\n工作向量 Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m个元素，在执行安全算法开始时，Work&#x3D;Available。 \nFinish: 含n个元素的一维数组，表示系统是否有足够的资源分配给n个进程，使之运行完成。开始时先令Finish[i]:&#x3D;false (i&#x3D;1..n); 当有足够资源分配给进程i时，再令Finish[i]:&#x3D;true。\n\n\n从进程集合中找到一个能满足下述条件的进程：\n\nFinish[i]&#x3D;false;\nNeed[i,j]≤Work[j]；\n若找到，执行步骤(3)，否则，执行步骤(4)。\n\n\n当进程 Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：\n\nWork[j] &#x3D; Work[j]+Allocation[i,j]；\nFinish[i] &#x3D; true；\ngo to step 2；\n\n\n如果所有进程的 Finish[i]&#x3D;true 都满足，则表示系统处于安全状态；否则，系统处于不安全状态。\n\n\n死锁的检测和解除\n当系统为进程分配资源时，若未采取任何限制性措施，则系统必须提供检测和解除死锁的手段，为此系统必须：\n\n保存有关资源的请求和分配信息；\n提供一种算法，以利用这些信息来检测系统是否已进入死锁状态。\n\n\n资源分配图：\n\n\n系统死锁可利用资源分配图来描述：\n该图由表示进程的圆圈和表示一类资源的方框组成\n其中方框中的一个点代表一个该类资源，请求边是由进程指向方框中的rj，而分配边则应始于方框中的一个点。如图所示。\n\n\n死锁定理：\n\n在资源分配图中找出一个既不阻塞又非独立的进程结点Pi，在顺利的情况下运行完毕，释放其占有的全部资源。\n由于释放了资源，这样能使其它被阻塞的进程获得资源继续运行。\n在经过一系列简化后若能消去图中的所有的边，使所有进程结点都孤立，则称该图是可完全简化的，反之是不可完全简化的。\nS 状态为死锁状态的充分条件是当且仅当 S 状态的资源分配图是不可完全简化的\n\n死锁的解除：\n\n剥夺资源：从其他进程剥夺足够数量的资源给死锁进程以解除死锁状态。\n撤销进程：最简单的是让全部进程都死掉；温和一点的是按照某种顺序逐个撤销进程，直至有足够的资源可用，使死锁状态消除为止。\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之处理机的调度","url":"/posts/58087.html","content":"处理机调度的层次和调度算法的目标在多道程序环境下，进程数目往往多于处理机数目。\n这就要求系统能够按某种算法，动态的把处理机分配给就绪队列中的一个进程，使之执行\n分配处理机的任务是由处理机调度程序完成的\n处理机调度的层次高级调度：用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后将新创建的进程排在就绪队列上，准备执行\n又称长程调度或作业调度。它的调度对象为作业，只适用于多道批处理系统中，不适合实时和分时系统。\n低级调度：用来决定就绪队列中的哪个进程应获得处理机，然后再由分派程序把处理机分配给该进程。为最基本的一种调度\n又称进程调度或短程调度。它的调度对象为进程或内核级线程，适用于所有类型的操作系统。\n中级调度：又称内存调度。主要目的是为了提高内存利用率和系统吞吐量。\n使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。\n进程调度可采用下述两种调度方式：\n\n非抢占方式（Non-preemptive Mode）\n一旦把处理机分配给某进程后，便让该进程一直执行，直至该进程完成或发生某事件而被阻塞时，才把处理机分配给其他进程\n\n抢占方式（Preemptive Mode）\n允许调度程序根据某种原则，去暂停某个正在执行的进程，将处理机重新分配给另一进程。\n\n\n队列调度模型仅有进程调度的调度队列模型在分时系统中，通常仅设置进程调度。系统可以把处于就绪状态的进程组织成栈、树或一个无序链表，形式取决于OS类型和所采用的调度算法。\n\n具有高级和低级调度的调度队列模型\n同时具有三级调度的调度队列模型当在OS中引入中级调度后，可以把进程的就绪状态分为内存就绪和外存就绪。也可以把阻塞状态分为内存阻塞和外存阻塞两种状态。\n\n处理机调度算法的目标共同目标：\n资源利用率\n\n\n公平性\n公平性是指应使诸进程都获得合理的CPU 时间，不会发生进程饥饿现象。公平性是相对的。\n\n平衡性\n应尽可能保持系统资源使用的平衡性。\n\n策略强制执行\n包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。\n\n\n批处理系统的目标：平均周转时间短：所谓周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔\n带权周转时间：作业的周转时间 T 与系统为它提供服务的时间 Ts 之比\n系统吞吐量高：吞吐量是指在单位时间内系统所完成的作业数。如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。\n处理机利用率高：如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行\n分时系统的目标：响应时间快。所谓响应时间，是从用户通过键盘提交一个请求开始，直至屏幕上显示出处理结果为止的一段时间间隔。\n均衡性。指系统响应时间的快慢应与用户所请求服务的复杂性相适应。\n实时系统的目标截止时间的保证。是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。\n可预测性。 例如在多媒体系统中，可实现第 i 帧的播放和第 i+1 帧的读取并行处理，进而提高其实时性。\n作业和作业调度作业控制块 JCB是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。\n每当一个作业进入系统时，便由“作业注册”程序为该作业建立一个 JCB，再根据作业类型将它插入相应的作业后备队列中等待调度。\n在每次执行作业调度时，都须作出两个决定：\n\n接纳多少作业\n\n接纳哪些作业\n\n\n作业运行的三个阶段和三种状态\n收容阶段。\n把作业输入到硬盘上，再为作业建立 JCB 并把它放入作业后备队列中。此时作业状态为“后备状态”。\n\n运行阶段。\n此时作业状态为“运行状态”。\n\n完成阶段。\n此时作业状态为“完成状态”。系统中的“终止作业”程序将会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。\n\n\n作业调度算法先来先服务调度算法 FCFS。当在作业调度中采用FCFS算法时，每次调度都是从后备作业队列中，选择一个或多个最先进入该队列的作业\n优先考虑在系统中最先进入（等待时间最长）的作业。\n比较有利于长作业（进程），而不利于短作业（进程）。有利于CPU繁忙型的作业，而不利于I&#x2F;O繁忙型的作业（进程）\n短作业（进程）优先调度算法 SJFSJF算法是以作业的长短来计算优先级的，作业的长短是以作业所要求的运行时间来衡量的。\n从后备队列中选择一个或若干个估计运行时间最短的作业\n优点是有效降低作业的平均等待时间，提高系统吞吐量。\n缺点是可能使长作业等待时间过长，出现饥饿现象。\n高优先权优先调度算法：优先权调度算法的类型\n为照顾紧迫性作业，使之在进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法\n分为：\n\n非抢占式优先权算法\n\n抢占式优先权调度算法\n\n\n静态优先权：在创建进程时确定的，在进程的整个运行期间保持不变\n动态优先权：在创建进程时所赋予的优先权可以随进程的推进或随其等待时间的增加而改变。\n高相应比优先调度算法高响应比优先调度算法是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长。\n为每个作业引入一个动态优先级，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加\n\n于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先权又相当于响应比 RP。\n\n例子：\n\n进程调度进程调度的任务：\n保存处理机的现场信息。\n按某种算法选取进程。\n把处理器分配给进程。\n\n进程调度可采用下述两种调度方式：\n非抢占式\n\n抢占式\n抢占的原则：\n\n优先权原则：优先权高的可以抢占优先级低的进程的处理机。\n短作业（进程）优先原则：短作业（进程）可以抢占长作业（进程）的处理机。\n时间片原则：各进程按时间片运行，一个时间片用完时，停止该进程执行重新进行调度。\n\n\n\n轮转调度算法：RR系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给首进程，并令其执行一个时间片。\n进程切换时机：\n\n若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，并为新进程启动一个新的时间片。 \n\n在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。\n\n\n 例题：\n​\t\n过程：\n\n(q &#x3D; 1) 时的调度过程\n0 时刻：进程 A 到达，进入就绪队列，此时就绪队列只有 A，A 开始运行。运行 1 个时间片后（到 1 时刻），A 还需服务时间 (4 - 1&#x3D;3) ，A 被暂停，放入就绪队列队尾 。\n1 时刻：进程 B 到达，加入就绪队列，此时队首是 B，B 开始运行 1 个时间片，B 还需服务时间 (3 - 1 &#x3D; 2) ，B 被暂停，放入队尾。然后队首是 A，A 运行 1 个时间片，如此循环。\n随着时间推进，不断按照每个进程运行 1 个时间片后放入队尾的规则调度，直到所有进程完成。比如 D 进程在 3 时刻到达，加入队尾，按序调度运行。\n计算周转时间：周转时间 &#x3D; 完成时间 - 到达时间，例如 A 的周转时间 (&#x3D; 12 - 0 &#x3D; 12) 。\n计算带权周转时间：带权周转时间 &#x3D; 周转时间 &#x2F; 服务时间，A 的带权周转时间 (&#x3D;12 &#x2F; 4 &#x3D; 3) 。\n\n\n(q &#x3D; 4) 时的调度过程\n原理类似，但时间片变长。0 时刻 A 到达运行，运行 4 个时间片到 4 时刻，A 服务时间 4 刚好完成，离开就绪队列 。\n之后按序调度其他进程，每个进程运行 4 个时间片，若未完成则放入队尾等待下次调度。例如 B 进程 1 时刻到达，在 A 完成后开始运行，运行 4 个时间片到 7 时刻，B 还需 (3 - 4&#x3D;-1) （已完成） 。\n同样计算周转时间和带权周转时间，如 A 的周转时间 (&#x3D; 4 - 0 &#x3D; 4) ，带权周转时间 (&#x3D; 4 &#x2F; 4 &#x3D; 1) 。\n\n\n\n优先级调度算法类型：\n\n非抢占式优先级调度算法。\n\n抢占式优先级调度算法，实时性高\n\n\n多级反馈队列调度算法：\n调度机制：\n\n设置多个就绪队列：\n每个队列赋予不同的优先级，第一个最高，依次逐渐降低；时间片设置也不同，优先级越高，时间片越小。\n\n每个队列都采用FCFS算法：\n当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度，依次\n\n按队列优先级调度：\n调度程序首先调度最高优先级队列中的诸进程运行，仅当第 1～(i-1) 所有队列均空时，才会调度第 i 队列中的进程运行。\n如果处理机正在第i队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程\n\n\n\n\n基于公平原则的调度算法保证调度算法:针对进程而言，处理机时间分配的公平性。\n公平分享调度算法:针对用户而言，使所有用户能获得相同的处理机时间，或要求的时间比例。\n实时调度实时系统中包含两种任务硬实时任务指必须满足最后期限的限制，否则会给系统带来不可接受的破坏或者致命错误。\n软实时任务也有一个与之关联的最后期限，并希望能满足这个期限的要求，但这并不是强制的，即使超过了最后期限，调度和完成这个任务仍然是有意义的。\n实现实时调度的基本条件提供必要的信息：\n\n就绪时间\n开始截止事件，完成截止时间\n处理时间\n资源要求\n优先级\n\n系统处理能力强\n\n采用抢占式调度机制\n具有快速切换机制\n实时调度算法的分类：根据实时任务性质的不同，分为硬实时调度算法和软实时调度算法；\n按调度方式的不同，分为非抢占调度算法和抢占调度算法；\n根据调度程序调度时间的不同，分为静态调度算法和动态调度算法。\n多处理机环境下，可分为集中式调度和分布式调度两种算法。\n非抢占调度算法该算法较简单，用于一些小型实时系统或要求不太严格的实时系统中。又可分为两种\n\n非抢占式轮转调度算法：\n要求不高的实时控制系统\n\n非抢占式优先调度算法：\n有一定要求的实时控制系统\n\n\n\n抢占调度算法：用于要求较严格的实时系统中，（t约为数十ms），采用抢占式优先权调度算法。根据抢占发生时间的不同可分为两种：\n基于时钟的抢占式优先权调度算法：\n\n在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务。\n\n立即抢占的优先权调度算法：一旦出现外部中断，只要当前任务未处于临界区，就立即抢占处理机。\n\n最早截止时间EDF算法：根据任务的截止时间确定任务的优先级，截止时间越早，优先级越高，最早截止时间的排在队首\n非抢占式调度方式用于非周期实时任务：\n\n在非抢占式 EDF 算法中，一旦一个任务开始执行，它就会一直运行直到完成，不会被其他任务中途抢占。\n\n调度器会在每个任务到达时，根据其截止时间来分配优先级，截止时间越早的任务优先级越高。\n\n在任务执行过程中，即使有更高优先级的任务到达，当前正在执行的任务也不会被打断，而是继续执行直到结束。\n\n\n\n抢占式调度方式用于周期实时任务：\n有两个周期任务A和B，周期时间分别为20ms和50ms，每个周期的处理时间分别为10ms和25ms。\n首先判断系统的处理能力：10&#x2F;20 + 25&#x2F;50 &#x3D; 1 —–可行\n\n最低松弛度优先 LLF 算法任务紧急程度愈高即松弛程度愈低，赋予该任务的优先级就愈高，以使之优先执行。\n该算法主要用于可抢占调度方式。\n松弛度 &#x3D; 完成截止时间 - 还需要的执行时间 - 当前时间。\n在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在队列最前面。松弛度是动态变化的，所以优先级也是动态的\n任务的抢占时机：当某后到任务的松弛度为0时，即获得最高优先级，立即抢占 CPU。其它时间就算发现后到任务的松弛度比之正在执行任务的松弛度要低但不为0，也不进行抢占。 \n例子\n\n优先级倒置\n“优先级倒置”现象：高优先级进程被低优先级进程延迟或阻塞。\n优先级倒置的解决方法。\n1）当进程进入临界区后，CPU就不能被剥夺。\n2）优先级继承\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之操作系统引论","url":"/posts/8682.html","content":"操作系统的目标及作用操作系统OS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口\n操作系统定义操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。\nOS\n\n直接控制和管理计算机硬件，软件资源\n\n合理的对各个作业进行调度\n\n以方便用户使用的程序集合\n\n\n操作系统的目标\n方便性：\n配置了OS的计算机硬件，系统可以直接使用编译命令将用户采用该机语言书写的程序翻译成机器代码，或者直接通过OS所提供的各种命令操纵计算机，方便用户\n\n有效性：\n第一层含义：提高系统资源的利用率\n另一层：提高系统的吞吐量\n\n可扩充性：\n与OS结构有关\n\n开放性：\n系统能遵循世界标准规范，尤其是遵循开放系统互联·OSI标准\n\n\n操作系统的作用：\nOS作为用户与计算机硬件系统之间的接口\n\n\n\nOS作为计算机系统资源的管理者\n\n\n处理机管理\n\n存储器管理\n\n文件管理\n\n设备管理\n\n\n\n\nOS实现了对计算机资源的抽象\n\n\n为了方便用户使用I&#x2F;O设备，人们在裸机上覆盖一层I&#x2F;O设备管理软件，隐藏了I&#x2F;O的具体细节\n\nI&#x2F;O设备管理软件实现了对计算机硬件操作的第一个层次的抽象\n\nOS是铺设在计算机硬件上的多层软件的集合，他们不仅增强了系统的功能，还隐藏了对硬件操作的具体细节\n\n\n\n推动OS发展的主要动力\n\n\n不断提高计算机资源利用率\n\n方便用户\n\n器件的不断更新\n\n计算机体系结构的不断发展\n\n不断提出新的应用需求\n\n\n操作系统的发展过程无OS：人工操作方式：\n用户独占全机\nCPU等待人工操作\n脱机输入输出方式：\n\n单道批处理系统：设计目标：提高系统资源的使用效率；提高作业吞吐量\n\n减少机器的空闲等待时间：保持系统的连续运行，在处理完一个作业后，紧接着处理下一个作业\n\n仍不能充分的利用系统资源\n\n\n原理：\n要求用户使用系统提供的作业控制语言（JCL）来描述自己对作业运行的控制意图，并将这些控制信息连同自己的程序和数据一起作为一个作业提交给操作员。\n操作员启动有关程序将一批作业输入到计算机外存，由OS去控制、调度各作业的运行并输出结果。\n由于作业进入系统后用户不再干预，从而提高了效率。\n\n批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。\n在内存中只保持一道作业的批处理系统。\n\n内存中始终只保持一道作业，称为单道批处理系统\n多道批处理系统多道程序设计的基本理念\n多道程序设计：多个作业存放在主存中，使它们同时处于运行状态，这些作业共享处理机时间和外围设备等资源\n\n多道批处理系统的优缺点：\n资源利用率高\n系统吞吐量大\n平均周转时间长\n无交互能力\n需要解决的问题：\n(1) 处理机管理问题。\n(2) 内存管理问题。\n(3) I&#x2F;O设备管理问题。\n(4) 文件管理问题。\n(5) 作业管理问题。\n(6) 用户与系统的接口问题\n分时系统：分时系统是为了满足 用户需求所形成的一种新型OS\n在操作系统中加入了分时技术：即将处理机的运行时间分为时间片，将时间片轮流分配给各联机作业使用。\n目标：对用户的请求及时响应；尽量提高系统资源的利用率\n\n\n\n表现\n(1) 人—机交互。     (2) 共享主机。     (3) 便于用户上机。\n\n\n\n特征\n1.多路性     2.独立性     3.及时性     4.交互性\n\n\n实时系统：所谓“实时”，是表示“及时”，而实时系统(RealTime System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\n目标：提高系统的响应时间，对随机发生的外部事件作出及时响应并对其进行处理。\n系统类型\n  (1) 实时控制与处理：工业武器控制、嵌入式系统\n  (2) 实时信息处理： 信息查询系统、多媒体系统\n实时任务类型\n按任务执行时是否呈现周期性来划分\n(1)周期性实时任务。\n(2)非周期性实时任务。\n根据对截止时间的要求来划分\n(1) 硬实时任务(hard real-time task)\n(2) 软实时任务(Soft real-time task)\n  特征\n   多路性\n   独立性\n   及时性\n   交互性\n   可靠性\n操作系统的基本特性并发 共享 虚拟 异步\n并行和并发：并行是指这一个时刻上面有着多个事件在执行，是一个瞬间的状态。\n并发是指在某一段时间间隔以内有着多个事件同时进行\n在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交 替执行。\n进程：程序为静态的，进程为程序的执行\n线程：进程的更小的可执行单位，一个进程可以包含若干个线程\n共享指系统中的资源供内存中的多道程序所共同使用\n在OS环境下的资源共享称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用\n在操作系统环境下，所谓共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。由于资源属性的不同，进程对资源共享的方式也不同，目前主要有\n以下两种资源共享方式：\n互斥共享方式：\n系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源，我们把这种资源共享方式称为互斥式共享\n临界资源或独占资源：一段时间内只允许一个进程访问的资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。\n同时访问方式\n允许在一段时间内由多个进程 “同时”对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。\n虚拟操作系统中的所谓“虚拟”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物\n在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存、 虚拟外部设备和虚拟信道等。\n时分复用技术：虚拟机处理技术：每个程序建里至少一个进程，让多道程序并发执行，通过时分复用同时为多个用户服务\n虚拟设备技术：通过时分复用将一台物理IO设备虚拟为多台逻辑上的IO设备，并允许每 个用户占用一台逻辑上的I&#x2F;O设备\n在操作系统中，虚拟的实现主要是通过分时使用的方法。显然，如果 n 是某物理设备所对应的虚拟的逻辑设备数，则虚 拟设备的平均速度必然是物理设备速度的 1 &#x2F; n \n空分复用技术虚拟磁盘技术：将硬盘划分为若干个卷，机器上便会有若 干个虚拟盘。\n虚拟存储器技术：将一台机器的物理存储器变为虚拟存储 器，以便从逻辑上来扩充存储器的容量。\n4、异步\n进程是以人们不可预知的速度向前推进，此即进程的异步性\n在多道程序环境下，系统允许多个进程并发执行\n并发执行的程序走走停停，以不可预知的速度前进\n操作系统的主要功能 引入OS的主要目的是：为多道程序的允许提供良好的运行环境，保证多道程序能有条不紊，高效的运行，并最大程度的提高系统中各种资源的利用率，方便用户的使用\nOS定义：OS是直接控制和管理计算机硬件、软件资源，合理地对各类作业进行调度，以方便用户使用的程序集合\n处理机管理功能\n存储器管理功能\n设备管理功能\n文件管理功能\n用户接口\n处理机管理功能\n进程控制\n进程同步\n进程通信\n调度\n存储器管理功能\n内存分配\n静态分配\n动态分配\n内存保护\n地址映射\n内存扩充\nOS结构设计传统的操作系统结构无结构操作系统\n模块化的操作系统\n模块独立性\n模块接口法\n分层次结构OS客户／服务器模式面向对象的程序设计微内核OS结构微内核的基本概念：将操作系统划分为两大部分：微内核和多个服务器\n足够小的内核：微内核并非是一个完整的OS，而只是操作系统中最基本的部分\n它通常用于：① 实现与硬件紧密相关的处理；② 实现一些较基本的功能； ③ 负责客户和服务器之间的通信\n基于客户&#x2F;服务器模式：\n将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现。\n客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。\n微内核的基本功能\n\n进程(线程)管理\n低级存储器管理\n中断和陷入处理\n\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之进程同步","url":"/posts/17351.html","content":"进程同步进程同步机制进程同步机制：利用他们保证程序执行的可再现性\n进程同步的基本概念：某进程未获得合作进程发来的消息之前应该进程等待，消息到来之后方可继续合作关系\n进程间两种形式的制约关系\n间接相互制约关系 — 源于资源共享\n\n直接相互制约关系 — 源于进程合作\n\n\n临界资源：互斥访问\n进程间采取互斥方式，实现对资源的共享\n生产者消费者问题：生产者进程和消费者进程都以异步方式运行，但它们之间必须保持同步。\n把一次仅允许一个进程访问的资源叫做临界资源\n临界区每个进程中访问临界资源的那段代码\n对欲访问的临界资源进行检查\n\n若此刻未被访问，设正在访问的标志   ……进入区\n\n访问临界资源             ……临界区\n\n将正在访问的标志恢复为未被访问的标志 ……退出区\n\n其余部分               ……剩余区\n\n\n进程互斥：两进程不能同时进入访问同一临界资源的临界区\n同步机制应遵循的规则\n空闲让进\n\n忙则等待\n\n有限等待\n\n让权等待\n\n\n信号量机制整型信号量定义：整型量，除初始化外，仅能通过两个原子操作来访问\n\nP操作 wait(S):   \n​\t\t\t\tWhile (S&lt;&#x3D;0) do no-op;                          \n​\t\t\t\t\tS–;\nV操作 signal(S):   \n​\t\t\t\tS++;\nP、V操作是原子操作，不可中断。\n\n\n记录型信号量引入整型变量value(代表资源数目)、进程链表List (链接所有等待进程)\n用S.value的初值表示系统中某种资源的数目。\n记录型数据结构：\ntypedef  struct&#123;\t              int value;\t              struct process_control_block * list;\t       &#125; semaphore;\n\n对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此S.value–，表示资源数减1，当S.value＜0时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞，主动放弃处理机，并插入该类资源的等待队列S.L中。\n对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示该资源数加1，若加1后仍是 S.value≤0，表示依然有进程在等待该类资源，因此应调用wakeup原语幻想等待队列中的第一个进程。 \n信号量&gt;0，代表可用资源的数量\n信号量&lt;0，代表由于申请信号量，代表的资源而阻塞的进程数量\n遵循了“让权等待”原则，不会出现“忙等”现象\n\nAND型信号量ADN型信号量主要针对的是一个进程需要获取两个或更多的共享资源执行任务时的问题。\n基本思想：对若干个临界资源的分配采取原子操作的方式\n\n要么把它所请求的资源全部分配到进程，要么一个也不分配。为此，在wait中加入了一个“AND”条件，故称为AND同步，或称为同时wait操作，即 Swait\n\n\n信号量集信号量集主要针对的是执行进程时一次需要N个单位的某类临界资源的问题\n对AND型信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源量需求，在一次P、V原语操作中完成申请或释放。\n进程对信号量Si的测试值不再是1，而是该资源的分配下限ti，即要求Si&gt;&#x3D;ti。一旦允许分配，进程对该资源的需求值为di，即表示资源占用量，进行Si:&#x3D;Si-di的操作，对应的Swait和Ssignal格式为：\n\nSwait(S1,t1,d1,...,Sn,tn,dn);\n\nSsignal(S1,d1,...,Sn,dn);\n\n\nSwait(S,d,d)：此时信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数量少于d时，不予分配。\nSwait(S,1,1)：此时信号量集已蜕化为一般的记录型信号量（S&gt;1时）或互斥信号量（S&#x3D;1）。\nSwait(S,1,0)：当S&gt;&#x3D;1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区，相当于一个可控开关。\n信号量的应用\n实现进程互斥：设置mutex为互斥信号量，初值为1，取值范围为（-1,0，1）。\n\n当mutex &#x3D; 1 时，表示两个进程皆未进入互斥的临界区\n\n当mutex &#x3D; 0 时，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列\n\n当mutex &#x3D; -1 时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。\n\n\nwait(mutex)和signal(mutex)操作必须成对出现，缺少P（mutex）将会导致系统混乱，不能保证对临界资源的访问，缺少V（mutex）将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程永远不能被唤醒。\n\n\n\n\n信号量机制实现前驱关系每一对前驱关系都是一个进程同步问题\n\n要为每一对前驱关系各设置一个同步变量\n在“前操作”之后对相应的同步变量执行V操作\n在“后操作”之前对相应的同步变量执行P操作\n\n例如：\n实现S1执行后执行S2\n进程P1：S1； signal（S）；  (S为P1,P2共用的信号量)\n进行P2：wait(S); S2；\n信号量机制实现同步关系：p1，p2两进程因合作完成一项任务而共用一个变量x。进程p2将处理结果送入x；进程p1将x的结果打印。\n\n经典的进程同步问题生产者消费者问题相互合作关系的一种抽象\n问题描述：一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才把消息放入缓冲区，否则必须等待；\n只有缓冲区不空时，消费者才能从中读取消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。\n\n可利用记录型信号量解决生产者—消费者问题：\n可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用，初值为1；\n信号量 full 用于记录当前缓冲池中的“满”缓冲区数，初值为 0；\n信号量 empty 用于记录当前缓冲池中“空”的缓冲区数，初值为 n；\n\n描述如下：\n\n加锁信号量的顺序不能打乱，否则容易出现死锁，也就是P(mutex)需要跟在P(full);前面\n利用AND信号量解决生产者—消费者问题：使用Swait(empty,mutex)代替wait(empty)，wait(mutex)，Ssignal(empty,mutex)代替signal(empty)，signal(mutex)\nfull和mutex也是一样\n\n\n例题：\n描述：\n桌子上有一个盘子，每次只能向其中放入一个水果。\n爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专吃盘子中的橘子，女儿专等吃盘子中的苹果。\n只有盘子为空时，爸爸或妈妈才可以向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。\n分析：\n爸爸和妈妈是互斥关系，爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行。\n信号量 plate 表示互斥信号量，用于确定是否可以往盘子中放水果，初值为 1 表示允许放入一个；\n信号量 apple 表示盘中是否还有苹果，初值为 0表示没有不许取；orange 表示盘中是否有橘子，初值同样为 0，orange&#x3D;1 表示盘子中由橘子允许取\n\n哲学家进餐问题问题描述：一张圆桌上坐着5名哲学家，每两名哲学家之间的桌子上摆着一根筷子，两根筷子之间是一碗米饭。\n哲学家倾注毕生精力于思考和进餐，哲学家思考时不影响其他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子——一根一根地拿起。\n若筷子已在他人手上，则需要等待。饥饿地哲学家只有同时拿到了两根筷子才能开始进餐，进餐完毕，放下筷子继续思考\n分析：5 名哲学家与左右邻座对其中间的筷子的访问时互斥关系。\n显而易见，5 个哲学家对应5 个进程，问题解决的关键就是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象\n解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。\n信号量设置：互斥信号量数组 chopstick[5]&#x3D;{1,1,1,1,1}，用于对 5 个筷子的互斥访问；哲学家编号顺序：0~4，哲学家 I 左边筷子的编号为 i，哲学家右边筷子的编号为(i+1)%5。\n使用记录型信号量：\n使用AND信号量\nbasicSwait(chopstick[(i+1) % 5], chopstick[i]);EatSginal(chopstick[(i+1) % 5], chopstick[i]);\n\n\n\n\n\n\n\n读者写者问题问题描述与分析一个数据文件或记录可被多个进程共享。\n只要求读文件的进程称为“Reader进程”，其它进程则称为“Writer进程”。允许多个进程同时读一个共享对象，但不允许一个Writer进程和其他Reader进程或Writer进程同时访问共享对象\n“读者——写者问题”是保证一个 Writer 进程必须与其他进程互斥地访问共享对象的同步问题。\n\n互斥信号量wmutex: 实现 Reader 与 Writer 进程间在读或写时的互斥    \n整型变量Readcount：表示正在读的进程数目;\n以Readcount为例：\n由于只要有一个 Reader 进程在读，便不允许 Writer 进程写。 \n ∴仅当Readcount=0，即无 Reader 进程在读时，Reader 才需要执行Wait(wmutex)操作。若Wait(wmutex)操作成功，Reader 进程便可去读，相应地，做Readcount+1操作。\n使用记录型信号量解决读者写者问题\n\n使用信号量集机制解决读者写者问题\nSwait(mx, 1, 1; L, RN, 0)语句表示仅当既无writer进程在写(mx&#x3D;1)，又无reader进程在读(L&#x3D;RN)，writer进程才能进入临界区写。\nSwait(mx, 1, 0)语句起着开关的作用。只要无writer进程进入写，mx&#x3D;1，reader进程就都可以进入读。但只要一旦有writer进程进入写时，mx&#x3D;0，则任何reader进程就都无法进入读。\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"操作系统之进程的描述与控制","url":"/posts/35167.html","content":"前驱图和程序执行前趋图前趋图(Precedence Graph) 是一个有向无循环图，可记为DAG，用于描述程序&#x2F;进程之间执行的先后顺序。\n\n图中每个结点可用来表示一个进程或程序段，结点间的有向边表示两个结点之间存在的偏序或前趋关系\n如P1与 P2存在前趋关系，记作P1 -&gt; P2，表示在P2开始执行之前P1必须完成，此时称P1是P2的直接前趋，P2是P1的直接后继。没有前趋的结点称为初始结点，没有后继的结点称为终止结点，每个结点还有一个重量，用于表示该结点所含有的程序量或程序的执行时间。\n注意：前趋图中必须不存在循环\n\n程序的顺序执行：在计算机系统中只有一个程序在运行，这个程序独占系统中所有资源，其执行不受外界影响。 一道程序执行完后另一道才能开始\n程序顺序执行的特征\n顺序性：处理机的操作严格按照程序所规定的顺序执行。\n\n封闭性：程序一旦开始执行，其计算结果不受外界因素的影响\n\n\n -可再现性：程序执行的结果与它的执行速度无关(即与时间无关)，而只与初始条件有关。\n程序并发执行的特征\n间断(异步)性：“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；\n\n失去封闭性：共享资源，受其他程序的控制逻辑的影响。如：一个程序写到存储器中的数据可能被另一个程序修改，失去原有的不变特征。\n\n失去可再现性：失去封闭性 -&gt; 失去可再现性；外界环境在程序的两次执行期间发生变化，失去原有的可重复特征。并发程序执行的结果与其执行的相对速度有关，是不确定的\n\n\n进程的描述进程的定义与特征进程的引入：为了使多道程序能够并发执行，且为了能对并发执行程序加以描述和控制,以提高资源利用率和系统效率。\n进程的定义\n进程是具有独立功能的程序关于某个数据集合在计算机系统中的一次执行过程。是系统进行资源分配和调度的一个单位\n\n系统进行资源分配和调度的、一个可并发执行的独立单位。\n\n进程是程序的一个实例，是程序的一次执行\n\n\n进程和程序的比较\n程序是静态的，在外存中，进程是动态的，在内存中\n\n程序可长期保存；而进程是有生命周期的。\n\n程序是指令的有序集合；而进程则是由程序、数据和进程控制块三部分组成。\n\n进程和程序之间不是一一对应的：一个进程可以执行一个或多个程序，一个程序可以同时被多个进程执行。\n\n进程是一个独立运行的单位，也是系统进行资源分配和调度的独立单位，能与其他进程并发执行；而程序不能并发执行。\n\n\n进程的特征\n结构特征：由程序段、数据段及进程控制块（PCB）三部分构成，总称“进程映像”。进程控制块(PCB) + 程序 + 数据 &#x3D; 进程实体\n\n动态性：进程的实质是程序的一次执行过程，因而是动态的；进程具有生命周期。\n\n并发性：多个进程可以并发地执行。\n\n独立性：独立运行，独立获得资源。\n\n异步性：间断性。\n\n\n进程的基本状态与转换三种基本状态及其转换一个进程从创建、运行至消亡的整个生命周期，可以用一组状态加以刻画。\n一般来说,进程在执行过程中至少经历三种不同的进程状态：\n  运行态（running）：占有处理机正在运行。\n  就绪态（ready）：具备运行条件，等待系统分配处理机以便运行。\n  阻塞态（blocked）：不具备运行条件，正在等待某个事件的发生\n三种基本状态的转换\n\n创建状态和终止状态\n创建状态:\n\n为一个新进程创建PCB，并填写必要的管理信息；\n\n分配必要的资源，再把该进程转入就绪状态并插入就绪队列\n\n\n终止状态：\n\n等待操作系统进行善后处理；\n\n将其PCB清零，并将PCB空间返回系统\n\n\n挂起操作和进程状态的转换当该操作作用于某个进程时，该进程将被挂起，这意味这此时进程处于静止状态。\n挂起操作的引入：\n\n终端用户的请求\n\n父进程请求\n\n负荷调节的需要\n\n操作系统的需要\n\n\n\n若原本处于就绪状态，则挂起后不接受调度\n阻塞变就绪需要释放资源，反过来就是请求资源\n静止变活动需要激活，反之就是挂起\n进程管理中的数据结构OS中用于管理资源和控制进程的数据结构\nOS管理的这些控制表一般可以分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，进程表又称为PCB。\nPCB的作用PCB的作用：\n​\t\t为了便于系统描述和管理进程的运行，在os的核心位每个进程定义了一个数据结构—PCB作为进程实体的一部分\n​\t\tPCB记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息\nPCB的作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位\n\n作为独立运行基本单位的标志。\n当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位了，即具有了取得OS服务的权利。\n系统是通过PCB来感知进程的存在的。也就是说，PCB已成为进程存在于系统中的唯一标志。\n\n实现间断性运行方式。\n系统就可以将CPU现场信息保存在被中断进程的PCB中，供该进程再次被调度运行而须恢复CPU现场信息时使用。\n\n提供进程管理所需要的信息。\n在进程的整个生命期中，OS总是根据PCB来实施对进程的控制和管理的\n\n提供进程调度所需要的信息。\n\n实现与其他进程的同步与通信。\n\n\nPCB中的信息PCB中的信息：\n\n进程标识符PID\n进程标识符用于唯一地标志一个进程。一个进程通常有两种标识符。\n\n\n\n外部标识符。为了方便用户（进程）对进程的访问\n\n内部标识符。为了方便系统对进程的使用\n\n\n\n处理机状态\n处理机状态信息，也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。\n\n\n\n通用寄存器，可被用户程序访问，用于暂存信息\n\n指令计数器，其中存放了要访问的下一条指令的地址；\n\n程序状态字寄存器，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；\n\n用户栈指针寄存器，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放进程和系统的调用参数及调用地址。\n\n\n\n进程调度信息\nOS在进行进程调度时，必须了解进程的状态以及有关进程调度的信息，这些信息包括：\n\n\n\n进程状态，指明进程的当前状态，作为进程调度和对换时的依据；\n\n进程优先级，描述进程使用处理机的优先级别（用一个整数表示），优先级高的进程应优先获得处理机；\n\n进程调度所需要的其他信息，如进程已等待CPU的时间总和、进程已执行时间总和等，它们与所采用的进程调度算法有关；\n\n事件，指进程由执行状态转换为阻塞状态所等待发生的事件，即阻塞原因。\n\n\n\n进程控制信息\n进程控制信息是指用于进程控制所必需的信息，包括：\n\n\n\n程序和数据的地址，即进程中程序和数据的内存或外存起始地址，便于再调度到该进程执行时，能从PCB中快速找到其程序和数据；\n\n进程同步和通信机制，这是实现进程同步和进程通信时所必需的机制，如消息队列指针、信号量等，它们可能会全部或部分放在PCB中；\n\n资源清单，在该清单中列出了进程在运行期间所需的全部资源（除CPU外）；\n\n链接指针，它给出了本进程所在队列中的下一个进程的PCB的始址。\n\n\nPCB的组成方式\n线性方式。将系统中所有的PCB都组织在一张线性表中，将该表的起始地址存放在内存的一个专用区域中。该方式实现简单且开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。\n\n链接方式。通过PCB中的链接字，将具有相同状态的进程的PCB分别链接成一个队列。\n\n索引方式。系统根据所有进程状态的不同，建立几张索引表，如就绪索引表、阻塞索引表等，并把各索引表在内存中的起始地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。\n\n\n进程控制进程控制是进程管理中最基本的功能，其负责创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、转换运行中进程的状态等，进程控制就是要实现进程状态转换\n进程控制一般是由OS内核中的原语（原子性操作，一旦开始不能停止）实现的\nOS内核主要功能OS内核：\n\n支撑功能\n\n中断处理：最基本功能\n时钟管理：\n原语操作\n\n\n资源管理功能\n\n\n进程的创建进程的层次结构：\n在OS中，允许一个进程创建另一个进程，子进程可以继续创建其自己的子进程（即父进程的孙进程），由此便形成了进程的层次结构\n引起进程创建的事件\n\n用户登录：在分时系统中，若登录成功，则系统将会为该用户创建一个进程，并把它插入就绪队列中。\n\n作业调度：在多道批处理系统中，当作业调度程序按一定的算法调度到某个（或某些）作业时，便会将它（们）装入内存、为它（们）创建进程，并把它（们）插入就绪队列中。\n\n提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来为用户提供其所需要的服务\n\n应用请求：由用户进程自己创建新进程，以使新进程以同创建进程并发执行的方式完成特定任务。\n\n\n操作系统发现要求创建新进程的事件后，调用进程创建原语Creat()创建新进程。\n进程的创建过程：\n申请空白PCB     为新进程分配资源   初始化进程控制块      将新进程插入就绪队列\n进程的终止引起进程终止的事件\n（1）正常结束\n（2）异常结束\n（3）外界干预\n终止过程：\n①PCB集合中检索出该进程的PCB：并从该进程的PCB中读出该进程的状态\n②若被终止进程正处于执行状态，立即剥夺CPU\n③终止其所有子孙进程：以防止它们成为不可控的进程；\n④将被终止的进程所拥有的全部资源，或归还给其父进程，或归还给系统；\n⑤将被终止进程的PCB从所在队列（或链表）中移出：等待其他程序来搜集信息\n进程的阻塞与唤醒引起进程阻塞与唤醒的事件\n向系统请求共享资源失败\n\n等待某种操作的完成\n\n新数据尚未到达\n\n等待新任务的到达\n\n\n阻塞过程：\n调用阻塞原语block阻塞自己；\n\n将PCB中的状态改为阻塞，并加入阻塞队列；\n\n转调度程序进行重新调度\n\n\n进程的唤醒：\n调用wakeup原语唤醒等待该事件的进程\n\n阻塞进程从等待该事件的阻塞队列中移出；\n\n置进程状态为就绪态，将PCB插入到就绪队列中\n\n\n进程的挂起与激活进程的挂起过程：当出现引起进程挂起的事件时，系统利用挂起原语suspend将指定进程或处于阻塞的进程挂起。\n先检查被挂起进程的状态：\n\n若处于活动就绪，则改为静止就绪\n若处于活动阻塞，则改为静止阻塞；\n若挂起的进程正在执行，则重新进行进程调度\n\n进程的激活过程：\n当发生激活进程的事件时，系统利用激活原语active将指定进程激活\n\n激活原语先将进程从外存调入内存；\n\n然后检查该进程的状态：\n\n若为静止就绪，则改为活动就绪；\n若处于静止阻塞，则改为活动阻塞\n\n\n\n","categories":["计算机理论","操作系统"],"tags":["实用知识","计算机理论知识","操作系统"]},{"title":"洛谷P1631序列合并Java题解","url":"/posts/48002.html","content":"\n\n题目分析给定两个长度为 $N$ 的有序数组 $A &#x3D; \\{a_1, a_2, \\ldots, a_N\\}$ 和 $B &#x3D; \\{b_1, b_2, \\ldots, b_N\\}$，求所有 $a_i + b_j$ 组合中的前 $N$ 个最小和。\n思路开个 N^2 大小的数组，直接计算所有 $N^2$ 个和并排序的时间复杂度为 $O(N^2 \\log N)$，这在 $N \\leq 10^5$ 时显然不可行。\n有序数组存在特性：数组 $A$ 和 $B$ 已分别按升序排列，因此对于固定的 $a_i$，$a_i + b_j$ 的值随 $j$ 增大而单调递增。\n考虑使用堆，观察题中的两个数组： [ a 1 , a 2 , … , a N ] ， [ b 1 , b 2 , … , b N ]，对这两个数组分别从小到大排序，变成两个有序队列。这样，从A和B中各任取一个数相加得到N^2个和，可以把这些和看成形成了n个有序表&#x2F;队列：\n 考虑多路归并： 将每个 $a_i$ 与 $B$ 数组相加得到的序列视为一个有序队列，则总共有 $N$ 个有序队列：$$\\begin{aligned}   Q_1 &amp;: a_1 + b_1,\\ a_1 + b_2,\\ \\ldots,\\ a_1 + b_N \\   Q_2 &amp;: a_2 + b_1,\\ a_2 + b_2,\\ \\ldots,\\ a_2 + b_N \\   &amp;\\vdots \\   Q_N &amp;: a_N + b_1,\\ a_N + b_2,\\ \\ldots,\\ a_N + b_N \\   \\end{aligned}$$我们的目标是合并这些队列，找到前 $N$ 小的元素。\n由所有的 a i + b j  便可以组成以下 N 个偏序集:\n\n\n显然，在这 N 个偏序集中，都能够保证是有序的（单调递增）\n因此，对每个单独的偏序集而言，其始终满足：ai + bj &lt;&#x3D; ai + b(j+1)\n同时，可断言 a 1 + b 1 为所有 a i + b j  组合中的最小值； a N + b N 为所有 a i + b j 组合中的最大值；\n所以，我们就能在 O(1)  的时间复杂度内，从构建好的偏序集中取出当前最小值\n使用最小堆维护当前所有队列的队首元素。每次取出堆顶元素（当前最小值），并将该元素所在队列的下一个元素加入堆中。\n建堆和取值策略如下：\n\n把每个偏序集中的最小元素加入到小根堆 heap 中，即 heap &#x3D; {a1+b1,a2+b1,…,aN+b1} ；\n从小根堆 h e a p heap heap 中取出根元素（即当前堆里的最小值），假设取出的元素为 a i + b j，记弹出数 +1；\n从取出元素所在的偏序集中，取出仅比此小的元素，ai + b (j+1)，将其插入到小根堆 heap 中\n若弹出数不为  N，则继续执行 2；否则结束取值\n\n\n初始化堆将每个队列的第一个元素（即 $a_i + b_1$）加入堆，记录对应的 $i$ 和当前 $b$ 的索引 $j&#x3D;1$。\n\n迭代取最小值重复 $N$ 次：\n\n取出堆顶元素 $a_i + b_j$，加入结果集。\n若 $j+1 \\leq N$，将 $a_i + b_{j+1}$ 加入堆中，并更新索引为 $j+1$。\n\n\n去重与边界处理使用三元组 $(sum, i, j)$ 存储堆元素，确保同一队列中不同位置的元素能被正确追踪。\n\n\n复杂度分析\n\n时间复杂度：$O(N \\log N)$，每次堆操作的时间为 $O(\\log N)$，共进行 $O(N)$ 次。\n空间复杂度：$O(N)$，堆中最多存储 $N$ 个元素。\n\nimport java.util.Arrays;import java.util.PriorityQueue;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n];        int[] b = new int[n];        // 读取输入数据        for (int i = 0; i &lt; n; i++) &#123;            a[i] = sc.nextInt();        &#125;        for (int i = 0; i &lt; n; i++) &#123;            b[i] = sc.nextInt();        &#125;        sc.close();        // 对数组排序        Arrays.sort(a);        Arrays.sort(b);        // 使用优先队列（小根堆）        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((x, y) -&gt; x[0] - y[0]);        // 初始化堆：将每个a[i]与b[0]的和加入堆        for (int i = 0; i &lt; n; i++) &#123;            pq.offer(new int[]&#123;a[i] + b[0], i, 0&#125;);        &#125;        // 查找前 n 小的值        StringBuilder sb = new StringBuilder();        while(n-- &gt; 0)&#123;            int[] curr = pq.poll();            int sum = curr[0];            int aIdx = curr[1];            int bIdx = curr[2];            sb.append(sum).append(&quot; &quot;);            // 如果当前b索引+1有效，则将下一个和加入堆            if (bIdx + 1 &lt; b.length) &#123;                pq.offer(new int[]&#123;a[aIdx] + b[bIdx + 1], aIdx, bIdx + 1&#125;);            &#125;        &#125;        System.out.println(sb.toString().trim());    &#125;&#125;\n\nAC:\n\n\n","categories":["算法类","题解"],"tags":["算法","题解","洛谷","数据结构"]},{"title":"第十五届蓝桥杯Java国赛B组D题-园丁","url":"/posts/12811.html","content":"\n题目大意题目的核心是要处理一棵树上每个节点的权值，对于拥有两个及以上儿子节点的父节点，要保证所有儿子节点的权值两两相乘不能是完全平方数，目标是求出最少需要修改多少个节点的权值，才能让整棵树满足这个条件。\n思路完全平方数的判定首先什么是完美平方数，如果一个正整数 $a$ 是某一个整数 $b$ 的平方，那么这个正整数 $a$ 叫做完全平方数。零也可称为完全平方数。\n两个数 $x$ 和 $y$ 的乘积是完全平方数，当且仅当 $x$ 与 $y$ 的乘积中，所有质因子的幂次都是偶数。\n例如 $4 * 9 &#x3D; 36$ 是完全平方数，因为 $4 &#x3D; 2 ^ 2，9 &#x3D; 3 ^ 2$ ，他们的质因子的幂次都是偶数。\n进一步推导，这个条件等价于 $x$ 和 $y$ 的 “平方因子化简后” 的形式相同。所谓 “平方因子化简”，就是对每个数 a 分解质因数后，只保留每个质因数的奇数次幂（即 $a_i$ 的“平方自由部分”），这部分记作 $f(a_i)$。\n若  $f(a_i) &#x3D; f(a_j)$  ，那么  $a_i * a_j$  必然是完全平方数。\n代码处理使用邻接表存树，如果存在两个儿子节点的 $f(a_j)$ 相等，那么这两个儿子节点权值的乘积就是完全平方数，不满足题目要求。\n贪心处理：\n对每个有 $k\\geq 2$ 个儿子的结点 $i$，统计其所有儿子的 $f(a_j)$，对于重复的 $f(a_j)$，需要修改其中 $cnt-1$ 个结点的权值（$cnt$ 为该 $f(a_j)$ 出现次数）。对每个结点，累加需要修改的次数。\n关于squareFree(int x) — 求平方自由部分:我们需要只保留不能被2整除的幂次部分，所以按照如下形式解耦出平方自由部分\nprivate int squareFree(int x) &#123;    int res = 1;    for (int i = 2; i * i &lt;= x; i++) &#123; // 枚举所有可能的质因数        int cnt = 0;        while (x % i == 0) &#123; // 统计i作为质因子的次数            x /= i;            cnt++;        &#125;        if ((cnt &amp; 1) == 1) res *= i; // 只保留奇数次的质因数    &#125;    if (x &gt; 1) res *= x; // x本身是大于1的质数    return res;&#125;\n\n完整代码如下\n//package 数学.subject.P12255_蓝桥杯2024国JavaB_园丁;import java.util.*;import java.io.*;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        new Solutions2();    &#125;&#125;class Solutions2&#123;    private int n;    private int[] a;    private int[] f;    private List&lt;Integer&gt;[] tree;    private int ans = 0;    private int squareFree(int x) &#123;        int res = 1;        for (int i = 2; i * i &lt;= x; i++) &#123;            if (x % i == 0) &#123;                int cnt = 0;                while (x % i == 0) &#123;                    x /= i;                    cnt++;                &#125;                if (cnt % 2 != 0) &#123;                    res *= i;                &#125;            &#125;        &#125;        if (x &gt; 1) &#123;            res *= x;        &#125;        return res;    &#125;    public Solutions2()&#123;        FastReader sc = new FastReader();        n = sc.nextInt();        a = new int[n + 1];        f = new int[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = sc.nextInt();            f[i] = squareFree(a[i]);        &#125;        tree = new ArrayList[n + 1];        for (int i = 1; i &lt;= n; i++) tree[i] = new ArrayList&lt;&gt;();        for (int i = 1; i &lt; n; i++) &#123;            int u = sc.nextInt();            int v = sc.nextInt();            tree[u].add(v);            tree[v].add(u);        &#125;        // 使用迭代的后序遍历来替代递归DFS        Deque&lt;Object[]&gt; stack = new ArrayDeque&lt;&gt;();        stack.push(new Object[]&#123;1, 0, false&#125;);        while (!stack.isEmpty()) &#123;            Object[] node = stack.pop();            int u = (Integer) node[0];            int fa = (Integer) node[1];            boolean visited = (Boolean) node[2];            if (!visited) &#123;                stack.push(new Object[]&#123;u, fa, true&#125;);                List&lt;Integer&gt; children = new ArrayList&lt;&gt;();                for (int v : tree[u]) &#123;                    if (v != fa) &#123;                        children.add(v);                    &#125;                &#125;                // 逆序压入，以保持原来的处理顺序                for (int i = children.size() - 1; i &gt;= 0; i--) &#123;                    int v = children.get(i);                    stack.push(new Object[]&#123;v, u, false&#125;);                &#125;            &#125; else &#123;                List&lt;Integer&gt; children = new ArrayList&lt;&gt;();                for (int v : tree[u]) &#123;                    if (v != fa) &#123;                        children.add(v);                    &#125;                &#125;                if (children.size() &gt;= 2) &#123;                    Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();                    for (int v : children) &#123;                        int sf = f[v];                        cnt.put(sf, cnt.getOrDefault(sf, 0) + 1);                    &#125;                    for (int c : cnt.values()) &#123;                        if (c &gt; 1) &#123;                            ans += c - 1;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(ans);    &#125;    class FastReader &#123;        BufferedReader br;        StringTokenizer st;        public FastReader() &#123;            br = new BufferedReader(new InputStreamReader(System.in));            st = new StringTokenizer(&quot;&quot;);        &#125;        String next() &#123;            while (!st.hasMoreElements()) &#123;                try &#123;                    st = new StringTokenizer(br.readLine());                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            return st.nextToken();        &#125;        int nextInt() &#123;            return Integer.parseInt(next());        &#125;    &#125;&#125;\n\n\n\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"自定义注解","url":"/posts/13512.html","content":"注解的基本结构以重写为例子了解基本结构package java.lang;import java.lang.annotation.*;/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: *  * &lt;ul&gt;&lt;li&gt; * The method does override or implement a method declared in a * supertype. * &lt;/li&gt;&lt;li&gt; * The method has a signature that is override-equivalent to that of * any public method declared in &#123;@linkplain Object&#125;. * &lt;/li&gt;&lt;/ul&gt; *  * @author  Peter von der Ah&amp;eacute; * @author  Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;\n\n注解的名称：\npublic @interface Override &#123;&#125;\n\n注解的元注解\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)\n\n这两个注解是注解中用到最多的元注解\n总结：\n注解分为两部分 :\n\n元注解 ;\n\npublic @interface 注解名称 ;\n\n\n注解的本质按照 public @interface 注解名称 格式 , 写出一个注解 , 编译该注解代码生成 Annotation.class 字节码文件 ;\npublic @interface Annotation &#123;&#125;\n\n使用 javap 命令反编译 Annotation.class 字节码文件 , 查看该注解的实际代码 ;\n发现输出\npublic interface Annotation extends java.lang.annotation.Annotation &#123;&#125;\n\n所以说，注解的本质是一个 interface 接口 , 注解接口默认继承了 java.lang.annotation.Annotation 接口 ;\n有如下关键特性：\n\n注解接口隐式继承Annotation接口\n不能显式实现其他接口\n不能包含泛型参数\n不能抛出异常\n\n注解的属性注解的属性注解的本质是接口 , 接口中可以定义 常量 和 方法 ;\n在注解中定义 接口方法 , 就是 注解的属性 ;\n为注解添加属性 : 接口中的方法都是抽象方法 , 其中 public abstract 可以省略 ;\npublic @interface Annotation &#123;    public abstract String path();   // Annotation接口 实现的接口 Annotation 中定义的注解属性(抽象方法)&#125;\n\n使用\n@注解名称(属性名称 = 属性值)\n\n@Annotation(path = &quot;&quot;)Student(String name, int age)&#123;&#125;\n\n属性定义规则\npublic @interface RequestMapping &#123;    String path();                // 必需属性    String method() default &quot;GET&quot;;// 可选属性    String[] params() default &#123;&#125;; // 数组属性&#125;\n\n\n\n\n\n注解的属性类型注解中定义了属性 , 在使用注解时 , 需要 给 注解属性 赋值 ;\n定义 注解属性 时 , 可以 使用 default 关键字 指定属性默认值 \nint intValue() default 666;   // 制定 注解属性 intValue 值类型为 int 整型 , 默认值 666 \n\n\n如果 注解属性 指定了默认值 , 在使用注解时 , 可以选择 不为该属性赋值 ( 此时使用默认属性值 ) , 也可以进行赋值 ( 指定一个新的属性值 ) ;\n\n如果 注解属性 没有指定默认值 , 则使用 注解 时 , 必须为其指定一个默认值 , 否则编译时报错 ;\n\n\n注解属性 ( 接口方法 ) 返回值类型要求 :\n\n基本数据类型 : byte , short , int , long , float , double , char , boolean ;\n字符串类型 : String ;\n枚举类型 : enum ;\n注解类型 ;\n其他注解类型\n以上类型的数组形式 ，不允许多维数组\n\n禁止的类型：\n\n自定义对象类型\n泛型类型（如List）\nnull值（默认值不能为null）\n\n注解属性返回值必须是以上的类型 , 不能设置其它类型返回值 , 否则会报错 ;\n赋值简化操作：\n如果 注解属性 名称是 value , 并且 注解中只有 1 个属性 , 那么在使用 注解 为 注解属性 赋值时 , 可以省略注解名称 , 直接传入 注解属性值 ;\n@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;// 使用 SuppressWarnings 注解时 , 直接传入 “all” 参数 , 省略了注解属性名称 ;    @SuppressWarnings(&quot;all&quot;)    @Override    public String toString() &#123;        return super.toString();    &#125;// 注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\n\n注解属性 名称是 value , 并且 注解中只有 1 个属性, 才能使用上述简化方式\n自定义一个注解\n使用@interface来申明一个自定义注解时，他会自动继承ava.lang.annotation.Annotation接口。\n格式public @interface xxx(注解名称){定义注解参数内容}。\n\n// 1. 定义带参数的注解@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ApiVersion &#123;    String group() default &quot;default&quot;;    int[] versions();  // 必须显式赋值&#125;// 2. 使用注解@ApiVersion(group = &quot;user&quot;, versions = &#123;1, 2&#125;)public class UserController &#123;    @ApiVersion(versions = &#123;2&#125;) // 使用默认group    public void updateUser() &#123;...&#125;&#125;// 3. 通过反射处理注解Class&lt;UserController&gt; clazz = UserController.class;ApiVersion classAnnotation = clazz.getAnnotation(ApiVersion.class);if (classAnnotation != null) &#123;    System.out.println(&quot;Supported versions: &quot; +         Arrays.toString(classAnnotation.versions()));&#125;\n\n如果是注解有参数，需要在注解里面添加参数类型\n参数格式： 类型 + 名称();\n加了参数后，使用注解如果不添加参数的话会报错，除非添加默认值\n参数设计建议\n\n当只有一个参数时，建议命名为value\n数组参数建议提供空数组默认值（default &#123;&#125;）\n复杂参数使用注解嵌套：\n\n\n如果只有一个参数可以直接使用value命名，这样在使用注解的时候可以省略’名称&#x3D;“xx”’直接赋值\n注解的使用自定义注解的使用需要用到反射的原理\n//作用于类@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface ClassAnno&#123;    String value();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoName&#123;    String name();&#125;//作用属性@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface FiledAnnoAge&#123;    int age();&#125;public class CustomAnnotationExample &#123;    public static void main(String[] args) &#123;        // 获取类的注解信息        Class&lt;Person&gt; personClass = Person.class;   // 反射获取        if (personClass.isAnnotationPresent(ClassAnno.class)) &#123;            // 取出Annotation注解信息            ClassAnno classAnno = personClass.getAnnotation(ClassAnno.class);            System.out.println(&quot;类注解信息: &quot; + classAnno.value());        &#125;        // 获取属性的注解信息        // 需要注意的是，类是默认缺省的，是有访问权限的。而name和age是私有private的，无法直接获取到Filed对象，需要使用getDeclaredField以及getDeclaredAnnotation获取        Field[] fields = personClass.getDeclaredFields();  // getDeclaredFields()反射获取        for (Field field : fields) &#123;            if (field.isAnnotationPresent(FiledAnnoName.class)) &#123;                // 使用反射获取Student注解信息annotations 可以获取到注解里面的值是多少                FiledAnnoName filedAnnoName = field.getAnnotation(FiledAnnoName.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoName.name());            &#125;            if (field.isAnnotationPresent(FiledAnnoAge.class)) &#123;                FiledAnnoAge filedAnnoAge = field.getAnnotation(FiledAnnoAge.class);                System.out.println(&quot;属性 &quot; + field.getName() + &quot; 的注解信息: &quot; + filedAnnoAge.age());            &#125;        &#125;    &#125;\n\n\n\n\n\n\n\n引用\n【Java 注解】自定义注解 ( 注解属性定义与赋值 )\njava如何优雅的自定义一个注解？\n","categories":["Java学习","JavaSE"],"tags":["Java技术","JavaSE","语言方面","学习"]},{"title":"蓝桥杯2025Python省BF题园艺题解","url":"/posts/20727.html","content":"洛谷上的题目markdown\nP12175 [蓝桥杯 2025 省 Python B] 园艺\n题目描述小蓝从左到右种了 $n$ 棵小树，第 $i$ 棵树的高度为 $h_i$，相邻树的间隔相同。小蓝想挪走一些树使得剩下的树等间隔分布，且从左到右高度逐渐上升（相邻两棵树高度满足右边的比左边的高），小蓝想知道最多能留下多少棵树。\n输入格式输入的第一行包含一个正整数 $n$。\n第二行包含 $n$ 个正整数 $h_1, h_2, \\cdots, h_n$，相邻整数之间使用一个空格分隔。\n输出格式输出一行包含一个整数表示答案。\n输入输出样例输入 #163 5 4 7 6 7\n\n输出 #13\n\n说明&#x2F;提示样例说明留下第 1、3、5 棵树，它们等间隔且从左到右高度逐渐上升。\n评测用例规模与约定\n对于 $30%$ 的评测用例，$1 \\leq n \\leq 500$；\n对于 $60%$ 的评测用例，$1 \\leq n \\leq 3000$；\n对于所有评测用例，$1 \\leq n \\leq 5000$，$0 &lt; h_i &lt; 10^6$。\n\n\n问题概述题目要求我们在一排树中选出尽可能多的树，满足两个条件：\n\n选出的树必须是等间隔分布的\n选出的树的高度必须严格递增\n\n思路可以发现类似 最长下降子序列 的问题\n考虑 dp ，对于每棵树 i ，检查它前面所有的树 j ，如果树 j 的高度小于树 i 的高度，计算它们之间的间隔 diff\ndp[i][d]表示以第 i 棵树结尾，间隔为 d 的最长子序列长度\n记录以树 i 结尾、间隔为 diff 的最长子序列长度\n代码package 动态规划.subject.线性dp.P12175_蓝桥杯2025_省_PythonB_园艺;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // 初始化输入        Scanner sc = new Scanner(System.in);        int n = sc.nextInt(); // 读取树的总数        int[] tree = new int[n]; // 存储每棵树的高度                // 读取每棵树的高度        for (int i = 0; i &lt; n; i++) &#123;            tree[i] = sc.nextInt();        &#125;        // 动态规划数组        // dp[i][d]表示以第i棵树结尾，间隔为d的最长子序列长度        int[][] dp = new int[n][n];                // 初始最大值设为1，因为至少可以选择一棵树        int max = 1;        // 初始化：每棵树可以单独形成一个子序列        // dp[i][0]表示间隔为0的情况（即只选这一棵树）        for (int i = 0; i &lt; n; i++) &#123;            dp[i][0] = 1;        &#125;        // 动态规划主过程        for (int i = 0; i &lt; n; i++) &#123; // 遍历每棵树作为结尾            for (int j = 0; j &lt; i; j++) &#123; // 检查前面的所有树                // 只有当当前树比前面的树高时才考虑                if (tree[j] &lt; tree[i]) &#123;                    // 计算两棵树之间的间隔                    int diff = i - j;                                        // 获取以树j结尾、间隔为diff的最长子序列长度                    int prev = dp[j][diff];                                        // 如果prev为0，说明树j是单独存在的                    // 此时可以形成一个长度为2的子序列（树j和树i）                    if (prev == 0) &#123;                        prev = 1;                    &#125;                                        // 如果发现更长的子序列，就更新                    if (dp[i][diff] &lt; prev + 1) &#123;                        dp[i][diff] = prev + 1;                                                // 更新全局最大值                        if (dp[i][diff] &gt; max) &#123;                            max = dp[i][diff];                        &#125;                    &#125;                &#125;            &#125;        &#125;        // 输出结果        System.out.println(max);                // 关闭Scanner        sc.close();    &#125;&#125;\n\n因为是 python 组的题目，所以这里放一下python的代码\ndef main():    import sys    input = sys.stdin.read        # 读取输入数据    data = input().split()    n = int(data[0])    tree = list(map(int, data[1:n+1]))        # 初始化动态规划数组    # dp[i][d] 表示以第i棵树结尾，间隔为d的最长子序列长度    dp = [[0] * n for _ in range(n)]    max_len = 1  # 至少可以选一棵树        # 初始化：每棵树可以单独形成一个子序列    for i in range(n):        dp[i][0] = 1        # 动态规划主过程    for i in range(n):  # 遍历每棵树作为结尾        for j in range(i):  # 检查前面的所有树            if tree[j] &lt; tree[i]:  # 只有当前树比前面的树高时才考虑                diff = i - j  # 计算间隔                                # 获取以树j结尾、间隔为diff的最长子序列长度                prev = dp[j][diff]                                # 如果prev为0，说明树j是单独存在的                # 此时可以形成一个长度为2的子序列（树j和树i）                if prev == 0:                    prev = 1                                # 如果发现更长的子序列，就更新                if dp[i][diff] &lt; prev + 1:                    dp[i][diff] = prev + 1                                        # 更新全局最大值                    if dp[i][diff] &gt; max_len:                        max_len = dp[i][diff]        # 输出结果    print(max_len)if __name__ == &quot;__main__&quot;:    main()\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯2025Python省赛B组题解","url":"/posts/5125.html","content":"A. 攻击次数\n\n这题有歧义，如果考虑三个英雄一起上，就是103，考虑一回合只能上一个伤害高的，就是181\n// 一起上的情况public class Main &#123;    public static void main(String[] args) &#123;        // 能一起上就一起上，不能一起上，就上攻击力高的        int hp = 2025;        int cnt = 0;        while(hp &gt; 0)&#123;            cnt++;            int hero1 = 5;   // 英雄 1 的固定伤害            int hero2 = (cnt % 2 == 1) ? 15 : 2;   // 英雄 2 的回合机制伤害            int hero3 = 0;            if(cnt % 3 == 1)&#123;                hero3 = 2;            &#125;else if(cnt % 3 == 2)&#123;                hero3 = 10;            &#125;else if(cnt % 3 == 0)&#123;                hero3 = 7;            &#125;            hp -= hero1 + hero2 + hero3;        &#125;        System.out.println(cnt);    &#125;&#125;\n\n# 不一起上的情况# 挑攻击力大的技能使用即可# 可见：奇数一定使用第二个英雄的技能，然后偶数情况的话模3余1用第一个英雄技能，其他情况用第三个英雄的技能。n = 0i = 1while n &lt; 2025:    if i &amp; 1:        n += 15    else:        if i % 3 == 2:            n += 10        elif i % 3 == 0:            n += 7        else:            n += 5    i += 1print(i - 1)\n\n\nB. 最长字符串\n\n下载附件 words.txt\n优美字符串的定义是：字符串本身存在于给定的单词列表中，并且可以通过调整顺序后由另一个更短的优美字符串扩展而来。\n考的主要是文件读写，默认把 txt 附件存在和代码同级别的目录下\npackage 基础算法和其他.IO读写流.P12171_蓝桥杯_2025_省_Python_B_最长字符串;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        //  读取 words.txt 文件中的单词        List&lt;String&gt; words = new ArrayList&lt;&gt;();        try(BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\\\WorkSpace\\\\JavaDemo\\\\IDEA\\\\Algorithm\\\\src\\\\字符串\\\\subject\\\\P12171_蓝桥杯2025省PythonB最长字符串\\\\words.txt&quot;)))&#123;            String line;            while ((line = br.readLine()) != null) &#123;                words.add(line.trim());            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;        // 按长度升序、字典序升序排序（确保处理顺序正确）        words.sort(Comparator.comparingInt(String::length).thenComparing(Comparator.naturalOrder()));        Set&lt;String&gt; bs = new HashSet&lt;&gt;();        // 动态规划：判断每个单词是否是优美字符串        for(String word : words)&#123;            if(word.length() == 1)&#123;                bs.add(word);            &#125;else&#123;                // 如果 前n-1 位的长度的字符串，我们把其和要对比的字符串按一定规律重组，那么两者就是一样的了                String pre = sortString(word.substring(0, word.length() - 1));                for(String sbs: bs)&#123;                    if(sortString(sbs).equals(pre))&#123;                        bs.add(word);                        break;                    &#125;                &#125;            &#125;        &#125;        // 找到最长的优美字符串        int maxLength = 0;        for (String word : bs) &#123;            maxLength = Math.max(maxLength, word.length());        &#125;        List&lt;String&gt; ls = new ArrayList&lt;&gt;();        for (String word : bs) &#123;            if (word.length() == maxLength) &#123;                ls.add(word);            &#125;        &#125;        // 输出字典序最小的结果        ls.sort(Comparator.naturalOrder());        System.out.println(ls.get(0));        // System.out.println(&quot;afplcu&quot;);    &#125;    // 字符串按字母字典序重组    private static String sortString(String s) &#123;        char[] charArray = s.toCharArray();        Arrays.sort(charArray);        return new String(charArray);    &#125;&#125;\n\n# 读取 words.txt 文件中的单词with open(&quot;words.txt&quot;, &quot;r&quot;) as f:    ws = [line.strip() for line in f]# 按长度和字典序排序ws.sort(key=lambda x: (len(x), x))# 初始化优美字符串集合bs = set()# 动态规划：判断每个单词是否是优美字符串for w in ws:    if len(w) == 1:        bs.add(w)    else:        pre = &#x27;&#x27;.join(sorted(w[:-1]))        if any(&#x27;&#x27;.join(sorted(s)) == pre for s in bs):            bs.add(w)# 找到最长的优美字符串ml = max(len(w) for w in bs)lbs = [w for w in bs if len(w) == ml]# 输出字典序最小的结果print(min(lbs))\n\n\n\n\nC. LQ图形\n\n\n\n观察可发现，可以将L分为上下两个部分，上面列数少的为h行，下面列数多的为w行，上下宽度分别为w和v+w。时间复杂度O(h + w)\n//package 基础算法和其他.模拟.P12172_蓝桥杯2025省PythonB_LQ图形;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int w = sc.nextInt();        int h = sc.nextInt();        int v = sc.nextInt();        // 先是h高w宽的Q，然后是w高v+w宽        StringBuilder sb1 = new StringBuilder();        StringBuilder sb2 = new StringBuilder();        for(int i = 1; i &lt;= w; i++) sb1.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= v + w; i++) sb2.append(&#x27;Q&#x27;);        for(int i = 1; i &lt;= h; i++) System.out.println(sb1);        for(int i = 1; i &lt;= w; i++) System.out.println(sb2);    &#125;&#125;\n\nw,h,v = MII()t = hb = wfor i in range(t):    print(&#x27;Q&#x27; * w)for i in range(b):    print(&#x27;Q&#x27; * (v + w))\n\n\nD. 最多次数\n\n贪心，遇到连续的三个某个顺序的 l,q,b, 就把他拿掉。时间复杂度O(n)\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        // lqb lbq qbl qlb blq bql 可以发现题目给出的是全排列        // 遇到连续的 lqb 三个字母拿掉就行        Scanner sc = new Scanner(System.in);        String str = sc.nextLine();        String[] strs = &#123;&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;&#125;;        int res = 0, index = 0;        for(int i = 0; i &lt; str.length() - 2; i++)&#123;   // 注意防止越界            String sub = str.substring(i, i + 3);            for(int j = 0; j &lt; 6; j++)&#123;                if(sub.equals(strs[j]))&#123;                    i += 2;   // 不判断中间的内容了                    res++;                    break;                &#125;            &#125;        &#125;        System.out.println(res);        sc.close();    &#125;&#125;\n\nstr_input = input()strs = [&quot;lqb&quot;, &quot;lbq&quot;, &quot;qlb&quot;, &quot;qbl&quot;, &quot;blq&quot;, &quot;bql&quot;]res = 0i = 0while i &lt; len(str_input) - 2:    sub = str_input[i:i + 3]    for j in range(6):        if sub == strs[j]:            i += 2            res += 1            break    i += 1print(res)\n\n\nE. A*B Problem\n\n给定 n，求四元组 (a,b,c,d) 个数，满足 a×b+c×d≤n，且 a,b,c,d 都是正整数。\n我们需要枚举所有可能的向量 A 和 B，使得它们的内积不超过 L。\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int L = scanner.nextInt();        int count = 0;        // 枚举所有可能的 (XA, YA) 和 (XB, YB)        for (int XA = 1; XA &lt;= L; XA++) &#123;            for (int YA = 1; YA &lt;= L; YA++) &#123;                for (int XB = 1; XB &lt;= L / XA + 1; XB++) &#123;                    for (int YB = 1; YB &lt;= (L - XA * XB) / YA + 1; YB++) &#123;                        if (XA * XB + YA * YB &lt;= L) &#123;                            count++;                        &#125;                    &#125;                &#125;            &#125;        &#125;        System.out.println(count);    &#125;&#125;\n\n不行，只有80分，考虑优化\n将四元组 (a,b,c,d) 的问题转化为两个部分：x&#x3D;a×b和 y&#x3D;c×d，使得 x+y≤n。\n这样，问题转化为统计所有满足 x+y≤n 的正整数对 (x,y) 的数量，其中 x 和 y 都可以表示为两个正整数的乘积。\n这样对于满足 x+y&#x3D;k 的四元组个数就是 tx×ty。\n考虑每个数 i，预处理其能表示为两个正整数乘积的方式数 t[i]（即 i 的因数对数）。把 x 打表打出来\n使用线性筛法预处理每个数的因数个数，计算 t[i]。\n计算 t[i] 的前缀和数组 s[i]，用于快速查询 y≤n−x 时的 t[y] 的总和。\n对于每个 x，其贡献为 t[x]×s[n−x]\n为什么求 t[y] 要使用前缀和数组，对于每个固定的 x，我们需要找到所有满足 y≤n−x 的 y 的数量，也就是 ∑y&#x3D;1n−x​t[y]\npackage 数学.subject.P12174_蓝桥杯2025省Python_B_AxBProblem;import java.util.Arrays;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int l = sc.nextInt();        int[] t = new int[l + 1];        Arrays.fill(t, 0);        // 枚举所有可能的 (a,b)组合，并统计每个乘积的出现次数，打表出四元组的前两部分乘积        for (int a = 1; a &lt;= l; a++) &#123;            for(int b = 1; a * b &lt;= l; b++)&#123;                t[a * b]++;            &#125;        &#125;        // 前缀和        int[] s = new int[l + 1];        s[0] = 0;        for (int i = 1; i &lt;= l; i++) &#123;            s[i] = s[i - 1] + t[i];        &#125;        long total = 0;        // 对于每个 x        for(int x = 1; x &lt; l; x++)&#123;            // 计算其对应的 y 的最大值 l - x            int y = l - x;            total += (long)t[x] * s[y];   // 前缀和计算        &#125;        System.out.println(total);    &#125;&#125;\n\n\nF. 园艺讲过了，在\n\nG. 书架还原\n\npackage 基础算法和其他.贪心.subject.P12176_蓝桥杯2025省PythonB_书架还原;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        int[] a = new int[n + 1];   // 书架        int[] p = new int[n + 1];   // p[x]表示书本编号现在所处的位置        int res = 0;        for(int i = 1; i &lt;= n; i++)&#123;            a[i] = sc.nextInt();            p[a[i]] = i;    // 桶记录书本a[i]的正确位置，p[a[i]] 是书本应该去的位置        &#125;        // 从第一个位置开始检查，如果当前数字不在正确位置，就找到它应该去的位置，把这两个位置的数字交换。        for(int i = 1; i &lt;= n; i++)&#123;            if(a[i] != i)&#123;   // 不在正确位置，需要调整位置                p[a[i]] = p[i];   // 把书本放到应该去的位置                ++res;                // 把正确位置p[i]上的书本和当前书本位置交换                int temp = a[p[i]];                a[p[i]] = a[i];                a[i] = temp;            &#125;        &#125;        System.out.println(res);    &#125;&#125;\n\nn = II()a = [0] + LII()p = [0] * (n + 1)res = 0for i in range(1,n + 1):    p[a[i]] = ifor i in range(1,n + 1):    if a[i] != i:        p[a[i]] = p[i]        a[i],a[p[i]] = a[p[i]],a[i]        res += 1print(res)\n\n\nH. 异或和\n\n考虑位运算，把每个数拆成二进制然后进行统计\n由于异或运算本身就是建立在位的基础上的，所以我们只需要用一层循环枚举位\n只有两个数当前位不同才能产生贡献。也就是说，如果这一位是 0，那他得跟这一位为 1 的数异或才能有贡献，所以加上这一位为 1 的数的个数再乘以这一位的权值\n如果先不考虑公式后面的 j−i，那么只有用两个变量统计每位 0 和 1 的个数。\n现在还得乘上 j−i，这个值是不断变化的，可以发现其中 i 是不变的，j 每次只加1，开两个变量存储每位 0 和 1 的权值\nimport java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        BigInteger[] arr = new BigInteger[n + 1];        for (int i = 1; i &lt;= n; i++) &#123;            arr[i] = sc.nextBigInteger();        &#125;        BigInteger res = BigInteger.ZERO;        // 只有两个数当前位不同才能产生贡献。        for (int dig = 0; dig &lt;= 20; dig++) &#123;            int[] cnt = &#123;0, 0&#125;;   // 记录当前已处理过的数中，二进制位 k 为 0 或 1 的数的个数。            BigInteger[] sum = &#123;BigInteger.ZERO, BigInteger.ZERO&#125;;   // 下标差的动态和            for (int i = 1; i &lt;= n; i++) &#123;                // 提取arr[i]的二进制中第 dig 位的值                int bit = arr[i].shiftRight(dig).and(BigInteger.ONE).intValue();                // 取出相反位的值，这样的才可以产生贡献                BigInteger multiplier = BigInteger.valueOf(1L &lt;&lt; dig);                res = res.add(sum[bit ^ 1].multiply(multiplier));                cnt[bit]++;                // 每次处理一个数时，所有之前记录的数的下标差会自然增加                sum[0] = sum[0].add(BigInteger.valueOf(cnt[0]));                sum[1] = sum[1].add(BigInteger.valueOf(cnt[1]));            &#125;        &#125;        System.out.println(res);    &#125;&#125;    \n\nn = int(input())  # 输入数组长度a = list(map(int, input().split()))  # 输入数组res = 0  # 最终结果for b in range(31):  # 遍历每一位（0到30位）    m = 1 &lt;&lt; b  # 当前位的掩码，用于提取该位的值    c = [0, 0]  # 用于统计当前位为0和1的数量    s = [0, 0]  # 用于记录当前位为0和1的索引和    cur = 0  # 当前位的贡献值    for i in range(n):  # 遍历数组中的每个元素        bit = (a[i] &gt;&gt; b) &amp; 1  # 提取当前元素在当前位的值（0或1）        cur += c[1 - bit] * i - s[1 - bit]  # 计算当前位的贡献值        c[bit] += 1  # 更新当前位的计数        s[bit] += i  # 更新当前位的索引和    res += cur * m  # 将当前位的贡献值乘以掩码，累加到最终结果print(res)  # 输出最终结果\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"蓝桥杯3月月赛F题题解","url":"/posts/46832.html","content":"「蓝桥·算法双周赛」第二十七场蓝桥月赛最后一题题解(可能是首发？？nm，真比第三题简单吧)\n(求你们看看吧我对我的码风很自信)\n问题描述 \n二分枚举时间m，然后剩下的就是根据题意纯模拟  \n注意备份和等待能不能跨天进行，这是个坑点\n细节在注释里有\npackage 蓝桥月赛第27场;import java.util.Scanner;public class F &#123;\t\tprivate static int calculateDays(int m, int[] a, int[] b) &#123;\t\t// 如果没有电脑需要备份，返回 0 天    \tif(a.length == 0) return 0;    \t    \t// 如果 M 小于第一台电脑的备份时间    \tif(m &lt; a[0]) return Integer.MAX_VALUE;    \t    \t// 第一天    \tint days = 1;    \t// 备份第一台开始算剩余时间    \tint currentRemaining = m - a[0];    \t// 第一台都备份不上？？        if (currentRemaining &lt; 0) &#123;            return Integer.MAX_VALUE;        &#125;                for (int i = 1; i &lt;= a.length; i++) &#123;        \tint wait = b[i];   // 获取前一台电脑的等待时间        \t        \t// 处理等待时间        \t// 时间足够，直接减去        \tif(currentRemaining &gt;= wait) &#123;        \t\tcurrentRemaining -= wait;        \t// 不够只能过天了，计算剩余的等待时间        \t&#125;else &#123;        \t\t// 把当天能等的给等了        \t\twait -= currentRemaining;        \t\tdays++;        \t\tcurrentRemaining = m;   // 重置剩余时间        \t\t        \t\tint fullDays = wait / m;   // 计算等几天        \t\tdays += fullDays;        \t\twait -= fullDays * m;        \t\t        \t\tif(wait &gt; 0) &#123;        \t\t\t// 减去零头        \t\t\tcurrentRemaining = m - wait;        \t\t&#125;else &#123;        \t\t\tcurrentRemaining = m;  // 重置        \t\t&#125;        \t&#125;        \t        \t        \t// 处理备份时间        \t// 今天够备份        \tif(currentRemaining &gt;= a[i]) &#123;        \t\tcurrentRemaining -= a[i];        \t&#125;else &#123;        \t\t// 今天备份不完，备份不能留到第二天        \t\tdays++;        \t\tcurrentRemaining = m - a[i];        \t\t// 不行，时间太短，备份不完        \t\tif (currentRemaining &lt; 0) &#123;        \t\t\treturn Integer.MAX_VALUE;        \t\t&#125;        \t&#125;        \t        &#125;        return days;    &#125;\t\tpublic static void main(String[] args) &#123;\t\tScanner scanner = new Scanner(System.in);\t\t\t\t// N 台电脑        int n = scanner.nextInt();        // 最多允许的天数T        int t = scanner.nextInt();        // 表示每台电脑的备份时间。        int[] a = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            a[i] = scanner.nextInt();        &#125;                // 每台电脑备份完成后需要等待的时间。        int[] b = new int[n];        for (int i = 1; i &lt;= n; i++) &#123;            b[i] = scanner.nextInt();        &#125;        scanner.close();                // 最长备份时间        int maxA = 0;        for(int ai: a) &#123;        \tif (ai &gt; maxA) &#123;                maxA = ai;            &#125;        &#125;                if (maxA &gt; 3600) &#123;            System.out.println(-1);            return;        &#125;                // 开始二分 枚举m        int left = maxA;        int right = 3600;        int result = -1;                while(left &lt;= right) &#123;        \tint mid = (left + right) / 2;        \tint days = calculateDays(mid, a, b);        \tif (days &lt;= t) &#123;                result = mid;                right = mid - 1;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;                System.out.println(result != -1 ? result : -1);\t&#125;&#125;\n\n","categories":["算法类","题解"],"tags":["算法","题解","蓝桥杯"]},{"title":"galgame妹妹推荐转自七海妹","url":"/posts/31531.html","content":"有群友希望我转载这个，那我就转载了\n更新时间  2021·12·23             更新内容：推妹妹破百，初代表格诞生     前排提醒：仅为群名~“七海妹”个人主观意见，如有与你不和者，就无视我，没必要争吵。本人一年游玩时间，耗时30小时制作而成，难免有失误，还请告知我更改。本人主看重妹妹，不对作品本身评价，所以废萌评分会高一点。更新时间  2022·7·26晚           更新内容1：重置评分系统，由原来的SS&lt;SS+&lt;SSS-&lt;SSS   更改成  S&lt;SA&lt;SX&lt;SS&lt;&#x3D;SAAA&lt;&#x3D;SSA&lt;SSS        更新内容2：增加50位妹妹，其中15名生肉，1名不能攻略 更新内容3：加入鼠标放在妹妹名字上显示立绘功能       更新耗时25小时 \n更新时间  2023·1·27下午       更新内容1：添加妹妹、兄妹、妹线这三个评价（等级为：稀烂、拉跨、不太行、凑合、一般、还行、良好  、不错、优秀、极好、完美）            更新内容2：增加23名妹妹，其中11名生肉          更新内容3：22年我二刷了不少妹妹，多刷的评价至少上升一个等级         更新内容4：校对了血缘，更改几个不严谨的  \n提醒：血缘为？？？是防止剧透，     评分的负XX不是差，比如空羽妹妹非常废柴，但粘人讨喜因此是负极好，以此类推\n更新时间  2024·9·10晚           更新内容1：总妹妹数突破200位，增加31位妹妹，生肉26名            更新内容2：生肉有汉化的添加在其作品后，部分有AI翻译的也如此     更新内容3：增加提醒一栏在最后，备注一些注意的，以及避雷提醒等等                          更新内容4：再次校对血缘加入双胞胎\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n提醒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n笹浦铃奈\n\nSSS妹控\n妹妹：负极好\n兄妹：优秀\n妹线：不错\n妹妹色诱术\n\n\n\n《缘染此叶，化作恋红》\n\n\n小恶魔\n灰色\n亲妹\n欧尼酱\n废萌\n美少女\n100分\n争风吃醋\n良好\n幼时多病\n寄宿\n\n有孩子、猫娘装、黑丝\n\n\n妹控\n\nS\n妹控福音\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n莲乃  咲\n\nSSS活\n妹妹：极好\n兄妹：还行\n妹线：良好\n为哥哥的诞生献上一份兄妹禁断之恋\n\n\n\n《幸福噩梦》\n\n\n情人级\n黑发\n青梅竹马\n欧尼桑\n剧情作\n美少女\n82分\n娟好静秀\n正常\n拯救男主\n男主独居\n\n有孩子、黑丝\n\n\n\n\nA\n真假妹三角恋\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n内藤 舞亚\n\nSAAA\n妹妹：优秀\n兄妹：良好\n妹线：良好\n爱着你，比爱这个世界还爱你\n\n\n\n《幸福噩梦》\n\n\n恶魔级\n灰色\n亲妹\n欧尼酱\n剧情作\n哥特萝莉\n86分\n调皮捣蛋\n良好\n？？？\n男主独居\n\n膝枕\n\n\n\n虐\nB\n防止剧透？？？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n才城花林\n\nSAAA\n妹妹：极好\n兄妹：不错\n妹线：还行\n超级美少女竟是我妹妹？\n\n\n\n《爱丽亚的明日盛典》\n\n\n美少女\n黑发\n亲妹\n莲哥\n战斗\n美少女\n90分\n贤妻良母\n小陌生\n6年不见\n加表姐共三人\n\n摸头杀、膝枕、黑丝\n\n\n\n\nS\n没啥违背道德感的亲妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在原七海\n\nSSS优\n妹妹：完美\n兄妹：优秀\n妹线：还行\n只想和你在一起\n\n\n\n《Riddle  Joker》\n\n\n妹妹级\n金发\n义妹\n欧尼酱\n超能力\n美少女\n99分\n全能妹妹\n亲密无间\n都被收养\n学校住宿\n\n\n\n\n兄控\n\nS\n人设完美\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n花咲樱花\n\nSX\n妹妹：不错\n兄妹：还行\n妹线：凑合\n接受失去的感情\n\n\n\n《红线物语》\n\n\n粘人级\n黑发\n亲妹\n欧尼桑&#x2F;酱\n废萌\n萝莉\n100分\n相依为命\n两小无猜\n父母双亡\n兄妹同居\n\n摸头杀、婚纱、裸体围裙\n\n\n兄控\n\nA\n贤妻良母\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n大藏里想奈\n\nSSS陪伴\n妹妹：极好\n兄妹：优秀\n妹线：优秀\n山重水复疑无路，柳暗花明又一村\n\n\n\n《少女理论及周边》\n\n\n童话级\n黑发\n同父异母\n欧尼酱\n剧情向\n美少女\n94分\n互相依靠\n舍己为人\n家族竞争\n男主女装独居\n\n公主抱、里想奈式拥抱\n\n\n兄控\n\nA\n为哥哥愿意放弃所有\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n朝仓由梦\n\nSSA\n妹妹：良好\n兄妹：良好\n妹线：优秀\n相守一生的誓言\n\n\n\n《初音岛2》\n\n\n情侣级\n灰色\n义妹\n欧尼桑\n剧情向\n美少女\n96分\n家熊外乖\n正常\n？？？\n住隔壁\n\n\n\n\n\n感人&#x2F;催泪\nC\n先推姐姐会剧透\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n新田一歌\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：不错\n十年之约，哥哥由我来守护！\n\n\n\n《如月金星》\n\n\n初恋级\n金发\n义妹\n欧尼酱\n剧情向\n美少女\n98分\n讨厌哥哥\n偏差\n兄被收养\n兄妹同居\n\n婚纱、孩子\n\n\n\n2个be\nB\n妹妹行动让我感动\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n彩迁日和\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：还行\n把我的人生奉献给哥哥\n\n\n\n《青春期的五月雨》\n\n\n可爱级\n金发\n亲妹\n欧尼酱\n废萌\n萝莉\n100分\n娇小能干\n亲密无间\n对抗真姐\n母儿女三人\n\n动态摸头杀\n\n\n兄控\n\nS\n2021第一届可爱妹妹排行榜第一名（自荐）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n鸣海兔亚\n\nSS\n妹妹：优秀\n兄妹：不错\n妹线：良好\n共渡未见的难关\n\n\n\n《任性highspec》\n\n\n萌兔级\n白毛\n亲妹\n欧尼酱\n废萌\n白发红眼\n93分\n相依为命\n正常\n离家出走\n兄妹同居\n\n摸头杀\n\n\n\n\nA\n妹妹游戏宅，感情线不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n群云空羽\n\nSSS妹控\n妹妹：负极好\n兄妹：极好\n妹线：不错\n妹控真神体降临\n\n\n\n《星恋twinkle》\n\n\n妹控之神\n银发\n亲妹\n欧尼桑&#x2F;酱\n废萌\n美少女\n100分\n相依为命\n形影不离\n母死父失\n寄宿、同居\n\n裸体围裙、裸体缎带\n\n\n妹控\n甜蜜至极\nA\n妹控究极福音、难找第二个\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n瓜生樱乃\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：良好\n真正意义上的兄妹恋\n\n\n\n《纯白交响曲》\n\n\n兄妹级\n蓝发\n？？？\n欧尼酱&#x2F;桑\n废萌\n美少女\n97分\n勤劳能干\n优秀\n？？？\n兄妹同居\n\n\n\n\n\n兄妹恋\nB\n兄妹恋过程写的很好\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n藤守由宇\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：一般\n好不容易追上你，这次绝对不放手\n\n\n\n《恋骑士》\n\n\n表白级\n蓝发\n亲妹\n欧尼桑\n打斗\n美少女\n98分\n勤学苦练\n优秀\n父死妹病\n学园住宿\n\n\n\n\n\n\nS\nCG美的窒息，比较现实的兄妹恋\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n伏见巴\n\nSSA\n妹妹：极好\n兄妹：一般\n妹线：还行\n我对你的爱是没有上限的\n\n\n\n《三千心世界，梦终将实现》\n\n\n兄控级\n黑发\n同父异母\n欧尼桑\n悬疑\n美少女\n97分\n平近易人\n妹好恋差\n异性待哥\n学校住宿\n\n\n\n\n恋兄\n\nB\n前期逃妹（有隐藏实妹）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小森江铃\n\nSX\n妹妹：不错\n兄妹：一般\n妹线：一般\n还好再次遇见你\n\n\n\n《青春好奇相伴的三角恋爱》\n\n\n贤妻级\n浅粉红\n亲妹\n欧尼桑\n废萌\n美少女\n94分\n温柔体贴\n良好\n兄妹分离\n全家6人\n\n\n\n\n\n\nC\n结局意料之外，情理之中\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小森江七瑠\n\nSA\n妹妹：一般\n兄妹：一般\n妹线：一般\n不动不说话确实是个美女\n\n\n\n《青春好奇相伴的三角恋爱》\n\n\n反差萌\n蓝发\n义妹\n欧尼酱\n废萌\n美少女\n88分\n颜艺\n良好\n正常\n全家7人\n\n\n\n\n\n\nB\n小时候挺可爱的，就是颜艺了点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n新海天\n\nSSS活泼\n妹妹：极好\n兄妹：良好\n妹线：良好\n兄妹相声\n\n\n\n《9-nine-天色天歌天籁音》\n\n\n活泼级\n白毛\n亲妹\n欧尼酱\n超能力\n美少女\n100分\n活泼可爱\n亲密无间\n正常\n兄妹同居\n\n\n\n\n\n有be\nS\n除了男主没说喜欢妹妹其他都优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n月社妃\n\nSSS绝望\n妹妹：极好\n兄妹：良好\n妹线：优秀\n无可奈何却又令人神往的爱恋\n\n\n\n《纸上魔法使》\n\n\n纸魔级\n金发\n亲妹\n欧尼桑\n神作\n美少女\n88分\n成熟稳重\n？？？\n离家出走\n寄宿\n\n\n\n\n\n虐\nS\n哎，不是亲妹就好了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n皆神沙久耶\n\nSSA\n妹妹：优秀\n兄妹：良好\n妹线：不错\n思念的终点站\n\n\n\n《黄昏的禁忌之药》\n\n\n妹药级\n黑发\n亲妹\n欧尼桑\n剧情作\n美少女\n93分\n风趣幽默\n不分彼此\n母死\n寄宿\n\n\n\n\n兄控\n\nB\n大名鼎鼎的妹药\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第2批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n提醒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n上川沙矢\n\nSAAA颜\n妹妹：优秀\n兄妹：不错\n妹线：一般\n取回属于我们兄妹的时光\n\n\n\n《樱舞恋花恋模样》\n\n\n女主级\n黑发\n亲妹\n欧尼酱\n废萌\n美少女\n83分\n黑长直\n恋人\n兄妹分离\n男主独居\n\n\n\n\n\n\nS\n就只有颜值很顶\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n浅叶 小奈美\n\nSAAA\n妹妹：优秀\n兄妹：不错\n妹线：还行\n理想中的兄妹关系\n\n\n\n《恋花绽放樱飞时》\n\n\n妹妹级\n银发\n亲妹\n欧尼桑\n废萌\n美少女\n100分\n活泼撒娇\n亲密无间\n父母双亡\n义母三人\n\n摸头杀\n\n\n\n\nA\n永不放弃的信念\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n木下卯月\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：不错\n只属于我们的恋爱故事\n\n\n\n《密语》\n\n\n情人级\n黑发\n亲妹\n欧尼酱\n妹单\n大姐姐\n91分\n成熟\n寻找\n兄妹分离\n男主独居\n\n\n\n\n\n现代相遇\nA\n多结局，全he\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n野野宫蓝\n\nSSS兄控\n妹妹：极好\n兄妹：优秀\n妹线：良好\n妹控养成计划\n\n\n\n《春季限定》\n\n\n正妻级\n浅粉红\n义妹\n欧尼酱\n废萌\n美少女\n100分\n活泼可爱\n妹控兄控\n被父抛弃\n学校住宿（同居）\n\n兄控言论\n\n\n兄控\n\nB\n当极致撒娇遇上妹控\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小春\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：一般\n再会，与妹同居\n\n\n\n《心猫~与再会的妹妹展开全新关系》\n\n\n萝莉级\n蓝发\n亲妹\n欧尼酱\n妹单\n萝莉\n100分\n娇小可爱\n亲密\n兄妹分开\n兄妹同居\n\n裸体围裙\n\n\n\n\nB\n可爱的萝莉妹妹还想啥呢\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n成海真莉音\n\nSS\n妹妹：极好\n兄妹：良好\n妹线：还行\n一生只为哥哥而活\n\n\n\n《鲸神》\n\n\n兄控级\n红发\n义妹\n欧尼酱\n废萌\n美少女\n92分\n重度兄控\n甜蜜\n被收养\n学校住宿\n\n婚纱\n\n\n重度兄控\n\nB\n甜度十足\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n神森樱乃\n\nSSS催泪\n妹妹：负极好\n兄妹：优秀\n妹线：极好\n我们永远在一起吧\n\n\n\n《盛开的钢琴之森下》\n\n\n神作级\n暗肉色\n义妹\n兄长大人\n泣作\n美少女\n94分\n体弱多病\n当世无双\n被收养\n住隔壁\n\n44秒定生死\n\n\n兄妹情\n催泪\nB\n妹妹催泪巅峰作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n沢井  夏叶\n\nSX萝莉\n妹妹：良好\n兄妹：良好\n妹线：还行\n牵着手永远不放开哦\n\n\n\n《茂神奇谈》\n\n\n女儿级\n灰色\n亲妹\n欧尼酱\n废萌\n三形态\n98分\n病弱\n纯粹\n父母双亡\n寄宿\n\n摸头杀\n\n\n\n\nB\n剧情超长\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n优\n\nSAAA\n妹妹：优秀\n兄妹：还行\n妹线：负极好\n赌上自己的一切，这场战斗必须赢！\n\n\n\n《VGNEO》有大量ntr，be牛\n\n\n女主级\n红发\n？？？\n欧尼酱\n战斗\n女仆\n90分\n坚强不屈\n亲密\n？？？\n同居\n\n\n\n\n恋兄\n氛围打斗\nC\n打斗超燃，氛围超好（结局算be吧？）→→→\n\n\n\n\n某种意义上算牛，谨慎推，打斗很优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n大泉栞\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：良好\n亲妹现实版\n\n\n\n《实妹相伴的大泉君》\n\n\n现实级\n浅肉色\n亲妹\n欧尼酱\n废萌\n美少女\n100分\n知情达理\n距离感\n与父吵架\n兄妹同居\n\n\n\n\n\n带点剧情\nB\n感情线非常不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n麻衣\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：一般\ngal攻略后的妹妹\n\n\n\n《实妹相伴的大泉君》\n\n\n想象级\n白毛\n义妹\n欧尼酱\n废萌\n美少女\n95分\n天真可爱\n妹主动\n？？？\n住隔壁\n\n\n\n\n\n\nB\n人挺好，结局不太好\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n北条实里果\n\nSS\n妹妹：良好\n兄妹：还行\n妹线：良好\n逃不掉的命运\n\n\n\n《逃避行》\n\n\n隐藏级\n红发\n亲妹\n欧尼桑\n废萌\n美少女\n89分\n天真可爱\n隐藏恋兄\n正常\n家庭生活\n\n摸头杀\n\n\n隐藏恋兄\n\nC\n两个结局，不同命运，都he\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n泽渡七凪\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：良好\n把恋爱化作语言\n\n\n\n《硬要无视与你的未来》\n\n\n妹管严\n白毛\n义妹\n欧尼桑\n废萌\n美少女\n94分\n活泼可爱\n妻管严\n？？？\n加母三人\n\n\n\n\n兄控\n甜中带刀\nB\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n天宫雫\n\nSX\n妹妹：良好\n兄妹：一般\n妹线：还行\n一起共度明天而努力活下去\n\n\n\n《死神之吻乃离别之味》\n\n\n恋兄级\n黑发\n义妹\n欧尼酱\n废萌\n美少女\n89分\n傲娇\n距离感\n正常\n兄妹同居\n\n\n\n\n恋兄\n\nB\n兄妹相互拯救的故事\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n长沢 星歌\n\nSA\n妹妹：一般\n兄妹：一般\n妹线：不太行\n游戏风云\n\n\n\n《心灵重启》\n\n\n\n黑发\n亲妹\n大哥\n废萌\n美少女\n87分\n胆小内向\n距离感\n正常\n全家生活\n\n\n\n\n\n\nB&#x2F;S\n作品非常新颖，有意思，在游戏中发生故事，颜值都挺高，但作为妹妹却不够格， 感情线如同拔作，游戏角色又不能推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n长沢 雪樱\n\nSA\n妹妹：一般\n兄妹：一般\n妹线：不太行\n游戏风云\n\n\n\n《心灵重启》\n\n\n\n黑发\n亲妹\n大哥\n废萌\n美少女\n88分\n家庭主妇\n距离感\n正常\n全家生活\n\n\n\n\n\n\nB&#x2F;A\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第3批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n提醒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n鹰仓杏铃\n\nSSS柔\n妹妹：极好\n兄妹：优秀\n妹线：良好\n金发撒娇妹代表\n\n\n\n《Clover Day’s》\n\n\n公主级\n金发\n义妹\n欧尼桑\n废萌\n美少女\n100分\n撒娇可爱\n亲密无间\n男主被养\n全家生活\n\n\n\n\n兄控&#x2F;妹控\n甜蜜\nS\n温馨甜蜜，妹控福音、剧情也不差，白学羞萝场\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n鹰仓杏璃\n\nSSA\n妹妹：优秀\n兄妹：优秀\n妹线：良好\n永远支持哥哥\n\n\n\n《Clover Day’s》\n\n\n双马尾\n灰色\n义妹\n欧尼酱\n废萌\n美少女\n95分\n傲娇\n亲密无间\n男主被养\n全家生活\n\n\n\n\n兄控&#x2F;妹控\n\nA\n温馨甜蜜，妹控福音、剧情也不差，白学羞萝场\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n春日井咲良\n\nSSS妹控\n妹妹：极好\n兄妹：极好\n妹线：良好\n想要把谎言变成真实\n\n\n\n《隙间樱花与谎言都市》\n\n\n妹控级\n银发\n亲妹\n欧尼酱\n剧情向\n美少女\n100分\n霸道柔弱\n相依为命\n被母虐待\n住宿\n\n\n\n\n妹控\n先苦后甜\nA\n离家出走，相依为命，我的最爱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n山神水绪里\n\nSS颜\n妹妹：不错\n兄妹：良好\n妹线：一般\n你对于我来说是特别的\n\n\n\n《清澄如境之水面上》\n\n\n女神级\n黑发\n亲妹\n欧尼\n废萌\n美少女\n90分\n强大\n爱慕\n被封神\n全家生活\n\n\n\n\n\n\nS\n拔作向的废萌，颜值高，剧情一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n仓野绘麻\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：凑合\n为欧尼酱而生\n\n\n\n《仓野家双胞胎的故事》\n\n\n可爱级\n蓝发\n亲妹\n欧尼酱\n废萌\n萝莉\n97分\n可爱撒娇\n亲密\n正常\n全家生活\n\n\n\n\n\n\nA\n撒娇卖萌小萝莉\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n仓野弥惠\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：凑合\n把我献给哥哥\n\n\n\n《仓野家双胞胎的故事》\n\n\n可爱级\n黑发\n亲妹\n欧尼酱\n废萌\n美少女\n88分\n可爱\n亲近\n正常\n全家生活\n\n\n\n\n\n\nB\n标准废萌\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n间宫 羽咲\n\nSAAA\n妹妹：良好\n兄妹：良好\n妹线：不错\n隐藏在地狱深渊的妹控魔神器\n\n\n\n《美好的每一天》素晴日\n\n\n埋葬级\n桃色\n同父异母\n欧尼酱\n神作\n萝莉\n88分\n娇小可爱\n守护\n？？？\n？？？\n\n膝枕\n\n\n妹控\n恶心人\nB\n大名鼎鼎素晴日，废萌玩家不建议推，\n\n\n\n\n大量牛头人，不过妹没有，不建议推，难受一个月，后劲太大\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n白藤友菜\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：一般\n魔法少女之妹妹\n\n\n\n《Animal☆Panic》\n\n\n可爱级\n浅粉红\n义妹\n欧尼酱\n废萌\n萝莉\n92分\n天真无邪\n守护\n哥父妹母\n兄妹同居\n\n摸头杀，婚纱\n\n\n\n\nA\n从此改变我对短发妹妹的看法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小雪（全年龄）\n\nSAAA\n妹妹：还行\n兄妹：还行\n妹线：良好\n四世轮回千年之恋\n\n\n\n《SAKURA~雪月华》\n\n\n千年之恋\n红&#x2F;黑\n表&#x2F;堂妹\n欧尼酱\n剧情向\n美少女\n93分\n天真善良\n亲和\n？？？\n学校住宿\n\n\n\n\n\n轮回\nA\n妹世差点，第一世我非常喜欢\n\n\n\n\n仅开局第四世是妹妹，单妹妹剧情不够多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n沙那\n\nSA\n妹妹：良好\n兄妹：不错\n妹线：凑合\n让哥哥只爱我一个人\n\n\n\n《吃醋大作战》\n\n\n满好感度\n黑发\n亲妹\n欧尼酱\n半拔\n美少女\n91分\n痴迷\n保护\n正常\n加母三人\n\n\n\n\n\n\nB\n典型的哥哥成分不足\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n黑川雫\n\nSA\n妹妹：还行\n兄妹：还行\n妹线：凑合\n为成为兄妹而努力着\n\n\n\n《家庭教师露美美》\n\n\n隐藏级\n灰色\n义妹\n欧尼酱\n废萌\n美少女\n83分\n和善\n逐渐认可\n正常\n加女主同居\n\n婚纱\n\n\n\n\nC\n就表白勇猛\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小河坂 千波\n\nSSA\n妹妹：不错\n兄妹：不错\n妹线：还行\n你的幸福就是我的幸福\n\n\n\n《星空的记忆》\n\n\n活泼级\n红发\n同母异父\n欧尼酱\n废萌\n美少女\n100分\n热情好客\n看护\n父母双亡\n加姨同居\n\n裸体围裙、女仆装\n\n\n妹控\n自然\nB\n在妹控道路越走越远，很自然又亲密的兄妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n萤铃音\n\nSA\n妹妹：还行\n兄妹：一般\n妹线：还行\n一心同体的搭档\n\n\n\n《星辰恋曲的白色永恒》\n\n\n拥有级\n白毛\n同父异母\n欧尼酱\n废萌\n美少女\n61分\n进攻型\n隐藏\n？？？\n男主独居\n\n公主抱\n\n\n\n\nB\n隐藏妹妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n皆树\n\nSA\n妹妹：还行\n兄妹：不太行\n妹线：一般\n你死了，我会为你哭\n\n\n\n《My Sweet Home》\n\n\n禁忌 级\n暗肉色\n义妹\n大哥\n妹单\n美少女\n90分\n贤惠\n加深型\n被收养\n加父同居\n\n\n\n\n\n\nC\n短小精悍，又禁忌感\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n浦部 葵\n\nSX\n妹妹：不错\n兄妹：良好\n妹线：凑合\n一起向未来出发\n\n\n\n《鬼的捉迷藏》FD妹线\n\n\n可靠级\n蓝发\n亲妹\n欧尼酱\n废萌\n美少女\n96分\n可靠\n亲密\n正常\n兄妹同居\n\n\n\n\n\n\nB\n遗憾之作，本体优秀，FD妹线拉跨\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n樱庭 水穗\n\nSSA\n妹妹：优秀\n兄妹：不错\n妹线：一般\n天使降临\n\n\n\n《LOVELYQUEST》\n\n\n天使级\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n97分\n温柔贤惠\n甜蜜\n正常\n兄妹同居\n\n膝枕，和服\n\n\n\n\nS\n感情线不错，温馨甜蜜\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n丘野日向（全年龄）\n\nSAAA\n妹妹：不错\n兄妹：优秀\n妹线：良好\n你就是我的唯一\n\n\n\n《Wind-a breath of heart-》\n\n\n兄妹情\n红发\n？？？\n欧尼酱\n废萌\n美少女\n100分\n活泼洒脱\n兄妹情\n父死母失\n兄妹同居\n\n\n\n\n妹控\n兄妹向\nB\n少有的体现纯粹兄妹情的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n天濑小雪\n\nSA\n妹妹：还行\n兄妹：一般\n妹线：一般\n让我取回曾经美好的岁月\n\n\n\n《Magus ~世界树》\n\n\n少女级\n实木色\n义妹\n欧尼酱\n魔法\n美少女\n81分\n学霸型\n一般\n正常\n学校住宿\n\n\n\n\n\n\nC\n各方面都很一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n长濑湊\n\nSSS恋\n妹妹：优秀\n兄妹：不错\n妹线：良好\n我的生命中需要你\n\n\n\n《染红的街道》\n\n\n美少女\n灰色\n亲妹\n欧尼桑&#x2F;酱\n剧情向\n美少女\n100分\n美少女\n间隔\n正常\n兄妹同居\n\n摸头杀，拥抱三连杀\n\n\n\n兄妹恋\nA\n从相爱到父母同意，比较全面的妹作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n濑名美优树\n\nSS\n妹妹：良好\n兄妹：还行\n妹线：凑合\n只为寻找你\n\n\n\n《妹之形》\n\n\n隐藏级\n浅粉红\n亲妹\n欧尼桑\n废萌\n美少女\n63分\n害羞\n恋人成妹\n兄妹分离\n学校住宿\n\n摸头杀\n\n\n\n\nB\n还有其他隐藏妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n鹭泽缘（全年龄）\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：不错\n心灵拯救\n\n\n\n《秋之回忆4~从今以后》\n\n\n猫咪级\n白毛\n？？？\n欧尼酱\n三角恋\n美少女\n99分\n撒娇可爱\n开始接近\n正常\n男主独居\n\n\n\n\n\n三角恋\nB\n妹妹可爱，剧情不错，有点虐妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n藤堂 加奈\n\nSAAA\n妹妹：良好\n兄妹：优秀\n妹线：不错\n妹控杀手与妹控福音共存\n\n\n\n《加奈，欢迎回来》\n\n\n妹控鼻祖\n黑发\n？？？\n欧尼酱\n三角恋\n美少女\n93分\n柔弱\n守护\n？？？\n家庭生活\n\n\n\n\n\n\nB\n5个be，1个he，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n片濑雪希\n\nSS\n妹妹：还行\n兄妹：良好\n妹线：还行\n愿永不改变，愿永不分离\n\n\n\n《水色》\n\n\n回忆级\n浅红\n义妹\n欧尼酱\n伪三角恋\n美少女\n94分\n贤惠刻苦\n隐藏\n被收养\n兄妹同居\n\n\n\n\n\n\nB\n，短小精悍，共通线比较虐妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n野乃崎翼\n\nSAAA\n妹妹：良好\n兄妹：凑合\n妹线：还行\n妹控监狱\n\n\n\n《假如明日天放晴》很虐妹！\n\n\n虐心级\n茶色\n义妹\n欧尼桑\n三角恋\n美少女\n93分\n刻苦自卑\n不敌姐姐\n被收养\n多女主居住\n\n\n\n\n虐妹\n虐妹\nB\n虐妹巅峰作，全程压抑，没病不建议推\n\n\n\n\n姐兄妹三角恋剧情，很虐妹！！！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第4批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n提醒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n乙原恋\n\nSSS粘人\n妹妹：完美\n兄妹：优秀\n妹线：优秀\n爱会让人倾尽所有，恋则会赋予人拯救\n\n\n\n《由梦想和色彩编制而成》\n\n\n亲密级\n金发\n亲妹\n欧尼桑&#x2F;酱\n废萌\n美少女\n100分\n勤劳能干\n亲密无双\n正常\n兄妹同居\n\n裸体围裙\n\n\n妹控\n拯救\nS\n感情线，剧情，人设都很优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n月岛和羽\n\nSSS萝莉\n妹妹：负极好\n兄妹：不错\n妹线：良好\n只想和你在一起\n\n\n\n《恋爱教室》\n\n\n可爱级\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n100分\n娇小可爱\n温顺\n正常\n兄妹同居\n\n有孩子\n\n\n\n甜蜜\nS\n纯甜蜜作，家中有妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n苇原希里奈\n\nSS颜\n妹妹：不错\n兄妹：良好\n妹线：一般\n化解不可能的未来\n\n\n\n《新娘太好找了我很方》\n\n\n伪天使\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n91分\n可靠努力\n亲近\n家族\n多女主同居\n\n\n\n\n\n\nS\n共通线妹妹戏份少，剧情一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可可音（全年龄）\n\nSAAA\n妹妹：良好\n兄妹：良好\n妹线：还行\n不甘只做妹妹\n\n\n\n《萌夏》\n\n\n转变级\n浅蓝灰\n义妹\n欧尼酱\n废萌\n美少女\n97分\n害羞努力\n亲近\n正常\n家庭生活\n\n\n\n\n\n\nA\n麻雀虽小，五脏俱全，非亲似更亲\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n橘茉莉\n\nSA\n妹妹：还行\n兄妹：还行\n妹线：凑合\n不会让你受伤\n\n\n\n《妹选总选举》\n\n\n小公主\n金发\n同父异母\n欧尼酱\n废萌\n萝莉\n79分\n傲娇\n距离感\n正常\n亲兄妹同居\n\n\n\n\n\n\nA\n傲娇，金发，毒舌，大小姐，萝莉\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n橘四叶\n\nSA\n妹妹：还行\n兄妹：还行\n妹线：凑合\n愿意成为哥哥的妹妹\n\n\n\n《妹选总选举》\n\n\n小七海\n暗灰色\n同父异母\n欧尼酱\n废萌\n美少女\n83分\n实用能干\n亲和\n正常\n亲兄妹同居\n\n\n\n\n\n\nA\n起床温柔叫醒，做饭，学习都优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n樱木灰\n\nSAAA\n妹妹：良好\n兄妹：良好\n妹线：良好\n只属于我的灰姑娘\n\n\n\n《恋爱少女崩坏的人格》\n\n\n霸道级\n紫发\n表&#x2F;堂妹\n欧尼桑\n女装\n美少女\n74分\n成长型\n男好女差\n体弱多病\n学校住宿\n\n\n\n\n\n\nA\n不知道男主女装，共通剧情比较优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n神林丽\n\nSAAA颜\n妹妹：负优秀\n兄妹：良好\n妹线：还行\n想变得更加喜欢你\n\n\n\n《求神太多我的未来糟糕了》\n\n\n恋人级\n金发\n亲妹\n欧尼桑\n废萌\n美少女\n81分\n活泼洒脱\n天降\n胎死腹中\n兄妹同居\n\n膝枕\n\n\n\n\nS\n天降实妹不好接受\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n神林真央\n\nSX颜\n妹妹：还行\n兄妹：一般\n妹线：凑合\n让我做你的新娘\n\n\n\n《求神太多我的未来糟糕了》\n\n\n路人级\n浅黄色\n表&#x2F;堂妹\n欧尼酱\n废萌\n美少女\n65分\n害羞胆小\n路人\n正常\n男女主同居\n\n\n\n\n\n\nA\n路人级表妹，戏份少\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n炽月\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：凑合\n不忍哥哥离我而去\n\n\n\n《樱花盛典》\n\n\n表面级\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n88分\n实力型\n距离感\n留学归来\n家庭生活\n\n\n\n\n\n\nC\n剧情不行，还有个妹妹，不过是不能推，双飞\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n折口美羽\n\nSSA\n妹妹：不错\n兄妹：优秀\n妹线：良好\n我只凝视着你\n\n\n\n《追亿夏色年华》\n\n\n相依为命\n玫瑰红\n双胞胎\n欧尼酱\n剧情向\n美少女\n100分\n相依为命\n亲密无间\n父母自杀\n同居、住宿\n\n\n\n\n\n悬疑\nB\n剧情可以，除了妹妹颜值差点都优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n筱崎步海\n\nSSA\n妹妹：不错\n兄妹：还行\n妹线：还行\n温馨甜蜜小情侣\n\n\n\n《与你心相连》\n\n\n表妹级\n银发\n表&#x2F;堂妹\n欧尼桑\n废萌\n美少女\n85分\n真表妹\n渐近\n正常\n家庭生活\n\n\n\n\n\n\nA\n睡颜可爱，实妹不能推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n近江小小路\n\nSSA\n妹妹：优秀\n兄妹：不错\n妹线：还行\n你就是我的世界中心\n\n\n\n《世界与世界的中心》\n\n\n白毛萝莉\n白毛\n义妹\n欧尼酱\n废萌\n萝莉\n98分\n勤劳能干\n亲密\n？？？\n住宿\n\n有孩子\n\n\n\n\nS\n白毛萝莉可爱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n神乐鸟 雏\n\nSS\n妹妹：还行\n兄妹：还行\n妹线：一般\n你对我来说就是这么重要\n\n\n\n《啾啾爱恋》\n\n\n女仆\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n81分\n自卑\n阻碍\n正常\n兄妹同居\n\n\n\n\n\n\nB\n妹妹非常自卑，害怕哥哥抛弃自己\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小野寺 鞠\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：还行\n拯救自己的愿望\n\n\n\n《妄想Complete！》\n\n\n诱惑\n红发\n亲妹\n欧尼酱\n废萌\n萝莉\n100分\n活泼好动\n亲密\n正常\n兄妹同居\n\n\n\n\n\n\nA\n共通有h，妹线还不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n一羽，二叶\n\nSSS虐\n妹妹：不错\n兄妹：良好\n妹线：不错\n属于我们的理想乡\n\n\n\n《重生游戏》\n\n\n姐妹花\n浅粉红\n亲妹\n欧尼酱\n剧情作\n美少女\n91分\n双妹妹\n亲密\n父母双亡\n兄妹同居\n\n\n\n\n\n\nA\n剧情不错，也有点虐\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n伊东美琴\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：还行\n探索未来的道路\n\n\n\n《恋色空模样》\n\n\n高冷\n灰色\n义妹\n欧尼酱\n废萌\n美少女\n98分\n高冷高傲\n阻碍\n正常\n兄妹同居\n\n\n\n\n\n\nB\n共通线很长，妹妹误以为哥哥是变态而远离\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n花咲乃乃香\n\nSSS温柔\n妹妹：完美\n兄妹：良好\n妹线：良好\n如此爱着你\n\n\n\n《花咲workspring》\n\n\n温柔\n暗肉色\n义妹\n欧尼酱\n废萌\n美少女\n99分\n温柔体贴\n亲密无间\n正常\n兄妹同居\n\n\n\n\n\n甜蜜\nS\n为报答哥哥，对男主无微不至的照顾\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n中条杏\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：还行\n你就是我的光\n\n\n\n《赠与你的空之花》\n\n\n甜蜜\n银发\n义妹\n欧尼酱\n废萌\n美少女\n99分\n温柔体贴\n亲密无间\n正常\n兄妹同居\n\n\n\n\n\n甜蜜\nA\n甜蜜温馨，感情线不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n千岁佐奈\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：还行\n紧握手中的幸福\n\n\n\n《天神乱漫》\n\n\n独自哭泣\n金发\n义妹\n欧尼桑\n废萌\n美少女\n98分\n体贴\n亲密\n正常\n家庭生活\n\n\n\n\n\n\nA\n剧情作设定，废萌剧情，感情线还行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n友濑瑠奈\n\nSX\n妹妹：不错\n兄妹：还行\n妹线：不太行\n想要拥有真实的你\n\n\n\n《少女与野兽》\n\n\n拥有级\n深灰色\n义妹\n名字\n废萌\n美少女\n93分\n坚强能干\n兄妹\n正常\n住宿\n\n\n\n\n\n\nA\n感情线可以，剧情不错\n\n\n\n\n逆天，哥哥是妹妹的性奴\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第5批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小鸟游亚子\n\nSSS甜\n妹妹：完美\n兄妹：不错\n妹线：优秀\n兄妹关系天花板\n\n\n\n《Making Lovers》\n\n\n兄妹级\n桃色\n义妹\n欧尼酱\n废萌\n美少女\n100分\n家庭主妇\n当世无双\n男主被养\n家庭生活\n\n\n\n\n\n兄妹\nB\n大概只有本人有亲妹才写的出来的剧本\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n白羽濑 悠\n\nSAAA\n妹妹：良好\n兄妹：良好\n妹线：良好\n爱恋之歌\n\n\n\n《杀恋~悠久之流传》\n\n\n守护级\n暗灰色\n亲妹\n欧尼酱\n带点\n美少女\n93分\n吵闹强硬\n从头\n兄妹分离\n兄妹同居\n\n\n\n\n\n恋成妹\nB\n典型的中期知道是兄妹，而且be，但剧情不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n双见空\n\nSAAA\n妹妹：不错\n兄妹：还行\n妹线：还行\n我守护着你，你保护着我\n\n\n\n《不要践踏天使的羽毛》\n\n\n信任级\n金发\n？？？\n大哥\n魔法\n美少年\n85分\n弟弟型\n姐弟？\n？？？\n学校住宿\n\n\n\n\n\n\nA\n妹妹男装，男主女装，男主不知道\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n远野 恋\n\nSS颜\n妹妹：不错\n兄妹：不错\n妹线：一般\n世界仅此你一人\n\n\n\n《夏空的英仙座》\n\n\n魅惑级\n深灰色\n亲妹\n欧尼酱\n废萌\n美少女\n94分\n对别高冷\n相依为命\n离家出走\n兄妹同居\n\n\n\n\n\n\nS\nCG美，设定好，但剧情有点偏了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n和泉妃爱\n\nSSS温柔\n妹妹：完美\n兄妹：良好\n妹线：不错\n契约之爱\n\n\n\n《灵感满溢的甜蜜幻想》\n\n\n兄妹级\n金发\n亲妹\n欧尼\n废萌\n美少女\n100分\n撒娇可爱\n依赖\n正常\n兄妹同居\n\n婚纱\n\n\n\n甜蜜\nS\n有名的富婆妹，人设好，剧情甜\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n吹上初音\n\nSS\n妹妹：良好\n兄妹：一般\n妹线：一般\n美梦粉碎留下的残骸\n\n\n\n《樱之社，净梦者》\n\n\n救赎\n浅粉红\n表&#x2F;堂妹\n欧尼桑\n悬疑血腥\n美少女\n88分\n小女孩\n掩埋\n哥父母死\n家庭生活\n\n婚纱\n\n\n\n氛围作\nB\n大量血腥镜头，妹前期没存在感，好在剧情不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n山吹恋华（全年龄）\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：凑合\n想看你的微笑\n\n\n\n《Canvas3  白银的肖像》\n\n\n兄妹级\n浅紫色\n亲妹\n欧尼桑\n废萌\n美少女\n100分\n温柔宁静\n亲密\n正常\n家庭生活\n\n\n\n\n\n\nB\n兄妹并没有表露出爱意，平常生活突出关系\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名濑由佳奈\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：凑合\n妹的圣域\n\n\n\n《妹妹的圣域》\n\n\n兄妹级\n暗灰色\n亲妹\n欧尼酱\n废萌\n美少女\n100分\n兄控\n温馨\n正常\n兄妹同居\n\n\n\n\n兄控妹控\n\nA\n妹控与兄控结合，剧情够甜\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n岛津秋\n\nSSS厌兄\n妹妹：负极好\n兄妹：负极好\n妹线：优秀\n爱，永恒不变\n\n\n\n《回忆录》\n\n\n拯救级\n紫色\n义妹\n欧尼桑\n官场\n美少女\n93分\n厌恶\n讨厌\n？？？\n家庭生活\n\n\n\n\n究极妹控\n智斗\nS\n攻略前讨厌哥哥，攻略后病娇，剧情反转过瘾\n\n\n\n\n唯一一个真正讨厌哥哥的妹妹（仅限共通）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n永远\n\nSS\n妹妹：良好\n兄妹：良好\n妹线：一般\n十秒钟的勇气\n\n\n\n《挚爱随行，倾慕相伴》\n\n\n兄控级\n蓝发\n亲妹\n欧尼酱\n废萌\n美少女\n92分\n调皮可爱\n亲密\n正常\n兄妹同居\n\n\n\n\n兄控\n\nA\n游戏中相爱，妹妹表现很好，就是h有点多坏好感\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n咲姬\n\nSX\n妹妹：良好\n兄妹：良好\n妹线：一般\n锁住彼此的感情\n\n\n\n《妹锁》\n\n\n迷惑级\n实木色\n亲妹\n欧尼酱\n废萌\n美少女\n91分\n优等生\n距离\n正常\n兄妹同居\n\n\n\n\n\n\nB\n妹妹人设还行，剧情CG也比较甜，感情线不行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n真由\n\nSX\n妹妹：良好\n兄妹：良好\n妹线：一般\n只有你能让我感到安宁\n\n\n\n《真由是只属于哥哥的》\n\n\n保护级\n黑发\n亲妹\n欧尼酱\n妹单\n美少女\n95分\n胆小主动\n亲密\n正常\n家庭生活\n\n\n\n\n\n\nB\n各方面一般，没有啥优点也没啥缺点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n红星阳菜\n\nSX颜\n妹妹：不错\n兄妹：良好\n妹线：凑合\n只为让你爱上我\n\n\n\n《LAMUNATION》\n\n\n宠溺级\n金发\n亲妹\n欧尼酱\n无厘头\n美少女\n85分\n母系\n亲密\n正常\n兄妹同居\n\n\n\n\n\n\nS\nCG很美，剧情太无厘头，无聊\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n仁科十花\n\nSA\n妹妹：不错\n兄妹：良好\n妹线：一般\n愿你的笑容永不凋零\n\n\n\n《伊人天使妹侧畔》\n\n\n天降级\n浅粉红\n天降实妹\n老哥\n废萌\n美少女\n81分\n活泼\n一见钟情\n天降\n兄妹同居\n\n\n\n\n\n\nB\n妹妹设定不行，剧情逻辑不通，没有啥实妹感\n\n\n\n\n天降实妹，逆天操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n三衣珠树\n\nSAAA\n妹妹：不错\n兄妹：不错\n妹线：不错\n你就是我的英雄\n\n\n\n《将军大人风华正茂》\n\n\n夫妻级\n浅粉红\n义妹\n欧尼酱\n穿越\n美少女\n100分\n撒娇可爱\n亲密无间\n妹被收养\n家庭生活\n\n\n\n\n\n\nB\n穿越剧，兄控，感情线不错，兄妹关系好\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n孔瑞丽（全年龄）\n\nSAAA\n妹妹：不错\n兄妹：优秀\n妹线：负极好\n世间永恒的爱恋\n\n\n\n《鬼哭街》重制版，设定有牛\n\n\n复仇级\n玫瑰红&#x2F;蓝\n亲妹\n兄长大人\n剧情作\n美少女\n94&#x2F;88分\n贤淑&#x2F;病娇\n亲密\n？？？\n？？？\n\n\n\n\n\n战斗\nB\n妹妹设定吓退90%玩家，废萌玩家勿入→→→\n\n\n\n\n不好评价，对某些人也算牛，萌豚勿入\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n浅井花音\n\nSSA\n妹妹：不错\n兄妹：还行\n妹线：良好\n挑战我作为妹妹的极限\n\n\n\n《G弦上的魔王》\n\n\n成长级\n玫瑰红\n义妹\n欧尼酱\n斗智作\n美少女\n97分\n任性外向\n认知\n男主死父\n独居，兄妹同居\n\n\n\n\n\n斗智斗勇\nA\n成长型妹妹，喜爱哥哥，剧情不错，感情线可以\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n藤仓雅\n\nSX\n妹妹：良好\n兄妹：良好\n妹线：一般\n被妹妹爱慕着是哥哥的荣耀\n\n\n\n《铳骑士》\n\n\n依靠级\n粉红\n亲妹\n欧尼酱\n废萌\n美少女\n98分\n双重人格\n亲密\n父死母游\n兄妹同居\n\n\n\n\n\n\nA\n妹妹戏份足，感情线还行人设可爱，但剧情幼儿化\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n树里\n\nSS\n妹妹：良好\n兄妹：良好\n妹线：优秀\n除了哥哥我谁也不要\n\n\n\n《腐姬》设定有牛\n\n\n病娇姬\n暗灰色\n？？？\n欧尼酱\n轮回作\n萝莉\n82分\n病娇\n亲密\n？？？\n家庭生活\n\n\n\n\n\n悬疑\nB\n妹妹戏份非常少不能推，但剧情特别牛逼，悬疑→\n\n\n\n\n不好评价，对某些人也算牛，萌豚勿入\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第6批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n长谷川菜乃\n\nSSS妹控\n妹妹：负极好\n兄妹：极好\n妹线：优秀\n没有谁比你更重要\n\n\n\n《雪歌》\n\n\n兄妹级\n棕色\n义妹\n欧尼酱\n废萌\n美少女\n100分\n活泼撒娇\n仅此二人\n妹妹被养\n兄妹同居\n\n裸体围裙，三连问\n\n\n超级妹控\n兄妹\nB\n称为世界第一妹控哥哥不为过\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n橘木理帆\n\nSSS温馨\n妹妹：极好\n兄妹：优秀\n妹线：不错\n我的世界不能没有你\n\n\n\n《家有妹妹》\n\n\n兄妹级\n褐玫瑰红\n亲妹\n欧尼酱\n妹单\n美少女\n100分\n活泼可爱\n真兄妹\n正常\n兄妹同居\n\n三连问\n\n\n\n\nA\n除了结局开放外没有什么缺点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n御城由乃\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：良好\n我们是命中注定的\n\n\n\n《自黯淡之刻的尽头》\n\n\n穿越\n浅粉\n亲妹\n欧尼酱\n末日\n萝莉\n100分\n撒娇开朗\n兄妹\n？？？\n家庭生活\n\n\n\n\n\n\nA\n氛围轮回作\n\n\n\n\n带点恐怖，有很现实的be\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n橘 皋月\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：一般\n兄控大作战\n\n\n\n《Stellar☆Theater encore》\n\n\n兄控级\n·蓝发\n亲妹\n欧尼酱\n废萌\n美少女\n97分\n兄控\n兄控\n正常\n兄妹同居\n\n裸体围裙，三连问\n\n\n重度兄控\nFD\nA\n完美的妹妹，而且兄控，FD才能推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n黑瀨樱良\n\nSS\n妹妹：不错\n兄妹：不错\n妹线：还行\n在一起是我们追求的命运\n\n\n\n《相见5分属于我，时间停止和不可避的命运》\n\n\n兄控级\n黑发\n亲妹\n欧尼桑\n废萌\n美少女\n100分\n温柔宁静\n依赖\n妹受伤\n兄妹同居\n\n\n\n\n\n\nA\n感情线不错，温馨甜蜜\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n月见里 水雪\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n守护哥哥的幸福\n\n\n\n《未来收音机与人工鸽》\n\n\n守护级\n暗灰色\n义妹\n欧尼酱\n废萌\n美少女\n100分\n活泼外向\n吸引注意\n妹被收养\n家庭生活\n\n\n\n\n\n\nA\n真女主光环过强，妹线还是可以的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n时谷忍\n\nSA\n妹妹：不错\n兄妹：稀烂\n妹线：不太行\n愿成你妹\n\n\n\n《缘契初情乃今家舍妹》\n\n\n相伴级\n灰蓝色\n义妹\n欧尼桑\n废萌\n美少女\n84分\n温柔优等\n隔阂\n成兄妹\n兄妹同居\n\n\n\n\n\n\nA\n血压升高作，男主死活不接受妹妹表白\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n深峰莉子\n\nSAAA\n妹妹：不错\n兄妹：还行\n妹线：还行\n留下彩虹以及对你的思念\n\n\n\n《永不消失的彩虹 Gift》\n\n\n兄妹级\n深红色\n义妹\n欧尼酱\n废萌\n美少女\n99分\n温柔高冷\n思念\n被分开\n家庭生活\n\n\n\n\n\n\nA\n日常感情戏很好，表现似亲妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeru\n\nSA\n妹妹：还行\n兄妹：还行\n妹线：凑合\n她的微笑如此美丽，但眼中充满悲伤\n\n\n\n《Millia -The ending》\n\n\n依靠\n金发\n义妹\n哥哥\n短篇\n美少女\n89分\n文静\n相依为命\n父母双亡\n兄妹同居\n\n裸体围裙\n\n\n\n\nC\n无语音，悲伤作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n瀨真梢\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：凑合\n眼里只有哥哥\n\n\n\n《白恋SAKURA＊GRAM》\n\n\n喜爱级\n浅粉红\n亲妹\n欧尼酱\n废萌\n美少女\n89分\n害羞胆小\n亲密\n正常\n学校住宿\n\n\n\n\n兄控\n\nA\n隐藏可推角色，表现还行，戏份比较少\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n希露菲·克劳德\n\nSAAA\n妹妹：优秀\n兄妹：良好\n妹线：还行\n回到兄妹时光\n\n\n\n《回转苹果亭的一千零一夜》\n\n\n重逢级\n褐色\n？？？\n欧尼酱\n废萌\n美少女\n96分\n纯洁无暇\n重逢\n正常\n多女主居住\n\n\n\n\n\n\nA\n重逢感情做的很好，妹妹很圣洁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n新见雪月\n\nSSS兄妹\n妹妹：极好\n兄妹：极好\n妹线：极好\n创造属于我们兄妹自己的形式\n\n\n\n《银色遥远》\n\n\n兄妹级\n黑发\n义妹\n欧尼酱\n废萌\n美少女\n98分\n温柔贤惠\n亲密\n正常\n家庭生活\n\n裸体围裙\n\n\n\n\nA\n时间跨度很大，非常棒的妹妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n葉山莉寿\n\nSAAA\n妹妹：不错\n兄妹：还行\n妹线：良好\n哥哥胜任之路\n\n\n\n《凝视那侧脸》\n\n\n守护级\n实木色\n义妹\n欧尼酱\n黑深残\n美少女\n91分\n活泼可爱\n伪亲密\n妹被收养\n家庭生活\n\n\n\n\n\n\nB\n黑马，意外感情线不错，就是有点暗黑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n朝雾麻衣\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：还行\n一直一直喜欢你\n\n\n\n《更胜黎明前的琉璃色》\n\n\n家庭级\n桃色\n？？？\n欧尼酱\n废萌\n美少女\n92分\n天真活泼\n喜欢\n破镜重圆\n姐兄妹同居\n\n\n\n\n\n\nB\n无血缘，姐兄妹破镜重圆的故事\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n皇城一花\n\nSS颜\n妹妹：优秀\n兄妹：良好\n妹线：一般\n宛如鲜花绽放\n\n\n\n《恋慕之心的交织方式》\n\n\n颜值级\n紫发\n义妹\n欧尼桑\n废萌\n美少女\n91分\n善解人意\n亲密无间\n正常\n兄妹同居\n\n\n\n\n\n\nS\nFD必推，除了流程短没有什么缺点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n高乃椎凪\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n彼此一如既往\n\n\n\n《雪境迷途遇仙踪》\n\n\n温情级\n蓝发\n亲妹\n欧尼桑\n废萌\n美少女\n96分\n温情\n亲密\n正常\n多女主居住\n\n膝枕\n\n\n\n\nA\n废萌，中规中矩\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n永仓小夏\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：凑合\n人气声优养成\n\n\n\n《人气声优的养成方式》\n\n\n平常级\n实木色\n亲妹\n欧尼酱\n声优\n美少女\n84分\n勤奋努力\n平常\n正常\n多女主居住\n\n\n\n\n\n\nC\n缺少兄妹单独剧情，表现一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n水泽巡\n\nS颜\n妹妹：还行\n兄妹：还行\n妹线：拉跨\n寻找救赎\n\n\n\n《罪恋X2&#x2F;3》\n\n\n颜值级\n紫发\n义妹\n欧尼桑\n狗血\n美少女\n81分\n外热内冷\n还行\n父母双亡\n兄妹同居\n\n\n\n\n\n\nS\n颜值是真的高，剧情也是真的狗血，不太建议推\n\n\n\n\n三角恋狗血剧情，谨慎推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第7批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n青葉英梨歌\n\nSSS妹控\n妹妹：优秀\n兄妹：优秀\n妹线：良好\n被尘封的爱恋\n\n\n\n《猫神大人与七颗星星》\n\n\n兄妹级\n金发\n亲妹\n欧尼酱&#x2F;桑\n妹单\n美少女\n100分\n撒娇可爱\n亲密无间\n被母虐待\n兄妹同居\n\n\n\n\n妹控\n兄妹\nS\n非常稀有的妹单佳作，完全符合我的兴趣\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n宝交祐佳\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：一般\n化作灯塔，指引你前进的方向\n\n\n\n《Berry’s》\n\n\n指引级\n棕色\n亲妹\n欧尼酱\n废萌\n美少女\n93分\n害羞胆小\n温和\n正常\n兄妹同居\n\n\n\n\n\n\nB\n先上车后补票，感情有点担忧\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n汀龙子\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：还行\n妹控勇往直前\n\n\n\n《こんそめ！～combination somebody～\n\n\n守护级\n浅粉\n义妹\n尼尼\n废萌\n美少女\n95分\n高冷撒娇\n重逢\n青梅\n多女主居住\n\n\n\n\n\n\nB\n改邪归正，不可多得的妹作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n藤白乃绘里\n\nSA颜\n妹妹：极好\n兄妹：稀烂\n妹线：拉跨\n妹想妹而妹非妹\n\n\n\n《Dal   Segno》\n\n\n\n·金发\n表&#x2F;堂妹\n欧尼\n废萌\n美少女\n88分\n活泼可爱\n隔阂\n正常\n学校住宿\n\n\n\n\n\n\nS\n亲妹不能推，男主不把表妹当妹，妹控慎推\n\n\n\n\n男主不随表妹意，只认亲妹却没线，表妹没得说标准妹妹形象\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n蜜娜\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：一般\n此生只为守护尼\n\n\n\n《猎人学院2》回合制RPG\n\n\n守护级\n暗灰色\n表&#x2F;堂妹\n名字\nRPG\n美少女\n95分\n善良温柔\n相依为命\n父母双亡\n多女主居住\n\n\n\n\n\nRPG\nB\n兄妹感情很好，很甜，但非gal而是rpg\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n稜祁祥那\n\nSSS萝莉\n妹妹：负极好\n兄妹：极好\n妹线：负极好\n永世爱恋\n\n\n\n《少女神域~少女天狱》be污点\n\n\n萝莉级\n粉色\n亲妹\n欧尼酱\n剧情向\n萝莉\n100分\n天真无邪\n兄妹情\n父母双亡\n家庭生活\n\n\n\n\n\n\nS\n刀多，be像雷，无牛，真萝莉，后期剧情精彩，\n\n\n\n\nbe是污点，只走TE那就是全年龄，其他女主线可能有大雷\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n喜多芽衣\n\nSA\n妹妹：还行\n兄妹：一般\n妹线：一般\n不想让你担心\n\n\n\n《正负战争》\n\n\n隐藏级\n黑发\n亲妹\n欧尼酱\n废萌\n美少女\n84分\n勤劳能干\n隐藏\n正常\n多女主居住\n\n\n\n\n\n\nB\n隐藏的感情可不太好，距离感也不太行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n忧姬（全年龄）\n\nSX\n妹妹：还行\n兄妹：一般\n妹线：一般\n带你穿越黑暗\n\n\n\n《NOeSIS羽化》\n\n\n爱护级\n蓝发\n义妹\n欧尼酱\n废萌\n美少女\n88分\n坚强能干\n漠视\n？？？\n多女主居住\n\n\n\n\n\n\nB\n剧情有些阴暗，妹线男主才重视妹妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n待雪亚芽\n\nSA颜\n妹妹：良好\n兄妹：良好\n妹线：凑合\n重新开始的关系\n\n\n\n《不可视之药与坎坷的命运》\n\n\n\n粉色\n表&#x2F;堂妹\n欧尼桑\n废萌\n美少女\n85分\n小傲娇\n阻碍\n正常\n兄妹同居\n\n\n\n\n\n\nS\nh过早，感情不到位，发展离谱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n朝仓音梦\n\nSAAA\n妹妹：良好\n兄妹：良好\n妹线：还行\n好想、好想和你在一起\n\n\n\n《初音岛1》\n\n\n珍惜级\n实木色\n义妹\n欧尼桑&#x2F;酱\n废萌\n美少女\n95分\n兄控活泼\n兄控\n正常\n兄妹同居\n\n\n\n\n\n\nB\n感情更加自然，前期发糖后期虐\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n速濑真奈美\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n一直相伴的思念\n\n\n\n《神风探索者》\n\n\n牵挂级\n浅粉红\n亲妹\n欧尼酱\n废萌\n美少女\n96分\n兄控活泼\n撒娇\n正常\n学校住宿\n\n\n\n\n\n\nB\n妹妹超兄控，表白很棒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n结城铃（全年龄）\n\nSAAA\n妹妹：良好\n兄妹：良好\n妹线：还行\n妹控是如何速成的？\n\n\n\n《女仆咖啡巧克拉》\n\n\n温馨级\n实木色\n义妹\n欧尼酱\n废萌\n美少女\n94分\n内向孤僻\n伪兄妹\n妹被收养\n兄妹同居\n\n\n\n\n\n\nC\n家庭温馨感不错，妹妹占有欲强的不建议推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n津云\n\nSS\n妹妹：负不错\n兄妹：还行\n妹线：负一般\n欧尼酱~欧尼酱\n\n\n\n《九十九之月》\n\n\n迷途级\n白毛\n？？？\n欧尼酱\n废萌\n萝莉\n100分\n娇小可爱\n眩晕\n？？？\n多女主居住\n\n\n\n\n\n\nB\n另一个妹妹操作让人不适，狂虐本妹\n\n\n\n\n假妹太虐真妹，痛苦之作，谨慎推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n葛木 姫乃\n\nSAAA\n妹妹：优秀\n兄妹：不错\n妹线：良好\n想要传达给你的爱恋\n\n\n\n《D.C.III R～ダ・カーポIII アール～ X-rated》\n\n\n亲密级\n棕色\n义妹\n尼桑\n废萌\n美少女\n99分\n固执温柔\n亲密无间\n兄被收养\n学校住宿\n\n公主抱\n\n\n\n\nB\n义妹但亲密度似亲妹，建议只推前世妹妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n佐久真 诗\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n献出我的契约之吻\n\n\n\n《我的恋天使太废材了好可怕》\n\n\n恋爱级\n桃色\n义妹\n尼桑\n废萌\n美少女\n93分\n痴女温柔\n男女\n正常\n兄妹同居\n\n摸头杀，婚纱，裸体围裙\n\n\n\n\nS\n标准废萌，妹妹兄控好评，成痴女了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n柳瀬 詠歌\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：一般\n兄控无极限\n\n\n\n《突然发现我已恋上你》\n\n\n兄控级\n灰色\n亲妹\n尼桑\n废萌\n美少女\n93分\n兄控毒舌\n恋爱\n父母失踪\n多女主居住\n\n\n\n\n\n\nA\n兄控到一夜白头乃第一人，自慰狂魔\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第8批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n作品\n\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n黑崎小夜\n\nSX\n妹妹：还行\n兄妹：还行\n妹线：还行\n血液继承生命的温暖\n\n\n\n《青鸟》\n\n\n相遇级\n暗灰色\n双胞胎\n名字\n剧情向\n美少女\n89分\n抖S\n强硬\n？？？\n学校住宿\n\n\n\n\n\n\nC\n强硬抖S妹，开局男主H很多贴脸，设定像拔作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常坂二乃\n\nSAAA\n妹妹：优秀\n兄妹：良好\n妹线：还行\n一起活下去的约定\n\n\n\n《初音岛4》2个版本声优不一样\n\n\n颜萌级\n黑发\n义妹\n尼桑&#x2F;欧尼酱\n废萌\n美少女\n95分\n温柔可爱\n亲密无间\n正常\n家庭生活\n\n\n\n\n\n\nS\n作为废萌还可以，作为初音岛系列就差不少\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n新山葵\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：良好\n爱的赞歌\n\n\n\n《秋色恋華》\n\n\n粉丝级\n棕色\n义妹\n欧尼酱\n废萌\n偶像\n89分\n活泼开朗\n粉丝\n正常\n兄妹分居\n\n\n\n\n\n偶像\nB\n注重偶像的绯闻，声音俏皮，整体不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n夏本 讽歌\n\nSAAA\n妹妹：良好\n兄妹：负不错\n妹线：一般\n别，别碰我......会怀孕的\n\n\n\n《魔卡魅恋》\n\n\n萝莉傲娇级\n浅蓝发\n亲妹\n尼桑\n废萌\n萝莉\n95分\n傲娇可爱\n不肯承认\n正常\n学校住宿\n\n\n\n\n妹控\n\nA\n超可爱傲娇巨乳萝莉\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n茅崎夕樱\n\nSSA\n妹妹：极好\n兄妹：良好\n妹线：一般\n想要坚守爱你的信念\n\n\n\n《水葬银货》\n\n\n守护级\n粉红\n亲妹\n欧尼酱\n剧情向\n美少女\n100分\n古灵精怪\n？？？\n？？？\n多女主同居\n\n\n\n\n兄控\n\nS\n妹妹可靠能干，兄控言论满天飞，TE表现最佳\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n三谷 歩夢（全年龄）\n\nSAAA\n妹妹：不错\n兄妹：良好\n妹线：良好\n我就是你的妹妹\n\n\n\n《现在立刻就想对哥哥说我是妹妹！》\n\n\n温柔级\n浅肉色\n义妹\n欧尼酱\n废萌\n美少女\n93分\n勤劳能干\n隐藏\n再婚\n家庭生活\n\n隐藏妹妹身份的佳作\n\n\n\n\nB\n除了妹妹男装隐藏身份，其他都不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n飞鹰春奈\n\nSA\n妹妹：还行\n兄妹：一般\n妹线：凑合\n迟到的感情\n\n\n\n《格林花园的少女》\n\n\n\n粉红色\n双胞胎\n名字\n废萌\n美少女\n75分\n孤僻坚强\n？？？\n？？？\n？？？\n\n\n\n\n\n\nA\n挂羊头卖狗肉，不建议推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n远野律\n\nSA\n妹妹：良好\n兄妹：良好\n妹线：凑合\n命运共同体\n\n\n\n《闪耀青春追着逐记》\n\n\n依靠级\n茶色\n义妹\n欧尼酱\n废萌\n萝莉\n95分\n兄控可爱\n可爱\n正常\n兄妹同居\n\n婚纱\n\n\n兄控\n\nB\n配角待遇，隐藏可推，流程短妹线剧情过于刻意\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n沢渡  满\n\nSAAA\n妹妹：优秀\n兄妹：还行\n妹线：还行\n你是我的眼\n\n\n\n《克洛的时钟》\n\n\n守护级\n黑发\n亲妹\n尼桑满\n废萌\n美少女\n96分\n兄控温柔\n还行\n？？？\n兄妹分居\n\n\n\n\n重度兄控\n\nS\n兄妹描述的不够多，但家庭温馨感很不错，注重妹妹的成长\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n八重垣 瑠璃\n\nSSA\n妹妹：极好\n兄妹：优秀\n妹线：良好\n兄妹携手迈向未来\n\n\n\n《交汇协奏曲》\n\n\n拯救级\n白毛\n双胞胎\n尼桑&#x2F;欧尼酱\n废萌\n美少女\n95分\n兄控温柔\n粘人\n正常\n学校住宿\n\n\n\n\n重度兄控\n\nS\n妹妹南原声音好听，私下粘人，剧情差点意思\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n如月 もも\n\nS\n妹妹：良好\n兄妹：一般\n妹线：不太行\n成为欧尼酱心中的第一\n\n\n\n《抚子革命 ナデレボ！》\n\n\n\n棕色\n亲妹\n欧尼酱\n废萌\n美少女\n88分\n活泼兄控\n？？？\n正常\n兄妹同居\n\n\n\n\n\n\nC\n本体不如青梅，if线满好感动，流程短\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n山吹爱丽丝\n\nSAAA\n妹妹：负极好\n兄妹：极好\n妹线：一般\n姐妹花，兄妹心\n\n\n\n《星之少女与六华的姐妹》\n\n\n姐妹级\n蓝色\n义妹\n尼尼\n废萌\n美少女\n97分\n兄控怕生\n当世无双\n正常\n学校住宿\n\n婚纱\n\n\n重度兄控\n\nS\n颜值爆表，撒娇可爱还卖萌，写作兄妹，读作姐妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n春日野穹\n\nSSS妹\n妹妹：极好\n兄妹：良好\n妹线：不错\n悠远的苍穹下，紧密相连的羁绊\n\n\n\n《缘之空》\n\n\n傲娇\n白毛\n亲妹\n名字\n废萌\n美少女\n100分\n傲娇，温情\n无你不活\n父母双亡\n兄妹同居\n\n\n\n\n兄控\n\nA\n妹控必经历的里程碑，恨妹不是穹，什么是兄妹恋？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n千惠\n\nSAAA\n妹妹：优秀\n兄妹：良好\n妹线：还行\n处男哥与反坑妹\n\n\n\n《童贞兄妹》\n\n\n相亲\n黑色\n亲妹\n欧尼酱\n废萌\n美少女\n99分\n傲娇，人精\n自然\n正常\n家庭生活\n\n\n\n\n\n\nB\n感情铺垫不是很够，认ai当妹影响剧情，h过多\n\n\n\n\n多种性格选择\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n友坂玲夏\n\nSSA\n妹妹：优秀\n兄妹：优秀\n妹线：不错\n妹控初心\n\n\n\n《波子汽水》\n\n\n兄妹同心\n蓝发\n亲妹\n欧尼酱\n废萌\n萝莉&#x2F;美少女\n95分\n温顺\n未曾不喜欢\n正常\n兄妹同居\n\n\n\n\n\n\nA\n非常优秀的童年剧情（萝莉体型），长大后再续前缘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n库可\n\nSA\n妹妹：不错\n兄妹：一般\n妹线：凑合\n你的鲨鱼我的妹\n\n\n\n《与鲨鱼共度的七日之间》\n\n\n隐藏\n白毛\n亲妹\n欧尼酱\n剧情向\n美少女\n40分\n天真无邪\n鲨鱼\n？？？\n兄妹同居\n\n摸头杀\n\n\n\n\nA\n剧情尚可，但隐藏妹，毫无妹属性\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n谷风天音\n\nSSA\n妹妹：优秀\n兄妹：不错\n妹线：还行\n杂鱼欧尼酱~\n\n\n\n《天使☆纷扰 RE-BOOT!》\n\n\n兄妹\n粉红\n亲妹\n欧尼酱&#x2F;欧尼\n废萌\n美少女\n100分\n雌小鬼\n被埋藏\n正常\n兄妹同居\n\n膝枕，婚纱\n\n\n\n\nA\n柚子社第一位实妹，很甜很现实的兄妹关系，没有伦理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n生肉妹妹\n\n\n\n\n\n\n\n\n\n生肉gal\n\n\n翻译补丁网址   https://galge\\.fun/subjects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第1批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n生肉\n\n\n汉化&#x2F;翻译\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n千ヶ崎  入莉\n\nSSS救赎\n妹妹：负极好\n兄妹：极好\n妹线：优秀\n在探寻爱与希望的道路上不断前进\n\n\n\n《終わる世界とバースデイ》\n\n\n世界终结与生日快乐\n\n救赎级\n浅钢兰\n义妹\n欧尼桑\n剧情作\n美少女\n96分\n病弱孤独\n守护\n？？？\n兄妹同居\n\n妹控杀手\n\n\n超妹控\n感人&#x2F;催泪\nS\n又一催泪神作，看兄妹如何相互救赎\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n爱沢花穗\n\nSSS甜\n妹妹：完美\n兄妹：极好\n妹线：极好\n今生今世永不分离\n\n\n\n《ラブラブル～Lover Able～》FD：《同棲ラブラブル》\n\n\n情侣热恋中\n\n甜蜜级\n蓝发\n亲妹\n欧尼桑&#x2F;酱\n废萌\n美少女\n100分\n小恶魔\n亲密无双\n正常\n兄妹同居\n\n甜死人不偿命\n\n\n\n甜蜜\nB\n超甜妹作，当世无双\n\n\n\n\n甜度神中神，FD甚至更优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n此花茉莉\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：一般\n相守一生\n\n\n\n《Marguerite Sphere -マーガレット スフィア- 》\n\n\n《丽特的占卜星》共通汉化\n\n双子级\n金发\n双胞胎\n欧尼酱\n废萌\n美少年\n100分\n双重人格\n忽冷忽热\n正常\n兄妹同居\n\n\n\n\n\n\nA\n感情发展，表白，伦理都处理的还可以\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n御法 光\n\nSSA\n妹妹：良好\n兄妹：还行\n妹线：凑合\n愿你只在我的身旁\n\n\n\n《運命予報をお知らせします》\n\n\nAI翻译\n\n陪伴级\n粉红色\n亲妹\n欧尼酱&#x2F;桑\n废萌\n美少女\n94分\n冷静稳重\n兄控\n正常\n家庭生活\n\n\n\n\n\n\nB\n共通发力表白优秀，怎么会拒绝这么可爱的妹妹呢\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n初駒ルリ\n\nSSS亲情\n妹妹：负完美\n兄妹：极好\n妹线：优秀\n陪你渡过幸福的一生\n\n\n\n《ルリのかさね ～いもうと物語り》\n\n\nAI翻译\n\n家人级\n黑发\n侄女\n欧尼酱\n温情\n萝莉\n94分\n相依为命\n非你莫属\n父母双亡\n兄妹同居\n\n\n\n\n\n亲情\nA\n亲情描写最强作，最纯粹的家人情感\n\n\n\n\n3条妹线，萝莉神中神，时间跨度大，催泪\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n香原瑞希\n\nSSS傲暴\n妹妹：负极好\n兄妹：负不错\n妹线：不错\n兄妹回归初心\n\n\n\n《かみぱに!》\n\n\n\n\n傲暴级\n浅粉红\n亲妹\n欧尼酱\n废萌\n美少女\n97分\n暴力独占\n回归\n阴影\n多女主居住\n\n\n\n\n\n\nB\n感情发展稳定优秀，暴力妹妹比较少见\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n仲神 かすが\n\nSX\n妹妹：不错\n兄妹：还行\n妹线：凑合\n恋人宣言\n\n\n\n《ひだまりバスケット 》\n\n\nAI翻译\n\n活泼级\n实木色\n义妹\n欧尼酱\n废萌\n美少女\n100分\n活泼可爱\n妹主\n正常\n学校住宿\n\n\n\n\n\n\nB\n共通优秀，妹线走下坡路，伦理没有写好\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n夏島 みさき\n\nS\n妹妹：还行\n兄妹：还行\n妹线：凑合\n那一天，我对妹妹恋爱了\n\n\n\n《ナマイキデレーション》\n\n\nAI翻译\n\n\n蓝发\n亲妹\n欧尼酱\n废萌\n美少女\n85分\n傲娇冷酷\n吸引\n正常\n兄妹同居\n\n\n\n\n\n\nC\n缺少感情转折，铺垫，很一般，像拔作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n浅坂爱莉\n\nSSS巫女\n妹妹：优秀\n兄妹：不错\n妹线：还行\n爱上你是我的荣幸\n\n\n\n《妹のおかげでモテすぎてヤバい》\n\n\n因为妹妹太受欢迎了糟糕了\n\n相爱级\n金发\n亲妹\n尼桑\n废萌\n美少女\n100分\n活泼兄控\n真女主\n正常\n兄妹同居\n\n\n\n\n\n\nS\n各方面都很棒，声音还好听，妹妹真女主待遇\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小町谷 菜砂\n\nSSS温情\n妹妹：优秀\n兄妹：优秀\n妹线：良好\n无限缩短彼此的距离\n\n\n\n《ココロネ&#x3D;ペンデュラム》\n\n\nAI翻译\n\n思念级\n粉红\n亲妹\n啊尼给\n废萌\n美少女\n96分\n高傲兄控\n前辈\n分开3年\n学校住宿（同居）\n\n黑色枕大腿\n\n\n\n\nS\n前辈型妹妹，比较甜，兄妹感情发展优秀\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n丹生 佳津美\n\nSSA\n妹妹：不错\n兄妹：良好\n妹线：还行\n你就是我的恋慕之心\n\n\n\n《コドモノアソビ》\n\n\nAI翻译\n\n恋情级\n紫发\n亲妹\n尼桑&#x2F;欧尼\n废萌\n萝莉\n91分\n兄控高冷\n隐藏\n3年未认\n学校住宿\n\n摸头杀\n\n\n\n\nA\n开始高冷，进线主动，害羞可爱至极\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n白咲 ひな\n\nSSS撒娇\n妹妹：不错\n兄妹：负不错\n妹线：良好\n啊~哥哥雷达有反应啦！\n\n\n\n《SuGirly  Wish》\n\n\nAI翻译\n\n喜欢级\n白杏色\n亲妹\n欧尼酱\n废萌\n萝莉\n100分\n活泼可爱\n接近\n正常\n学校住宿\n\n\n\n\n超兄控\n\nB\n精力爆表，超喜欢哥哥，想成为哥哥的恋人\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n美野里 巴\n\nSA\n妹妹：良好\n兄妹：还行\n妹线：一般\n尽情撒娇吧，妹妹\n\n\n\n《QUINTUPLE☆SPLASH》\n\n\nAI翻译\n\n\n黑发\n亲妹\n欧尼酱\n废萌\n美少女\n93分\n傲娇严厉\n隐藏\n正常\n学校住宿（同居）\n\n\n\n\n\n\nA\n画风可爱，CG很棒，但感情变化过快，剧情一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n遠海 佐奈\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n我们不i可分离\n\n\n\n《Angel Ring》\n\n\nAI翻译\n\n相思级\n实木色\n亲妹\n啊尼给\n废萌\n美少女\n95分\n暴力能干\n隐藏\n正常\n多女主居住\n\n\n\n\n\n\nB\n共通非常棒，妹线感情变化不自然，犹豫不决\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n麻生 こま\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：还行\n相思成双\n\n\n\n《めぐり、ひとひら。》\n\n\n\n\n思念级\n棕色\n义妹\n欧尼酱\n带点剧情\n美少女\n93分\n善良温柔\n思念\n？？？\n多女主居住\n\n\n\n\n\n\nB\n人设很好，共通日常过长，剧情反转过于简单\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n燕子花 こりす\n\nSS\n妹妹：极好\n兄妹：负良好\n妹线：一般\n期待着回心转意\n\n\n\n《めぐり、ひとひら。》\n\n\n\n\n追寻级\n白毛\n青梅\n尼桑\n剧情向\n美少女\n90分\n温柔贤惠\n不高\n追寻\n住宿\n\n苦苦追寻男主，毅力最强之妹\n\n\n重度兄控\n\nS\n画风古老颜值依旧在，啥都好，可惜男主只在乎真妹妹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第2批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n翻译补丁网址   https://galge\\.fun/subjects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n生肉\n\n\n汉化&#x2F;翻译\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n岛津朗\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：凑合\n天才在左，废柴在右\n\n\n\n《木洩れ陽のノスタルジーカ》\n\n\n\n\n依赖级\n黑发\n义妹\n欧尼酱\n科技废萌\n美少女\n84分\n活泼开朗\n依赖\n正常\n家庭生活\n\n\n\n\n\n\nB\n妹妹设定优秀，但表现拉跨，兄妹戏份不够多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常盘木  雪\n\nSX\n妹妹：极好\n兄妹：良好\n妹线：一般\n编织属于我们的童话\n\n\n\n《雲上のフェアリーテイル》\n\n\nAI翻译\n\n公主级\n白毛\n亲妹\n哥哥大人\n废萌\n公主\n93分\n温文尔雅\n兄控\n分离几年\n住宿\n\n首个公主妹妹\n\n\n兄控\n公主\nS\n妹妹非常棒，但剧情不行，老套，无聊\n\n\n\n\nCG好看，剧情略显幼稚，而且非纯爱，在共通有男主跟其他女主h\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n双見 伊織（织）\n\nSSS宠物\n妹妹：优秀\n兄妹：优秀\n妹线：良好\n妹妹宠物\n\n\n\n《Love Sweets》\n\n\nAI翻译\n\n粘人级\n黑发\n亲妹\n尼桑\n温情\n美少女\n100分\n文静粘人\n亲密无间\n正常\n兄妹同居\n\n\n\n\n\n\nA\n文静可爱的妹妹谁不想守护呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n神木彩花\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：一般\n兄妹的纯真\n\n\n\n《夏彩恋唄》\n\n\n夏彩恋歌\n\n萝莉级\n浅黄红\n亲妹\n欧尼酱\n废萌\n萝莉\n93分\n活泼可爱\n粘人\n正常\n兄妹同居\n\n\n\n\n\n\nB\n活泼可爱萝莉妹妹，可惜流程短，感情线一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n大日向 ルイ\n\nSA\n妹妹：还行\n兄妹：良好\n妹线：一般\n心灵一体\n\n\n\n《ノブレスオブルージュ -Noblesse of Rouge》\n\n\nAI翻译\n\n温柔级\n黑发\n双胞胎\n尼桑\n废萌\n美少女\n93分\n温柔优等\n兄妹一体\n正常\n学校住宿\n\n\n\n\n\n\nA\n男主女装代替妹妹上学，流程短\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n十崎由衣\n\nSSS甜&#x2F;虐\n妹妹：完美\n兄妹：还行\n妹线：优秀\n血脉相连至不可分离的羁绊\n\n\n\n《ALMA～ずっとそばに…～》\n\n\n\n\n喜与悲\n红发\n亲妹\n欧尼酱\n天堂与地狱\n美少女\n100分\n贤妻良母\n超级兄控\n？？？\n兄妹同居\n\n天堂与地狱同在\n\n\n兄控\n\nC\n妹人妻属性拉满，前期多甜后期多虐\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n藤宮凛\n\nSS\n妹妹：优秀\n兄妹：一般\n妹线：一般\n一生妹，一生随\n\n\n\n《よくばりサボテン》\n\n\n\n\n信念级\n白毛\n义妹\n欧尼酱\n废萌\n美少女\n93分\n活泼兄控\n妹攻哥受\n分离多年\n兄妹同居\n\n婚纱\n\n\n\n\nS\n白毛长发.猫耳，妹妹不错，男主比较懦弱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n海棠 璃々子\n\nSSA\n妹妹：优秀\n兄妹：不错\n妹线：良好\n融入血缘的喜欢\n\n\n\n《サキガケ⇒ジェネレーション！》\n\n\nAI翻译\n\n萌兔级\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n100分\n中二缅甸\n甜蜜\n正常\n兄妹同居\n\n\n\n\n兄控\n中二\nS\n妹妹娇羞可爱又中二，白毛万岁\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小鸟游夜夜\n\nSSA\n妹妹：完美\n兄妹：稀烂\n妹线：拉跨\n留住回忆，锁住感情\n\n\n\n《Clover Point》\n\n\n四叶奇迹\n\n温柔级\n金发\n？？？\n欧尼酱\n废萌\n美少女\n98分\n温柔体贴\n兄控\n？？？\n家庭生活\n\n\n\n\n兄控\n\nA\n妹妹完美，男主太拉跨配不上妹妹\n\n\n\n\n妹妹太好，男主态度不行，还伤妹妹心\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n风祭 爱奈\n\nSAAA\n妹妹：优秀\n兄妹：还行\n妹线：还行\n守护在你的身旁\n\n\n\n《真夏の夜の雪物語 -MIDSUMMER SNOW NIGHT-》\n\n\n\n\n守护级\n金发\n表&#x2F;堂妹\n尼桑\n废萌\n美少女\n86分\n勤劳能干\n异性\n？？？\n姐兄妹同居\n\n\n\n\n\n\nS\n颜值顶中顶，兄妹感不高，三个周目表现都不算好\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第3批\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n翻译补丁网址   https://galge\\.fun/subjects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n生肉\n\n\n汉化&#x2F;翻译\n\n级别\n发色\n血缘\n称呼\n剧情\n形态\n妹力\n属性\n亲密度\n身世\n家庭生活\n\n荣誉\n\n\n妹控\n类型\n颜值\n感想\n\n\n\n\n提醒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n久我山 このか\n\nSSA\n妹妹：极好\n兄妹：优秀\n妹线：良好\n今生今世，与你相遇\n\n\n\n《プリズム◇リコレクション！》\n\n\nAI翻译\n\n贤惠可爱\n黑色\n亲妹\n欧尼酱\n废萌\n美少女\n100分\n温柔乖巧\n兄控\n正常\n兄妹同居\n\n\n\n\n兄控\n\nS\n记录哥哥的天才少女，妹人设无敌，发糖也甜\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n天都早紗\n\nSSA\n妹妹：极好\n兄妹：良好\n妹线：良好\n爱的魔法\n\n\n\n《夏の魔女のパレード》\n\n\nAI翻译\n\n温柔体贴\n黑色\n义妹\n尼桑\n魔法学校\n美少女\n99分\n忠犬\n兄控\n与老妈不合\n学校住宿\n\n婚纱\n\n\n兄控\n\nS\n重度兄控妹妹求爱记，世界名画壁咚表白，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n八坂可子\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：凑合\n无法抑制的喜欢\n\n\n\n《初音岛5》\n\n\nAI翻译\n\n\n深灰色\n青梅\n尼桑\n废萌\n美少女\n69分\n柔情善良\n喜欢\n？？？\n姐兄妹同居\n\n\n\n\n\n\nC\n共通体验差，初音岛待遇最差的一妹妹，边缘化\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n莉丝·格里菲兹\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n为你而活为你而死，直至死亡将我们分离\n\n\n\n《シャマナ シャマナ～月とこころと太陽の魔法～》\n\n\n\n\n守护\n桃色\n义妹\n欧尼酱\n废萌\n美少女\n85分\n淑女腼腆\n守护\n正常\n兄妹同居\n\n\n\n\n\n\nB\n超想守护的妹妹，柔弱腼腆，想撒娇却不敢行动\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n日向 なずな\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：一般\n守护这份情意\n\n\n\n《BLUE》\n\n\n\n\n恋爱\n黑色\n义妹\n欧尼酱\n废萌\n美少女\n78分\n高冷\n外冷内热\n正常\n分开\n\n\n\n\n隐藏兄控\n\nB\n外冷内热型妹，隐藏兄控，流程短但算全，发糖不够\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n上杉朱乃\n\nSSA\n妹妹：优秀\n兄妹：优秀\n妹线：良好\n爱的鞭挞\n\n\n\n《俺の彼女のウラオモテ》\n\n\nAI翻译\n\n爱意\n黑色\n亲妹\n欧尼\n废萌\n美少女\n91分\n热情兄控\n兄控\n正常\n家庭生活\n\n\n\n\n\n\nB\n在外骂哥哥，私下兄控，袒护哥哥，妹控福音\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n星央遥\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：一般\n爱上狮子的兔子\n\n\n\n《ガチ乙女クインテット》\n\n\n\n\n\n金发\n亲妹\n兄长大人\n废萌\n美少女\n95分\n温柔体贴\n喜欢\n正常\n兄妹同居\n\n摸头杀，婚纱\n\n\n\n\nC\n共通大量无关剧情且退其他女主线才能进，表现一般\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n宮沢 あきら\n\nSS\n妹妹：不错\n兄妹：良好\n妹线：还行\n心房上的钥匙\n\n\n\n《ゆきいろ ～空に六花の住む町～》\n\n\n\n\n童年\n白毛\n亲妹\n欧尼酱\n废萌\n萝莉\n98分\n温柔可爱\n粘人\n正常\n兄妹同居\n\n\n\n\n\n\nC\n童年戏份，超可爱，妹心理描写不错\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n雜賀ほたる\n\nSX\n妹妹：不错\n兄妹：良好\n妹线：还行\n不可或缺的存在\n\n\n\nFD:《Whiteちょこっとファンディスク》\n\n\n\n\n\n粉红\n亲妹\n欧尼酱\n废萌\n美少女\n91分\n胆小柔弱\n自始不变\n分开\n多女主同居\n\n\n\n\n\n\nB\n童年剧情优秀，但其他女主吃醋让人血压升高，仅FD有妹线\n\n\n\n\n其他女主抢男主特别恶心人，谨慎推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n臣苗 鈴\n\nSAAA\n妹妹：优秀\n兄妹：不错\n妹线：良好\n撒娇行动\n\n\n\n《ナツイロココロログ》\n\n\nAI翻译\n\n双妹泡芙\n桃色\n亲妹\n欧尼酱\n废萌\n美少女\n98分\n腼腆自卑\n隐藏\n正常\n兄妹同居\n\n\n\n\n\n\nA\n双重人格，精华在前，什么？能破妹两次处？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n一ノ瀬 乙葉\n\nSX\n妹妹：良好\n兄妹：还行\n妹线：还行\n你的梦魇我的心\n\n\n\n《幸福の食卓～しあわせのはね》\n\n\n\n\n灾恶\n黑发\n义妹\n欧尼酱\n废萌\n美少女\n86分\n村姑\n不得不爱\n父母再婚\n兄妹同居\n\n\n\n\n\n\nC\n相爱在一起是幸福的，同时也是悲剧的，痛苦是无尽的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n七枷 琴子\n\nSS\n妹妹：优秀\n兄妹：不错\n妹线：还行\n让我在爱你一次\n\n\n\n《猫撫ディストーション》有FD\n\n\n\n\n虚幻\n白毛\n亲妹\n尼桑\n剧情向\n天使\n95分\n贤淑温柔\n再爱一次\n？？？\n家庭生活\n\n\n\n\n\n\nS\nCG超美，剧情冗长且哲学悲剧？？？？？？？？\n\n\n\n\n不是很推荐，只当收集好看CG妹还行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n青野七\n\nSAAA\n妹妹：优秀\n兄妹：不错\n妹线：不错\n一日为亲，终生为妹\n\n\n\n《海と雪のシアンブルー》\n\n\nAI翻译\n\n义兄妹\n深红\n义妹\n欧尼酱\n废萌\n美少女\n98分\n温文尔雅\n积极上升\n开局义妹\n兄妹同居\n\n\n\n\n\n\nB\n，开局天降，从陌生人到兄妹再到恋人描写的非常好\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n早坂 羽未\n\nSS\n妹妹：不错\n兄妹：还行\n妹线：一般\n影子下的阴影\n\n\n\n《春恋＊乙女～乙女の園でごきげんよう。～》\n\n\n\n\n继承\n浅玫瑰色\n？？？\n欧尼酱\n废萌\n美少女\n98分\n活泼开朗\n？？？\n？？？\n学校住宿\n\n摸头杀\n\n\n\n\nA\n妹妹可爱，发糖可，但妹线压抑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n三枝 彩叶\n\nSSS萝莉\n妹妹：优秀\n兄妹：优秀\n妹线：优秀\n我心永恒\n\n\n\n《ラムネ2》波子汽水2\n\n\nAI翻译\n\n兄控\n粉红\n义妹\n欧尼酱\n废萌\n萝莉\n100分\n直率兄控\n欧尼酱\n两天故事线\n兄妹同居\n\n\n\n\n\n\nA\n完全不同两条故事线，教科书式感情描述，但有点小虐\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n冬马琴未\n\nS\n妹妹：还行\n兄妹：凑合\n妹线：拉跨\n牵引着你的到来\n\n\n\n《私立アキハバラ学園》\n\n\n\n\n\n粉红\n？？？\n欧尼酱\n废萌\n美少女\n88分\n粘人\n喜欢\n正常\n兄妹同居\n\n\n\n\n\n\nC\n妹线反转极其拉跨，恶心人，不建议游玩\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n六桜 日奈々（全年龄\n\nSS\n妹妹：不错\n兄妹：不错\n妹线：还行\n为你驱散黑暗\n\n\n\n《Primary ～Magical★Trouble★Scramble～》\n\n\nAI翻译\n\n可爱\n白毛\n亲妹\n欧尼酱\n废萌\n美少女\n93分\n懂事兄控\n妹妹\n失明\n学校住宿\n\n\n\n\n\n\nA\n全年龄，兄控且令人怜爱的妹妹，男主十足的妹控\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n波佐見 都\n\nSAAA\n妹妹：极好\n兄妹：一般\n妹线：还行\n兄控进行史\n\n\n\n《南十字星恋歌》\n\n\n\n\n兄妹\n黑长直\n表&#x2F;堂妹\n尼桑&#x2F;欧尼酱\n废萌\n黑长直\n100分\n毒舌兄控\n喜欢喜欢\n分开\n学校住宿\n\n被膝枕，摸头杀\n\n\n\n\nS\n妹妹兄控黑长直无敌，但有大量党争以及现任哥剧情\n\n\n\n\n有前任哥（男主）与现任哥（会长）争妹剧情，不过妹妹只爱男主，有妹妹跟真女主党争剧情，而且男主有两个萝莉妹妹却不能推\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n舞浜 有梨子\n\nSAAA\n妹妹：不错\n兄妹：优秀\n妹线：不错\n名为爱情的媚药\n\n\n\n《リトルプリンセスＧＯ！》\n\n\nAI翻译\n\n爱情\n茶色\n亲妹\n欧尼酱\n废萌\n美少女\n96分\n冷漠热情\n暗恋\n正常\n家庭分开\n\n\n\n\n\n\nB\n一对兄妹，二次表白，三场约会，节节高升\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n速水 朝顔\n\nSX\n妹妹：不错\n兄妹：还行\n妹线：一般\n爱的逃避行\n\n\n\n《ココロ＠ファンクション！》\n\n\nAI翻译\n\n\n黑发\n亲妹\n尼桑\n废萌\n美少女\n93分\n社恐\n暗恋\n收养人死亡\n学校住宿\n\n摸头杀\n\n\n\n\nA\n感情戏略少，发糖在h，ai抢走大部剧情甜度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n桧山 璃子\n\nSSA\n妹妹：优秀\n兄妹：不错\n妹线：良好\n内心深处的依赖\n\n\n\n《さくらビットマップ》\n\n\nAI翻译\n\n隐藏兄控\n蓝发\n义妹\n欧尼酱&#x2F;欧尼\n废萌\n美少女\n99分\n害羞温柔\n隐藏\n正常\n兄妹同居\n\n\n\n\n\n\nS\n隐藏兄控，想撒娇，全文非常丝滑，大量发糖\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n初芝 愛衣\n\nSSS妹线\n妹妹：优秀\n兄妹：优秀\n妹线：优秀\n初恋之心\n\n\n\n《そらいろ》\n\n\n\n\n初恋\n粉红\n义妹\n欧尼酱\n废萌\n美少女\n91分\n纯朴天真\n爱恋\n情人成兄妹\n兄妹同居\n\n摸头杀\n\n\n\n\nB\n三条妹线极致的满足，精心打磨，稳步发展，小虐\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n叶野 夢\n\nSX\n妹妹：不错\n兄妹：一般\n妹线：还行\n交往游戏\n\n\n\n《夏の幼馴染と冬のカノジョ》\n\n\nAI翻译\n\n病弱\n灰石色\n亲妹\n尼\n废萌\n美少女\n93分\n病弱\n白送\n正常\n兄妹同居\n\n\n\n\n\n\nB\n开局好感度满，缺失感情铺垫日常发糖，感情升温\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n周防 ななの\n\nSAAA\n妹妹：优秀\n兄妹：不错\n妹线：良好\n一起成长的约定\n\n\n\n《ほしうた》\n\n\n\n\n成长\n茶色\n义妹\n欧尼酱\n废萌\n美少女\n99分\n柔弱坚强\n一直喜欢\n男主被收养\n兄妹同居\n\n\n\n\n\n\nC\n妹妹的成长记录，兄妹跟奶奶三人的亲情写的很棒\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小田島小鈴\n\nSX\n妹妹：不错\n兄妹：还行\n妹线：一般\n家人一体\n\n\n\n《秋のうららの ～あかね色商店街～》\n\n\nAI翻译\n\n\n紫色\n义妹（大）\n欧尼&#x2F;欧尼酱\n废萌\n美少女\n86分\n坚强努力\n慢慢喜欢\n天降\n三兄妹住宿\n\n\n\n\n\n\nB\n共通不错少有的无血缘的家族情，但妹线感情线差点意思\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n小田島 まゆ\n\nSS\n妹妹：优秀\n兄妹：良好\n妹线：还行\n家人一体\n\n\n\n《秋のうららの ～あかね色商店街～》\n\n\nAI翻译\n\n柔弱\n金发\n义妹（小）\n欧尼酱\n废萌\n美少女\n91分\n柔弱温柔\n喜欢\n天降\n三兄妹住宿\n\n怀孕\n\n\n\n\nA\n共通同上，金发柔弱女子，窈窕淑女，一笑倾城\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n鼠标放妹妹名字上显示立绘\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n不能攻略的妹妹\n\n综合评分\n妹妹评分\n兄妹评分\n妹线评分\n评价\n\n\n\n没有妹线\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n久我 满琉\n\nSAAA\n妹妹：不错\n兄妹：不错\n妹线：无\n一直陪伴着你\n\n\n\n《时钟机关的朝雾中飘零之花》\n\n\n\n\n兄妹级\n灰石色\n亲妹\n欧尼酱\n剧情作\n美少女\n95分\n兄控病弱\n守护\n相依为命\n学校住宿\n\n\n\n\n\n\nC\n注意，妹妹不能推！妹妹很兄控，怕生（仅限pc版）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n评价\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["其他","galgame相关"],"tags":["其他","galgame相关"]}]