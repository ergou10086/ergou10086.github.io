<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring Boot part19-生命周期监听与9大事件 | ErgouTree's Blog</title><meta name="author" content="ErgouTree"><meta name="copyright" content="ErgouTree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="观察者模式 观察者模式是一种行为设计模式，它定义了对象之间的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。在这个模式中，改变状态的对象被称为主题，依赖的对象被称为观察者。 举个实际的例子：  事件源（Event Source）：可以视为“主题（Subject）”，当其状态发生变化时（比如播放新的内容），会通知所有的观察者。想象我们正在听广播，广播电台就">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot part19-生命周期监听与9大事件">
<meta property="og:url" content="https://ergou10086.github.io/posts/54298.html">
<meta property="og:site_name" content="ErgouTree&#39;s Blog">
<meta property="og:description" content="观察者模式 观察者模式是一种行为设计模式，它定义了对象之间的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。在这个模式中，改变状态的对象被称为主题，依赖的对象被称为观察者。 举个实际的例子：  事件源（Event Source）：可以视为“主题（Subject）”，当其状态发生变化时（比如播放新的内容），会通知所有的观察者。想象我们正在听广播，广播电台就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ergou10086.github.io/images/posts/cover_java8.jpg">
<meta property="article:published_time" content="2025-06-21T11:59:13.000Z">
<meta property="article:modified_time" content="2025-06-27T06:09:44.426Z">
<meta property="article:author" content="ErgouTree">
<meta property="article:tag" content="Java技术">
<meta property="article:tag" content="JavaWeb">
<meta property="article:tag" content="框架知识">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="JavaEE">
<meta property="article:tag" content="Spring系列">
<meta property="article:tag" content="Spring Boot">
<meta property="article:tag" content="Java框架">
<meta property="article:tag" content="配置相关">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="JUnit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ergou10086.github.io/images/posts/cover_java8.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring Boot part19-生命周期监听与9大事件",
  "url": "https://ergou10086.github.io/posts/54298.html",
  "image": "https://ergou10086.github.io/images/posts/cover_java8.jpg",
  "datePublished": "2025-06-21T11:59:13.000Z",
  "dateModified": "2025-06-27T06:09:44.426Z",
  "author": [
    {
      "@type": "Person",
      "name": "ErgouTree",
      "url": "https://github.com/ergou10086"
    }
  ]
}</script><link rel="shortcut icon" href="/img/pi.ico"><link rel="canonical" href="https://ergou10086.github.io/posts/54298.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?a6ab1b78e2c6320b664f31e8b9bf0e36";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Boot part19-生命周期监听与9大事件',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/arp.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-game"></i><span> GalGame</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><span> Random</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/posts/cover_java8.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ErgouTree's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring Boot part19-生命周期监听与9大事件</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-game"></i><span> GalGame</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fas fa-video"></i><span> Video</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><span> Random</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div></nav><div id="post-info"><h1 class="post-title">Spring Boot part19-生命周期监听与9大事件<a class="post-edit-link" href="https://github.com/ergou10086/ergou10086.github.io/edit/main/source/_posts/_posts/SpringBootpart18-生命周期监听与9大事件.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-21T11:59:13.000Z" title="发表于 2025-06-21 19:59:13">2025-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-27T06:09:44.426Z" title="更新于 2025-06-27 14:09:44">2025-06-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0/Spring%E7%B3%BB%E5%88%97/">Spring系列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0/Spring%E7%B3%BB%E5%88%97/Spring-Boot/">Spring Boot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/54298.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="观察者模式">观察者模式</h2>
<p>观察者模式是一种行为设计模式，它定义了对象之间的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。在这个模式中，改变状态的对象被称为主题，依赖的对象被称为观察者。</p>
<p>举个实际的例子：</p>
<ol type="1">
<li><strong>事件源（Event
Source）</strong>：可以视为“主题（<code>Subject</code>）”，当其状态发生变化时（比如播放新的内容），会通知所有的观察者。想象我们正在听广播，广播电台就是一个事件源，它提供了大量的新闻、音乐和其他内容。</li>
<li><strong>事件（Event）</strong>：这是主题状态改变的具体表示，对应到广播例子中，就是新闻、音乐和其他内容。每当电台播放新的内容时，就相当于一个新的事件被发布了。</li>
<li><strong>广播器（Event Publisher /
Multicaster）</strong>：广播器起到的是中介的作用，它将事件从事件源传递到监听器。在这个例子中，广播塔就充当了这个角色，它将电台的节目的无线电信号发送到空气中，以便无线电接收器（监听器）可以接收。</li>
<li><strong>监听器（Listener）</strong>：监听器就是“观察者”，它们监听并响应特定的事件。在例子中，无线电接收器就是监听器，它接收广播塔发出的信号，然后播放电台的内容。</li>
</ol>
<p>在<code>Spring</code>中，事件模型的工作方式也是类似的：</p>
<ol type="1">
<li>当<code>Spring</code>应用程序中发生某个行为时（比如一个用户完成了注册），那么产生这个行为的组件（比如用户服务）就会创建一个事件，并将它发布出去。</li>
<li>事件一旦被发布，<code>Spring</code>的<code>ApplicationContext</code>就会作为广播器，把这个事件发送给所有注册的监听器。</li>
<li>各个监听器接收到事件后，就会根据事件的类型和内容，进行相应的处理（比如发送欢迎邮件，赠送新用户优惠券等）。</li>
</ol>
<p>这就是<code>Spring</code>事件模型的工作原理，它实现了事件源、广播器和监听器之间的解耦，使得事件的生产者和消费者可以独立地进行开发和修改，增强了程序的灵活性和可维护性。</p>
<h2 id="生命周期监听">生命周期监听</h2>
<p>监听 Spring Boot
的生命周期的事件，让开发者能在应用启动不同阶段（如环境准备、容器初始化、Bean
加载等）插入自定义逻辑，实现对启动流程的精细控制。</p>
<h3 id="自定义springapplicationrunlistener来监听事件">自定义<code>SpringApplicationRunListener</code>来监听事件</h3>
<p><code>SpringApplicationRunListener</code>是Spring Boot
定义的应用启动生命周期监听器接口，作用是
“感知应用启动的关键阶段，触发自定义逻辑”
，比如在环境准备好时打印启动参数、在 Bean 加载完成后做初始化校验等</p>
<p>实现与配置自定义监听器的流程如下</p>
<ul>
<li><p><strong>编写实现类</strong>：</p>
<p>自定义一个类，实现 <code>SpringApplicationRunListener</code>
接口，重写接口中定义的生命周期方法（如
<code>starting</code>、<code>environmentPrepared</code> 等
），在方法里写你想执行的逻辑（比如日志打印、参数校验 ）。</p></li>
<li><p><strong>配置 <code>spring.factories</code></strong>： 在项目
<code>META-INF</code> 目录下创建（或已有）<code>spring.factories</code>
文件，添加配置，还可以指定⼀个有参构造器，接
受两个参数<code>(SpringApplication application, String[] args)</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">你的包名.MyRunListener</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/posts/54298/image-20250621142029901.png" alt="image-20250621142029901">
<figcaption aria-hidden="true">image-20250621142029901</figcaption>
</figure>
<p>这样，Spring Boot 启动时会通过 SPI
机制（<code>spring.factories</code> 是 SPI 配置方式
），找到并加载你的监听器。</p></li>
</ul>
<p>而 Spring Boot 在 <code>spring-boot.jar</code> 中配置了默认的
Listener，如下</p>
<figure>
<img src="/posts/54298/image-20250621141047197.png" alt="image-20250621141047197">
<figcaption aria-hidden="true">image-20250621141047197</figcaption>
</figure>
<p>Spring Boot 自身在 <code>spring-boot.jar</code> 的
<code>META-INF/spring.factories</code> 中，默认配置了
<code>EventPublishingRunListener</code> ，它的核心作用是
<strong>“事件转发”</strong>，在上述生命周期阶段，它会把
<code>SpringApplicationRunListener</code> 的事件，转换为 Spring 标准的
<code>ApplicationEvent</code>（如
<code>ApplicationStartingEvent</code>、<code>ApplicationEnvironmentPreparedEvent</code>
等 ），然后发布到 Spring 事件机制中。这样，其他通过
<code>@EventListener</code>
注解监听这些事件的组件，就能感知启动流程。</p>
<p>我们来写一个实例，来看看实现<code>SpringApplicationRunListener</code>手写监听器都需要实现什么方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppListener</span> <span class="keyword">implements</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line">    <span class="comment">// 传递的是启动上下文</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">(ConfigurableBootstrapContext bootstrapContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====staring 正在启动===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====failed 应用启动失败===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====environmentPrepared 环境准备完成===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====contextPrepared IOC容器准备完成===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====contextPrepared IOC容器加载完成===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递的是启动上下文</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context, Duration timeTaken)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====started 启动完成===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ready</span><span class="params">(ConfigurableApplicationContext context, Duration timeTaken)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====ready 准备就绪===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，一个空的<code>SpringApplicationRunListener</code>的实现类有如上这些方法需要被实现，这也对应着其
Spring Boot 应用的生命周期</p>
<p>Spring Boot 启动过程会触发 <code>SpringApplicationRunListener</code>
的多个方法，对应不同阶段，可理解为
“<strong>应用启动的时间轴</strong>”：</p>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 46%">
<col style="width: 36%">
</colgroup>
<thead>
<tr>
<th>阶段方法</th>
<th>触发时机 &amp; 作用</th>
<th>关键说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>starting</code></td>
<td><code>SpringApplication.run()</code>
调用后立即执行，此时应用刚启动，<code>BootstrapContext</code> 可用</td>
<td>可做最早期初始化（如标记启动开始时间 ）</td>
</tr>
<tr>
<td><code>environmentPrepared</code></td>
<td>环境准备完成（启动参数、系统变量等绑定到 <code>Environment</code>
），但 <code>IoC 容器</code> 还未创建</td>
<td>可修改环境变量（如动态设置配置参数 ）</td>
</tr>
<tr>
<td><code>contextPrepared</code></td>
<td><code>IoC 容器</code> 创建并准备好，但主配置类（<code>sources</code>
）未加载、组件未创建</td>
<td>可对容器做预配置（如注册自定义 Bean 后处理器 ）</td>
</tr>
<tr>
<td><code>contextLoaded</code></td>
<td><code>IoC 容器</code> 加载主配置类，但容器未刷新（Bean
未实例化、依赖未注入 ）</td>
<td>可在此阶段加载额外配置类</td>
</tr>
<tr>
<td><code>started</code></td>
<td><code>IoC 容器</code> 刷新完成（所有 Bean 已创建、依赖注入完成
），但 <code>ApplicationRunner</code>/<code>CommandLineRunner</code>
未执行</td>
<td>可做 Bean 初始化后的校验、日志统计</td>
</tr>
<tr>
<td><code>ready</code></td>
<td><code>ApplicationRunner</code>/<code>CommandLineRunner</code>
执行完毕，应用完全就绪</td>
<td>可标记启动完成，对外暴露服务就绪状态</td>
</tr>
<tr>
<td><code>failed</code></td>
<td>启动过程中发生异常时触发</td>
<td>可做异常兜底（如记录详细错误、发送告警 ）</td>
</tr>
</tbody>
</table>
<p>在META-INF中配好了我们自己实现的<code>SpringApplicationRunListener</code>监听器后，来看看启动后的关键流程变化</p>
<figure>
<img src="/posts/54298/image-20250621142323120.png" alt="image-20250621142323120">
<figcaption aria-hidden="true">image-20250621142323120</figcaption>
</figure>
<figure>
<img src="/posts/54298/image-20250621142200266.png" alt="image-20250621142200266">
<figcaption aria-hidden="true">image-20250621142200266</figcaption>
</figure>
<h3 id="项目启动的生命周期流程分析">项目启动的生命周期流程分析</h3>
<p>所以整个启动流程就分为如下三步</p>
<h4 id="引导">引导</h4>
<ul>
<li><p>关键动作围绕 <code>BootstrapContext</code>
展开，利用它引导上下文启动，它是一个轻量级上下文，存放启动初期必要的基础配置、监听器等，支撑应用启动流程
“开个头”。</p></li>
<li><p>首先就是这个 staring
方法，<code>SpringApplicationRunListener</code>接口中的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">(ConfigurableBootstrapContext bootstrapContext)</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们返回到我们的启动类中，可以发现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="type">Startup</span> <span class="variable">startup</span> <span class="operator">=</span> SpringApplication.Startup.create(); </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.properties.isRegisterShutdownHook()) &#123;</span><br><span class="line">        shutdownHook.enableShutdownHookAddition(); <span class="comment">// 注册关闭钩子，用于优雅停机</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键：创建引导上下文 BootstrapContext </span></span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext(); </span><br><span class="line">    <span class="comment">// ... 后续流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>SpringApplication.run()</code>
调用开始，引导阶段的核心步骤可拆解为：</p>
<ul>
<li><p>当你在启动类调用
<code>SpringApplication.run(xxx.class, args)</code> run方法时候，Spring
Boot 会进入启动流程，先初始化一些基础对象（如 <code>Startup</code>
记录启动指标、<code>shutdownHook</code> 注册关闭钩子
），然后<strong>创建 <code>BootstrapContext</code></strong></p></li>
<li><p>然后触发 <code>starting</code>
方法，<code>SpringApplicationRunListener</code> 介入，创建完
<code>BootstrapContext</code> 后，Spring Boot 会<strong>主动调用所有
<code>SpringApplicationRunListener</code> 的 <code>starting</code>
方法</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br></pre></td></tr></table></figure>
<p>以你自定义的监听器为例，Linstener先要从
<code>META-INF / spring.factories</code>
中读到实现类，用构造器（<code>SpringApplication application, String[] args</code>
）实例化后，执行 <code>starting</code> 逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br></pre></td></tr></table></figure></li>
<li><p>此时，只要有了<code>BootstrapContext</code>，<code>starting</code>
方法里的逻辑就会执行（比如打印 “应用开始启动” 日志、记录启动时间戳
），这是<strong>应用启动生命周期的第一个可扩展点</strong>，能在最早期插入自定义逻辑。</p></li>
<li><p>之后就是进行环境准备，把环境准备好，启动参数什么的进行绑定，但是此时，ioc容器还没有被创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"><span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><code>BootstrapContext</code> 虽然
“生命周期短”（主要在引导阶段活跃 ），但承担两个关键职责：</p>
<ul>
<li><strong>存放基础配置</strong>：启动过程中需要的一些基础
Bean、配置参数，会临时存在这里，供后续流程快速获取。</li>
<li><strong>支撑监听器交互</strong>：<code>starting</code>
等方法的参数是 <code>BootstrapContext</code> ，监听器可通过它读取 /
修改启动初期的基础配置（比如动态设置环境变量 ），影响后续启动流程。</li>
<li>引导阶段结束后，<code>BootstrapContext</code>
并不会直接销毁，而是会<strong>传递给后续流程</strong>（比如
<code>environmentPrepared</code> 阶段，监听器仍能拿到它 ），直到
<code>IoC 容器</code> （如
<code>AnnotationConfigApplicationContext</code>
）创建并准备好，引导上下文的使命才会逐步收尾，应用进入
<strong>“启动阶段”</strong>（如
<code>contextPrepared</code>、<code>contextLoaded</code> 等流程
）。</li>
</ul></li>
</ul>
<h4 id="启动">启动</h4>
<ul>
<li><p>启动阶段” 是 Spring Boot 真正构建
<code>IoC 容器</code>、加载配置、初始化 Bean 的过程，对应
<code>SpringApplicationRunListener</code> 的
<code>environmentPrepared</code>、<code>contextPrepared</code>、<code>contextLicooaded</code>、<code>started</code>
等方法。可以理解为：<strong>引导阶段搭好 “启动框架”，启动阶段负责
“填充内容、构建ioc容器”</strong>。</p></li>
<li><p>引导创建启动上下文之后，Spring Boot
会进入<strong>环境准备完成阶段</strong>，触发
<code>SpringApplicationRunListener</code> 的
<code>environmentPrepared</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，从引导阶段传递下来的<code>BootstrapContext</code>对象就会帮助其完成<code>Environment</code>
的准备，在这里，我们可以<strong>修改 /
校验环境配置</strong>，比如动态设置配置参数、检查必要配置是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - 创建并配置 Environment（包含系统属性、配置文件、命令行参数等）</span></span><br><span class="line"><span class="comment">// - 触发 listeners.environmentPrepared() 事件</span></span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br></pre></td></tr></table></figure>
<p>这一步，本质上是引导的延续，也可以算是引导的一环</p></li>
<li><p>接下来，就来到<code>contextPrepared</code>这一步，此时，<code>IoC 容器</code>（如
<code>AnnotationConfigApplicationContext</code> ）已创建并
“准备好”，但<strong>主配置类（<code>sources</code>，即
<code>@SpringBootApplication</code> 标注的类
）还未加载</strong>，容器内也没有任何 Bean。</p>
<p>在这里，框架会创建 <code>IoC 容器</code>
并触发此阶段，此时可以发现，容器是空的，但你可以通过
<code>context</code> 做预配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 创建应用上下文（IoC 容器）</span></span><br><span class="line"><span class="comment">// 根据应用类型（Web/非 Web）创建对应的 ApplicationContext</span></span><br><span class="line">context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line"><span class="comment">// 这里只是准备好了 IOC 容器</span></span><br></pre></td></tr></table></figure></li>
<li><p>之后，就来到<code>contextLoaded</code>这步了，加载主配置类，但
Bean 未实例化，此时<code>IoC 容器</code>
已加载<strong>主配置类</strong>（<code>@SpringBootApplication</code> 类
），解析其 <code>@Bean</code>、<code>@ComponentScan</code>
等注解，但<strong>容器未刷新</strong>（Bean 未实例化、依赖未注入
）里面没有组件，bean此时还没有创建。在这里，就是允许你加载额外的
<code>@Configuration</code> 类的时候了</p>
<p>继续追随 run
方法，可以看到在<code>createApplicationContext()</code>之后，有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一步，就是准备应用上下文，配置上下文环境、加载主配置类，触发 listeners.contextPrepared() 和 listeners.contextLoaded() 事件</span></span><br><span class="line"><span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure>
<p>追随<code>prepareContext</code>方法，继续阅读</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置之前准备好的 Environment 到应用上下文</span></span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用上下文后置处理（模板方法，子类可重写）</span></span><br><span class="line"><span class="comment">// 例如：ServletWebServerApplicationContext 会在此设置 Servlet 相关配置</span></span><br><span class="line"><span class="built_in">this</span>.postProcessApplicationContext(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 AOT（提前编译）生成的初始化器（如果适用）</span></span><br><span class="line"><span class="built_in">this</span>.addAotGeneratedInitializerIfNecessary(<span class="built_in">this</span>.initializers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用所有 ApplicationContextInitializer</span></span><br><span class="line"><span class="comment">// 允许第三方组件在容器刷新前自定义上下文（如注册属性源、添加 Bean 定义）</span></span><br><span class="line"><span class="built_in">this</span>.applyInitializers(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 contextPrepared 事件</span></span><br><span class="line"><span class="comment">// 此时容器已创建但尚未加载任何配置</span></span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 BootstrapContext（引导上下文）</span></span><br><span class="line"><span class="comment">// 标志引导阶段结束，后续使用正式的应用上下文</span></span><br><span class="line">bootstrapContext.close(context);</span><br></pre></td></tr></table></figure>
<p>这也就是为什么，<code>contextLoaded</code> 事件是 Spring Boot
启动流程中的<strong>配置扩展点</strong></p></li>
<li><p>接下来，就是对应<code>started</code>这步，此时<code>IoC 容器</code>
已刷新完成（所有 Bean
已实例化、依赖注入完成、<code>@PostConstruct</code> 等初始化方法已执行
），但
<strong><code>ApplicationRunner</code>/<code>CommandLineRunner</code>
还未执行</strong>。</p>
<p>继续追随 run
方法，可以发现ioc容器刷新了，bean都造好了，这里涉及到容器刷新12大步，我之前也讲过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6. 刷新应用上下文（核心启动逻辑）</span></span><br><span class="line"><span class="comment">// - 初始化 BeanFactory、加载所有 Bean 定义</span></span><br><span class="line"><span class="comment">// - 实例化单例 Bean、处理依赖注入</span></span><br><span class="line"><span class="comment">// - 触发各种 Bean 生命周期回调（@PostConstruct、InitializingBean 等）</span></span><br><span class="line"><span class="built_in">this</span>.refreshContext(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 刷新后的处理（模板方法）</span></span><br><span class="line"><span class="comment">// 子类可重写此方法，在容器刷新后执行自定义逻辑</span></span><br><span class="line"><span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 记录启动完成时间</span></span><br><span class="line">startup.started();</span><br><span class="line"><span class="comment">// 打印启动信息（如果启用）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.properties.isLogStartupInfo()) &#123;</span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass, environment)).logStarted(<span class="built_in">this</span>.getApplicationLog(), startup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 触发容器启动完成事件</span></span><br><span class="line"><span class="comment">// 调用 listeners.started()，通知所有监听器容器已启动</span></span><br><span class="line">listeners.started(context, startup.timeTakenToStarted());</span><br></pre></td></tr></table></figure></li>
<li><p>最后就是启动的终点，触发
<code>SpringApplicationRunListener</code> 的 <code>ready</code>
方法，执行 <code>ApplicationRunner</code>/<code>CommandLineRunner</code>
逻辑。这一步标志着：<strong>应用已完全就绪，可对外提供服务</strong>。</p>
<p>来到我们run 方法主要流程try块中的最后一行，我们会发现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10. 执行应用运行器和命令行运行器</span></span><br><span class="line"><span class="comment">// 调用所有实现 ApplicationRunner 或 CommandLineRunner 的 Bean</span></span><br><span class="line"><span class="comment">// 这是应用完全启动前的最后一步，常用于执行初始化任务</span></span><br><span class="line"><span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br></pre></td></tr></table></figure>
<p>这里面会调用<code>callRunners</code>方法，执行
<code>ApplicationRunner</code>/<code>CommandLineRunner</code>
逻辑，源码如下</p>
<p>在 <code>callRunners</code> 执行完毕后，Spring Boot 会触发
<code>SpringApplicationRunListener</code> 的 <code>ready</code>
方法，这标志着</p>
<ul>
<li>所有 Bean 已初始化</li>
<li>所有 <code>ApplicationRunner</code>/<code>CommandLineRunner</code>
已执行</li>
<li><strong>应用可以正式对外提供服务</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callRunners</span><span class="params">(ConfigurableApplicationContext context, ApplicationArguments args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">        String[] beanNames = beanFactory.getBeanNamesForType(Runner.class);</span><br><span class="line">        Map&lt;Runner, String&gt; instancesToBeanNames = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String beanName : beanNames) &#123;</span><br><span class="line">            instancesToBeanNames.put((Runner)beanFactory.getBean(beanName, Runner.class), beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Object&gt; comparator = <span class="built_in">this</span>.getOrderComparator(beanFactory).withSourceProvider(<span class="keyword">new</span> <span class="title class_">FactoryAwareOrderSourceProvider</span>(beanFactory, instancesToBeanNames));</span><br><span class="line">        instancesToBeanNames.keySet().stream().sorted(comparator).forEach((runner) -&gt; <span class="built_in">this</span>.callRunner(runner, args));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面的catch块，就是在 ready 返回的 context
中判断出现了什么样的异常，进行进一步的处理</p></li>
</ul>
<h4 id="运行">运行</h4>
<ul>
<li><p>之后，我们发现，就剩下一个方法没有被处理过，那就是在运行过程中发生异常（如
Bean 初始化失败、Runner 执行异常），Spring Boot 会触发
<code>failed</code> 事件</p>
<p>这里就是用到了 run 方法中那一大堆的 catch 块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (context.isRunning()) &#123;</span><br><span class="line">      listeners.ready(context, startup.ready());</span><br><span class="line">    &#125;  </span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">this</span>.handleRunFailure(context, ex, (SpringApplicationRunListeners)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而其中会有一个<code>handleRunFailure</code>专门处理
<code>failed</code> 事件异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RuntimeException <span class="title function_">handleRunFailure</span><span class="params">(ConfigurableApplicationContext context, Throwable exception, SpringApplicationRunListeners listeners)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AbandonedRunException abandonedRunException) &#123;</span><br><span class="line">            <span class="keyword">return</span> abandonedRunException;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.handleExitCode(context, exception);</span><br><span class="line">                     <span class="comment">// 触发 failed 事件</span></span><br><span class="line">                    <span class="keyword">if</span> (listeners != <span class="literal">null</span>) &#123;</span><br><span class="line">                        listeners.failed(context, exception);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.reportFailure(<span class="built_in">this</span>.getExceptionReporters(context), exception);</span><br><span class="line">                    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">                        context.close();</span><br><span class="line">                        shutdownHook.deregisterFailedApplicationContext(context);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unable to close ApplicationContext&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object var10000;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RuntimeException runtimeException) &#123;</span><br><span class="line">                var10000 = runtimeException;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var10000 = <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(exception);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (RuntimeException)var10000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结下来，整个流程就行如下图</p>
<figure>
<img src="/posts/54298/image-20250621151006134.png" alt="image-20250621151006134">
<figcaption aria-hidden="true">image-20250621151006134</figcaption>
</figure>
<h2 id="事件触发的时机">事件触发的时机</h2>
<h3 id="各种回调监听器">各种回调监听器</h3>
<p>Spring Boot 监听器（Listeners）基于 Spring Framework
的事件机制（<code>ApplicationEvent</code>和<code>ApplicationListener</code>），用于在应用生命周期或自定义事件触发时执行特定逻辑。它们提供了一种松耦合的方式响应应用状态变化，常用于初始化资源、监控应用状态、执行异步任务等。</p>
<p>而 Spring Boot 中存在很多事件回调监听器，这些监听器都是 Spring Boot
为了让开发者 <strong>“感知应用启动流程、插入自定义逻辑”</strong>
设计的扩展点，覆盖从 “最早期引导上下文” 到 “应用完全就绪”
的全生命周期，可按需选择对应监听器实现精细化控制。</p>
<p>简单说，这些监听器就像 Spring Boot 启动流程里的
“钩子”，从最早期的引导上下文，到容器初始化、事件驱动，再到应用就绪，不同阶段都有对应的扩展点。根据需求选对应的
“钩子”，就能精准在 Spring Boot
启动的各个环节插入自定义逻辑，实现如安全校验、配置修改、初始化加载等功能</p>
<h4 id="bootstrapregistryinitializer"><code>BootstrapRegistryInitializer</code></h4>
<ul>
<li><p><strong>感知阶段</strong>：引导上下文（<code>BootstrapContext</code>）初始化阶段</p></li>
<li><p><strong>触发时机</strong>：创建 <code>BootstrapContext</code>
时触发（启动最早期，比 <code>IoC</code> 容器创建还早 ），在进入 run
方法的时候就被创建</p>
<p>在run方法中有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext();</span><br></pre></td></tr></table></figure>
<figure>
<img src="/posts/54298/image-20250621154930427.png" alt="image-20250621154930427">
<figcaption aria-hidden="true">image-20250621154930427</figcaption>
</figure>
<figure>
<img src="/posts/54298/image-20250621152216366.png" alt="image-20250621152216366">
<figcaption aria-hidden="true">image-20250621152216366</figcaption>
</figure>
<p>可以发现，run方法进入以后，首先就调用了<code>BootstrapRegistryInitializer</code>中的<code>initialize</code>方法</p></li>
<li><p>使用方式</p>
<ul>
<li><p>配置：在 <code>META-INF/spring.factories</code> 里加
<code>org.springframework.boot.BootstrapRegistryInitializer=你的实现类</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">com.your.listener.MyApplicationListener</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">org.springframework.boot.BootstrapRegistryInitializer</span>=<span class="string">com.your.listener.MyBootstrapRegistryInitializer</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码：<code>application.addBootstrapRegistryInitializer(...)</code>
在启动主类中动态添加</p></li>
</ul></li>
<li><p><strong>典型场景</strong>：最早期的
“底层初始化”，比如<strong>密钥校验、授权初始化</strong>（需要在容器启动前完成的安全逻辑
）</p></li>
</ul>
<h4 id="applicationcontextinitializer"><code>ApplicationContextInitializer</code></h4>
<ul>
<li><p><strong>感知阶段</strong>：<code>IoC</code>
容器（<code>ApplicationContext</code>）初始化阶段（容器创建后，刷新前
）</p></li>
<li><p><strong>触发时机</strong>：<code>IoC</code>
容器准备好，但还没加载 Bean 定义、实例化 Bean
时触发，经过上文的分析，我们知道，<code>ApplicationContextInitializer</code>执行是在<code>contextPrepared</code>(ioc容器准备完成)之前，<code>environmentPrepared</code>(环境准备完成)之后</p>
<p>run 方法中，之后不断进入，就能知道其中什么时候调用了这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/posts/54298/image-20250621152629580.png" alt="image-20250621152629580">
<figcaption aria-hidden="true">image-20250621152629580</figcaption>
</figure>
<figure>
<img src="/posts/54298/image-20250621152641493.png" alt="image-20250621152641493">
<figcaption aria-hidden="true">image-20250621152641493</figcaption>
</figure></li>
<li><p>使用方式</p>
<ul>
<li>配置：<code>META-INF/spring.factories</code> 里加
<code>org.springframework.context.ApplicationContextInitializer=你的实现类</code></li>
<li>代码：<code>application.addInitializers(...)</code> 动态添加</li>
</ul></li>
<li><p><strong>典型场景</strong>：对 <code>IoC</code>
容器做预配置，比如<strong>修改环境变量、注册自定义 Bean
后处理器</strong>（影响容器后续加载流程 ）</p></li>
</ul>
<h4 id="applicationlistener"><code>ApplicationListener</code></h4>
<ul>
<li><p><strong>感知阶段</strong>：基于 Spring
事件机制，感知<strong>全流程事件</strong>（从应用启动到关闭的各种事件
）这也是为什么，我们要是重写监听器，一般都会实现这个接口，<strong>它是基于事件机制感知全阶段的，是感知事件用的，不能够去进行对应操作</strong>。类似于那种
AOP
的普通通知，而下面的<code>SpringApplicationRunListener</code>类似于环绕通知</p></li>
<li><p><strong>触发时机</strong>：对应事件发生时触发（如
<code>ApplicationStartingEvent</code>、<code>ContextRefreshedEvent</code>
等 ）</p></li>
<li><p>使用方式</p>
<ul>
<li><p>注解：<code>@Bean</code> 定义监听器 Bean，或用
<code>@EventListener</code>
标注方法（更简洁）这里涉及到后面的事件驱动开发，我这里就简单说一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 ApplicationListener，指定监听的事件类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppReadyListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// event.getTimestamp() 是事件触发时间（接近应用启动完成时间）</span></span><br><span class="line">        <span class="comment">// 可以结合启动开始时间，计算耗时（实际可通过上下文存启动开始时间）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;应用已完全就绪！启动耗时可在此计算...&quot;</span>);</span><br><span class="line">        <span class="comment">// 也能获取容器、环境等信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前环境：&quot;</span> + event.getApplicationContext().getEnvironment().getActiveProfiles()[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置类（或启动类 ）里，通过 <code>@Bean</code> 把监听器加入 Spring
容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyAppReadyListener <span class="title function_">myAppReadyListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAppReadyListener</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<p>无需显式实现 <code>ApplicationListener</code> 接口，直接在 Spring
管理的 Bean（如 <code>@Component</code> 类 ）里，用
<code>@EventListener</code> 标注方法，指定要监听的事件类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.EventListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 必须是 Spring 管理的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListenerBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标注 @EventListener，指定监听 ApplicationReadyEvent</span></span><br><span class="line">    <span class="meta">@EventListener(ApplicationReadyEvent.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAppReady</span><span class="params">(ApplicationReadyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过 @EventListener 监听到应用就绪事件！&quot;</span>);</span><br><span class="line">        <span class="comment">// 同样可操作容器、环境等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前激活配置：&quot;</span> + event.getApplicationContext().getEnvironment().getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置：启动类中添加<code>SpringApplication.addListeners(...)</code>
或 <code>spring.factories</code> 配置</p></li>
</ul></li>
<li><p><strong>典型场景</strong>：<strong>事件驱动的零散逻辑</strong>，比如监听应用启动完成发通知、监听
Bean 加载完成做缓存预热（灵活，可针对不同事件写逻辑 ）</p></li>
<li><p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----事件&quot;</span> + event + <span class="string">&quot;到达-------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，写到 META-INF 中</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  edu.software.ergoutree.springbootwebpart2.listener.MyApplicationListener</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​ 启动后发现，事件就被标注出来了</p>
<figure>
<img src="/posts/54298/image-20250621160339952.png" alt="image-20250621160339952">
<figcaption aria-hidden="true">image-20250621160339952</figcaption>
</figure>
<h4 id="springapplicationrunlistener"><code>SpringApplicationRunListener</code></h4>
<ul>
<li><strong>感知阶段</strong>：不仅能够感知应用启动<strong>全生命周期</strong>（从
<code>starting</code> 到 <code>ready</code>/<code>failed</code> 所有阶段
），而且还能进行各阶段的自定义操作</li>
<li><strong>触发时机</strong>：启动流程的每个关键节点（如环境准备、容器刷新、应用就绪等
）都会触发对应方法，这个在上面已经说的比较多了</li>
<li><strong>使用方式</strong>：<code>META-INF/spring.factories</code>
配置
<code>org.springframework.boot.SpringApplicationRunListener=你的实现类</code></li>
<li><strong>典型场景</strong>：<strong>深度干预启动流程</strong>，比如在每个阶段记录日志、统计启动耗时、自定义启动失败处理（功能最全面，覆盖所有阶段
）</li>
</ul>
<h4 id="applicationrunner-commandlinerunner"><code>ApplicationRunner</code>
&amp; <code>CommandLineRunner</code></h4>
<ul>
<li><p><strong>感知阶段</strong>：感知应用就绪，是应用<strong>就绪前最后一步</strong>（所有
Bean 加载完成，准备对外提供服务时
），也就是感知应用就绪<code>ready</code>这步，这些 Runner
的作用就是，在runner执行的前后都会发送探针事件</p></li>
<li><p><strong>触发时机</strong>：<code>IoC</code>
容器刷新完成，<code>ApplicationRunner</code> 先执行（参数是
<code>ApplicationArguments</code> ），<code>CommandLineRunner</code>
后执行（参数是原始命令行参数数组 ）</p>
<p>从 run 方法中的try块最后一行进入到started 方法来</p>
<figure>
<img src="/posts/54298/image-20250621162954409.png" alt="image-20250621162954409">
<figcaption aria-hidden="true">image-20250621162954409</figcaption>
</figure>
<p>进入 callRunner 方法，不断进入</p>
<figure>
<img src="/posts/54298/image-20250621163231548.png" alt="image-20250621163231548">
<figcaption aria-hidden="true">image-20250621163231548</figcaption>
</figure></li>
<li><p><strong>使用方式</strong>：定义实现类，用 <code>@Bean</code> 注入
Spring 容器</p></li>
<li><p><strong>典型场景</strong>：<strong>应用就绪前的初始化逻辑</strong>，比如加载基础数据、注册服务到注册中心；如果逻辑里抛异常，会<strong>阻断应用就绪</strong>（让应用启动失败，适合做
“启动前最后校验” ）</p></li>
</ul>
<h3 id="大事件">9大事件</h3>
<p>经过上述示例，我们实现了<code>ApplicationListene</code>接口，标注出了其中的事件，这些事件的内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----事件org.springframework.boot.context.event.ApplicationStartingEvent[source=org.springframework.boot.SpringApplication@<span class="number">5204062d</span>]到达-------</span><br><span class="line">====staring 正在启动===</span><br><span class="line">----事件org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent[source=org.springframework.boot.SpringApplication@<span class="number">5204062d</span>]到达-------</span><br><span class="line">====environmentPrepared 环境准备完成===</span><br><span class="line">----事件org.springframework.boot.context.event.ApplicationContextInitializedEvent[source=org.springframework.boot.SpringApplication@<span class="number">5204062d</span>]到达-------</span><br><span class="line">====contextPrepared IOC容器准备完成===</span><br><span class="line">----事件org.springframework.boot.context.event.ApplicationPreparedEvent[source=org.springframework.boot.SpringApplication@<span class="number">5204062d</span>]到达-------</span><br><span class="line">====contextPrepared IOC容器加载完成===</span><br><span class="line">----事件org.springframework.boot.web.servlet.context.ServletWebServerInitializedEvent[source=org.springframework.boot.web.embedded.tomcat.TomcatWebServer@56da8847]到达-------</span><br><span class="line">----事件org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@747f281, started on Sat Jun <span class="number">21</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">16</span> GMT+08:<span class="number">00</span> <span class="number">2025</span>]到达-------</span><br><span class="line">----事件org.springframework.boot.context.event.ApplicationStartedEvent[source=org.springframework.boot.SpringApplication@<span class="number">5204062d</span>]到达-------</span><br><span class="line">----事件org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@747f281, started on Sat Jun <span class="number">21</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">16</span> GMT+08:<span class="number">00</span> <span class="number">2025</span>]到达-------</span><br><span class="line">====started 启动完成===</span><br><span class="line">----事件org.springframework.boot.context.event.ApplicationReadyEvent[source=org.springframework.boot.SpringApplication@<span class="number">5204062d</span>]到达-------</span><br><span class="line">----事件org.springframework.boot.availability.AvailabilityChangeEvent[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@747f281, started on Sat Jun <span class="number">21</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">16</span> GMT+08:<span class="number">00</span> <span class="number">2025</span>]到达-------</span><br><span class="line">====ready 准备就绪===</span><br></pre></td></tr></table></figure>
<h4 id="applicationstartingevent"><code>ApplicationStartingEvent</code></h4>
<ul>
<li><strong>触发时机</strong>：应用启动最开始，仅完成
<code>listeners</code>（监听器 ）和 <code>initializers</code>（初始化器
）的注册，还未加载环境、创建容器。在进行任何处理之前发送（除了监听器和初始化器注册之外）。</li>
<li><strong>核心作用</strong>：标记
“应用启动的起点”，可在此做<strong>最早期初始化</strong>（如设置全局日志标识、初始化基础工具类
）。</li>
</ul>
<h4 id="applicationenvironmentpreparedevent"><code>ApplicationEnvironmentPreparedEvent</code></h4>
<ul>
<li><strong>触发时机</strong>：<code>Environment</code>（环境配置，包含配置文件、系统变量、命令行参数等
）准备完成，但 <code>IoC</code> 容器（<code>ApplicationContext</code>
）还未创建。</li>
<li><strong>核心作用</strong>：允许<strong>修改 /
校验环境配置</strong>，是干预应用配置的关键节点。</li>
<li><strong>实践场景</strong>：动态设置配置参数（如根据环境变量切换数据源地址
）；校验必要配置是否存在（如 <code>database.url</code> 未配置则抛异常
）。</li>
</ul>
<h4 id="applicationcontextinitializedevent"><code>ApplicationContextInitializedEvent</code></h4>
<ul>
<li><strong>触发时机</strong>：<code>IoC</code>
(<code>ApplicationContext</code>)容器创建完成，且
<code>ApplicationContextInitializers</code>（容器初始化器
）已调用，但<strong>没有加载任何 Bean
定义</strong>（主配置类、<code>@Bean</code> 等还未解析
）。此时，容器是空的</li>
<li><strong>核心作用</strong>：对空容器做<strong>预配置</strong>，影响后续
Bean 加载流程。</li>
<li><strong>实践场景</strong>：注册自定义
<code>BeanFactoryPostProcessor</code>（修改 Bean 定义的处理器
）；提前设置容器级别的属性（如资源加载器 ）。</li>
</ul>
<h4 id="applicationpreparedevent"><code>ApplicationPreparedEvent</code></h4>
<ul>
<li><strong>触发时机</strong>：容器刷新（<code>refresh</code>）之前，<strong>Bean
定义信息已加载</strong>（主配置类、<code>@ComponentScan</code> 扫描的
Bean、<code>@Bean</code> 等已解析为 Bean 定义 ），但 Bean
未实例化。此时，容器里面没有组件，bean此时还没有创建。</li>
<li><strong>核心作用</strong>：最后一次修改 Bean 定义的机会，可调整 Bean
的配置。</li>
<li><strong>实践场景</strong>：根据环境动态替换 Bean
定义（如开发环境用模拟 Bean，生产环境用真实 Bean ）；校验 Bean
定义的合法性（如某个 Bean 必须设置特定属性 ）。</li>
</ul>
<h4 id="contextrefreshedevent">ContextRefreshedEvent</h4>
<ul>
<li><strong>触发时机</strong>：Spring
<strong>应用上下文（<code>ApplicationContext</code>）完成刷新时触发</strong>。具体发生在：
<ol type="1">
<li><strong>容器初始化完成</strong>：所有 Bean
定义已加载、实例化、依赖注入完成，且执行了所有初始化回调（如
<code>@PostConstruct</code>、<code>InitializingBean</code>）。</li>
<li><strong>容器刷新操作结束</strong>：调用 <code>refresh()</code>
方法（包括应用启动时自动调用，或手动刷新）的最后阶段。</li>
<li><strong>可多次触发</strong>：对于支持热刷新的容器（如
<code>GenericApplicationContext</code>），每次刷新都会触发；但 Spring
Boot 默认容器通常只在启动时刷新一次。</li>
</ol></li>
<li><strong>核心作用</strong>：
<ul>
<li><strong>标记容器完全就绪</strong>：此时所有 Bean
已处于可用状态，可执行依赖于完整容器环境的操作。</li>
<li><strong>扩展容器功能</strong>：注册动态组件（如事件监听器、MBean）、启动后台任务、执行最终配置校验。</li>
</ul></li>
</ul>
<h4 id="applicationstartedevent"><code>ApplicationStartedEvent</code></h4>
<ul>
<li><strong>触发时机</strong>：容器刷新完成（所有 Bean
已实例化、依赖注入完成、<code>@PostConstruct</code> 等初始化方法执行完毕
），但
<strong><code>ApplicationRunner</code>/<code>CommandLineRunner</code>
未执行</strong>。</li>
<li><strong>核心作用</strong>：标记
“容器已就绪，但应用还未完全对外服务”，可做 Bean 初始化后的校验。</li>
<li><strong>实践场景</strong>：检查关键 Bean 的状态（如数据库连接 Bean
是否正常 ）；初始化业务资源（如缓存预热、定时任务注册 ）。</li>
</ul>
<h4 id="availabilitychangeeventlivenessstate.correct"><code>AvailabilityChangeEvent</code>（<code>LivenessState.CORRECT</code>）</h4>
<ul>
<li><strong>触发时机</strong>：应用存活状态变更为
“健康”（<code>LivenessState.CORRECT</code>
），一般在容器正常刷新后触发，属于<strong>存活探针</strong>。</li>
<li><strong>核心作用</strong>：告知监控系统
“应用进程还活着，基础功能正常”。</li>
<li><strong>实践场景</strong>：配合 Kubernetes
等平台的存活检测；自定义监控逻辑，标记应用存活状态。</li>
</ul>
<h4 id="applicationreadyevent"><code>ApplicationReadyEvent</code></h4>
<ul>
<li><strong>触发时机</strong>：所有
<code>ApplicationRunner</code>/<code>CommandLineRunner</code>
执行完毕，应用<strong>完全就绪</strong>，可对外提供服务。</li>
<li><strong>核心作用</strong>：标记
“应用已准备好处理外部请求”，是启动流程的关键终点。</li>
<li><strong>实践场景</strong>：发送应用就绪通知（如给运维平台、监控系统
）；记录完整启动耗时（从 <code>ApplicationStartingEvent</code> 到此时
）。</li>
</ul>
<h4 id="availabilitychangeeventreadinessstate.accepting_traffic"><code>AvailabilityChangeEvent</code>（<code>ReadinessState.ACCEPTING_TRAFFIC</code>）</h4>
<ul>
<li><strong>触发时机</strong>：应用就绪状态变更为
“可接收流量”（<code>ReadinessState.ACCEPTING_TRAFFIC</code> ），在
<code>ApplicationReadyEvent</code>
后触发，属于<strong>就绪探针</strong>。</li>
<li><strong>核心作用</strong>：告知外部系统
“应用不仅活着，还能处理请求”。</li>
<li><strong>实践场景</strong>：Kubernetes
等平台据此判断是否将流量转发到该实例；网关、负载均衡器感知应用状态。</li>
</ul>
<h4 id="applicationfailedevent"><code>ApplicationFailedEvent</code></h4>
<p><del>九大事件有十个怎么了</del></p>
<ul>
<li><strong>触发时机</strong>：启动过程中发生异常（如 Bean
初始化失败、Runner 执行报错 ），导致应用启动终止。</li>
<li><strong>核心作用</strong>：捕获启动异常，做兜底处理。</li>
<li><strong>实践场景</strong>：记录详细错误日志（便于排查问题
）；发送启动失败告警（邮件、短信通知运维 ）。</li>
</ul>
<h4 id="总结下来就是这张图">总结下来就是这张图</h4>
<figure>
<img src="/posts/54298/image-20250621155431009.png" alt="image-20250621155431009">
<figcaption aria-hidden="true">image-20250621155431009</figcaption>
</figure>
<pre><code class="highlight mermaid">flowchart TB
    %% 定义节点样式
    classDef eventStyle fill:#f9f,stroke:#333,stroke-width:1px,rx:5px,ry:5px;
    classDef listenerStyle fill:#b8e994,stroke:#333,stroke-width:1px,rx:5px,ry:5px;
    
    %% 应用事件流程
    A[&quot;ApplicationStartingEvent\n应用开始启动&quot;]:::eventStyle --&gt; B[&quot;prepareEnvironment\n准备环境&quot;]
    B --&gt; C[&quot;ApplicationEnvironmentPreparedEvent\n环境准备完成&quot;]:::eventStyle
    C --&gt; D[&quot;prepareContext\n初始化容器&quot;]
    D --&gt; E[&quot;ApplicationContextInitializedEvent\nInitializer 调用&quot;]:::eventStyle
    D --&gt; F[&quot;ApplicationPreparedEvent\n应用准备完成&quot;]:::eventStyle
    F --&gt; G[&quot;refreshContext 之后\n容器刷新完成&quot;]
    G --&gt; H[&quot;ApplicationStartedEvent\nstarted 阶段&quot;]:::eventStyle
    G --&gt; I[&quot;AvailabilityChangeEvent\n(LivenessState.CORRECT)\n可用探针&quot;]:::eventStyle
    H --&gt; J[&quot;callRunners\n调用所有 runner&quot;]
    J --&gt; K[&quot;ApplicationReadyEvent\n应用运行完成&quot;]:::eventStyle
    J --&gt; L[&quot;AvailabilityChangeEvent\n(ReadinessState.ACCEPTING_TRAFFIC)\n就绪探针&quot;]:::eventStyle
    
    %% 异常分支
    B --&gt; M[&quot;所有异常、进行捕获&quot;]
    D --&gt; M
    F --&gt; M
    G --&gt; M
    H --&gt; M
    J --&gt; M
    M --&gt; N[&quot;ApplicationFailedEvent\n应用失败&quot;]:::eventStyle
    
    %% 监听器运行流程
    O[&quot;listeners.starting&quot;]:::listenerStyle --&gt; P[&quot;listeners.environmentPrepared&quot;]:::listenerStyle
    P --&gt; Q[&quot;listeners.contextPrepared&quot;]:::listenerStyle
    Q --&gt; R[&quot;listeners.contextLoaded&quot;]:::listenerStyle
    R --&gt; S[&quot;listeners.started&quot;]:::listenerStyle
    S --&gt; T[&quot;callRunners\n调用所有 runner&quot;]
    T --&gt; U[&quot;listeners.ready&quot;]:::listenerStyle
    
    %% 异常时监听器执行
    M --&gt; V[&quot;listeners.failed&quot;]:::listenerStyle</code></pre>
<figure>
<img src="/posts/54298/image-20250621162125240.png" alt="image-20250621162125240">
<figcaption aria-hidden="true">image-20250621162125240</figcaption>
</figure>
<figure>
<img src="/posts/54298/image-20250621162216083.png" alt="image-20250621162216083">
<figcaption aria-hidden="true">image-20250621162216083</figcaption>
</figure>
<pre><code class="highlight mermaid">sequenceDiagram
    title Spring Boot 启动事件时序
    participant 应用 as 应用启动入口
    participant 事件1 as ApplicationStartingEvent
    participant 事件2 as ApplicationEnvironmentPreparedEvent
    participant 事件3 as ApplicationContextInitializedEvent
    participant 事件4 as ApplicationPreparedEvent
    participant 事件5 as ApplicationStartedEvent
    participant 事件6 as AvailabilityChangeEvent(Liveness)
    participant 事件7 as ApplicationReadyEvent
    participant 事件8 as AvailabilityChangeEvent(Readiness)
    participant 事件9 as ApplicationFailedEvent
    
    应用-&gt;&gt;事件1: 启动开始，仅注册监听器/初始化器
    事件1-&gt;&gt;事件2: 环境准备完成（配置加载）
    事件2-&gt;&gt;事件3: IoC容器创建，未加载Bean
    事件3-&gt;&gt;事件4: Bean定义加载完成，未实例化
    事件4-&gt;&gt;事件5: 容器刷新完成，Bean初始化完成
    事件5-&gt;&gt;事件6: 标记应用存活
    事件6-&gt;&gt;事件7: Runner执行完毕，应用就绪
    事件7-&gt;&gt;事件8: 标记应用可接收流量
    应用-&gt;&gt;事件9: 启动异常时触发</code></pre>
<p>哪个看得懂看哪个</p>
<h3 id="实践总结">实践总结</h3>
<ul>
<li><p>项目启动<strong>前</strong>做事 →
<code>BootstrapRegistryInitializer</code> +
<code>ApplicationContextInitializer</code></p>
<ul>
<li><p><strong>核心需求</strong>：在应用启动最早期（容器创建前、Bean
加载前 ）执行逻辑。</p></li>
<li><p><strong><code>BootstrapRegistryInitializer</code></strong>：</p>
<ul>
<li><p>触发时机：<strong>引导上下文（<code>BootstrapContext</code>）创建时</strong>（比
<code>IoC</code> 容器还早 ）。</p></li>
<li><p>典型场景：最底层的初始化（如<strong>密钥校验、授权认证</strong>，需要在容器启动前完成
）。</p></li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBootstrapInitializer</span> <span class="keyword">implements</span> <span class="title class_">BootstrapRegistryInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(BootstrapRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动前校验：比如检查 License 文件是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!checkLicense()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;License 无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 META-INF/spring.factories 配置：</span></span><br><span class="line"><span class="comment">// org.springframework.boot.BootstrapRegistryInitializer=com.example.MyBootstrapInitializer</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong><code>ApplicationContextInitializer</code></strong>：</p>
<ul>
<li><p>触发时机：<strong><code>IoC</code> 容器创建后，但 Bean
未加载时</strong>（可修改容器环境、预配置 ）。</p></li>
<li><p>典型场景：动态修改配置（如根据环境变量切换数据源 ）、注册 Bean
后处理器。</p></li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 修改环境变量：生产环境启用调试模式</span></span><br><span class="line">        <span class="keyword">if</span> (context.getEnvironment().getActiveProfiles()[<span class="number">0</span>].equals(<span class="string">&quot;prod&quot;</span>)) &#123;</span><br><span class="line">            context.getEnvironment().setActiveProfiles(<span class="string">&quot;prod&quot;</span>, <span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 META-INF/spring.factories 配置：</span></span><br><span class="line"><span class="comment">// org.springframework.context.ApplicationContextInitializer=com.example.MyContextInitializer</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>项目启动<strong>完成后</strong>做事 →
<code>ApplicationRunner</code> + <code>CommandLineRunner</code></p>
<ul>
<li><strong>核心需求</strong>：应用完全就绪（所有 Bean
加载完成、容器刷新完成 ）后，执行初始化逻辑。</li>
<li><strong><code>ApplicationRunner</code></strong>：
<ul>
<li>触发时机：应用就绪后，<strong>接收
<code>ApplicationArguments</code>（封装命令行参数 ）</strong>。</li>
<li>典型场景：需要解析命令行参数的初始化（如根据
<code>--import-data</code> 参数加载数据 ）。</li>
</ul></li>
<li><strong><code>CommandLineRunner</code></strong>：
<ul>
<li>触发时机：应用就绪后，<strong>接收原始命令行参数数组</strong>（更简单直接
）。</li>
<li>典型场景：无需复杂参数解析的初始化（如打印启动完成日志、注册服务
）。</li>
</ul></li>
</ul></li>
<li><p>干涉<strong>生命周期</strong>做事 →
<code>SpringApplicationRunListener</code></p>
<ul>
<li><strong>核心需求</strong>：深度控制启动流程，在每个生命周期阶段（如环境准备、容器刷新、应用就绪
）插入逻辑。</li>
</ul></li>
<li><p>用<strong>事件机制</strong>做事 →
<code>ApplicationListener</code></p>
<ul>
<li><strong>核心需求</strong>：通过事件驱动，灵活响应特定阶段（如应用启动、Bean
加载完成 ）。</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 23%">
<col style="width: 39%">
</colgroup>
<thead>
<tr>
<th>需求场景</th>
<th>推荐工具</th>
<th>核心优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动<strong>前</strong>最早期初始化（容器创建前 ）</td>
<td><code>BootstrapRegistryInitializer</code></td>
<td>干预引导上下文，做底层校验（如 License ）</td>
</tr>
<tr>
<td>启动<strong>前</strong>容器级初始化（容器创建后，Bean 加载前 ）</td>
<td><code>ApplicationContextInitializer</code></td>
<td>修改环境、预配置容器（如动态切换数据源 ）</td>
</tr>
<tr>
<td>启动<strong>后</strong>业务初始化（需解析命令行参数 ）</td>
<td><code>ApplicationRunner</code></td>
<td>支持复杂参数解析（如 <code>--import-data</code> ）</td>
</tr>
<tr>
<td>启动<strong>后</strong>简单初始化（无需参数解析 ）</td>
<td><code>CommandLineRunner</code></td>
<td>代码简洁，直接执行逻辑（如注册服务 ）</td>
</tr>
<tr>
<td>深度干预生命周期（每个阶段精细控制 ）</td>
<td><code>SpringApplicationRunListener</code></td>
<td>覆盖全生命周期，统计耗时、自定义失败处理</td>
</tr>
<tr>
<td>事件驱动响应（灵活监听任意阶段 ）</td>
<td><code>ApplicationListener</code></td>
<td>解耦逻辑，通过事件触发（如应用就绪、Bean 加载完成 ）</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/ergou10086">ErgouTree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ergou10086.github.io/posts/54298.html">https://ergou10086.github.io/posts/54298.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ergou10086.github.io" target="_blank">ErgouTree's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E6%8A%80%E6%9C%AF/">Java技术</a><a class="post-meta__tags" href="/tags/JavaWeb/">JavaWeb</a><a class="post-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86/">框架知识</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/JavaEE/">JavaEE</a><a class="post-meta__tags" href="/tags/Spring%E7%B3%BB%E5%88%97/">Spring系列</a><a class="post-meta__tags" href="/tags/Spring-Boot/">Spring Boot</a><a class="post-meta__tags" href="/tags/Java%E6%A1%86%E6%9E%B6/">Java框架</a><a class="post-meta__tags" href="/tags/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/">配置相关</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><a class="post-meta__tags" href="/tags/JUnit/">JUnit</a></div><div class="post-share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_facebook_messenger"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/22150.html" title="Spring Boot part18-整合JUnit5进行测试"><img class="cover" src="/images/posts/cover_java11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Spring Boot part18-整合JUnit5进行测试</div></div><div class="info-2"><div class="info-item-1">Spring Boot 整合 JUnit5 进行单元测试 SpringBoot 提供⼀系列测试⼯具集及注解⽅便我们进⾏测试。 Spring Test 与 JUnit等其他测试框架结合起来，提供了便捷高效的测试手段。而 Spring Boot Test 是在 Spring Test 之上的再次封装，增加了切片测试，增强了 mock 能力。 spring-boot-test提供核⼼测试能⼒，spring-boot-test-autoconfigure提供测试的⼀些⾃动配置 我们只需要导⼊ spring-boot-starter-test 即可整合测试 12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Spring...</div></div></div></a><a class="pagination-related" href="/posts/10821.html" title="Spring Boot part20-事件驱动开发"><img class="cover" src="/images/posts/cover_wish.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Spring Boot part20-事件驱动开发</div></div><div class="info-2"><div class="info-item-1">事件驱动开发 简介 在现代应用程序开发中，事件驱动架构（EDA）越来越受欢迎。它不仅可以提高系统的解耦性，还能提升系统的可扩展性和响应速度。Spring Boot 中的事件驱动开发是一种解耦业务逻辑的设计模式，核心思想是：通过 “事件发布 - 监听” 机制，让不同组件在不直接依赖的情况下协作。 事件驱动开发是一种软件架构模式，系统通过事件来进行通信和协调。事件可以是系统中发生的任何有意义的事情，如用户点击按钮、数据更新等。事件驱动架构的核心思想是将事件的发布者和事件的处理者解耦，通过事件总线来传递事件。这样可以使得系统更加灵活，易于扩展和维护。 Spring Boot中的事件模型基于 Spring Framework 的 ApplicationEvent 和 ApplicationListener。ApplicationEvent 是所有事件的基类，ApplicationListener 是所有事件监听器的接口。我们可以自定义事件并发布，自定义监听器来处理这些事件。 简单说，事件驱动开发是用 “事件” 作为业务流程的 “粘合剂”，让不同组件在...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8200.html" title="Spring Boot part13-全面接管Spring MVC"><img class="cover" src="/images/posts/cover_java15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-11</div><div class="info-item-2">Spring Boot part13-全面接管Spring MVC</div></div><div class="info-2"><div class="info-item-1">全面接管 SpringMVC 的思路 SpringBoot 默认配置好了 SpringMVC 的所有常⽤特性。 在 SpringBoot 中，全面接管 SpringMVC 配置的思路是通过禁用默认配置并完全自定义所有 MVC 行为。这是一个高级用法，适用于需要对 SpringMVC 进行深度定制的场景。 全面接管 SpringMVC 的核心步骤如下：  创建一个配置类，实现WebMvcConfigurer接口 使用@EnableWebMvc注解禁用 SpringBoot 的默认 MVC 配置 重写WebMvcConfigurer接口中的方法来定义所有需要的 MVC 行为，WebMvcConfigurer组件定义MVC的底层行为  回忆一下配置类的三种自定义方式          全自动 直接编写控制器逻辑  全部使用自动配置默认效果     手自一体 @Configuration + 配置 WebMvcConfigurer + 配置...</div></div></div></a><a class="pagination-related" href="/posts/6874.html" title="Spring Boot part12-嵌入式容器"><img class="cover" src="/images/posts/cover_main.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-11</div><div class="info-item-2">Spring Boot part12-嵌入式容器</div></div><div class="info-2"><div class="info-item-1">前言 Spring Boot 的目标是构建“非常容易创建、独立、产品级别的基于Spring的应用”。这些应用是“立即可运行的”。在这个过程中，完全没有代码生成，不需要配置任何特殊的XML配置，为了这个目标，Spring Boot 在 Spring 4.0 框架之上提供了很多特性，帮助应用以“约定优于配置”“开箱即用”的方式来启动应用并运行上下文。 Spring Boot 同样改变了一个传统的 Web 应用服务的启动流程和部署方式。通过自动配置机制，Spring Boot 提供了一个嵌入式的运行时容器环境，并使用代码注解的方式在代码中将 URL 服务地址映射到 Controller 的方法完成服务映射。 所以，开发者不再需要关心传统容器（如 Tomcat）中web.xml的配置，同时实现容器的具体技术都是可替换及可更改的，这些技术以插件化的Starter组件方式在运行时加载到 Spring...</div></div></div></a><a class="pagination-related" href="/posts/22150.html" title="Spring Boot part18-整合JUnit5进行测试"><img class="cover" src="/images/posts/cover_java11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-21</div><div class="info-item-2">Spring Boot part18-整合JUnit5进行测试</div></div><div class="info-2"><div class="info-item-1">Spring Boot 整合 JUnit5 进行单元测试 SpringBoot 提供⼀系列测试⼯具集及注解⽅便我们进⾏测试。 Spring Test 与 JUnit等其他测试框架结合起来，提供了便捷高效的测试手段。而 Spring Boot Test 是在 Spring Test 之上的再次封装，增加了切片测试，增强了 mock 能力。 spring-boot-test提供核⼼测试能⼒，spring-boot-test-autoconfigure提供测试的⼀些⾃动配置 我们只需要导⼊ spring-boot-starter-test 即可整合测试 12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Spring...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/arp.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ErgouTree</div><div class="author-info-description">I start a brand-new life with you.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ergou10086"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ergou10086" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/zjm88822201@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/142045656?spm_id_from=333.1007.0.0" target="_blank" title="bilibili"><i class="fas fa-brands fa-bilibili" style="color: #4a72be;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">作者长期陷入galgame和osu!maina4k中 祝他好运吧 对了 如果图片加载过慢 建议科学上网进行使用</div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E5%90%AC"><span class="toc-number">2.</span> <span class="toc-text">生命周期监听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89springapplicationrunlistener%E6%9D%A5%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">自定义SpringApplicationRunListener来监听事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">项目启动的生命周期流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC"><span class="toc-number">2.2.1.</span> <span class="toc-text">引导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-number">2.2.3.</span> <span class="toc-text">运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.</span> <span class="toc-text">事件触发的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%9B%9E%E8%B0%83%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">各种回调监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bootstrapregistryinitializer"><span class="toc-number">3.1.1.</span> <span class="toc-text">BootstrapRegistryInitializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationcontextinitializer"><span class="toc-number">3.1.2.</span> <span class="toc-text">ApplicationContextInitializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationlistener"><span class="toc-number">3.1.3.</span> <span class="toc-text">ApplicationListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springapplicationrunlistener"><span class="toc-number">3.1.4.</span> <span class="toc-text">SpringApplicationRunListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationrunner-commandlinerunner"><span class="toc-number">3.1.5.</span> <span class="toc-text">ApplicationRunner
&amp; CommandLineRunner</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">9大事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationstartingevent"><span class="toc-number">3.2.1.</span> <span class="toc-text">ApplicationStartingEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationenvironmentpreparedevent"><span class="toc-number">3.2.2.</span> <span class="toc-text">ApplicationEnvironmentPreparedEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationcontextinitializedevent"><span class="toc-number">3.2.3.</span> <span class="toc-text">ApplicationContextInitializedEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationpreparedevent"><span class="toc-number">3.2.4.</span> <span class="toc-text">ApplicationPreparedEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contextrefreshedevent"><span class="toc-number">3.2.5.</span> <span class="toc-text">ContextRefreshedEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationstartedevent"><span class="toc-number">3.2.6.</span> <span class="toc-text">ApplicationStartedEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#availabilitychangeeventlivenessstate.correct"><span class="toc-number">3.2.7.</span> <span class="toc-text">AvailabilityChangeEvent（LivenessState.CORRECT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationreadyevent"><span class="toc-number">3.2.8.</span> <span class="toc-text">ApplicationReadyEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#availabilitychangeeventreadinessstate.accepting_traffic"><span class="toc-number">3.2.9.</span> <span class="toc-text">AvailabilityChangeEvent（ReadinessState.ACCEPTING_TRAFFIC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applicationfailedevent"><span class="toc-number">3.2.10.</span> <span class="toc-text">ApplicationFailedEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8B%E6%9D%A5%E5%B0%B1%E6%98%AF%E8%BF%99%E5%BC%A0%E5%9B%BE"><span class="toc-number">3.2.11.</span> <span class="toc-text">总结下来就是这张图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">实践总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/58992.html" title="理解JavaLambda表达式的使用"><img src="/images/posts/cover_database2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理解JavaLambda表达式的使用"/></a><div class="content"><a class="title" href="/posts/58992.html" title="理解JavaLambda表达式的使用">理解JavaLambda表达式的使用</a><time datetime="2025-07-03T02:25:28.000Z" title="发表于 2025-07-03 10:25:28">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/14594.html" title="Java枚举类型及其深入理解"><img src="/images/posts/cover_docker2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java枚举类型及其深入理解"/></a><div class="content"><a class="title" href="/posts/14594.html" title="Java枚举类型及其深入理解">Java枚举类型及其深入理解</a><time datetime="2025-07-03T02:06:05.000Z" title="发表于 2025-07-03 10:06:05">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4240.html" title="概率论与数理统计部分习题选做"><img src="/images/posts/cover_7x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="概率论与数理统计部分习题选做"/></a><div class="content"><a class="title" href="/posts/4240.html" title="概率论与数理统计部分习题选做">概率论与数理统计部分习题选做</a><time datetime="2025-06-29T12:55:34.000Z" title="发表于 2025-06-29 20:55:34">2025-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/44212.html" title="魔女恋爱日记攻略"><div style="background: /images/posts/"></div></a><div class="content"><a class="title" href="/posts/44212.html" title="魔女恋爱日记攻略">魔女恋爱日记攻略</a><time datetime="2025-06-28T04:36:07.000Z" title="发表于 2025-06-28 12:36:07">2025-06-28</time></div></div></div></div></div></div></main><div class="fps-display"><span id="fps">FPS: 60</span></div><footer id="footer" style="background-image: url(/images/posts/cover_java8.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By ErgouTree</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">忘れたくない思い、ありますか？ <br>,<span id="realtime_duration" style="font-family: monospace;"></span>,<br><a href="https://icp.gov.moe/?keyword=20257009" target="_blank">萌ICP备20257009号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="日间和夜间模式切换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-comment"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script><script>(function() {
  const abcjsInit = function() {
    const abcjsFn = function() {
      setTimeout(function() {
        const sheets = document.querySelectorAll(".abc-music-sheet")
        for (let i = 0; i < sheets.length; i++) {
          const ele = sheets[i]
          if (ele.children.length > 0) continue

          // Parse parameters from data-params attribute
          let params = {}
          const dp = ele.getAttribute("data-params")
          if (dp) {
            try {
              params = JSON.parse(dp)
            } catch (e) {
              console.error("Failed to parse data-params:", e)
            }
          }

          // Merge parsed parameters with the responsive option
          // Ensures params content appears before responsive
          const options = { ...params, responsive: "resize" }

          // Render the music score using ABCJS.renderAbc
          ABCJS.renderAbc(ele, ele.innerHTML, options)
        }
      }, 100)
    }

    if (typeof ABCJS === "object") {
      abcjsFn()
    } else {
      btf.getScript("https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js").then(abcjsFn)
    }
  }

  if (window.pjax) {
    abcjsInit()
  } else {
    window.addEventListener("load", abcjsInit)
  }

  btf.addGlobalFn("encrypt", abcjsInit, "abcjs")
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"labels":["Gitalk","Comment"],"createIssueManually":false,"distractionFreeMode":false}

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li3vDQANiUddL4XB',
      clientSecret: '5c9a56d02995340fca117809cd414662aadce6ff',
      repo: 'HexoComment',
      owner: 'ergou10086',
      admin: ['ergou10086'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '83c52c9fdf23a759850171ed51be2e3c'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="13587761608" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><script src="https://cdn.jsdelivr.net/npm/abcjs@7.1.2/dist/abcjs-basic-min.js"></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/plugin/duration.min.js"></script><script src="/scripts/realtime.js"></script><script src="/scripts/random.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="null" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  window.ChatraID = '4bzb546NSBoJcrNyu'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script src="/js/fps-display.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7844.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_database.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7844.html&quot;);" href="javascript:void(0);" alt="">结构化查询语言SQL</a><div class="blog-slider__text">SQL基本很常用的语句都在这里了，本质上是当初为了应付数据库考试整理的，后来发现还蛮有用的很方便查常用的语句</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7844.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/39918.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_java4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/39918.html&quot;);" href="javascript:void(0);" alt="">SpringBoot part0?INF-SpringBoot这个框架都需要学习什么</a><div class="blog-slider__text">主要围绕Spring Boot中重要知识来简洁或详细的说明，其中部分不够完全，持续更新</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/39918.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/42179.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_java11.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/42179.html&quot;);" href="javascript:void(0);" alt="">关于Lombok在高版本IDEA中注解处理不生效的问题解决</a><div class="blog-slider__text">基本上是彻底的解决了用 IDEA 新建 Spring Boot 项目时候会产生的 Lombok 注解处理失效的各种问题</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/42179.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/40344.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_实用.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/40344.html&quot;);" href="javascript:void(0);" alt="">个人向galgame原声带或相关音乐整理及其资源</a><div class="blog-slider__text">整理了我喜欢的galgame ost或者衍生的音乐专辑，部分资源是自己扒盘扒下来的，部分来自鸟白岛放映厅</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/40344.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6458.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_math.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6458.html&quot;);" href="javascript:void(0);" alt="">对书上证明样本方差是总体方差的无偏估计量的解析</a><div class="blog-slider__text">对书上证明样本方差是总体方差的无偏估计量的解析，高等教育出版社-华科大版本</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6458.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/12811.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_alog.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/12811.html&quot;);" href="javascript:void(0);" alt="">第十五届蓝桥杯Java国赛B组D题-园丁题解</a><div class="blog-slider__text">第十五届蓝桥杯Java国赛B组D题-园丁题解，该题解已经发布到洛谷社区中并且被全站推荐</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/12811.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27893.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_java4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-04-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27893.html&quot;);" href="javascript:void(0);" alt="">操作系统之处理机的死锁部分概述</a><div class="blog-slider__text">对操作系统之处理机的死锁部分知识的总结，包括代码复现</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27893.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/28134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_lb.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/28134.html&quot;);" href="javascript:void(0);" alt="">Little Busters!EX游戏攻略</a><div class="blog-slider__text">整理了一份详细清晰的Little Busters！EX的游戏攻略，因为我自己也在推，就顺手整理了一份方便查阅的md文档</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/28134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9323.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/images/posts/cover_java9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9323.html&quot;);" href="javascript:void(0);" alt="">Spring Boot中使用Hibernate框架</a><div class="blog-slider__text">对学习完Hibernate的应用部分，主要围绕Spring Boot中使用Hibernate框架，建议学习完 Hibernate 框架再看</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9323.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>